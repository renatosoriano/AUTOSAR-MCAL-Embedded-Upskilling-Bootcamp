
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000b27 	.word	0x00000b27
  10:	00000b29 	.word	0x00000b29
  14:	00000b2b 	.word	0x00000b2b
  18:	00000b2d 	.word	0x00000b2d
	...
  2c:	00000b2f 	.word	0x00000b2f
  30:	00000b31 	.word	0x00000b31
  34:	00000000 	.word	0x00000000
  38:	00000b33 	.word	0x00000b33
  3c:	00000b35 	.word	0x00000b35
  40:	00000b37 	.word	0x00000b37
  44:	00000b37 	.word	0x00000b37
  48:	00000b37 	.word	0x00000b37
  4c:	00000b37 	.word	0x00000b37
  50:	00000b37 	.word	0x00000b37
  54:	00000b37 	.word	0x00000b37
  58:	00000b37 	.word	0x00000b37
  5c:	00000b37 	.word	0x00000b37
  60:	00000b37 	.word	0x00000b37
  64:	00000b37 	.word	0x00000b37
  68:	00000b37 	.word	0x00000b37
  6c:	00000b37 	.word	0x00000b37
  70:	00000b37 	.word	0x00000b37
  74:	00000b37 	.word	0x00000b37
  78:	00000b37 	.word	0x00000b37
  7c:	00000b37 	.word	0x00000b37
  80:	00000b37 	.word	0x00000b37
  84:	00000b37 	.word	0x00000b37
  88:	00000b37 	.word	0x00000b37
  8c:	00000b37 	.word	0x00000b37
  90:	00000b37 	.word	0x00000b37
  94:	00000b37 	.word	0x00000b37
  98:	00000b37 	.word	0x00000b37
  9c:	00000b37 	.word	0x00000b37
  a0:	00000b37 	.word	0x00000b37
  a4:	00000b37 	.word	0x00000b37
  a8:	00000b37 	.word	0x00000b37
  ac:	00000b37 	.word	0x00000b37
  b0:	00000b37 	.word	0x00000b37
  b4:	00000b37 	.word	0x00000b37
  b8:	00000b37 	.word	0x00000b37
  bc:	00000b37 	.word	0x00000b37
  c0:	00000b37 	.word	0x00000b37
  c4:	00000b37 	.word	0x00000b37
  c8:	00000b37 	.word	0x00000b37
  cc:	00000b37 	.word	0x00000b37
  d0:	00000b37 	.word	0x00000b37
  d4:	00000b37 	.word	0x00000b37
  d8:	00000b37 	.word	0x00000b37
  dc:	00000b37 	.word	0x00000b37
  e0:	00000b37 	.word	0x00000b37
  e4:	00000b37 	.word	0x00000b37
  e8:	00000b37 	.word	0x00000b37
  ec:	00000b37 	.word	0x00000b37
  f0:	00000b37 	.word	0x00000b37
  f4:	00000b37 	.word	0x00000b37
  f8:	00000b37 	.word	0x00000b37
  fc:	00000b37 	.word	0x00000b37
 100:	00000b37 	.word	0x00000b37
 104:	00000b37 	.word	0x00000b37
 108:	00000b37 	.word	0x00000b37
 10c:	00000b37 	.word	0x00000b37
 110:	00000b37 	.word	0x00000b37
 114:	00000b37 	.word	0x00000b37
 118:	00000b37 	.word	0x00000b37
 11c:	00000b37 	.word	0x00000b37
 120:	00000b37 	.word	0x00000b37
 124:	00000b37 	.word	0x00000b37
 128:	00000b37 	.word	0x00000b37
 12c:	00000b37 	.word	0x00000b37
 130:	00000b37 	.word	0x00000b37
 134:	00000b37 	.word	0x00000b37
 138:	00000b37 	.word	0x00000b37
 13c:	00000b37 	.word	0x00000b37
 140:	00000b37 	.word	0x00000b37
 144:	00000b37 	.word	0x00000b37
 148:	00000b37 	.word	0x00000b37
 14c:	00000b37 	.word	0x00000b37
 150:	00000b37 	.word	0x00000b37
 154:	00000b37 	.word	0x00000b37
 158:	00000b37 	.word	0x00000b37
 15c:	00000b37 	.word	0x00000b37
 160:	00000b37 	.word	0x00000b37
 164:	00000b37 	.word	0x00000b37
 168:	00000b37 	.word	0x00000b37
 16c:	00000b37 	.word	0x00000b37
 170:	00000b37 	.word	0x00000b37
 174:	00000b37 	.word	0x00000b37
 178:	00000b37 	.word	0x00000b37
 17c:	00000b37 	.word	0x00000b37
 180:	00000b37 	.word	0x00000b37
 184:	00000b37 	.word	0x00000b37
 188:	00000b37 	.word	0x00000b37
 18c:	00000b37 	.word	0x00000b37
 190:	00000b37 	.word	0x00000b37
 194:	00000b37 	.word	0x00000b37
 198:	00000b37 	.word	0x00000b37
 19c:	00000b37 	.word	0x00000b37
 1a0:	00000b37 	.word	0x00000b37
 1a4:	00000b37 	.word	0x00000b37
 1a8:	00000b37 	.word	0x00000b37
 1ac:	00000b37 	.word	0x00000b37
 1b0:	00000b37 	.word	0x00000b37
 1b4:	00000b37 	.word	0x00000b37
 1b8:	00000b37 	.word	0x00000b37
 1bc:	00000b37 	.word	0x00000b37
 1c0:	00000b37 	.word	0x00000b37
 1c4:	00000b37 	.word	0x00000b37
 1c8:	00000b37 	.word	0x00000b37
 1cc:	00000b37 	.word	0x00000b37
 1d0:	00000b37 	.word	0x00000b37
 1d4:	00000b37 	.word	0x00000b37
 1d8:	00000b37 	.word	0x00000b37
 1dc:	00000b37 	.word	0x00000b37
 1e0:	00000b37 	.word	0x00000b37
 1e4:	00000b37 	.word	0x00000b37
 1e8:	00000b37 	.word	0x00000b37
 1ec:	00000b37 	.word	0x00000b37
 1f0:	00000b37 	.word	0x00000b37
 1f4:	00000b37 	.word	0x00000b37
 1f8:	00000b37 	.word	0x00000b37
 1fc:	00000b37 	.word	0x00000b37
 200:	00000b37 	.word	0x00000b37
 204:	00000b37 	.word	0x00000b37
 208:	00000b37 	.word	0x00000b37
 20c:	00000b37 	.word	0x00000b37
 210:	00000b37 	.word	0x00000b37
 214:	00000b37 	.word	0x00000b37
 218:	00000b37 	.word	0x00000b37
 21c:	00000b37 	.word	0x00000b37
 220:	00000b37 	.word	0x00000b37
 224:	00000b37 	.word	0x00000b37
 228:	00000b37 	.word	0x00000b37
 22c:	00000b37 	.word	0x00000b37
 230:	00000b37 	.word	0x00000b37
 234:	00000b37 	.word	0x00000b37
 238:	00000b37 	.word	0x00000b37
 23c:	00000b37 	.word	0x00000b37
 240:	00000b37 	.word	0x00000b37
 244:	00000b37 	.word	0x00000b37
 248:	00000b37 	.word	0x00000b37
 24c:	00000b37 	.word	0x00000b37
 250:	00000b37 	.word	0x00000b37
 254:	00000b37 	.word	0x00000b37
 258:	00000b37 	.word	0x00000b37
 25c:	00000b37 	.word	0x00000b37
 260:	00000b37 	.word	0x00000b37
 264:	00000b37 	.word	0x00000b37
 268:	00000b37 	.word	0x00000b37
 26c:	00000b37 	.word	0x00000b37
 270:	00000b37 	.word	0x00000b37
 274:	00000b37 	.word	0x00000b37
 278:	00000b37 	.word	0x00000b37
 27c:	00000b37 	.word	0x00000b37
 280:	00000b37 	.word	0x00000b37
 284:	00000b37 	.word	0x00000b37
 288:	00000b37 	.word	0x00000b37
 28c:	00000b37 	.word	0x00000b37
 290:	00000b37 	.word	0x00000b37
 294:	00000b37 	.word	0x00000b37
 298:	00000b37 	.word	0x00000b37
 29c:	00000b37 	.word	0x00000b37
 2a0:	00000b37 	.word	0x00000b37
 2a4:	00000b37 	.word	0x00000b37
 2a8:	00000b37 	.word	0x00000b37
 2ac:	00000b37 	.word	0x00000b37
 2b0:	00000b37 	.word	0x00000b37
 2b4:	00000b37 	.word	0x00000b37
 2b8:	00000b37 	.word	0x00000b37
 2bc:	00000b37 	.word	0x00000b37
 2c0:	00000b37 	.word	0x00000b37
 2c4:	00000b37 	.word	0x00000b37
 2c8:	00000b37 	.word	0x00000b37
 2cc:	00000b37 	.word	0x00000b37
 2d0:	00000b37 	.word	0x00000b37
 2d4:	00000b37 	.word	0x00000b37
 2d8:	00000b37 	.word	0x00000b37
 2dc:	00000b37 	.word	0x00000b37
 2e0:	00000b37 	.word	0x00000b37
 2e4:	00000b37 	.word	0x00000b37
 2e8:	00000b37 	.word	0x00000b37
 2ec:	00000b37 	.word	0x00000b37
 2f0:	00000b37 	.word	0x00000b37
 2f4:	00000b37 	.word	0x00000b37
 2f8:	00000b37 	.word	0x00000b37
 2fc:	00000b37 	.word	0x00000b37
 300:	00000b37 	.word	0x00000b37
 304:	00000b37 	.word	0x00000b37
 308:	00000b37 	.word	0x00000b37
 30c:	00000b37 	.word	0x00000b37

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fa87 	bl	994 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fb46 	bl	b1c <startup_go_to_user_mode>
     490:	f000 fa34 	bl	8fc <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff8ef4 	.word	0x1fff8ef4

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fa91 	bl	ac0 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <Delay>:
void Delay( uint32 ms );

/*this is dummy delay function prepare just for this example, in a real application 
no delay shall be used*/
void Delay( uint32 ms )
{
     8b0:	b500      	push	{lr}
     8b2:	b087      	sub	sp, #28
     8b4:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
     8b6:	9b01      	ldr	r3, [sp, #4]
     8b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8bc:	fb02 f303 	mul.w	r3, r2, r3
     8c0:	2101      	movs	r1, #1
     8c2:	4618      	mov	r0, r3
     8c4:	f000 fc14 	bl	10f0 <OsIf_MicrosToTicks>
     8c8:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
     8ca:	2001      	movs	r0, #1
     8cc:	f000 fbc4 	bl	1058 <OsIf_GetCounter>
     8d0:	4603      	mov	r3, r0
     8d2:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
     8d4:	2300      	movs	r3, #0
     8d6:	9305      	str	r3, [sp, #20]
    do
    {
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     8d8:	ab03      	add	r3, sp, #12
     8da:	2101      	movs	r1, #1
     8dc:	4618      	mov	r0, r3
     8de:	f000 fbd4 	bl	108a <OsIf_GetElapsed>
     8e2:	4602      	mov	r2, r0
     8e4:	9b05      	ldr	r3, [sp, #20]
     8e6:	4413      	add	r3, r2
     8e8:	9305      	str	r3, [sp, #20]
    }while( ElapsedTime < Timeout );
     8ea:	9a05      	ldr	r2, [sp, #20]
     8ec:	9b04      	ldr	r3, [sp, #16]
     8ee:	429a      	cmp	r2, r3
     8f0:	d3f2      	bcc.n	8d8 <Delay+0x28>
}
     8f2:	bf00      	nop
     8f4:	bf00      	nop
     8f6:	b007      	add	sp, #28
     8f8:	f85d fb04 	ldr.w	pc, [sp], #4

000008fc <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     8fc:	b508      	push	{r3, lr}
    static Spi_DataBufferType TxMasterBuffer[10] = {11,12,13,14,15,16,17,18,19,20};

    EcuM_Init();
     8fe:	f000 f80f 	bl	920 <EcuM_Init>

    /* Copy transmitted data to internal buffer */
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_0, TxMasterBuffer, NULL, 10 );
     902:	230a      	movs	r3, #10
     904:	2200      	movs	r2, #0
     906:	4905      	ldr	r1, [pc, #20]	; (91c <main+0x20>)
     908:	2000      	movs	r0, #0
     90a:	f006 fd25 	bl	7358 <Spi_SetupEB>

    while( 1u )
    {
        /* This sequence of master transferring 10 frames of 8 bits using synchronous method*/
        Spi_SyncTransmit( SpiConf_SpiSequence_SpiSequence_0 );
     90e:	2000      	movs	r0, #0
     910:	f006 fdfa 	bl	7508 <Spi_SyncTransmit>
        Delay( 10u );
     914:	200a      	movs	r0, #10
     916:	f7ff ffcb 	bl	8b0 <Delay>
        Spi_SyncTransmit( SpiConf_SpiSequence_SpiSequence_0 );
     91a:	e7f8      	b.n	90e <main+0x12>
     91c:	1fff8b10 	.word	0x1fff8b10

00000920 <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     920:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );
     922:	480b      	ldr	r0, [pc, #44]	; (950 <EcuM_Init+0x30>)
     924:	f004 f924 	bl	4b70 <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     928:	2000      	movs	r0, #0
     92a:	f004 f975 	bl	4c18 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     92e:	2000      	movs	r0, #0
     930:	f004 f996 	bl	4c60 <Mcu_SetMode>

    /*Init the internal tick reference Systick Timer*/
    OsIf_Init( NULL_PTR );
     934:	2000      	movs	r0, #0
     936:	f000 fb86 	bl	1046 <OsIf_Init>
    /*enable and setup interrupts*/
    Platform_Init( NULL_PTR );
     93a:	2000      	movs	r0, #0
     93c:	f000 fa80 	bl	e40 <Platform_Init>

    /*Apply all the Pin Port microcontroller configuration, for this case
    only Port Pin 122  (D16) is configured as output*/
    Port_Init( &Port_Config );
     940:	4804      	ldr	r0, [pc, #16]	; (954 <EcuM_Init+0x34>)
     942:	f004 fd17 	bl	5374 <Port_Init>

    /*init the FlexCAN0 with the paramters set in Tresos in loop back mode*/
    Spi_Init( &Spi_Config );
     946:	4804      	ldr	r0, [pc, #16]	; (958 <EcuM_Init+0x38>)
     948:	f006 fc54 	bl	71f4 <Spi_Init>
}
     94c:	bf00      	nop
     94e:	bd08      	pop	{r3, pc}
     950:	0000a60c 	.word	0x0000a60c
     954:	0000a7f4 	.word	0x0000a7f4
     958:	0000a8d4 	.word	0x0000a8d4

0000095c <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     95c:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     95e:	f3ef 8310 	mrs	r3, PRIMASK
     962:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     964:	4623      	mov	r3, r4
}
     966:	4618      	mov	r0, r3
     968:	f85d 4b04 	ldr.w	r4, [sp], #4
     96c:	4770      	bx	lr

0000096e <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     96e:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     970:	f3ef 8310 	mrs	r3, PRIMASK
     974:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     976:	4623      	mov	r3, r4
}
     978:	4618      	mov	r0, r3
     97a:	f85d 4b04 	ldr.w	r4, [sp], #4
     97e:	4770      	bx	lr

00000980 <Spi_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Spi_schm_read_msr(void)
{
     980:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     982:	f3ef 8310 	mrs	r3, PRIMASK
     986:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     988:	4623      	mov	r3, r4
}
     98a:	4618      	mov	r0, r3
     98c:	f85d 4b04 	ldr.w	r4, [sp], #4
     990:	4770      	bx	lr
	...

00000994 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     994:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     996:	2300      	movs	r3, #0
     998:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     99a:	2300      	movs	r3, #0
     99c:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     99e:	2300      	movs	r3, #0
     9a0:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     9a2:	2300      	movs	r3, #0
     9a4:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     9a6:	4b44      	ldr	r3, [pc, #272]	; (ab8 <init_data_bss+0x124>)
     9a8:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     9aa:	4b44      	ldr	r3, [pc, #272]	; (abc <init_data_bss+0x128>)
     9ac:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     9ae:	9b05      	ldr	r3, [sp, #20]
     9b0:	681b      	ldr	r3, [r3, #0]
     9b2:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     9b4:	9b05      	ldr	r3, [sp, #20]
     9b6:	3304      	adds	r3, #4
     9b8:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     9ba:	9b05      	ldr	r3, [sp, #20]
     9bc:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     9be:	2300      	movs	r3, #0
     9c0:	9309      	str	r3, [sp, #36]	; 0x24
     9c2:	e03d      	b.n	a40 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     9c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     9c6:	4613      	mov	r3, r2
     9c8:	005b      	lsls	r3, r3, #1
     9ca:	4413      	add	r3, r2
     9cc:	009b      	lsls	r3, r3, #2
     9ce:	461a      	mov	r2, r3
     9d0:	9b03      	ldr	r3, [sp, #12]
     9d2:	4413      	add	r3, r2
     9d4:	685b      	ldr	r3, [r3, #4]
     9d6:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     9d8:	9a09      	ldr	r2, [sp, #36]	; 0x24
     9da:	4613      	mov	r3, r2
     9dc:	005b      	lsls	r3, r3, #1
     9de:	4413      	add	r3, r2
     9e0:	009b      	lsls	r3, r3, #2
     9e2:	461a      	mov	r2, r3
     9e4:	9b03      	ldr	r3, [sp, #12]
     9e6:	4413      	add	r3, r2
     9e8:	681b      	ldr	r3, [r3, #0]
     9ea:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     9ec:	9a09      	ldr	r2, [sp, #36]	; 0x24
     9ee:	4613      	mov	r3, r2
     9f0:	005b      	lsls	r3, r3, #1
     9f2:	4413      	add	r3, r2
     9f4:	009b      	lsls	r3, r3, #2
     9f6:	461a      	mov	r2, r3
     9f8:	9b03      	ldr	r3, [sp, #12]
     9fa:	4413      	add	r3, r2
     9fc:	689b      	ldr	r3, [r3, #8]
     9fe:	4619      	mov	r1, r3
     a00:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a02:	4613      	mov	r3, r2
     a04:	005b      	lsls	r3, r3, #1
     a06:	4413      	add	r3, r2
     a08:	009b      	lsls	r3, r3, #2
     a0a:	461a      	mov	r2, r3
     a0c:	9b03      	ldr	r3, [sp, #12]
     a0e:	4413      	add	r3, r2
     a10:	685b      	ldr	r3, [r3, #4]
     a12:	1acb      	subs	r3, r1, r3
     a14:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     a16:	2300      	movs	r3, #0
     a18:	9308      	str	r3, [sp, #32]
     a1a:	e00a      	b.n	a32 <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     a1c:	9a00      	ldr	r2, [sp, #0]
     a1e:	9b08      	ldr	r3, [sp, #32]
     a20:	441a      	add	r2, r3
     a22:	9901      	ldr	r1, [sp, #4]
     a24:	9b08      	ldr	r3, [sp, #32]
     a26:	440b      	add	r3, r1
     a28:	7812      	ldrb	r2, [r2, #0]
     a2a:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     a2c:	9b08      	ldr	r3, [sp, #32]
     a2e:	3301      	adds	r3, #1
     a30:	9308      	str	r3, [sp, #32]
     a32:	9a08      	ldr	r2, [sp, #32]
     a34:	9b06      	ldr	r3, [sp, #24]
     a36:	429a      	cmp	r2, r3
     a38:	d3f0      	bcc.n	a1c <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     a3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a3c:	3301      	adds	r3, #1
     a3e:	9309      	str	r3, [sp, #36]	; 0x24
     a40:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a42:	9b07      	ldr	r3, [sp, #28]
     a44:	429a      	cmp	r2, r3
     a46:	d3bd      	bcc.n	9c4 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     a48:	9b04      	ldr	r3, [sp, #16]
     a4a:	681b      	ldr	r3, [r3, #0]
     a4c:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     a4e:	9b04      	ldr	r3, [sp, #16]
     a50:	3304      	adds	r3, #4
     a52:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     a54:	9b04      	ldr	r3, [sp, #16]
     a56:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     a58:	2300      	movs	r3, #0
     a5a:	9309      	str	r3, [sp, #36]	; 0x24
     a5c:	e024      	b.n	aa8 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     a5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a60:	00db      	lsls	r3, r3, #3
     a62:	9a02      	ldr	r2, [sp, #8]
     a64:	4413      	add	r3, r2
     a66:	681b      	ldr	r3, [r3, #0]
     a68:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     a6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a6c:	00db      	lsls	r3, r3, #3
     a6e:	9a02      	ldr	r2, [sp, #8]
     a70:	4413      	add	r3, r2
     a72:	685b      	ldr	r3, [r3, #4]
     a74:	4619      	mov	r1, r3
     a76:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a78:	00db      	lsls	r3, r3, #3
     a7a:	9a02      	ldr	r2, [sp, #8]
     a7c:	4413      	add	r3, r2
     a7e:	681b      	ldr	r3, [r3, #0]
     a80:	1acb      	subs	r3, r1, r3
     a82:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     a84:	2300      	movs	r3, #0
     a86:	9308      	str	r3, [sp, #32]
     a88:	e007      	b.n	a9a <init_data_bss+0x106>
        {
            ram[j] = 0U;
     a8a:	9a01      	ldr	r2, [sp, #4]
     a8c:	9b08      	ldr	r3, [sp, #32]
     a8e:	4413      	add	r3, r2
     a90:	2200      	movs	r2, #0
     a92:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     a94:	9b08      	ldr	r3, [sp, #32]
     a96:	3301      	adds	r3, #1
     a98:	9308      	str	r3, [sp, #32]
     a9a:	9a08      	ldr	r2, [sp, #32]
     a9c:	9b06      	ldr	r3, [sp, #24]
     a9e:	429a      	cmp	r2, r3
     aa0:	d3f3      	bcc.n	a8a <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     aa2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     aa4:	3301      	adds	r3, #1
     aa6:	9309      	str	r3, [sp, #36]	; 0x24
     aa8:	9a09      	ldr	r2, [sp, #36]	; 0x24
     aaa:	9b07      	ldr	r3, [sp, #28]
     aac:	429a      	cmp	r2, r3
     aae:	d3d6      	bcc.n	a5e <init_data_bss+0xca>
        }
    }
}
     ab0:	bf00      	nop
     ab2:	bf00      	nop
     ab4:	b00a      	add	sp, #40	; 0x28
     ab6:	4770      	bx	lr
     ab8:	0000a8f4 	.word	0x0000a8f4
     abc:	0000a910 	.word	0x0000a910

00000ac0 <sys_m4_cache_init>:
{
     ac0:	b084      	sub	sp, #16
     ac2:	4603      	mov	r3, r0
     ac4:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     ac8:	2300      	movs	r3, #0
     aca:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     ace:	f89d 3007 	ldrb.w	r3, [sp, #7]
     ad2:	2b00      	cmp	r3, #0
     ad4:	d118      	bne.n	b08 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     ad6:	4b10      	ldr	r3, [pc, #64]	; (b18 <sys_m4_cache_init+0x58>)
     ad8:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     adc:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     ade:	4b0e      	ldr	r3, [pc, #56]	; (b18 <sys_m4_cache_init+0x58>)
     ae0:	681b      	ldr	r3, [r3, #0]
     ae2:	4a0d      	ldr	r2, [pc, #52]	; (b18 <sys_m4_cache_init+0x58>)
     ae4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     ae8:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     aea:	bf00      	nop
     aec:	4b0a      	ldr	r3, [pc, #40]	; (b18 <sys_m4_cache_init+0x58>)
     aee:	681b      	ldr	r3, [r3, #0]
     af0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     af4:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     af8:	d0f8      	beq.n	aec <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     afa:	4b07      	ldr	r3, [pc, #28]	; (b18 <sys_m4_cache_init+0x58>)
     afc:	681b      	ldr	r3, [r3, #0]
     afe:	4a06      	ldr	r2, [pc, #24]	; (b18 <sys_m4_cache_init+0x58>)
     b00:	f043 0301 	orr.w	r3, r3, #1
     b04:	6013      	str	r3, [r2, #0]
     b06:	e002      	b.n	b0e <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     b08:	2301      	movs	r3, #1
     b0a:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     b0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     b12:	4618      	mov	r0, r3
     b14:	b004      	add	sp, #16
     b16:	4770      	bx	lr
     b18:	e0082000 	.word	0xe0082000

00000b1c <startup_go_to_user_mode>:
}
     b1c:	bf00      	nop
     b1e:	4770      	bx	lr

00000b20 <Sys_GetCoreID>:
    return 0U;
     b20:	2300      	movs	r3, #0
}
     b22:	4618      	mov	r0, r3
     b24:	4770      	bx	lr

00000b26 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     b26:	e7fe      	b.n	b26 <HardFault_Handler>

00000b28 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     b28:	e7fe      	b.n	b28 <MemManage_Handler>

00000b2a <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     b2a:	e7fe      	b.n	b2a <BusFault_Handler>

00000b2c <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     b2c:	e7fe      	b.n	b2c <UsageFault_Handler>

00000b2e <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     b2e:	e7fe      	b.n	b2e <SVC_Handler>

00000b30 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     b30:	e7fe      	b.n	b30 <DebugMon_Handler>

00000b32 <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     b32:	e7fe      	b.n	b32 <PendSV_Handler>

00000b34 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     b34:	e7fe      	b.n	b34 <SysTick_Handler>

00000b36 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     b36:	e7fe      	b.n	b36 <undefined_handler>

00000b38 <IntCtrl_Ip_InstallHandlerPrivileged>:
#endif

void IntCtrl_Ip_InstallHandlerPrivileged(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
     b38:	b086      	sub	sp, #24
     b3a:	9003      	str	r0, [sp, #12]
     b3c:	9102      	str	r1, [sp, #8]
     b3e:	9201      	str	r2, [sp, #4]

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber)] = pfNewHandler;
    OsIf_ResumeAllInterrupts();
#else
    IntCtrl_Ip_IrqHandlerType *pVectorRam = (IntCtrl_Ip_IrqHandlerType *)S32_SCB->VTOR;
     b40:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     b44:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
     b48:	9305      	str	r3, [sp, #20]

    /* Save the former handler pointer */
    if (pfOldHandler != NULL_PTR)
     b4a:	9b01      	ldr	r3, [sp, #4]
     b4c:	2b00      	cmp	r3, #0
     b4e:	d007      	beq.n	b60 <IntCtrl_Ip_InstallHandlerPrivileged+0x28>
    {
        *pfOldHandler = (IntCtrl_Ip_IrqHandlerType)pVectorRam[((sint32)eIrqNumber) + 16];
     b50:	9b03      	ldr	r3, [sp, #12]
     b52:	3310      	adds	r3, #16
     b54:	009b      	lsls	r3, r3, #2
     b56:	9a05      	ldr	r2, [sp, #20]
     b58:	4413      	add	r3, r2
     b5a:	681a      	ldr	r2, [r3, #0]
     b5c:	9b01      	ldr	r3, [sp, #4]
     b5e:	601a      	str	r2, [r3, #0]
    }

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber) + 16] = pfNewHandler;
     b60:	9b03      	ldr	r3, [sp, #12]
     b62:	3310      	adds	r3, #16
     b64:	009b      	lsls	r3, r3, #2
     b66:	9a05      	ldr	r2, [sp, #20]
     b68:	4413      	add	r3, r2
     b6a:	9a02      	ldr	r2, [sp, #8]
     b6c:	601a      	str	r2, [r3, #0]
    S32_SCB->ICIALLU = 0UL;
#endif
    
#endif /* (INT_CTRL_IP_CORTEXR == STD_ON) || (INT_CTRL_IP_CORTEXA == STD_ON) */
/*LDRA_NOANALYSIS*/
    MCAL_INSTRUCTION_SYNC_BARRIER();
     b6e:	f3bf 8f6f 	isb	sy
    MCAL_DATA_SYNC_BARRIER();
     b72:	f3bf 8f4f 	dsb	sy
/*LDRA_ANALYSIS*/    
}
     b76:	bf00      	nop
     b78:	b006      	add	sp, #24
     b7a:	4770      	bx	lr

00000b7c <IntCtrl_Ip_EnableIrqPrivileged>:

void IntCtrl_Ip_EnableIrqPrivileged(IRQn_Type eIrqNumber)
{
     b7c:	b082      	sub	sp, #8
     b7e:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ISENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ISER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
     b80:	9b01      	ldr	r3, [sp, #4]
     b82:	f003 021f 	and.w	r2, r3, #31
     b86:	4905      	ldr	r1, [pc, #20]	; (b9c <IntCtrl_Ip_EnableIrqPrivileged+0x20>)
     b88:	9b01      	ldr	r3, [sp, #4]
     b8a:	095b      	lsrs	r3, r3, #5
     b8c:	2001      	movs	r0, #1
     b8e:	fa00 f202 	lsl.w	r2, r0, r2
     b92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
     b96:	bf00      	nop
     b98:	b002      	add	sp, #8
     b9a:	4770      	bx	lr
     b9c:	e000e100 	.word	0xe000e100

00000ba0 <IntCtrl_Ip_DisableIrqPrivileged>:

void IntCtrl_Ip_DisableIrqPrivileged(IRQn_Type eIrqNumber)
{
     ba0:	b082      	sub	sp, #8
     ba2:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ICENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ICER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
     ba4:	9b01      	ldr	r3, [sp, #4]
     ba6:	f003 021f 	and.w	r2, r3, #31
     baa:	4906      	ldr	r1, [pc, #24]	; (bc4 <IntCtrl_Ip_DisableIrqPrivileged+0x24>)
     bac:	9b01      	ldr	r3, [sp, #4]
     bae:	095b      	lsrs	r3, r3, #5
     bb0:	2001      	movs	r0, #1
     bb2:	fa00 f202 	lsl.w	r2, r0, r2
     bb6:	3320      	adds	r3, #32
     bb8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
     bbc:	bf00      	nop
     bbe:	b002      	add	sp, #8
     bc0:	4770      	bx	lr
     bc2:	bf00      	nop
     bc4:	e000e100 	.word	0xe000e100

00000bc8 <IntCtrl_Ip_SetPriorityPrivileged>:

void IntCtrl_Ip_SetPriorityPrivileged(IRQn_Type eIrqNumber, uint8 u8Priority)
{
     bc8:	b084      	sub	sp, #16
     bca:	9001      	str	r0, [sp, #4]
     bcc:	460b      	mov	r3, r1
     bce:	f88d 3003 	strb.w	r3, [sp, #3]
#endif

#endif /* (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON) */

#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8) (8U - INT_CTRL_IP_NVIC_PRIO_BITS);
     bd2:	2304      	movs	r3, #4
     bd4:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Set Priority for device specific Interrupts */
        S32_NVIC->IP[(uint32)(eIrqNumber)] = (uint8)((((uint32)u8Priority) << shift) & 0xFFUL);
     bd8:	f89d 2003 	ldrb.w	r2, [sp, #3]
     bdc:	f89d 300f 	ldrb.w	r3, [sp, #15]
     be0:	fa02 f103 	lsl.w	r1, r2, r3
     be4:	4a04      	ldr	r2, [pc, #16]	; (bf8 <IntCtrl_Ip_SetPriorityPrivileged+0x30>)
     be6:	9b01      	ldr	r3, [sp, #4]
     be8:	b2c9      	uxtb	r1, r1
     bea:	4413      	add	r3, r2
     bec:	460a      	mov	r2, r1
     bee:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] &= ~(0xFFUL << priByteShift);
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] |= ((uint32)(((((uint32)u8Priority) << shift_gic)) & 0xFFUL)) << priByteShift;
        }
    #endif
#endif
}
     bf2:	bf00      	nop
     bf4:	b004      	add	sp, #16
     bf6:	4770      	bx	lr
     bf8:	e000e100 	.word	0xe000e100

00000bfc <IntCtrl_Ip_GetPriorityPrivileged>:

uint8 IntCtrl_Ip_GetPriorityPrivileged(IRQn_Type eIrqNumber)
{
     bfc:	b084      	sub	sp, #16
     bfe:	9001      	str	r0, [sp, #4]

    uint8 priority;


#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8)(8U - INT_CTRL_IP_NVIC_PRIO_BITS);
     c00:	2304      	movs	r3, #4
     c02:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Get Priority for device specific Interrupts  */
        priority = (uint8)(S32_NVIC->IP[(uint32)(eIrqNumber)] >> shift);
     c06:	4a09      	ldr	r2, [pc, #36]	; (c2c <IntCtrl_Ip_GetPriorityPrivileged+0x30>)
     c08:	9b01      	ldr	r3, [sp, #4]
     c0a:	4413      	add	r3, r2
     c0c:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
     c10:	b2db      	uxtb	r3, r3
     c12:	461a      	mov	r2, r3
     c14:	f89d 300f 	ldrb.w	r3, [sp, #15]
     c18:	fa42 f303 	asr.w	r3, r2, r3
     c1c:	f88d 300e 	strb.w	r3, [sp, #14]
            uint8 priByteShift = (uint8)((((uint8)(eIrqNumber)) & 0x3U) << 3U);
            priority = ((uint8)(IP_GIC500->GICD.IPRIORITYR[iprVectorId] >> priByteShift)) >> shift_gic;
        }
    #endif
#endif
    return priority;
     c20:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
     c24:	4618      	mov	r0, r3
     c26:	b004      	add	sp, #16
     c28:	4770      	bx	lr
     c2a:	bf00      	nop
     c2c:	e000e100 	.word	0xe000e100

00000c30 <IntCtrl_Ip_ClearPendingPrivileged>:

void IntCtrl_Ip_ClearPendingPrivileged(IRQn_Type eIrqNumber)
{
     c30:	b082      	sub	sp, #8
     c32:	9001      	str	r0, [sp, #4]
    }
#endif

#else
    /* Clear Pending Interrupt */
    S32_NVIC->ICPR[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
     c34:	9b01      	ldr	r3, [sp, #4]
     c36:	f003 021f 	and.w	r2, r3, #31
     c3a:	4906      	ldr	r1, [pc, #24]	; (c54 <IntCtrl_Ip_ClearPendingPrivileged+0x24>)
     c3c:	9b01      	ldr	r3, [sp, #4]
     c3e:	095b      	lsrs	r3, r3, #5
     c40:	2001      	movs	r0, #1
     c42:	fa00 f202 	lsl.w	r2, r0, r2
     c46:	3360      	adds	r3, #96	; 0x60
     c48:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
     c4c:	bf00      	nop
     c4e:	b002      	add	sp, #8
     c50:	4770      	bx	lr
     c52:	bf00      	nop
     c54:	e000e100 	.word	0xe000e100

00000c58 <IntCtrl_Ip_Init>:
 * @internal
 * @brief         Initializes the configured interrupts at interrupt controller level.
 * @implements    IntCtrl_Ip_Init_Activity
 */
IntCtrl_Ip_StatusType IntCtrl_Ip_Init(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
     c58:	b500      	push	{lr}
     c5a:	b085      	sub	sp, #20
     c5c:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(pIntCtrlCtrlConfig != NULL_PTR);
    DevAssert(pIntCtrlCtrlConfig->u32ConfigIrqCount <= INT_CTRL_IP_IRQ_COUNT);
#endif
    uint32 irqIdx;
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
     c5e:	2300      	movs	r3, #0
     c60:	9303      	str	r3, [sp, #12]
     c62:	e05d      	b.n	d20 <IntCtrl_Ip_Init+0xc8>
    {
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     c64:	9b01      	ldr	r3, [sp, #4]
     c66:	6859      	ldr	r1, [r3, #4]
     c68:	9a03      	ldr	r2, [sp, #12]
     c6a:	4613      	mov	r3, r2
     c6c:	005b      	lsls	r3, r3, #1
     c6e:	4413      	add	r3, r2
     c70:	009b      	lsls	r3, r3, #2
     c72:	440b      	add	r3, r1
     c74:	681b      	ldr	r3, [r3, #0]
     c76:	4618      	mov	r0, r3
     c78:	f000 f899 	bl	dae <IntCtrl_Ip_ClearPending>
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     c7c:	9b01      	ldr	r3, [sp, #4]
     c7e:	6859      	ldr	r1, [r3, #4]
     c80:	9a03      	ldr	r2, [sp, #12]
     c82:	4613      	mov	r3, r2
     c84:	005b      	lsls	r3, r3, #1
     c86:	4413      	add	r3, r2
     c88:	009b      	lsls	r3, r3, #2
     c8a:	440b      	add	r3, r1
     c8c:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
     c8e:	9b01      	ldr	r3, [sp, #4]
     c90:	6859      	ldr	r1, [r3, #4]
     c92:	9a03      	ldr	r2, [sp, #12]
     c94:	4613      	mov	r3, r2
     c96:	005b      	lsls	r3, r3, #1
     c98:	4413      	add	r3, r2
     c9a:	009b      	lsls	r3, r3, #2
     c9c:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     c9e:	795b      	ldrb	r3, [r3, #5]
     ca0:	4619      	mov	r1, r3
     ca2:	f000 f869 	bl	d78 <IntCtrl_Ip_SetPriority>

        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     ca6:	9b01      	ldr	r3, [sp, #4]
     ca8:	6859      	ldr	r1, [r3, #4]
     caa:	9a03      	ldr	r2, [sp, #12]
     cac:	4613      	mov	r3, r2
     cae:	005b      	lsls	r3, r3, #1
     cb0:	4413      	add	r3, r2
     cb2:	009b      	lsls	r3, r3, #2
     cb4:	440b      	add	r3, r1
     cb6:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
     cb8:	9b01      	ldr	r3, [sp, #4]
     cba:	6859      	ldr	r1, [r3, #4]
     cbc:	9a03      	ldr	r2, [sp, #12]
     cbe:	4613      	mov	r3, r2
     cc0:	005b      	lsls	r3, r3, #1
     cc2:	4413      	add	r3, r2
     cc4:	009b      	lsls	r3, r3, #2
     cc6:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     cc8:	689b      	ldr	r3, [r3, #8]
     cca:	2200      	movs	r2, #0
     ccc:	4619      	mov	r1, r3
     cce:	f000 f831 	bl	d34 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
     cd2:	9b01      	ldr	r3, [sp, #4]
     cd4:	6859      	ldr	r1, [r3, #4]
     cd6:	9a03      	ldr	r2, [sp, #12]
     cd8:	4613      	mov	r3, r2
     cda:	005b      	lsls	r3, r3, #1
     cdc:	4413      	add	r3, r2
     cde:	009b      	lsls	r3, r3, #2
     ce0:	440b      	add	r3, r1
     ce2:	791b      	ldrb	r3, [r3, #4]
     ce4:	2b00      	cmp	r3, #0
     ce6:	d00c      	beq.n	d02 <IntCtrl_Ip_Init+0xaa>
        {
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     ce8:	9b01      	ldr	r3, [sp, #4]
     cea:	6859      	ldr	r1, [r3, #4]
     cec:	9a03      	ldr	r2, [sp, #12]
     cee:	4613      	mov	r3, r2
     cf0:	005b      	lsls	r3, r3, #1
     cf2:	4413      	add	r3, r2
     cf4:	009b      	lsls	r3, r3, #2
     cf6:	440b      	add	r3, r1
     cf8:	681b      	ldr	r3, [r3, #0]
     cfa:	4618      	mov	r0, r3
     cfc:	f000 f828 	bl	d50 <IntCtrl_Ip_EnableIrq>
     d00:	e00b      	b.n	d1a <IntCtrl_Ip_Init+0xc2>
        }
        else
        {
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     d02:	9b01      	ldr	r3, [sp, #4]
     d04:	6859      	ldr	r1, [r3, #4]
     d06:	9a03      	ldr	r2, [sp, #12]
     d08:	4613      	mov	r3, r2
     d0a:	005b      	lsls	r3, r3, #1
     d0c:	4413      	add	r3, r2
     d0e:	009b      	lsls	r3, r3, #2
     d10:	440b      	add	r3, r1
     d12:	681b      	ldr	r3, [r3, #0]
     d14:	4618      	mov	r0, r3
     d16:	f000 f825 	bl	d64 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
     d1a:	9b03      	ldr	r3, [sp, #12]
     d1c:	3301      	adds	r3, #1
     d1e:	9303      	str	r3, [sp, #12]
     d20:	9b01      	ldr	r3, [sp, #4]
     d22:	681b      	ldr	r3, [r3, #0]
     d24:	9a03      	ldr	r2, [sp, #12]
     d26:	429a      	cmp	r2, r3
     d28:	d39c      	bcc.n	c64 <IntCtrl_Ip_Init+0xc>
        }
    }

    return INTCTRL_IP_STATUS_SUCCESS;
     d2a:	2300      	movs	r3, #0
}
     d2c:	4618      	mov	r0, r3
     d2e:	b005      	add	sp, #20
     d30:	f85d fb04 	ldr.w	pc, [sp], #4

00000d34 <IntCtrl_Ip_InstallHandler>:
 * @implements    IntCtrl_Ip_InstallHandler_Activity
 */
void IntCtrl_Ip_InstallHandler(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
     d34:	b500      	push	{lr}
     d36:	b085      	sub	sp, #20
     d38:	9003      	str	r0, [sp, #12]
     d3a:	9102      	str	r1, [sp, #8]
     d3c:	9201      	str	r2, [sp, #4]
    Call_IntCtrl_Ip_InstallHandlerPrivileged(eIrqNumber,pfNewHandler,pfOldHandler);
     d3e:	9a01      	ldr	r2, [sp, #4]
     d40:	9902      	ldr	r1, [sp, #8]
     d42:	9803      	ldr	r0, [sp, #12]
     d44:	f7ff fef8 	bl	b38 <IntCtrl_Ip_InstallHandlerPrivileged>
}
     d48:	bf00      	nop
     d4a:	b005      	add	sp, #20
     d4c:	f85d fb04 	ldr.w	pc, [sp], #4

00000d50 <IntCtrl_Ip_EnableIrq>:
 * @internal
 * @brief         Enables an interrupt request.
 * @implements    IntCtrl_Ip_EnableIrq_Activity
 */
void IntCtrl_Ip_EnableIrq(IRQn_Type eIrqNumber)
{
     d50:	b500      	push	{lr}
     d52:	b083      	sub	sp, #12
     d54:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_EnableIrqPrivileged(eIrqNumber);
     d56:	9801      	ldr	r0, [sp, #4]
     d58:	f7ff ff10 	bl	b7c <IntCtrl_Ip_EnableIrqPrivileged>
}
     d5c:	bf00      	nop
     d5e:	b003      	add	sp, #12
     d60:	f85d fb04 	ldr.w	pc, [sp], #4

00000d64 <IntCtrl_Ip_DisableIrq>:
 * @internal
 * @brief         Disables an interrupt request.
 * @implements    IntCtrl_Ip_DisableIrq_Activity
 */
void IntCtrl_Ip_DisableIrq(IRQn_Type eIrqNumber)
{
     d64:	b500      	push	{lr}
     d66:	b083      	sub	sp, #12
     d68:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_DisableIrqPrivileged(eIrqNumber);
     d6a:	9801      	ldr	r0, [sp, #4]
     d6c:	f7ff ff18 	bl	ba0 <IntCtrl_Ip_DisableIrqPrivileged>
}
     d70:	bf00      	nop
     d72:	b003      	add	sp, #12
     d74:	f85d fb04 	ldr.w	pc, [sp], #4

00000d78 <IntCtrl_Ip_SetPriority>:
 * @internal
 * @brief         Sets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_SetPriority_Activity
 */
void IntCtrl_Ip_SetPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
     d78:	b500      	push	{lr}
     d7a:	b083      	sub	sp, #12
     d7c:	9001      	str	r0, [sp, #4]
     d7e:	460b      	mov	r3, r1
     d80:	f88d 3003 	strb.w	r3, [sp, #3]
    Call_IntCtrl_Ip_SetPriorityPrivileged(eIrqNumber,u8Priority);
     d84:	f89d 3003 	ldrb.w	r3, [sp, #3]
     d88:	4619      	mov	r1, r3
     d8a:	9801      	ldr	r0, [sp, #4]
     d8c:	f7ff ff1c 	bl	bc8 <IntCtrl_Ip_SetPriorityPrivileged>
}
     d90:	bf00      	nop
     d92:	b003      	add	sp, #12
     d94:	f85d fb04 	ldr.w	pc, [sp], #4

00000d98 <IntCtrl_Ip_GetPriority>:
 * @internal
 * @brief         Gets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_GetPriority_Activity
 */
uint8 IntCtrl_Ip_GetPriority(IRQn_Type eIrqNumber)
{
     d98:	b500      	push	{lr}
     d9a:	b083      	sub	sp, #12
     d9c:	9001      	str	r0, [sp, #4]
    return (uint8)Call_IntCtrl_Ip_GetPriorityPrivileged(eIrqNumber);
     d9e:	9801      	ldr	r0, [sp, #4]
     da0:	f7ff ff2c 	bl	bfc <IntCtrl_Ip_GetPriorityPrivileged>
     da4:	4603      	mov	r3, r0
}
     da6:	4618      	mov	r0, r3
     da8:	b003      	add	sp, #12
     daa:	f85d fb04 	ldr.w	pc, [sp], #4

00000dae <IntCtrl_Ip_ClearPending>:
 * @internal
 * @brief         Clears the pending flag for an interrupt request.
 * @implements    IntCtrl_Ip_ClearPending_Activity
 */
void IntCtrl_Ip_ClearPending(IRQn_Type eIrqNumber)
{
     dae:	b500      	push	{lr}
     db0:	b083      	sub	sp, #12
     db2:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_ClearPendingPrivileged(eIrqNumber);
     db4:	9801      	ldr	r0, [sp, #4]
     db6:	f7ff ff3b 	bl	c30 <IntCtrl_Ip_ClearPendingPrivileged>
}
     dba:	bf00      	nop
     dbc:	b003      	add	sp, #12
     dbe:	f85d fb04 	ldr.w	pc, [sp], #4
     dc2:	bf00      	nop

00000dc4 <Platform_Ipw_SetIrq>:
/**
 * @internal
 * @brief         Enables/disables an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
     dc4:	b500      	push	{lr}
     dc6:	b083      	sub	sp, #12
     dc8:	9001      	str	r0, [sp, #4]
     dca:	460b      	mov	r3, r1
     dcc:	f88d 3003 	strb.w	r3, [sp, #3]
    if (bEnable)
     dd0:	f89d 3003 	ldrb.w	r3, [sp, #3]
     dd4:	2b00      	cmp	r3, #0
     dd6:	d003      	beq.n	de0 <Platform_Ipw_SetIrq+0x1c>
    {
        IntCtrl_Ip_EnableIrq(eIrqNumber);
     dd8:	9801      	ldr	r0, [sp, #4]
     dda:	f7ff ffb9 	bl	d50 <IntCtrl_Ip_EnableIrq>
    }
    else
    {
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    }
}
     dde:	e002      	b.n	de6 <Platform_Ipw_SetIrq+0x22>
        IntCtrl_Ip_DisableIrq(eIrqNumber);
     de0:	9801      	ldr	r0, [sp, #4]
     de2:	f7ff ffbf 	bl	d64 <IntCtrl_Ip_DisableIrq>
}
     de6:	bf00      	nop
     de8:	b003      	add	sp, #12
     dea:	f85d fb04 	ldr.w	pc, [sp], #4

00000dee <Platform_Ipw_SetIrqPriority>:
/**
 * @internal
 * @brief         Sets the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
     dee:	b500      	push	{lr}
     df0:	b083      	sub	sp, #12
     df2:	9001      	str	r0, [sp, #4]
     df4:	460b      	mov	r3, r1
     df6:	f88d 3003 	strb.w	r3, [sp, #3]
    IntCtrl_Ip_SetPriority(eIrqNumber, u8Priority);
     dfa:	f89d 3003 	ldrb.w	r3, [sp, #3]
     dfe:	4619      	mov	r1, r3
     e00:	9801      	ldr	r0, [sp, #4]
     e02:	f7ff ffb9 	bl	d78 <IntCtrl_Ip_SetPriority>
}
     e06:	bf00      	nop
     e08:	b003      	add	sp, #12
     e0a:	f85d fb04 	ldr.w	pc, [sp], #4

00000e0e <Platform_Ipw_GetIrqPriority>:
/**
 * @internal
 * @brief         Returns the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline uint8 Platform_Ipw_GetIrqPriority(IRQn_Type eIrqNumber)
{
     e0e:	b500      	push	{lr}
     e10:	b083      	sub	sp, #12
     e12:	9001      	str	r0, [sp, #4]
    return IntCtrl_Ip_GetPriority(eIrqNumber);
     e14:	9801      	ldr	r0, [sp, #4]
     e16:	f7ff ffbf 	bl	d98 <IntCtrl_Ip_GetPriority>
     e1a:	4603      	mov	r3, r0
}
     e1c:	4618      	mov	r0, r3
     e1e:	b003      	add	sp, #12
     e20:	f85d fb04 	ldr.w	pc, [sp], #4

00000e24 <Platform_Ipw_InstallIrqHandler>:
 * @brief         Installs a new interrupt handler by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_InstallIrqHandler(IRQn_Type eIrqNumber,
                                                  const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                                                  IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
     e24:	b500      	push	{lr}
     e26:	b085      	sub	sp, #20
     e28:	9003      	str	r0, [sp, #12]
     e2a:	9102      	str	r1, [sp, #8]
     e2c:	9201      	str	r2, [sp, #4]
    IntCtrl_Ip_InstallHandler(eIrqNumber, pfNewHandler, pfOldHandler);
     e2e:	9a01      	ldr	r2, [sp, #4]
     e30:	9902      	ldr	r1, [sp, #8]
     e32:	9803      	ldr	r0, [sp, #12]
     e34:	f7ff ff7e 	bl	d34 <IntCtrl_Ip_InstallHandler>
}
     e38:	bf00      	nop
     e3a:	b005      	add	sp, #20
     e3c:	f85d fb04 	ldr.w	pc, [sp], #4

00000e40 <Platform_Init>:
 * @internal
 * @brief         Initializes the platform settings based on user configuration.
 * @implements    Platform_Init_Activity
 */
void Platform_Init(const Platform_ConfigType *pConfig)
{
     e40:	b500      	push	{lr}
     e42:	b085      	sub	sp, #20
     e44:	9001      	str	r0, [sp, #4]
    uint8 u8CoreId;

    u8CoreId = (uint8)Platform_GetCoreID();
     e46:	2300      	movs	r3, #0
     e48:	f88d 300f 	strb.w	r3, [sp, #15]
        {
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
#endif /*(PLATFORM_DEV_ERROR_DETECT == STD_ON)*/


            Platform_Ipw_Init(Platform_Config[u8CoreId]->pIpwConfig);
     e4c:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e50:	4a05      	ldr	r2, [pc, #20]	; (e68 <Platform_Init+0x28>)
     e52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     e56:	681b      	ldr	r3, [r3, #0]
     e58:	4618      	mov	r0, r3
     e5a:	f000 f8c7 	bl	fec <Platform_Ipw_Init>
        }
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
    }
#endif /* (PLATFORM_DEV_ERROR_DETECT == STD_ON)*/

}
     e5e:	bf00      	nop
     e60:	b005      	add	sp, #20
     e62:	f85d fb04 	ldr.w	pc, [sp], #4
     e66:	bf00      	nop
     e68:	0000a638 	.word	0x0000a638

00000e6c <Platform_SetIrq>:
 * @internal
 * @brief         Configures (enables/disables) an interrupt request.
 * @implements    Platform_SetIrq_Activity
 */
Std_ReturnType Platform_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
     e6c:	b500      	push	{lr}
     e6e:	b085      	sub	sp, #20
     e70:	9001      	str	r0, [sp, #4]
     e72:	460b      	mov	r3, r1
     e74:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
     e78:	2300      	movs	r3, #0
     e7a:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrq(eIrqNumber, bEnable);
     e7e:	f89d 3003 	ldrb.w	r3, [sp, #3]
     e82:	4619      	mov	r1, r3
     e84:	9801      	ldr	r0, [sp, #4]
     e86:	f7ff ff9d 	bl	dc4 <Platform_Ipw_SetIrq>
    }
    return RetValue;
     e8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     e8e:	4618      	mov	r0, r3
     e90:	b005      	add	sp, #20
     e92:	f85d fb04 	ldr.w	pc, [sp], #4

00000e96 <Platform_SetIrqPriority>:
 * @internal
 * @brief         Configures the priority of an interrupt request.
 * @implements    Platform_SetIrqPriority_Activity
 */
Std_ReturnType Platform_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
     e96:	b500      	push	{lr}
     e98:	b085      	sub	sp, #20
     e9a:	9001      	str	r0, [sp, #4]
     e9c:	460b      	mov	r3, r1
     e9e:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
     ea2:	2300      	movs	r3, #0
     ea4:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrqPriority(eIrqNumber, u8Priority);
     ea8:	f89d 3003 	ldrb.w	r3, [sp, #3]
     eac:	4619      	mov	r1, r3
     eae:	9801      	ldr	r0, [sp, #4]
     eb0:	f7ff ff9d 	bl	dee <Platform_Ipw_SetIrqPriority>
    }
    return RetValue;
     eb4:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     eb8:	4618      	mov	r0, r3
     eba:	b005      	add	sp, #20
     ebc:	f85d fb04 	ldr.w	pc, [sp], #4

00000ec0 <Platform_GetIrqPriority>:
 * @internal
 * @brief         Returns the priority of an interrupt request.
 * @implements    Platform_GetIrqPriority_Activity
 */
Std_ReturnType Platform_GetIrqPriority(IRQn_Type eIrqNumber, uint8 * u8Priority)
{
     ec0:	b500      	push	{lr}
     ec2:	b085      	sub	sp, #20
     ec4:	9001      	str	r0, [sp, #4]
     ec6:	9100      	str	r1, [sp, #0]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
     ec8:	2300      	movs	r3, #0
     eca:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        *u8Priority = Platform_Ipw_GetIrqPriority(eIrqNumber);
     ece:	9801      	ldr	r0, [sp, #4]
     ed0:	f7ff ff9d 	bl	e0e <Platform_Ipw_GetIrqPriority>
     ed4:	4603      	mov	r3, r0
     ed6:	461a      	mov	r2, r3
     ed8:	9b00      	ldr	r3, [sp, #0]
     eda:	701a      	strb	r2, [r3, #0]
    }

    return RetValue;
     edc:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     ee0:	4618      	mov	r0, r3
     ee2:	b005      	add	sp, #20
     ee4:	f85d fb04 	ldr.w	pc, [sp], #4

00000ee8 <Platform_InstallIrqHandler>:
 * @implements    Platform_InstallIrqHandler_Activity
 */
Std_ReturnType Platform_InstallIrqHandler(IRQn_Type eIrqNumber,
                                          const Platform_IrqHandlerType pfNewHandler,
                                          Platform_IrqHandlerType* const pfOldHandler)
{
     ee8:	b500      	push	{lr}
     eea:	b087      	sub	sp, #28
     eec:	9003      	str	r0, [sp, #12]
     eee:	9102      	str	r1, [sp, #8]
     ef0:	9201      	str	r2, [sp, #4]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
     ef2:	2300      	movs	r3, #0
     ef4:	f88d 3017 	strb.w	r3, [sp, #23]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_InstallIrqHandler(eIrqNumber, pfNewHandler, pfOldHandler);
     ef8:	9a01      	ldr	r2, [sp, #4]
     efa:	9902      	ldr	r1, [sp, #8]
     efc:	9803      	ldr	r0, [sp, #12]
     efe:	f7ff ff91 	bl	e24 <Platform_Ipw_InstallIrqHandler>
    }
    return RetValue;
     f02:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
     f06:	4618      	mov	r0, r3
     f08:	b007      	add	sp, #28
     f0a:	f85d fb04 	ldr.w	pc, [sp], #4
     f0e:	bf00      	nop

00000f10 <Platform_Ipw_InitIntCtrl>:
#endif



static Std_ReturnType Platform_Ipw_InitIntCtrl(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
     f10:	b500      	push	{lr}
     f12:	b085      	sub	sp, #20
     f14:	9001      	str	r0, [sp, #4]
    uint32 irqIdx;
    
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
     f16:	2300      	movs	r3, #0
     f18:	9303      	str	r3, [sp, #12]
     f1a:	e05d      	b.n	fd8 <Platform_Ipw_InitIntCtrl+0xc8>
    {   
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     f1c:	9b01      	ldr	r3, [sp, #4]
     f1e:	6859      	ldr	r1, [r3, #4]
     f20:	9a03      	ldr	r2, [sp, #12]
     f22:	4613      	mov	r3, r2
     f24:	005b      	lsls	r3, r3, #1
     f26:	4413      	add	r3, r2
     f28:	009b      	lsls	r3, r3, #2
     f2a:	440b      	add	r3, r1
     f2c:	681b      	ldr	r3, [r3, #0]
     f2e:	4618      	mov	r0, r3
     f30:	f7ff ff3d 	bl	dae <IntCtrl_Ip_ClearPending>
        /* interrupt number for which the priority is set */
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     f34:	9b01      	ldr	r3, [sp, #4]
     f36:	6859      	ldr	r1, [r3, #4]
     f38:	9a03      	ldr	r2, [sp, #12]
     f3a:	4613      	mov	r3, r2
     f3c:	005b      	lsls	r3, r3, #1
     f3e:	4413      	add	r3, r2
     f40:	009b      	lsls	r3, r3, #2
     f42:	440b      	add	r3, r1
     f44:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
     f46:	9b01      	ldr	r3, [sp, #4]
     f48:	6859      	ldr	r1, [r3, #4]
     f4a:	9a03      	ldr	r2, [sp, #12]
     f4c:	4613      	mov	r3, r2
     f4e:	005b      	lsls	r3, r3, #1
     f50:	4413      	add	r3, r2
     f52:	009b      	lsls	r3, r3, #2
     f54:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     f56:	795b      	ldrb	r3, [r3, #5]
     f58:	4619      	mov	r1, r3
     f5a:	f7ff ff0d 	bl	d78 <IntCtrl_Ip_SetPriority>
        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     f5e:	9b01      	ldr	r3, [sp, #4]
     f60:	6859      	ldr	r1, [r3, #4]
     f62:	9a03      	ldr	r2, [sp, #12]
     f64:	4613      	mov	r3, r2
     f66:	005b      	lsls	r3, r3, #1
     f68:	4413      	add	r3, r2
     f6a:	009b      	lsls	r3, r3, #2
     f6c:	440b      	add	r3, r1
     f6e:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
     f70:	9b01      	ldr	r3, [sp, #4]
     f72:	6859      	ldr	r1, [r3, #4]
     f74:	9a03      	ldr	r2, [sp, #12]
     f76:	4613      	mov	r3, r2
     f78:	005b      	lsls	r3, r3, #1
     f7a:	4413      	add	r3, r2
     f7c:	009b      	lsls	r3, r3, #2
     f7e:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
     f80:	689b      	ldr	r3, [r3, #8]
     f82:	2200      	movs	r2, #0
     f84:	4619      	mov	r1, r3
     f86:	f7ff fed5 	bl	d34 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        /* Enable interrupt */                       
        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
     f8a:	9b01      	ldr	r3, [sp, #4]
     f8c:	6859      	ldr	r1, [r3, #4]
     f8e:	9a03      	ldr	r2, [sp, #12]
     f90:	4613      	mov	r3, r2
     f92:	005b      	lsls	r3, r3, #1
     f94:	4413      	add	r3, r2
     f96:	009b      	lsls	r3, r3, #2
     f98:	440b      	add	r3, r1
     f9a:	791b      	ldrb	r3, [r3, #4]
     f9c:	2b00      	cmp	r3, #0
     f9e:	d00c      	beq.n	fba <Platform_Ipw_InitIntCtrl+0xaa>
        {   
            /* enables the interrupt request at interrupt controller level. */
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     fa0:	9b01      	ldr	r3, [sp, #4]
     fa2:	6859      	ldr	r1, [r3, #4]
     fa4:	9a03      	ldr	r2, [sp, #12]
     fa6:	4613      	mov	r3, r2
     fa8:	005b      	lsls	r3, r3, #1
     faa:	4413      	add	r3, r2
     fac:	009b      	lsls	r3, r3, #2
     fae:	440b      	add	r3, r1
     fb0:	681b      	ldr	r3, [r3, #0]
     fb2:	4618      	mov	r0, r3
     fb4:	f7ff fecc 	bl	d50 <IntCtrl_Ip_EnableIrq>
     fb8:	e00b      	b.n	fd2 <Platform_Ipw_InitIntCtrl+0xc2>
        }
        else
        {   
            /* disables the interrupt request at interrupt controller level.*/
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
     fba:	9b01      	ldr	r3, [sp, #4]
     fbc:	6859      	ldr	r1, [r3, #4]
     fbe:	9a03      	ldr	r2, [sp, #12]
     fc0:	4613      	mov	r3, r2
     fc2:	005b      	lsls	r3, r3, #1
     fc4:	4413      	add	r3, r2
     fc6:	009b      	lsls	r3, r3, #2
     fc8:	440b      	add	r3, r1
     fca:	681b      	ldr	r3, [r3, #0]
     fcc:	4618      	mov	r0, r3
     fce:	f7ff fec9 	bl	d64 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
     fd2:	9b03      	ldr	r3, [sp, #12]
     fd4:	3301      	adds	r3, #1
     fd6:	9303      	str	r3, [sp, #12]
     fd8:	9b01      	ldr	r3, [sp, #4]
     fda:	681b      	ldr	r3, [r3, #0]
     fdc:	9a03      	ldr	r2, [sp, #12]
     fde:	429a      	cmp	r2, r3
     fe0:	d39c      	bcc.n	f1c <Platform_Ipw_InitIntCtrl+0xc>
        }
    }

    return E_OK;
     fe2:	2300      	movs	r3, #0
}
     fe4:	4618      	mov	r0, r3
     fe6:	b005      	add	sp, #20
     fe8:	f85d fb04 	ldr.w	pc, [sp], #4

00000fec <Platform_Ipw_Init>:

/**
 * @brief         Initializes the platform settings based on user configuration.
 */
void Platform_Ipw_Init(const Platform_Ipw_ConfigType *pConfig)
{    
     fec:	b500      	push	{lr}
     fee:	b085      	sub	sp, #20
     ff0:	9001      	str	r0, [sp, #4]
#if ((PLATFORM_SYS_CFG == STD_ON)&&(INT_CTRL_IP_CORTEXM == STD_ON))
    uint8 irqIdx;
#endif
    Std_ReturnType ret = (Std_ReturnType)E_OK;
     ff2:	2300      	movs	r3, #0
     ff4:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Initialize interrupts at interrupt controller level */
    if (NULL_PTR != pConfig->pIntCtrlConfig)
     ff8:	9b01      	ldr	r3, [sp, #4]
     ffa:	681b      	ldr	r3, [r3, #0]
     ffc:	2b00      	cmp	r3, #0
     ffe:	d007      	beq.n	1010 <Platform_Ipw_Init+0x24>
    {
        ret = Platform_Ipw_InitIntCtrl(pConfig->pIntCtrlConfig);
    1000:	9b01      	ldr	r3, [sp, #4]
    1002:	681b      	ldr	r3, [r3, #0]
    1004:	4618      	mov	r0, r3
    1006:	f7ff ff83 	bl	f10 <Platform_Ipw_InitIntCtrl>
    100a:	4603      	mov	r3, r0
    100c:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    if(ret == (Std_ReturnType)E_OK)
    1010:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1014:	2b00      	cmp	r3, #0
            /* Call_System_Ip_SetAhbSlavePriority((pConfig->aSystemConfig)->bAhbSlavePriority); */
#endif
        }  
#endif
    }
}
    1016:	bf00      	nop
    1018:	b005      	add	sp, #20
    101a:	f85d fb04 	ldr.w	pc, [sp], #4

0000101e <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
    101e:	2300      	movs	r3, #0
}
    1020:	4618      	mov	r0, r3
    1022:	4770      	bx	lr

00001024 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    1024:	b082      	sub	sp, #8
    1026:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    1028:	2301      	movs	r3, #1
}
    102a:	4618      	mov	r0, r3
    102c:	b002      	add	sp, #8
    102e:	4770      	bx	lr

00001030 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    1030:	b082      	sub	sp, #8
    1032:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    1034:	bf00      	nop
    1036:	b002      	add	sp, #8
    1038:	4770      	bx	lr

0000103a <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    103a:	b082      	sub	sp, #8
    103c:	9001      	str	r0, [sp, #4]
    return Micros;
    103e:	9b01      	ldr	r3, [sp, #4]
}
    1040:	4618      	mov	r0, r3
    1042:	b002      	add	sp, #8
    1044:	4770      	bx	lr

00001046 <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    1046:	b500      	push	{lr}
    1048:	b083      	sub	sp, #12
    104a:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    104c:	f000 f86c 	bl	1128 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    1050:	bf00      	nop
    1052:	b003      	add	sp, #12
    1054:	f85d fb04 	ldr.w	pc, [sp], #4

00001058 <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    1058:	b500      	push	{lr}
    105a:	b085      	sub	sp, #20
    105c:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    105e:	2300      	movs	r3, #0
    1060:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1062:	9b01      	ldr	r3, [sp, #4]
    1064:	2b00      	cmp	r3, #0
    1066:	d003      	beq.n	1070 <OsIf_GetCounter+0x18>
    1068:	9b01      	ldr	r3, [sp, #4]
    106a:	2b01      	cmp	r3, #1
    106c:	d004      	beq.n	1078 <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    106e:	e007      	b.n	1080 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    1070:	f7ff ffd5 	bl	101e <OsIf_Timer_Dummy_GetCounter>
    1074:	9003      	str	r0, [sp, #12]
            break;
    1076:	e003      	b.n	1080 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    1078:	f000 f872 	bl	1160 <OsIf_Timer_System_GetCounter>
    107c:	9003      	str	r0, [sp, #12]
            break;
    107e:	bf00      	nop
    }

    return Value;
    1080:	9b03      	ldr	r3, [sp, #12]
}
    1082:	4618      	mov	r0, r3
    1084:	b005      	add	sp, #20
    1086:	f85d fb04 	ldr.w	pc, [sp], #4

0000108a <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    108a:	b500      	push	{lr}
    108c:	b085      	sub	sp, #20
    108e:	9001      	str	r0, [sp, #4]
    1090:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1092:	2300      	movs	r3, #0
    1094:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1096:	9b00      	ldr	r3, [sp, #0]
    1098:	2b00      	cmp	r3, #0
    109a:	d003      	beq.n	10a4 <OsIf_GetElapsed+0x1a>
    109c:	9b00      	ldr	r3, [sp, #0]
    109e:	2b01      	cmp	r3, #1
    10a0:	d005      	beq.n	10ae <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    10a2:	e009      	b.n	10b8 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    10a4:	9801      	ldr	r0, [sp, #4]
    10a6:	f7ff ffbd 	bl	1024 <OsIf_Timer_Dummy_GetElapsed>
    10aa:	9003      	str	r0, [sp, #12]
            break;
    10ac:	e004      	b.n	10b8 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    10ae:	9801      	ldr	r0, [sp, #4]
    10b0:	f000 f864 	bl	117c <OsIf_Timer_System_GetElapsed>
    10b4:	9003      	str	r0, [sp, #12]
            break;
    10b6:	bf00      	nop
    }

    return Value;
    10b8:	9b03      	ldr	r3, [sp, #12]
}
    10ba:	4618      	mov	r0, r3
    10bc:	b005      	add	sp, #20
    10be:	f85d fb04 	ldr.w	pc, [sp], #4

000010c2 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    10c2:	b500      	push	{lr}
    10c4:	b083      	sub	sp, #12
    10c6:	9001      	str	r0, [sp, #4]
    10c8:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    10ca:	9b00      	ldr	r3, [sp, #0]
    10cc:	2b00      	cmp	r3, #0
    10ce:	d003      	beq.n	10d8 <OsIf_SetTimerFrequency+0x16>
    10d0:	9b00      	ldr	r3, [sp, #0]
    10d2:	2b01      	cmp	r3, #1
    10d4:	d004      	beq.n	10e0 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    10d6:	e007      	b.n	10e8 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    10d8:	9801      	ldr	r0, [sp, #4]
    10da:	f7ff ffa9 	bl	1030 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    10de:	e003      	b.n	10e8 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    10e0:	9801      	ldr	r0, [sp, #4]
    10e2:	f000 f85b 	bl	119c <OsIf_Timer_System_SetTimerFrequency>
            break;
    10e6:	bf00      	nop
    }
}
    10e8:	bf00      	nop
    10ea:	b003      	add	sp, #12
    10ec:	f85d fb04 	ldr.w	pc, [sp], #4

000010f0 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    10f0:	b500      	push	{lr}
    10f2:	b085      	sub	sp, #20
    10f4:	9001      	str	r0, [sp, #4]
    10f6:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    10f8:	2300      	movs	r3, #0
    10fa:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    10fc:	9b00      	ldr	r3, [sp, #0]
    10fe:	2b00      	cmp	r3, #0
    1100:	d003      	beq.n	110a <OsIf_MicrosToTicks+0x1a>
    1102:	9b00      	ldr	r3, [sp, #0]
    1104:	2b01      	cmp	r3, #1
    1106:	d005      	beq.n	1114 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1108:	e009      	b.n	111e <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    110a:	9801      	ldr	r0, [sp, #4]
    110c:	f7ff ff95 	bl	103a <OsIf_Timer_Dummy_MicrosToTicks>
    1110:	9003      	str	r0, [sp, #12]
            break;
    1112:	e004      	b.n	111e <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    1114:	9801      	ldr	r0, [sp, #4]
    1116:	f000 f84f 	bl	11b8 <OsIf_Timer_System_MicrosToTicks>
    111a:	9003      	str	r0, [sp, #12]
            break;
    111c:	bf00      	nop
    }

    return Value;
    111e:	9b03      	ldr	r3, [sp, #12]
}
    1120:	4618      	mov	r0, r3
    1122:	b005      	add	sp, #20
    1124:	f85d fb04 	ldr.w	pc, [sp], #4

00001128 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    1128:	b500      	push	{lr}
    112a:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    112c:	2300      	movs	r3, #0
    112e:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    1130:	4a09      	ldr	r2, [pc, #36]	; (1158 <OsIf_Timer_System_Init+0x30>)
    1132:	9b01      	ldr	r3, [sp, #4]
    1134:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1138:	685a      	ldr	r2, [r3, #4]
    113a:	4908      	ldr	r1, [pc, #32]	; (115c <OsIf_Timer_System_Init+0x34>)
    113c:	9b01      	ldr	r3, [sp, #4]
    113e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    1142:	4a06      	ldr	r2, [pc, #24]	; (115c <OsIf_Timer_System_Init+0x34>)
    1144:	9b01      	ldr	r3, [sp, #4]
    1146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    114a:	4618      	mov	r0, r3
    114c:	f000 f868 	bl	1220 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    1150:	bf00      	nop
    1152:	b003      	add	sp, #12
    1154:	f85d fb04 	ldr.w	pc, [sp], #4
    1158:	0000a630 	.word	0x0000a630
    115c:	1fff8b40 	.word	0x1fff8b40

00001160 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    1160:	b500      	push	{lr}
    1162:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    1164:	2300      	movs	r3, #0
    1166:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1168:	2300      	movs	r3, #0
    116a:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    116c:	f000 f86c 	bl	1248 <OsIf_Timer_System_Internal_GetCounter>
    1170:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    1172:	9b01      	ldr	r3, [sp, #4]
}
    1174:	4618      	mov	r0, r3
    1176:	b003      	add	sp, #12
    1178:	f85d fb04 	ldr.w	pc, [sp], #4

0000117c <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    117c:	b500      	push	{lr}
    117e:	b085      	sub	sp, #20
    1180:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    1182:	2300      	movs	r3, #0
    1184:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    1186:	2300      	movs	r3, #0
    1188:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    118a:	9801      	ldr	r0, [sp, #4]
    118c:	f000 f864 	bl	1258 <OsIf_Timer_System_Internal_GetElapsed>
    1190:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    1192:	9b03      	ldr	r3, [sp, #12]
}
    1194:	4618      	mov	r0, r3
    1196:	b005      	add	sp, #20
    1198:	f85d fb04 	ldr.w	pc, [sp], #4

0000119c <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    119c:	b084      	sub	sp, #16
    119e:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    11a0:	2300      	movs	r3, #0
    11a2:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    11a4:	4903      	ldr	r1, [pc, #12]	; (11b4 <OsIf_Timer_System_SetTimerFrequency+0x18>)
    11a6:	9b03      	ldr	r3, [sp, #12]
    11a8:	9a01      	ldr	r2, [sp, #4]
    11aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    11ae:	bf00      	nop
    11b0:	b004      	add	sp, #16
    11b2:	4770      	bx	lr
    11b4:	1fff8b40 	.word	0x1fff8b40

000011b8 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    11b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    11ba:	b087      	sub	sp, #28
    11bc:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    11be:	2100      	movs	r1, #0
    11c0:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    11c2:	2100      	movs	r1, #0
    11c4:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    11c6:	9901      	ldr	r1, [sp, #4]
    11c8:	2000      	movs	r0, #0
    11ca:	460e      	mov	r6, r1
    11cc:	4607      	mov	r7, r0
    11ce:	4812      	ldr	r0, [pc, #72]	; (1218 <OsIf_Timer_System_MicrosToTicks+0x60>)
    11d0:	9904      	ldr	r1, [sp, #16]
    11d2:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    11d6:	2000      	movs	r0, #0
    11d8:	460c      	mov	r4, r1
    11da:	4605      	mov	r5, r0
    11dc:	fb04 f007 	mul.w	r0, r4, r7
    11e0:	fb06 f105 	mul.w	r1, r6, r5
    11e4:	4401      	add	r1, r0
    11e6:	fba6 2304 	umull	r2, r3, r6, r4
    11ea:	4419      	add	r1, r3
    11ec:	460b      	mov	r3, r1
    11ee:	e9cd 2302 	strd	r2, r3, [sp, #8]
    11f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    11f6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    11fa:	4a08      	ldr	r2, [pc, #32]	; (121c <OsIf_Timer_System_MicrosToTicks+0x64>)
    11fc:	f04f 0300 	mov.w	r3, #0
    1200:	f7ff f9d0 	bl	5a4 <__aeabi_uldivmod>
    1204:	4602      	mov	r2, r0
    1206:	460b      	mov	r3, r1
    1208:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    120c:	9b02      	ldr	r3, [sp, #8]
    120e:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    1210:	9b05      	ldr	r3, [sp, #20]
}
    1212:	4618      	mov	r0, r3
    1214:	b007      	add	sp, #28
    1216:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1218:	1fff8b40 	.word	0x1fff8b40
    121c:	000f4240 	.word	0x000f4240

00001220 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    1220:	b082      	sub	sp, #8
    1222:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    1224:	4b07      	ldr	r3, [pc, #28]	; (1244 <OsIf_Timer_System_Internal_Init+0x24>)
    1226:	2200      	movs	r2, #0
    1228:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    122a:	4b06      	ldr	r3, [pc, #24]	; (1244 <OsIf_Timer_System_Internal_Init+0x24>)
    122c:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    1230:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    1232:	4b04      	ldr	r3, [pc, #16]	; (1244 <OsIf_Timer_System_Internal_Init+0x24>)
    1234:	2200      	movs	r2, #0
    1236:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    1238:	4b02      	ldr	r3, [pc, #8]	; (1244 <OsIf_Timer_System_Internal_Init+0x24>)
    123a:	2205      	movs	r2, #5
    123c:	601a      	str	r2, [r3, #0]
}
    123e:	bf00      	nop
    1240:	b002      	add	sp, #8
    1242:	4770      	bx	lr
    1244:	e000e010 	.word	0xe000e010

00001248 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    1248:	4b02      	ldr	r3, [pc, #8]	; (1254 <OsIf_Timer_System_Internal_GetCounter+0xc>)
    124a:	689b      	ldr	r3, [r3, #8]
    124c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    1250:	4618      	mov	r0, r3
    1252:	4770      	bx	lr
    1254:	e000e010 	.word	0xe000e010

00001258 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    1258:	b084      	sub	sp, #16
    125a:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    125c:	4b10      	ldr	r3, [pc, #64]	; (12a0 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    125e:	689b      	ldr	r3, [r3, #8]
    1260:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    1264:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    1266:	2300      	movs	r3, #0
    1268:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    126a:	9b01      	ldr	r3, [sp, #4]
    126c:	681b      	ldr	r3, [r3, #0]
    126e:	9a02      	ldr	r2, [sp, #8]
    1270:	429a      	cmp	r2, r3
    1272:	d909      	bls.n	1288 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    1274:	9b01      	ldr	r3, [sp, #4]
    1276:	681a      	ldr	r2, [r3, #0]
    1278:	9b02      	ldr	r3, [sp, #8]
    127a:	1ad3      	subs	r3, r2, r3
    127c:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    1280:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    1284:	9303      	str	r3, [sp, #12]
    1286:	e004      	b.n	1292 <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    1288:	9b01      	ldr	r3, [sp, #4]
    128a:	681a      	ldr	r2, [r3, #0]
    128c:	9b02      	ldr	r3, [sp, #8]
    128e:	1ad3      	subs	r3, r2, r3
    1290:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    1292:	9b01      	ldr	r3, [sp, #4]
    1294:	9a02      	ldr	r2, [sp, #8]
    1296:	601a      	str	r2, [r3, #0]

    return dif;
    1298:	9b03      	ldr	r3, [sp, #12]
}
    129a:	4618      	mov	r0, r3
    129c:	b004      	add	sp, #16
    129e:	4770      	bx	lr
    12a0:	e000e010 	.word	0xe000e010

000012a4 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    12a4:	b082      	sub	sp, #8
    12a6:	9001      	str	r0, [sp, #4]
    12a8:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    12aa:	bf00      	nop
    12ac:	b002      	add	sp, #8
    12ae:	4770      	bx	lr

000012b0 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    12b0:	b500      	push	{lr}
    12b2:	b085      	sub	sp, #20
    12b4:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    12b6:	4b24      	ldr	r3, [pc, #144]	; (1348 <Clock_Ip_UpdateDriverContext+0x98>)
    12b8:	2201      	movs	r2, #1
    12ba:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    12bc:	4b23      	ldr	r3, [pc, #140]	; (134c <Clock_Ip_UpdateDriverContext+0x9c>)
    12be:	681b      	ldr	r3, [r3, #0]
    12c0:	2102      	movs	r1, #2
    12c2:	4618      	mov	r0, r3
    12c4:	f003 fc32 	bl	4b2c <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    12c8:	2300      	movs	r3, #0
    12ca:	f88d 300f 	strb.w	r3, [sp, #15]
    12ce:	e015      	b.n	12fc <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    12d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12d4:	9a01      	ldr	r2, [sp, #4]
    12d6:	334a      	adds	r3, #74	; 0x4a
    12d8:	00db      	lsls	r3, r3, #3
    12da:	4413      	add	r3, r2
    12dc:	6858      	ldr	r0, [r3, #4]
    12de:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12e2:	9a01      	ldr	r2, [sp, #4]
    12e4:	334a      	adds	r3, #74	; 0x4a
    12e6:	00db      	lsls	r3, r3, #3
    12e8:	4413      	add	r3, r2
    12ea:	689b      	ldr	r3, [r3, #8]
    12ec:	4619      	mov	r1, r3
    12ee:	f001 fadc 	bl	28aa <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    12f2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12f6:	3301      	adds	r3, #1
    12f8:	f88d 300f 	strb.w	r3, [sp, #15]
    12fc:	9b01      	ldr	r3, [sp, #4]
    12fe:	7bdb      	ldrb	r3, [r3, #15]
    1300:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1304:	429a      	cmp	r2, r3
    1306:	d3e3      	bcc.n	12d0 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    1308:	f000 f824 	bl	1354 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    130c:	2301      	movs	r3, #1
    130e:	f88d 300f 	strb.w	r3, [sp, #15]
    1312:	e00e      	b.n	1332 <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    1314:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1318:	9b01      	ldr	r3, [sp, #4]
    131a:	327e      	adds	r2, #126	; 0x7e
    131c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1320:	490b      	ldr	r1, [pc, #44]	; (1350 <Clock_Ip_UpdateDriverContext+0xa0>)
    1322:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1326:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    1328:	f89d 300f 	ldrb.w	r3, [sp, #15]
    132c:	3301      	adds	r3, #1
    132e:	f88d 300f 	strb.w	r3, [sp, #15]
    1332:	9b01      	ldr	r3, [sp, #4]
    1334:	7cdb      	ldrb	r3, [r3, #19]
    1336:	f89d 200f 	ldrb.w	r2, [sp, #15]
    133a:	429a      	cmp	r2, r3
    133c:	d3ea      	bcc.n	1314 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    133e:	bf00      	nop
    1340:	bf00      	nop
    1342:	b005      	add	sp, #20
    1344:	f85d fb04 	ldr.w	pc, [sp], #4
    1348:	1fff8b1a 	.word	0x1fff8b1a
    134c:	1fff8b44 	.word	0x1fff8b44
    1350:	1fff8b50 	.word	0x1fff8b50

00001354 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    1354:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    1356:	4b23      	ldr	r3, [pc, #140]	; (13e4 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1358:	781b      	ldrb	r3, [r3, #0]
    135a:	f083 0301 	eor.w	r3, r3, #1
    135e:	b2db      	uxtb	r3, r3
    1360:	2b00      	cmp	r3, #0
    1362:	d03d      	beq.n	13e0 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    1364:	4b1f      	ldr	r3, [pc, #124]	; (13e4 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1366:	2201      	movs	r2, #1
    1368:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    136a:	4b1f      	ldr	r3, [pc, #124]	; (13e8 <Clock_Ip_CallEmptyCallbacks+0x94>)
    136c:	685b      	ldr	r3, [r3, #4]
    136e:	2100      	movs	r1, #0
    1370:	2000      	movs	r0, #0
    1372:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    1374:	4b1c      	ldr	r3, [pc, #112]	; (13e8 <Clock_Ip_CallEmptyCallbacks+0x94>)
    1376:	689b      	ldr	r3, [r3, #8]
    1378:	2057      	movs	r0, #87	; 0x57
    137a:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    137c:	4b1b      	ldr	r3, [pc, #108]	; (13ec <Clock_Ip_CallEmptyCallbacks+0x98>)
    137e:	681b      	ldr	r3, [r3, #0]
    1380:	2000      	movs	r0, #0
    1382:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    1384:	4b1a      	ldr	r3, [pc, #104]	; (13f0 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    1386:	681b      	ldr	r3, [r3, #0]
    1388:	2000      	movs	r0, #0
    138a:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    138c:	4b19      	ldr	r3, [pc, #100]	; (13f4 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    138e:	681b      	ldr	r3, [r3, #0]
    1390:	2000      	movs	r0, #0
    1392:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1394:	4b18      	ldr	r3, [pc, #96]	; (13f8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    1396:	685b      	ldr	r3, [r3, #4]
    1398:	2000      	movs	r0, #0
    139a:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    139c:	4b16      	ldr	r3, [pc, #88]	; (13f8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    139e:	689b      	ldr	r3, [r3, #8]
    13a0:	2057      	movs	r0, #87	; 0x57
    13a2:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    13a4:	4b15      	ldr	r3, [pc, #84]	; (13fc <Clock_Ip_CallEmptyCallbacks+0xa8>)
    13a6:	681b      	ldr	r3, [r3, #0]
    13a8:	2000      	movs	r0, #0
    13aa:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    13ac:	4b13      	ldr	r3, [pc, #76]	; (13fc <Clock_Ip_CallEmptyCallbacks+0xa8>)
    13ae:	685b      	ldr	r3, [r3, #4]
    13b0:	2100      	movs	r1, #0
    13b2:	2057      	movs	r0, #87	; 0x57
    13b4:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    13b6:	4b12      	ldr	r3, [pc, #72]	; (1400 <Clock_Ip_CallEmptyCallbacks+0xac>)
    13b8:	681b      	ldr	r3, [r3, #0]
    13ba:	2000      	movs	r0, #0
    13bc:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    13be:	4b11      	ldr	r3, [pc, #68]	; (1404 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    13c0:	685b      	ldr	r3, [r3, #4]
    13c2:	2000      	movs	r0, #0
    13c4:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    13c6:	4b0f      	ldr	r3, [pc, #60]	; (1404 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    13c8:	689b      	ldr	r3, [r3, #8]
    13ca:	2057      	movs	r0, #87	; 0x57
    13cc:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    13ce:	4b0e      	ldr	r3, [pc, #56]	; (1408 <Clock_Ip_CallEmptyCallbacks+0xb4>)
    13d0:	685b      	ldr	r3, [r3, #4]
    13d2:	2000      	movs	r0, #0
    13d4:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    13d6:	4b0d      	ldr	r3, [pc, #52]	; (140c <Clock_Ip_CallEmptyCallbacks+0xb8>)
    13d8:	681b      	ldr	r3, [r3, #0]
    13da:	2100      	movs	r1, #0
    13dc:	2000      	movs	r0, #0
    13de:	4798      	blx	r3
    }
}
    13e0:	bf00      	nop
    13e2:	bd08      	pop	{r3, pc}
    13e4:	1fff8b48 	.word	0x1fff8b48
    13e8:	0000a0d0 	.word	0x0000a0d0
    13ec:	00009fe4 	.word	0x00009fe4
    13f0:	0000a020 	.word	0x0000a020
    13f4:	0000a028 	.word	0x0000a028
    13f8:	0000a050 	.word	0x0000a050
    13fc:	0000a05c 	.word	0x0000a05c
    1400:	0000a094 	.word	0x0000a094
    1404:	0000a0e0 	.word	0x0000a0e0
    1408:	0000a10c 	.word	0x0000a10c
    140c:	0000a108 	.word	0x0000a108

00001410 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    1410:	b500      	push	{lr}
    1412:	b085      	sub	sp, #20
    1414:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    1416:	9b01      	ldr	r3, [sp, #4]
    1418:	7adb      	ldrb	r3, [r3, #11]
    141a:	9303      	str	r3, [sp, #12]
    141c:	e01f      	b.n	145e <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    141e:	9b03      	ldr	r3, [sp, #12]
    1420:	1e5a      	subs	r2, r3, #1
    1422:	9b01      	ldr	r3, [sp, #4]
    1424:	320d      	adds	r2, #13
    1426:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    142a:	495a      	ldr	r1, [pc, #360]	; (1594 <Clock_Ip_ResetClockConfiguration+0x184>)
    142c:	4613      	mov	r3, r2
    142e:	00db      	lsls	r3, r3, #3
    1430:	4413      	add	r3, r2
    1432:	440b      	add	r3, r1
    1434:	3301      	adds	r3, #1
    1436:	781b      	ldrb	r3, [r3, #0]
    1438:	461a      	mov	r2, r3
    143a:	4b57      	ldr	r3, [pc, #348]	; (1598 <Clock_Ip_ResetClockConfiguration+0x188>)
    143c:	5c9b      	ldrb	r3, [r3, r2]
    143e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    1440:	4a56      	ldr	r2, [pc, #344]	; (159c <Clock_Ip_ResetClockConfiguration+0x18c>)
    1442:	9b02      	ldr	r3, [sp, #8]
    1444:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1448:	9a03      	ldr	r2, [sp, #12]
    144a:	3a01      	subs	r2, #1
    144c:	320d      	adds	r2, #13
    144e:	00d2      	lsls	r2, r2, #3
    1450:	9901      	ldr	r1, [sp, #4]
    1452:	440a      	add	r2, r1
    1454:	4610      	mov	r0, r2
    1456:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    1458:	9b03      	ldr	r3, [sp, #12]
    145a:	3b01      	subs	r3, #1
    145c:	9303      	str	r3, [sp, #12]
    145e:	9b03      	ldr	r3, [sp, #12]
    1460:	2b00      	cmp	r3, #0
    1462:	d1dc      	bne.n	141e <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    1464:	9b01      	ldr	r3, [sp, #4]
    1466:	7b9b      	ldrb	r3, [r3, #14]
    1468:	9303      	str	r3, [sp, #12]
    146a:	e026      	b.n	14ba <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    146c:	9b03      	ldr	r3, [sp, #12]
    146e:	3b01      	subs	r3, #1
    1470:	9a01      	ldr	r2, [sp, #4]
    1472:	3324      	adds	r3, #36	; 0x24
    1474:	011b      	lsls	r3, r3, #4
    1476:	4413      	add	r3, r2
    1478:	3304      	adds	r3, #4
    147a:	681a      	ldr	r2, [r3, #0]
    147c:	4945      	ldr	r1, [pc, #276]	; (1594 <Clock_Ip_ResetClockConfiguration+0x184>)
    147e:	4613      	mov	r3, r2
    1480:	00db      	lsls	r3, r3, #3
    1482:	4413      	add	r3, r2
    1484:	440b      	add	r3, r1
    1486:	3301      	adds	r3, #1
    1488:	781b      	ldrb	r3, [r3, #0]
    148a:	461a      	mov	r2, r3
    148c:	4b44      	ldr	r3, [pc, #272]	; (15a0 <Clock_Ip_ResetClockConfiguration+0x190>)
    148e:	5c9b      	ldrb	r3, [r3, r2]
    1490:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    1492:	4944      	ldr	r1, [pc, #272]	; (15a4 <Clock_Ip_ResetClockConfiguration+0x194>)
    1494:	9a02      	ldr	r2, [sp, #8]
    1496:	4613      	mov	r3, r2
    1498:	005b      	lsls	r3, r3, #1
    149a:	4413      	add	r3, r2
    149c:	009b      	lsls	r3, r3, #2
    149e:	440b      	add	r3, r1
    14a0:	681b      	ldr	r3, [r3, #0]
    14a2:	9a03      	ldr	r2, [sp, #12]
    14a4:	3a01      	subs	r2, #1
    14a6:	3224      	adds	r2, #36	; 0x24
    14a8:	0112      	lsls	r2, r2, #4
    14aa:	9901      	ldr	r1, [sp, #4]
    14ac:	440a      	add	r2, r1
    14ae:	3204      	adds	r2, #4
    14b0:	4610      	mov	r0, r2
    14b2:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    14b4:	9b03      	ldr	r3, [sp, #12]
    14b6:	3b01      	subs	r3, #1
    14b8:	9303      	str	r3, [sp, #12]
    14ba:	9b03      	ldr	r3, [sp, #12]
    14bc:	2b00      	cmp	r3, #0
    14be:	d1d5      	bne.n	146c <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    14c0:	9b01      	ldr	r3, [sp, #4]
    14c2:	7a9b      	ldrb	r3, [r3, #10]
    14c4:	9303      	str	r3, [sp, #12]
    14c6:	e02a      	b.n	151e <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    14c8:	9b03      	ldr	r3, [sp, #12]
    14ca:	1e5a      	subs	r2, r3, #1
    14cc:	9901      	ldr	r1, [sp, #4]
    14ce:	4613      	mov	r3, r2
    14d0:	009b      	lsls	r3, r3, #2
    14d2:	4413      	add	r3, r2
    14d4:	00db      	lsls	r3, r3, #3
    14d6:	440b      	add	r3, r1
    14d8:	3340      	adds	r3, #64	; 0x40
    14da:	681a      	ldr	r2, [r3, #0]
    14dc:	492d      	ldr	r1, [pc, #180]	; (1594 <Clock_Ip_ResetClockConfiguration+0x184>)
    14de:	4613      	mov	r3, r2
    14e0:	00db      	lsls	r3, r3, #3
    14e2:	4413      	add	r3, r2
    14e4:	440b      	add	r3, r1
    14e6:	3301      	adds	r3, #1
    14e8:	781b      	ldrb	r3, [r3, #0]
    14ea:	461a      	mov	r2, r3
    14ec:	4b2e      	ldr	r3, [pc, #184]	; (15a8 <Clock_Ip_ResetClockConfiguration+0x198>)
    14ee:	5c9b      	ldrb	r3, [r3, r2]
    14f0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    14f2:	492e      	ldr	r1, [pc, #184]	; (15ac <Clock_Ip_ResetClockConfiguration+0x19c>)
    14f4:	9a02      	ldr	r2, [sp, #8]
    14f6:	4613      	mov	r3, r2
    14f8:	009b      	lsls	r3, r3, #2
    14fa:	4413      	add	r3, r2
    14fc:	009b      	lsls	r3, r3, #2
    14fe:	440b      	add	r3, r1
    1500:	6819      	ldr	r1, [r3, #0]
    1502:	9b03      	ldr	r3, [sp, #12]
    1504:	1e5a      	subs	r2, r3, #1
    1506:	4613      	mov	r3, r2
    1508:	009b      	lsls	r3, r3, #2
    150a:	4413      	add	r3, r2
    150c:	00db      	lsls	r3, r3, #3
    150e:	3340      	adds	r3, #64	; 0x40
    1510:	9a01      	ldr	r2, [sp, #4]
    1512:	4413      	add	r3, r2
    1514:	4618      	mov	r0, r3
    1516:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    1518:	9b03      	ldr	r3, [sp, #12]
    151a:	3b01      	subs	r3, #1
    151c:	9303      	str	r3, [sp, #12]
    151e:	9b03      	ldr	r3, [sp, #12]
    1520:	2b00      	cmp	r3, #0
    1522:	d1d1      	bne.n	14c8 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    1524:	9b01      	ldr	r3, [sp, #4]
    1526:	7a5b      	ldrb	r3, [r3, #9]
    1528:	9303      	str	r3, [sp, #12]
    152a:	e02b      	b.n	1584 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    152c:	9b03      	ldr	r3, [sp, #12]
    152e:	1e5a      	subs	r2, r3, #1
    1530:	9901      	ldr	r1, [sp, #4]
    1532:	4613      	mov	r3, r2
    1534:	009b      	lsls	r3, r3, #2
    1536:	4413      	add	r3, r2
    1538:	009b      	lsls	r3, r3, #2
    153a:	440b      	add	r3, r1
    153c:	332c      	adds	r3, #44	; 0x2c
    153e:	681a      	ldr	r2, [r3, #0]
    1540:	4914      	ldr	r1, [pc, #80]	; (1594 <Clock_Ip_ResetClockConfiguration+0x184>)
    1542:	4613      	mov	r3, r2
    1544:	00db      	lsls	r3, r3, #3
    1546:	4413      	add	r3, r2
    1548:	440b      	add	r3, r1
    154a:	3301      	adds	r3, #1
    154c:	781b      	ldrb	r3, [r3, #0]
    154e:	461a      	mov	r2, r3
    1550:	4b17      	ldr	r3, [pc, #92]	; (15b0 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    1552:	5c9b      	ldrb	r3, [r3, r2]
    1554:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    1556:	4917      	ldr	r1, [pc, #92]	; (15b4 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    1558:	9a02      	ldr	r2, [sp, #8]
    155a:	4613      	mov	r3, r2
    155c:	009b      	lsls	r3, r3, #2
    155e:	4413      	add	r3, r2
    1560:	009b      	lsls	r3, r3, #2
    1562:	440b      	add	r3, r1
    1564:	6819      	ldr	r1, [r3, #0]
    1566:	9b03      	ldr	r3, [sp, #12]
    1568:	1e5a      	subs	r2, r3, #1
    156a:	4613      	mov	r3, r2
    156c:	009b      	lsls	r3, r3, #2
    156e:	4413      	add	r3, r2
    1570:	009b      	lsls	r3, r3, #2
    1572:	3328      	adds	r3, #40	; 0x28
    1574:	9a01      	ldr	r2, [sp, #4]
    1576:	4413      	add	r3, r2
    1578:	3304      	adds	r3, #4
    157a:	4618      	mov	r0, r3
    157c:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    157e:	9b03      	ldr	r3, [sp, #12]
    1580:	3b01      	subs	r3, #1
    1582:	9303      	str	r3, [sp, #12]
    1584:	9b03      	ldr	r3, [sp, #12]
    1586:	2b00      	cmp	r3, #0
    1588:	d1d0      	bne.n	152c <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    158a:	bf00      	nop
    158c:	bf00      	nop
    158e:	b005      	add	sp, #20
    1590:	f85d fb04 	ldr.w	pc, [sp], #4
    1594:	00009ad4 	.word	0x00009ad4
    1598:	00009aa4 	.word	0x00009aa4
    159c:	0000a10c 	.word	0x0000a10c
    15a0:	00009a84 	.word	0x00009a84
    15a4:	0000a050 	.word	0x0000a050
    15a8:	00009a94 	.word	0x00009a94
    15ac:	0000a0e0 	.word	0x0000a0e0
    15b0:	00009a54 	.word	0x00009a54
    15b4:	0000a028 	.word	0x0000a028

000015b8 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    15b8:	b500      	push	{lr}
    15ba:	b085      	sub	sp, #20
    15bc:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    15be:	2301      	movs	r3, #1
    15c0:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    15c2:	9801      	ldr	r0, [sp, #4]
    15c4:	f000 f818 	bl	15f8 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    15c8:	4b0a      	ldr	r3, [pc, #40]	; (15f4 <Clock_Ip_Init+0x3c>)
    15ca:	781b      	ldrb	r3, [r3, #0]
    15cc:	2b00      	cmp	r3, #0
    15ce:	d00a      	beq.n	15e6 <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    15d0:	f000 fb74 	bl	1cbc <Clock_Ip_GetPllStatus>
    15d4:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    15d6:	9b02      	ldr	r3, [sp, #8]
    15d8:	2b00      	cmp	r3, #0
    15da:	d106      	bne.n	15ea <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    15dc:	f000 fbf2 	bl	1dc4 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    15e0:	2300      	movs	r3, #0
    15e2:	9303      	str	r3, [sp, #12]
    15e4:	e001      	b.n	15ea <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    15e6:	2300      	movs	r3, #0
    15e8:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    15ea:	9b03      	ldr	r3, [sp, #12]
}
    15ec:	4618      	mov	r0, r3
    15ee:	b005      	add	sp, #20
    15f0:	f85d fb04 	ldr.w	pc, [sp], #4
    15f4:	1fff8b4c 	.word	0x1fff8b4c

000015f8 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    15f8:	b510      	push	{r4, lr}
    15fa:	b084      	sub	sp, #16
    15fc:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    15fe:	4a9f      	ldr	r2, [pc, #636]	; (187c <Clock_Ip_InitClock+0x284>)
    1600:	9b01      	ldr	r3, [sp, #4]
    1602:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    1604:	2101      	movs	r1, #1
    1606:	9801      	ldr	r0, [sp, #4]
    1608:	f003 fa90 	bl	4b2c <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    160c:	4b9b      	ldr	r3, [pc, #620]	; (187c <Clock_Ip_InitClock+0x284>)
    160e:	681b      	ldr	r3, [r3, #0]
    1610:	2b00      	cmp	r3, #0
    1612:	d030      	beq.n	1676 <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    1614:	2300      	movs	r3, #0
    1616:	9303      	str	r3, [sp, #12]
    1618:	e027      	b.n	166a <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    161a:	9901      	ldr	r1, [sp, #4]
    161c:	9a03      	ldr	r2, [sp, #12]
    161e:	4613      	mov	r3, r2
    1620:	009b      	lsls	r3, r3, #2
    1622:	4413      	add	r3, r2
    1624:	009b      	lsls	r3, r3, #2
    1626:	440b      	add	r3, r1
    1628:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    162c:	681a      	ldr	r2, [r3, #0]
    162e:	4994      	ldr	r1, [pc, #592]	; (1880 <Clock_Ip_InitClock+0x288>)
    1630:	4613      	mov	r3, r2
    1632:	00db      	lsls	r3, r3, #3
    1634:	4413      	add	r3, r2
    1636:	440b      	add	r3, r1
    1638:	3301      	adds	r3, #1
    163a:	781b      	ldrb	r3, [r3, #0]
    163c:	461a      	mov	r2, r3
    163e:	4b91      	ldr	r3, [pc, #580]	; (1884 <Clock_Ip_InitClock+0x28c>)
    1640:	5c9b      	ldrb	r3, [r3, r2]
    1642:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    1644:	4a90      	ldr	r2, [pc, #576]	; (1888 <Clock_Ip_InitClock+0x290>)
    1646:	9b02      	ldr	r3, [sp, #8]
    1648:	011b      	lsls	r3, r3, #4
    164a:	4413      	add	r3, r2
    164c:	6819      	ldr	r1, [r3, #0]
    164e:	9a03      	ldr	r2, [sp, #12]
    1650:	4613      	mov	r3, r2
    1652:	009b      	lsls	r3, r3, #2
    1654:	4413      	add	r3, r2
    1656:	009b      	lsls	r3, r3, #2
    1658:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    165c:	9a01      	ldr	r2, [sp, #4]
    165e:	4413      	add	r3, r2
    1660:	4618      	mov	r0, r3
    1662:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    1664:	9b03      	ldr	r3, [sp, #12]
    1666:	3301      	adds	r3, #1
    1668:	9303      	str	r3, [sp, #12]
    166a:	9b01      	ldr	r3, [sp, #4]
    166c:	7c9b      	ldrb	r3, [r3, #18]
    166e:	461a      	mov	r2, r3
    1670:	9b03      	ldr	r3, [sp, #12]
    1672:	4293      	cmp	r3, r2
    1674:	d3d1      	bcc.n	161a <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    1676:	9801      	ldr	r0, [sp, #4]
    1678:	f7ff feca 	bl	1410 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    167c:	2300      	movs	r3, #0
    167e:	9303      	str	r3, [sp, #12]
    1680:	e029      	b.n	16d6 <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    1682:	9901      	ldr	r1, [sp, #4]
    1684:	9a03      	ldr	r2, [sp, #12]
    1686:	4613      	mov	r3, r2
    1688:	005b      	lsls	r3, r3, #1
    168a:	4413      	add	r3, r2
    168c:	009b      	lsls	r3, r3, #2
    168e:	440b      	add	r3, r1
    1690:	3314      	adds	r3, #20
    1692:	681a      	ldr	r2, [r3, #0]
    1694:	497a      	ldr	r1, [pc, #488]	; (1880 <Clock_Ip_InitClock+0x288>)
    1696:	4613      	mov	r3, r2
    1698:	00db      	lsls	r3, r3, #3
    169a:	4413      	add	r3, r2
    169c:	440b      	add	r3, r1
    169e:	3301      	adds	r3, #1
    16a0:	781b      	ldrb	r3, [r3, #0]
    16a2:	461a      	mov	r2, r3
    16a4:	4b79      	ldr	r3, [pc, #484]	; (188c <Clock_Ip_InitClock+0x294>)
    16a6:	5c9b      	ldrb	r3, [r3, r2]
    16a8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    16aa:	4979      	ldr	r1, [pc, #484]	; (1890 <Clock_Ip_InitClock+0x298>)
    16ac:	9a02      	ldr	r2, [sp, #8]
    16ae:	4613      	mov	r3, r2
    16b0:	005b      	lsls	r3, r3, #1
    16b2:	4413      	add	r3, r2
    16b4:	009b      	lsls	r3, r3, #2
    16b6:	440b      	add	r3, r1
    16b8:	6819      	ldr	r1, [r3, #0]
    16ba:	9a03      	ldr	r2, [sp, #12]
    16bc:	4613      	mov	r3, r2
    16be:	005b      	lsls	r3, r3, #1
    16c0:	4413      	add	r3, r2
    16c2:	009b      	lsls	r3, r3, #2
    16c4:	3310      	adds	r3, #16
    16c6:	9a01      	ldr	r2, [sp, #4]
    16c8:	4413      	add	r3, r2
    16ca:	3304      	adds	r3, #4
    16cc:	4618      	mov	r0, r3
    16ce:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    16d0:	9b03      	ldr	r3, [sp, #12]
    16d2:	3301      	adds	r3, #1
    16d4:	9303      	str	r3, [sp, #12]
    16d6:	9b01      	ldr	r3, [sp, #4]
    16d8:	7a1b      	ldrb	r3, [r3, #8]
    16da:	461a      	mov	r2, r3
    16dc:	9b03      	ldr	r3, [sp, #12]
    16de:	4293      	cmp	r3, r2
    16e0:	d3cf      	bcc.n	1682 <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    16e2:	2300      	movs	r3, #0
    16e4:	9303      	str	r3, [sp, #12]
    16e6:	e02a      	b.n	173e <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    16e8:	9901      	ldr	r1, [sp, #4]
    16ea:	9a03      	ldr	r2, [sp, #12]
    16ec:	4613      	mov	r3, r2
    16ee:	009b      	lsls	r3, r3, #2
    16f0:	4413      	add	r3, r2
    16f2:	009b      	lsls	r3, r3, #2
    16f4:	440b      	add	r3, r1
    16f6:	332c      	adds	r3, #44	; 0x2c
    16f8:	681a      	ldr	r2, [r3, #0]
    16fa:	4961      	ldr	r1, [pc, #388]	; (1880 <Clock_Ip_InitClock+0x288>)
    16fc:	4613      	mov	r3, r2
    16fe:	00db      	lsls	r3, r3, #3
    1700:	4413      	add	r3, r2
    1702:	440b      	add	r3, r1
    1704:	3301      	adds	r3, #1
    1706:	781b      	ldrb	r3, [r3, #0]
    1708:	461a      	mov	r2, r3
    170a:	4b62      	ldr	r3, [pc, #392]	; (1894 <Clock_Ip_InitClock+0x29c>)
    170c:	5c9b      	ldrb	r3, [r3, r2]
    170e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    1710:	4961      	ldr	r1, [pc, #388]	; (1898 <Clock_Ip_InitClock+0x2a0>)
    1712:	9a02      	ldr	r2, [sp, #8]
    1714:	4613      	mov	r3, r2
    1716:	009b      	lsls	r3, r3, #2
    1718:	4413      	add	r3, r2
    171a:	009b      	lsls	r3, r3, #2
    171c:	440b      	add	r3, r1
    171e:	3304      	adds	r3, #4
    1720:	6819      	ldr	r1, [r3, #0]
    1722:	9a03      	ldr	r2, [sp, #12]
    1724:	4613      	mov	r3, r2
    1726:	009b      	lsls	r3, r3, #2
    1728:	4413      	add	r3, r2
    172a:	009b      	lsls	r3, r3, #2
    172c:	3328      	adds	r3, #40	; 0x28
    172e:	9a01      	ldr	r2, [sp, #4]
    1730:	4413      	add	r3, r2
    1732:	3304      	adds	r3, #4
    1734:	4618      	mov	r0, r3
    1736:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    1738:	9b03      	ldr	r3, [sp, #12]
    173a:	3301      	adds	r3, #1
    173c:	9303      	str	r3, [sp, #12]
    173e:	9b01      	ldr	r3, [sp, #4]
    1740:	7a5b      	ldrb	r3, [r3, #9]
    1742:	461a      	mov	r2, r3
    1744:	9b03      	ldr	r3, [sp, #12]
    1746:	4293      	cmp	r3, r2
    1748:	d3ce      	bcc.n	16e8 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    174a:	9801      	ldr	r0, [sp, #4]
    174c:	f7ff fdb0 	bl	12b0 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    1750:	2300      	movs	r3, #0
    1752:	9303      	str	r3, [sp, #12]
    1754:	e028      	b.n	17a8 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    1756:	9901      	ldr	r1, [sp, #4]
    1758:	9a03      	ldr	r2, [sp, #12]
    175a:	4613      	mov	r3, r2
    175c:	009b      	lsls	r3, r3, #2
    175e:	4413      	add	r3, r2
    1760:	009b      	lsls	r3, r3, #2
    1762:	440b      	add	r3, r1
    1764:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    1768:	681a      	ldr	r2, [r3, #0]
    176a:	4945      	ldr	r1, [pc, #276]	; (1880 <Clock_Ip_InitClock+0x288>)
    176c:	4613      	mov	r3, r2
    176e:	00db      	lsls	r3, r3, #3
    1770:	4413      	add	r3, r2
    1772:	440b      	add	r3, r1
    1774:	3301      	adds	r3, #1
    1776:	781b      	ldrb	r3, [r3, #0]
    1778:	461a      	mov	r2, r3
    177a:	4b48      	ldr	r3, [pc, #288]	; (189c <Clock_Ip_InitClock+0x2a4>)
    177c:	5c9b      	ldrb	r3, [r3, r2]
    177e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    1780:	4a47      	ldr	r2, [pc, #284]	; (18a0 <Clock_Ip_InitClock+0x2a8>)
    1782:	9b02      	ldr	r3, [sp, #8]
    1784:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    1788:	9a03      	ldr	r2, [sp, #12]
    178a:	4613      	mov	r3, r2
    178c:	009b      	lsls	r3, r3, #2
    178e:	4413      	add	r3, r2
    1790:	009b      	lsls	r3, r3, #2
    1792:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    1796:	9a01      	ldr	r2, [sp, #4]
    1798:	4413      	add	r3, r2
    179a:	3304      	adds	r3, #4
    179c:	9903      	ldr	r1, [sp, #12]
    179e:	4618      	mov	r0, r3
    17a0:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    17a2:	9b03      	ldr	r3, [sp, #12]
    17a4:	3301      	adds	r3, #1
    17a6:	9303      	str	r3, [sp, #12]
    17a8:	9b01      	ldr	r3, [sp, #4]
    17aa:	7c5b      	ldrb	r3, [r3, #17]
    17ac:	461a      	mov	r2, r3
    17ae:	9b03      	ldr	r3, [sp, #12]
    17b0:	4293      	cmp	r3, r2
    17b2:	d3d0      	bcc.n	1756 <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    17b4:	2300      	movs	r3, #0
    17b6:	9303      	str	r3, [sp, #12]
    17b8:	e026      	b.n	1808 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    17ba:	9901      	ldr	r1, [sp, #4]
    17bc:	9a03      	ldr	r2, [sp, #12]
    17be:	4613      	mov	r3, r2
    17c0:	005b      	lsls	r3, r3, #1
    17c2:	4413      	add	r3, r2
    17c4:	009b      	lsls	r3, r3, #2
    17c6:	440b      	add	r3, r1
    17c8:	f503 730e 	add.w	r3, r3, #568	; 0x238
    17cc:	681a      	ldr	r2, [r3, #0]
    17ce:	492c      	ldr	r1, [pc, #176]	; (1880 <Clock_Ip_InitClock+0x288>)
    17d0:	4613      	mov	r3, r2
    17d2:	00db      	lsls	r3, r3, #3
    17d4:	4413      	add	r3, r2
    17d6:	440b      	add	r3, r1
    17d8:	3301      	adds	r3, #1
    17da:	781b      	ldrb	r3, [r3, #0]
    17dc:	461a      	mov	r2, r3
    17de:	4b31      	ldr	r3, [pc, #196]	; (18a4 <Clock_Ip_InitClock+0x2ac>)
    17e0:	5c9b      	ldrb	r3, [r3, r2]
    17e2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    17e4:	4a30      	ldr	r2, [pc, #192]	; (18a8 <Clock_Ip_InitClock+0x2b0>)
    17e6:	9b02      	ldr	r3, [sp, #8]
    17e8:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    17ec:	9a03      	ldr	r2, [sp, #12]
    17ee:	4613      	mov	r3, r2
    17f0:	005b      	lsls	r3, r3, #1
    17f2:	4413      	add	r3, r2
    17f4:	009b      	lsls	r3, r3, #2
    17f6:	f503 730e 	add.w	r3, r3, #568	; 0x238
    17fa:	9a01      	ldr	r2, [sp, #4]
    17fc:	4413      	add	r3, r2
    17fe:	4618      	mov	r0, r3
    1800:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1802:	9b03      	ldr	r3, [sp, #12]
    1804:	3301      	adds	r3, #1
    1806:	9303      	str	r3, [sp, #12]
    1808:	9b01      	ldr	r3, [sp, #4]
    180a:	7b5b      	ldrb	r3, [r3, #13]
    180c:	461a      	mov	r2, r3
    180e:	9b03      	ldr	r3, [sp, #12]
    1810:	4293      	cmp	r3, r2
    1812:	d3d2      	bcc.n	17ba <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    1814:	2300      	movs	r3, #0
    1816:	9303      	str	r3, [sp, #12]
    1818:	e026      	b.n	1868 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    181a:	9901      	ldr	r1, [sp, #4]
    181c:	9a03      	ldr	r2, [sp, #12]
    181e:	4613      	mov	r3, r2
    1820:	005b      	lsls	r3, r3, #1
    1822:	4413      	add	r3, r2
    1824:	009b      	lsls	r3, r3, #2
    1826:	440b      	add	r3, r1
    1828:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    182c:	681a      	ldr	r2, [r3, #0]
    182e:	4914      	ldr	r1, [pc, #80]	; (1880 <Clock_Ip_InitClock+0x288>)
    1830:	4613      	mov	r3, r2
    1832:	00db      	lsls	r3, r3, #3
    1834:	4413      	add	r3, r2
    1836:	440b      	add	r3, r1
    1838:	3301      	adds	r3, #1
    183a:	781b      	ldrb	r3, [r3, #0]
    183c:	461a      	mov	r2, r3
    183e:	4b1b      	ldr	r3, [pc, #108]	; (18ac <Clock_Ip_InitClock+0x2b4>)
    1840:	5c9b      	ldrb	r3, [r3, r2]
    1842:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    1844:	4a1a      	ldr	r2, [pc, #104]	; (18b0 <Clock_Ip_InitClock+0x2b8>)
    1846:	9b02      	ldr	r3, [sp, #8]
    1848:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    184c:	9a03      	ldr	r2, [sp, #12]
    184e:	4613      	mov	r3, r2
    1850:	005b      	lsls	r3, r3, #1
    1852:	4413      	add	r3, r2
    1854:	009b      	lsls	r3, r3, #2
    1856:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    185a:	9a01      	ldr	r2, [sp, #4]
    185c:	4413      	add	r3, r2
    185e:	4618      	mov	r0, r3
    1860:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    1862:	9b03      	ldr	r3, [sp, #12]
    1864:	3301      	adds	r3, #1
    1866:	9303      	str	r3, [sp, #12]
    1868:	9b01      	ldr	r3, [sp, #4]
    186a:	7b1b      	ldrb	r3, [r3, #12]
    186c:	461a      	mov	r2, r3
    186e:	9b03      	ldr	r3, [sp, #12]
    1870:	4293      	cmp	r3, r2
    1872:	d3d2      	bcc.n	181a <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1874:	2300      	movs	r3, #0
    1876:	9303      	str	r3, [sp, #12]
    1878:	e044      	b.n	1904 <Clock_Ip_InitClock+0x30c>
    187a:	bf00      	nop
    187c:	1fff8b44 	.word	0x1fff8b44
    1880:	00009ad4 	.word	0x00009ad4
    1884:	00009ac4 	.word	0x00009ac4
    1888:	0000a0d0 	.word	0x0000a0d0
    188c:	00009a64 	.word	0x00009a64
    1890:	0000a094 	.word	0x0000a094
    1894:	00009a54 	.word	0x00009a54
    1898:	0000a028 	.word	0x0000a028
    189c:	00009ab4 	.word	0x00009ab4
    18a0:	0000a108 	.word	0x0000a108
    18a4:	00009a44 	.word	0x00009a44
    18a8:	0000a020 	.word	0x0000a020
    18ac:	00009a34 	.word	0x00009a34
    18b0:	00009fe4 	.word	0x00009fe4
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    18b4:	9901      	ldr	r1, [sp, #4]
    18b6:	9a03      	ldr	r2, [sp, #12]
    18b8:	4613      	mov	r3, r2
    18ba:	005b      	lsls	r3, r3, #1
    18bc:	4413      	add	r3, r2
    18be:	009b      	lsls	r3, r3, #2
    18c0:	440b      	add	r3, r1
    18c2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    18c6:	681a      	ldr	r2, [r3, #0]
    18c8:	49ac      	ldr	r1, [pc, #688]	; (1b7c <Clock_Ip_InitClock+0x584>)
    18ca:	4613      	mov	r3, r2
    18cc:	00db      	lsls	r3, r3, #3
    18ce:	4413      	add	r3, r2
    18d0:	440b      	add	r3, r1
    18d2:	3301      	adds	r3, #1
    18d4:	781b      	ldrb	r3, [r3, #0]
    18d6:	461a      	mov	r2, r3
    18d8:	4ba9      	ldr	r3, [pc, #676]	; (1b80 <Clock_Ip_InitClock+0x588>)
    18da:	5c9b      	ldrb	r3, [r3, r2]
    18dc:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    18de:	4aa9      	ldr	r2, [pc, #676]	; (1b84 <Clock_Ip_InitClock+0x58c>)
    18e0:	9b02      	ldr	r3, [sp, #8]
    18e2:	00db      	lsls	r3, r3, #3
    18e4:	4413      	add	r3, r2
    18e6:	6859      	ldr	r1, [r3, #4]
    18e8:	9a03      	ldr	r2, [sp, #12]
    18ea:	4613      	mov	r3, r2
    18ec:	005b      	lsls	r3, r3, #1
    18ee:	4413      	add	r3, r2
    18f0:	009b      	lsls	r3, r3, #2
    18f2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    18f6:	9a01      	ldr	r2, [sp, #4]
    18f8:	4413      	add	r3, r2
    18fa:	4618      	mov	r0, r3
    18fc:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    18fe:	9b03      	ldr	r3, [sp, #12]
    1900:	3301      	adds	r3, #1
    1902:	9303      	str	r3, [sp, #12]
    1904:	9b01      	ldr	r3, [sp, #4]
    1906:	7b5b      	ldrb	r3, [r3, #13]
    1908:	461a      	mov	r2, r3
    190a:	9b03      	ldr	r3, [sp, #12]
    190c:	4293      	cmp	r3, r2
    190e:	d3d1      	bcc.n	18b4 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    1910:	2300      	movs	r3, #0
    1912:	9303      	str	r3, [sp, #12]
    1914:	e029      	b.n	196a <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    1916:	9901      	ldr	r1, [sp, #4]
    1918:	9a03      	ldr	r2, [sp, #12]
    191a:	4613      	mov	r3, r2
    191c:	009b      	lsls	r3, r3, #2
    191e:	4413      	add	r3, r2
    1920:	00db      	lsls	r3, r3, #3
    1922:	440b      	add	r3, r1
    1924:	3340      	adds	r3, #64	; 0x40
    1926:	681a      	ldr	r2, [r3, #0]
    1928:	4994      	ldr	r1, [pc, #592]	; (1b7c <Clock_Ip_InitClock+0x584>)
    192a:	4613      	mov	r3, r2
    192c:	00db      	lsls	r3, r3, #3
    192e:	4413      	add	r3, r2
    1930:	440b      	add	r3, r1
    1932:	3301      	adds	r3, #1
    1934:	781b      	ldrb	r3, [r3, #0]
    1936:	461a      	mov	r2, r3
    1938:	4b93      	ldr	r3, [pc, #588]	; (1b88 <Clock_Ip_InitClock+0x590>)
    193a:	5c9b      	ldrb	r3, [r3, r2]
    193c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    193e:	4993      	ldr	r1, [pc, #588]	; (1b8c <Clock_Ip_InitClock+0x594>)
    1940:	9a02      	ldr	r2, [sp, #8]
    1942:	4613      	mov	r3, r2
    1944:	009b      	lsls	r3, r3, #2
    1946:	4413      	add	r3, r2
    1948:	009b      	lsls	r3, r3, #2
    194a:	440b      	add	r3, r1
    194c:	3304      	adds	r3, #4
    194e:	6819      	ldr	r1, [r3, #0]
    1950:	9a03      	ldr	r2, [sp, #12]
    1952:	4613      	mov	r3, r2
    1954:	009b      	lsls	r3, r3, #2
    1956:	4413      	add	r3, r2
    1958:	00db      	lsls	r3, r3, #3
    195a:	3340      	adds	r3, #64	; 0x40
    195c:	9a01      	ldr	r2, [sp, #4]
    195e:	4413      	add	r3, r2
    1960:	4618      	mov	r0, r3
    1962:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    1964:	9b03      	ldr	r3, [sp, #12]
    1966:	3301      	adds	r3, #1
    1968:	9303      	str	r3, [sp, #12]
    196a:	9b01      	ldr	r3, [sp, #4]
    196c:	7a9b      	ldrb	r3, [r3, #10]
    196e:	461a      	mov	r2, r3
    1970:	9b03      	ldr	r3, [sp, #12]
    1972:	4293      	cmp	r3, r2
    1974:	d3cf      	bcc.n	1916 <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    1976:	2300      	movs	r3, #0
    1978:	9303      	str	r3, [sp, #12]
    197a:	e029      	b.n	19d0 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    197c:	9901      	ldr	r1, [sp, #4]
    197e:	9a03      	ldr	r2, [sp, #12]
    1980:	4613      	mov	r3, r2
    1982:	009b      	lsls	r3, r3, #2
    1984:	4413      	add	r3, r2
    1986:	009b      	lsls	r3, r3, #2
    1988:	440b      	add	r3, r1
    198a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    198e:	681a      	ldr	r2, [r3, #0]
    1990:	497a      	ldr	r1, [pc, #488]	; (1b7c <Clock_Ip_InitClock+0x584>)
    1992:	4613      	mov	r3, r2
    1994:	00db      	lsls	r3, r3, #3
    1996:	4413      	add	r3, r2
    1998:	440b      	add	r3, r1
    199a:	3301      	adds	r3, #1
    199c:	781b      	ldrb	r3, [r3, #0]
    199e:	461a      	mov	r2, r3
    19a0:	4b7b      	ldr	r3, [pc, #492]	; (1b90 <Clock_Ip_InitClock+0x598>)
    19a2:	5c9b      	ldrb	r3, [r3, r2]
    19a4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    19a6:	4a7b      	ldr	r2, [pc, #492]	; (1b94 <Clock_Ip_InitClock+0x59c>)
    19a8:	9b02      	ldr	r3, [sp, #8]
    19aa:	011b      	lsls	r3, r3, #4
    19ac:	4413      	add	r3, r2
    19ae:	3304      	adds	r3, #4
    19b0:	681c      	ldr	r4, [r3, #0]
    19b2:	9a03      	ldr	r2, [sp, #12]
    19b4:	4613      	mov	r3, r2
    19b6:	009b      	lsls	r3, r3, #2
    19b8:	4413      	add	r3, r2
    19ba:	009b      	lsls	r3, r3, #2
    19bc:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    19c0:	9a01      	ldr	r2, [sp, #4]
    19c2:	4413      	add	r3, r2
    19c4:	9903      	ldr	r1, [sp, #12]
    19c6:	4618      	mov	r0, r3
    19c8:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    19ca:	9b03      	ldr	r3, [sp, #12]
    19cc:	3301      	adds	r3, #1
    19ce:	9303      	str	r3, [sp, #12]
    19d0:	9b01      	ldr	r3, [sp, #4]
    19d2:	7c9b      	ldrb	r3, [r3, #18]
    19d4:	461a      	mov	r2, r3
    19d6:	9b03      	ldr	r3, [sp, #12]
    19d8:	4293      	cmp	r3, r2
    19da:	d3cf      	bcc.n	197c <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    19dc:	2300      	movs	r3, #0
    19de:	9303      	str	r3, [sp, #12]
    19e0:	e02a      	b.n	1a38 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    19e2:	9901      	ldr	r1, [sp, #4]
    19e4:	9a03      	ldr	r2, [sp, #12]
    19e6:	4613      	mov	r3, r2
    19e8:	009b      	lsls	r3, r3, #2
    19ea:	4413      	add	r3, r2
    19ec:	009b      	lsls	r3, r3, #2
    19ee:	440b      	add	r3, r1
    19f0:	332c      	adds	r3, #44	; 0x2c
    19f2:	681a      	ldr	r2, [r3, #0]
    19f4:	4961      	ldr	r1, [pc, #388]	; (1b7c <Clock_Ip_InitClock+0x584>)
    19f6:	4613      	mov	r3, r2
    19f8:	00db      	lsls	r3, r3, #3
    19fa:	4413      	add	r3, r2
    19fc:	440b      	add	r3, r1
    19fe:	3301      	adds	r3, #1
    1a00:	781b      	ldrb	r3, [r3, #0]
    1a02:	461a      	mov	r2, r3
    1a04:	4b64      	ldr	r3, [pc, #400]	; (1b98 <Clock_Ip_InitClock+0x5a0>)
    1a06:	5c9b      	ldrb	r3, [r3, r2]
    1a08:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    1a0a:	4964      	ldr	r1, [pc, #400]	; (1b9c <Clock_Ip_InitClock+0x5a4>)
    1a0c:	9a02      	ldr	r2, [sp, #8]
    1a0e:	4613      	mov	r3, r2
    1a10:	009b      	lsls	r3, r3, #2
    1a12:	4413      	add	r3, r2
    1a14:	009b      	lsls	r3, r3, #2
    1a16:	440b      	add	r3, r1
    1a18:	3308      	adds	r3, #8
    1a1a:	6819      	ldr	r1, [r3, #0]
    1a1c:	9a03      	ldr	r2, [sp, #12]
    1a1e:	4613      	mov	r3, r2
    1a20:	009b      	lsls	r3, r3, #2
    1a22:	4413      	add	r3, r2
    1a24:	009b      	lsls	r3, r3, #2
    1a26:	3328      	adds	r3, #40	; 0x28
    1a28:	9a01      	ldr	r2, [sp, #4]
    1a2a:	4413      	add	r3, r2
    1a2c:	3304      	adds	r3, #4
    1a2e:	4618      	mov	r0, r3
    1a30:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    1a32:	9b03      	ldr	r3, [sp, #12]
    1a34:	3301      	adds	r3, #1
    1a36:	9303      	str	r3, [sp, #12]
    1a38:	9b01      	ldr	r3, [sp, #4]
    1a3a:	7a5b      	ldrb	r3, [r3, #9]
    1a3c:	461a      	mov	r2, r3
    1a3e:	9b03      	ldr	r3, [sp, #12]
    1a40:	4293      	cmp	r3, r2
    1a42:	d3ce      	bcc.n	19e2 <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1a44:	2300      	movs	r3, #0
    1a46:	9303      	str	r3, [sp, #12]
    1a48:	e029      	b.n	1a9e <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    1a4a:	9901      	ldr	r1, [sp, #4]
    1a4c:	9a03      	ldr	r2, [sp, #12]
    1a4e:	4613      	mov	r3, r2
    1a50:	009b      	lsls	r3, r3, #2
    1a52:	4413      	add	r3, r2
    1a54:	00db      	lsls	r3, r3, #3
    1a56:	440b      	add	r3, r1
    1a58:	3340      	adds	r3, #64	; 0x40
    1a5a:	681a      	ldr	r2, [r3, #0]
    1a5c:	4947      	ldr	r1, [pc, #284]	; (1b7c <Clock_Ip_InitClock+0x584>)
    1a5e:	4613      	mov	r3, r2
    1a60:	00db      	lsls	r3, r3, #3
    1a62:	4413      	add	r3, r2
    1a64:	440b      	add	r3, r1
    1a66:	3301      	adds	r3, #1
    1a68:	781b      	ldrb	r3, [r3, #0]
    1a6a:	461a      	mov	r2, r3
    1a6c:	4b46      	ldr	r3, [pc, #280]	; (1b88 <Clock_Ip_InitClock+0x590>)
    1a6e:	5c9b      	ldrb	r3, [r3, r2]
    1a70:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    1a72:	4946      	ldr	r1, [pc, #280]	; (1b8c <Clock_Ip_InitClock+0x594>)
    1a74:	9a02      	ldr	r2, [sp, #8]
    1a76:	4613      	mov	r3, r2
    1a78:	009b      	lsls	r3, r3, #2
    1a7a:	4413      	add	r3, r2
    1a7c:	009b      	lsls	r3, r3, #2
    1a7e:	440b      	add	r3, r1
    1a80:	330c      	adds	r3, #12
    1a82:	6819      	ldr	r1, [r3, #0]
    1a84:	9a03      	ldr	r2, [sp, #12]
    1a86:	4613      	mov	r3, r2
    1a88:	009b      	lsls	r3, r3, #2
    1a8a:	4413      	add	r3, r2
    1a8c:	00db      	lsls	r3, r3, #3
    1a8e:	3340      	adds	r3, #64	; 0x40
    1a90:	9a01      	ldr	r2, [sp, #4]
    1a92:	4413      	add	r3, r2
    1a94:	4618      	mov	r0, r3
    1a96:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1a98:	9b03      	ldr	r3, [sp, #12]
    1a9a:	3301      	adds	r3, #1
    1a9c:	9303      	str	r3, [sp, #12]
    1a9e:	9b01      	ldr	r3, [sp, #4]
    1aa0:	7a9b      	ldrb	r3, [r3, #10]
    1aa2:	461a      	mov	r2, r3
    1aa4:	9b03      	ldr	r3, [sp, #12]
    1aa6:	4293      	cmp	r3, r2
    1aa8:	d3cf      	bcc.n	1a4a <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1aaa:	2300      	movs	r3, #0
    1aac:	9303      	str	r3, [sp, #12]
    1aae:	e025      	b.n	1afc <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    1ab0:	9a01      	ldr	r2, [sp, #4]
    1ab2:	9b03      	ldr	r3, [sp, #12]
    1ab4:	3324      	adds	r3, #36	; 0x24
    1ab6:	011b      	lsls	r3, r3, #4
    1ab8:	4413      	add	r3, r2
    1aba:	3304      	adds	r3, #4
    1abc:	681a      	ldr	r2, [r3, #0]
    1abe:	492f      	ldr	r1, [pc, #188]	; (1b7c <Clock_Ip_InitClock+0x584>)
    1ac0:	4613      	mov	r3, r2
    1ac2:	00db      	lsls	r3, r3, #3
    1ac4:	4413      	add	r3, r2
    1ac6:	440b      	add	r3, r1
    1ac8:	3301      	adds	r3, #1
    1aca:	781b      	ldrb	r3, [r3, #0]
    1acc:	461a      	mov	r2, r3
    1ace:	4b34      	ldr	r3, [pc, #208]	; (1ba0 <Clock_Ip_InitClock+0x5a8>)
    1ad0:	5c9b      	ldrb	r3, [r3, r2]
    1ad2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    1ad4:	4933      	ldr	r1, [pc, #204]	; (1ba4 <Clock_Ip_InitClock+0x5ac>)
    1ad6:	9a02      	ldr	r2, [sp, #8]
    1ad8:	4613      	mov	r3, r2
    1ada:	005b      	lsls	r3, r3, #1
    1adc:	4413      	add	r3, r2
    1ade:	009b      	lsls	r3, r3, #2
    1ae0:	440b      	add	r3, r1
    1ae2:	3304      	adds	r3, #4
    1ae4:	681b      	ldr	r3, [r3, #0]
    1ae6:	9a03      	ldr	r2, [sp, #12]
    1ae8:	3224      	adds	r2, #36	; 0x24
    1aea:	0112      	lsls	r2, r2, #4
    1aec:	9901      	ldr	r1, [sp, #4]
    1aee:	440a      	add	r2, r1
    1af0:	3204      	adds	r2, #4
    1af2:	4610      	mov	r0, r2
    1af4:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1af6:	9b03      	ldr	r3, [sp, #12]
    1af8:	3301      	adds	r3, #1
    1afa:	9303      	str	r3, [sp, #12]
    1afc:	9b01      	ldr	r3, [sp, #4]
    1afe:	7b9b      	ldrb	r3, [r3, #14]
    1b00:	461a      	mov	r2, r3
    1b02:	9b03      	ldr	r3, [sp, #12]
    1b04:	4293      	cmp	r3, r2
    1b06:	d3d3      	bcc.n	1ab0 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    1b08:	4b27      	ldr	r3, [pc, #156]	; (1ba8 <Clock_Ip_InitClock+0x5b0>)
    1b0a:	2200      	movs	r2, #0
    1b0c:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    1b0e:	4b26      	ldr	r3, [pc, #152]	; (1ba8 <Clock_Ip_InitClock+0x5b0>)
    1b10:	2200      	movs	r2, #0
    1b12:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    1b14:	4b24      	ldr	r3, [pc, #144]	; (1ba8 <Clock_Ip_InitClock+0x5b0>)
    1b16:	2201      	movs	r2, #1
    1b18:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    1b1a:	4b23      	ldr	r3, [pc, #140]	; (1ba8 <Clock_Ip_InitClock+0x5b0>)
    1b1c:	2200      	movs	r2, #0
    1b1e:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    1b20:	f000 fa9c 	bl	205c <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    1b24:	2300      	movs	r3, #0
    1b26:	9303      	str	r3, [sp, #12]
    1b28:	e04c      	b.n	1bc4 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    1b2a:	9a01      	ldr	r2, [sp, #4]
    1b2c:	9b03      	ldr	r3, [sp, #12]
    1b2e:	330d      	adds	r3, #13
    1b30:	00db      	lsls	r3, r3, #3
    1b32:	4413      	add	r3, r2
    1b34:	685b      	ldr	r3, [r3, #4]
    1b36:	4a1d      	ldr	r2, [pc, #116]	; (1bac <Clock_Ip_InitClock+0x5b4>)
    1b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1b3c:	2b03      	cmp	r3, #3
    1b3e:	d03b      	beq.n	1bb8 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    1b40:	9b01      	ldr	r3, [sp, #4]
    1b42:	9a03      	ldr	r2, [sp, #12]
    1b44:	320d      	adds	r2, #13
    1b46:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1b4a:	490c      	ldr	r1, [pc, #48]	; (1b7c <Clock_Ip_InitClock+0x584>)
    1b4c:	4613      	mov	r3, r2
    1b4e:	00db      	lsls	r3, r3, #3
    1b50:	4413      	add	r3, r2
    1b52:	440b      	add	r3, r1
    1b54:	3301      	adds	r3, #1
    1b56:	781b      	ldrb	r3, [r3, #0]
    1b58:	461a      	mov	r2, r3
    1b5a:	4b15      	ldr	r3, [pc, #84]	; (1bb0 <Clock_Ip_InitClock+0x5b8>)
    1b5c:	5c9b      	ldrb	r3, [r3, r2]
    1b5e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    1b60:	4a14      	ldr	r2, [pc, #80]	; (1bb4 <Clock_Ip_InitClock+0x5bc>)
    1b62:	9b02      	ldr	r3, [sp, #8]
    1b64:	00db      	lsls	r3, r3, #3
    1b66:	4413      	add	r3, r2
    1b68:	685b      	ldr	r3, [r3, #4]
    1b6a:	9a03      	ldr	r2, [sp, #12]
    1b6c:	320d      	adds	r2, #13
    1b6e:	00d2      	lsls	r2, r2, #3
    1b70:	9901      	ldr	r1, [sp, #4]
    1b72:	440a      	add	r2, r1
    1b74:	4610      	mov	r0, r2
    1b76:	4798      	blx	r3
    1b78:	e021      	b.n	1bbe <Clock_Ip_InitClock+0x5c6>
    1b7a:	bf00      	nop
    1b7c:	00009ad4 	.word	0x00009ad4
    1b80:	00009a44 	.word	0x00009a44
    1b84:	0000a020 	.word	0x0000a020
    1b88:	00009a94 	.word	0x00009a94
    1b8c:	0000a0e0 	.word	0x0000a0e0
    1b90:	00009ac4 	.word	0x00009ac4
    1b94:	0000a0d0 	.word	0x0000a0d0
    1b98:	00009a54 	.word	0x00009a54
    1b9c:	0000a028 	.word	0x0000a028
    1ba0:	00009a84 	.word	0x00009a84
    1ba4:	0000a050 	.word	0x0000a050
    1ba8:	1fff8b4c 	.word	0x1fff8b4c
    1bac:	00009f20 	.word	0x00009f20
    1bb0:	00009aa4 	.word	0x00009aa4
    1bb4:	0000a10c 	.word	0x0000a10c
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    1bb8:	4b3a      	ldr	r3, [pc, #232]	; (1ca4 <Clock_Ip_InitClock+0x6ac>)
    1bba:	2201      	movs	r2, #1
    1bbc:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    1bbe:	9b03      	ldr	r3, [sp, #12]
    1bc0:	3301      	adds	r3, #1
    1bc2:	9303      	str	r3, [sp, #12]
    1bc4:	9b01      	ldr	r3, [sp, #4]
    1bc6:	7adb      	ldrb	r3, [r3, #11]
    1bc8:	461a      	mov	r2, r3
    1bca:	9b03      	ldr	r3, [sp, #12]
    1bcc:	4293      	cmp	r3, r2
    1bce:	d3ac      	bcc.n	1b2a <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    1bd0:	4b34      	ldr	r3, [pc, #208]	; (1ca4 <Clock_Ip_InitClock+0x6ac>)
    1bd2:	781b      	ldrb	r3, [r3, #0]
    1bd4:	f083 0301 	eor.w	r3, r3, #1
    1bd8:	b2db      	uxtb	r3, r3
    1bda:	2b00      	cmp	r3, #0
    1bdc:	d05e      	beq.n	1c9c <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1bde:	2300      	movs	r3, #0
    1be0:	9303      	str	r3, [sp, #12]
    1be2:	e01f      	b.n	1c24 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    1be4:	9a01      	ldr	r2, [sp, #4]
    1be6:	9b03      	ldr	r3, [sp, #12]
    1be8:	334e      	adds	r3, #78	; 0x4e
    1bea:	00db      	lsls	r3, r3, #3
    1bec:	4413      	add	r3, r2
    1bee:	685a      	ldr	r2, [r3, #4]
    1bf0:	492d      	ldr	r1, [pc, #180]	; (1ca8 <Clock_Ip_InitClock+0x6b0>)
    1bf2:	4613      	mov	r3, r2
    1bf4:	00db      	lsls	r3, r3, #3
    1bf6:	4413      	add	r3, r2
    1bf8:	440b      	add	r3, r1
    1bfa:	3301      	adds	r3, #1
    1bfc:	781b      	ldrb	r3, [r3, #0]
    1bfe:	461a      	mov	r2, r3
    1c00:	4b2a      	ldr	r3, [pc, #168]	; (1cac <Clock_Ip_InitClock+0x6b4>)
    1c02:	5c9b      	ldrb	r3, [r3, r2]
    1c04:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    1c06:	4a2a      	ldr	r2, [pc, #168]	; (1cb0 <Clock_Ip_InitClock+0x6b8>)
    1c08:	9b02      	ldr	r3, [sp, #8]
    1c0a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1c0e:	9a03      	ldr	r2, [sp, #12]
    1c10:	324e      	adds	r2, #78	; 0x4e
    1c12:	00d2      	lsls	r2, r2, #3
    1c14:	9901      	ldr	r1, [sp, #4]
    1c16:	440a      	add	r2, r1
    1c18:	3204      	adds	r2, #4
    1c1a:	4610      	mov	r0, r2
    1c1c:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1c1e:	9b03      	ldr	r3, [sp, #12]
    1c20:	3301      	adds	r3, #1
    1c22:	9303      	str	r3, [sp, #12]
    1c24:	9b01      	ldr	r3, [sp, #4]
    1c26:	7c1b      	ldrb	r3, [r3, #16]
    1c28:	461a      	mov	r2, r3
    1c2a:	9b03      	ldr	r3, [sp, #12]
    1c2c:	4293      	cmp	r3, r2
    1c2e:	d3d9      	bcc.n	1be4 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    1c30:	2300      	movs	r3, #0
    1c32:	9303      	str	r3, [sp, #12]
    1c34:	e028      	b.n	1c88 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1c36:	9901      	ldr	r1, [sp, #4]
    1c38:	9a03      	ldr	r2, [sp, #12]
    1c3a:	4613      	mov	r3, r2
    1c3c:	009b      	lsls	r3, r3, #2
    1c3e:	4413      	add	r3, r2
    1c40:	009b      	lsls	r3, r3, #2
    1c42:	440b      	add	r3, r1
    1c44:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1c48:	681a      	ldr	r2, [r3, #0]
    1c4a:	4917      	ldr	r1, [pc, #92]	; (1ca8 <Clock_Ip_InitClock+0x6b0>)
    1c4c:	4613      	mov	r3, r2
    1c4e:	00db      	lsls	r3, r3, #3
    1c50:	4413      	add	r3, r2
    1c52:	440b      	add	r3, r1
    1c54:	3301      	adds	r3, #1
    1c56:	781b      	ldrb	r3, [r3, #0]
    1c58:	461a      	mov	r2, r3
    1c5a:	4b16      	ldr	r3, [pc, #88]	; (1cb4 <Clock_Ip_InitClock+0x6bc>)
    1c5c:	5c9b      	ldrb	r3, [r3, r2]
    1c5e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    1c60:	4a15      	ldr	r2, [pc, #84]	; (1cb8 <Clock_Ip_InitClock+0x6c0>)
    1c62:	9b02      	ldr	r3, [sp, #8]
    1c64:	011b      	lsls	r3, r3, #4
    1c66:	4413      	add	r3, r2
    1c68:	330c      	adds	r3, #12
    1c6a:	6819      	ldr	r1, [r3, #0]
    1c6c:	9a03      	ldr	r2, [sp, #12]
    1c6e:	4613      	mov	r3, r2
    1c70:	009b      	lsls	r3, r3, #2
    1c72:	4413      	add	r3, r2
    1c74:	009b      	lsls	r3, r3, #2
    1c76:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1c7a:	9a01      	ldr	r2, [sp, #4]
    1c7c:	4413      	add	r3, r2
    1c7e:	4618      	mov	r0, r3
    1c80:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    1c82:	9b03      	ldr	r3, [sp, #12]
    1c84:	3301      	adds	r3, #1
    1c86:	9303      	str	r3, [sp, #12]
    1c88:	9b01      	ldr	r3, [sp, #4]
    1c8a:	7c9b      	ldrb	r3, [r3, #18]
    1c8c:	461a      	mov	r2, r3
    1c8e:	9b03      	ldr	r3, [sp, #12]
    1c90:	4293      	cmp	r3, r2
    1c92:	d3d0      	bcc.n	1c36 <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1c94:	2104      	movs	r1, #4
    1c96:	9801      	ldr	r0, [sp, #4]
    1c98:	f002 ff48 	bl	4b2c <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    1c9c:	bf00      	nop
    1c9e:	b004      	add	sp, #16
    1ca0:	bd10      	pop	{r4, pc}
    1ca2:	bf00      	nop
    1ca4:	1fff8b4c 	.word	0x1fff8b4c
    1ca8:	00009ad4 	.word	0x00009ad4
    1cac:	00009a74 	.word	0x00009a74
    1cb0:	0000a05c 	.word	0x0000a05c
    1cb4:	00009ac4 	.word	0x00009ac4
    1cb8:	0000a0d0 	.word	0x0000a0d0

00001cbc <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    1cbc:	b500      	push	{lr}
    1cbe:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    1cc0:	2302      	movs	r3, #2
    1cc2:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    1cc4:	2300      	movs	r3, #0
    1cc6:	9304      	str	r3, [sp, #16]
    1cc8:	e02c      	b.n	1d24 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    1cca:	4a36      	ldr	r2, [pc, #216]	; (1da4 <Clock_Ip_GetPllStatus+0xe8>)
    1ccc:	9b04      	ldr	r3, [sp, #16]
    1cce:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1cd2:	4935      	ldr	r1, [pc, #212]	; (1da8 <Clock_Ip_GetPllStatus+0xec>)
    1cd4:	4613      	mov	r3, r2
    1cd6:	00db      	lsls	r3, r3, #3
    1cd8:	4413      	add	r3, r2
    1cda:	440b      	add	r3, r1
    1cdc:	3301      	adds	r3, #1
    1cde:	781b      	ldrb	r3, [r3, #0]
    1ce0:	461a      	mov	r2, r3
    1ce2:	4b32      	ldr	r3, [pc, #200]	; (1dac <Clock_Ip_GetPllStatus+0xf0>)
    1ce4:	5c9b      	ldrb	r3, [r3, r2]
    1ce6:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    1ce8:	4931      	ldr	r1, [pc, #196]	; (1db0 <Clock_Ip_GetPllStatus+0xf4>)
    1cea:	9a03      	ldr	r2, [sp, #12]
    1cec:	4613      	mov	r3, r2
    1cee:	009b      	lsls	r3, r3, #2
    1cf0:	4413      	add	r3, r2
    1cf2:	009b      	lsls	r3, r3, #2
    1cf4:	440b      	add	r3, r1
    1cf6:	3308      	adds	r3, #8
    1cf8:	681b      	ldr	r3, [r3, #0]
    1cfa:	492a      	ldr	r1, [pc, #168]	; (1da4 <Clock_Ip_GetPllStatus+0xe8>)
    1cfc:	9a04      	ldr	r2, [sp, #16]
    1cfe:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    1d02:	4610      	mov	r0, r2
    1d04:	4798      	blx	r3
    1d06:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    1d08:	9b02      	ldr	r3, [sp, #8]
    1d0a:	2b01      	cmp	r3, #1
    1d0c:	d102      	bne.n	1d14 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    1d0e:	2301      	movs	r3, #1
    1d10:	9305      	str	r3, [sp, #20]
            break;
    1d12:	e00d      	b.n	1d30 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    1d14:	9b02      	ldr	r3, [sp, #8]
    1d16:	2b02      	cmp	r3, #2
    1d18:	d101      	bne.n	1d1e <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    1d1a:	2300      	movs	r3, #0
    1d1c:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    1d1e:	9b04      	ldr	r3, [sp, #16]
    1d20:	3301      	adds	r3, #1
    1d22:	9304      	str	r3, [sp, #16]
    1d24:	4b23      	ldr	r3, [pc, #140]	; (1db4 <Clock_Ip_GetPllStatus+0xf8>)
    1d26:	789b      	ldrb	r3, [r3, #2]
    1d28:	461a      	mov	r2, r3
    1d2a:	9b04      	ldr	r3, [sp, #16]
    1d2c:	4293      	cmp	r3, r2
    1d2e:	d3cc      	bcc.n	1cca <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    1d30:	9b05      	ldr	r3, [sp, #20]
    1d32:	2b00      	cmp	r3, #0
    1d34:	d130      	bne.n	1d98 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    1d36:	2300      	movs	r3, #0
    1d38:	9304      	str	r3, [sp, #16]
    1d3a:	e027      	b.n	1d8c <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    1d3c:	4a1e      	ldr	r2, [pc, #120]	; (1db8 <Clock_Ip_GetPllStatus+0xfc>)
    1d3e:	9b04      	ldr	r3, [sp, #16]
    1d40:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1d44:	4918      	ldr	r1, [pc, #96]	; (1da8 <Clock_Ip_GetPllStatus+0xec>)
    1d46:	4613      	mov	r3, r2
    1d48:	00db      	lsls	r3, r3, #3
    1d4a:	4413      	add	r3, r2
    1d4c:	440b      	add	r3, r1
    1d4e:	3301      	adds	r3, #1
    1d50:	781b      	ldrb	r3, [r3, #0]
    1d52:	461a      	mov	r2, r3
    1d54:	4b19      	ldr	r3, [pc, #100]	; (1dbc <Clock_Ip_GetPllStatus+0x100>)
    1d56:	5c9b      	ldrb	r3, [r3, r2]
    1d58:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    1d5a:	4919      	ldr	r1, [pc, #100]	; (1dc0 <Clock_Ip_GetPllStatus+0x104>)
    1d5c:	9a03      	ldr	r2, [sp, #12]
    1d5e:	4613      	mov	r3, r2
    1d60:	005b      	lsls	r3, r3, #1
    1d62:	4413      	add	r3, r2
    1d64:	009b      	lsls	r3, r3, #2
    1d66:	440b      	add	r3, r1
    1d68:	3308      	adds	r3, #8
    1d6a:	681b      	ldr	r3, [r3, #0]
    1d6c:	4912      	ldr	r1, [pc, #72]	; (1db8 <Clock_Ip_GetPllStatus+0xfc>)
    1d6e:	9a04      	ldr	r2, [sp, #16]
    1d70:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    1d74:	4610      	mov	r0, r2
    1d76:	4798      	blx	r3
    1d78:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    1d7a:	9b01      	ldr	r3, [sp, #4]
    1d7c:	2b01      	cmp	r3, #1
    1d7e:	d102      	bne.n	1d86 <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    1d80:	2301      	movs	r3, #1
    1d82:	9305      	str	r3, [sp, #20]
                break;
    1d84:	e008      	b.n	1d98 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    1d86:	9b04      	ldr	r3, [sp, #16]
    1d88:	3301      	adds	r3, #1
    1d8a:	9304      	str	r3, [sp, #16]
    1d8c:	4b09      	ldr	r3, [pc, #36]	; (1db4 <Clock_Ip_GetPllStatus+0xf8>)
    1d8e:	78db      	ldrb	r3, [r3, #3]
    1d90:	461a      	mov	r2, r3
    1d92:	9b04      	ldr	r3, [sp, #16]
    1d94:	4293      	cmp	r3, r2
    1d96:	d3d1      	bcc.n	1d3c <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    1d98:	9b05      	ldr	r3, [sp, #20]
}
    1d9a:	4618      	mov	r0, r3
    1d9c:	b007      	add	sp, #28
    1d9e:	f85d fb04 	ldr.w	pc, [sp], #4
    1da2:	bf00      	nop
    1da4:	00009fdc 	.word	0x00009fdc
    1da8:	00009ad4 	.word	0x00009ad4
    1dac:	00009a94 	.word	0x00009a94
    1db0:	0000a0e0 	.word	0x0000a0e0
    1db4:	1fff8b4c 	.word	0x1fff8b4c
    1db8:	00009fe0 	.word	0x00009fe0
    1dbc:	00009a84 	.word	0x00009a84
    1dc0:	0000a050 	.word	0x0000a050

00001dc4 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    1dc4:	b500      	push	{lr}
    1dc6:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    1dc8:	4b55      	ldr	r3, [pc, #340]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1dca:	681b      	ldr	r3, [r3, #0]
    1dcc:	2b00      	cmp	r3, #0
    1dce:	f000 80a2 	beq.w	1f16 <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    1dd2:	2300      	movs	r3, #0
    1dd4:	9301      	str	r3, [sp, #4]
    1dd6:	e02c      	b.n	1e32 <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    1dd8:	4b51      	ldr	r3, [pc, #324]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1dda:	681a      	ldr	r2, [r3, #0]
    1ddc:	9b01      	ldr	r3, [sp, #4]
    1dde:	330d      	adds	r3, #13
    1de0:	00db      	lsls	r3, r3, #3
    1de2:	4413      	add	r3, r2
    1de4:	685b      	ldr	r3, [r3, #4]
    1de6:	4a4f      	ldr	r2, [pc, #316]	; (1f24 <Clock_Ip_DistributePll+0x160>)
    1de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1dec:	2b03      	cmp	r3, #3
    1dee:	d11d      	bne.n	1e2c <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    1df0:	4b4b      	ldr	r3, [pc, #300]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1df2:	681b      	ldr	r3, [r3, #0]
    1df4:	9a01      	ldr	r2, [sp, #4]
    1df6:	320d      	adds	r2, #13
    1df8:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1dfc:	494a      	ldr	r1, [pc, #296]	; (1f28 <Clock_Ip_DistributePll+0x164>)
    1dfe:	4613      	mov	r3, r2
    1e00:	00db      	lsls	r3, r3, #3
    1e02:	4413      	add	r3, r2
    1e04:	440b      	add	r3, r1
    1e06:	3301      	adds	r3, #1
    1e08:	781b      	ldrb	r3, [r3, #0]
    1e0a:	461a      	mov	r2, r3
    1e0c:	4b47      	ldr	r3, [pc, #284]	; (1f2c <Clock_Ip_DistributePll+0x168>)
    1e0e:	5c9b      	ldrb	r3, [r3, r2]
    1e10:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    1e12:	4a47      	ldr	r2, [pc, #284]	; (1f30 <Clock_Ip_DistributePll+0x16c>)
    1e14:	9b00      	ldr	r3, [sp, #0]
    1e16:	00db      	lsls	r3, r3, #3
    1e18:	4413      	add	r3, r2
    1e1a:	685b      	ldr	r3, [r3, #4]
    1e1c:	4a40      	ldr	r2, [pc, #256]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1e1e:	6811      	ldr	r1, [r2, #0]
    1e20:	9a01      	ldr	r2, [sp, #4]
    1e22:	320d      	adds	r2, #13
    1e24:	00d2      	lsls	r2, r2, #3
    1e26:	440a      	add	r2, r1
    1e28:	4610      	mov	r0, r2
    1e2a:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    1e2c:	9b01      	ldr	r3, [sp, #4]
    1e2e:	3301      	adds	r3, #1
    1e30:	9301      	str	r3, [sp, #4]
    1e32:	4b3b      	ldr	r3, [pc, #236]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1e34:	681b      	ldr	r3, [r3, #0]
    1e36:	7adb      	ldrb	r3, [r3, #11]
    1e38:	461a      	mov	r2, r3
    1e3a:	9b01      	ldr	r3, [sp, #4]
    1e3c:	4293      	cmp	r3, r2
    1e3e:	d3cb      	bcc.n	1dd8 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    1e40:	4b3c      	ldr	r3, [pc, #240]	; (1f34 <Clock_Ip_DistributePll+0x170>)
    1e42:	781b      	ldrb	r3, [r3, #0]
    1e44:	2b00      	cmp	r3, #0
    1e46:	d066      	beq.n	1f16 <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1e48:	2300      	movs	r3, #0
    1e4a:	9301      	str	r3, [sp, #4]
    1e4c:	e021      	b.n	1e92 <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    1e4e:	4b34      	ldr	r3, [pc, #208]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1e50:	681a      	ldr	r2, [r3, #0]
    1e52:	9b01      	ldr	r3, [sp, #4]
    1e54:	334e      	adds	r3, #78	; 0x4e
    1e56:	00db      	lsls	r3, r3, #3
    1e58:	4413      	add	r3, r2
    1e5a:	685a      	ldr	r2, [r3, #4]
    1e5c:	4932      	ldr	r1, [pc, #200]	; (1f28 <Clock_Ip_DistributePll+0x164>)
    1e5e:	4613      	mov	r3, r2
    1e60:	00db      	lsls	r3, r3, #3
    1e62:	4413      	add	r3, r2
    1e64:	440b      	add	r3, r1
    1e66:	3301      	adds	r3, #1
    1e68:	781b      	ldrb	r3, [r3, #0]
    1e6a:	461a      	mov	r2, r3
    1e6c:	4b32      	ldr	r3, [pc, #200]	; (1f38 <Clock_Ip_DistributePll+0x174>)
    1e6e:	5c9b      	ldrb	r3, [r3, r2]
    1e70:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    1e72:	4a32      	ldr	r2, [pc, #200]	; (1f3c <Clock_Ip_DistributePll+0x178>)
    1e74:	9b00      	ldr	r3, [sp, #0]
    1e76:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1e7a:	4a29      	ldr	r2, [pc, #164]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1e7c:	6811      	ldr	r1, [r2, #0]
    1e7e:	9a01      	ldr	r2, [sp, #4]
    1e80:	324e      	adds	r2, #78	; 0x4e
    1e82:	00d2      	lsls	r2, r2, #3
    1e84:	440a      	add	r2, r1
    1e86:	3204      	adds	r2, #4
    1e88:	4610      	mov	r0, r2
    1e8a:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1e8c:	9b01      	ldr	r3, [sp, #4]
    1e8e:	3301      	adds	r3, #1
    1e90:	9301      	str	r3, [sp, #4]
    1e92:	4b23      	ldr	r3, [pc, #140]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1e94:	681b      	ldr	r3, [r3, #0]
    1e96:	7c1b      	ldrb	r3, [r3, #16]
    1e98:	461a      	mov	r2, r3
    1e9a:	9b01      	ldr	r3, [sp, #4]
    1e9c:	4293      	cmp	r3, r2
    1e9e:	d3d6      	bcc.n	1e4e <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1ea0:	2300      	movs	r3, #0
    1ea2:	9301      	str	r3, [sp, #4]
    1ea4:	e02a      	b.n	1efc <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1ea6:	4b1e      	ldr	r3, [pc, #120]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1ea8:	6819      	ldr	r1, [r3, #0]
    1eaa:	9a01      	ldr	r2, [sp, #4]
    1eac:	4613      	mov	r3, r2
    1eae:	009b      	lsls	r3, r3, #2
    1eb0:	4413      	add	r3, r2
    1eb2:	009b      	lsls	r3, r3, #2
    1eb4:	440b      	add	r3, r1
    1eb6:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1eba:	681a      	ldr	r2, [r3, #0]
    1ebc:	491a      	ldr	r1, [pc, #104]	; (1f28 <Clock_Ip_DistributePll+0x164>)
    1ebe:	4613      	mov	r3, r2
    1ec0:	00db      	lsls	r3, r3, #3
    1ec2:	4413      	add	r3, r2
    1ec4:	440b      	add	r3, r1
    1ec6:	3301      	adds	r3, #1
    1ec8:	781b      	ldrb	r3, [r3, #0]
    1eca:	461a      	mov	r2, r3
    1ecc:	4b1c      	ldr	r3, [pc, #112]	; (1f40 <Clock_Ip_DistributePll+0x17c>)
    1ece:	5c9b      	ldrb	r3, [r3, r2]
    1ed0:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    1ed2:	4a1c      	ldr	r2, [pc, #112]	; (1f44 <Clock_Ip_DistributePll+0x180>)
    1ed4:	9b00      	ldr	r3, [sp, #0]
    1ed6:	011b      	lsls	r3, r3, #4
    1ed8:	4413      	add	r3, r2
    1eda:	330c      	adds	r3, #12
    1edc:	6819      	ldr	r1, [r3, #0]
    1ede:	4b10      	ldr	r3, [pc, #64]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1ee0:	6818      	ldr	r0, [r3, #0]
    1ee2:	9a01      	ldr	r2, [sp, #4]
    1ee4:	4613      	mov	r3, r2
    1ee6:	009b      	lsls	r3, r3, #2
    1ee8:	4413      	add	r3, r2
    1eea:	009b      	lsls	r3, r3, #2
    1eec:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1ef0:	4403      	add	r3, r0
    1ef2:	4618      	mov	r0, r3
    1ef4:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1ef6:	9b01      	ldr	r3, [sp, #4]
    1ef8:	3301      	adds	r3, #1
    1efa:	9301      	str	r3, [sp, #4]
    1efc:	4b08      	ldr	r3, [pc, #32]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1efe:	681b      	ldr	r3, [r3, #0]
    1f00:	7c9b      	ldrb	r3, [r3, #18]
    1f02:	461a      	mov	r2, r3
    1f04:	9b01      	ldr	r3, [sp, #4]
    1f06:	4293      	cmp	r3, r2
    1f08:	d3cd      	bcc.n	1ea6 <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1f0a:	4b05      	ldr	r3, [pc, #20]	; (1f20 <Clock_Ip_DistributePll+0x15c>)
    1f0c:	681b      	ldr	r3, [r3, #0]
    1f0e:	2104      	movs	r1, #4
    1f10:	4618      	mov	r0, r3
    1f12:	f002 fe0b 	bl	4b2c <Clock_Ip_Command>
        }
    }
}
    1f16:	bf00      	nop
    1f18:	b003      	add	sp, #12
    1f1a:	f85d fb04 	ldr.w	pc, [sp], #4
    1f1e:	bf00      	nop
    1f20:	1fff8b44 	.word	0x1fff8b44
    1f24:	00009f20 	.word	0x00009f20
    1f28:	00009ad4 	.word	0x00009ad4
    1f2c:	00009aa4 	.word	0x00009aa4
    1f30:	0000a10c 	.word	0x0000a10c
    1f34:	1fff8b4c 	.word	0x1fff8b4c
    1f38:	00009a74 	.word	0x00009a74
    1f3c:	0000a05c 	.word	0x0000a05c
    1f40:	00009ac4 	.word	0x00009ac4
    1f44:	0000a0d0 	.word	0x0000a0d0

00001f48 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    1f48:	b500      	push	{lr}
    1f4a:	b085      	sub	sp, #20
    1f4c:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1f4e:	490c      	ldr	r1, [pc, #48]	; (1f80 <Clock_Ip_DisableClockMonitor+0x38>)
    1f50:	9a01      	ldr	r2, [sp, #4]
    1f52:	4613      	mov	r3, r2
    1f54:	00db      	lsls	r3, r3, #3
    1f56:	4413      	add	r3, r2
    1f58:	440b      	add	r3, r1
    1f5a:	3301      	adds	r3, #1
    1f5c:	781b      	ldrb	r3, [r3, #0]
    1f5e:	461a      	mov	r2, r3
    1f60:	4b08      	ldr	r3, [pc, #32]	; (1f84 <Clock_Ip_DisableClockMonitor+0x3c>)
    1f62:	5c9b      	ldrb	r3, [r3, r2]
    1f64:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    1f66:	4a08      	ldr	r2, [pc, #32]	; (1f88 <Clock_Ip_DisableClockMonitor+0x40>)
    1f68:	9b03      	ldr	r3, [sp, #12]
    1f6a:	011b      	lsls	r3, r3, #4
    1f6c:	4413      	add	r3, r2
    1f6e:	3308      	adds	r3, #8
    1f70:	681b      	ldr	r3, [r3, #0]
    1f72:	9801      	ldr	r0, [sp, #4]
    1f74:	4798      	blx	r3
}
    1f76:	bf00      	nop
    1f78:	b005      	add	sp, #20
    1f7a:	f85d fb04 	ldr.w	pc, [sp], #4
    1f7e:	bf00      	nop
    1f80:	00009ad4 	.word	0x00009ad4
    1f84:	00009ac4 	.word	0x00009ac4
    1f88:	0000a0d0 	.word	0x0000a0d0

00001f8c <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    1f8c:	b082      	sub	sp, #8
    1f8e:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    1f90:	4a02      	ldr	r2, [pc, #8]	; (1f9c <Clock_Ip_InstallNotificationsCallback+0x10>)
    1f92:	9b01      	ldr	r3, [sp, #4]
    1f94:	6013      	str	r3, [r2, #0]
}
    1f96:	bf00      	nop
    1f98:	b002      	add	sp, #8
    1f9a:	4770      	bx	lr
    1f9c:	1fff8b1c 	.word	0x1fff8b1c

00001fa0 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    1fa0:	b500      	push	{lr}
    1fa2:	b085      	sub	sp, #20
    1fa4:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1fa6:	490c      	ldr	r1, [pc, #48]	; (1fd8 <Clock_Ip_DisableModuleClock+0x38>)
    1fa8:	9a01      	ldr	r2, [sp, #4]
    1faa:	4613      	mov	r3, r2
    1fac:	00db      	lsls	r3, r3, #3
    1fae:	4413      	add	r3, r2
    1fb0:	440b      	add	r3, r1
    1fb2:	3301      	adds	r3, #1
    1fb4:	781b      	ldrb	r3, [r3, #0]
    1fb6:	461a      	mov	r2, r3
    1fb8:	4b08      	ldr	r3, [pc, #32]	; (1fdc <Clock_Ip_DisableModuleClock+0x3c>)
    1fba:	5c9b      	ldrb	r3, [r3, r2]
    1fbc:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    1fbe:	4a08      	ldr	r2, [pc, #32]	; (1fe0 <Clock_Ip_DisableModuleClock+0x40>)
    1fc0:	9b03      	ldr	r3, [sp, #12]
    1fc2:	00db      	lsls	r3, r3, #3
    1fc4:	4413      	add	r3, r2
    1fc6:	685b      	ldr	r3, [r3, #4]
    1fc8:	2101      	movs	r1, #1
    1fca:	9801      	ldr	r0, [sp, #4]
    1fcc:	4798      	blx	r3
}
    1fce:	bf00      	nop
    1fd0:	b005      	add	sp, #20
    1fd2:	f85d fb04 	ldr.w	pc, [sp], #4
    1fd6:	bf00      	nop
    1fd8:	00009ad4 	.word	0x00009ad4
    1fdc:	00009a74 	.word	0x00009a74
    1fe0:	0000a05c 	.word	0x0000a05c

00001fe4 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    1fe4:	b500      	push	{lr}
    1fe6:	b085      	sub	sp, #20
    1fe8:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1fea:	490c      	ldr	r1, [pc, #48]	; (201c <Clock_Ip_EnableModuleClock+0x38>)
    1fec:	9a01      	ldr	r2, [sp, #4]
    1fee:	4613      	mov	r3, r2
    1ff0:	00db      	lsls	r3, r3, #3
    1ff2:	4413      	add	r3, r2
    1ff4:	440b      	add	r3, r1
    1ff6:	3301      	adds	r3, #1
    1ff8:	781b      	ldrb	r3, [r3, #0]
    1ffa:	461a      	mov	r2, r3
    1ffc:	4b08      	ldr	r3, [pc, #32]	; (2020 <Clock_Ip_EnableModuleClock+0x3c>)
    1ffe:	5c9b      	ldrb	r3, [r3, r2]
    2000:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    2002:	4a08      	ldr	r2, [pc, #32]	; (2024 <Clock_Ip_EnableModuleClock+0x40>)
    2004:	9b03      	ldr	r3, [sp, #12]
    2006:	00db      	lsls	r3, r3, #3
    2008:	4413      	add	r3, r2
    200a:	685b      	ldr	r3, [r3, #4]
    200c:	2100      	movs	r1, #0
    200e:	9801      	ldr	r0, [sp, #4]
    2010:	4798      	blx	r3
}
    2012:	bf00      	nop
    2014:	b005      	add	sp, #20
    2016:	f85d fb04 	ldr.w	pc, [sp], #4
    201a:	bf00      	nop
    201c:	00009ad4 	.word	0x00009ad4
    2020:	00009a74 	.word	0x00009a74
    2024:	0000a05c 	.word	0x0000a05c

00002028 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    2028:	b500      	push	{lr}
    202a:	b083      	sub	sp, #12
    202c:	9001      	str	r0, [sp, #4]
    202e:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    2030:	4b08      	ldr	r3, [pc, #32]	; (2054 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    2032:	2200      	movs	r2, #0
    2034:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2036:	4b08      	ldr	r3, [pc, #32]	; (2058 <Clock_Ip_PowerModeChangeNotification+0x30>)
    2038:	681b      	ldr	r3, [r3, #0]
    203a:	2102      	movs	r1, #2
    203c:	4618      	mov	r0, r3
    203e:	f002 fd75 	bl	4b2c <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    2042:	9900      	ldr	r1, [sp, #0]
    2044:	9801      	ldr	r0, [sp, #4]
    2046:	f002 fc51 	bl	48ec <Clock_Ip_ClockPowerModeChangeNotification>
}
    204a:	bf00      	nop
    204c:	b003      	add	sp, #12
    204e:	f85d fb04 	ldr.w	pc, [sp], #4
    2052:	bf00      	nop
    2054:	1fff8b1a 	.word	0x1fff8b1a
    2058:	1fff8b44 	.word	0x1fff8b44

0000205c <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    205c:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    205e:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    2062:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    2064:	4b06      	ldr	r3, [pc, #24]	; (2080 <Clock_Ip_SetWaitStates+0x24>)
    2066:	785b      	ldrb	r3, [r3, #1]
    2068:	2b00      	cmp	r3, #0
    206a:	d005      	beq.n	2078 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    206c:	9b01      	ldr	r3, [sp, #4]
    206e:	3b01      	subs	r3, #1
    2070:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    2072:	9b01      	ldr	r3, [sp, #4]
    2074:	2b00      	cmp	r3, #0
    2076:	d1f9      	bne.n	206c <Clock_Ip_SetWaitStates+0x10>
    }
}
    2078:	bf00      	nop
    207a:	b002      	add	sp, #8
    207c:	4770      	bx	lr
    207e:	bf00      	nop
    2080:	1fff8b4c 	.word	0x1fff8b4c

00002084 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    2084:	b500      	push	{lr}
    2086:	b083      	sub	sp, #12
    2088:	9001      	str	r0, [sp, #4]
    208a:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    208c:	4b04      	ldr	r3, [pc, #16]	; (20a0 <Clock_Ip_ReportClockErrors+0x1c>)
    208e:	681b      	ldr	r3, [r3, #0]
    2090:	9900      	ldr	r1, [sp, #0]
    2092:	9801      	ldr	r0, [sp, #4]
    2094:	4798      	blx	r3
}
    2096:	bf00      	nop
    2098:	b003      	add	sp, #12
    209a:	f85d fb04 	ldr.w	pc, [sp], #4
    209e:	bf00      	nop
    20a0:	1fff8b1c 	.word	0x1fff8b1c

000020a4 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    20a4:	b500      	push	{lr}
    20a6:	b085      	sub	sp, #20
    20a8:	9003      	str	r0, [sp, #12]
    20aa:	9102      	str	r1, [sp, #8]
    20ac:	9201      	str	r2, [sp, #4]
    20ae:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    20b0:	2000      	movs	r0, #0
    20b2:	f7fe ffd1 	bl	1058 <OsIf_GetCounter>
    20b6:	4602      	mov	r2, r0
    20b8:	9b03      	ldr	r3, [sp, #12]
    20ba:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    20bc:	9b02      	ldr	r3, [sp, #8]
    20be:	2200      	movs	r2, #0
    20c0:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    20c2:	2100      	movs	r1, #0
    20c4:	9800      	ldr	r0, [sp, #0]
    20c6:	f7ff f813 	bl	10f0 <OsIf_MicrosToTicks>
    20ca:	4602      	mov	r2, r0
    20cc:	9b01      	ldr	r3, [sp, #4]
    20ce:	601a      	str	r2, [r3, #0]
}
    20d0:	bf00      	nop
    20d2:	b005      	add	sp, #20
    20d4:	f85d fb04 	ldr.w	pc, [sp], #4

000020d8 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    20d8:	b500      	push	{lr}
    20da:	b087      	sub	sp, #28
    20dc:	9003      	str	r0, [sp, #12]
    20de:	9102      	str	r1, [sp, #8]
    20e0:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    20e2:	2300      	movs	r3, #0
    20e4:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    20e8:	2100      	movs	r1, #0
    20ea:	9803      	ldr	r0, [sp, #12]
    20ec:	f7fe ffcd 	bl	108a <OsIf_GetElapsed>
    20f0:	4602      	mov	r2, r0
    20f2:	9b02      	ldr	r3, [sp, #8]
    20f4:	681b      	ldr	r3, [r3, #0]
    20f6:	441a      	add	r2, r3
    20f8:	9b02      	ldr	r3, [sp, #8]
    20fa:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    20fc:	9b02      	ldr	r3, [sp, #8]
    20fe:	681b      	ldr	r3, [r3, #0]
    2100:	9a01      	ldr	r2, [sp, #4]
    2102:	429a      	cmp	r2, r3
    2104:	d802      	bhi.n	210c <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    2106:	2301      	movs	r3, #1
    2108:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    210c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    2110:	4618      	mov	r0, r3
    2112:	b007      	add	sp, #28
    2114:	f85d fb04 	ldr.w	pc, [sp], #4

00002118 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    2118:	b082      	sub	sp, #8
    211a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    211c:	bf00      	nop
    211e:	b002      	add	sp, #8
    2120:	4770      	bx	lr

00002122 <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    2122:	b500      	push	{lr}
    2124:	b083      	sub	sp, #12
    2126:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2128:	9b01      	ldr	r3, [sp, #4]
    212a:	2b00      	cmp	r3, #0
    212c:	d002      	beq.n	2134 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    212e:	9801      	ldr	r0, [sp, #4]
    2130:	f000 f8ad 	bl	228e <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2134:	bf00      	nop
    2136:	b003      	add	sp, #12
    2138:	f85d fb04 	ldr.w	pc, [sp], #4

0000213c <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    213c:	b500      	push	{lr}
    213e:	b083      	sub	sp, #12
    2140:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2142:	9b01      	ldr	r3, [sp, #4]
    2144:	2b00      	cmp	r3, #0
    2146:	d002      	beq.n	214e <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    2148:	9801      	ldr	r0, [sp, #4]
    214a:	f000 f8cd 	bl	22e8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    214e:	bf00      	nop
    2150:	b003      	add	sp, #12
    2152:	f85d fb04 	ldr.w	pc, [sp], #4

00002156 <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2156:	b500      	push	{lr}
    2158:	b083      	sub	sp, #12
    215a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	2b00      	cmp	r3, #0
    2160:	d002      	beq.n	2168 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    2162:	9801      	ldr	r0, [sp, #4]
    2164:	f000 f8ee 	bl	2344 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2168:	bf00      	nop
    216a:	b003      	add	sp, #12
    216c:	f85d fb04 	ldr.w	pc, [sp], #4

00002170 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2170:	b500      	push	{lr}
    2172:	b083      	sub	sp, #12
    2174:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2176:	9b01      	ldr	r3, [sp, #4]
    2178:	2b00      	cmp	r3, #0
    217a:	d002      	beq.n	2182 <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    217c:	9801      	ldr	r0, [sp, #4]
    217e:	f000 f8f9 	bl	2374 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2182:	bf00      	nop
    2184:	b003      	add	sp, #12
    2186:	f85d fb04 	ldr.w	pc, [sp], #4

0000218a <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    218a:	b500      	push	{lr}
    218c:	b083      	sub	sp, #12
    218e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2190:	9b01      	ldr	r3, [sp, #4]
    2192:	2b00      	cmp	r3, #0
    2194:	d002      	beq.n	219c <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    2196:	9801      	ldr	r0, [sp, #4]
    2198:	f000 f904 	bl	23a4 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    219c:	bf00      	nop
    219e:	b003      	add	sp, #12
    21a0:	f85d fb04 	ldr.w	pc, [sp], #4

000021a4 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    21a4:	b500      	push	{lr}
    21a6:	b083      	sub	sp, #12
    21a8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21aa:	9b01      	ldr	r3, [sp, #4]
    21ac:	2b00      	cmp	r3, #0
    21ae:	d002      	beq.n	21b6 <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    21b0:	9801      	ldr	r0, [sp, #4]
    21b2:	f000 f90f 	bl	23d4 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21b6:	bf00      	nop
    21b8:	b003      	add	sp, #12
    21ba:	f85d fb04 	ldr.w	pc, [sp], #4

000021be <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    21be:	b500      	push	{lr}
    21c0:	b083      	sub	sp, #12
    21c2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21c4:	9b01      	ldr	r3, [sp, #4]
    21c6:	2b00      	cmp	r3, #0
    21c8:	d002      	beq.n	21d0 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    21ca:	9801      	ldr	r0, [sp, #4]
    21cc:	f000 f91a 	bl	2404 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21d0:	bf00      	nop
    21d2:	b003      	add	sp, #12
    21d4:	f85d fb04 	ldr.w	pc, [sp], #4

000021d8 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    21d8:	b500      	push	{lr}
    21da:	b083      	sub	sp, #12
    21dc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21de:	9b01      	ldr	r3, [sp, #4]
    21e0:	2b00      	cmp	r3, #0
    21e2:	d002      	beq.n	21ea <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    21e4:	9801      	ldr	r0, [sp, #4]
    21e6:	f000 f925 	bl	2434 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21ea:	bf00      	nop
    21ec:	b003      	add	sp, #12
    21ee:	f85d fb04 	ldr.w	pc, [sp], #4

000021f2 <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    21f2:	b500      	push	{lr}
    21f4:	b083      	sub	sp, #12
    21f6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21f8:	9b01      	ldr	r3, [sp, #4]
    21fa:	2b00      	cmp	r3, #0
    21fc:	d002      	beq.n	2204 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    21fe:	9801      	ldr	r0, [sp, #4]
    2200:	f000 f930 	bl	2464 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2204:	bf00      	nop
    2206:	b003      	add	sp, #12
    2208:	f85d fb04 	ldr.w	pc, [sp], #4

0000220c <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    220c:	b500      	push	{lr}
    220e:	b083      	sub	sp, #12
    2210:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2212:	9b01      	ldr	r3, [sp, #4]
    2214:	2b00      	cmp	r3, #0
    2216:	d002      	beq.n	221e <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    2218:	9801      	ldr	r0, [sp, #4]
    221a:	f000 f93b 	bl	2494 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    221e:	bf00      	nop
    2220:	b003      	add	sp, #12
    2222:	f85d fb04 	ldr.w	pc, [sp], #4

00002226 <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2226:	b500      	push	{lr}
    2228:	b083      	sub	sp, #12
    222a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    222c:	9b01      	ldr	r3, [sp, #4]
    222e:	2b00      	cmp	r3, #0
    2230:	d002      	beq.n	2238 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    2232:	9801      	ldr	r0, [sp, #4]
    2234:	f000 f946 	bl	24c4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2238:	bf00      	nop
    223a:	b003      	add	sp, #12
    223c:	f85d fb04 	ldr.w	pc, [sp], #4

00002240 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    2240:	b500      	push	{lr}
    2242:	b083      	sub	sp, #12
    2244:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2246:	9b01      	ldr	r3, [sp, #4]
    2248:	2b00      	cmp	r3, #0
    224a:	d002      	beq.n	2252 <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    224c:	9801      	ldr	r0, [sp, #4]
    224e:	f000 f951 	bl	24f4 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2252:	bf00      	nop
    2254:	b003      	add	sp, #12
    2256:	f85d fb04 	ldr.w	pc, [sp], #4

0000225a <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    225a:	b500      	push	{lr}
    225c:	b083      	sub	sp, #12
    225e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2260:	9b01      	ldr	r3, [sp, #4]
    2262:	2b00      	cmp	r3, #0
    2264:	d002      	beq.n	226c <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    2266:	9801      	ldr	r0, [sp, #4]
    2268:	f000 f95e 	bl	2528 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    226c:	bf00      	nop
    226e:	b003      	add	sp, #12
    2270:	f85d fb04 	ldr.w	pc, [sp], #4

00002274 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    2274:	b500      	push	{lr}
    2276:	b083      	sub	sp, #12
    2278:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    227a:	9b01      	ldr	r3, [sp, #4]
    227c:	2b00      	cmp	r3, #0
    227e:	d002      	beq.n	2286 <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    2280:	9801      	ldr	r0, [sp, #4]
    2282:	f000 f98b 	bl	259c <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2286:	bf00      	nop
    2288:	b003      	add	sp, #12
    228a:	f85d fb04 	ldr.w	pc, [sp], #4

0000228e <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    228e:	b086      	sub	sp, #24
    2290:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2292:	9b01      	ldr	r3, [sp, #4]
    2294:	681a      	ldr	r2, [r3, #0]
    2296:	4911      	ldr	r1, [pc, #68]	; (22dc <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    2298:	4613      	mov	r3, r2
    229a:	00db      	lsls	r3, r3, #3
    229c:	4413      	add	r3, r2
    229e:	440b      	add	r3, r1
    22a0:	781b      	ldrb	r3, [r3, #0]
    22a2:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    22a4:	9b01      	ldr	r3, [sp, #4]
    22a6:	685b      	ldr	r3, [r3, #4]
    22a8:	4a0d      	ldr	r2, [pc, #52]	; (22e0 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    22aa:	5cd3      	ldrb	r3, [r2, r3]
    22ac:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    22ae:	4a0d      	ldr	r2, [pc, #52]	; (22e4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    22b0:	9b05      	ldr	r3, [sp, #20]
    22b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22b6:	681b      	ldr	r3, [r3, #0]
    22b8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    22ba:	9b03      	ldr	r3, [sp, #12]
    22bc:	f023 0307 	bic.w	r3, r3, #7
    22c0:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    22c2:	9a03      	ldr	r2, [sp, #12]
    22c4:	9b04      	ldr	r3, [sp, #16]
    22c6:	4313      	orrs	r3, r2
    22c8:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    22ca:	4a06      	ldr	r2, [pc, #24]	; (22e4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    22cc:	9b05      	ldr	r3, [sp, #20]
    22ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22d2:	9a03      	ldr	r2, [sp, #12]
    22d4:	601a      	str	r2, [r3, #0]
}
    22d6:	bf00      	nop
    22d8:	b006      	add	sp, #24
    22da:	4770      	bx	lr
    22dc:	00009ad4 	.word	0x00009ad4
    22e0:	00009ecc 	.word	0x00009ecc
    22e4:	00009f10 	.word	0x00009f10

000022e8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    22e8:	b086      	sub	sp, #24
    22ea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    22ec:	9b01      	ldr	r3, [sp, #4]
    22ee:	681a      	ldr	r2, [r3, #0]
    22f0:	4911      	ldr	r1, [pc, #68]	; (2338 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    22f2:	4613      	mov	r3, r2
    22f4:	00db      	lsls	r3, r3, #3
    22f6:	4413      	add	r3, r2
    22f8:	440b      	add	r3, r1
    22fa:	781b      	ldrb	r3, [r3, #0]
    22fc:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    22fe:	9b01      	ldr	r3, [sp, #4]
    2300:	685b      	ldr	r3, [r3, #4]
    2302:	4a0e      	ldr	r2, [pc, #56]	; (233c <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    2304:	5cd3      	ldrb	r3, [r2, r3]
    2306:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    2308:	4a0d      	ldr	r2, [pc, #52]	; (2340 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    230a:	9b05      	ldr	r3, [sp, #20]
    230c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2310:	681b      	ldr	r3, [r3, #0]
    2312:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    2314:	9b03      	ldr	r3, [sp, #12]
    2316:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    231a:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    231c:	9b04      	ldr	r3, [sp, #16]
    231e:	021b      	lsls	r3, r3, #8
    2320:	9a03      	ldr	r2, [sp, #12]
    2322:	4313      	orrs	r3, r2
    2324:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    2326:	4a06      	ldr	r2, [pc, #24]	; (2340 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    2328:	9b05      	ldr	r3, [sp, #20]
    232a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    232e:	9a03      	ldr	r2, [sp, #12]
    2330:	601a      	str	r2, [r3, #0]
}
    2332:	bf00      	nop
    2334:	b006      	add	sp, #24
    2336:	4770      	bx	lr
    2338:	00009ad4 	.word	0x00009ad4
    233c:	00009ecc 	.word	0x00009ecc
    2340:	00009f10 	.word	0x00009f10

00002344 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2344:	b084      	sub	sp, #16
    2346:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2348:	4b09      	ldr	r3, [pc, #36]	; (2370 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    234a:	695b      	ldr	r3, [r3, #20]
    234c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    234e:	9b03      	ldr	r3, [sp, #12]
    2350:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2354:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    2356:	9b01      	ldr	r3, [sp, #4]
    2358:	685b      	ldr	r3, [r3, #4]
    235a:	3b01      	subs	r3, #1
    235c:	041b      	lsls	r3, r3, #16
    235e:	9a03      	ldr	r2, [sp, #12]
    2360:	4313      	orrs	r3, r2
    2362:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2364:	4a02      	ldr	r2, [pc, #8]	; (2370 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    2366:	9b03      	ldr	r3, [sp, #12]
    2368:	6153      	str	r3, [r2, #20]
}
    236a:	bf00      	nop
    236c:	b004      	add	sp, #16
    236e:	4770      	bx	lr
    2370:	40064000 	.word	0x40064000

00002374 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2374:	b084      	sub	sp, #16
    2376:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2378:	4b09      	ldr	r3, [pc, #36]	; (23a0 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    237a:	695b      	ldr	r3, [r3, #20]
    237c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    237e:	9b03      	ldr	r3, [sp, #12]
    2380:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2384:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    2386:	9b01      	ldr	r3, [sp, #4]
    2388:	685b      	ldr	r3, [r3, #4]
    238a:	3b01      	subs	r3, #1
    238c:	011b      	lsls	r3, r3, #4
    238e:	9a03      	ldr	r2, [sp, #12]
    2390:	4313      	orrs	r3, r2
    2392:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2394:	4a02      	ldr	r2, [pc, #8]	; (23a0 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    2396:	9b03      	ldr	r3, [sp, #12]
    2398:	6153      	str	r3, [r2, #20]
}
    239a:	bf00      	nop
    239c:	b004      	add	sp, #16
    239e:	4770      	bx	lr
    23a0:	40064000 	.word	0x40064000

000023a4 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    23a4:	b084      	sub	sp, #16
    23a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    23a8:	4b09      	ldr	r3, [pc, #36]	; (23d0 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    23aa:	695b      	ldr	r3, [r3, #20]
    23ac:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    23ae:	9b03      	ldr	r3, [sp, #12]
    23b0:	f023 030f 	bic.w	r3, r3, #15
    23b4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    23b6:	9b01      	ldr	r3, [sp, #4]
    23b8:	685b      	ldr	r3, [r3, #4]
    23ba:	3b01      	subs	r3, #1
    23bc:	9a03      	ldr	r2, [sp, #12]
    23be:	4313      	orrs	r3, r2
    23c0:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    23c2:	4a03      	ldr	r2, [pc, #12]	; (23d0 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    23c4:	9b03      	ldr	r3, [sp, #12]
    23c6:	6153      	str	r3, [r2, #20]
}
    23c8:	bf00      	nop
    23ca:	b004      	add	sp, #16
    23cc:	4770      	bx	lr
    23ce:	bf00      	nop
    23d0:	40064000 	.word	0x40064000

000023d4 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    23d4:	b084      	sub	sp, #16
    23d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    23d8:	4b09      	ldr	r3, [pc, #36]	; (2400 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    23da:	699b      	ldr	r3, [r3, #24]
    23dc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    23de:	9b03      	ldr	r3, [sp, #12]
    23e0:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    23e4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    23e6:	9b01      	ldr	r3, [sp, #4]
    23e8:	685b      	ldr	r3, [r3, #4]
    23ea:	3b01      	subs	r3, #1
    23ec:	041b      	lsls	r3, r3, #16
    23ee:	9a03      	ldr	r2, [sp, #12]
    23f0:	4313      	orrs	r3, r2
    23f2:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    23f4:	4a02      	ldr	r2, [pc, #8]	; (2400 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    23f6:	9b03      	ldr	r3, [sp, #12]
    23f8:	6193      	str	r3, [r2, #24]
}
    23fa:	bf00      	nop
    23fc:	b004      	add	sp, #16
    23fe:	4770      	bx	lr
    2400:	40064000 	.word	0x40064000

00002404 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2404:	b084      	sub	sp, #16
    2406:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2408:	4b09      	ldr	r3, [pc, #36]	; (2430 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    240a:	699b      	ldr	r3, [r3, #24]
    240c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    240e:	9b03      	ldr	r3, [sp, #12]
    2410:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2414:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    2416:	9b01      	ldr	r3, [sp, #4]
    2418:	685b      	ldr	r3, [r3, #4]
    241a:	3b01      	subs	r3, #1
    241c:	011b      	lsls	r3, r3, #4
    241e:	9a03      	ldr	r2, [sp, #12]
    2420:	4313      	orrs	r3, r2
    2422:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2424:	4a02      	ldr	r2, [pc, #8]	; (2430 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    2426:	9b03      	ldr	r3, [sp, #12]
    2428:	6193      	str	r3, [r2, #24]
}
    242a:	bf00      	nop
    242c:	b004      	add	sp, #16
    242e:	4770      	bx	lr
    2430:	40064000 	.word	0x40064000

00002434 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2434:	b084      	sub	sp, #16
    2436:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2438:	4b09      	ldr	r3, [pc, #36]	; (2460 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    243a:	699b      	ldr	r3, [r3, #24]
    243c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    243e:	9b03      	ldr	r3, [sp, #12]
    2440:	f023 030f 	bic.w	r3, r3, #15
    2444:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    2446:	9b01      	ldr	r3, [sp, #4]
    2448:	685b      	ldr	r3, [r3, #4]
    244a:	3b01      	subs	r3, #1
    244c:	9a03      	ldr	r2, [sp, #12]
    244e:	4313      	orrs	r3, r2
    2450:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2452:	4a03      	ldr	r2, [pc, #12]	; (2460 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    2454:	9b03      	ldr	r3, [sp, #12]
    2456:	6193      	str	r3, [r2, #24]
}
    2458:	bf00      	nop
    245a:	b004      	add	sp, #16
    245c:	4770      	bx	lr
    245e:	bf00      	nop
    2460:	40064000 	.word	0x40064000

00002464 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2464:	b084      	sub	sp, #16
    2466:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2468:	4b09      	ldr	r3, [pc, #36]	; (2490 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    246a:	69db      	ldr	r3, [r3, #28]
    246c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    246e:	9b03      	ldr	r3, [sp, #12]
    2470:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2474:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    2476:	9b01      	ldr	r3, [sp, #4]
    2478:	685b      	ldr	r3, [r3, #4]
    247a:	3b01      	subs	r3, #1
    247c:	041b      	lsls	r3, r3, #16
    247e:	9a03      	ldr	r2, [sp, #12]
    2480:	4313      	orrs	r3, r2
    2482:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    2484:	4a02      	ldr	r2, [pc, #8]	; (2490 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    2486:	9b03      	ldr	r3, [sp, #12]
    2488:	61d3      	str	r3, [r2, #28]
}
    248a:	bf00      	nop
    248c:	b004      	add	sp, #16
    248e:	4770      	bx	lr
    2490:	40064000 	.word	0x40064000

00002494 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2494:	b084      	sub	sp, #16
    2496:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2498:	4b09      	ldr	r3, [pc, #36]	; (24c0 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    249a:	69db      	ldr	r3, [r3, #28]
    249c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    249e:	9b03      	ldr	r3, [sp, #12]
    24a0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    24a4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    24a6:	9b01      	ldr	r3, [sp, #4]
    24a8:	685b      	ldr	r3, [r3, #4]
    24aa:	3b01      	subs	r3, #1
    24ac:	011b      	lsls	r3, r3, #4
    24ae:	9a03      	ldr	r2, [sp, #12]
    24b0:	4313      	orrs	r3, r2
    24b2:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    24b4:	4a02      	ldr	r2, [pc, #8]	; (24c0 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    24b6:	9b03      	ldr	r3, [sp, #12]
    24b8:	61d3      	str	r3, [r2, #28]
}
    24ba:	bf00      	nop
    24bc:	b004      	add	sp, #16
    24be:	4770      	bx	lr
    24c0:	40064000 	.word	0x40064000

000024c4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    24c4:	b084      	sub	sp, #16
    24c6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    24c8:	4b09      	ldr	r3, [pc, #36]	; (24f0 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    24ca:	69db      	ldr	r3, [r3, #28]
    24cc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    24ce:	9b03      	ldr	r3, [sp, #12]
    24d0:	f023 030f 	bic.w	r3, r3, #15
    24d4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    24d6:	9b01      	ldr	r3, [sp, #4]
    24d8:	685b      	ldr	r3, [r3, #4]
    24da:	3b01      	subs	r3, #1
    24dc:	9a03      	ldr	r2, [sp, #12]
    24de:	4313      	orrs	r3, r2
    24e0:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    24e2:	4a03      	ldr	r2, [pc, #12]	; (24f0 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    24e4:	9b03      	ldr	r3, [sp, #12]
    24e6:	61d3      	str	r3, [r2, #28]
}
    24e8:	bf00      	nop
    24ea:	b004      	add	sp, #16
    24ec:	4770      	bx	lr
    24ee:	bf00      	nop
    24f0:	40064000 	.word	0x40064000

000024f4 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    24f4:	b084      	sub	sp, #16
    24f6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    24f8:	4b0a      	ldr	r3, [pc, #40]	; (2524 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    24fa:	685b      	ldr	r3, [r3, #4]
    24fc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    24fe:	9b03      	ldr	r3, [sp, #12]
    2500:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    2504:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    2506:	9b01      	ldr	r3, [sp, #4]
    2508:	685b      	ldr	r3, [r3, #4]
    250a:	3b01      	subs	r3, #1
    250c:	021b      	lsls	r3, r3, #8
    250e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    2512:	9a03      	ldr	r2, [sp, #12]
    2514:	4313      	orrs	r3, r2
    2516:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    2518:	4a02      	ldr	r2, [pc, #8]	; (2524 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    251a:	9b03      	ldr	r3, [sp, #12]
    251c:	6053      	str	r3, [r2, #4]
}
    251e:	bf00      	nop
    2520:	b004      	add	sp, #16
    2522:	4770      	bx	lr
    2524:	40048000 	.word	0x40048000

00002528 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2528:	b084      	sub	sp, #16
    252a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    252c:	4919      	ldr	r1, [pc, #100]	; (2594 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    252e:	9b01      	ldr	r3, [sp, #4]
    2530:	681a      	ldr	r2, [r3, #0]
    2532:	4819      	ldr	r0, [pc, #100]	; (2598 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2534:	4613      	mov	r3, r2
    2536:	00db      	lsls	r3, r3, #3
    2538:	4413      	add	r3, r2
    253a:	4403      	add	r3, r0
    253c:	3305      	adds	r3, #5
    253e:	781b      	ldrb	r3, [r3, #0]
    2540:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    2544:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    2546:	9b03      	ldr	r3, [sp, #12]
    2548:	f023 030f 	bic.w	r3, r3, #15
    254c:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    254e:	9b01      	ldr	r3, [sp, #4]
    2550:	685b      	ldr	r3, [r3, #4]
    2552:	3b01      	subs	r3, #1
    2554:	f003 0307 	and.w	r3, r3, #7
    2558:	9a03      	ldr	r2, [sp, #12]
    255a:	4313      	orrs	r3, r2
    255c:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    255e:	9b01      	ldr	r3, [sp, #4]
    2560:	7a1b      	ldrb	r3, [r3, #8]
    2562:	3b01      	subs	r3, #1
    2564:	00db      	lsls	r3, r3, #3
    2566:	f003 0308 	and.w	r3, r3, #8
    256a:	9a03      	ldr	r2, [sp, #12]
    256c:	4313      	orrs	r3, r2
    256e:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    2570:	4908      	ldr	r1, [pc, #32]	; (2594 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    2572:	9b01      	ldr	r3, [sp, #4]
    2574:	681a      	ldr	r2, [r3, #0]
    2576:	4808      	ldr	r0, [pc, #32]	; (2598 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2578:	4613      	mov	r3, r2
    257a:	00db      	lsls	r3, r3, #3
    257c:	4413      	add	r3, r2
    257e:	4403      	add	r3, r0
    2580:	3305      	adds	r3, #5
    2582:	781b      	ldrb	r3, [r3, #0]
    2584:	461a      	mov	r2, r3
    2586:	9b03      	ldr	r3, [sp, #12]
    2588:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    258c:	bf00      	nop
    258e:	b004      	add	sp, #16
    2590:	4770      	bx	lr
    2592:	bf00      	nop
    2594:	40065000 	.word	0x40065000
    2598:	00009ad4 	.word	0x00009ad4

0000259c <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    259c:	b084      	sub	sp, #16
    259e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    25a0:	4b10      	ldr	r3, [pc, #64]	; (25e4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    25a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    25a4:	4a0f      	ldr	r2, [pc, #60]	; (25e4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    25a6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    25aa:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    25ac:	4b0d      	ldr	r3, [pc, #52]	; (25e4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    25ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    25b0:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    25b2:	9b03      	ldr	r3, [sp, #12]
    25b4:	f023 030f 	bic.w	r3, r3, #15
    25b8:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    25ba:	9b01      	ldr	r3, [sp, #4]
    25bc:	685b      	ldr	r3, [r3, #4]
    25be:	3b01      	subs	r3, #1
    25c0:	005b      	lsls	r3, r3, #1
    25c2:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    25c6:	9b01      	ldr	r3, [sp, #4]
    25c8:	7a1b      	ldrb	r3, [r3, #8]
    25ca:	3b01      	subs	r3, #1
    25cc:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    25d0:	4313      	orrs	r3, r2
    25d2:	9a03      	ldr	r2, [sp, #12]
    25d4:	4313      	orrs	r3, r2
    25d6:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    25d8:	4a02      	ldr	r2, [pc, #8]	; (25e4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    25da:	9b03      	ldr	r3, [sp, #12]
    25dc:	6693      	str	r3, [r2, #104]	; 0x68
}
    25de:	bf00      	nop
    25e0:	b004      	add	sp, #16
    25e2:	4770      	bx	lr
    25e4:	40048000 	.word	0x40048000

000025e8 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    25e8:	b082      	sub	sp, #8
    25ea:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    25ec:	bf00      	nop
    25ee:	b002      	add	sp, #8
    25f0:	4770      	bx	lr
	...

000025f4 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    25f4:	b082      	sub	sp, #8
    25f6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    25f8:	bf00      	nop
    25fa:	b002      	add	sp, #8
    25fc:	4770      	bx	lr

000025fe <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    25fe:	b082      	sub	sp, #8
    2600:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    2602:	bf00      	nop
    2604:	b002      	add	sp, #8
    2606:	4770      	bx	lr

00002608 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    2608:	b500      	push	{lr}
    260a:	b083      	sub	sp, #12
    260c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    260e:	9b01      	ldr	r3, [sp, #4]
    2610:	2b00      	cmp	r3, #0
    2612:	d002      	beq.n	261a <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    2614:	9801      	ldr	r0, [sp, #4]
    2616:	f000 f86a 	bl	26ee <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    261a:	bf00      	nop
    261c:	b003      	add	sp, #12
    261e:	f85d fb04 	ldr.w	pc, [sp], #4

00002622 <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    2622:	b500      	push	{lr}
    2624:	b083      	sub	sp, #12
    2626:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2628:	9b01      	ldr	r3, [sp, #4]
    262a:	2b00      	cmp	r3, #0
    262c:	d002      	beq.n	2634 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    262e:	9801      	ldr	r0, [sp, #4]
    2630:	f000 f884 	bl	273c <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    2634:	bf00      	nop
    2636:	b003      	add	sp, #12
    2638:	f85d fb04 	ldr.w	pc, [sp], #4

0000263c <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    263c:	b500      	push	{lr}
    263e:	b089      	sub	sp, #36	; 0x24
    2640:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2642:	2300      	movs	r3, #0
    2644:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    2648:	9b01      	ldr	r3, [sp, #4]
    264a:	2b00      	cmp	r3, #0
    264c:	d031      	beq.n	26b2 <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    264e:	4b1b      	ldr	r3, [pc, #108]	; (26bc <Clock_Ip_CompleteSOSC+0x80>)
    2650:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2654:	f003 0301 	and.w	r3, r3, #1
    2658:	2b00      	cmp	r3, #0
    265a:	d02a      	beq.n	26b2 <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    265c:	aa03      	add	r2, sp, #12
    265e:	a904      	add	r1, sp, #16
    2660:	a805      	add	r0, sp, #20
    2662:	f24c 3350 	movw	r3, #50000	; 0xc350
    2666:	f7ff fd1d 	bl	20a4 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    266a:	4b14      	ldr	r3, [pc, #80]	; (26bc <Clock_Ip_CompleteSOSC+0x80>)
    266c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2670:	0e1b      	lsrs	r3, r3, #24
    2672:	f003 0301 	and.w	r3, r3, #1
    2676:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2678:	9a03      	ldr	r2, [sp, #12]
    267a:	a904      	add	r1, sp, #16
    267c:	ab05      	add	r3, sp, #20
    267e:	4618      	mov	r0, r3
    2680:	f7ff fd2a 	bl	20d8 <Clock_Ip_TimeoutExpired>
    2684:	4603      	mov	r3, r0
    2686:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    268a:	9b06      	ldr	r3, [sp, #24]
    268c:	2b00      	cmp	r3, #0
    268e:	d106      	bne.n	269e <Clock_Ip_CompleteSOSC+0x62>
    2690:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2694:	f083 0301 	eor.w	r3, r3, #1
    2698:	b2db      	uxtb	r3, r3
    269a:	2b00      	cmp	r3, #0
    269c:	d1e5      	bne.n	266a <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    269e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    26a2:	2b00      	cmp	r3, #0
    26a4:	d005      	beq.n	26b2 <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    26a6:	9b01      	ldr	r3, [sp, #4]
    26a8:	681b      	ldr	r3, [r3, #0]
    26aa:	4619      	mov	r1, r3
    26ac:	2001      	movs	r0, #1
    26ae:	f7ff fce9 	bl	2084 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    26b2:	bf00      	nop
    26b4:	b009      	add	sp, #36	; 0x24
    26b6:	f85d fb04 	ldr.w	pc, [sp], #4
    26ba:	bf00      	nop
    26bc:	40064000 	.word	0x40064000

000026c0 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    26c0:	b500      	push	{lr}
    26c2:	b083      	sub	sp, #12
    26c4:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    26c6:	9801      	ldr	r0, [sp, #4]
    26c8:	f000 f8c0 	bl	284c <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    26cc:	bf00      	nop
    26ce:	b003      	add	sp, #12
    26d0:	f85d fb04 	ldr.w	pc, [sp], #4

000026d4 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    26d4:	b500      	push	{lr}
    26d6:	b083      	sub	sp, #12
    26d8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    26da:	9b01      	ldr	r3, [sp, #4]
    26dc:	2b00      	cmp	r3, #0
    26de:	d002      	beq.n	26e6 <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    26e0:	9801      	ldr	r0, [sp, #4]
    26e2:	f000 f8c3 	bl	286c <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    26e6:	bf00      	nop
    26e8:	b003      	add	sp, #12
    26ea:	f85d fb04 	ldr.w	pc, [sp], #4

000026ee <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    26ee:	b082      	sub	sp, #8
    26f0:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    26f2:	4b11      	ldr	r3, [pc, #68]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26f4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    26f8:	4a0f      	ldr	r2, [pc, #60]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26fa:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    26fe:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    2702:	4b0d      	ldr	r3, [pc, #52]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2704:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2708:	4a0b      	ldr	r2, [pc, #44]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    270a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    270e:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    2712:	4b09      	ldr	r3, [pc, #36]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2714:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2718:	4a07      	ldr	r2, [pc, #28]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    271a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    271e:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    2722:	4b05      	ldr	r3, [pc, #20]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2724:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2728:	4a03      	ldr	r2, [pc, #12]	; (2738 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    272a:	f023 0301 	bic.w	r3, r3, #1
    272e:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2732:	bf00      	nop
    2734:	b002      	add	sp, #8
    2736:	4770      	bx	lr
    2738:	40064000 	.word	0x40064000

0000273c <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    273c:	b082      	sub	sp, #8
    273e:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    2740:	9b01      	ldr	r3, [sp, #4]
    2742:	891b      	ldrh	r3, [r3, #8]
    2744:	2b01      	cmp	r3, #1
    2746:	d174      	bne.n	2832 <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    2748:	9b01      	ldr	r3, [sp, #4]
    274a:	7bdb      	ldrb	r3, [r3, #15]
    274c:	2b00      	cmp	r3, #0
    274e:	d002      	beq.n	2756 <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    2750:	2b01      	cmp	r3, #1
    2752:	d009      	beq.n	2768 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    2754:	e011      	b.n	277a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    2756:	4b39      	ldr	r3, [pc, #228]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2758:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    275c:	4a37      	ldr	r2, [pc, #220]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    275e:	f023 0308 	bic.w	r3, r3, #8
    2762:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2766:	e008      	b.n	277a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    2768:	4b34      	ldr	r3, [pc, #208]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    276a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    276e:	4a33      	ldr	r2, [pc, #204]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2770:	f043 0308 	orr.w	r3, r3, #8
    2774:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2778:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    277a:	4b30      	ldr	r3, [pc, #192]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    277c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2780:	4a2e      	ldr	r2, [pc, #184]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2782:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    2786:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    278a:	9b01      	ldr	r3, [sp, #4]
    278c:	685b      	ldr	r3, [r3, #4]
    278e:	4a2c      	ldr	r2, [pc, #176]	; (2840 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    2790:	4293      	cmp	r3, r2
    2792:	d90d      	bls.n	27b0 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    2794:	9b01      	ldr	r3, [sp, #4]
    2796:	685b      	ldr	r3, [r3, #4]
    2798:	4a2a      	ldr	r2, [pc, #168]	; (2844 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    279a:	4293      	cmp	r3, r2
    279c:	d208      	bcs.n	27b0 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    279e:	4b27      	ldr	r3, [pc, #156]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27a0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27a4:	4a25      	ldr	r2, [pc, #148]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27a6:	f043 0320 	orr.w	r3, r3, #32
    27aa:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    27ae:	e007      	b.n	27c0 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    27b0:	4b22      	ldr	r3, [pc, #136]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27b2:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27b6:	4a21      	ldr	r2, [pc, #132]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27b8:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    27bc:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    27c0:	9b01      	ldr	r3, [sp, #4]
    27c2:	7b1b      	ldrb	r3, [r3, #12]
    27c4:	2b00      	cmp	r3, #0
    27c6:	d108      	bne.n	27da <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    27c8:	4b1c      	ldr	r3, [pc, #112]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27ca:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27ce:	4a1b      	ldr	r2, [pc, #108]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27d0:	f043 0304 	orr.w	r3, r3, #4
    27d4:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    27d8:	e007      	b.n	27ea <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    27da:	4b18      	ldr	r3, [pc, #96]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27dc:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27e0:	4a16      	ldr	r2, [pc, #88]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27e2:	f023 0304 	bic.w	r3, r3, #4
    27e6:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    27ea:	9b01      	ldr	r3, [sp, #4]
    27ec:	7c1b      	ldrb	r3, [r3, #16]
    27ee:	2b02      	cmp	r3, #2
    27f0:	d011      	beq.n	2816 <Clock_Ip_SetSOSC_TrustedCall+0xda>
    27f2:	2b02      	cmp	r3, #2
    27f4:	dc14      	bgt.n	2820 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    27f6:	2b00      	cmp	r3, #0
    27f8:	d002      	beq.n	2800 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    27fa:	2b01      	cmp	r3, #1
    27fc:	d005      	beq.n	280a <Clock_Ip_SetSOSC_TrustedCall+0xce>
    27fe:	e00f      	b.n	2820 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    2800:	4b0e      	ldr	r3, [pc, #56]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2802:	2201      	movs	r2, #1
    2804:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    2808:	e014      	b.n	2834 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    280a:	4b0c      	ldr	r3, [pc, #48]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    280c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    2810:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    2814:	e00e      	b.n	2834 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    2816:	4b09      	ldr	r3, [pc, #36]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2818:	4a0b      	ldr	r2, [pc, #44]	; (2848 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    281a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    281e:	e009      	b.n	2834 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2820:	4b06      	ldr	r3, [pc, #24]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2822:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2826:	4a05      	ldr	r2, [pc, #20]	; (283c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2828:	f043 0301 	orr.w	r3, r3, #1
    282c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    2830:	e000      	b.n	2834 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    2832:	bf00      	nop
}
    2834:	bf00      	nop
    2836:	b002      	add	sp, #8
    2838:	4770      	bx	lr
    283a:	bf00      	nop
    283c:	40064000 	.word	0x40064000
    2840:	003d08ff 	.word	0x003d08ff
    2844:	007a1200 	.word	0x007a1200
    2848:	00030001 	.word	0x00030001

0000284c <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    284c:	b082      	sub	sp, #8
    284e:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    2850:	4b05      	ldr	r3, [pc, #20]	; (2868 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2852:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2856:	4a04      	ldr	r2, [pc, #16]	; (2868 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2858:	f023 0301 	bic.w	r3, r3, #1
    285c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2860:	bf00      	nop
    2862:	b002      	add	sp, #8
    2864:	4770      	bx	lr
    2866:	bf00      	nop
    2868:	40064000 	.word	0x40064000

0000286c <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    286c:	b082      	sub	sp, #8
    286e:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2870:	9b01      	ldr	r3, [sp, #4]
    2872:	891b      	ldrh	r3, [r3, #8]
    2874:	2b01      	cmp	r3, #1
    2876:	d107      	bne.n	2888 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2878:	4b05      	ldr	r3, [pc, #20]	; (2890 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    287a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    287e:	4a04      	ldr	r2, [pc, #16]	; (2890 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2880:	f043 0301 	orr.w	r3, r3, #1
    2884:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    2888:	bf00      	nop
    288a:	b002      	add	sp, #8
    288c:	4770      	bx	lr
    288e:	bf00      	nop
    2890:	40064000 	.word	0x40064000

00002894 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    2894:	b082      	sub	sp, #8
    2896:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2898:	bf00      	nop
    289a:	b002      	add	sp, #8
    289c:	4770      	bx	lr

0000289e <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    289e:	b082      	sub	sp, #8
    28a0:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    28a2:	2300      	movs	r3, #0
}
    28a4:	4618      	mov	r0, r3
    28a6:	b002      	add	sp, #8
    28a8:	4770      	bx	lr

000028aa <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    28aa:	b082      	sub	sp, #8
    28ac:	9001      	str	r0, [sp, #4]
    28ae:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    28b0:	bf00      	nop
    28b2:	b002      	add	sp, #8
    28b4:	4770      	bx	lr
	...

000028b8 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    28b8:	b082      	sub	sp, #8
    28ba:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    28bc:	bf00      	nop
    28be:	b002      	add	sp, #8
    28c0:	4770      	bx	lr

000028c2 <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    28c2:	b082      	sub	sp, #8
    28c4:	9001      	str	r0, [sp, #4]
    28c6:	460b      	mov	r3, r1
    28c8:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    28cc:	bf00      	nop
    28ce:	b002      	add	sp, #8
    28d0:	4770      	bx	lr

000028d2 <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    28d2:	b500      	push	{lr}
    28d4:	b083      	sub	sp, #12
    28d6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    28d8:	9b01      	ldr	r3, [sp, #4]
    28da:	2b00      	cmp	r3, #0
    28dc:	d002      	beq.n	28e4 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    28de:	9801      	ldr	r0, [sp, #4]
    28e0:	f000 f8e7 	bl	2ab2 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    28e4:	bf00      	nop
    28e6:	b003      	add	sp, #12
    28e8:	f85d fb04 	ldr.w	pc, [sp], #4

000028ec <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    28ec:	b500      	push	{lr}
    28ee:	b085      	sub	sp, #20
    28f0:	9001      	str	r0, [sp, #4]
    28f2:	460b      	mov	r3, r1
    28f4:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    28f8:	9b01      	ldr	r3, [sp, #4]
    28fa:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    28fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2900:	2b00      	cmp	r3, #0
    2902:	d003      	beq.n	290c <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    2904:	2300      	movs	r3, #0
    2906:	f8ad 300c 	strh.w	r3, [sp, #12]
    290a:	e002      	b.n	2912 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    290c:	2301      	movs	r3, #1
    290e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    2912:	ab02      	add	r3, sp, #8
    2914:	4618      	mov	r0, r3
    2916:	f7ff ffdc 	bl	28d2 <Clock_Ip_ClockSetSimLPO1KEnable>
}
    291a:	bf00      	nop
    291c:	b005      	add	sp, #20
    291e:	f85d fb04 	ldr.w	pc, [sp], #4

00002922 <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    2922:	b500      	push	{lr}
    2924:	b083      	sub	sp, #12
    2926:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2928:	9b01      	ldr	r3, [sp, #4]
    292a:	2b00      	cmp	r3, #0
    292c:	d002      	beq.n	2934 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    292e:	9801      	ldr	r0, [sp, #4]
    2930:	f000 f8d6 	bl	2ae0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2934:	bf00      	nop
    2936:	b003      	add	sp, #12
    2938:	f85d fb04 	ldr.w	pc, [sp], #4

0000293c <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    293c:	b500      	push	{lr}
    293e:	b085      	sub	sp, #20
    2940:	9001      	str	r0, [sp, #4]
    2942:	460b      	mov	r3, r1
    2944:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2948:	9b01      	ldr	r3, [sp, #4]
    294a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    294c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2950:	2b00      	cmp	r3, #0
    2952:	d003      	beq.n	295c <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    2954:	2300      	movs	r3, #0
    2956:	f8ad 300c 	strh.w	r3, [sp, #12]
    295a:	e002      	b.n	2962 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    295c:	2301      	movs	r3, #1
    295e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    2962:	ab02      	add	r3, sp, #8
    2964:	4618      	mov	r0, r3
    2966:	f7ff ffdc 	bl	2922 <Clock_Ip_ClockSetSimLPO32KEnable>
}
    296a:	bf00      	nop
    296c:	b005      	add	sp, #20
    296e:	f85d fb04 	ldr.w	pc, [sp], #4

00002972 <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    2972:	b500      	push	{lr}
    2974:	b083      	sub	sp, #12
    2976:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2978:	9b01      	ldr	r3, [sp, #4]
    297a:	2b00      	cmp	r3, #0
    297c:	d002      	beq.n	2984 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    297e:	9801      	ldr	r0, [sp, #4]
    2980:	f000 f8c6 	bl	2b10 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2984:	bf00      	nop
    2986:	b003      	add	sp, #12
    2988:	f85d fb04 	ldr.w	pc, [sp], #4

0000298c <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    298c:	b500      	push	{lr}
    298e:	b085      	sub	sp, #20
    2990:	9001      	str	r0, [sp, #4]
    2992:	460b      	mov	r3, r1
    2994:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2998:	9b01      	ldr	r3, [sp, #4]
    299a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    299c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    29a0:	2b00      	cmp	r3, #0
    29a2:	d003      	beq.n	29ac <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    29a4:	2300      	movs	r3, #0
    29a6:	f8ad 300c 	strh.w	r3, [sp, #12]
    29aa:	e002      	b.n	29b2 <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    29ac:	2301      	movs	r3, #1
    29ae:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    29b2:	ab02      	add	r3, sp, #8
    29b4:	4618      	mov	r0, r3
    29b6:	f7ff ffdc 	bl	2972 <Clock_Ip_ClockSetSimClkoutEnable>
}
    29ba:	bf00      	nop
    29bc:	b005      	add	sp, #20
    29be:	f85d fb04 	ldr.w	pc, [sp], #4

000029c2 <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    29c2:	b500      	push	{lr}
    29c4:	b083      	sub	sp, #12
    29c6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    29c8:	9b01      	ldr	r3, [sp, #4]
    29ca:	2b00      	cmp	r3, #0
    29cc:	d002      	beq.n	29d4 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    29ce:	9801      	ldr	r0, [sp, #4]
    29d0:	f000 f8b6 	bl	2b40 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    29d4:	bf00      	nop
    29d6:	b003      	add	sp, #12
    29d8:	f85d fb04 	ldr.w	pc, [sp], #4

000029dc <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    29dc:	b500      	push	{lr}
    29de:	b085      	sub	sp, #20
    29e0:	9001      	str	r0, [sp, #4]
    29e2:	460b      	mov	r3, r1
    29e4:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    29e8:	9b01      	ldr	r3, [sp, #4]
    29ea:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    29ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
    29f0:	2b00      	cmp	r3, #0
    29f2:	d003      	beq.n	29fc <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    29f4:	2300      	movs	r3, #0
    29f6:	f8ad 300c 	strh.w	r3, [sp, #12]
    29fa:	e002      	b.n	2a02 <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    29fc:	2301      	movs	r3, #1
    29fe:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    2a02:	ab02      	add	r3, sp, #8
    2a04:	4618      	mov	r0, r3
    2a06:	f7ff ffdc 	bl	29c2 <Clock_Ip_ClockSetPccCgcEnable>
}
    2a0a:	bf00      	nop
    2a0c:	b005      	add	sp, #20
    2a0e:	f85d fb04 	ldr.w	pc, [sp], #4

00002a12 <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    2a12:	b500      	push	{lr}
    2a14:	b083      	sub	sp, #12
    2a16:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2a18:	9b01      	ldr	r3, [sp, #4]
    2a1a:	2b00      	cmp	r3, #0
    2a1c:	d002      	beq.n	2a24 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    2a1e:	9801      	ldr	r0, [sp, #4]
    2a20:	f000 f8bc 	bl	2b9c <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2a24:	bf00      	nop
    2a26:	b003      	add	sp, #12
    2a28:	f85d fb04 	ldr.w	pc, [sp], #4

00002a2c <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    2a2c:	b500      	push	{lr}
    2a2e:	b085      	sub	sp, #20
    2a30:	9001      	str	r0, [sp, #4]
    2a32:	460b      	mov	r3, r1
    2a34:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2a38:	9b01      	ldr	r3, [sp, #4]
    2a3a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2a3c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2a40:	2b00      	cmp	r3, #0
    2a42:	d003      	beq.n	2a4c <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    2a44:	2300      	movs	r3, #0
    2a46:	f8ad 300c 	strh.w	r3, [sp, #12]
    2a4a:	e002      	b.n	2a52 <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2a4c:	2301      	movs	r3, #1
    2a4e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    2a52:	ab02      	add	r3, sp, #8
    2a54:	4618      	mov	r0, r3
    2a56:	f7ff ffdc 	bl	2a12 <Clock_Ip_ClockSetSimGate>
}
    2a5a:	bf00      	nop
    2a5c:	b005      	add	sp, #20
    2a5e:	f85d fb04 	ldr.w	pc, [sp], #4

00002a62 <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    2a62:	b500      	push	{lr}
    2a64:	b083      	sub	sp, #12
    2a66:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2a68:	9b01      	ldr	r3, [sp, #4]
    2a6a:	2b00      	cmp	r3, #0
    2a6c:	d002      	beq.n	2a74 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    2a6e:	9801      	ldr	r0, [sp, #4]
    2a70:	f000 f8c0 	bl	2bf4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2a74:	bf00      	nop
    2a76:	b003      	add	sp, #12
    2a78:	f85d fb04 	ldr.w	pc, [sp], #4

00002a7c <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2a7c:	b500      	push	{lr}
    2a7e:	b085      	sub	sp, #20
    2a80:	9001      	str	r0, [sp, #4]
    2a82:	460b      	mov	r3, r1
    2a84:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2a88:	9b01      	ldr	r3, [sp, #4]
    2a8a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2a8c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2a90:	2b00      	cmp	r3, #0
    2a92:	d003      	beq.n	2a9c <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    2a94:	2300      	movs	r3, #0
    2a96:	f8ad 300c 	strh.w	r3, [sp, #12]
    2a9a:	e002      	b.n	2aa2 <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2a9c:	2301      	movs	r3, #1
    2a9e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    2aa2:	ab02      	add	r3, sp, #8
    2aa4:	4618      	mov	r0, r3
    2aa6:	f7ff ffdc 	bl	2a62 <Clock_Ip_ClockSetSimTraceEnable>
}
    2aaa:	bf00      	nop
    2aac:	b005      	add	sp, #20
    2aae:	f85d fb04 	ldr.w	pc, [sp], #4

00002ab2 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2ab2:	b084      	sub	sp, #16
    2ab4:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2ab6:	4b09      	ldr	r3, [pc, #36]	; (2adc <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2ab8:	691b      	ldr	r3, [r3, #16]
    2aba:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    2abc:	9b03      	ldr	r3, [sp, #12]
    2abe:	f023 0301 	bic.w	r3, r3, #1
    2ac2:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    2ac4:	9b01      	ldr	r3, [sp, #4]
    2ac6:	889b      	ldrh	r3, [r3, #4]
    2ac8:	461a      	mov	r2, r3
    2aca:	9b03      	ldr	r3, [sp, #12]
    2acc:	4313      	orrs	r3, r2
    2ace:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    2ad0:	4a02      	ldr	r2, [pc, #8]	; (2adc <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2ad2:	9b03      	ldr	r3, [sp, #12]
    2ad4:	6113      	str	r3, [r2, #16]
}
    2ad6:	bf00      	nop
    2ad8:	b004      	add	sp, #16
    2ada:	4770      	bx	lr
    2adc:	40048000 	.word	0x40048000

00002ae0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2ae0:	b084      	sub	sp, #16
    2ae2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2ae4:	4b09      	ldr	r3, [pc, #36]	; (2b0c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    2ae6:	691b      	ldr	r3, [r3, #16]
    2ae8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    2aea:	9b03      	ldr	r3, [sp, #12]
    2aec:	f023 0302 	bic.w	r3, r3, #2
    2af0:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    2af2:	9b01      	ldr	r3, [sp, #4]
    2af4:	889b      	ldrh	r3, [r3, #4]
    2af6:	005b      	lsls	r3, r3, #1
    2af8:	9a03      	ldr	r2, [sp, #12]
    2afa:	4313      	orrs	r3, r2
    2afc:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    2afe:	4a03      	ldr	r2, [pc, #12]	; (2b0c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    2b00:	9b03      	ldr	r3, [sp, #12]
    2b02:	6113      	str	r3, [r2, #16]
}
    2b04:	bf00      	nop
    2b06:	b004      	add	sp, #16
    2b08:	4770      	bx	lr
    2b0a:	bf00      	nop
    2b0c:	40048000 	.word	0x40048000

00002b10 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2b10:	b084      	sub	sp, #16
    2b12:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    2b14:	4b09      	ldr	r3, [pc, #36]	; (2b3c <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    2b16:	685b      	ldr	r3, [r3, #4]
    2b18:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    2b1a:	9b03      	ldr	r3, [sp, #12]
    2b1c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    2b20:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    2b22:	9b01      	ldr	r3, [sp, #4]
    2b24:	889b      	ldrh	r3, [r3, #4]
    2b26:	02db      	lsls	r3, r3, #11
    2b28:	9a03      	ldr	r2, [sp, #12]
    2b2a:	4313      	orrs	r3, r2
    2b2c:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    2b2e:	4a03      	ldr	r2, [pc, #12]	; (2b3c <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    2b30:	9b03      	ldr	r3, [sp, #12]
    2b32:	6053      	str	r3, [r2, #4]
}
    2b34:	bf00      	nop
    2b36:	b004      	add	sp, #16
    2b38:	4770      	bx	lr
    2b3a:	bf00      	nop
    2b3c:	40048000 	.word	0x40048000

00002b40 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2b40:	b084      	sub	sp, #16
    2b42:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    2b44:	4913      	ldr	r1, [pc, #76]	; (2b94 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    2b46:	9b01      	ldr	r3, [sp, #4]
    2b48:	681a      	ldr	r2, [r3, #0]
    2b4a:	4813      	ldr	r0, [pc, #76]	; (2b98 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2b4c:	4613      	mov	r3, r2
    2b4e:	00db      	lsls	r3, r3, #3
    2b50:	4413      	add	r3, r2
    2b52:	4403      	add	r3, r0
    2b54:	3306      	adds	r3, #6
    2b56:	781b      	ldrb	r3, [r3, #0]
    2b58:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    2b5c:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    2b5e:	9b03      	ldr	r3, [sp, #12]
    2b60:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    2b64:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    2b66:	9b01      	ldr	r3, [sp, #4]
    2b68:	889b      	ldrh	r3, [r3, #4]
    2b6a:	079b      	lsls	r3, r3, #30
    2b6c:	9a03      	ldr	r2, [sp, #12]
    2b6e:	4313      	orrs	r3, r2
    2b70:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    2b72:	4908      	ldr	r1, [pc, #32]	; (2b94 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    2b74:	9b01      	ldr	r3, [sp, #4]
    2b76:	681a      	ldr	r2, [r3, #0]
    2b78:	4807      	ldr	r0, [pc, #28]	; (2b98 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2b7a:	4613      	mov	r3, r2
    2b7c:	00db      	lsls	r3, r3, #3
    2b7e:	4413      	add	r3, r2
    2b80:	4403      	add	r3, r0
    2b82:	3306      	adds	r3, #6
    2b84:	781b      	ldrb	r3, [r3, #0]
    2b86:	461a      	mov	r2, r3
    2b88:	9b03      	ldr	r3, [sp, #12]
    2b8a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    2b8e:	bf00      	nop
    2b90:	b004      	add	sp, #16
    2b92:	4770      	bx	lr
    2b94:	40065000 	.word	0x40065000
    2b98:	00009ad4 	.word	0x00009ad4

00002b9c <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2b9c:	b086      	sub	sp, #24
    2b9e:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    2ba0:	9b01      	ldr	r3, [sp, #4]
    2ba2:	889b      	ldrh	r3, [r3, #4]
    2ba4:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    2ba6:	9b01      	ldr	r3, [sp, #4]
    2ba8:	681a      	ldr	r2, [r3, #0]
    2baa:	4910      	ldr	r1, [pc, #64]	; (2bec <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    2bac:	4613      	mov	r3, r2
    2bae:	00db      	lsls	r3, r3, #3
    2bb0:	4413      	add	r3, r2
    2bb2:	440b      	add	r3, r1
    2bb4:	3306      	adds	r3, #6
    2bb6:	781b      	ldrb	r3, [r3, #0]
    2bb8:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    2bba:	4b0d      	ldr	r3, [pc, #52]	; (2bf0 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2bbc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2bbe:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    2bc0:	2201      	movs	r2, #1
    2bc2:	9b04      	ldr	r3, [sp, #16]
    2bc4:	fa02 f303 	lsl.w	r3, r2, r3
    2bc8:	43db      	mvns	r3, r3
    2bca:	9a03      	ldr	r2, [sp, #12]
    2bcc:	4013      	ands	r3, r2
    2bce:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    2bd0:	9a05      	ldr	r2, [sp, #20]
    2bd2:	9b04      	ldr	r3, [sp, #16]
    2bd4:	fa02 f303 	lsl.w	r3, r2, r3
    2bd8:	9a03      	ldr	r2, [sp, #12]
    2bda:	4313      	orrs	r3, r2
    2bdc:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    2bde:	4a04      	ldr	r2, [pc, #16]	; (2bf0 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2be0:	9b03      	ldr	r3, [sp, #12]
    2be2:	6413      	str	r3, [r2, #64]	; 0x40
}
    2be4:	bf00      	nop
    2be6:	b006      	add	sp, #24
    2be8:	4770      	bx	lr
    2bea:	bf00      	nop
    2bec:	00009ad4 	.word	0x00009ad4
    2bf0:	40048000 	.word	0x40048000

00002bf4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2bf4:	b084      	sub	sp, #16
    2bf6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    2bf8:	4b0a      	ldr	r3, [pc, #40]	; (2c24 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    2bfa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2bfc:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    2bfe:	9b01      	ldr	r3, [sp, #4]
    2c00:	889b      	ldrh	r3, [r3, #4]
    2c02:	2b01      	cmp	r3, #1
    2c04:	d104      	bne.n	2c10 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    2c06:	9b03      	ldr	r3, [sp, #12]
    2c08:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    2c0c:	9303      	str	r3, [sp, #12]
    2c0e:	e003      	b.n	2c18 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    2c10:	9b03      	ldr	r3, [sp, #12]
    2c12:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2c16:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    2c18:	4a02      	ldr	r2, [pc, #8]	; (2c24 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    2c1a:	9b03      	ldr	r3, [sp, #12]
    2c1c:	6693      	str	r3, [r2, #104]	; 0x68
}
    2c1e:	bf00      	nop
    2c20:	b004      	add	sp, #16
    2c22:	4770      	bx	lr
    2c24:	40048000 	.word	0x40048000

00002c28 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    2c28:	b082      	sub	sp, #8
    2c2a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2c2c:	bf00      	nop
    2c2e:	b002      	add	sp, #8
    2c30:	4770      	bx	lr

00002c32 <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    2c32:	b082      	sub	sp, #8
    2c34:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    2c36:	bf00      	nop
    2c38:	b002      	add	sp, #8
    2c3a:	4770      	bx	lr

00002c3c <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2c3c:	b500      	push	{lr}
    2c3e:	b083      	sub	sp, #12
    2c40:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c42:	9b01      	ldr	r3, [sp, #4]
    2c44:	2b00      	cmp	r3, #0
    2c46:	d002      	beq.n	2c4e <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    2c48:	9801      	ldr	r0, [sp, #4]
    2c4a:	f000 f8d1 	bl	2df0 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c4e:	bf00      	nop
    2c50:	b003      	add	sp, #12
    2c52:	f85d fb04 	ldr.w	pc, [sp], #4

00002c56 <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2c56:	b500      	push	{lr}
    2c58:	b083      	sub	sp, #12
    2c5a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c5c:	9b01      	ldr	r3, [sp, #4]
    2c5e:	2b00      	cmp	r3, #0
    2c60:	d002      	beq.n	2c68 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    2c62:	9801      	ldr	r0, [sp, #4]
    2c64:	f000 f950 	bl	2f08 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c68:	bf00      	nop
    2c6a:	b003      	add	sp, #12
    2c6c:	f85d fb04 	ldr.w	pc, [sp], #4

00002c70 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    2c70:	b500      	push	{lr}
    2c72:	b083      	sub	sp, #12
    2c74:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    2c76:	9801      	ldr	r0, [sp, #4]
    2c78:	f000 f98e 	bl	2f98 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2c7c:	bf00      	nop
    2c7e:	b003      	add	sp, #12
    2c80:	f85d fb04 	ldr.w	pc, [sp], #4

00002c84 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2c84:	b500      	push	{lr}
    2c86:	b083      	sub	sp, #12
    2c88:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c8a:	9b01      	ldr	r3, [sp, #4]
    2c8c:	2b00      	cmp	r3, #0
    2c8e:	d002      	beq.n	2c96 <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    2c90:	9801      	ldr	r0, [sp, #4]
    2c92:	f000 f999 	bl	2fc8 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c96:	bf00      	nop
    2c98:	b003      	add	sp, #12
    2c9a:	f85d fb04 	ldr.w	pc, [sp], #4

00002c9e <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2c9e:	b500      	push	{lr}
    2ca0:	b083      	sub	sp, #12
    2ca2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ca4:	9b01      	ldr	r3, [sp, #4]
    2ca6:	2b00      	cmp	r3, #0
    2ca8:	d002      	beq.n	2cb0 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    2caa:	9801      	ldr	r0, [sp, #4]
    2cac:	f000 f9b0 	bl	3010 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cb0:	bf00      	nop
    2cb2:	b003      	add	sp, #12
    2cb4:	f85d fb04 	ldr.w	pc, [sp], #4

00002cb8 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    2cb8:	b500      	push	{lr}
    2cba:	b083      	sub	sp, #12
    2cbc:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    2cbe:	9801      	ldr	r0, [sp, #4]
    2cc0:	f000 f9ba 	bl	3038 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2cc4:	bf00      	nop
    2cc6:	b003      	add	sp, #12
    2cc8:	f85d fb04 	ldr.w	pc, [sp], #4

00002ccc <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2ccc:	b500      	push	{lr}
    2cce:	b083      	sub	sp, #12
    2cd0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2cd2:	9b01      	ldr	r3, [sp, #4]
    2cd4:	2b00      	cmp	r3, #0
    2cd6:	d002      	beq.n	2cde <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    2cd8:	9801      	ldr	r0, [sp, #4]
    2cda:	f000 f9bd 	bl	3058 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cde:	bf00      	nop
    2ce0:	b003      	add	sp, #12
    2ce2:	f85d fb04 	ldr.w	pc, [sp], #4

00002ce6 <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2ce6:	b500      	push	{lr}
    2ce8:	b083      	sub	sp, #12
    2cea:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2cec:	9b01      	ldr	r3, [sp, #4]
    2cee:	2b00      	cmp	r3, #0
    2cf0:	d002      	beq.n	2cf8 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    2cf2:	9801      	ldr	r0, [sp, #4]
    2cf4:	f000 f9d4 	bl	30a0 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cf8:	bf00      	nop
    2cfa:	b003      	add	sp, #12
    2cfc:	f85d fb04 	ldr.w	pc, [sp], #4

00002d00 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    2d00:	b500      	push	{lr}
    2d02:	b083      	sub	sp, #12
    2d04:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    2d06:	9801      	ldr	r0, [sp, #4]
    2d08:	f000 f9de 	bl	30c8 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2d0c:	bf00      	nop
    2d0e:	b003      	add	sp, #12
    2d10:	f85d fb04 	ldr.w	pc, [sp], #4

00002d14 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    2d14:	b500      	push	{lr}
    2d16:	b089      	sub	sp, #36	; 0x24
    2d18:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    2d1a:	2300      	movs	r3, #0
    2d1c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    2d20:	4b20      	ldr	r3, [pc, #128]	; (2da4 <SetInputSouceSytemClock+0x90>)
    2d22:	695b      	ldr	r3, [r3, #20]
    2d24:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    2d26:	9b06      	ldr	r3, [sp, #24]
    2d28:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    2d2c:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    2d2e:	9b01      	ldr	r3, [sp, #4]
    2d30:	061b      	lsls	r3, r3, #24
    2d32:	9a06      	ldr	r2, [sp, #24]
    2d34:	4313      	orrs	r3, r2
    2d36:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    2d38:	4a1a      	ldr	r2, [pc, #104]	; (2da4 <SetInputSouceSytemClock+0x90>)
    2d3a:	9b06      	ldr	r3, [sp, #24]
    2d3c:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2d3e:	aa02      	add	r2, sp, #8
    2d40:	a903      	add	r1, sp, #12
    2d42:	a804      	add	r0, sp, #16
    2d44:	f24c 3350 	movw	r3, #50000	; 0xc350
    2d48:	f7ff f9ac 	bl	20a4 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    2d4c:	4b15      	ldr	r3, [pc, #84]	; (2da4 <SetInputSouceSytemClock+0x90>)
    2d4e:	691b      	ldr	r3, [r3, #16]
    2d50:	0e1b      	lsrs	r3, r3, #24
    2d52:	f003 030f 	and.w	r3, r3, #15
    2d56:	9a01      	ldr	r2, [sp, #4]
    2d58:	429a      	cmp	r2, r3
    2d5a:	bf0c      	ite	eq
    2d5c:	2301      	moveq	r3, #1
    2d5e:	2300      	movne	r3, #0
    2d60:	b2db      	uxtb	r3, r3
    2d62:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2d64:	9a02      	ldr	r2, [sp, #8]
    2d66:	a903      	add	r1, sp, #12
    2d68:	ab04      	add	r3, sp, #16
    2d6a:	4618      	mov	r0, r3
    2d6c:	f7ff f9b4 	bl	20d8 <Clock_Ip_TimeoutExpired>
    2d70:	4603      	mov	r3, r0
    2d72:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    2d76:	9b05      	ldr	r3, [sp, #20]
    2d78:	2b00      	cmp	r3, #0
    2d7a:	d106      	bne.n	2d8a <SetInputSouceSytemClock+0x76>
    2d7c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d80:	f083 0301 	eor.w	r3, r3, #1
    2d84:	b2db      	uxtb	r3, r3
    2d86:	2b00      	cmp	r3, #0
    2d88:	d1e0      	bne.n	2d4c <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    2d8a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d8e:	2b00      	cmp	r3, #0
    2d90:	d003      	beq.n	2d9a <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    2d92:	2105      	movs	r1, #5
    2d94:	2001      	movs	r0, #1
    2d96:	f7ff f975 	bl	2084 <Clock_Ip_ReportClockErrors>
    }
}
    2d9a:	bf00      	nop
    2d9c:	b009      	add	sp, #36	; 0x24
    2d9e:	f85d fb04 	ldr.w	pc, [sp], #4
    2da2:	bf00      	nop
    2da4:	40064000 	.word	0x40064000

00002da8 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2da8:	b500      	push	{lr}
    2daa:	b083      	sub	sp, #12
    2dac:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2dae:	9b01      	ldr	r3, [sp, #4]
    2db0:	2b00      	cmp	r3, #0
    2db2:	d002      	beq.n	2dba <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    2db4:	9801      	ldr	r0, [sp, #4]
    2db6:	f000 f997 	bl	30e8 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2dba:	bf00      	nop
    2dbc:	b003      	add	sp, #12
    2dbe:	f85d fb04 	ldr.w	pc, [sp], #4

00002dc2 <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2dc2:	b500      	push	{lr}
    2dc4:	b083      	sub	sp, #12
    2dc6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2dc8:	9b01      	ldr	r3, [sp, #4]
    2dca:	2b00      	cmp	r3, #0
    2dcc:	d002      	beq.n	2dd4 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    2dce:	9801      	ldr	r0, [sp, #4]
    2dd0:	f000 fa7e 	bl	32d0 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2dd4:	bf00      	nop
    2dd6:	b003      	add	sp, #12
    2dd8:	f85d fb04 	ldr.w	pc, [sp], #4

00002ddc <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    2ddc:	b500      	push	{lr}
    2dde:	b083      	sub	sp, #12
    2de0:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    2de2:	9801      	ldr	r0, [sp, #4]
    2de4:	f000 fab8 	bl	3358 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2de8:	bf00      	nop
    2dea:	b003      	add	sp, #12
    2dec:	f85d fb04 	ldr.w	pc, [sp], #4

00002df0 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2df0:	b500      	push	{lr}
    2df2:	b08b      	sub	sp, #44	; 0x2c
    2df4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2df6:	2300      	movs	r3, #0
    2df8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    2dfc:	9b01      	ldr	r3, [sp, #4]
    2dfe:	2b00      	cmp	r3, #0
    2e00:	d10b      	bne.n	2e1a <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    2e02:	2305      	movs	r3, #5
    2e04:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    2e06:	2301      	movs	r3, #1
    2e08:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    2e0c:	2301      	movs	r3, #1
    2e0e:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    2e12:	2301      	movs	r3, #1
    2e14:	f88d 3010 	strb.w	r3, [sp, #16]
    2e18:	e00e      	b.n	2e38 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    2e1a:	9b01      	ldr	r3, [sp, #4]
    2e1c:	681b      	ldr	r3, [r3, #0]
    2e1e:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    2e20:	9b01      	ldr	r3, [sp, #4]
    2e22:	79db      	ldrb	r3, [r3, #7]
    2e24:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    2e28:	9b01      	ldr	r3, [sp, #4]
    2e2a:	889b      	ldrh	r3, [r3, #4]
    2e2c:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    2e30:	9b01      	ldr	r3, [sp, #4]
    2e32:	7a1b      	ldrb	r3, [r3, #8]
    2e34:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2e38:	4b32      	ldr	r3, [pc, #200]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e3a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e3e:	4a31      	ldr	r2, [pc, #196]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e40:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2e44:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    2e48:	4b2e      	ldr	r3, [pc, #184]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e4a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e4e:	4a2d      	ldr	r2, [pc, #180]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e50:	f023 0301 	bic.w	r3, r3, #1
    2e54:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2e58:	4b2a      	ldr	r3, [pc, #168]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e5a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e5e:	4a29      	ldr	r2, [pc, #164]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e60:	f023 0304 	bic.w	r3, r3, #4
    2e64:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    2e68:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    2e6c:	2b01      	cmp	r3, #1
    2e6e:	d144      	bne.n	2efa <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    2e70:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2e74:	4a23      	ldr	r2, [pc, #140]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e76:	f003 0301 	and.w	r3, r3, #1
    2e7a:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2e7e:	4b21      	ldr	r3, [pc, #132]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e80:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e84:	4a1f      	ldr	r2, [pc, #124]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e86:	f043 0301 	orr.w	r3, r3, #1
    2e8a:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    2e8e:	4b1d      	ldr	r3, [pc, #116]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e90:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2e94:	f89d 3010 	ldrb.w	r3, [sp, #16]
    2e98:	009b      	lsls	r3, r3, #2
    2e9a:	f003 0304 	and.w	r3, r3, #4
    2e9e:	4919      	ldr	r1, [pc, #100]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2ea0:	4313      	orrs	r3, r2
    2ea2:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2ea6:	aa05      	add	r2, sp, #20
    2ea8:	a906      	add	r1, sp, #24
    2eaa:	a807      	add	r0, sp, #28
    2eac:	f24c 3350 	movw	r3, #50000	; 0xc350
    2eb0:	f7ff f8f8 	bl	20a4 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2eb4:	4b13      	ldr	r3, [pc, #76]	; (2f04 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2eb6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2eba:	0e1b      	lsrs	r3, r3, #24
    2ebc:	f003 0301 	and.w	r3, r3, #1
    2ec0:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2ec2:	9a05      	ldr	r2, [sp, #20]
    2ec4:	a906      	add	r1, sp, #24
    2ec6:	ab07      	add	r3, sp, #28
    2ec8:	4618      	mov	r0, r3
    2eca:	f7ff f905 	bl	20d8 <Clock_Ip_TimeoutExpired>
    2ece:	4603      	mov	r3, r0
    2ed0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2ed4:	9b08      	ldr	r3, [sp, #32]
    2ed6:	2b00      	cmp	r3, #0
    2ed8:	d106      	bne.n	2ee8 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    2eda:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2ede:	f083 0301 	eor.w	r3, r3, #1
    2ee2:	b2db      	uxtb	r3, r3
    2ee4:	2b00      	cmp	r3, #0
    2ee6:	d1e5      	bne.n	2eb4 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    2ee8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2eec:	2b00      	cmp	r3, #0
    2eee:	d004      	beq.n	2efa <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    2ef0:	9b02      	ldr	r3, [sp, #8]
    2ef2:	4619      	mov	r1, r3
    2ef4:	2001      	movs	r0, #1
    2ef6:	f7ff f8c5 	bl	2084 <Clock_Ip_ReportClockErrors>
        }
    }
}
    2efa:	bf00      	nop
    2efc:	b00b      	add	sp, #44	; 0x2c
    2efe:	f85d fb04 	ldr.w	pc, [sp], #4
    2f02:	bf00      	nop
    2f04:	40064000 	.word	0x40064000

00002f08 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2f08:	b500      	push	{lr}
    2f0a:	b089      	sub	sp, #36	; 0x24
    2f0c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2f0e:	2300      	movs	r3, #0
    2f10:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2f14:	4b1f      	ldr	r3, [pc, #124]	; (2f94 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f16:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f1a:	4a1e      	ldr	r2, [pc, #120]	; (2f94 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f1c:	f043 0301 	orr.w	r3, r3, #1
    2f20:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    2f24:	4b1b      	ldr	r3, [pc, #108]	; (2f94 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f26:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f2a:	4a1a      	ldr	r2, [pc, #104]	; (2f94 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f2c:	f043 0304 	orr.w	r3, r3, #4
    2f30:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2f34:	aa03      	add	r2, sp, #12
    2f36:	a904      	add	r1, sp, #16
    2f38:	a805      	add	r0, sp, #20
    2f3a:	f24c 3350 	movw	r3, #50000	; 0xc350
    2f3e:	f7ff f8b1 	bl	20a4 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2f42:	4b14      	ldr	r3, [pc, #80]	; (2f94 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f44:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f48:	0e1b      	lsrs	r3, r3, #24
    2f4a:	f003 0301 	and.w	r3, r3, #1
    2f4e:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2f50:	9a03      	ldr	r2, [sp, #12]
    2f52:	a904      	add	r1, sp, #16
    2f54:	ab05      	add	r3, sp, #20
    2f56:	4618      	mov	r0, r3
    2f58:	f7ff f8be 	bl	20d8 <Clock_Ip_TimeoutExpired>
    2f5c:	4603      	mov	r3, r0
    2f5e:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2f62:	9b06      	ldr	r3, [sp, #24]
    2f64:	2b00      	cmp	r3, #0
    2f66:	d106      	bne.n	2f76 <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    2f68:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2f6c:	f083 0301 	eor.w	r3, r3, #1
    2f70:	b2db      	uxtb	r3, r3
    2f72:	2b00      	cmp	r3, #0
    2f74:	d1e5      	bne.n	2f42 <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    2f76:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2f7a:	2b00      	cmp	r3, #0
    2f7c:	d005      	beq.n	2f8a <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2f7e:	9b01      	ldr	r3, [sp, #4]
    2f80:	681b      	ldr	r3, [r3, #0]
    2f82:	4619      	mov	r1, r3
    2f84:	2001      	movs	r0, #1
    2f86:	f7ff f87d 	bl	2084 <Clock_Ip_ReportClockErrors>
    }
}
    2f8a:	bf00      	nop
    2f8c:	b009      	add	sp, #36	; 0x24
    2f8e:	f85d fb04 	ldr.w	pc, [sp], #4
    2f92:	bf00      	nop
    2f94:	40064000 	.word	0x40064000

00002f98 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    2f98:	b082      	sub	sp, #8
    2f9a:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    2f9c:	4b09      	ldr	r3, [pc, #36]	; (2fc4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2f9e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fa2:	4a08      	ldr	r2, [pc, #32]	; (2fc4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2fa4:	f023 0301 	bic.w	r3, r3, #1
    2fa8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2fac:	4b05      	ldr	r3, [pc, #20]	; (2fc4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2fae:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fb2:	4a04      	ldr	r2, [pc, #16]	; (2fc4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2fb4:	f023 0304 	bic.w	r3, r3, #4
    2fb8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2fbc:	bf00      	nop
    2fbe:	b002      	add	sp, #8
    2fc0:	4770      	bx	lr
    2fc2:	bf00      	nop
    2fc4:	40064000 	.word	0x40064000

00002fc8 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2fc8:	b082      	sub	sp, #8
    2fca:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2fcc:	4b0f      	ldr	r3, [pc, #60]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fce:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fd2:	4a0e      	ldr	r2, [pc, #56]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fd4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2fd8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2fdc:	4b0b      	ldr	r3, [pc, #44]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fde:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fe2:	4a0a      	ldr	r2, [pc, #40]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fe4:	f023 0304 	bic.w	r3, r3, #4
    2fe8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    2fec:	4b07      	ldr	r3, [pc, #28]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fee:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2ff2:	9b01      	ldr	r3, [sp, #4]
    2ff4:	7a1b      	ldrb	r3, [r3, #8]
    2ff6:	009b      	lsls	r3, r3, #2
    2ff8:	f003 0304 	and.w	r3, r3, #4
    2ffc:	4903      	ldr	r1, [pc, #12]	; (300c <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2ffe:	4313      	orrs	r3, r2
    3000:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3004:	bf00      	nop
    3006:	b002      	add	sp, #8
    3008:	4770      	bx	lr
    300a:	bf00      	nop
    300c:	40064000 	.word	0x40064000

00003010 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3010:	b082      	sub	sp, #8
    3012:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3014:	9b01      	ldr	r3, [sp, #4]
    3016:	889b      	ldrh	r3, [r3, #4]
    3018:	2b01      	cmp	r3, #1
    301a:	d107      	bne.n	302c <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    301c:	4b05      	ldr	r3, [pc, #20]	; (3034 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    301e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3022:	4a04      	ldr	r2, [pc, #16]	; (3034 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3024:	f043 0304 	orr.w	r3, r3, #4
    3028:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    302c:	bf00      	nop
    302e:	b002      	add	sp, #8
    3030:	4770      	bx	lr
    3032:	bf00      	nop
    3034:	40064000 	.word	0x40064000

00003038 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    3038:	b082      	sub	sp, #8
    303a:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    303c:	4b05      	ldr	r3, [pc, #20]	; (3054 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    303e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3042:	4a04      	ldr	r2, [pc, #16]	; (3054 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3044:	f023 0304 	bic.w	r3, r3, #4
    3048:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    304c:	bf00      	nop
    304e:	b002      	add	sp, #8
    3050:	4770      	bx	lr
    3052:	bf00      	nop
    3054:	40064000 	.word	0x40064000

00003058 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3058:	b082      	sub	sp, #8
    305a:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    305c:	4b0f      	ldr	r3, [pc, #60]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    305e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3062:	4a0e      	ldr	r2, [pc, #56]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3064:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3068:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    306c:	4b0b      	ldr	r3, [pc, #44]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    306e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3072:	4a0a      	ldr	r2, [pc, #40]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3074:	f023 0302 	bic.w	r3, r3, #2
    3078:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    307c:	4b07      	ldr	r3, [pc, #28]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    307e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3082:	9b01      	ldr	r3, [sp, #4]
    3084:	7a5b      	ldrb	r3, [r3, #9]
    3086:	005b      	lsls	r3, r3, #1
    3088:	f003 0302 	and.w	r3, r3, #2
    308c:	4903      	ldr	r1, [pc, #12]	; (309c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    308e:	4313      	orrs	r3, r2
    3090:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3094:	bf00      	nop
    3096:	b002      	add	sp, #8
    3098:	4770      	bx	lr
    309a:	bf00      	nop
    309c:	40064000 	.word	0x40064000

000030a0 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    30a0:	b082      	sub	sp, #8
    30a2:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    30a4:	9b01      	ldr	r3, [sp, #4]
    30a6:	889b      	ldrh	r3, [r3, #4]
    30a8:	2b01      	cmp	r3, #1
    30aa:	d107      	bne.n	30bc <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    30ac:	4b05      	ldr	r3, [pc, #20]	; (30c4 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    30ae:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    30b2:	4a04      	ldr	r2, [pc, #16]	; (30c4 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    30b4:	f043 0302 	orr.w	r3, r3, #2
    30b8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    30bc:	bf00      	nop
    30be:	b002      	add	sp, #8
    30c0:	4770      	bx	lr
    30c2:	bf00      	nop
    30c4:	40064000 	.word	0x40064000

000030c8 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    30c8:	b082      	sub	sp, #8
    30ca:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    30cc:	4b05      	ldr	r3, [pc, #20]	; (30e4 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    30ce:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    30d2:	4a04      	ldr	r2, [pc, #16]	; (30e4 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    30d4:	f023 0302 	bic.w	r3, r3, #2
    30d8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    30dc:	bf00      	nop
    30de:	b002      	add	sp, #8
    30e0:	4770      	bx	lr
    30e2:	bf00      	nop
    30e4:	40064000 	.word	0x40064000

000030e8 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    30e8:	b500      	push	{lr}
    30ea:	b08b      	sub	sp, #44	; 0x2c
    30ec:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    30ee:	9b01      	ldr	r3, [sp, #4]
    30f0:	681a      	ldr	r2, [r3, #0]
    30f2:	4975      	ldr	r1, [pc, #468]	; (32c8 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    30f4:	4613      	mov	r3, r2
    30f6:	00db      	lsls	r3, r3, #3
    30f8:	4413      	add	r3, r2
    30fa:	440b      	add	r3, r1
    30fc:	781b      	ldrb	r3, [r3, #0]
    30fe:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    3100:	2300      	movs	r3, #0
    3102:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    3106:	2300      	movs	r3, #0
    3108:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    310c:	4b6f      	ldr	r3, [pc, #444]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    310e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3112:	4a6e      	ldr	r2, [pc, #440]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3114:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3118:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    311c:	4b6b      	ldr	r3, [pc, #428]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    311e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3122:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    3126:	2b00      	cmp	r3, #0
    3128:	d07d      	beq.n	3226 <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    312a:	9b01      	ldr	r3, [sp, #4]
    312c:	79db      	ldrb	r3, [r3, #7]
    312e:	461a      	mov	r2, r3
    3130:	4b66      	ldr	r3, [pc, #408]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3132:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3136:	f003 0303 	and.w	r3, r3, #3
    313a:	429a      	cmp	r2, r3
    313c:	d10b      	bne.n	3156 <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    313e:	9b01      	ldr	r3, [sp, #4]
    3140:	799b      	ldrb	r3, [r3, #6]
    3142:	461a      	mov	r2, r3
    3144:	4b61      	ldr	r3, [pc, #388]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3146:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    314a:	08db      	lsrs	r3, r3, #3
    314c:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3150:	429a      	cmp	r2, r3
    3152:	f000 80b4 	beq.w	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    3156:	4b5d      	ldr	r3, [pc, #372]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3158:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    315c:	f003 0301 	and.w	r3, r3, #1
    3160:	2b00      	cmp	r3, #0
    3162:	d105      	bne.n	3170 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    3164:	2301      	movs	r3, #1
    3166:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    316a:	2000      	movs	r0, #0
    316c:	f7ff fd66 	bl	2c3c <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    3170:	2002      	movs	r0, #2
    3172:	f7ff fdcf 	bl	2d14 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3176:	4b55      	ldr	r3, [pc, #340]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3178:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    317c:	4a53      	ldr	r2, [pc, #332]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    317e:	f023 0301 	bic.w	r3, r3, #1
    3182:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    3186:	9b01      	ldr	r3, [sp, #4]
    3188:	889b      	ldrh	r3, [r3, #4]
    318a:	2b01      	cmp	r3, #1
    318c:	f040 8097 	bne.w	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3190:	9b01      	ldr	r3, [sp, #4]
    3192:	79db      	ldrb	r3, [r3, #7]
    3194:	4a4d      	ldr	r2, [pc, #308]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3196:	f003 0303 	and.w	r3, r3, #3
    319a:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    319e:	4b4b      	ldr	r3, [pc, #300]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    31a0:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    31a4:	9b01      	ldr	r3, [sp, #4]
    31a6:	799b      	ldrb	r3, [r3, #6]
    31a8:	00db      	lsls	r3, r3, #3
    31aa:	f003 0308 	and.w	r3, r3, #8
    31ae:	4313      	orrs	r3, r2
    31b0:	4a46      	ldr	r2, [pc, #280]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    31b2:	f043 0301 	orr.w	r3, r3, #1
    31b6:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    31ba:	aa03      	add	r2, sp, #12
    31bc:	a904      	add	r1, sp, #16
    31be:	a805      	add	r0, sp, #20
    31c0:	f24c 3350 	movw	r3, #50000	; 0xc350
    31c4:	f7fe ff6e 	bl	20a4 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    31c8:	4b40      	ldr	r3, [pc, #256]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    31ca:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    31ce:	0e1b      	lsrs	r3, r3, #24
    31d0:	f003 0301 	and.w	r3, r3, #1
    31d4:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    31d6:	9a03      	ldr	r2, [sp, #12]
    31d8:	a904      	add	r1, sp, #16
    31da:	ab05      	add	r3, sp, #20
    31dc:	4618      	mov	r0, r3
    31de:	f7fe ff7b 	bl	20d8 <Clock_Ip_TimeoutExpired>
    31e2:	4603      	mov	r3, r0
    31e4:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    31e8:	9b06      	ldr	r3, [sp, #24]
    31ea:	2b00      	cmp	r3, #0
    31ec:	d106      	bne.n	31fc <Clock_Ip_SetFirc_TrustedCall+0x114>
    31ee:	f89d 301f 	ldrb.w	r3, [sp, #31]
    31f2:	f083 0301 	eor.w	r3, r3, #1
    31f6:	b2db      	uxtb	r3, r3
    31f8:	2b00      	cmp	r3, #0
    31fa:	d1e5      	bne.n	31c8 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    31fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3200:	2b00      	cmp	r3, #0
    3202:	d005      	beq.n	3210 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3204:	9b01      	ldr	r3, [sp, #4]
    3206:	681b      	ldr	r3, [r3, #0]
    3208:	4619      	mov	r1, r3
    320a:	2001      	movs	r0, #1
    320c:	f7fe ff3a 	bl	2084 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    3210:	2003      	movs	r0, #3
    3212:	f7ff fd7f 	bl	2d14 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    3216:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    321a:	2b00      	cmp	r3, #0
    321c:	d04f      	beq.n	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    321e:	2002      	movs	r0, #2
    3220:	f7ff fd26 	bl	2c70 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    3224:	e04b      	b.n	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3226:	4b29      	ldr	r3, [pc, #164]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3228:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    322c:	4a27      	ldr	r2, [pc, #156]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    322e:	f023 0301 	bic.w	r3, r3, #1
    3232:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    3236:	9b01      	ldr	r3, [sp, #4]
    3238:	889b      	ldrh	r3, [r3, #4]
    323a:	2b01      	cmp	r3, #1
    323c:	d13f      	bne.n	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    323e:	9b01      	ldr	r3, [sp, #4]
    3240:	79db      	ldrb	r3, [r3, #7]
    3242:	4a22      	ldr	r2, [pc, #136]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3244:	f003 0303 	and.w	r3, r3, #3
    3248:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    324c:	4b1f      	ldr	r3, [pc, #124]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    324e:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3252:	9b01      	ldr	r3, [sp, #4]
    3254:	799b      	ldrb	r3, [r3, #6]
    3256:	00db      	lsls	r3, r3, #3
    3258:	f003 0308 	and.w	r3, r3, #8
    325c:	4313      	orrs	r3, r2
    325e:	4a1b      	ldr	r2, [pc, #108]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3260:	f043 0301 	orr.w	r3, r3, #1
    3264:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3268:	aa03      	add	r2, sp, #12
    326a:	a904      	add	r1, sp, #16
    326c:	a805      	add	r0, sp, #20
    326e:	f24c 3350 	movw	r3, #50000	; 0xc350
    3272:	f7fe ff17 	bl	20a4 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3276:	4b15      	ldr	r3, [pc, #84]	; (32cc <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3278:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    327c:	0e1b      	lsrs	r3, r3, #24
    327e:	f003 0301 	and.w	r3, r3, #1
    3282:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3284:	9a03      	ldr	r2, [sp, #12]
    3286:	a904      	add	r1, sp, #16
    3288:	ab05      	add	r3, sp, #20
    328a:	4618      	mov	r0, r3
    328c:	f7fe ff24 	bl	20d8 <Clock_Ip_TimeoutExpired>
    3290:	4603      	mov	r3, r0
    3292:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3296:	9b06      	ldr	r3, [sp, #24]
    3298:	2b00      	cmp	r3, #0
    329a:	d106      	bne.n	32aa <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    329c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    32a0:	f083 0301 	eor.w	r3, r3, #1
    32a4:	b2db      	uxtb	r3, r3
    32a6:	2b00      	cmp	r3, #0
    32a8:	d1e5      	bne.n	3276 <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    32aa:	f89d 301f 	ldrb.w	r3, [sp, #31]
    32ae:	2b00      	cmp	r3, #0
    32b0:	d005      	beq.n	32be <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    32b2:	9b01      	ldr	r3, [sp, #4]
    32b4:	681b      	ldr	r3, [r3, #0]
    32b6:	4619      	mov	r1, r3
    32b8:	2001      	movs	r0, #1
    32ba:	f7fe fee3 	bl	2084 <Clock_Ip_ReportClockErrors>
}
    32be:	bf00      	nop
    32c0:	b00b      	add	sp, #44	; 0x2c
    32c2:	f85d fb04 	ldr.w	pc, [sp], #4
    32c6:	bf00      	nop
    32c8:	00009ad4 	.word	0x00009ad4
    32cc:	40064000 	.word	0x40064000

000032d0 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    32d0:	b500      	push	{lr}
    32d2:	b089      	sub	sp, #36	; 0x24
    32d4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    32d6:	2300      	movs	r3, #0
    32d8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    32dc:	9b01      	ldr	r3, [sp, #4]
    32de:	889b      	ldrh	r3, [r3, #4]
    32e0:	2b01      	cmp	r3, #1
    32e2:	d132      	bne.n	334a <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    32e4:	4b1b      	ldr	r3, [pc, #108]	; (3354 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    32e6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    32ea:	4a1a      	ldr	r2, [pc, #104]	; (3354 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    32ec:	f043 0301 	orr.w	r3, r3, #1
    32f0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    32f4:	aa03      	add	r2, sp, #12
    32f6:	a904      	add	r1, sp, #16
    32f8:	a805      	add	r0, sp, #20
    32fa:	f24c 3350 	movw	r3, #50000	; 0xc350
    32fe:	f7fe fed1 	bl	20a4 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3302:	4b14      	ldr	r3, [pc, #80]	; (3354 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    3304:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3308:	0e1b      	lsrs	r3, r3, #24
    330a:	f003 0301 	and.w	r3, r3, #1
    330e:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3310:	9a03      	ldr	r2, [sp, #12]
    3312:	a904      	add	r1, sp, #16
    3314:	ab05      	add	r3, sp, #20
    3316:	4618      	mov	r0, r3
    3318:	f7fe fede 	bl	20d8 <Clock_Ip_TimeoutExpired>
    331c:	4603      	mov	r3, r0
    331e:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3322:	9b06      	ldr	r3, [sp, #24]
    3324:	2b00      	cmp	r3, #0
    3326:	d106      	bne.n	3336 <Clock_Ip_EnableFirc_TrustedCall+0x66>
    3328:	f89d 301f 	ldrb.w	r3, [sp, #31]
    332c:	f083 0301 	eor.w	r3, r3, #1
    3330:	b2db      	uxtb	r3, r3
    3332:	2b00      	cmp	r3, #0
    3334:	d1e5      	bne.n	3302 <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    3336:	f89d 301f 	ldrb.w	r3, [sp, #31]
    333a:	2b00      	cmp	r3, #0
    333c:	d005      	beq.n	334a <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    333e:	9b01      	ldr	r3, [sp, #4]
    3340:	681b      	ldr	r3, [r3, #0]
    3342:	4619      	mov	r1, r3
    3344:	2001      	movs	r0, #1
    3346:	f7fe fe9d 	bl	2084 <Clock_Ip_ReportClockErrors>
        }
    }
}
    334a:	bf00      	nop
    334c:	b009      	add	sp, #36	; 0x24
    334e:	f85d fb04 	ldr.w	pc, [sp], #4
    3352:	bf00      	nop
    3354:	40064000 	.word	0x40064000

00003358 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    3358:	b082      	sub	sp, #8
    335a:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    335c:	4b05      	ldr	r3, [pc, #20]	; (3374 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    335e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3362:	4a04      	ldr	r2, [pc, #16]	; (3374 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    3364:	f023 0301 	bic.w	r3, r3, #1
    3368:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    336c:	bf00      	nop
    336e:	b002      	add	sp, #8
    3370:	4770      	bx	lr
    3372:	bf00      	nop
    3374:	40064000 	.word	0x40064000

00003378 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    3378:	b082      	sub	sp, #8
    337a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    337c:	bf00      	nop
    337e:	b002      	add	sp, #8
    3380:	4770      	bx	lr

00003382 <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    3382:	b082      	sub	sp, #8
    3384:	9001      	str	r0, [sp, #4]
    3386:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    3388:	bf00      	nop
    338a:	b002      	add	sp, #8
    338c:	4770      	bx	lr

0000338e <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    338e:	b082      	sub	sp, #8
    3390:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3392:	bf00      	nop
    3394:	b002      	add	sp, #8
    3396:	4770      	bx	lr

00003398 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    3398:	b082      	sub	sp, #8
    339a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    339c:	bf00      	nop
    339e:	b002      	add	sp, #8
    33a0:	4770      	bx	lr

000033a2 <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    33a2:	b082      	sub	sp, #8
    33a4:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    33a6:	2302      	movs	r3, #2
}
    33a8:	4618      	mov	r0, r3
    33aa:	b002      	add	sp, #8
    33ac:	4770      	bx	lr

000033ae <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    33ae:	b082      	sub	sp, #8
    33b0:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    33b2:	bf00      	nop
    33b4:	b002      	add	sp, #8
    33b6:	4770      	bx	lr

000033b8 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    33b8:	b500      	push	{lr}
    33ba:	b083      	sub	sp, #12
    33bc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33be:	9b01      	ldr	r3, [sp, #4]
    33c0:	2b00      	cmp	r3, #0
    33c2:	d002      	beq.n	33ca <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    33c4:	9801      	ldr	r0, [sp, #4]
    33c6:	f000 f870 	bl	34aa <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33ca:	bf00      	nop
    33cc:	b003      	add	sp, #12
    33ce:	f85d fb04 	ldr.w	pc, [sp], #4

000033d2 <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    33d2:	b500      	push	{lr}
    33d4:	b083      	sub	sp, #12
    33d6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33d8:	9b01      	ldr	r3, [sp, #4]
    33da:	2b00      	cmp	r3, #0
    33dc:	d002      	beq.n	33e4 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    33de:	9801      	ldr	r0, [sp, #4]
    33e0:	f000 f89a 	bl	3518 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33e4:	bf00      	nop
    33e6:	b003      	add	sp, #12
    33e8:	f85d fb04 	ldr.w	pc, [sp], #4

000033ec <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    33ec:	b500      	push	{lr}
    33ee:	b089      	sub	sp, #36	; 0x24
    33f0:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    33f2:	2301      	movs	r3, #1
    33f4:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    33f6:	2300      	movs	r3, #0
    33f8:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    33fc:	4b1e      	ldr	r3, [pc, #120]	; (3478 <Clock_Ip_CompleteSpll+0x8c>)
    33fe:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3402:	f003 0301 	and.w	r3, r3, #1
    3406:	2b00      	cmp	r3, #0
    3408:	d02f      	beq.n	346a <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    340a:	aa02      	add	r2, sp, #8
    340c:	a903      	add	r1, sp, #12
    340e:	a804      	add	r0, sp, #16
    3410:	f24c 3350 	movw	r3, #50000	; 0xc350
    3414:	f7fe fe46 	bl	20a4 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    3418:	4b17      	ldr	r3, [pc, #92]	; (3478 <Clock_Ip_CompleteSpll+0x8c>)
    341a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    341e:	0e1b      	lsrs	r3, r3, #24
    3420:	f003 0301 	and.w	r3, r3, #1
    3424:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3426:	9a02      	ldr	r2, [sp, #8]
    3428:	a903      	add	r1, sp, #12
    342a:	ab04      	add	r3, sp, #16
    342c:	4618      	mov	r0, r3
    342e:	f7fe fe53 	bl	20d8 <Clock_Ip_TimeoutExpired>
    3432:	4603      	mov	r3, r0
    3434:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    3438:	9b05      	ldr	r3, [sp, #20]
    343a:	2b00      	cmp	r3, #0
    343c:	d106      	bne.n	344c <Clock_Ip_CompleteSpll+0x60>
    343e:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3442:	f083 0301 	eor.w	r3, r3, #1
    3446:	b2db      	uxtb	r3, r3
    3448:	2b00      	cmp	r3, #0
    344a:	d1e5      	bne.n	3418 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    344c:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3450:	f083 0301 	eor.w	r3, r3, #1
    3454:	b2db      	uxtb	r3, r3
    3456:	2b00      	cmp	r3, #0
    3458:	d002      	beq.n	3460 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    345a:	2302      	movs	r3, #2
    345c:	9307      	str	r3, [sp, #28]
    345e:	e006      	b.n	346e <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    3460:	9901      	ldr	r1, [sp, #4]
    3462:	2001      	movs	r0, #1
    3464:	f7fe fe0e 	bl	2084 <Clock_Ip_ReportClockErrors>
    3468:	e001      	b.n	346e <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    346a:	2300      	movs	r3, #0
    346c:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    346e:	9b07      	ldr	r3, [sp, #28]
}
    3470:	4618      	mov	r0, r3
    3472:	b009      	add	sp, #36	; 0x24
    3474:	f85d fb04 	ldr.w	pc, [sp], #4
    3478:	40064000 	.word	0x40064000

0000347c <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    347c:	b500      	push	{lr}
    347e:	b083      	sub	sp, #12
    3480:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    3482:	9801      	ldr	r0, [sp, #4]
    3484:	f000 f886 	bl	3594 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3488:	bf00      	nop
    348a:	b003      	add	sp, #12
    348c:	f85d fb04 	ldr.w	pc, [sp], #4

00003490 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    3490:	b500      	push	{lr}
    3492:	b083      	sub	sp, #12
    3494:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3496:	9b01      	ldr	r3, [sp, #4]
    3498:	2b00      	cmp	r3, #0
    349a:	d002      	beq.n	34a2 <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    349c:	9801      	ldr	r0, [sp, #4]
    349e:	f000 f891 	bl	35c4 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    34a2:	bf00      	nop
    34a4:	b003      	add	sp, #12
    34a6:	f85d fb04 	ldr.w	pc, [sp], #4

000034aa <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    34aa:	b082      	sub	sp, #8
    34ac:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    34ae:	4b19      	ldr	r3, [pc, #100]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34b0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34b4:	4a17      	ldr	r2, [pc, #92]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34b6:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    34ba:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    34be:	4b15      	ldr	r3, [pc, #84]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34c0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34c4:	4a13      	ldr	r2, [pc, #76]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34c6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    34ca:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    34ce:	4b11      	ldr	r3, [pc, #68]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34d0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34d4:	4a0f      	ldr	r2, [pc, #60]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34d6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    34da:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    34de:	4b0d      	ldr	r3, [pc, #52]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34e0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34e4:	4a0b      	ldr	r2, [pc, #44]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34e6:	f023 0301 	bic.w	r3, r3, #1
    34ea:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    34ee:	4b09      	ldr	r3, [pc, #36]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34f0:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    34f4:	4a07      	ldr	r2, [pc, #28]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34f6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    34fa:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    34fe:	4b05      	ldr	r3, [pc, #20]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3500:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3504:	4a03      	ldr	r2, [pc, #12]	; (3514 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3506:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    350a:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    350e:	bf00      	nop
    3510:	b002      	add	sp, #8
    3512:	4770      	bx	lr
    3514:	40064000 	.word	0x40064000

00003518 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    3518:	b082      	sub	sp, #8
    351a:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    351c:	9b01      	ldr	r3, [sp, #4]
    351e:	889b      	ldrh	r3, [r3, #4]
    3520:	2b01      	cmp	r3, #1
    3522:	d12f      	bne.n	3584 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    3524:	4b1a      	ldr	r3, [pc, #104]	; (3590 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3526:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    352a:	9b01      	ldr	r3, [sp, #4]
    352c:	7b5b      	ldrb	r3, [r3, #13]
    352e:	3b01      	subs	r3, #1
    3530:	021b      	lsls	r3, r3, #8
    3532:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    3536:	9b01      	ldr	r3, [sp, #4]
    3538:	7d1b      	ldrb	r3, [r3, #20]
    353a:	3b10      	subs	r3, #16
    353c:	041b      	lsls	r3, r3, #16
    353e:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    3542:	430b      	orrs	r3, r1
    3544:	4912      	ldr	r1, [pc, #72]	; (3590 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3546:	4313      	orrs	r3, r2
    3548:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    354c:	9b01      	ldr	r3, [sp, #4]
    354e:	7fdb      	ldrb	r3, [r3, #31]
    3550:	2b02      	cmp	r3, #2
    3552:	d011      	beq.n	3578 <Clock_Ip_SetSpll_TrustedCall+0x60>
    3554:	2b02      	cmp	r3, #2
    3556:	dc17      	bgt.n	3588 <Clock_Ip_SetSpll_TrustedCall+0x70>
    3558:	2b00      	cmp	r3, #0
    355a:	d002      	beq.n	3562 <Clock_Ip_SetSpll_TrustedCall+0x4a>
    355c:	2b01      	cmp	r3, #1
    355e:	d005      	beq.n	356c <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    3560:	e012      	b.n	3588 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    3562:	4b0b      	ldr	r3, [pc, #44]	; (3590 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3564:	2200      	movs	r2, #0
    3566:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    356a:	e00e      	b.n	358a <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    356c:	4b08      	ldr	r3, [pc, #32]	; (3590 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    356e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    3572:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3576:	e008      	b.n	358a <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3578:	4b05      	ldr	r3, [pc, #20]	; (3590 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    357a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    357e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3582:	e002      	b.n	358a <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    3584:	bf00      	nop
    3586:	e000      	b.n	358a <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    3588:	bf00      	nop
}
    358a:	bf00      	nop
    358c:	b002      	add	sp, #8
    358e:	4770      	bx	lr
    3590:	40064000 	.word	0x40064000

00003594 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    3594:	b082      	sub	sp, #8
    3596:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    3598:	4b09      	ldr	r3, [pc, #36]	; (35c0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    359a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    359e:	4a08      	ldr	r2, [pc, #32]	; (35c0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    35a0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    35a4:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    35a8:	4b05      	ldr	r3, [pc, #20]	; (35c0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    35aa:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    35ae:	4a04      	ldr	r2, [pc, #16]	; (35c0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    35b0:	f023 0301 	bic.w	r3, r3, #1
    35b4:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    35b8:	bf00      	nop
    35ba:	b002      	add	sp, #8
    35bc:	4770      	bx	lr
    35be:	bf00      	nop
    35c0:	40064000 	.word	0x40064000

000035c4 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    35c4:	b082      	sub	sp, #8
    35c6:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    35c8:	9b01      	ldr	r3, [sp, #4]
    35ca:	889b      	ldrh	r3, [r3, #4]
    35cc:	2b01      	cmp	r3, #1
    35ce:	d107      	bne.n	35e0 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    35d0:	4b05      	ldr	r3, [pc, #20]	; (35e8 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    35d2:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    35d6:	4a04      	ldr	r2, [pc, #16]	; (35e8 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    35d8:	f043 0301 	orr.w	r3, r3, #1
    35dc:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    35e0:	bf00      	nop
    35e2:	b002      	add	sp, #8
    35e4:	4770      	bx	lr
    35e6:	bf00      	nop
    35e8:	40064000 	.word	0x40064000

000035ec <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    35ec:	b082      	sub	sp, #8
    35ee:	9001      	str	r0, [sp, #4]
    35f0:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    35f2:	bf00      	nop
    35f4:	b002      	add	sp, #8
    35f6:	4770      	bx	lr

000035f8 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    35f8:	b082      	sub	sp, #8
    35fa:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    35fc:	bf00      	nop
    35fe:	b002      	add	sp, #8
    3600:	4770      	bx	lr

00003602 <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    3602:	b500      	push	{lr}
    3604:	b083      	sub	sp, #12
    3606:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3608:	9b01      	ldr	r3, [sp, #4]
    360a:	2b00      	cmp	r3, #0
    360c:	d002      	beq.n	3614 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    360e:	9801      	ldr	r0, [sp, #4]
    3610:	f000 f8ee 	bl	37f0 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3614:	bf00      	nop
    3616:	b003      	add	sp, #12
    3618:	f85d fb04 	ldr.w	pc, [sp], #4

0000361c <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    361c:	b500      	push	{lr}
    361e:	b083      	sub	sp, #12
    3620:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3622:	9b01      	ldr	r3, [sp, #4]
    3624:	2b00      	cmp	r3, #0
    3626:	d002      	beq.n	362e <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    3628:	9801      	ldr	r0, [sp, #4]
    362a:	f000 f8ff 	bl	382c <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    362e:	bf00      	nop
    3630:	b003      	add	sp, #12
    3632:	f85d fb04 	ldr.w	pc, [sp], #4

00003636 <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    3636:	b500      	push	{lr}
    3638:	b083      	sub	sp, #12
    363a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    363c:	9b01      	ldr	r3, [sp, #4]
    363e:	2b00      	cmp	r3, #0
    3640:	d002      	beq.n	3648 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    3642:	9801      	ldr	r0, [sp, #4]
    3644:	f000 f912 	bl	386c <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3648:	bf00      	nop
    364a:	b003      	add	sp, #12
    364c:	f85d fb04 	ldr.w	pc, [sp], #4

00003650 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    3650:	b500      	push	{lr}
    3652:	b083      	sub	sp, #12
    3654:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3656:	9b01      	ldr	r3, [sp, #4]
    3658:	2b00      	cmp	r3, #0
    365a:	d002      	beq.n	3662 <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    365c:	9801      	ldr	r0, [sp, #4]
    365e:	f000 f925 	bl	38ac <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3662:	bf00      	nop
    3664:	b003      	add	sp, #12
    3666:	f85d fb04 	ldr.w	pc, [sp], #4

0000366a <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    366a:	b500      	push	{lr}
    366c:	b083      	sub	sp, #12
    366e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3670:	9b01      	ldr	r3, [sp, #4]
    3672:	2b00      	cmp	r3, #0
    3674:	d002      	beq.n	367c <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    3676:	9801      	ldr	r0, [sp, #4]
    3678:	f000 f936 	bl	38e8 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    367c:	bf00      	nop
    367e:	b003      	add	sp, #12
    3680:	f85d fb04 	ldr.w	pc, [sp], #4

00003684 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    3684:	b500      	push	{lr}
    3686:	b083      	sub	sp, #12
    3688:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    368a:	9b01      	ldr	r3, [sp, #4]
    368c:	2b00      	cmp	r3, #0
    368e:	d002      	beq.n	3696 <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    3690:	9801      	ldr	r0, [sp, #4]
    3692:	f000 f949 	bl	3928 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3696:	bf00      	nop
    3698:	b003      	add	sp, #12
    369a:	f85d fb04 	ldr.w	pc, [sp], #4

0000369e <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    369e:	b500      	push	{lr}
    36a0:	b083      	sub	sp, #12
    36a2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36a4:	9b01      	ldr	r3, [sp, #4]
    36a6:	2b00      	cmp	r3, #0
    36a8:	d002      	beq.n	36b0 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    36aa:	9801      	ldr	r0, [sp, #4]
    36ac:	f000 f958 	bl	3960 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36b0:	bf00      	nop
    36b2:	b003      	add	sp, #12
    36b4:	f85d fb04 	ldr.w	pc, [sp], #4

000036b8 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    36b8:	b500      	push	{lr}
    36ba:	b083      	sub	sp, #12
    36bc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36be:	9b01      	ldr	r3, [sp, #4]
    36c0:	2b00      	cmp	r3, #0
    36c2:	d002      	beq.n	36ca <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    36c4:	9801      	ldr	r0, [sp, #4]
    36c6:	f000 f969 	bl	399c <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36ca:	bf00      	nop
    36cc:	b003      	add	sp, #12
    36ce:	f85d fb04 	ldr.w	pc, [sp], #4

000036d2 <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    36d2:	b500      	push	{lr}
    36d4:	b083      	sub	sp, #12
    36d6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36d8:	9b01      	ldr	r3, [sp, #4]
    36da:	2b00      	cmp	r3, #0
    36dc:	d002      	beq.n	36e4 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    36de:	9801      	ldr	r0, [sp, #4]
    36e0:	f000 f978 	bl	39d4 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36e4:	bf00      	nop
    36e6:	b003      	add	sp, #12
    36e8:	f85d fb04 	ldr.w	pc, [sp], #4

000036ec <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    36ec:	b500      	push	{lr}
    36ee:	b083      	sub	sp, #12
    36f0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36f2:	9b01      	ldr	r3, [sp, #4]
    36f4:	2b00      	cmp	r3, #0
    36f6:	d002      	beq.n	36fe <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    36f8:	9801      	ldr	r0, [sp, #4]
    36fa:	f000 f989 	bl	3a10 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36fe:	bf00      	nop
    3700:	b003      	add	sp, #12
    3702:	f85d fb04 	ldr.w	pc, [sp], #4

00003706 <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3706:	b500      	push	{lr}
    3708:	b083      	sub	sp, #12
    370a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    370c:	9b01      	ldr	r3, [sp, #4]
    370e:	2b00      	cmp	r3, #0
    3710:	d002      	beq.n	3718 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    3712:	9801      	ldr	r0, [sp, #4]
    3714:	f000 f998 	bl	3a48 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3718:	bf00      	nop
    371a:	b003      	add	sp, #12
    371c:	f85d fb04 	ldr.w	pc, [sp], #4

00003720 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    3720:	b500      	push	{lr}
    3722:	b083      	sub	sp, #12
    3724:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3726:	9b01      	ldr	r3, [sp, #4]
    3728:	2b00      	cmp	r3, #0
    372a:	d002      	beq.n	3732 <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    372c:	9801      	ldr	r0, [sp, #4]
    372e:	f000 f9a9 	bl	3a84 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3732:	bf00      	nop
    3734:	b003      	add	sp, #12
    3736:	f85d fb04 	ldr.w	pc, [sp], #4

0000373a <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    373a:	b500      	push	{lr}
    373c:	b083      	sub	sp, #12
    373e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3740:	9b01      	ldr	r3, [sp, #4]
    3742:	2b00      	cmp	r3, #0
    3744:	d002      	beq.n	374c <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    3746:	9801      	ldr	r0, [sp, #4]
    3748:	f000 f9e6 	bl	3b18 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    374c:	bf00      	nop
    374e:	b003      	add	sp, #12
    3750:	f85d fb04 	ldr.w	pc, [sp], #4

00003754 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3754:	b500      	push	{lr}
    3756:	b083      	sub	sp, #12
    3758:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    375a:	9b01      	ldr	r3, [sp, #4]
    375c:	2b00      	cmp	r3, #0
    375e:	d002      	beq.n	3766 <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    3760:	9801      	ldr	r0, [sp, #4]
    3762:	f000 fa25 	bl	3bb0 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3766:	bf00      	nop
    3768:	b003      	add	sp, #12
    376a:	f85d fb04 	ldr.w	pc, [sp], #4

0000376e <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    376e:	b500      	push	{lr}
    3770:	b083      	sub	sp, #12
    3772:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3774:	9b01      	ldr	r3, [sp, #4]
    3776:	2b00      	cmp	r3, #0
    3778:	d002      	beq.n	3780 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    377a:	9801      	ldr	r0, [sp, #4]
    377c:	f000 fa2a 	bl	3bd4 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3780:	bf00      	nop
    3782:	b003      	add	sp, #12
    3784:	f85d fb04 	ldr.w	pc, [sp], #4

00003788 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    3788:	b500      	push	{lr}
    378a:	b083      	sub	sp, #12
    378c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    378e:	9b01      	ldr	r3, [sp, #4]
    3790:	2b00      	cmp	r3, #0
    3792:	d002      	beq.n	379a <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    3794:	9801      	ldr	r0, [sp, #4]
    3796:	f000 fa3b 	bl	3c10 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    379a:	bf00      	nop
    379c:	b003      	add	sp, #12
    379e:	f85d fb04 	ldr.w	pc, [sp], #4

000037a2 <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    37a2:	b500      	push	{lr}
    37a4:	b083      	sub	sp, #12
    37a6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37a8:	9b01      	ldr	r3, [sp, #4]
    37aa:	2b00      	cmp	r3, #0
    37ac:	d002      	beq.n	37b4 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    37ae:	9801      	ldr	r0, [sp, #4]
    37b0:	f000 fa56 	bl	3c60 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37b4:	bf00      	nop
    37b6:	b003      	add	sp, #12
    37b8:	f85d fb04 	ldr.w	pc, [sp], #4

000037bc <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    37bc:	b500      	push	{lr}
    37be:	b083      	sub	sp, #12
    37c0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37c2:	9b01      	ldr	r3, [sp, #4]
    37c4:	2b00      	cmp	r3, #0
    37c6:	d002      	beq.n	37ce <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    37c8:	9801      	ldr	r0, [sp, #4]
    37ca:	f000 fa79 	bl	3cc0 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37ce:	bf00      	nop
    37d0:	b003      	add	sp, #12
    37d2:	f85d fb04 	ldr.w	pc, [sp], #4

000037d6 <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    37d6:	b500      	push	{lr}
    37d8:	b083      	sub	sp, #12
    37da:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37dc:	9b01      	ldr	r3, [sp, #4]
    37de:	2b00      	cmp	r3, #0
    37e0:	d002      	beq.n	37e8 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    37e2:	9801      	ldr	r0, [sp, #4]
    37e4:	f000 fa8a 	bl	3cfc <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37e8:	bf00      	nop
    37ea:	b003      	add	sp, #12
    37ec:	f85d fb04 	ldr.w	pc, [sp], #4

000037f0 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    37f0:	b084      	sub	sp, #16
    37f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    37f4:	4b0b      	ldr	r3, [pc, #44]	; (3824 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    37f6:	795b      	ldrb	r3, [r3, #5]
    37f8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    37fa:	4b0b      	ldr	r3, [pc, #44]	; (3828 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    37fc:	695b      	ldr	r3, [r3, #20]
    37fe:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3800:	9b02      	ldr	r3, [sp, #8]
    3802:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3806:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    3808:	9b03      	ldr	r3, [sp, #12]
    380a:	061b      	lsls	r3, r3, #24
    380c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3810:	9a02      	ldr	r2, [sp, #8]
    3812:	4313      	orrs	r3, r2
    3814:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    3816:	4a04      	ldr	r2, [pc, #16]	; (3828 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    3818:	9b02      	ldr	r3, [sp, #8]
    381a:	6153      	str	r3, [r2, #20]
}
    381c:	bf00      	nop
    381e:	b004      	add	sp, #16
    3820:	4770      	bx	lr
    3822:	bf00      	nop
    3824:	00009e3c 	.word	0x00009e3c
    3828:	40064000 	.word	0x40064000

0000382c <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    382c:	b084      	sub	sp, #16
    382e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3830:	9b01      	ldr	r3, [sp, #4]
    3832:	685b      	ldr	r3, [r3, #4]
    3834:	4a0b      	ldr	r2, [pc, #44]	; (3864 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    3836:	5cd3      	ldrb	r3, [r2, r3]
    3838:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    383a:	4b0b      	ldr	r3, [pc, #44]	; (3868 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    383c:	695b      	ldr	r3, [r3, #20]
    383e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3840:	9b02      	ldr	r3, [sp, #8]
    3842:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3846:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    3848:	9b03      	ldr	r3, [sp, #12]
    384a:	061b      	lsls	r3, r3, #24
    384c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3850:	9a02      	ldr	r2, [sp, #8]
    3852:	4313      	orrs	r3, r2
    3854:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    3856:	4a04      	ldr	r2, [pc, #16]	; (3868 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    3858:	9b02      	ldr	r3, [sp, #8]
    385a:	6153      	str	r3, [r2, #20]
}
    385c:	bf00      	nop
    385e:	b004      	add	sp, #16
    3860:	4770      	bx	lr
    3862:	bf00      	nop
    3864:	00009e3c 	.word	0x00009e3c
    3868:	40064000 	.word	0x40064000

0000386c <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    386c:	b084      	sub	sp, #16
    386e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3870:	9b01      	ldr	r3, [sp, #4]
    3872:	685b      	ldr	r3, [r3, #4]
    3874:	4a0b      	ldr	r2, [pc, #44]	; (38a4 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    3876:	5cd3      	ldrb	r3, [r2, r3]
    3878:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    387a:	4b0b      	ldr	r3, [pc, #44]	; (38a8 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    387c:	699b      	ldr	r3, [r3, #24]
    387e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    3880:	9b02      	ldr	r3, [sp, #8]
    3882:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3886:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    3888:	9b03      	ldr	r3, [sp, #12]
    388a:	061b      	lsls	r3, r3, #24
    388c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3890:	9a02      	ldr	r2, [sp, #8]
    3892:	4313      	orrs	r3, r2
    3894:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    3896:	4a04      	ldr	r2, [pc, #16]	; (38a8 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3898:	9b02      	ldr	r3, [sp, #8]
    389a:	6193      	str	r3, [r2, #24]
}
    389c:	bf00      	nop
    389e:	b004      	add	sp, #16
    38a0:	4770      	bx	lr
    38a2:	bf00      	nop
    38a4:	00009e3c 	.word	0x00009e3c
    38a8:	40064000 	.word	0x40064000

000038ac <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    38ac:	b084      	sub	sp, #16
    38ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    38b0:	4b0b      	ldr	r3, [pc, #44]	; (38e0 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    38b2:	795b      	ldrb	r3, [r3, #5]
    38b4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    38b6:	4b0b      	ldr	r3, [pc, #44]	; (38e4 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    38b8:	69db      	ldr	r3, [r3, #28]
    38ba:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    38bc:	9b02      	ldr	r3, [sp, #8]
    38be:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    38c2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    38c4:	9b03      	ldr	r3, [sp, #12]
    38c6:	061b      	lsls	r3, r3, #24
    38c8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    38cc:	9a02      	ldr	r2, [sp, #8]
    38ce:	4313      	orrs	r3, r2
    38d0:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    38d2:	4a04      	ldr	r2, [pc, #16]	; (38e4 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    38d4:	9b02      	ldr	r3, [sp, #8]
    38d6:	61d3      	str	r3, [r2, #28]
}
    38d8:	bf00      	nop
    38da:	b004      	add	sp, #16
    38dc:	4770      	bx	lr
    38de:	bf00      	nop
    38e0:	00009e3c 	.word	0x00009e3c
    38e4:	40064000 	.word	0x40064000

000038e8 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    38e8:	b084      	sub	sp, #16
    38ea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    38ec:	9b01      	ldr	r3, [sp, #4]
    38ee:	685b      	ldr	r3, [r3, #4]
    38f0:	4a0b      	ldr	r2, [pc, #44]	; (3920 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    38f2:	5cd3      	ldrb	r3, [r2, r3]
    38f4:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    38f6:	4b0b      	ldr	r3, [pc, #44]	; (3924 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    38f8:	69db      	ldr	r3, [r3, #28]
    38fa:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    38fc:	9b02      	ldr	r3, [sp, #8]
    38fe:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3902:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    3904:	9b03      	ldr	r3, [sp, #12]
    3906:	061b      	lsls	r3, r3, #24
    3908:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    390c:	9a02      	ldr	r2, [sp, #8]
    390e:	4313      	orrs	r3, r2
    3910:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    3912:	4a04      	ldr	r2, [pc, #16]	; (3924 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    3914:	9b02      	ldr	r3, [sp, #8]
    3916:	61d3      	str	r3, [r2, #28]
}
    3918:	bf00      	nop
    391a:	b004      	add	sp, #16
    391c:	4770      	bx	lr
    391e:	bf00      	nop
    3920:	00009e3c 	.word	0x00009e3c
    3924:	40064000 	.word	0x40064000

00003928 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3928:	b084      	sub	sp, #16
    392a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    392c:	4b0a      	ldr	r3, [pc, #40]	; (3958 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    392e:	7b9b      	ldrb	r3, [r3, #14]
    3930:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    3932:	4b0a      	ldr	r3, [pc, #40]	; (395c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    3934:	691b      	ldr	r3, [r3, #16]
    3936:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    3938:	9b02      	ldr	r3, [sp, #8]
    393a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    393e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3940:	9b03      	ldr	r3, [sp, #12]
    3942:	011b      	lsls	r3, r3, #4
    3944:	9a02      	ldr	r2, [sp, #8]
    3946:	4313      	orrs	r3, r2
    3948:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    394a:	4a04      	ldr	r2, [pc, #16]	; (395c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    394c:	9b02      	ldr	r3, [sp, #8]
    394e:	6113      	str	r3, [r2, #16]
}
    3950:	bf00      	nop
    3952:	b004      	add	sp, #16
    3954:	4770      	bx	lr
    3956:	bf00      	nop
    3958:	00009de4 	.word	0x00009de4
    395c:	40048000 	.word	0x40048000

00003960 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3960:	b084      	sub	sp, #16
    3962:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3964:	9b01      	ldr	r3, [sp, #4]
    3966:	685b      	ldr	r3, [r3, #4]
    3968:	4a0a      	ldr	r2, [pc, #40]	; (3994 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    396a:	5cd3      	ldrb	r3, [r2, r3]
    396c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    396e:	4b0a      	ldr	r3, [pc, #40]	; (3998 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3970:	691b      	ldr	r3, [r3, #16]
    3972:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    3974:	9b02      	ldr	r3, [sp, #8]
    3976:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    397a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    397c:	9b03      	ldr	r3, [sp, #12]
    397e:	011b      	lsls	r3, r3, #4
    3980:	9a02      	ldr	r2, [sp, #8]
    3982:	4313      	orrs	r3, r2
    3984:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    3986:	4a04      	ldr	r2, [pc, #16]	; (3998 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3988:	9b02      	ldr	r3, [sp, #8]
    398a:	6113      	str	r3, [r2, #16]
}
    398c:	bf00      	nop
    398e:	b004      	add	sp, #16
    3990:	4770      	bx	lr
    3992:	bf00      	nop
    3994:	00009de4 	.word	0x00009de4
    3998:	40048000 	.word	0x40048000

0000399c <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    399c:	b084      	sub	sp, #16
    399e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    39a0:	4b0a      	ldr	r3, [pc, #40]	; (39cc <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    39a2:	785b      	ldrb	r3, [r3, #1]
    39a4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    39a6:	4b0a      	ldr	r3, [pc, #40]	; (39d0 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    39a8:	691b      	ldr	r3, [r3, #16]
    39aa:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    39ac:	9b02      	ldr	r3, [sp, #8]
    39ae:	f023 030c 	bic.w	r3, r3, #12
    39b2:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    39b4:	9b03      	ldr	r3, [sp, #12]
    39b6:	009b      	lsls	r3, r3, #2
    39b8:	9a02      	ldr	r2, [sp, #8]
    39ba:	4313      	orrs	r3, r2
    39bc:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    39be:	4a04      	ldr	r2, [pc, #16]	; (39d0 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    39c0:	9b02      	ldr	r3, [sp, #8]
    39c2:	6113      	str	r3, [r2, #16]
}
    39c4:	bf00      	nop
    39c6:	b004      	add	sp, #16
    39c8:	4770      	bx	lr
    39ca:	bf00      	nop
    39cc:	00009e9c 	.word	0x00009e9c
    39d0:	40048000 	.word	0x40048000

000039d4 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    39d4:	b084      	sub	sp, #16
    39d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    39d8:	9b01      	ldr	r3, [sp, #4]
    39da:	685b      	ldr	r3, [r3, #4]
    39dc:	4a0a      	ldr	r2, [pc, #40]	; (3a08 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    39de:	5cd3      	ldrb	r3, [r2, r3]
    39e0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    39e2:	4b0a      	ldr	r3, [pc, #40]	; (3a0c <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    39e4:	691b      	ldr	r3, [r3, #16]
    39e6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    39e8:	9b02      	ldr	r3, [sp, #8]
    39ea:	f023 030c 	bic.w	r3, r3, #12
    39ee:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    39f0:	9b03      	ldr	r3, [sp, #12]
    39f2:	009b      	lsls	r3, r3, #2
    39f4:	9a02      	ldr	r2, [sp, #8]
    39f6:	4313      	orrs	r3, r2
    39f8:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    39fa:	4a04      	ldr	r2, [pc, #16]	; (3a0c <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    39fc:	9b02      	ldr	r3, [sp, #8]
    39fe:	6113      	str	r3, [r2, #16]
}
    3a00:	bf00      	nop
    3a02:	b004      	add	sp, #16
    3a04:	4770      	bx	lr
    3a06:	bf00      	nop
    3a08:	00009e9c 	.word	0x00009e9c
    3a0c:	40048000 	.word	0x40048000

00003a10 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3a10:	b084      	sub	sp, #16
    3a12:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3a14:	4b0a      	ldr	r3, [pc, #40]	; (3a40 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    3a16:	795b      	ldrb	r3, [r3, #5]
    3a18:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    3a1a:	4b0a      	ldr	r3, [pc, #40]	; (3a44 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    3a1c:	6a1b      	ldr	r3, [r3, #32]
    3a1e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    3a20:	9b02      	ldr	r3, [sp, #8]
    3a22:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3a26:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    3a28:	9b03      	ldr	r3, [sp, #12]
    3a2a:	061b      	lsls	r3, r3, #24
    3a2c:	9a02      	ldr	r2, [sp, #8]
    3a2e:	4313      	orrs	r3, r2
    3a30:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    3a32:	4a04      	ldr	r2, [pc, #16]	; (3a44 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    3a34:	9b02      	ldr	r3, [sp, #8]
    3a36:	6213      	str	r3, [r2, #32]
}
    3a38:	bf00      	nop
    3a3a:	b004      	add	sp, #16
    3a3c:	4770      	bx	lr
    3a3e:	bf00      	nop
    3a40:	00009e3c 	.word	0x00009e3c
    3a44:	40064000 	.word	0x40064000

00003a48 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3a48:	b084      	sub	sp, #16
    3a4a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3a4c:	9b01      	ldr	r3, [sp, #4]
    3a4e:	685b      	ldr	r3, [r3, #4]
    3a50:	4a0a      	ldr	r2, [pc, #40]	; (3a7c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    3a52:	5cd3      	ldrb	r3, [r2, r3]
    3a54:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    3a56:	4b0a      	ldr	r3, [pc, #40]	; (3a80 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3a58:	6a1b      	ldr	r3, [r3, #32]
    3a5a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    3a5c:	9b02      	ldr	r3, [sp, #8]
    3a5e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3a62:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    3a64:	9b03      	ldr	r3, [sp, #12]
    3a66:	061b      	lsls	r3, r3, #24
    3a68:	9a02      	ldr	r2, [sp, #8]
    3a6a:	4313      	orrs	r3, r2
    3a6c:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    3a6e:	4a04      	ldr	r2, [pc, #16]	; (3a80 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3a70:	9b02      	ldr	r3, [sp, #8]
    3a72:	6213      	str	r3, [r2, #32]
}
    3a74:	bf00      	nop
    3a76:	b004      	add	sp, #16
    3a78:	4770      	bx	lr
    3a7a:	bf00      	nop
    3a7c:	00009e3c 	.word	0x00009e3c
    3a80:	40064000 	.word	0x40064000

00003a84 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3a84:	b086      	sub	sp, #24
    3a86:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3a88:	4b20      	ldr	r3, [pc, #128]	; (3b0c <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    3a8a:	795b      	ldrb	r3, [r3, #5]
    3a8c:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3a8e:	9b01      	ldr	r3, [sp, #4]
    3a90:	681a      	ldr	r2, [r3, #0]
    3a92:	491f      	ldr	r1, [pc, #124]	; (3b10 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    3a94:	4613      	mov	r3, r2
    3a96:	00db      	lsls	r3, r3, #3
    3a98:	4413      	add	r3, r2
    3a9a:	440b      	add	r3, r1
    3a9c:	781b      	ldrb	r3, [r3, #0]
    3a9e:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    3aa0:	4b1c      	ldr	r3, [pc, #112]	; (3b14 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    3aa2:	68db      	ldr	r3, [r3, #12]
    3aa4:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    3aa6:	9b03      	ldr	r3, [sp, #12]
    3aa8:	2b03      	cmp	r3, #3
    3aaa:	d813      	bhi.n	3ad4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3aac:	9b03      	ldr	r3, [sp, #12]
    3aae:	005b      	lsls	r3, r3, #1
    3ab0:	3318      	adds	r3, #24
    3ab2:	2203      	movs	r2, #3
    3ab4:	fa02 f303 	lsl.w	r3, r2, r3
    3ab8:	43db      	mvns	r3, r3
    3aba:	9a05      	ldr	r2, [sp, #20]
    3abc:	4013      	ands	r3, r2
    3abe:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3ac0:	9b03      	ldr	r3, [sp, #12]
    3ac2:	005b      	lsls	r3, r3, #1
    3ac4:	3318      	adds	r3, #24
    3ac6:	9a04      	ldr	r2, [sp, #16]
    3ac8:	fa02 f303 	lsl.w	r3, r2, r3
    3acc:	9a05      	ldr	r2, [sp, #20]
    3ace:	4313      	orrs	r3, r2
    3ad0:	9305      	str	r3, [sp, #20]
    3ad2:	e014      	b.n	3afe <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3ad4:	9b03      	ldr	r3, [sp, #12]
    3ad6:	3b04      	subs	r3, #4
    3ad8:	005b      	lsls	r3, r3, #1
    3ada:	3310      	adds	r3, #16
    3adc:	2203      	movs	r2, #3
    3ade:	fa02 f303 	lsl.w	r3, r2, r3
    3ae2:	43db      	mvns	r3, r3
    3ae4:	9a05      	ldr	r2, [sp, #20]
    3ae6:	4013      	ands	r3, r2
    3ae8:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3aea:	9b03      	ldr	r3, [sp, #12]
    3aec:	3b04      	subs	r3, #4
    3aee:	005b      	lsls	r3, r3, #1
    3af0:	3310      	adds	r3, #16
    3af2:	9a04      	ldr	r2, [sp, #16]
    3af4:	fa02 f303 	lsl.w	r3, r2, r3
    3af8:	9a05      	ldr	r2, [sp, #20]
    3afa:	4313      	orrs	r3, r2
    3afc:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    3afe:	4a05      	ldr	r2, [pc, #20]	; (3b14 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    3b00:	9b05      	ldr	r3, [sp, #20]
    3b02:	60d3      	str	r3, [r2, #12]
}
    3b04:	bf00      	nop
    3b06:	b006      	add	sp, #24
    3b08:	4770      	bx	lr
    3b0a:	bf00      	nop
    3b0c:	00009de4 	.word	0x00009de4
    3b10:	00009ad4 	.word	0x00009ad4
    3b14:	40048000 	.word	0x40048000

00003b18 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3b18:	b086      	sub	sp, #24
    3b1a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3b1c:	9b01      	ldr	r3, [sp, #4]
    3b1e:	685b      	ldr	r3, [r3, #4]
    3b20:	4a20      	ldr	r2, [pc, #128]	; (3ba4 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    3b22:	5cd3      	ldrb	r3, [r2, r3]
    3b24:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3b26:	9b01      	ldr	r3, [sp, #4]
    3b28:	681a      	ldr	r2, [r3, #0]
    3b2a:	491f      	ldr	r1, [pc, #124]	; (3ba8 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    3b2c:	4613      	mov	r3, r2
    3b2e:	00db      	lsls	r3, r3, #3
    3b30:	4413      	add	r3, r2
    3b32:	440b      	add	r3, r1
    3b34:	781b      	ldrb	r3, [r3, #0]
    3b36:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    3b38:	4b1c      	ldr	r3, [pc, #112]	; (3bac <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3b3a:	68db      	ldr	r3, [r3, #12]
    3b3c:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    3b3e:	9b03      	ldr	r3, [sp, #12]
    3b40:	2b03      	cmp	r3, #3
    3b42:	d813      	bhi.n	3b6c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3b44:	9b03      	ldr	r3, [sp, #12]
    3b46:	005b      	lsls	r3, r3, #1
    3b48:	3318      	adds	r3, #24
    3b4a:	2203      	movs	r2, #3
    3b4c:	fa02 f303 	lsl.w	r3, r2, r3
    3b50:	43db      	mvns	r3, r3
    3b52:	9a05      	ldr	r2, [sp, #20]
    3b54:	4013      	ands	r3, r2
    3b56:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3b58:	9b03      	ldr	r3, [sp, #12]
    3b5a:	005b      	lsls	r3, r3, #1
    3b5c:	3318      	adds	r3, #24
    3b5e:	9a04      	ldr	r2, [sp, #16]
    3b60:	fa02 f303 	lsl.w	r3, r2, r3
    3b64:	9a05      	ldr	r2, [sp, #20]
    3b66:	4313      	orrs	r3, r2
    3b68:	9305      	str	r3, [sp, #20]
    3b6a:	e014      	b.n	3b96 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3b6c:	9b03      	ldr	r3, [sp, #12]
    3b6e:	3b04      	subs	r3, #4
    3b70:	005b      	lsls	r3, r3, #1
    3b72:	3310      	adds	r3, #16
    3b74:	2203      	movs	r2, #3
    3b76:	fa02 f303 	lsl.w	r3, r2, r3
    3b7a:	43db      	mvns	r3, r3
    3b7c:	9a05      	ldr	r2, [sp, #20]
    3b7e:	4013      	ands	r3, r2
    3b80:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3b82:	9b03      	ldr	r3, [sp, #12]
    3b84:	3b04      	subs	r3, #4
    3b86:	005b      	lsls	r3, r3, #1
    3b88:	3310      	adds	r3, #16
    3b8a:	9a04      	ldr	r2, [sp, #16]
    3b8c:	fa02 f303 	lsl.w	r3, r2, r3
    3b90:	9a05      	ldr	r2, [sp, #20]
    3b92:	4313      	orrs	r3, r2
    3b94:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    3b96:	4a05      	ldr	r2, [pc, #20]	; (3bac <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3b98:	9b05      	ldr	r3, [sp, #20]
    3b9a:	60d3      	str	r3, [r2, #12]
}
    3b9c:	bf00      	nop
    3b9e:	b006      	add	sp, #24
    3ba0:	4770      	bx	lr
    3ba2:	bf00      	nop
    3ba4:	00009de4 	.word	0x00009de4
    3ba8:	00009ad4 	.word	0x00009ad4
    3bac:	40048000 	.word	0x40048000

00003bb0 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3bb0:	b084      	sub	sp, #16
    3bb2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    3bb4:	4b06      	ldr	r3, [pc, #24]	; (3bd0 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3bb6:	685b      	ldr	r3, [r3, #4]
    3bb8:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    3bba:	9b03      	ldr	r3, [sp, #12]
    3bbc:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    3bc0:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3bc2:	4a03      	ldr	r2, [pc, #12]	; (3bd0 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3bc4:	9b03      	ldr	r3, [sp, #12]
    3bc6:	6053      	str	r3, [r2, #4]
}
    3bc8:	bf00      	nop
    3bca:	b004      	add	sp, #16
    3bcc:	4770      	bx	lr
    3bce:	bf00      	nop
    3bd0:	40048000 	.word	0x40048000

00003bd4 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3bd4:	b084      	sub	sp, #16
    3bd6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3bd8:	9b01      	ldr	r3, [sp, #4]
    3bda:	685b      	ldr	r3, [r3, #4]
    3bdc:	4a0a      	ldr	r2, [pc, #40]	; (3c08 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    3bde:	5cd3      	ldrb	r3, [r2, r3]
    3be0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    3be2:	4b0a      	ldr	r3, [pc, #40]	; (3c0c <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3be4:	685b      	ldr	r3, [r3, #4]
    3be6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    3be8:	9b02      	ldr	r3, [sp, #8]
    3bea:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3bee:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    3bf0:	9b03      	ldr	r3, [sp, #12]
    3bf2:	011b      	lsls	r3, r3, #4
    3bf4:	9a02      	ldr	r2, [sp, #8]
    3bf6:	4313      	orrs	r3, r2
    3bf8:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    3bfa:	4a04      	ldr	r2, [pc, #16]	; (3c0c <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3bfc:	9b02      	ldr	r3, [sp, #8]
    3bfe:	6053      	str	r3, [r2, #4]
}
    3c00:	bf00      	nop
    3c02:	b004      	add	sp, #16
    3c04:	4770      	bx	lr
    3c06:	bf00      	nop
    3c08:	00009de4 	.word	0x00009de4
    3c0c:	40048000 	.word	0x40048000

00003c10 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3c10:	b084      	sub	sp, #16
    3c12:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    3c14:	9b01      	ldr	r3, [sp, #4]
    3c16:	681a      	ldr	r2, [r3, #0]
    3c18:	490f      	ldr	r1, [pc, #60]	; (3c58 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    3c1a:	4613      	mov	r3, r2
    3c1c:	00db      	lsls	r3, r3, #3
    3c1e:	4413      	add	r3, r2
    3c20:	440b      	add	r3, r1
    3c22:	3304      	adds	r3, #4
    3c24:	781b      	ldrb	r3, [r3, #0]
    3c26:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    3c28:	4a0c      	ldr	r2, [pc, #48]	; (3c5c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c2a:	9b03      	ldr	r3, [sp, #12]
    3c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c30:	490a      	ldr	r1, [pc, #40]	; (3c5c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c32:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    3c36:	9b03      	ldr	r3, [sp, #12]
    3c38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    3c3c:	4a07      	ldr	r2, [pc, #28]	; (3c5c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c3e:	9b03      	ldr	r3, [sp, #12]
    3c40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c44:	4905      	ldr	r1, [pc, #20]	; (3c5c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c46:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    3c4a:	9b03      	ldr	r3, [sp, #12]
    3c4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3c50:	bf00      	nop
    3c52:	b004      	add	sp, #16
    3c54:	4770      	bx	lr
    3c56:	bf00      	nop
    3c58:	00009ad4 	.word	0x00009ad4
    3c5c:	40065000 	.word	0x40065000

00003c60 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3c60:	b086      	sub	sp, #24
    3c62:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    3c64:	9b01      	ldr	r3, [sp, #4]
    3c66:	681a      	ldr	r2, [r3, #0]
    3c68:	4912      	ldr	r1, [pc, #72]	; (3cb4 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    3c6a:	4613      	mov	r3, r2
    3c6c:	00db      	lsls	r3, r3, #3
    3c6e:	4413      	add	r3, r2
    3c70:	440b      	add	r3, r1
    3c72:	3304      	adds	r3, #4
    3c74:	781b      	ldrb	r3, [r3, #0]
    3c76:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3c78:	9b01      	ldr	r3, [sp, #4]
    3c7a:	685b      	ldr	r3, [r3, #4]
    3c7c:	4a0e      	ldr	r2, [pc, #56]	; (3cb8 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    3c7e:	5cd3      	ldrb	r3, [r2, r3]
    3c80:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    3c82:	4a0e      	ldr	r2, [pc, #56]	; (3cbc <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3c84:	9b05      	ldr	r3, [sp, #20]
    3c86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c8a:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    3c8c:	9b03      	ldr	r3, [sp, #12]
    3c8e:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    3c92:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    3c94:	9b04      	ldr	r3, [sp, #16]
    3c96:	061b      	lsls	r3, r3, #24
    3c98:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    3c9c:	9a03      	ldr	r2, [sp, #12]
    3c9e:	4313      	orrs	r3, r2
    3ca0:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    3ca2:	4906      	ldr	r1, [pc, #24]	; (3cbc <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3ca4:	9b05      	ldr	r3, [sp, #20]
    3ca6:	9a03      	ldr	r2, [sp, #12]
    3ca8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3cac:	bf00      	nop
    3cae:	b006      	add	sp, #24
    3cb0:	4770      	bx	lr
    3cb2:	bf00      	nop
    3cb4:	00009ad4 	.word	0x00009ad4
    3cb8:	00009e6c 	.word	0x00009e6c
    3cbc:	40065000 	.word	0x40065000

00003cc0 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3cc0:	b084      	sub	sp, #16
    3cc2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3cc4:	4b0b      	ldr	r3, [pc, #44]	; (3cf4 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    3cc6:	7f1b      	ldrb	r3, [r3, #28]
    3cc8:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    3cca:	4b0b      	ldr	r3, [pc, #44]	; (3cf8 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3ccc:	685b      	ldr	r3, [r3, #4]
    3cce:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    3cd0:	9b02      	ldr	r3, [sp, #8]
    3cd2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    3cd6:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3cd8:	9b03      	ldr	r3, [sp, #12]
    3cda:	031b      	lsls	r3, r3, #12
    3cdc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    3ce0:	9a02      	ldr	r2, [sp, #8]
    3ce2:	4313      	orrs	r3, r2
    3ce4:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    3ce6:	4a04      	ldr	r2, [pc, #16]	; (3cf8 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3ce8:	9b02      	ldr	r3, [sp, #8]
    3cea:	6053      	str	r3, [r2, #4]
}
    3cec:	bf00      	nop
    3cee:	b004      	add	sp, #16
    3cf0:	4770      	bx	lr
    3cf2:	bf00      	nop
    3cf4:	00009de4 	.word	0x00009de4
    3cf8:	40048000 	.word	0x40048000

00003cfc <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3cfc:	b084      	sub	sp, #16
    3cfe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3d00:	9b01      	ldr	r3, [sp, #4]
    3d02:	685b      	ldr	r3, [r3, #4]
    3d04:	4a0b      	ldr	r2, [pc, #44]	; (3d34 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    3d06:	5cd3      	ldrb	r3, [r2, r3]
    3d08:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    3d0a:	4b0b      	ldr	r3, [pc, #44]	; (3d38 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    3d0c:	685b      	ldr	r3, [r3, #4]
    3d0e:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    3d10:	9b02      	ldr	r3, [sp, #8]
    3d12:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    3d16:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3d18:	9b03      	ldr	r3, [sp, #12]
    3d1a:	031b      	lsls	r3, r3, #12
    3d1c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    3d20:	9a02      	ldr	r2, [sp, #8]
    3d22:	4313      	orrs	r3, r2
    3d24:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    3d26:	4a04      	ldr	r2, [pc, #16]	; (3d38 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    3d28:	9b02      	ldr	r3, [sp, #8]
    3d2a:	6053      	str	r3, [r2, #4]
}
    3d2c:	bf00      	nop
    3d2e:	b004      	add	sp, #16
    3d30:	4770      	bx	lr
    3d32:	bf00      	nop
    3d34:	00009de4 	.word	0x00009de4
    3d38:	40048000 	.word	0x40048000

00003d3c <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    3d3c:	b500      	push	{lr}
    3d3e:	b085      	sub	sp, #20
    3d40:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    3d42:	2300      	movs	r3, #0
    3d44:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    3d48:	9b01      	ldr	r3, [sp, #4]
    3d4a:	2b00      	cmp	r3, #0
    3d4c:	d037      	beq.n	3dbe <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3d4e:	2300      	movs	r3, #0
    3d50:	9303      	str	r3, [sp, #12]
    3d52:	e02b      	b.n	3dac <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3d54:	4b29      	ldr	r3, [pc, #164]	; (3dfc <DisableSafeClock+0xc0>)
    3d56:	6819      	ldr	r1, [r3, #0]
    3d58:	9a03      	ldr	r2, [sp, #12]
    3d5a:	4613      	mov	r3, r2
    3d5c:	005b      	lsls	r3, r3, #1
    3d5e:	4413      	add	r3, r2
    3d60:	009b      	lsls	r3, r3, #2
    3d62:	440b      	add	r3, r1
    3d64:	3314      	adds	r3, #20
    3d66:	681b      	ldr	r3, [r3, #0]
    3d68:	2b05      	cmp	r3, #5
    3d6a:	d11c      	bne.n	3da6 <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    3d6c:	2301      	movs	r3, #1
    3d6e:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    3d72:	4b22      	ldr	r3, [pc, #136]	; (3dfc <DisableSafeClock+0xc0>)
    3d74:	6819      	ldr	r1, [r3, #0]
    3d76:	9a03      	ldr	r2, [sp, #12]
    3d78:	4613      	mov	r3, r2
    3d7a:	005b      	lsls	r3, r3, #1
    3d7c:	4413      	add	r3, r2
    3d7e:	009b      	lsls	r3, r3, #2
    3d80:	440b      	add	r3, r1
    3d82:	3318      	adds	r3, #24
    3d84:	881b      	ldrh	r3, [r3, #0]
    3d86:	2b00      	cmp	r3, #0
    3d88:	d118      	bne.n	3dbc <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3d8a:	4b1d      	ldr	r3, [pc, #116]	; (3e00 <DisableSafeClock+0xc4>)
    3d8c:	791b      	ldrb	r3, [r3, #4]
    3d8e:	4619      	mov	r1, r3
    3d90:	4a1c      	ldr	r2, [pc, #112]	; (3e04 <DisableSafeClock+0xc8>)
    3d92:	460b      	mov	r3, r1
    3d94:	005b      	lsls	r3, r3, #1
    3d96:	440b      	add	r3, r1
    3d98:	009b      	lsls	r3, r3, #2
    3d9a:	4413      	add	r3, r2
    3d9c:	3308      	adds	r3, #8
    3d9e:	681b      	ldr	r3, [r3, #0]
    3da0:	2005      	movs	r0, #5
    3da2:	4798      	blx	r3
                }
                break;
    3da4:	e00a      	b.n	3dbc <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3da6:	9b03      	ldr	r3, [sp, #12]
    3da8:	3301      	adds	r3, #1
    3daa:	9303      	str	r3, [sp, #12]
    3dac:	4b13      	ldr	r3, [pc, #76]	; (3dfc <DisableSafeClock+0xc0>)
    3dae:	681b      	ldr	r3, [r3, #0]
    3db0:	7a1b      	ldrb	r3, [r3, #8]
    3db2:	461a      	mov	r2, r3
    3db4:	9b03      	ldr	r3, [sp, #12]
    3db6:	4293      	cmp	r3, r2
    3db8:	d3cc      	bcc.n	3d54 <DisableSafeClock+0x18>
    3dba:	e000      	b.n	3dbe <DisableSafeClock+0x82>
                break;
    3dbc:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    3dbe:	f89d 300b 	ldrb.w	r3, [sp, #11]
    3dc2:	f083 0301 	eor.w	r3, r3, #1
    3dc6:	b2db      	uxtb	r3, r3
    3dc8:	2b00      	cmp	r3, #0
    3dca:	d013      	beq.n	3df4 <DisableSafeClock+0xb8>
    3dcc:	4b0e      	ldr	r3, [pc, #56]	; (3e08 <DisableSafeClock+0xcc>)
    3dce:	781b      	ldrb	r3, [r3, #0]
    3dd0:	f083 0301 	eor.w	r3, r3, #1
    3dd4:	b2db      	uxtb	r3, r3
    3dd6:	2b00      	cmp	r3, #0
    3dd8:	d00c      	beq.n	3df4 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3dda:	4b09      	ldr	r3, [pc, #36]	; (3e00 <DisableSafeClock+0xc4>)
    3ddc:	791b      	ldrb	r3, [r3, #4]
    3dde:	4619      	mov	r1, r3
    3de0:	4a08      	ldr	r2, [pc, #32]	; (3e04 <DisableSafeClock+0xc8>)
    3de2:	460b      	mov	r3, r1
    3de4:	005b      	lsls	r3, r3, #1
    3de6:	440b      	add	r3, r1
    3de8:	009b      	lsls	r3, r3, #2
    3dea:	4413      	add	r3, r2
    3dec:	3308      	adds	r3, #8
    3dee:	681b      	ldr	r3, [r3, #0]
    3df0:	2005      	movs	r0, #5
    3df2:	4798      	blx	r3
    }
}
    3df4:	bf00      	nop
    3df6:	b005      	add	sp, #20
    3df8:	f85d fb04 	ldr.w	pc, [sp], #4
    3dfc:	1fff8ba8 	.word	0x1fff8ba8
    3e00:	00009a64 	.word	0x00009a64
    3e04:	0000a094 	.word	0x0000a094
    3e08:	1fff8b20 	.word	0x1fff8b20

00003e0c <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    3e0c:	4b06      	ldr	r3, [pc, #24]	; (3e28 <SetFircToResetValue_TrustedCall+0x1c>)
    3e0e:	2200      	movs	r2, #0
    3e10:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    3e14:	4b04      	ldr	r3, [pc, #16]	; (3e28 <SetFircToResetValue_TrustedCall+0x1c>)
    3e16:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3e1a:	4a03      	ldr	r2, [pc, #12]	; (3e28 <SetFircToResetValue_TrustedCall+0x1c>)
    3e1c:	f043 0301 	orr.w	r3, r3, #1
    3e20:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    3e24:	bf00      	nop
    3e26:	4770      	bx	lr
    3e28:	40064000 	.word	0x40064000

00003e2c <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    3e2c:	b084      	sub	sp, #16
    3e2e:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    3e30:	2303      	movs	r3, #3
    3e32:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3e34:	2300      	movs	r3, #0
    3e36:	9302      	str	r3, [sp, #8]
    3e38:	e028      	b.n	3e8c <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    3e3a:	9b01      	ldr	r3, [sp, #4]
    3e3c:	9a02      	ldr	r2, [sp, #8]
    3e3e:	320d      	adds	r2, #13
    3e40:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3e44:	2b28      	cmp	r3, #40	; 0x28
    3e46:	d10b      	bne.n	3e60 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3e48:	9a01      	ldr	r2, [sp, #4]
    3e4a:	9b02      	ldr	r3, [sp, #8]
    3e4c:	330d      	adds	r3, #13
    3e4e:	00db      	lsls	r3, r3, #3
    3e50:	4413      	add	r3, r2
    3e52:	685b      	ldr	r3, [r3, #4]
    3e54:	4a2b      	ldr	r2, [pc, #172]	; (3f04 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    3e56:	5cd3      	ldrb	r3, [r2, r3]
    3e58:	011b      	lsls	r3, r3, #4
    3e5a:	9a03      	ldr	r2, [sp, #12]
    3e5c:	4313      	orrs	r3, r2
    3e5e:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    3e60:	9b01      	ldr	r3, [sp, #4]
    3e62:	9a02      	ldr	r2, [sp, #8]
    3e64:	320d      	adds	r2, #13
    3e66:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3e6a:	2b29      	cmp	r3, #41	; 0x29
    3e6c:	d10b      	bne.n	3e86 <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3e6e:	9a01      	ldr	r2, [sp, #4]
    3e70:	9b02      	ldr	r3, [sp, #8]
    3e72:	330d      	adds	r3, #13
    3e74:	00db      	lsls	r3, r3, #3
    3e76:	4413      	add	r3, r2
    3e78:	685b      	ldr	r3, [r3, #4]
    3e7a:	4a23      	ldr	r2, [pc, #140]	; (3f08 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    3e7c:	5cd3      	ldrb	r3, [r2, r3]
    3e7e:	009b      	lsls	r3, r3, #2
    3e80:	9a03      	ldr	r2, [sp, #12]
    3e82:	4313      	orrs	r3, r2
    3e84:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3e86:	9b02      	ldr	r3, [sp, #8]
    3e88:	3301      	adds	r3, #1
    3e8a:	9302      	str	r3, [sp, #8]
    3e8c:	9b01      	ldr	r3, [sp, #4]
    3e8e:	7adb      	ldrb	r3, [r3, #11]
    3e90:	461a      	mov	r2, r3
    3e92:	9b02      	ldr	r3, [sp, #8]
    3e94:	4293      	cmp	r3, r2
    3e96:	d3d0      	bcc.n	3e3a <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3e98:	2300      	movs	r3, #0
    3e9a:	9302      	str	r3, [sp, #8]
    3e9c:	e026      	b.n	3eec <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    3e9e:	9a01      	ldr	r2, [sp, #4]
    3ea0:	9b02      	ldr	r3, [sp, #8]
    3ea2:	334e      	adds	r3, #78	; 0x4e
    3ea4:	00db      	lsls	r3, r3, #3
    3ea6:	4413      	add	r3, r2
    3ea8:	685b      	ldr	r3, [r3, #4]
    3eaa:	2b12      	cmp	r3, #18
    3eac:	d109      	bne.n	3ec2 <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3eae:	9a01      	ldr	r2, [sp, #4]
    3eb0:	9b02      	ldr	r3, [sp, #8]
    3eb2:	334e      	adds	r3, #78	; 0x4e
    3eb4:	00db      	lsls	r3, r3, #3
    3eb6:	4413      	add	r3, r2
    3eb8:	891b      	ldrh	r3, [r3, #8]
    3eba:	005b      	lsls	r3, r3, #1
    3ebc:	9a03      	ldr	r2, [sp, #12]
    3ebe:	4313      	orrs	r3, r2
    3ec0:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    3ec2:	9a01      	ldr	r2, [sp, #4]
    3ec4:	9b02      	ldr	r3, [sp, #8]
    3ec6:	334e      	adds	r3, #78	; 0x4e
    3ec8:	00db      	lsls	r3, r3, #3
    3eca:	4413      	add	r3, r2
    3ecc:	685b      	ldr	r3, [r3, #4]
    3ece:	2b13      	cmp	r3, #19
    3ed0:	d109      	bne.n	3ee6 <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3ed2:	9a01      	ldr	r2, [sp, #4]
    3ed4:	9b02      	ldr	r3, [sp, #8]
    3ed6:	334e      	adds	r3, #78	; 0x4e
    3ed8:	00db      	lsls	r3, r3, #3
    3eda:	4413      	add	r3, r2
    3edc:	891b      	ldrh	r3, [r3, #8]
    3ede:	461a      	mov	r2, r3
    3ee0:	9b03      	ldr	r3, [sp, #12]
    3ee2:	4313      	orrs	r3, r2
    3ee4:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3ee6:	9b02      	ldr	r3, [sp, #8]
    3ee8:	3301      	adds	r3, #1
    3eea:	9302      	str	r3, [sp, #8]
    3eec:	9b01      	ldr	r3, [sp, #4]
    3eee:	7c1b      	ldrb	r3, [r3, #16]
    3ef0:	461a      	mov	r2, r3
    3ef2:	9b02      	ldr	r3, [sp, #8]
    3ef4:	4293      	cmp	r3, r2
    3ef6:	d3d2      	bcc.n	3e9e <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    3ef8:	4a04      	ldr	r2, [pc, #16]	; (3f0c <SetSimLpoclksRegister_TrustedCall+0xe0>)
    3efa:	9b03      	ldr	r3, [sp, #12]
    3efc:	6113      	str	r3, [r2, #16]
}
    3efe:	bf00      	nop
    3f00:	b004      	add	sp, #16
    3f02:	4770      	bx	lr
    3f04:	00009de4 	.word	0x00009de4
    3f08:	00009e9c 	.word	0x00009e9c
    3f0c:	40048000 	.word	0x40048000

00003f10 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    3f10:	b500      	push	{lr}
    3f12:	b089      	sub	sp, #36	; 0x24
    3f14:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3f16:	2300      	movs	r3, #0
    3f18:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    3f1c:	4a21      	ldr	r2, [pc, #132]	; (3fa4 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    3f1e:	9b01      	ldr	r3, [sp, #4]
    3f20:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    3f22:	4b21      	ldr	r3, [pc, #132]	; (3fa8 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3f24:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f28:	f003 0301 	and.w	r3, r3, #1
    3f2c:	2b00      	cmp	r3, #0
    3f2e:	d12e      	bne.n	3f8e <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    3f30:	4b1e      	ldr	r3, [pc, #120]	; (3fac <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3f32:	2200      	movs	r2, #0
    3f34:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    3f36:	f7ff ff69 	bl	3e0c <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3f3a:	aa03      	add	r2, sp, #12
    3f3c:	a904      	add	r1, sp, #16
    3f3e:	a805      	add	r0, sp, #20
    3f40:	f24c 3350 	movw	r3, #50000	; 0xc350
    3f44:	f7fe f8ae 	bl	20a4 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3f48:	4b17      	ldr	r3, [pc, #92]	; (3fa8 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3f4a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f4e:	0e1b      	lsrs	r3, r3, #24
    3f50:	f003 0301 	and.w	r3, r3, #1
    3f54:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3f56:	9a03      	ldr	r2, [sp, #12]
    3f58:	a904      	add	r1, sp, #16
    3f5a:	ab05      	add	r3, sp, #20
    3f5c:	4618      	mov	r0, r3
    3f5e:	f7fe f8bb 	bl	20d8 <Clock_Ip_TimeoutExpired>
    3f62:	4603      	mov	r3, r0
    3f64:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    3f68:	9b06      	ldr	r3, [sp, #24]
    3f6a:	2b00      	cmp	r3, #0
    3f6c:	d106      	bne.n	3f7c <Clock_Ip_SpecificPlatformInitClock+0x6c>
    3f6e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f72:	f083 0301 	eor.w	r3, r3, #1
    3f76:	b2db      	uxtb	r3, r3
    3f78:	2b00      	cmp	r3, #0
    3f7a:	d1e5      	bne.n	3f48 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    3f7c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f80:	2b00      	cmp	r3, #0
    3f82:	d007      	beq.n	3f94 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3f84:	2105      	movs	r1, #5
    3f86:	2001      	movs	r0, #1
    3f88:	f7fe f87c 	bl	2084 <Clock_Ip_ReportClockErrors>
    3f8c:	e002      	b.n	3f94 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    3f8e:	4b07      	ldr	r3, [pc, #28]	; (3fac <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3f90:	2201      	movs	r2, #1
    3f92:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    3f94:	9801      	ldr	r0, [sp, #4]
    3f96:	f7ff ff49 	bl	3e2c <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    3f9a:	bf00      	nop
    3f9c:	b009      	add	sp, #36	; 0x24
    3f9e:	f85d fb04 	ldr.w	pc, [sp], #4
    3fa2:	bf00      	nop
    3fa4:	1fff8ba8 	.word	0x1fff8ba8
    3fa8:	40064000 	.word	0x40064000
    3fac:	1fff8b20 	.word	0x1fff8b20

00003fb0 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    3fb0:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    3fb2:	2300      	movs	r3, #0
    3fb4:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3fb6:	4b29      	ldr	r3, [pc, #164]	; (405c <getFircConfig+0xac>)
    3fb8:	681b      	ldr	r3, [r3, #0]
    3fba:	2b00      	cmp	r3, #0
    3fbc:	d024      	beq.n	4008 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3fbe:	2300      	movs	r3, #0
    3fc0:	9301      	str	r3, [sp, #4]
    3fc2:	e01a      	b.n	3ffa <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3fc4:	4b25      	ldr	r3, [pc, #148]	; (405c <getFircConfig+0xac>)
    3fc6:	6819      	ldr	r1, [r3, #0]
    3fc8:	9a01      	ldr	r2, [sp, #4]
    3fca:	4613      	mov	r3, r2
    3fcc:	005b      	lsls	r3, r3, #1
    3fce:	4413      	add	r3, r2
    3fd0:	009b      	lsls	r3, r3, #2
    3fd2:	440b      	add	r3, r1
    3fd4:	3314      	adds	r3, #20
    3fd6:	681b      	ldr	r3, [r3, #0]
    3fd8:	2b05      	cmp	r3, #5
    3fda:	d10b      	bne.n	3ff4 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    3fdc:	4b1f      	ldr	r3, [pc, #124]	; (405c <getFircConfig+0xac>)
    3fde:	6819      	ldr	r1, [r3, #0]
    3fe0:	9a01      	ldr	r2, [sp, #4]
    3fe2:	4613      	mov	r3, r2
    3fe4:	005b      	lsls	r3, r3, #1
    3fe6:	4413      	add	r3, r2
    3fe8:	009b      	lsls	r3, r3, #2
    3fea:	3310      	adds	r3, #16
    3fec:	440b      	add	r3, r1
    3fee:	3304      	adds	r3, #4
    3ff0:	9300      	str	r3, [sp, #0]
                break;
    3ff2:	e009      	b.n	4008 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3ff4:	9b01      	ldr	r3, [sp, #4]
    3ff6:	3301      	adds	r3, #1
    3ff8:	9301      	str	r3, [sp, #4]
    3ffa:	4b18      	ldr	r3, [pc, #96]	; (405c <getFircConfig+0xac>)
    3ffc:	681b      	ldr	r3, [r3, #0]
    3ffe:	7a1b      	ldrb	r3, [r3, #8]
    4000:	461a      	mov	r2, r3
    4002:	9b01      	ldr	r3, [sp, #4]
    4004:	4293      	cmp	r3, r2
    4006:	d3dd      	bcc.n	3fc4 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4008:	9b00      	ldr	r3, [sp, #0]
    400a:	2b00      	cmp	r3, #0
    400c:	d121      	bne.n	4052 <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    400e:	4b14      	ldr	r3, [pc, #80]	; (4060 <getFircConfig+0xb0>)
    4010:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    4012:	4b13      	ldr	r3, [pc, #76]	; (4060 <getFircConfig+0xb0>)
    4014:	2205      	movs	r2, #5
    4016:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    4018:	4b12      	ldr	r3, [pc, #72]	; (4064 <getFircConfig+0xb4>)
    401a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    401e:	b29b      	uxth	r3, r3
    4020:	f003 0301 	and.w	r3, r3, #1
    4024:	b29a      	uxth	r2, r3
    4026:	4b0e      	ldr	r3, [pc, #56]	; (4060 <getFircConfig+0xb0>)
    4028:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    402a:	4b0e      	ldr	r3, [pc, #56]	; (4064 <getFircConfig+0xb4>)
    402c:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    4030:	b2db      	uxtb	r3, r3
    4032:	f003 0303 	and.w	r3, r3, #3
    4036:	b2da      	uxtb	r2, r3
    4038:	4b09      	ldr	r3, [pc, #36]	; (4060 <getFircConfig+0xb0>)
    403a:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    403c:	4b09      	ldr	r3, [pc, #36]	; (4064 <getFircConfig+0xb4>)
    403e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4042:	b2db      	uxtb	r3, r3
    4044:	10db      	asrs	r3, r3, #3
    4046:	b2db      	uxtb	r3, r3
    4048:	f003 0301 	and.w	r3, r3, #1
    404c:	b2da      	uxtb	r2, r3
    404e:	4b04      	ldr	r3, [pc, #16]	; (4060 <getFircConfig+0xb0>)
    4050:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    4052:	9b00      	ldr	r3, [sp, #0]
}
    4054:	4618      	mov	r0, r3
    4056:	b002      	add	sp, #8
    4058:	4770      	bx	lr
    405a:	bf00      	nop
    405c:	1fff8ba8 	.word	0x1fff8ba8
    4060:	1fff8c14 	.word	0x1fff8c14
    4064:	40064000 	.word	0x40064000

00004068 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    4068:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    406a:	2300      	movs	r3, #0
    406c:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    406e:	4b20      	ldr	r3, [pc, #128]	; (40f0 <getSoscConfig+0x88>)
    4070:	681b      	ldr	r3, [r3, #0]
    4072:	2b00      	cmp	r3, #0
    4074:	d024      	beq.n	40c0 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4076:	2300      	movs	r3, #0
    4078:	9301      	str	r3, [sp, #4]
    407a:	e01a      	b.n	40b2 <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    407c:	4b1c      	ldr	r3, [pc, #112]	; (40f0 <getSoscConfig+0x88>)
    407e:	6819      	ldr	r1, [r3, #0]
    4080:	9a01      	ldr	r2, [sp, #4]
    4082:	4613      	mov	r3, r2
    4084:	009b      	lsls	r3, r3, #2
    4086:	4413      	add	r3, r2
    4088:	009b      	lsls	r3, r3, #2
    408a:	440b      	add	r3, r1
    408c:	332c      	adds	r3, #44	; 0x2c
    408e:	681b      	ldr	r3, [r3, #0]
    4090:	2b08      	cmp	r3, #8
    4092:	d10b      	bne.n	40ac <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    4094:	4b16      	ldr	r3, [pc, #88]	; (40f0 <getSoscConfig+0x88>)
    4096:	6819      	ldr	r1, [r3, #0]
    4098:	9a01      	ldr	r2, [sp, #4]
    409a:	4613      	mov	r3, r2
    409c:	009b      	lsls	r3, r3, #2
    409e:	4413      	add	r3, r2
    40a0:	009b      	lsls	r3, r3, #2
    40a2:	3328      	adds	r3, #40	; 0x28
    40a4:	440b      	add	r3, r1
    40a6:	3304      	adds	r3, #4
    40a8:	9300      	str	r3, [sp, #0]
                break;
    40aa:	e009      	b.n	40c0 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    40ac:	9b01      	ldr	r3, [sp, #4]
    40ae:	3301      	adds	r3, #1
    40b0:	9301      	str	r3, [sp, #4]
    40b2:	4b0f      	ldr	r3, [pc, #60]	; (40f0 <getSoscConfig+0x88>)
    40b4:	681b      	ldr	r3, [r3, #0]
    40b6:	7a5b      	ldrb	r3, [r3, #9]
    40b8:	461a      	mov	r2, r3
    40ba:	9b01      	ldr	r3, [sp, #4]
    40bc:	4293      	cmp	r3, r2
    40be:	d3dd      	bcc.n	407c <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    40c0:	9b00      	ldr	r3, [sp, #0]
    40c2:	2b00      	cmp	r3, #0
    40c4:	d110      	bne.n	40e8 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    40c6:	4b0b      	ldr	r3, [pc, #44]	; (40f4 <getSoscConfig+0x8c>)
    40c8:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    40ca:	4b0a      	ldr	r3, [pc, #40]	; (40f4 <getSoscConfig+0x8c>)
    40cc:	2208      	movs	r2, #8
    40ce:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    40d0:	4b09      	ldr	r3, [pc, #36]	; (40f8 <getSoscConfig+0x90>)
    40d2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    40d6:	b29b      	uxth	r3, r3
    40d8:	f003 0301 	and.w	r3, r3, #1
    40dc:	b29a      	uxth	r2, r3
    40de:	4b05      	ldr	r3, [pc, #20]	; (40f4 <getSoscConfig+0x8c>)
    40e0:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    40e2:	4b04      	ldr	r3, [pc, #16]	; (40f4 <getSoscConfig+0x8c>)
    40e4:	4a05      	ldr	r2, [pc, #20]	; (40fc <getSoscConfig+0x94>)
    40e6:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    40e8:	9b00      	ldr	r3, [sp, #0]
}
    40ea:	4618      	mov	r0, r3
    40ec:	b002      	add	sp, #8
    40ee:	4770      	bx	lr
    40f0:	1fff8ba8 	.word	0x1fff8ba8
    40f4:	1fff8c20 	.word	0x1fff8c20
    40f8:	40064000 	.word	0x40064000
    40fc:	02625a00 	.word	0x02625a00

00004100 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    4100:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    4102:	2300      	movs	r3, #0
    4104:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4106:	4b28      	ldr	r3, [pc, #160]	; (41a8 <getSpllConfig+0xa8>)
    4108:	681b      	ldr	r3, [r3, #0]
    410a:	2b00      	cmp	r3, #0
    410c:	d023      	beq.n	4156 <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    410e:	2300      	movs	r3, #0
    4110:	9301      	str	r3, [sp, #4]
    4112:	e019      	b.n	4148 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    4114:	4b24      	ldr	r3, [pc, #144]	; (41a8 <getSpllConfig+0xa8>)
    4116:	6819      	ldr	r1, [r3, #0]
    4118:	9a01      	ldr	r2, [sp, #4]
    411a:	4613      	mov	r3, r2
    411c:	009b      	lsls	r3, r3, #2
    411e:	4413      	add	r3, r2
    4120:	00db      	lsls	r3, r3, #3
    4122:	440b      	add	r3, r1
    4124:	3340      	adds	r3, #64	; 0x40
    4126:	681b      	ldr	r3, [r3, #0]
    4128:	2b09      	cmp	r3, #9
    412a:	d10a      	bne.n	4142 <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    412c:	4b1e      	ldr	r3, [pc, #120]	; (41a8 <getSpllConfig+0xa8>)
    412e:	6819      	ldr	r1, [r3, #0]
    4130:	9a01      	ldr	r2, [sp, #4]
    4132:	4613      	mov	r3, r2
    4134:	009b      	lsls	r3, r3, #2
    4136:	4413      	add	r3, r2
    4138:	00db      	lsls	r3, r3, #3
    413a:	3340      	adds	r3, #64	; 0x40
    413c:	440b      	add	r3, r1
    413e:	9300      	str	r3, [sp, #0]
                break;
    4140:	e009      	b.n	4156 <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4142:	9b01      	ldr	r3, [sp, #4]
    4144:	3301      	adds	r3, #1
    4146:	9301      	str	r3, [sp, #4]
    4148:	4b17      	ldr	r3, [pc, #92]	; (41a8 <getSpllConfig+0xa8>)
    414a:	681b      	ldr	r3, [r3, #0]
    414c:	7a9b      	ldrb	r3, [r3, #10]
    414e:	461a      	mov	r2, r3
    4150:	9b01      	ldr	r3, [sp, #4]
    4152:	4293      	cmp	r3, r2
    4154:	d3de      	bcc.n	4114 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4156:	9b00      	ldr	r3, [sp, #0]
    4158:	2b00      	cmp	r3, #0
    415a:	d121      	bne.n	41a0 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    415c:	4b13      	ldr	r3, [pc, #76]	; (41ac <getSpllConfig+0xac>)
    415e:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    4160:	4b12      	ldr	r3, [pc, #72]	; (41ac <getSpllConfig+0xac>)
    4162:	2209      	movs	r2, #9
    4164:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    4166:	4b12      	ldr	r3, [pc, #72]	; (41b0 <getSpllConfig+0xb0>)
    4168:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    416c:	b29b      	uxth	r3, r3
    416e:	f003 0301 	and.w	r3, r3, #1
    4172:	b29a      	uxth	r2, r3
    4174:	4b0d      	ldr	r3, [pc, #52]	; (41ac <getSpllConfig+0xac>)
    4176:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    4178:	4b0d      	ldr	r3, [pc, #52]	; (41b0 <getSpllConfig+0xb0>)
    417a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    417e:	0a1b      	lsrs	r3, r3, #8
    4180:	b2db      	uxtb	r3, r3
    4182:	f003 0307 	and.w	r3, r3, #7
    4186:	b2da      	uxtb	r2, r3
    4188:	4b08      	ldr	r3, [pc, #32]	; (41ac <getSpllConfig+0xac>)
    418a:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    418c:	4b08      	ldr	r3, [pc, #32]	; (41b0 <getSpllConfig+0xb0>)
    418e:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4192:	0c1b      	lsrs	r3, r3, #16
    4194:	b2db      	uxtb	r3, r3
    4196:	f003 031f 	and.w	r3, r3, #31
    419a:	b2da      	uxtb	r2, r3
    419c:	4b03      	ldr	r3, [pc, #12]	; (41ac <getSpllConfig+0xac>)
    419e:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    41a0:	9b00      	ldr	r3, [sp, #0]
}
    41a2:	4618      	mov	r0, r3
    41a4:	b002      	add	sp, #8
    41a6:	4770      	bx	lr
    41a8:	1fff8ba8 	.word	0x1fff8ba8
    41ac:	1fff8c34 	.word	0x1fff8c34
    41b0:	40064000 	.word	0x40064000

000041b4 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    41b4:	b086      	sub	sp, #24
    41b6:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    41b8:	2300      	movs	r3, #0
    41ba:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    41bc:	9b01      	ldr	r3, [sp, #4]
    41be:	2b1b      	cmp	r3, #27
    41c0:	d00f      	beq.n	41e2 <getSelectorConfig+0x2e>
    41c2:	9b01      	ldr	r3, [sp, #4]
    41c4:	2b1b      	cmp	r3, #27
    41c6:	d80f      	bhi.n	41e8 <getSelectorConfig+0x34>
    41c8:	9b01      	ldr	r3, [sp, #4]
    41ca:	2b19      	cmp	r3, #25
    41cc:	d003      	beq.n	41d6 <getSelectorConfig+0x22>
    41ce:	9b01      	ldr	r3, [sp, #4]
    41d0:	2b1a      	cmp	r3, #26
    41d2:	d003      	beq.n	41dc <getSelectorConfig+0x28>
    41d4:	e008      	b.n	41e8 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    41d6:	2300      	movs	r3, #0
    41d8:	9304      	str	r3, [sp, #16]
            break;
    41da:	e008      	b.n	41ee <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    41dc:	2301      	movs	r3, #1
    41de:	9304      	str	r3, [sp, #16]
            break;
    41e0:	e005      	b.n	41ee <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    41e2:	2302      	movs	r3, #2
    41e4:	9304      	str	r3, [sp, #16]
            break;
    41e6:	e002      	b.n	41ee <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    41e8:	2300      	movs	r3, #0
    41ea:	9304      	str	r3, [sp, #16]
            break;
    41ec:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    41ee:	4b36      	ldr	r3, [pc, #216]	; (42c8 <getSelectorConfig+0x114>)
    41f0:	681b      	ldr	r3, [r3, #0]
    41f2:	2b00      	cmp	r3, #0
    41f4:	d01d      	beq.n	4232 <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    41f6:	2300      	movs	r3, #0
    41f8:	9303      	str	r3, [sp, #12]
    41fa:	e013      	b.n	4224 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    41fc:	4b32      	ldr	r3, [pc, #200]	; (42c8 <getSelectorConfig+0x114>)
    41fe:	681b      	ldr	r3, [r3, #0]
    4200:	9a03      	ldr	r2, [sp, #12]
    4202:	320d      	adds	r2, #13
    4204:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4208:	9a01      	ldr	r2, [sp, #4]
    420a:	429a      	cmp	r2, r3
    420c:	d107      	bne.n	421e <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    420e:	4b2e      	ldr	r3, [pc, #184]	; (42c8 <getSelectorConfig+0x114>)
    4210:	681a      	ldr	r2, [r3, #0]
    4212:	9b03      	ldr	r3, [sp, #12]
    4214:	330d      	adds	r3, #13
    4216:	00db      	lsls	r3, r3, #3
    4218:	4413      	add	r3, r2
    421a:	9305      	str	r3, [sp, #20]
                break;
    421c:	e009      	b.n	4232 <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    421e:	9b03      	ldr	r3, [sp, #12]
    4220:	3301      	adds	r3, #1
    4222:	9303      	str	r3, [sp, #12]
    4224:	4b28      	ldr	r3, [pc, #160]	; (42c8 <getSelectorConfig+0x114>)
    4226:	681b      	ldr	r3, [r3, #0]
    4228:	7adb      	ldrb	r3, [r3, #11]
    422a:	461a      	mov	r2, r3
    422c:	9b03      	ldr	r3, [sp, #12]
    422e:	4293      	cmp	r3, r2
    4230:	d3e4      	bcc.n	41fc <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4232:	9b05      	ldr	r3, [sp, #20]
    4234:	2b00      	cmp	r3, #0
    4236:	d140      	bne.n	42ba <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    4238:	9b04      	ldr	r3, [sp, #16]
    423a:	00db      	lsls	r3, r3, #3
    423c:	4a23      	ldr	r2, [pc, #140]	; (42cc <getSelectorConfig+0x118>)
    423e:	4413      	add	r3, r2
    4240:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    4242:	4922      	ldr	r1, [pc, #136]	; (42cc <getSelectorConfig+0x118>)
    4244:	9b04      	ldr	r3, [sp, #16]
    4246:	9a01      	ldr	r2, [sp, #4]
    4248:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    424c:	9b01      	ldr	r3, [sp, #4]
    424e:	2b1b      	cmp	r3, #27
    4250:	d025      	beq.n	429e <getSelectorConfig+0xea>
    4252:	9b01      	ldr	r3, [sp, #4]
    4254:	2b1b      	cmp	r3, #27
    4256:	d832      	bhi.n	42be <getSelectorConfig+0x10a>
    4258:	9b01      	ldr	r3, [sp, #4]
    425a:	2b19      	cmp	r3, #25
    425c:	d003      	beq.n	4266 <getSelectorConfig+0xb2>
    425e:	9b01      	ldr	r3, [sp, #4]
    4260:	2b1a      	cmp	r3, #26
    4262:	d00e      	beq.n	4282 <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4264:	e02b      	b.n	42be <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    4266:	4b1a      	ldr	r3, [pc, #104]	; (42d0 <getSelectorConfig+0x11c>)
    4268:	695b      	ldr	r3, [r3, #20]
    426a:	0e1b      	lsrs	r3, r3, #24
    426c:	f003 030f 	and.w	r3, r3, #15
    4270:	4a18      	ldr	r2, [pc, #96]	; (42d4 <getSelectorConfig+0x120>)
    4272:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4276:	4915      	ldr	r1, [pc, #84]	; (42cc <getSelectorConfig+0x118>)
    4278:	9b04      	ldr	r3, [sp, #16]
    427a:	00db      	lsls	r3, r3, #3
    427c:	440b      	add	r3, r1
    427e:	605a      	str	r2, [r3, #4]
                break;
    4280:	e01e      	b.n	42c0 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    4282:	4b13      	ldr	r3, [pc, #76]	; (42d0 <getSelectorConfig+0x11c>)
    4284:	699b      	ldr	r3, [r3, #24]
    4286:	0e1b      	lsrs	r3, r3, #24
    4288:	f003 030f 	and.w	r3, r3, #15
    428c:	4a11      	ldr	r2, [pc, #68]	; (42d4 <getSelectorConfig+0x120>)
    428e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4292:	490e      	ldr	r1, [pc, #56]	; (42cc <getSelectorConfig+0x118>)
    4294:	9b04      	ldr	r3, [sp, #16]
    4296:	00db      	lsls	r3, r3, #3
    4298:	440b      	add	r3, r1
    429a:	605a      	str	r2, [r3, #4]
                break;
    429c:	e010      	b.n	42c0 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    429e:	4b0c      	ldr	r3, [pc, #48]	; (42d0 <getSelectorConfig+0x11c>)
    42a0:	69db      	ldr	r3, [r3, #28]
    42a2:	0e1b      	lsrs	r3, r3, #24
    42a4:	f003 030f 	and.w	r3, r3, #15
    42a8:	4a0a      	ldr	r2, [pc, #40]	; (42d4 <getSelectorConfig+0x120>)
    42aa:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    42ae:	4907      	ldr	r1, [pc, #28]	; (42cc <getSelectorConfig+0x118>)
    42b0:	9b04      	ldr	r3, [sp, #16]
    42b2:	00db      	lsls	r3, r3, #3
    42b4:	440b      	add	r3, r1
    42b6:	605a      	str	r2, [r3, #4]
                break;
    42b8:	e002      	b.n	42c0 <getSelectorConfig+0x10c>
        }
    }
    42ba:	bf00      	nop
    42bc:	e000      	b.n	42c0 <getSelectorConfig+0x10c>
                break;
    42be:	bf00      	nop

    return ReturnValue;
    42c0:	9b05      	ldr	r3, [sp, #20]
}
    42c2:	4618      	mov	r0, r3
    42c4:	b006      	add	sp, #24
    42c6:	4770      	bx	lr
    42c8:	1fff8ba8 	.word	0x1fff8ba8
    42cc:	1fff8c5c 	.word	0x1fff8c5c
    42d0:	40064000 	.word	0x40064000
    42d4:	0000a164 	.word	0x0000a164

000042d8 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    42d8:	b086      	sub	sp, #24
    42da:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    42dc:	2300      	movs	r3, #0
    42de:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    42e0:	2300      	movs	r3, #0
    42e2:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    42e4:	9b01      	ldr	r3, [sp, #4]
    42e6:	2b1f      	cmp	r3, #31
    42e8:	d00f      	beq.n	430a <getCoreDividerConfig+0x32>
    42ea:	9b01      	ldr	r3, [sp, #4]
    42ec:	2b1f      	cmp	r3, #31
    42ee:	d80f      	bhi.n	4310 <getCoreDividerConfig+0x38>
    42f0:	9b01      	ldr	r3, [sp, #4]
    42f2:	2b1d      	cmp	r3, #29
    42f4:	d003      	beq.n	42fe <getCoreDividerConfig+0x26>
    42f6:	9b01      	ldr	r3, [sp, #4]
    42f8:	2b1e      	cmp	r3, #30
    42fa:	d003      	beq.n	4304 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    42fc:	e008      	b.n	4310 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    42fe:	2300      	movs	r3, #0
    4300:	9304      	str	r3, [sp, #16]
            break;
    4302:	e006      	b.n	4312 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4304:	2301      	movs	r3, #1
    4306:	9304      	str	r3, [sp, #16]
            break;
    4308:	e003      	b.n	4312 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    430a:	2302      	movs	r3, #2
    430c:	9304      	str	r3, [sp, #16]
            break;
    430e:	e000      	b.n	4312 <getCoreDividerConfig+0x3a>
                break;
    4310:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4312:	4b41      	ldr	r3, [pc, #260]	; (4418 <getCoreDividerConfig+0x140>)
    4314:	681b      	ldr	r3, [r3, #0]
    4316:	2b00      	cmp	r3, #0
    4318:	d026      	beq.n	4368 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    431a:	2300      	movs	r3, #0
    431c:	9303      	str	r3, [sp, #12]
    431e:	e01c      	b.n	435a <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4320:	4b3d      	ldr	r3, [pc, #244]	; (4418 <getCoreDividerConfig+0x140>)
    4322:	6819      	ldr	r1, [r3, #0]
    4324:	9a03      	ldr	r2, [sp, #12]
    4326:	4613      	mov	r3, r2
    4328:	005b      	lsls	r3, r3, #1
    432a:	4413      	add	r3, r2
    432c:	009b      	lsls	r3, r3, #2
    432e:	440b      	add	r3, r1
    4330:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4334:	681b      	ldr	r3, [r3, #0]
    4336:	9a01      	ldr	r2, [sp, #4]
    4338:	429a      	cmp	r2, r3
    433a:	d10b      	bne.n	4354 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    433c:	4b36      	ldr	r3, [pc, #216]	; (4418 <getCoreDividerConfig+0x140>)
    433e:	6819      	ldr	r1, [r3, #0]
    4340:	9a03      	ldr	r2, [sp, #12]
    4342:	4613      	mov	r3, r2
    4344:	005b      	lsls	r3, r3, #1
    4346:	4413      	add	r3, r2
    4348:	009b      	lsls	r3, r3, #2
    434a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    434e:	440b      	add	r3, r1
    4350:	9305      	str	r3, [sp, #20]
                break;
    4352:	e009      	b.n	4368 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4354:	9b03      	ldr	r3, [sp, #12]
    4356:	3301      	adds	r3, #1
    4358:	9303      	str	r3, [sp, #12]
    435a:	4b2f      	ldr	r3, [pc, #188]	; (4418 <getCoreDividerConfig+0x140>)
    435c:	681b      	ldr	r3, [r3, #0]
    435e:	7b1b      	ldrb	r3, [r3, #12]
    4360:	461a      	mov	r2, r3
    4362:	9b03      	ldr	r3, [sp, #12]
    4364:	4293      	cmp	r3, r2
    4366:	d3db      	bcc.n	4320 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4368:	9b05      	ldr	r3, [sp, #20]
    436a:	2b00      	cmp	r3, #0
    436c:	d14d      	bne.n	440a <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    436e:	9a04      	ldr	r2, [sp, #16]
    4370:	4613      	mov	r3, r2
    4372:	005b      	lsls	r3, r3, #1
    4374:	4413      	add	r3, r2
    4376:	009b      	lsls	r3, r3, #2
    4378:	4a28      	ldr	r2, [pc, #160]	; (441c <getCoreDividerConfig+0x144>)
    437a:	4413      	add	r3, r2
    437c:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    437e:	4927      	ldr	r1, [pc, #156]	; (441c <getCoreDividerConfig+0x144>)
    4380:	9a04      	ldr	r2, [sp, #16]
    4382:	4613      	mov	r3, r2
    4384:	005b      	lsls	r3, r3, #1
    4386:	4413      	add	r3, r2
    4388:	009b      	lsls	r3, r3, #2
    438a:	440b      	add	r3, r1
    438c:	9a01      	ldr	r2, [sp, #4]
    438e:	601a      	str	r2, [r3, #0]
        switch(Name)
    4390:	9b01      	ldr	r3, [sp, #4]
    4392:	2b1f      	cmp	r3, #31
    4394:	d029      	beq.n	43ea <getCoreDividerConfig+0x112>
    4396:	9b01      	ldr	r3, [sp, #4]
    4398:	2b1f      	cmp	r3, #31
    439a:	d838      	bhi.n	440e <getCoreDividerConfig+0x136>
    439c:	9b01      	ldr	r3, [sp, #4]
    439e:	2b1d      	cmp	r3, #29
    43a0:	d003      	beq.n	43aa <getCoreDividerConfig+0xd2>
    43a2:	9b01      	ldr	r3, [sp, #4]
    43a4:	2b1e      	cmp	r3, #30
    43a6:	d010      	beq.n	43ca <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    43a8:	e031      	b.n	440e <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    43aa:	4b1d      	ldr	r3, [pc, #116]	; (4420 <getCoreDividerConfig+0x148>)
    43ac:	695b      	ldr	r3, [r3, #20]
    43ae:	0c1b      	lsrs	r3, r3, #16
    43b0:	f003 030f 	and.w	r3, r3, #15
    43b4:	1c59      	adds	r1, r3, #1
    43b6:	4819      	ldr	r0, [pc, #100]	; (441c <getCoreDividerConfig+0x144>)
    43b8:	9a04      	ldr	r2, [sp, #16]
    43ba:	4613      	mov	r3, r2
    43bc:	005b      	lsls	r3, r3, #1
    43be:	4413      	add	r3, r2
    43c0:	009b      	lsls	r3, r3, #2
    43c2:	4403      	add	r3, r0
    43c4:	3304      	adds	r3, #4
    43c6:	6019      	str	r1, [r3, #0]
                break;
    43c8:	e022      	b.n	4410 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    43ca:	4b15      	ldr	r3, [pc, #84]	; (4420 <getCoreDividerConfig+0x148>)
    43cc:	699b      	ldr	r3, [r3, #24]
    43ce:	0c1b      	lsrs	r3, r3, #16
    43d0:	f003 030f 	and.w	r3, r3, #15
    43d4:	1c59      	adds	r1, r3, #1
    43d6:	4811      	ldr	r0, [pc, #68]	; (441c <getCoreDividerConfig+0x144>)
    43d8:	9a04      	ldr	r2, [sp, #16]
    43da:	4613      	mov	r3, r2
    43dc:	005b      	lsls	r3, r3, #1
    43de:	4413      	add	r3, r2
    43e0:	009b      	lsls	r3, r3, #2
    43e2:	4403      	add	r3, r0
    43e4:	3304      	adds	r3, #4
    43e6:	6019      	str	r1, [r3, #0]
                break;
    43e8:	e012      	b.n	4410 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    43ea:	4b0d      	ldr	r3, [pc, #52]	; (4420 <getCoreDividerConfig+0x148>)
    43ec:	69db      	ldr	r3, [r3, #28]
    43ee:	0c1b      	lsrs	r3, r3, #16
    43f0:	f003 030f 	and.w	r3, r3, #15
    43f4:	1c59      	adds	r1, r3, #1
    43f6:	4809      	ldr	r0, [pc, #36]	; (441c <getCoreDividerConfig+0x144>)
    43f8:	9a04      	ldr	r2, [sp, #16]
    43fa:	4613      	mov	r3, r2
    43fc:	005b      	lsls	r3, r3, #1
    43fe:	4413      	add	r3, r2
    4400:	009b      	lsls	r3, r3, #2
    4402:	4403      	add	r3, r0
    4404:	3304      	adds	r3, #4
    4406:	6019      	str	r1, [r3, #0]
                break;
    4408:	e002      	b.n	4410 <getCoreDividerConfig+0x138>
        }
    }
    440a:	bf00      	nop
    440c:	e000      	b.n	4410 <getCoreDividerConfig+0x138>
                break;
    440e:	bf00      	nop

    return ReturnValue;
    4410:	9b05      	ldr	r3, [sp, #20]
}
    4412:	4618      	mov	r0, r3
    4414:	b006      	add	sp, #24
    4416:	4770      	bx	lr
    4418:	1fff8ba8 	.word	0x1fff8ba8
    441c:	1fff8c74 	.word	0x1fff8c74
    4420:	40064000 	.word	0x40064000

00004424 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    4424:	b086      	sub	sp, #24
    4426:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4428:	2300      	movs	r3, #0
    442a:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    442c:	2300      	movs	r3, #0
    442e:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4430:	9b01      	ldr	r3, [sp, #4]
    4432:	2b23      	cmp	r3, #35	; 0x23
    4434:	d00f      	beq.n	4456 <getBusDividerConfig+0x32>
    4436:	9b01      	ldr	r3, [sp, #4]
    4438:	2b23      	cmp	r3, #35	; 0x23
    443a:	d80f      	bhi.n	445c <getBusDividerConfig+0x38>
    443c:	9b01      	ldr	r3, [sp, #4]
    443e:	2b21      	cmp	r3, #33	; 0x21
    4440:	d003      	beq.n	444a <getBusDividerConfig+0x26>
    4442:	9b01      	ldr	r3, [sp, #4]
    4444:	2b22      	cmp	r3, #34	; 0x22
    4446:	d003      	beq.n	4450 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4448:	e008      	b.n	445c <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    444a:	2300      	movs	r3, #0
    444c:	9304      	str	r3, [sp, #16]
            break;
    444e:	e006      	b.n	445e <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4450:	2301      	movs	r3, #1
    4452:	9304      	str	r3, [sp, #16]
            break;
    4454:	e003      	b.n	445e <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    4456:	2302      	movs	r3, #2
    4458:	9304      	str	r3, [sp, #16]
            break;
    445a:	e000      	b.n	445e <getBusDividerConfig+0x3a>
                break;
    445c:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    445e:	4b41      	ldr	r3, [pc, #260]	; (4564 <getBusDividerConfig+0x140>)
    4460:	681b      	ldr	r3, [r3, #0]
    4462:	2b00      	cmp	r3, #0
    4464:	d026      	beq.n	44b4 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4466:	2300      	movs	r3, #0
    4468:	9303      	str	r3, [sp, #12]
    446a:	e01c      	b.n	44a6 <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    446c:	4b3d      	ldr	r3, [pc, #244]	; (4564 <getBusDividerConfig+0x140>)
    446e:	6819      	ldr	r1, [r3, #0]
    4470:	9a03      	ldr	r2, [sp, #12]
    4472:	4613      	mov	r3, r2
    4474:	005b      	lsls	r3, r3, #1
    4476:	4413      	add	r3, r2
    4478:	009b      	lsls	r3, r3, #2
    447a:	440b      	add	r3, r1
    447c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4480:	681b      	ldr	r3, [r3, #0]
    4482:	9a01      	ldr	r2, [sp, #4]
    4484:	429a      	cmp	r2, r3
    4486:	d10b      	bne.n	44a0 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    4488:	4b36      	ldr	r3, [pc, #216]	; (4564 <getBusDividerConfig+0x140>)
    448a:	6819      	ldr	r1, [r3, #0]
    448c:	9a03      	ldr	r2, [sp, #12]
    448e:	4613      	mov	r3, r2
    4490:	005b      	lsls	r3, r3, #1
    4492:	4413      	add	r3, r2
    4494:	009b      	lsls	r3, r3, #2
    4496:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    449a:	440b      	add	r3, r1
    449c:	9305      	str	r3, [sp, #20]
                break;
    449e:	e009      	b.n	44b4 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    44a0:	9b03      	ldr	r3, [sp, #12]
    44a2:	3301      	adds	r3, #1
    44a4:	9303      	str	r3, [sp, #12]
    44a6:	4b2f      	ldr	r3, [pc, #188]	; (4564 <getBusDividerConfig+0x140>)
    44a8:	681b      	ldr	r3, [r3, #0]
    44aa:	7b1b      	ldrb	r3, [r3, #12]
    44ac:	461a      	mov	r2, r3
    44ae:	9b03      	ldr	r3, [sp, #12]
    44b0:	4293      	cmp	r3, r2
    44b2:	d3db      	bcc.n	446c <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    44b4:	9b05      	ldr	r3, [sp, #20]
    44b6:	2b00      	cmp	r3, #0
    44b8:	d14d      	bne.n	4556 <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    44ba:	9a04      	ldr	r2, [sp, #16]
    44bc:	4613      	mov	r3, r2
    44be:	005b      	lsls	r3, r3, #1
    44c0:	4413      	add	r3, r2
    44c2:	009b      	lsls	r3, r3, #2
    44c4:	4a28      	ldr	r2, [pc, #160]	; (4568 <getBusDividerConfig+0x144>)
    44c6:	4413      	add	r3, r2
    44c8:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    44ca:	4927      	ldr	r1, [pc, #156]	; (4568 <getBusDividerConfig+0x144>)
    44cc:	9a04      	ldr	r2, [sp, #16]
    44ce:	4613      	mov	r3, r2
    44d0:	005b      	lsls	r3, r3, #1
    44d2:	4413      	add	r3, r2
    44d4:	009b      	lsls	r3, r3, #2
    44d6:	440b      	add	r3, r1
    44d8:	9a01      	ldr	r2, [sp, #4]
    44da:	601a      	str	r2, [r3, #0]
        switch(Name)
    44dc:	9b01      	ldr	r3, [sp, #4]
    44de:	2b23      	cmp	r3, #35	; 0x23
    44e0:	d029      	beq.n	4536 <getBusDividerConfig+0x112>
    44e2:	9b01      	ldr	r3, [sp, #4]
    44e4:	2b23      	cmp	r3, #35	; 0x23
    44e6:	d838      	bhi.n	455a <getBusDividerConfig+0x136>
    44e8:	9b01      	ldr	r3, [sp, #4]
    44ea:	2b21      	cmp	r3, #33	; 0x21
    44ec:	d003      	beq.n	44f6 <getBusDividerConfig+0xd2>
    44ee:	9b01      	ldr	r3, [sp, #4]
    44f0:	2b22      	cmp	r3, #34	; 0x22
    44f2:	d010      	beq.n	4516 <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    44f4:	e031      	b.n	455a <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    44f6:	4b1d      	ldr	r3, [pc, #116]	; (456c <getBusDividerConfig+0x148>)
    44f8:	695b      	ldr	r3, [r3, #20]
    44fa:	091b      	lsrs	r3, r3, #4
    44fc:	f003 030f 	and.w	r3, r3, #15
    4500:	1c59      	adds	r1, r3, #1
    4502:	4819      	ldr	r0, [pc, #100]	; (4568 <getBusDividerConfig+0x144>)
    4504:	9a04      	ldr	r2, [sp, #16]
    4506:	4613      	mov	r3, r2
    4508:	005b      	lsls	r3, r3, #1
    450a:	4413      	add	r3, r2
    450c:	009b      	lsls	r3, r3, #2
    450e:	4403      	add	r3, r0
    4510:	3304      	adds	r3, #4
    4512:	6019      	str	r1, [r3, #0]
                break;
    4514:	e022      	b.n	455c <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    4516:	4b15      	ldr	r3, [pc, #84]	; (456c <getBusDividerConfig+0x148>)
    4518:	699b      	ldr	r3, [r3, #24]
    451a:	091b      	lsrs	r3, r3, #4
    451c:	f003 030f 	and.w	r3, r3, #15
    4520:	1c59      	adds	r1, r3, #1
    4522:	4811      	ldr	r0, [pc, #68]	; (4568 <getBusDividerConfig+0x144>)
    4524:	9a04      	ldr	r2, [sp, #16]
    4526:	4613      	mov	r3, r2
    4528:	005b      	lsls	r3, r3, #1
    452a:	4413      	add	r3, r2
    452c:	009b      	lsls	r3, r3, #2
    452e:	4403      	add	r3, r0
    4530:	3304      	adds	r3, #4
    4532:	6019      	str	r1, [r3, #0]
                break;
    4534:	e012      	b.n	455c <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    4536:	4b0d      	ldr	r3, [pc, #52]	; (456c <getBusDividerConfig+0x148>)
    4538:	69db      	ldr	r3, [r3, #28]
    453a:	091b      	lsrs	r3, r3, #4
    453c:	f003 030f 	and.w	r3, r3, #15
    4540:	1c59      	adds	r1, r3, #1
    4542:	4809      	ldr	r0, [pc, #36]	; (4568 <getBusDividerConfig+0x144>)
    4544:	9a04      	ldr	r2, [sp, #16]
    4546:	4613      	mov	r3, r2
    4548:	005b      	lsls	r3, r3, #1
    454a:	4413      	add	r3, r2
    454c:	009b      	lsls	r3, r3, #2
    454e:	4403      	add	r3, r0
    4550:	3304      	adds	r3, #4
    4552:	6019      	str	r1, [r3, #0]
                break;
    4554:	e002      	b.n	455c <getBusDividerConfig+0x138>
        }
    }
    4556:	bf00      	nop
    4558:	e000      	b.n	455c <getBusDividerConfig+0x138>
                break;
    455a:	bf00      	nop

    return ReturnValue;
    455c:	9b05      	ldr	r3, [sp, #20]
}
    455e:	4618      	mov	r0, r3
    4560:	b006      	add	sp, #24
    4562:	4770      	bx	lr
    4564:	1fff8ba8 	.word	0x1fff8ba8
    4568:	1fff8c98 	.word	0x1fff8c98
    456c:	40064000 	.word	0x40064000

00004570 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    4570:	b086      	sub	sp, #24
    4572:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4574:	2300      	movs	r3, #0
    4576:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4578:	2300      	movs	r3, #0
    457a:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    457c:	9b01      	ldr	r3, [sp, #4]
    457e:	2b27      	cmp	r3, #39	; 0x27
    4580:	d00f      	beq.n	45a2 <getSlowDividerConfig+0x32>
    4582:	9b01      	ldr	r3, [sp, #4]
    4584:	2b27      	cmp	r3, #39	; 0x27
    4586:	d80f      	bhi.n	45a8 <getSlowDividerConfig+0x38>
    4588:	9b01      	ldr	r3, [sp, #4]
    458a:	2b25      	cmp	r3, #37	; 0x25
    458c:	d003      	beq.n	4596 <getSlowDividerConfig+0x26>
    458e:	9b01      	ldr	r3, [sp, #4]
    4590:	2b26      	cmp	r3, #38	; 0x26
    4592:	d003      	beq.n	459c <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4594:	e008      	b.n	45a8 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    4596:	2300      	movs	r3, #0
    4598:	9304      	str	r3, [sp, #16]
            break;
    459a:	e006      	b.n	45aa <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    459c:	2301      	movs	r3, #1
    459e:	9304      	str	r3, [sp, #16]
            break;
    45a0:	e003      	b.n	45aa <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    45a2:	2302      	movs	r3, #2
    45a4:	9304      	str	r3, [sp, #16]
            break;
    45a6:	e000      	b.n	45aa <getSlowDividerConfig+0x3a>
                break;
    45a8:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    45aa:	4b40      	ldr	r3, [pc, #256]	; (46ac <getSlowDividerConfig+0x13c>)
    45ac:	681b      	ldr	r3, [r3, #0]
    45ae:	2b00      	cmp	r3, #0
    45b0:	d026      	beq.n	4600 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    45b2:	2300      	movs	r3, #0
    45b4:	9303      	str	r3, [sp, #12]
    45b6:	e01c      	b.n	45f2 <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    45b8:	4b3c      	ldr	r3, [pc, #240]	; (46ac <getSlowDividerConfig+0x13c>)
    45ba:	6819      	ldr	r1, [r3, #0]
    45bc:	9a03      	ldr	r2, [sp, #12]
    45be:	4613      	mov	r3, r2
    45c0:	005b      	lsls	r3, r3, #1
    45c2:	4413      	add	r3, r2
    45c4:	009b      	lsls	r3, r3, #2
    45c6:	440b      	add	r3, r1
    45c8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    45cc:	681b      	ldr	r3, [r3, #0]
    45ce:	9a01      	ldr	r2, [sp, #4]
    45d0:	429a      	cmp	r2, r3
    45d2:	d10b      	bne.n	45ec <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    45d4:	4b35      	ldr	r3, [pc, #212]	; (46ac <getSlowDividerConfig+0x13c>)
    45d6:	6819      	ldr	r1, [r3, #0]
    45d8:	9a03      	ldr	r2, [sp, #12]
    45da:	4613      	mov	r3, r2
    45dc:	005b      	lsls	r3, r3, #1
    45de:	4413      	add	r3, r2
    45e0:	009b      	lsls	r3, r3, #2
    45e2:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    45e6:	440b      	add	r3, r1
    45e8:	9305      	str	r3, [sp, #20]
                break;
    45ea:	e009      	b.n	4600 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    45ec:	9b03      	ldr	r3, [sp, #12]
    45ee:	3301      	adds	r3, #1
    45f0:	9303      	str	r3, [sp, #12]
    45f2:	4b2e      	ldr	r3, [pc, #184]	; (46ac <getSlowDividerConfig+0x13c>)
    45f4:	681b      	ldr	r3, [r3, #0]
    45f6:	7b1b      	ldrb	r3, [r3, #12]
    45f8:	461a      	mov	r2, r3
    45fa:	9b03      	ldr	r3, [sp, #12]
    45fc:	4293      	cmp	r3, r2
    45fe:	d3db      	bcc.n	45b8 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4600:	9b05      	ldr	r3, [sp, #20]
    4602:	2b00      	cmp	r3, #0
    4604:	d14a      	bne.n	469c <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    4606:	9a04      	ldr	r2, [sp, #16]
    4608:	4613      	mov	r3, r2
    460a:	005b      	lsls	r3, r3, #1
    460c:	4413      	add	r3, r2
    460e:	009b      	lsls	r3, r3, #2
    4610:	4a27      	ldr	r2, [pc, #156]	; (46b0 <getSlowDividerConfig+0x140>)
    4612:	4413      	add	r3, r2
    4614:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    4616:	4926      	ldr	r1, [pc, #152]	; (46b0 <getSlowDividerConfig+0x140>)
    4618:	9a04      	ldr	r2, [sp, #16]
    461a:	4613      	mov	r3, r2
    461c:	005b      	lsls	r3, r3, #1
    461e:	4413      	add	r3, r2
    4620:	009b      	lsls	r3, r3, #2
    4622:	440b      	add	r3, r1
    4624:	9a01      	ldr	r2, [sp, #4]
    4626:	601a      	str	r2, [r3, #0]
        switch(Name)
    4628:	9b01      	ldr	r3, [sp, #4]
    462a:	2b27      	cmp	r3, #39	; 0x27
    462c:	d027      	beq.n	467e <getSlowDividerConfig+0x10e>
    462e:	9b01      	ldr	r3, [sp, #4]
    4630:	2b27      	cmp	r3, #39	; 0x27
    4632:	d835      	bhi.n	46a0 <getSlowDividerConfig+0x130>
    4634:	9b01      	ldr	r3, [sp, #4]
    4636:	2b25      	cmp	r3, #37	; 0x25
    4638:	d003      	beq.n	4642 <getSlowDividerConfig+0xd2>
    463a:	9b01      	ldr	r3, [sp, #4]
    463c:	2b26      	cmp	r3, #38	; 0x26
    463e:	d00f      	beq.n	4660 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4640:	e02e      	b.n	46a0 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    4642:	4b1c      	ldr	r3, [pc, #112]	; (46b4 <getSlowDividerConfig+0x144>)
    4644:	695b      	ldr	r3, [r3, #20]
    4646:	f003 030f 	and.w	r3, r3, #15
    464a:	1c59      	adds	r1, r3, #1
    464c:	4818      	ldr	r0, [pc, #96]	; (46b0 <getSlowDividerConfig+0x140>)
    464e:	9a04      	ldr	r2, [sp, #16]
    4650:	4613      	mov	r3, r2
    4652:	005b      	lsls	r3, r3, #1
    4654:	4413      	add	r3, r2
    4656:	009b      	lsls	r3, r3, #2
    4658:	4403      	add	r3, r0
    465a:	3304      	adds	r3, #4
    465c:	6019      	str	r1, [r3, #0]
                break;
    465e:	e020      	b.n	46a2 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    4660:	4b14      	ldr	r3, [pc, #80]	; (46b4 <getSlowDividerConfig+0x144>)
    4662:	699b      	ldr	r3, [r3, #24]
    4664:	f003 030f 	and.w	r3, r3, #15
    4668:	1c59      	adds	r1, r3, #1
    466a:	4811      	ldr	r0, [pc, #68]	; (46b0 <getSlowDividerConfig+0x140>)
    466c:	9a04      	ldr	r2, [sp, #16]
    466e:	4613      	mov	r3, r2
    4670:	005b      	lsls	r3, r3, #1
    4672:	4413      	add	r3, r2
    4674:	009b      	lsls	r3, r3, #2
    4676:	4403      	add	r3, r0
    4678:	3304      	adds	r3, #4
    467a:	6019      	str	r1, [r3, #0]
                break;
    467c:	e011      	b.n	46a2 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    467e:	4b0d      	ldr	r3, [pc, #52]	; (46b4 <getSlowDividerConfig+0x144>)
    4680:	69db      	ldr	r3, [r3, #28]
    4682:	f003 030f 	and.w	r3, r3, #15
    4686:	1c59      	adds	r1, r3, #1
    4688:	4809      	ldr	r0, [pc, #36]	; (46b0 <getSlowDividerConfig+0x140>)
    468a:	9a04      	ldr	r2, [sp, #16]
    468c:	4613      	mov	r3, r2
    468e:	005b      	lsls	r3, r3, #1
    4690:	4413      	add	r3, r2
    4692:	009b      	lsls	r3, r3, #2
    4694:	4403      	add	r3, r0
    4696:	3304      	adds	r3, #4
    4698:	6019      	str	r1, [r3, #0]
                break;
    469a:	e002      	b.n	46a2 <getSlowDividerConfig+0x132>
        }
    }
    469c:	bf00      	nop
    469e:	e000      	b.n	46a2 <getSlowDividerConfig+0x132>
                break;
    46a0:	bf00      	nop

    return ReturnValue;
    46a2:	9b05      	ldr	r3, [sp, #20]
}
    46a4:	4618      	mov	r0, r3
    46a6:	b006      	add	sp, #24
    46a8:	4770      	bx	lr
    46aa:	bf00      	nop
    46ac:	1fff8ba8 	.word	0x1fff8ba8
    46b0:	1fff8cbc 	.word	0x1fff8cbc
    46b4:	40064000 	.word	0x40064000

000046b8 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    46b8:	b500      	push	{lr}
    46ba:	b083      	sub	sp, #12
    46bc:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    46be:	4b64      	ldr	r3, [pc, #400]	; (4850 <Clock_Ip_ClockInitializeObjects+0x198>)
    46c0:	781b      	ldrb	r3, [r3, #0]
    46c2:	f083 0301 	eor.w	r3, r3, #1
    46c6:	b2db      	uxtb	r3, r3
    46c8:	2b00      	cmp	r3, #0
    46ca:	d05b      	beq.n	4784 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    46cc:	4b60      	ldr	r3, [pc, #384]	; (4850 <Clock_Ip_ClockInitializeObjects+0x198>)
    46ce:	2201      	movs	r2, #1
    46d0:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    46d2:	4b60      	ldr	r3, [pc, #384]	; (4854 <Clock_Ip_ClockInitializeObjects+0x19c>)
    46d4:	785b      	ldrb	r3, [r3, #1]
    46d6:	461a      	mov	r2, r3
    46d8:	4613      	mov	r3, r2
    46da:	009b      	lsls	r3, r3, #2
    46dc:	4413      	add	r3, r2
    46de:	009b      	lsls	r3, r3, #2
    46e0:	4a5d      	ldr	r2, [pc, #372]	; (4858 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    46e2:	4413      	add	r3, r2
    46e4:	4a5d      	ldr	r2, [pc, #372]	; (485c <Clock_Ip_ClockInitializeObjects+0x1a4>)
    46e6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    46e8:	4b5d      	ldr	r3, [pc, #372]	; (4860 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    46ea:	785b      	ldrb	r3, [r3, #1]
    46ec:	461a      	mov	r2, r3
    46ee:	4613      	mov	r3, r2
    46f0:	009b      	lsls	r3, r3, #2
    46f2:	4413      	add	r3, r2
    46f4:	009b      	lsls	r3, r3, #2
    46f6:	4a5b      	ldr	r2, [pc, #364]	; (4864 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    46f8:	4413      	add	r3, r2
    46fa:	4a5b      	ldr	r2, [pc, #364]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    46fc:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    46fe:	4b5b      	ldr	r3, [pc, #364]	; (486c <Clock_Ip_ClockInitializeObjects+0x1b4>)
    4700:	791b      	ldrb	r3, [r3, #4]
    4702:	461a      	mov	r2, r3
    4704:	4613      	mov	r3, r2
    4706:	005b      	lsls	r3, r3, #1
    4708:	4413      	add	r3, r2
    470a:	009b      	lsls	r3, r3, #2
    470c:	4a58      	ldr	r2, [pc, #352]	; (4870 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    470e:	4413      	add	r3, r2
    4710:	4a58      	ldr	r2, [pc, #352]	; (4874 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    4712:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    4714:	4b58      	ldr	r3, [pc, #352]	; (4878 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    4716:	795b      	ldrb	r3, [r3, #5]
    4718:	00db      	lsls	r3, r3, #3
    471a:	4a58      	ldr	r2, [pc, #352]	; (487c <Clock_Ip_ClockInitializeObjects+0x1c4>)
    471c:	4413      	add	r3, r2
    471e:	4a58      	ldr	r2, [pc, #352]	; (4880 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    4720:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    4722:	4b55      	ldr	r3, [pc, #340]	; (4878 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    4724:	79db      	ldrb	r3, [r3, #7]
    4726:	00db      	lsls	r3, r3, #3
    4728:	4a54      	ldr	r2, [pc, #336]	; (487c <Clock_Ip_ClockInitializeObjects+0x1c4>)
    472a:	4413      	add	r3, r2
    472c:	4a55      	ldr	r2, [pc, #340]	; (4884 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    472e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    4730:	4b55      	ldr	r3, [pc, #340]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4732:	799b      	ldrb	r3, [r3, #6]
    4734:	009b      	lsls	r3, r3, #2
    4736:	4a55      	ldr	r2, [pc, #340]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4738:	4413      	add	r3, r2
    473a:	4a55      	ldr	r2, [pc, #340]	; (4890 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    473c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    473e:	4b52      	ldr	r3, [pc, #328]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4740:	7a1b      	ldrb	r3, [r3, #8]
    4742:	009b      	lsls	r3, r3, #2
    4744:	4a51      	ldr	r2, [pc, #324]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4746:	4413      	add	r3, r2
    4748:	4a52      	ldr	r2, [pc, #328]	; (4894 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    474a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    474c:	4b4e      	ldr	r3, [pc, #312]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    474e:	7a5b      	ldrb	r3, [r3, #9]
    4750:	009b      	lsls	r3, r3, #2
    4752:	4a4e      	ldr	r2, [pc, #312]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4754:	4413      	add	r3, r2
    4756:	4a50      	ldr	r2, [pc, #320]	; (4898 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    4758:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    475a:	4b4b      	ldr	r3, [pc, #300]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    475c:	7adb      	ldrb	r3, [r3, #11]
    475e:	009b      	lsls	r3, r3, #2
    4760:	4a4a      	ldr	r2, [pc, #296]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4762:	4413      	add	r3, r2
    4764:	4a4d      	ldr	r2, [pc, #308]	; (489c <Clock_Ip_ClockInitializeObjects+0x1e4>)
    4766:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    4768:	4b47      	ldr	r3, [pc, #284]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    476a:	7b1b      	ldrb	r3, [r3, #12]
    476c:	009b      	lsls	r3, r3, #2
    476e:	4a47      	ldr	r2, [pc, #284]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4770:	4413      	add	r3, r2
    4772:	4a4b      	ldr	r2, [pc, #300]	; (48a0 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    4774:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    4776:	4b44      	ldr	r3, [pc, #272]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4778:	7b9b      	ldrb	r3, [r3, #14]
    477a:	009b      	lsls	r3, r3, #2
    477c:	4a43      	ldr	r2, [pc, #268]	; (488c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    477e:	4413      	add	r3, r2
    4780:	4a48      	ldr	r2, [pc, #288]	; (48a4 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    4782:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    4784:	4b48      	ldr	r3, [pc, #288]	; (48a8 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    4786:	781b      	ldrb	r3, [r3, #0]
    4788:	2b00      	cmp	r3, #0
    478a:	d002      	beq.n	4792 <Clock_Ip_ClockInitializeObjects+0xda>
    478c:	9b01      	ldr	r3, [sp, #4]
    478e:	2b00      	cmp	r3, #0
    4790:	d003      	beq.n	479a <Clock_Ip_ClockInitializeObjects+0xe2>
    4792:	4b46      	ldr	r3, [pc, #280]	; (48ac <Clock_Ip_ClockInitializeObjects+0x1f4>)
    4794:	781b      	ldrb	r3, [r3, #0]
    4796:	2b00      	cmp	r3, #0
    4798:	d056      	beq.n	4848 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    479a:	f7ff fc09 	bl	3fb0 <getFircConfig>
    479e:	4603      	mov	r3, r0
    47a0:	4a43      	ldr	r2, [pc, #268]	; (48b0 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    47a2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    47a4:	f7ff fc60 	bl	4068 <getSoscConfig>
    47a8:	4603      	mov	r3, r0
    47aa:	4a42      	ldr	r2, [pc, #264]	; (48b4 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    47ac:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    47ae:	f7ff fca7 	bl	4100 <getSpllConfig>
    47b2:	4603      	mov	r3, r0
    47b4:	4a40      	ldr	r2, [pc, #256]	; (48b8 <Clock_Ip_ClockInitializeObjects+0x200>)
    47b6:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    47b8:	2019      	movs	r0, #25
    47ba:	f7ff fcfb 	bl	41b4 <getSelectorConfig>
    47be:	4603      	mov	r3, r0
    47c0:	4a3e      	ldr	r2, [pc, #248]	; (48bc <Clock_Ip_ClockInitializeObjects+0x204>)
    47c2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    47c4:	201a      	movs	r0, #26
    47c6:	f7ff fcf5 	bl	41b4 <getSelectorConfig>
    47ca:	4603      	mov	r3, r0
    47cc:	4a3c      	ldr	r2, [pc, #240]	; (48c0 <Clock_Ip_ClockInitializeObjects+0x208>)
    47ce:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    47d0:	201b      	movs	r0, #27
    47d2:	f7ff fcef 	bl	41b4 <getSelectorConfig>
    47d6:	4603      	mov	r3, r0
    47d8:	4a3a      	ldr	r2, [pc, #232]	; (48c4 <Clock_Ip_ClockInitializeObjects+0x20c>)
    47da:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    47dc:	201d      	movs	r0, #29
    47de:	f7ff fd7b 	bl	42d8 <getCoreDividerConfig>
    47e2:	4603      	mov	r3, r0
    47e4:	4a38      	ldr	r2, [pc, #224]	; (48c8 <Clock_Ip_ClockInitializeObjects+0x210>)
    47e6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    47e8:	201e      	movs	r0, #30
    47ea:	f7ff fd75 	bl	42d8 <getCoreDividerConfig>
    47ee:	4603      	mov	r3, r0
    47f0:	4a36      	ldr	r2, [pc, #216]	; (48cc <Clock_Ip_ClockInitializeObjects+0x214>)
    47f2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    47f4:	201f      	movs	r0, #31
    47f6:	f7ff fd6f 	bl	42d8 <getCoreDividerConfig>
    47fa:	4603      	mov	r3, r0
    47fc:	4a34      	ldr	r2, [pc, #208]	; (48d0 <Clock_Ip_ClockInitializeObjects+0x218>)
    47fe:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    4800:	2021      	movs	r0, #33	; 0x21
    4802:	f7ff fe0f 	bl	4424 <getBusDividerConfig>
    4806:	4603      	mov	r3, r0
    4808:	4a32      	ldr	r2, [pc, #200]	; (48d4 <Clock_Ip_ClockInitializeObjects+0x21c>)
    480a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    480c:	2022      	movs	r0, #34	; 0x22
    480e:	f7ff fe09 	bl	4424 <getBusDividerConfig>
    4812:	4603      	mov	r3, r0
    4814:	4a30      	ldr	r2, [pc, #192]	; (48d8 <Clock_Ip_ClockInitializeObjects+0x220>)
    4816:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    4818:	2023      	movs	r0, #35	; 0x23
    481a:	f7ff fe03 	bl	4424 <getBusDividerConfig>
    481e:	4603      	mov	r3, r0
    4820:	4a2e      	ldr	r2, [pc, #184]	; (48dc <Clock_Ip_ClockInitializeObjects+0x224>)
    4822:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    4824:	2025      	movs	r0, #37	; 0x25
    4826:	f7ff fea3 	bl	4570 <getSlowDividerConfig>
    482a:	4603      	mov	r3, r0
    482c:	4a2c      	ldr	r2, [pc, #176]	; (48e0 <Clock_Ip_ClockInitializeObjects+0x228>)
    482e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    4830:	2026      	movs	r0, #38	; 0x26
    4832:	f7ff fe9d 	bl	4570 <getSlowDividerConfig>
    4836:	4603      	mov	r3, r0
    4838:	4a2a      	ldr	r2, [pc, #168]	; (48e4 <Clock_Ip_ClockInitializeObjects+0x22c>)
    483a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    483c:	2027      	movs	r0, #39	; 0x27
    483e:	f7ff fe97 	bl	4570 <getSlowDividerConfig>
    4842:	4603      	mov	r3, r0
    4844:	4a28      	ldr	r2, [pc, #160]	; (48e8 <Clock_Ip_ClockInitializeObjects+0x230>)
    4846:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    4848:	bf00      	nop
    484a:	b003      	add	sp, #12
    484c:	f85d fb04 	ldr.w	pc, [sp], #4
    4850:	1fff8ce0 	.word	0x1fff8ce0
    4854:	00009a94 	.word	0x00009a94
    4858:	0000a0e0 	.word	0x0000a0e0
    485c:	1fff8bac 	.word	0x1fff8bac
    4860:	00009a54 	.word	0x00009a54
    4864:	0000a028 	.word	0x0000a028
    4868:	1fff8bb0 	.word	0x1fff8bb0
    486c:	00009a64 	.word	0x00009a64
    4870:	0000a094 	.word	0x0000a094
    4874:	1fff8bb4 	.word	0x1fff8bb4
    4878:	00009aa4 	.word	0x00009aa4
    487c:	0000a10c 	.word	0x0000a10c
    4880:	1fff8bb8 	.word	0x1fff8bb8
    4884:	1fff8bf4 	.word	0x1fff8bf4
    4888:	00009a34 	.word	0x00009a34
    488c:	00009fe4 	.word	0x00009fe4
    4890:	1fff8bbc 	.word	0x1fff8bbc
    4894:	1fff8bf8 	.word	0x1fff8bf8
    4898:	1fff8bc0 	.word	0x1fff8bc0
    489c:	1fff8bfc 	.word	0x1fff8bfc
    48a0:	1fff8bc4 	.word	0x1fff8bc4
    48a4:	1fff8c00 	.word	0x1fff8c00
    48a8:	1fff8b21 	.word	0x1fff8b21
    48ac:	1fff8b1a 	.word	0x1fff8b1a
    48b0:	1fff8bc8 	.word	0x1fff8bc8
    48b4:	1fff8bcc 	.word	0x1fff8bcc
    48b8:	1fff8bd0 	.word	0x1fff8bd0
    48bc:	1fff8bd4 	.word	0x1fff8bd4
    48c0:	1fff8bd8 	.word	0x1fff8bd8
    48c4:	1fff8c04 	.word	0x1fff8c04
    48c8:	1fff8bdc 	.word	0x1fff8bdc
    48cc:	1fff8be0 	.word	0x1fff8be0
    48d0:	1fff8c08 	.word	0x1fff8c08
    48d4:	1fff8be4 	.word	0x1fff8be4
    48d8:	1fff8be8 	.word	0x1fff8be8
    48dc:	1fff8c0c 	.word	0x1fff8c0c
    48e0:	1fff8bec 	.word	0x1fff8bec
    48e4:	1fff8bf0 	.word	0x1fff8bf0
    48e8:	1fff8c10 	.word	0x1fff8c10

000048ec <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    48ec:	b500      	push	{lr}
    48ee:	b083      	sub	sp, #12
    48f0:	9001      	str	r0, [sp, #4]
    48f2:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    48f4:	9b01      	ldr	r3, [sp, #4]
    48f6:	2b03      	cmp	r3, #3
    48f8:	f000 8090 	beq.w	4a1c <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    48fc:	9b01      	ldr	r3, [sp, #4]
    48fe:	2b03      	cmp	r3, #3
    4900:	f200 80d3 	bhi.w	4aaa <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    4904:	9b01      	ldr	r3, [sp, #4]
    4906:	2b00      	cmp	r3, #0
    4908:	d040      	beq.n	498c <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    490a:	9b01      	ldr	r3, [sp, #4]
    490c:	3b01      	subs	r3, #1
    490e:	2b01      	cmp	r3, #1
    4910:	f200 80cb 	bhi.w	4aaa <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    4914:	9b00      	ldr	r3, [sp, #0]
    4916:	2b00      	cmp	r3, #0
    4918:	f040 80c9 	bne.w	4aae <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    491c:	4b68      	ldr	r3, [pc, #416]	; (4ac0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    491e:	2200      	movs	r2, #0
    4920:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    4922:	4b68      	ldr	r3, [pc, #416]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    4924:	681b      	ldr	r3, [r3, #0]
    4926:	685b      	ldr	r3, [r3, #4]
    4928:	4a67      	ldr	r2, [pc, #412]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    492a:	6812      	ldr	r2, [r2, #0]
    492c:	4610      	mov	r0, r2
    492e:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    4930:	4b66      	ldr	r3, [pc, #408]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    4932:	681b      	ldr	r3, [r3, #0]
    4934:	681b      	ldr	r3, [r3, #0]
    4936:	4a66      	ldr	r2, [pc, #408]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    4938:	6812      	ldr	r2, [r2, #0]
    493a:	4610      	mov	r0, r2
    493c:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    493e:	4b65      	ldr	r3, [pc, #404]	; (4ad4 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    4940:	681b      	ldr	r3, [r3, #0]
    4942:	681b      	ldr	r3, [r3, #0]
    4944:	4a64      	ldr	r2, [pc, #400]	; (4ad8 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    4946:	6812      	ldr	r2, [r2, #0]
    4948:	4610      	mov	r0, r2
    494a:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    494c:	4b63      	ldr	r3, [pc, #396]	; (4adc <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    494e:	681b      	ldr	r3, [r3, #0]
    4950:	681b      	ldr	r3, [r3, #0]
    4952:	4a63      	ldr	r2, [pc, #396]	; (4ae0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    4954:	6812      	ldr	r2, [r2, #0]
    4956:	4610      	mov	r0, r2
    4958:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    495a:	4b62      	ldr	r3, [pc, #392]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    495c:	681b      	ldr	r3, [r3, #0]
    495e:	691b      	ldr	r3, [r3, #16]
    4960:	4a61      	ldr	r2, [pc, #388]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4962:	6812      	ldr	r2, [r2, #0]
    4964:	6812      	ldr	r2, [r2, #0]
    4966:	4610      	mov	r0, r2
    4968:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    496a:	4b60      	ldr	r3, [pc, #384]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    496c:	681b      	ldr	r3, [r3, #0]
    496e:	68db      	ldr	r3, [r3, #12]
    4970:	4a5f      	ldr	r2, [pc, #380]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4972:	6812      	ldr	r2, [r2, #0]
    4974:	6812      	ldr	r2, [r2, #0]
    4976:	4610      	mov	r0, r2
    4978:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    497a:	4b5e      	ldr	r3, [pc, #376]	; (4af4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    497c:	681b      	ldr	r3, [r3, #0]
    497e:	689b      	ldr	r3, [r3, #8]
    4980:	4a5d      	ldr	r2, [pc, #372]	; (4af8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    4982:	6812      	ldr	r2, [r2, #0]
    4984:	6812      	ldr	r2, [r2, #0]
    4986:	4610      	mov	r0, r2
    4988:	4798      	blx	r3
            }
        }
        break;
    498a:	e090      	b.n	4aae <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    498c:	9b00      	ldr	r3, [sp, #0]
    498e:	2b02      	cmp	r3, #2
    4990:	f040 808f 	bne.w	4ab2 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    4994:	4b4a      	ldr	r3, [pc, #296]	; (4ac0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    4996:	2201      	movs	r2, #1
    4998:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    499a:	4b56      	ldr	r3, [pc, #344]	; (4af4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    499c:	681b      	ldr	r3, [r3, #0]
    499e:	685b      	ldr	r3, [r3, #4]
    49a0:	4a55      	ldr	r2, [pc, #340]	; (4af8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    49a2:	6812      	ldr	r2, [r2, #0]
    49a4:	4610      	mov	r0, r2
    49a6:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    49a8:	4b50      	ldr	r3, [pc, #320]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    49aa:	681b      	ldr	r3, [r3, #0]
    49ac:	691b      	ldr	r3, [r3, #16]
    49ae:	4a50      	ldr	r2, [pc, #320]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    49b0:	6812      	ldr	r2, [r2, #0]
    49b2:	4610      	mov	r0, r2
    49b4:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    49b6:	4b4d      	ldr	r3, [pc, #308]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    49b8:	681b      	ldr	r3, [r3, #0]
    49ba:	689b      	ldr	r3, [r3, #8]
    49bc:	4a4c      	ldr	r2, [pc, #304]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    49be:	6812      	ldr	r2, [r2, #0]
    49c0:	4610      	mov	r0, r2
    49c2:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    49c4:	4b47      	ldr	r3, [pc, #284]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    49c6:	681b      	ldr	r3, [r3, #0]
    49c8:	68db      	ldr	r3, [r3, #12]
    49ca:	4a47      	ldr	r2, [pc, #284]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    49cc:	6812      	ldr	r2, [r2, #0]
    49ce:	4610      	mov	r0, r2
    49d0:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    49d2:	4b44      	ldr	r3, [pc, #272]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    49d4:	681b      	ldr	r3, [r3, #0]
    49d6:	689b      	ldr	r3, [r3, #8]
    49d8:	4a43      	ldr	r2, [pc, #268]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    49da:	6812      	ldr	r2, [r2, #0]
    49dc:	6812      	ldr	r2, [r2, #0]
    49de:	4610      	mov	r0, r2
    49e0:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    49e2:	4b38      	ldr	r3, [pc, #224]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    49e4:	681b      	ldr	r3, [r3, #0]
    49e6:	685b      	ldr	r3, [r3, #4]
    49e8:	4a44      	ldr	r2, [pc, #272]	; (4afc <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    49ea:	6812      	ldr	r2, [r2, #0]
    49ec:	4610      	mov	r0, r2
    49ee:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    49f0:	4b36      	ldr	r3, [pc, #216]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    49f2:	681b      	ldr	r3, [r3, #0]
    49f4:	681b      	ldr	r3, [r3, #0]
    49f6:	4a42      	ldr	r2, [pc, #264]	; (4b00 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    49f8:	6812      	ldr	r2, [r2, #0]
    49fa:	4610      	mov	r0, r2
    49fc:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    49fe:	4b35      	ldr	r3, [pc, #212]	; (4ad4 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    4a00:	681b      	ldr	r3, [r3, #0]
    4a02:	681b      	ldr	r3, [r3, #0]
    4a04:	4a3f      	ldr	r2, [pc, #252]	; (4b04 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    4a06:	6812      	ldr	r2, [r2, #0]
    4a08:	4610      	mov	r0, r2
    4a0a:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    4a0c:	4b33      	ldr	r3, [pc, #204]	; (4adc <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    4a0e:	681b      	ldr	r3, [r3, #0]
    4a10:	681b      	ldr	r3, [r3, #0]
    4a12:	4a3d      	ldr	r2, [pc, #244]	; (4b08 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    4a14:	6812      	ldr	r2, [r2, #0]
    4a16:	4610      	mov	r0, r2
    4a18:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    4a1a:	e04a      	b.n	4ab2 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    4a1c:	9b00      	ldr	r3, [sp, #0]
    4a1e:	2b02      	cmp	r3, #2
    4a20:	d149      	bne.n	4ab6 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    4a22:	4b27      	ldr	r3, [pc, #156]	; (4ac0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    4a24:	2201      	movs	r2, #1
    4a26:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    4a28:	4b32      	ldr	r3, [pc, #200]	; (4af4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4a2a:	681b      	ldr	r3, [r3, #0]
    4a2c:	685b      	ldr	r3, [r3, #4]
    4a2e:	4a32      	ldr	r2, [pc, #200]	; (4af8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    4a30:	6812      	ldr	r2, [r2, #0]
    4a32:	4610      	mov	r0, r2
    4a34:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    4a36:	4b2d      	ldr	r3, [pc, #180]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4a38:	681b      	ldr	r3, [r3, #0]
    4a3a:	691b      	ldr	r3, [r3, #16]
    4a3c:	4a2c      	ldr	r2, [pc, #176]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4a3e:	6812      	ldr	r2, [r2, #0]
    4a40:	4610      	mov	r0, r2
    4a42:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    4a44:	4b29      	ldr	r3, [pc, #164]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4a46:	681b      	ldr	r3, [r3, #0]
    4a48:	689b      	ldr	r3, [r3, #8]
    4a4a:	4a29      	ldr	r2, [pc, #164]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4a4c:	6812      	ldr	r2, [r2, #0]
    4a4e:	4610      	mov	r0, r2
    4a50:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    4a52:	4b24      	ldr	r3, [pc, #144]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4a54:	681b      	ldr	r3, [r3, #0]
    4a56:	68db      	ldr	r3, [r3, #12]
    4a58:	4a23      	ldr	r2, [pc, #140]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4a5a:	6812      	ldr	r2, [r2, #0]
    4a5c:	4610      	mov	r0, r2
    4a5e:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    4a60:	4b20      	ldr	r3, [pc, #128]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4a62:	681b      	ldr	r3, [r3, #0]
    4a64:	689b      	ldr	r3, [r3, #8]
    4a66:	4a20      	ldr	r2, [pc, #128]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4a68:	6812      	ldr	r2, [r2, #0]
    4a6a:	6812      	ldr	r2, [r2, #0]
    4a6c:	4610      	mov	r0, r2
    4a6e:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    4a70:	4b26      	ldr	r3, [pc, #152]	; (4b0c <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    4a72:	681b      	ldr	r3, [r3, #0]
    4a74:	685b      	ldr	r3, [r3, #4]
    4a76:	4a26      	ldr	r2, [pc, #152]	; (4b10 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    4a78:	6812      	ldr	r2, [r2, #0]
    4a7a:	4610      	mov	r0, r2
    4a7c:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    4a7e:	4b25      	ldr	r3, [pc, #148]	; (4b14 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    4a80:	681b      	ldr	r3, [r3, #0]
    4a82:	681b      	ldr	r3, [r3, #0]
    4a84:	4a24      	ldr	r2, [pc, #144]	; (4b18 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    4a86:	6812      	ldr	r2, [r2, #0]
    4a88:	4610      	mov	r0, r2
    4a8a:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    4a8c:	4b23      	ldr	r3, [pc, #140]	; (4b1c <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    4a8e:	681b      	ldr	r3, [r3, #0]
    4a90:	681b      	ldr	r3, [r3, #0]
    4a92:	4a23      	ldr	r2, [pc, #140]	; (4b20 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    4a94:	6812      	ldr	r2, [r2, #0]
    4a96:	4610      	mov	r0, r2
    4a98:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    4a9a:	4b22      	ldr	r3, [pc, #136]	; (4b24 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    4a9c:	681b      	ldr	r3, [r3, #0]
    4a9e:	681b      	ldr	r3, [r3, #0]
    4aa0:	4a21      	ldr	r2, [pc, #132]	; (4b28 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    4aa2:	6812      	ldr	r2, [r2, #0]
    4aa4:	4610      	mov	r0, r2
    4aa6:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    4aa8:	e005      	b.n	4ab6 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    4aaa:	bf00      	nop
    4aac:	e004      	b.n	4ab8 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4aae:	bf00      	nop
    4ab0:	e002      	b.n	4ab8 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4ab2:	bf00      	nop
    4ab4:	e000      	b.n	4ab8 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4ab6:	bf00      	nop
    }

}
    4ab8:	bf00      	nop
    4aba:	b003      	add	sp, #12
    4abc:	f85d fb04 	ldr.w	pc, [sp], #4
    4ac0:	1fff8b21 	.word	0x1fff8b21
    4ac4:	1fff8bb8 	.word	0x1fff8bb8
    4ac8:	1fff8bd8 	.word	0x1fff8bd8
    4acc:	1fff8bbc 	.word	0x1fff8bbc
    4ad0:	1fff8be0 	.word	0x1fff8be0
    4ad4:	1fff8bc0 	.word	0x1fff8bc0
    4ad8:	1fff8be8 	.word	0x1fff8be8
    4adc:	1fff8bc4 	.word	0x1fff8bc4
    4ae0:	1fff8bf0 	.word	0x1fff8bf0
    4ae4:	1fff8bac 	.word	0x1fff8bac
    4ae8:	1fff8bd0 	.word	0x1fff8bd0
    4aec:	1fff8bb0 	.word	0x1fff8bb0
    4af0:	1fff8bcc 	.word	0x1fff8bcc
    4af4:	1fff8bb4 	.word	0x1fff8bb4
    4af8:	1fff8bc8 	.word	0x1fff8bc8
    4afc:	1fff8bd4 	.word	0x1fff8bd4
    4b00:	1fff8bdc 	.word	0x1fff8bdc
    4b04:	1fff8be4 	.word	0x1fff8be4
    4b08:	1fff8bec 	.word	0x1fff8bec
    4b0c:	1fff8bf4 	.word	0x1fff8bf4
    4b10:	1fff8c04 	.word	0x1fff8c04
    4b14:	1fff8bf8 	.word	0x1fff8bf8
    4b18:	1fff8c08 	.word	0x1fff8c08
    4b1c:	1fff8bfc 	.word	0x1fff8bfc
    4b20:	1fff8c0c 	.word	0x1fff8c0c
    4b24:	1fff8c00 	.word	0x1fff8c00
    4b28:	1fff8c10 	.word	0x1fff8c10

00004b2c <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    4b2c:	b500      	push	{lr}
    4b2e:	b083      	sub	sp, #12
    4b30:	9001      	str	r0, [sp, #4]
    4b32:	9100      	str	r1, [sp, #0]
    switch(Command)
    4b34:	9b00      	ldr	r3, [sp, #0]
    4b36:	2b04      	cmp	r3, #4
    4b38:	d010      	beq.n	4b5c <Clock_Ip_Command+0x30>
    4b3a:	9b00      	ldr	r3, [sp, #0]
    4b3c:	2b04      	cmp	r3, #4
    4b3e:	d811      	bhi.n	4b64 <Clock_Ip_Command+0x38>
    4b40:	9b00      	ldr	r3, [sp, #0]
    4b42:	2b01      	cmp	r3, #1
    4b44:	d006      	beq.n	4b54 <Clock_Ip_Command+0x28>
    4b46:	9b00      	ldr	r3, [sp, #0]
    4b48:	2b02      	cmp	r3, #2
    4b4a:	d10b      	bne.n	4b64 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    4b4c:	9801      	ldr	r0, [sp, #4]
    4b4e:	f7ff fdb3 	bl	46b8 <Clock_Ip_ClockInitializeObjects>
            break;
    4b52:	e008      	b.n	4b66 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    4b54:	9801      	ldr	r0, [sp, #4]
    4b56:	f7ff f9db 	bl	3f10 <Clock_Ip_SpecificPlatformInitClock>
            break;
    4b5a:	e004      	b.n	4b66 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    4b5c:	9801      	ldr	r0, [sp, #4]
    4b5e:	f7ff f8ed 	bl	3d3c <DisableSafeClock>
            break;
    4b62:	e000      	b.n	4b66 <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    4b64:	bf00      	nop
    }
}
    4b66:	bf00      	nop
    4b68:	b003      	add	sp, #12
    4b6a:	f85d fb04 	ldr.w	pc, [sp], #4
    4b6e:	bf00      	nop

00004b70 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    4b70:	b500      	push	{lr}
    4b72:	b085      	sub	sp, #20
    4b74:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    4b76:	4a20      	ldr	r2, [pc, #128]	; (4bf8 <Mcu_Init+0x88>)
    4b78:	9b01      	ldr	r3, [sp, #4]
    4b7a:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4b7c:	2300      	movs	r3, #0
    4b7e:	9303      	str	r3, [sp, #12]
    4b80:	e010      	b.n	4ba4 <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    4b82:	4b1d      	ldr	r3, [pc, #116]	; (4bf8 <Mcu_Init+0x88>)
    4b84:	681b      	ldr	r3, [r3, #0]
    4b86:	6919      	ldr	r1, [r3, #16]
    4b88:	9a03      	ldr	r2, [sp, #12]
    4b8a:	4613      	mov	r3, r2
    4b8c:	005b      	lsls	r3, r3, #1
    4b8e:	4413      	add	r3, r2
    4b90:	009b      	lsls	r3, r3, #2
    4b92:	440b      	add	r3, r1
    4b94:	681b      	ldr	r3, [r3, #0]
    4b96:	9a03      	ldr	r2, [sp, #12]
    4b98:	b2d1      	uxtb	r1, r2
    4b9a:	4a18      	ldr	r2, [pc, #96]	; (4bfc <Mcu_Init+0x8c>)
    4b9c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4b9e:	9b03      	ldr	r3, [sp, #12]
    4ba0:	3301      	adds	r3, #1
    4ba2:	9303      	str	r3, [sp, #12]
    4ba4:	4b14      	ldr	r3, [pc, #80]	; (4bf8 <Mcu_Init+0x88>)
    4ba6:	681b      	ldr	r3, [r3, #0]
    4ba8:	689b      	ldr	r3, [r3, #8]
    4baa:	9a03      	ldr	r2, [sp, #12]
    4bac:	429a      	cmp	r2, r3
    4bae:	d3e8      	bcc.n	4b82 <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    4bb0:	2300      	movs	r3, #0
    4bb2:	9303      	str	r3, [sp, #12]
    4bb4:	e010      	b.n	4bd8 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    4bb6:	4b10      	ldr	r3, [pc, #64]	; (4bf8 <Mcu_Init+0x88>)
    4bb8:	681b      	ldr	r3, [r3, #0]
    4bba:	6959      	ldr	r1, [r3, #20]
    4bbc:	9a03      	ldr	r2, [sp, #12]
    4bbe:	4613      	mov	r3, r2
    4bc0:	01db      	lsls	r3, r3, #7
    4bc2:	1a9b      	subs	r3, r3, r2
    4bc4:	00db      	lsls	r3, r3, #3
    4bc6:	440b      	add	r3, r1
    4bc8:	681b      	ldr	r3, [r3, #0]
    4bca:	9a03      	ldr	r2, [sp, #12]
    4bcc:	b2d1      	uxtb	r1, r2
    4bce:	4a0c      	ldr	r2, [pc, #48]	; (4c00 <Mcu_Init+0x90>)
    4bd0:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    4bd2:	9b03      	ldr	r3, [sp, #12]
    4bd4:	3301      	adds	r3, #1
    4bd6:	9303      	str	r3, [sp, #12]
    4bd8:	4b07      	ldr	r3, [pc, #28]	; (4bf8 <Mcu_Init+0x88>)
    4bda:	681b      	ldr	r3, [r3, #0]
    4bdc:	68db      	ldr	r3, [r3, #12]
    4bde:	9a03      	ldr	r2, [sp, #12]
    4be0:	429a      	cmp	r2, r3
    4be2:	d3e8      	bcc.n	4bb6 <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    4be4:	4b04      	ldr	r3, [pc, #16]	; (4bf8 <Mcu_Init+0x88>)
    4be6:	681b      	ldr	r3, [r3, #0]
    4be8:	699b      	ldr	r3, [r3, #24]
    4bea:	4618      	mov	r0, r3
    4bec:	f000 f88a 	bl	4d04 <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4bf0:	bf00      	nop
    4bf2:	b005      	add	sp, #20
    4bf4:	f85d fb04 	ldr.w	pc, [sp], #4
    4bf8:	1fff8cec 	.word	0x1fff8cec
    4bfc:	1fff8ce8 	.word	0x1fff8ce8
    4c00:	1fff8ce4 	.word	0x1fff8ce4

00004c04 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    4c04:	b084      	sub	sp, #16
    4c06:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    4c08:	2301      	movs	r3, #1
    4c0a:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    4c0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    4c12:	4618      	mov	r0, r3
    4c14:	b004      	add	sp, #16
    4c16:	4770      	bx	lr

00004c18 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    4c18:	b500      	push	{lr}
    4c1a:	b085      	sub	sp, #20
    4c1c:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    4c1e:	4a0e      	ldr	r2, [pc, #56]	; (4c58 <Mcu_InitClock+0x40>)
    4c20:	9b01      	ldr	r3, [sp, #4]
    4c22:	4413      	add	r3, r2
    4c24:	781b      	ldrb	r3, [r3, #0]
    4c26:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    4c2a:	4b0c      	ldr	r3, [pc, #48]	; (4c5c <Mcu_InitClock+0x44>)
    4c2c:	681b      	ldr	r3, [r3, #0]
    4c2e:	6959      	ldr	r1, [r3, #20]
    4c30:	f89d 200f 	ldrb.w	r2, [sp, #15]
    4c34:	4613      	mov	r3, r2
    4c36:	01db      	lsls	r3, r3, #7
    4c38:	1a9b      	subs	r3, r3, r2
    4c3a:	00db      	lsls	r3, r3, #3
    4c3c:	440b      	add	r3, r1
    4c3e:	4618      	mov	r0, r3
    4c40:	f000 f86a 	bl	4d18 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    4c44:	2300      	movs	r3, #0
    4c46:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    4c4a:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    4c4e:	4618      	mov	r0, r3
    4c50:	b005      	add	sp, #20
    4c52:	f85d fb04 	ldr.w	pc, [sp], #4
    4c56:	bf00      	nop
    4c58:	1fff8ce4 	.word	0x1fff8ce4
    4c5c:	1fff8cec 	.word	0x1fff8cec

00004c60 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    4c60:	b500      	push	{lr}
    4c62:	b085      	sub	sp, #20
    4c64:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    4c66:	4a0d      	ldr	r2, [pc, #52]	; (4c9c <Mcu_SetMode+0x3c>)
    4c68:	9b01      	ldr	r3, [sp, #4]
    4c6a:	4413      	add	r3, r2
    4c6c:	781b      	ldrb	r3, [r3, #0]
    4c6e:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    4c72:	f002 fedb 	bl	7a2c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    4c76:	4b0a      	ldr	r3, [pc, #40]	; (4ca0 <Mcu_SetMode+0x40>)
    4c78:	681b      	ldr	r3, [r3, #0]
    4c7a:	6919      	ldr	r1, [r3, #16]
    4c7c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    4c80:	4613      	mov	r3, r2
    4c82:	005b      	lsls	r3, r3, #1
    4c84:	4413      	add	r3, r2
    4c86:	009b      	lsls	r3, r3, #2
    4c88:	440b      	add	r3, r1
    4c8a:	4618      	mov	r0, r3
    4c8c:	f000 f84e 	bl	4d2c <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    4c90:	f002 fef8 	bl	7a84 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4c94:	bf00      	nop
    4c96:	b005      	add	sp, #20
    4c98:	f85d fb04 	ldr.w	pc, [sp], #4
    4c9c:	1fff8ce8 	.word	0x1fff8ce8
    4ca0:	1fff8cec 	.word	0x1fff8cec

00004ca4 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    4ca4:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    4ca6:	2302      	movs	r3, #2
    4ca8:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    4caa:	9b01      	ldr	r3, [sp, #4]
}
    4cac:	4618      	mov	r0, r3
    4cae:	b002      	add	sp, #8
    4cb0:	4770      	bx	lr

00004cb2 <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    4cb2:	b500      	push	{lr}
    4cb4:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    4cb6:	f000 f843 	bl	4d40 <Mcu_Ipw_GetResetReason>
    4cba:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    4cbc:	9b01      	ldr	r3, [sp, #4]
}
    4cbe:	4618      	mov	r0, r3
    4cc0:	b003      	add	sp, #12
    4cc2:	f85d fb04 	ldr.w	pc, [sp], #4

00004cc6 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    4cc6:	b500      	push	{lr}
    4cc8:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    4cca:	f000 f83f 	bl	4d4c <Mcu_Ipw_GetResetRawValue>
    4cce:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    4cd0:	9b01      	ldr	r3, [sp, #4]
}
    4cd2:	4618      	mov	r0, r3
    4cd4:	b003      	add	sp, #12
    4cd6:	f85d fb04 	ldr.w	pc, [sp], #4

00004cda <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4cda:	b500      	push	{lr}
    4cdc:	b083      	sub	sp, #12
    4cde:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    4ce0:	9801      	ldr	r0, [sp, #4]
    4ce2:	f000 f839 	bl	4d58 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    4ce6:	bf00      	nop
    4ce8:	b003      	add	sp, #12
    4cea:	f85d fb04 	ldr.w	pc, [sp], #4

00004cee <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    4cee:	b082      	sub	sp, #8
    4cf0:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    4cf2:	4b03      	ldr	r3, [pc, #12]	; (4d00 <Mcu_ClkSrcFailureNotification+0x12>)
    4cf4:	681b      	ldr	r3, [r3, #0]
    4cf6:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    4cf8:	bf00      	nop
    4cfa:	b002      	add	sp, #8
    4cfc:	4770      	bx	lr
    4cfe:	bf00      	nop
    4d00:	1fff8cec 	.word	0x1fff8cec

00004d04 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    4d04:	b500      	push	{lr}
    4d06:	b083      	sub	sp, #12
    4d08:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    4d0a:	9801      	ldr	r0, [sp, #4]
    4d0c:	f000 f882 	bl	4e14 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    4d10:	bf00      	nop
    4d12:	b003      	add	sp, #12
    4d14:	f85d fb04 	ldr.w	pc, [sp], #4

00004d18 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    4d18:	b500      	push	{lr}
    4d1a:	b083      	sub	sp, #12
    4d1c:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    4d1e:	9801      	ldr	r0, [sp, #4]
    4d20:	f7fc fc6a 	bl	15f8 <Clock_Ip_InitClock>
}
    4d24:	bf00      	nop
    4d26:	b003      	add	sp, #12
    4d28:	f85d fb04 	ldr.w	pc, [sp], #4

00004d2c <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    4d2c:	b500      	push	{lr}
    4d2e:	b083      	sub	sp, #12
    4d30:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    4d32:	9801      	ldr	r0, [sp, #4]
    4d34:	f000 f820 	bl	4d78 <Power_Ip_SetMode>
}
    4d38:	bf00      	nop
    4d3a:	b003      	add	sp, #12
    4d3c:	f85d fb04 	ldr.w	pc, [sp], #4

00004d40 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    4d40:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    4d42:	f000 f84f 	bl	4de4 <Power_Ip_GetResetReason>
    4d46:	4603      	mov	r3, r0
}
    4d48:	4618      	mov	r0, r3
    4d4a:	bd08      	pop	{r3, pc}

00004d4c <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    4d4c:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    4d4e:	f000 f857 	bl	4e00 <Power_Ip_GetResetRawValue>
    4d52:	4603      	mov	r3, r0
}
    4d54:	4618      	mov	r0, r3
    4d56:	bd08      	pop	{r3, pc}

00004d58 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4d58:	b500      	push	{lr}
    4d5a:	b083      	sub	sp, #12
    4d5c:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    4d5e:	9b01      	ldr	r3, [sp, #4]
    4d60:	2b00      	cmp	r3, #0
    4d62:	d102      	bne.n	4d6a <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    4d64:	f000 f86c 	bl	4e40 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    4d68:	e001      	b.n	4d6e <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    4d6a:	f000 f86e 	bl	4e4a <Power_Ip_EnableSleepOnExit>
}
    4d6e:	bf00      	nop
    4d70:	b003      	add	sp, #12
    4d72:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004d78 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4d78:	b500      	push	{lr}
    4d7a:	b085      	sub	sp, #20
    4d7c:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    4d7e:	9b01      	ldr	r3, [sp, #4]
    4d80:	685b      	ldr	r3, [r3, #4]
    4d82:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    4d84:	9802      	ldr	r0, [sp, #8]
    4d86:	f000 f9f5 	bl	5174 <Power_Ip_SMC_ModeCheckEntry>
    4d8a:	4603      	mov	r3, r0
    4d8c:	2b00      	cmp	r3, #0
    4d8e:	d002      	beq.n	4d96 <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4d90:	2301      	movs	r3, #1
    4d92:	9303      	str	r3, [sp, #12]
    4d94:	e003      	b.n	4d9e <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    4d96:	9801      	ldr	r0, [sp, #4]
    4d98:	f000 fa1e 	bl	51d8 <Power_Ip_SMC_ModeConfig>
    4d9c:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    4d9e:	9b03      	ldr	r3, [sp, #12]
    4da0:	2b01      	cmp	r3, #1
    4da2:	d103      	bne.n	4dac <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4da4:	21ff      	movs	r1, #255	; 0xff
    4da6:	2003      	movs	r0, #3
    4da8:	f000 f8f4 	bl	4f94 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    4dac:	bf00      	nop
    4dae:	b005      	add	sp, #20
    4db0:	f85d fb04 	ldr.w	pc, [sp], #4

00004db4 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    4db4:	b084      	sub	sp, #16
    4db6:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    4db8:	230c      	movs	r3, #12
    4dba:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    4dbc:	4a08      	ldr	r2, [pc, #32]	; (4de0 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4dbe:	9b01      	ldr	r3, [sp, #4]
    4dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4dc4:	2b0e      	cmp	r3, #14
    4dc6:	d805      	bhi.n	4dd4 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    4dc8:	4a05      	ldr	r2, [pc, #20]	; (4de0 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4dca:	9b01      	ldr	r3, [sp, #4]
    4dcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4dd0:	9303      	str	r3, [sp, #12]
    4dd2:	e001      	b.n	4dd8 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    4dd4:	230c      	movs	r3, #12
    4dd6:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    4dd8:	9b03      	ldr	r3, [sp, #12]
}
    4dda:	4618      	mov	r0, r3
    4ddc:	b004      	add	sp, #16
    4dde:	4770      	bx	lr
    4de0:	0000a180 	.word	0x0000a180

00004de4 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    4de4:	b500      	push	{lr}
    4de6:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    4de8:	f000 f940 	bl	506c <Power_Ip_RCM_GetResetReason>
    4dec:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    4dee:	9801      	ldr	r0, [sp, #4]
    4df0:	f7ff ffe0 	bl	4db4 <Power_Ip_ConvertIntergeToResetType>
    4df4:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    4df6:	9b00      	ldr	r3, [sp, #0]
}
    4df8:	4618      	mov	r0, r3
    4dfa:	b003      	add	sp, #12
    4dfc:	f85d fb04 	ldr.w	pc, [sp], #4

00004e00 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    4e00:	b500      	push	{lr}
    4e02:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    4e04:	f000 f98a 	bl	511c <Power_Ip_RCM_GetResetRawValue>
    4e08:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    4e0a:	9b01      	ldr	r3, [sp, #4]
}
    4e0c:	4618      	mov	r0, r3
    4e0e:	b003      	add	sp, #12
    4e10:	f85d fb04 	ldr.w	pc, [sp], #4

00004e14 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    4e14:	b500      	push	{lr}
    4e16:	b083      	sub	sp, #12
    4e18:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    4e1a:	9b01      	ldr	r3, [sp, #4]
    4e1c:	681b      	ldr	r3, [r3, #0]
    4e1e:	4618      	mov	r0, r3
    4e20:	f000 f90e 	bl	5040 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    4e24:	9b01      	ldr	r3, [sp, #4]
    4e26:	685b      	ldr	r3, [r3, #4]
    4e28:	4618      	mov	r0, r3
    4e2a:	f000 f86d 	bl	4f08 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    4e2e:	9b01      	ldr	r3, [sp, #4]
    4e30:	689b      	ldr	r3, [r3, #8]
    4e32:	4618      	mov	r0, r3
    4e34:	f000 f990 	bl	5158 <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    4e38:	bf00      	nop
    4e3a:	b003      	add	sp, #12
    4e3c:	f85d fb04 	ldr.w	pc, [sp], #4

00004e40 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    4e40:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    4e42:	f000 f811 	bl	4e68 <Power_Ip_CM4_DisableSleepOnExit>
}
    4e46:	bf00      	nop
    4e48:	bd08      	pop	{r3, pc}

00004e4a <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    4e4a:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    4e4c:	f000 f820 	bl	4e90 <Power_Ip_CM4_EnableSleepOnExit>
}
    4e50:	bf00      	nop
    4e52:	bd08      	pop	{r3, pc}

00004e54 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    4e54:	b082      	sub	sp, #8
    4e56:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    4e58:	4a02      	ldr	r2, [pc, #8]	; (4e64 <Power_Ip_InstallNotificationsCallback+0x10>)
    4e5a:	9b01      	ldr	r3, [sp, #4]
    4e5c:	6013      	str	r3, [r2, #0]
}
    4e5e:	bf00      	nop
    4e60:	b002      	add	sp, #8
    4e62:	4770      	bx	lr
    4e64:	1fff8b24 	.word	0x1fff8b24

00004e68 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    4e68:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4e6a:	2300      	movs	r3, #0
    4e6c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4e6e:	4b07      	ldr	r3, [pc, #28]	; (4e8c <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4e70:	681b      	ldr	r3, [r3, #0]
    4e72:	685b      	ldr	r3, [r3, #4]
    4e74:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    4e76:	9b01      	ldr	r3, [sp, #4]
    4e78:	f023 0302 	bic.w	r3, r3, #2
    4e7c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4e7e:	4b03      	ldr	r3, [pc, #12]	; (4e8c <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4e80:	681b      	ldr	r3, [r3, #0]
    4e82:	9a01      	ldr	r2, [sp, #4]
    4e84:	605a      	str	r2, [r3, #4]
}
    4e86:	bf00      	nop
    4e88:	b002      	add	sp, #8
    4e8a:	4770      	bx	lr
    4e8c:	1fff8b28 	.word	0x1fff8b28

00004e90 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    4e90:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4e92:	2300      	movs	r3, #0
    4e94:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4e96:	4b07      	ldr	r3, [pc, #28]	; (4eb4 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4e98:	681b      	ldr	r3, [r3, #0]
    4e9a:	685b      	ldr	r3, [r3, #4]
    4e9c:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    4e9e:	9b01      	ldr	r3, [sp, #4]
    4ea0:	f043 0302 	orr.w	r3, r3, #2
    4ea4:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4ea6:	4b03      	ldr	r3, [pc, #12]	; (4eb4 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4ea8:	681b      	ldr	r3, [r3, #0]
    4eaa:	9a01      	ldr	r2, [sp, #4]
    4eac:	605a      	str	r2, [r3, #4]
}
    4eae:	bf00      	nop
    4eb0:	b002      	add	sp, #8
    4eb2:	4770      	bx	lr
    4eb4:	1fff8b28 	.word	0x1fff8b28

00004eb8 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    4eb8:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4eba:	2300      	movs	r3, #0
    4ebc:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4ebe:	4b07      	ldr	r3, [pc, #28]	; (4edc <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4ec0:	681b      	ldr	r3, [r3, #0]
    4ec2:	685b      	ldr	r3, [r3, #4]
    4ec4:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    4ec6:	9b01      	ldr	r3, [sp, #4]
    4ec8:	f043 0304 	orr.w	r3, r3, #4
    4ecc:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4ece:	4b03      	ldr	r3, [pc, #12]	; (4edc <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4ed0:	681b      	ldr	r3, [r3, #0]
    4ed2:	9a01      	ldr	r2, [sp, #4]
    4ed4:	605a      	str	r2, [r3, #4]
}
    4ed6:	bf00      	nop
    4ed8:	b002      	add	sp, #8
    4eda:	4770      	bx	lr
    4edc:	1fff8b28 	.word	0x1fff8b28

00004ee0 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    4ee0:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4ee2:	2300      	movs	r3, #0
    4ee4:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4ee6:	4b07      	ldr	r3, [pc, #28]	; (4f04 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4ee8:	681b      	ldr	r3, [r3, #0]
    4eea:	685b      	ldr	r3, [r3, #4]
    4eec:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    4eee:	9b01      	ldr	r3, [sp, #4]
    4ef0:	f023 0304 	bic.w	r3, r3, #4
    4ef4:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4ef6:	4b03      	ldr	r3, [pc, #12]	; (4f04 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4ef8:	681b      	ldr	r3, [r3, #0]
    4efa:	9a01      	ldr	r2, [sp, #4]
    4efc:	605a      	str	r2, [r3, #4]
}
    4efe:	bf00      	nop
    4f00:	b002      	add	sp, #8
    4f02:	4770      	bx	lr
    4f04:	1fff8b28 	.word	0x1fff8b28

00004f08 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    4f08:	b084      	sub	sp, #16
    4f0a:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    4f0c:	4b20      	ldr	r3, [pc, #128]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f0e:	781b      	ldrb	r3, [r3, #0]
    4f10:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    4f14:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f18:	f003 030f 	and.w	r3, r3, #15
    4f1c:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    4f20:	9b01      	ldr	r3, [sp, #4]
    4f22:	781a      	ldrb	r2, [r3, #0]
    4f24:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f28:	4313      	orrs	r3, r2
    4f2a:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    4f2e:	4a18      	ldr	r2, [pc, #96]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f30:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f34:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    4f36:	4b16      	ldr	r3, [pc, #88]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f38:	785b      	ldrb	r3, [r3, #1]
    4f3a:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    4f3e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f42:	f003 031f 	and.w	r3, r3, #31
    4f46:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    4f4a:	9b01      	ldr	r3, [sp, #4]
    4f4c:	785a      	ldrb	r2, [r3, #1]
    4f4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f52:	4313      	orrs	r3, r2
    4f54:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    4f58:	4a0d      	ldr	r2, [pc, #52]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f5e:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    4f60:	4b0b      	ldr	r3, [pc, #44]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f62:	789b      	ldrb	r3, [r3, #2]
    4f64:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    4f68:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f6c:	f003 0338 	and.w	r3, r3, #56	; 0x38
    4f70:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    4f74:	9b01      	ldr	r3, [sp, #4]
    4f76:	789a      	ldrb	r2, [r3, #2]
    4f78:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f7c:	4313      	orrs	r3, r2
    4f7e:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    4f82:	4a03      	ldr	r2, [pc, #12]	; (4f90 <Power_Ip_PMC_PowerInit+0x88>)
    4f84:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f88:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    4f8a:	bf00      	nop
    4f8c:	b004      	add	sp, #16
    4f8e:	4770      	bx	lr
    4f90:	4007d000 	.word	0x4007d000

00004f94 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4f94:	b500      	push	{lr}
    4f96:	b083      	sub	sp, #12
    4f98:	9001      	str	r0, [sp, #4]
    4f9a:	460b      	mov	r3, r1
    4f9c:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    4fa0:	4b05      	ldr	r3, [pc, #20]	; (4fb8 <Power_Ip_ReportPowerErrors+0x24>)
    4fa2:	681b      	ldr	r3, [r3, #0]
    4fa4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    4fa8:	4611      	mov	r1, r2
    4faa:	9801      	ldr	r0, [sp, #4]
    4fac:	4798      	blx	r3
}
    4fae:	bf00      	nop
    4fb0:	b003      	add	sp, #12
    4fb2:	f85d fb04 	ldr.w	pc, [sp], #4
    4fb6:	bf00      	nop
    4fb8:	1fff8b24 	.word	0x1fff8b24

00004fbc <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4fbc:	b082      	sub	sp, #8
    4fbe:	9001      	str	r0, [sp, #4]
    4fc0:	460b      	mov	r3, r1
    4fc2:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    4fc6:	bf00      	nop
    4fc8:	b002      	add	sp, #8
    4fca:	4770      	bx	lr

00004fcc <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    4fcc:	b500      	push	{lr}
    4fce:	b085      	sub	sp, #20
    4fd0:	9003      	str	r0, [sp, #12]
    4fd2:	9102      	str	r1, [sp, #8]
    4fd4:	9201      	str	r2, [sp, #4]
    4fd6:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    4fd8:	2000      	movs	r0, #0
    4fda:	f7fc f83d 	bl	1058 <OsIf_GetCounter>
    4fde:	4602      	mov	r2, r0
    4fe0:	9b03      	ldr	r3, [sp, #12]
    4fe2:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    4fe4:	9b02      	ldr	r3, [sp, #8]
    4fe6:	2200      	movs	r2, #0
    4fe8:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    4fea:	2100      	movs	r1, #0
    4fec:	9800      	ldr	r0, [sp, #0]
    4fee:	f7fc f87f 	bl	10f0 <OsIf_MicrosToTicks>
    4ff2:	4602      	mov	r2, r0
    4ff4:	9b01      	ldr	r3, [sp, #4]
    4ff6:	601a      	str	r2, [r3, #0]
}
    4ff8:	bf00      	nop
    4ffa:	b005      	add	sp, #20
    4ffc:	f85d fb04 	ldr.w	pc, [sp], #4

00005000 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    5000:	b500      	push	{lr}
    5002:	b087      	sub	sp, #28
    5004:	9003      	str	r0, [sp, #12]
    5006:	9102      	str	r1, [sp, #8]
    5008:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    500a:	2300      	movs	r3, #0
    500c:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    5010:	2100      	movs	r1, #0
    5012:	9803      	ldr	r0, [sp, #12]
    5014:	f7fc f839 	bl	108a <OsIf_GetElapsed>
    5018:	4602      	mov	r2, r0
    501a:	9b02      	ldr	r3, [sp, #8]
    501c:	681b      	ldr	r3, [r3, #0]
    501e:	441a      	add	r2, r3
    5020:	9b02      	ldr	r3, [sp, #8]
    5022:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    5024:	9b02      	ldr	r3, [sp, #8]
    5026:	681b      	ldr	r3, [r3, #0]
    5028:	9a01      	ldr	r2, [sp, #4]
    502a:	429a      	cmp	r2, r3
    502c:	d802      	bhi.n	5034 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    502e:	2301      	movs	r3, #1
    5030:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    5034:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5038:	4618      	mov	r0, r3
    503a:	b007      	add	sp, #28
    503c:	f85d fb04 	ldr.w	pc, [sp], #4

00005040 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    5040:	b082      	sub	sp, #8
    5042:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    5044:	9b01      	ldr	r3, [sp, #4]
    5046:	681a      	ldr	r2, [r3, #0]
    5048:	4907      	ldr	r1, [pc, #28]	; (5068 <Power_Ip_RCM_ResetInit+0x28>)
    504a:	f641 7307 	movw	r3, #7943	; 0x1f07
    504e:	4013      	ands	r3, r2
    5050:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    5052:	9b01      	ldr	r3, [sp, #4]
    5054:	685a      	ldr	r2, [r3, #4]
    5056:	4904      	ldr	r1, [pc, #16]	; (5068 <Power_Ip_RCM_ResetInit+0x28>)
    5058:	f642 73ff 	movw	r3, #12287	; 0x2fff
    505c:	4013      	ands	r3, r2
    505e:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    5060:	bf00      	nop
    5062:	b002      	add	sp, #8
    5064:	4770      	bx	lr
    5066:	bf00      	nop
    5068:	4007f000 	.word	0x4007f000

0000506c <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    506c:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    506e:	230c      	movs	r3, #12
    5070:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    5072:	2300      	movs	r3, #0
    5074:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    5076:	2300      	movs	r3, #0
    5078:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    507a:	2300      	movs	r3, #0
    507c:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    507e:	4b25      	ldr	r3, [pc, #148]	; (5114 <Power_Ip_RCM_GetResetReason+0xa8>)
    5080:	699a      	ldr	r2, [r3, #24]
    5082:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5086:	4013      	ands	r3, r2
    5088:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    508a:	9b03      	ldr	r3, [sp, #12]
    508c:	2b00      	cmp	r3, #0
    508e:	d008      	beq.n	50a2 <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5090:	4920      	ldr	r1, [pc, #128]	; (5114 <Power_Ip_RCM_GetResetReason+0xa8>)
    5092:	9a03      	ldr	r2, [sp, #12]
    5094:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5098:	4013      	ands	r3, r2
    509a:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    509c:	4a1e      	ldr	r2, [pc, #120]	; (5118 <Power_Ip_RCM_GetResetReason+0xac>)
    509e:	9b03      	ldr	r3, [sp, #12]
    50a0:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    50a2:	4b1d      	ldr	r3, [pc, #116]	; (5118 <Power_Ip_RCM_GetResetReason+0xac>)
    50a4:	681b      	ldr	r3, [r3, #0]
    50a6:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    50a8:	9a02      	ldr	r2, [sp, #8]
    50aa:	f642 73ee 	movw	r3, #12270	; 0x2fee
    50ae:	4013      	ands	r3, r2
    50b0:	2b82      	cmp	r3, #130	; 0x82
    50b2:	d102      	bne.n	50ba <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    50b4:	2305      	movs	r3, #5
    50b6:	9307      	str	r3, [sp, #28]
    50b8:	e027      	b.n	510a <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    50ba:	2300      	movs	r3, #0
    50bc:	9306      	str	r3, [sp, #24]
    50be:	e021      	b.n	5104 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    50c0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    50c4:	9b06      	ldr	r3, [sp, #24]
    50c6:	fa22 f303 	lsr.w	r3, r2, r3
    50ca:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    50cc:	9a01      	ldr	r2, [sp, #4]
    50ce:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    50d2:	4013      	ands	r3, r2
    50d4:	2b00      	cmp	r3, #0
    50d6:	d012      	beq.n	50fe <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    50d8:	9a01      	ldr	r2, [sp, #4]
    50da:	9b02      	ldr	r3, [sp, #8]
    50dc:	4013      	ands	r3, r2
    50de:	2b00      	cmp	r3, #0
    50e0:	d00a      	beq.n	50f8 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    50e2:	9b05      	ldr	r3, [sp, #20]
    50e4:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    50e6:	9b04      	ldr	r3, [sp, #16]
    50e8:	3301      	adds	r3, #1
    50ea:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    50ec:	9b04      	ldr	r3, [sp, #16]
    50ee:	2b01      	cmp	r3, #1
    50f0:	d902      	bls.n	50f8 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    50f2:	230d      	movs	r3, #13
    50f4:	9307      	str	r3, [sp, #28]
                        break;
    50f6:	e008      	b.n	510a <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    50f8:	9b05      	ldr	r3, [sp, #20]
    50fa:	3301      	adds	r3, #1
    50fc:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    50fe:	9b06      	ldr	r3, [sp, #24]
    5100:	3301      	adds	r3, #1
    5102:	9306      	str	r3, [sp, #24]
    5104:	9b06      	ldr	r3, [sp, #24]
    5106:	2b1f      	cmp	r3, #31
    5108:	d9da      	bls.n	50c0 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    510a:	9b07      	ldr	r3, [sp, #28]
}
    510c:	4618      	mov	r0, r3
    510e:	b008      	add	sp, #32
    5110:	4770      	bx	lr
    5112:	bf00      	nop
    5114:	4007f000 	.word	0x4007f000
    5118:	1fff8cf0 	.word	0x1fff8cf0

0000511c <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    511c:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    511e:	4b0c      	ldr	r3, [pc, #48]	; (5150 <Power_Ip_RCM_GetResetRawValue+0x34>)
    5120:	699a      	ldr	r2, [r3, #24]
    5122:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5126:	4013      	ands	r3, r2
    5128:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    512a:	9b01      	ldr	r3, [sp, #4]
    512c:	2b00      	cmp	r3, #0
    512e:	d008      	beq.n	5142 <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5130:	4907      	ldr	r1, [pc, #28]	; (5150 <Power_Ip_RCM_GetResetRawValue+0x34>)
    5132:	9a01      	ldr	r2, [sp, #4]
    5134:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5138:	4013      	ands	r3, r2
    513a:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    513c:	4a05      	ldr	r2, [pc, #20]	; (5154 <Power_Ip_RCM_GetResetRawValue+0x38>)
    513e:	9b01      	ldr	r3, [sp, #4]
    5140:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    5142:	4b04      	ldr	r3, [pc, #16]	; (5154 <Power_Ip_RCM_GetResetRawValue+0x38>)
    5144:	681b      	ldr	r3, [r3, #0]
    5146:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    5148:	9b00      	ldr	r3, [sp, #0]
}
    514a:	4618      	mov	r0, r3
    514c:	b002      	add	sp, #8
    514e:	4770      	bx	lr
    5150:	4007f000 	.word	0x4007f000
    5154:	1fff8cf0 	.word	0x1fff8cf0

00005158 <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    5158:	b082      	sub	sp, #8
    515a:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    515c:	9b01      	ldr	r3, [sp, #4]
    515e:	681b      	ldr	r3, [r3, #0]
    5160:	4a03      	ldr	r2, [pc, #12]	; (5170 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    5162:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    5166:	6093      	str	r3, [r2, #8]
}
    5168:	bf00      	nop
    516a:	b002      	add	sp, #8
    516c:	4770      	bx	lr
    516e:	bf00      	nop
    5170:	4007e000 	.word	0x4007e000

00005174 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    5174:	b084      	sub	sp, #16
    5176:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    5178:	2301      	movs	r3, #1
    517a:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    517c:	4b15      	ldr	r3, [pc, #84]	; (51d4 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    517e:	695b      	ldr	r3, [r3, #20]
    5180:	b2db      	uxtb	r3, r3
    5182:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    5184:	9b01      	ldr	r3, [sp, #4]
    5186:	2b02      	cmp	r3, #2
    5188:	d012      	beq.n	51b0 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    518a:	9b01      	ldr	r3, [sp, #4]
    518c:	2b02      	cmp	r3, #2
    518e:	d818      	bhi.n	51c2 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    5190:	9b01      	ldr	r3, [sp, #4]
    5192:	2b00      	cmp	r3, #0
    5194:	d003      	beq.n	519e <Power_Ip_SMC_ModeCheckEntry+0x2a>
    5196:	9b01      	ldr	r3, [sp, #4]
    5198:	2b01      	cmp	r3, #1
    519a:	d003      	beq.n	51a4 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    519c:	e011      	b.n	51c2 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    519e:	2300      	movs	r3, #0
    51a0:	9303      	str	r3, [sp, #12]
            break;
    51a2:	e013      	b.n	51cc <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    51a4:	9b02      	ldr	r3, [sp, #8]
    51a6:	2b01      	cmp	r3, #1
    51a8:	d10d      	bne.n	51c6 <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    51aa:	2300      	movs	r3, #0
    51ac:	9303      	str	r3, [sp, #12]
            break;
    51ae:	e00a      	b.n	51c6 <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    51b0:	9b02      	ldr	r3, [sp, #8]
    51b2:	2b01      	cmp	r3, #1
    51b4:	d002      	beq.n	51bc <Power_Ip_SMC_ModeCheckEntry+0x48>
    51b6:	9b02      	ldr	r3, [sp, #8]
    51b8:	2b10      	cmp	r3, #16
    51ba:	d106      	bne.n	51ca <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    51bc:	2300      	movs	r3, #0
    51be:	9303      	str	r3, [sp, #12]
            break;
    51c0:	e003      	b.n	51ca <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    51c2:	bf00      	nop
    51c4:	e002      	b.n	51cc <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    51c6:	bf00      	nop
    51c8:	e000      	b.n	51cc <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    51ca:	bf00      	nop
        }
    }

    return PowerModeCheck;
    51cc:	9b03      	ldr	r3, [sp, #12]
}
    51ce:	4618      	mov	r0, r3
    51d0:	b004      	add	sp, #16
    51d2:	4770      	bx	lr
    51d4:	4007e000 	.word	0x4007e000

000051d8 <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    51d8:	b500      	push	{lr}
    51da:	b08b      	sub	sp, #44	; 0x2c
    51dc:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    51de:	2300      	movs	r3, #0
    51e0:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    51e2:	2300      	movs	r3, #0
    51e4:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    51e6:	2300      	movs	r3, #0
    51e8:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    51ec:	9b01      	ldr	r3, [sp, #4]
    51ee:	685b      	ldr	r3, [r3, #4]
    51f0:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    51f2:	9b08      	ldr	r3, [sp, #32]
    51f4:	2b02      	cmp	r3, #2
    51f6:	d076      	beq.n	52e6 <Power_Ip_SMC_ModeConfig+0x10e>
    51f8:	9b08      	ldr	r3, [sp, #32]
    51fa:	2b02      	cmp	r3, #2
    51fc:	f200 80ab 	bhi.w	5356 <Power_Ip_SMC_ModeConfig+0x17e>
    5200:	9b08      	ldr	r3, [sp, #32]
    5202:	2b00      	cmp	r3, #0
    5204:	d003      	beq.n	520e <Power_Ip_SMC_ModeConfig+0x36>
    5206:	9b08      	ldr	r3, [sp, #32]
    5208:	2b01      	cmp	r3, #1
    520a:	d034      	beq.n	5276 <Power_Ip_SMC_ModeConfig+0x9e>
    520c:	e0a3      	b.n	5356 <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    520e:	4b58      	ldr	r3, [pc, #352]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    5210:	68db      	ldr	r3, [r3, #12]
    5212:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    5214:	9b06      	ldr	r3, [sp, #24]
    5216:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    521a:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    521c:	4a54      	ldr	r2, [pc, #336]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    521e:	9b06      	ldr	r3, [sp, #24]
    5220:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5222:	aa02      	add	r2, sp, #8
    5224:	a903      	add	r1, sp, #12
    5226:	a804      	add	r0, sp, #16
    5228:	f24c 3350 	movw	r3, #50000	; 0xc350
    522c:	f7ff fece 	bl	4fcc <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5230:	9a02      	ldr	r2, [sp, #8]
    5232:	a903      	add	r1, sp, #12
    5234:	ab04      	add	r3, sp, #16
    5236:	4618      	mov	r0, r3
    5238:	f7ff fee2 	bl	5000 <Power_Ip_TimeoutExpired>
    523c:	4603      	mov	r3, r0
    523e:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    5242:	4b4b      	ldr	r3, [pc, #300]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    5244:	695b      	ldr	r3, [r3, #20]
    5246:	f003 0301 	and.w	r3, r3, #1
    524a:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    524c:	9b05      	ldr	r3, [sp, #20]
    524e:	2b01      	cmp	r3, #1
    5250:	d006      	beq.n	5260 <Power_Ip_SMC_ModeConfig+0x88>
    5252:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5256:	f083 0301 	eor.w	r3, r3, #1
    525a:	b2db      	uxtb	r3, r3
    525c:	2b00      	cmp	r3, #0
    525e:	d1e7      	bne.n	5230 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    5260:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5264:	2b00      	cmp	r3, #0
    5266:	d079      	beq.n	535c <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5268:	2301      	movs	r3, #1
    526a:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    526c:	21ff      	movs	r1, #255	; 0xff
    526e:	2000      	movs	r0, #0
    5270:	f7ff fe90 	bl	4f94 <Power_Ip_ReportPowerErrors>
            }

            break;
    5274:	e072      	b.n	535c <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    5276:	4b3e      	ldr	r3, [pc, #248]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    5278:	68db      	ldr	r3, [r3, #12]
    527a:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    527c:	9b06      	ldr	r3, [sp, #24]
    527e:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    5282:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    5284:	9b06      	ldr	r3, [sp, #24]
    5286:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    528a:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    528c:	4a38      	ldr	r2, [pc, #224]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    528e:	9b06      	ldr	r3, [sp, #24]
    5290:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5292:	aa02      	add	r2, sp, #8
    5294:	a903      	add	r1, sp, #12
    5296:	a804      	add	r0, sp, #16
    5298:	f24c 3350 	movw	r3, #50000	; 0xc350
    529c:	f7ff fe96 	bl	4fcc <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    52a0:	9a02      	ldr	r2, [sp, #8]
    52a2:	a903      	add	r1, sp, #12
    52a4:	ab04      	add	r3, sp, #16
    52a6:	4618      	mov	r0, r3
    52a8:	f7ff feaa 	bl	5000 <Power_Ip_TimeoutExpired>
    52ac:	4603      	mov	r3, r0
    52ae:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    52b2:	4b2f      	ldr	r3, [pc, #188]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    52b4:	695b      	ldr	r3, [r3, #20]
    52b6:	f003 0380 	and.w	r3, r3, #128	; 0x80
    52ba:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    52bc:	9b05      	ldr	r3, [sp, #20]
    52be:	2b80      	cmp	r3, #128	; 0x80
    52c0:	d006      	beq.n	52d0 <Power_Ip_SMC_ModeConfig+0xf8>
    52c2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    52c6:	f083 0301 	eor.w	r3, r3, #1
    52ca:	b2db      	uxtb	r3, r3
    52cc:	2b00      	cmp	r3, #0
    52ce:	d1e7      	bne.n	52a0 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    52d0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    52d4:	2b00      	cmp	r3, #0
    52d6:	d043      	beq.n	5360 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    52d8:	2301      	movs	r3, #1
    52da:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    52dc:	21ff      	movs	r1, #255	; 0xff
    52de:	2000      	movs	r0, #0
    52e0:	f7ff fe58 	bl	4f94 <Power_Ip_ReportPowerErrors>
            }

            break;
    52e4:	e03c      	b.n	5360 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    52e6:	4b22      	ldr	r3, [pc, #136]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    52e8:	68db      	ldr	r3, [r3, #12]
    52ea:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    52ec:	9b06      	ldr	r3, [sp, #24]
    52ee:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    52f2:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    52f4:	9b06      	ldr	r3, [sp, #24]
    52f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    52fa:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    52fc:	4a1c      	ldr	r2, [pc, #112]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    52fe:	9b06      	ldr	r3, [sp, #24]
    5300:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5302:	aa02      	add	r2, sp, #8
    5304:	a903      	add	r1, sp, #12
    5306:	a804      	add	r0, sp, #16
    5308:	f24c 3350 	movw	r3, #50000	; 0xc350
    530c:	f7ff fe5e 	bl	4fcc <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5310:	9a02      	ldr	r2, [sp, #8]
    5312:	a903      	add	r1, sp, #12
    5314:	ab04      	add	r3, sp, #16
    5316:	4618      	mov	r0, r3
    5318:	f7ff fe72 	bl	5000 <Power_Ip_TimeoutExpired>
    531c:	4603      	mov	r3, r0
    531e:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    5322:	4b13      	ldr	r3, [pc, #76]	; (5370 <Power_Ip_SMC_ModeConfig+0x198>)
    5324:	695b      	ldr	r3, [r3, #20]
    5326:	f003 0304 	and.w	r3, r3, #4
    532a:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    532c:	9b05      	ldr	r3, [sp, #20]
    532e:	2b04      	cmp	r3, #4
    5330:	d006      	beq.n	5340 <Power_Ip_SMC_ModeConfig+0x168>
    5332:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5336:	f083 0301 	eor.w	r3, r3, #1
    533a:	b2db      	uxtb	r3, r3
    533c:	2b00      	cmp	r3, #0
    533e:	d1e7      	bne.n	5310 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    5340:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5344:	2b00      	cmp	r3, #0
    5346:	d00d      	beq.n	5364 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5348:	2301      	movs	r3, #1
    534a:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    534c:	21ff      	movs	r1, #255	; 0xff
    534e:	2000      	movs	r0, #0
    5350:	f7ff fe20 	bl	4f94 <Power_Ip_ReportPowerErrors>
            }

            break;
    5354:	e006      	b.n	5364 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5356:	2301      	movs	r3, #1
    5358:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    535a:	e004      	b.n	5366 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    535c:	bf00      	nop
    535e:	e002      	b.n	5366 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5360:	bf00      	nop
    5362:	e000      	b.n	5366 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5364:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    5366:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5368:	4618      	mov	r0, r3
    536a:	b00b      	add	sp, #44	; 0x2c
    536c:	f85d fb04 	ldr.w	pc, [sp], #4
    5370:	4007e000 	.word	0x4007e000

00005374 <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    5374:	b500      	push	{lr}
    5376:	b085      	sub	sp, #20
    5378:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    537a:	9b01      	ldr	r3, [sp, #4]
    537c:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    537e:	9803      	ldr	r0, [sp, #12]
    5380:	f000 fbc8 	bl	5b14 <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    5384:	4a03      	ldr	r2, [pc, #12]	; (5394 <Port_Init+0x20>)
    5386:	9b03      	ldr	r3, [sp, #12]
    5388:	6013      	str	r3, [r2, #0]
        }
    }
}
    538a:	bf00      	nop
    538c:	b005      	add	sp, #20
    538e:	f85d fb04 	ldr.w	pc, [sp], #4
    5392:	bf00      	nop
    5394:	1fff8cf4 	.word	0x1fff8cf4

00005398 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    5398:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    539a:	4b03      	ldr	r3, [pc, #12]	; (53a8 <Port_RefreshPortDirection+0x10>)
    539c:	681b      	ldr	r3, [r3, #0]
    539e:	4618      	mov	r0, r3
    53a0:	f000 fc10 	bl	5bc4 <Port_Ipw_RefreshPortDirection>
    }
}
    53a4:	bf00      	nop
    53a6:	bd08      	pop	{r3, pc}
    53a8:	1fff8cf4 	.word	0x1fff8cf4

000053ac <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    53ac:	b086      	sub	sp, #24
    53ae:	9003      	str	r0, [sp, #12]
    53b0:	9102      	str	r1, [sp, #8]
    53b2:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    53b4:	23ff      	movs	r3, #255	; 0xff
    53b6:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    53b8:	9b03      	ldr	r3, [sp, #12]
    53ba:	4a39      	ldr	r2, [pc, #228]	; (54a0 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    53bc:	4293      	cmp	r3, r2
    53be:	d151      	bne.n	5464 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    53c0:	9b02      	ldr	r3, [sp, #8]
    53c2:	2b10      	cmp	r3, #16
    53c4:	d867      	bhi.n	5496 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    53c6:	a201      	add	r2, pc, #4	; (adr r2, 53cc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    53c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    53cc:	00005411 	.word	0x00005411
    53d0:	0000541f 	.word	0x0000541f
    53d4:	00005497 	.word	0x00005497
    53d8:	00005497 	.word	0x00005497
    53dc:	00005497 	.word	0x00005497
    53e0:	00005497 	.word	0x00005497
    53e4:	00005497 	.word	0x00005497
    53e8:	00005497 	.word	0x00005497
    53ec:	00005497 	.word	0x00005497
    53f0:	00005497 	.word	0x00005497
    53f4:	00005497 	.word	0x00005497
    53f8:	00005497 	.word	0x00005497
    53fc:	00005497 	.word	0x00005497
    5400:	0000542d 	.word	0x0000542d
    5404:	0000543b 	.word	0x0000543b
    5408:	00005449 	.word	0x00005449
    540c:	00005457 	.word	0x00005457
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    5410:	2301      	movs	r3, #1
    5412:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5414:	9a05      	ldr	r2, [sp, #20]
    5416:	9b01      	ldr	r3, [sp, #4]
    5418:	4313      	orrs	r3, r2
    541a:	9305      	str	r3, [sp, #20]
                break;
    541c:	e03c      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    541e:	2302      	movs	r3, #2
    5420:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5422:	9a05      	ldr	r2, [sp, #20]
    5424:	9b01      	ldr	r3, [sp, #4]
    5426:	4313      	orrs	r3, r2
    5428:	9305      	str	r3, [sp, #20]
                break;
    542a:	e035      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    542c:	2304      	movs	r3, #4
    542e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5430:	9a05      	ldr	r2, [sp, #20]
    5432:	9b01      	ldr	r3, [sp, #4]
    5434:	4313      	orrs	r3, r2
    5436:	9305      	str	r3, [sp, #20]
                break;
    5438:	e02e      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    543a:	2308      	movs	r3, #8
    543c:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    543e:	9a05      	ldr	r2, [sp, #20]
    5440:	9b01      	ldr	r3, [sp, #4]
    5442:	4313      	orrs	r3, r2
    5444:	9305      	str	r3, [sp, #20]
                break;
    5446:	e027      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    5448:	230e      	movs	r3, #14
    544a:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    544c:	9a05      	ldr	r2, [sp, #20]
    544e:	9b01      	ldr	r3, [sp, #4]
    5450:	4013      	ands	r3, r2
    5452:	9305      	str	r3, [sp, #20]
                break;
    5454:	e020      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    5456:	230d      	movs	r3, #13
    5458:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    545a:	9a05      	ldr	r2, [sp, #20]
    545c:	9b01      	ldr	r3, [sp, #4]
    545e:	4013      	ands	r3, r2
    5460:	9305      	str	r3, [sp, #20]
                break;
    5462:	e019      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    5464:	9b03      	ldr	r3, [sp, #12]
    5466:	4a0f      	ldr	r2, [pc, #60]	; (54a4 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    5468:	4293      	cmp	r3, r2
    546a:	d115      	bne.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    546c:	9b02      	ldr	r3, [sp, #8]
    546e:	2b00      	cmp	r3, #0
    5470:	d003      	beq.n	547a <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    5472:	9b02      	ldr	r3, [sp, #8]
    5474:	2b01      	cmp	r3, #1
    5476:	d007      	beq.n	5488 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    5478:	e00e      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    547a:	230b      	movs	r3, #11
    547c:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    547e:	9a05      	ldr	r2, [sp, #20]
    5480:	9b01      	ldr	r3, [sp, #4]
    5482:	4013      	ands	r3, r2
    5484:	9305      	str	r3, [sp, #20]
                break;
    5486:	e007      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    5488:	2307      	movs	r3, #7
    548a:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    548c:	9a05      	ldr	r2, [sp, #20]
    548e:	9b01      	ldr	r3, [sp, #4]
    5490:	4013      	ands	r3, r2
    5492:	9305      	str	r3, [sp, #20]
                break;
    5494:	e000      	b.n	5498 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    5496:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    5498:	9b05      	ldr	r3, [sp, #20]
}
    549a:	4618      	mov	r0, r3
    549c:	b006      	add	sp, #24
    549e:	4770      	bx	lr
    54a0:	4004a000 	.word	0x4004a000
    54a4:	4004b000 	.word	0x4004b000

000054a8 <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    54a8:	b500      	push	{lr}
    54aa:	b089      	sub	sp, #36	; 0x24
    54ac:	9003      	str	r0, [sp, #12]
    54ae:	9102      	str	r1, [sp, #8]
    54b0:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    54b2:	9b01      	ldr	r3, [sp, #4]
    54b4:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    54b6:	9b01      	ldr	r3, [sp, #4]
    54b8:	2b08      	cmp	r3, #8
    54ba:	d121      	bne.n	5500 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    54bc:	4b13      	ldr	r3, [pc, #76]	; (550c <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    54be:	685b      	ldr	r3, [r3, #4]
    54c0:	f003 030f 	and.w	r3, r3, #15
    54c4:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    54c6:	9a06      	ldr	r2, [sp, #24]
    54c8:	9902      	ldr	r1, [sp, #8]
    54ca:	9803      	ldr	r0, [sp, #12]
    54cc:	f7ff ff6e 	bl	53ac <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    54d0:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    54d2:	9b05      	ldr	r3, [sp, #20]
    54d4:	2bff      	cmp	r3, #255	; 0xff
    54d6:	d011      	beq.n	54fc <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    54d8:	f002 fd38 	bl	7f4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    54dc:	4b0b      	ldr	r3, [pc, #44]	; (550c <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    54de:	685b      	ldr	r3, [r3, #4]
    54e0:	4a0a      	ldr	r2, [pc, #40]	; (550c <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    54e2:	f023 030f 	bic.w	r3, r3, #15
    54e6:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    54e8:	4b08      	ldr	r3, [pc, #32]	; (550c <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    54ea:	685a      	ldr	r2, [r3, #4]
    54ec:	9b05      	ldr	r3, [sp, #20]
    54ee:	f003 030f 	and.w	r3, r3, #15
    54f2:	4906      	ldr	r1, [pc, #24]	; (550c <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    54f4:	4313      	orrs	r3, r2
    54f6:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    54f8:	f002 fd54 	bl	7fa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    54fc:	2300      	movs	r3, #0
    54fe:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    5500:	9b07      	ldr	r3, [sp, #28]
}
    5502:	4618      	mov	r0, r3
    5504:	b009      	add	sp, #36	; 0x24
    5506:	f85d fb04 	ldr.w	pc, [sp], #4
    550a:	bf00      	nop
    550c:	40048000 	.word	0x40048000

00005510 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    5510:	b500      	push	{lr}
    5512:	b087      	sub	sp, #28
    5514:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    5516:	2300      	movs	r3, #0
    5518:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    551a:	2300      	movs	r3, #0
    551c:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    551e:	2300      	movs	r3, #0
    5520:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    5522:	9b01      	ldr	r3, [sp, #4]
    5524:	68db      	ldr	r3, [r3, #12]
    5526:	2b02      	cmp	r3, #2
    5528:	d00a      	beq.n	5540 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    552a:	9b05      	ldr	r3, [sp, #20]
    552c:	f043 0302 	orr.w	r3, r3, #2
    5530:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    5532:	9b01      	ldr	r3, [sp, #4]
    5534:	68db      	ldr	r3, [r3, #12]
    5536:	f003 0301 	and.w	r3, r3, #1
    553a:	9a05      	ldr	r2, [sp, #20]
    553c:	4313      	orrs	r3, r2
    553e:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    5540:	9b01      	ldr	r3, [sp, #4]
    5542:	699b      	ldr	r3, [r3, #24]
    5544:	019b      	lsls	r3, r3, #6
    5546:	f003 0340 	and.w	r3, r3, #64	; 0x40
    554a:	9a05      	ldr	r2, [sp, #20]
    554c:	4313      	orrs	r3, r2
    554e:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    5550:	9b01      	ldr	r3, [sp, #4]
    5552:	6a1b      	ldr	r3, [r3, #32]
    5554:	03db      	lsls	r3, r3, #15
    5556:	b29b      	uxth	r3, r3
    5558:	9a05      	ldr	r2, [sp, #20]
    555a:	4313      	orrs	r3, r2
    555c:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    555e:	9b01      	ldr	r3, [sp, #4]
    5560:	7f1b      	ldrb	r3, [r3, #28]
    5562:	2b00      	cmp	r3, #0
    5564:	d001      	beq.n	556a <Port_Ci_Port_Ip_PinInit+0x5a>
    5566:	2310      	movs	r3, #16
    5568:	e000      	b.n	556c <Port_Ci_Port_Ip_PinInit+0x5c>
    556a:	2300      	movs	r3, #0
    556c:	9a05      	ldr	r2, [sp, #20]
    556e:	4313      	orrs	r3, r2
    5570:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    5572:	9b01      	ldr	r3, [sp, #4]
    5574:	691b      	ldr	r3, [r3, #16]
    5576:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    5578:	9b01      	ldr	r3, [sp, #4]
    557a:	6818      	ldr	r0, [r3, #0]
    557c:	9b01      	ldr	r3, [sp, #4]
    557e:	689b      	ldr	r3, [r3, #8]
    5580:	9a04      	ldr	r2, [sp, #16]
    5582:	4619      	mov	r1, r3
    5584:	f7ff ff90 	bl	54a8 <Port_Ci_Port_Ip_ConfigureInterleave>
    5588:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    558a:	9b03      	ldr	r3, [sp, #12]
    558c:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    558e:	9b04      	ldr	r3, [sp, #16]
    5590:	021b      	lsls	r3, r3, #8
    5592:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5596:	9a05      	ldr	r2, [sp, #20]
    5598:	4313      	orrs	r3, r2
    559a:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    559c:	f002 fb3c 	bl	7c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    55a0:	9b01      	ldr	r3, [sp, #4]
    55a2:	681b      	ldr	r3, [r3, #0]
    55a4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    55a8:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    55aa:	9b01      	ldr	r3, [sp, #4]
    55ac:	689b      	ldr	r3, [r3, #8]
    55ae:	2201      	movs	r2, #1
    55b0:	fa02 f303 	lsl.w	r3, r2, r3
    55b4:	43db      	mvns	r3, r3
    55b6:	9a02      	ldr	r2, [sp, #8]
    55b8:	4013      	ands	r3, r2
    55ba:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    55bc:	9b01      	ldr	r3, [sp, #4]
    55be:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    55c2:	2b00      	cmp	r3, #0
    55c4:	d001      	beq.n	55ca <Port_Ci_Port_Ip_PinInit+0xba>
    55c6:	2201      	movs	r2, #1
    55c8:	e000      	b.n	55cc <Port_Ci_Port_Ip_PinInit+0xbc>
    55ca:	2200      	movs	r2, #0
    55cc:	9b01      	ldr	r3, [sp, #4]
    55ce:	689b      	ldr	r3, [r3, #8]
    55d0:	fa02 f303 	lsl.w	r3, r2, r3
    55d4:	9a02      	ldr	r2, [sp, #8]
    55d6:	4313      	orrs	r3, r2
    55d8:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    55da:	9b01      	ldr	r3, [sp, #4]
    55dc:	681b      	ldr	r3, [r3, #0]
    55de:	9a02      	ldr	r2, [sp, #8]
    55e0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    55e4:	f002 fb44 	bl	7c70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    55e8:	9b04      	ldr	r3, [sp, #16]
    55ea:	2b01      	cmp	r3, #1
    55ec:	d16d      	bne.n	56ca <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    55ee:	9b01      	ldr	r3, [sp, #4]
    55f0:	695b      	ldr	r3, [r3, #20]
    55f2:	2b02      	cmp	r3, #2
    55f4:	d138      	bne.n	5668 <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    55f6:	9b01      	ldr	r3, [sp, #4]
    55f8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    55fc:	2b01      	cmp	r3, #1
    55fe:	d10f      	bne.n	5620 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    5600:	f002 fb5c 	bl	7cbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    5604:	9b01      	ldr	r3, [sp, #4]
    5606:	685b      	ldr	r3, [r3, #4]
    5608:	6859      	ldr	r1, [r3, #4]
    560a:	9b01      	ldr	r3, [sp, #4]
    560c:	689b      	ldr	r3, [r3, #8]
    560e:	2201      	movs	r2, #1
    5610:	409a      	lsls	r2, r3
    5612:	9b01      	ldr	r3, [sp, #4]
    5614:	685b      	ldr	r3, [r3, #4]
    5616:	430a      	orrs	r2, r1
    5618:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    561a:	f002 fb7b 	bl	7d14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    561e:	e013      	b.n	5648 <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    5620:	9b01      	ldr	r3, [sp, #4]
    5622:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    5626:	2b00      	cmp	r3, #0
    5628:	d10e      	bne.n	5648 <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    562a:	f002 fb99 	bl	7d60 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    562e:	9b01      	ldr	r3, [sp, #4]
    5630:	685b      	ldr	r3, [r3, #4]
    5632:	6899      	ldr	r1, [r3, #8]
    5634:	9b01      	ldr	r3, [sp, #4]
    5636:	689b      	ldr	r3, [r3, #8]
    5638:	2201      	movs	r2, #1
    563a:	409a      	lsls	r2, r3
    563c:	9b01      	ldr	r3, [sp, #4]
    563e:	685b      	ldr	r3, [r3, #4]
    5640:	430a      	orrs	r2, r1
    5642:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    5644:	f002 fbb8 	bl	7db8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    5648:	f002 fbdc 	bl	7e04 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    564c:	9b01      	ldr	r3, [sp, #4]
    564e:	685b      	ldr	r3, [r3, #4]
    5650:	6959      	ldr	r1, [r3, #20]
    5652:	9b01      	ldr	r3, [sp, #4]
    5654:	689b      	ldr	r3, [r3, #8]
    5656:	2201      	movs	r2, #1
    5658:	409a      	lsls	r2, r3
    565a:	9b01      	ldr	r3, [sp, #4]
    565c:	685b      	ldr	r3, [r3, #4]
    565e:	430a      	orrs	r2, r1
    5660:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    5662:	f002 fbfb 	bl	7e5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    5666:	e030      	b.n	56ca <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    5668:	f002 fbcc 	bl	7e04 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    566c:	9b01      	ldr	r3, [sp, #4]
    566e:	685b      	ldr	r3, [r3, #4]
    5670:	6959      	ldr	r1, [r3, #20]
    5672:	9b01      	ldr	r3, [sp, #4]
    5674:	689b      	ldr	r3, [r3, #8]
    5676:	2201      	movs	r2, #1
    5678:	fa02 f303 	lsl.w	r3, r2, r3
    567c:	43da      	mvns	r2, r3
    567e:	9b01      	ldr	r3, [sp, #4]
    5680:	685b      	ldr	r3, [r3, #4]
    5682:	400a      	ands	r2, r1
    5684:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    5686:	f002 fbe9 	bl	7e5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    568a:	f002 fc0d 	bl	7ea8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    568e:	9b01      	ldr	r3, [sp, #4]
    5690:	685b      	ldr	r3, [r3, #4]
    5692:	6999      	ldr	r1, [r3, #24]
    5694:	9b01      	ldr	r3, [sp, #4]
    5696:	689b      	ldr	r3, [r3, #8]
    5698:	2201      	movs	r2, #1
    569a:	fa02 f303 	lsl.w	r3, r2, r3
    569e:	43da      	mvns	r2, r3
    56a0:	9b01      	ldr	r3, [sp, #4]
    56a2:	685b      	ldr	r3, [r3, #4]
    56a4:	400a      	ands	r2, r1
    56a6:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    56a8:	9b01      	ldr	r3, [sp, #4]
    56aa:	695b      	ldr	r3, [r3, #20]
    56ac:	2b03      	cmp	r3, #3
    56ae:	d10a      	bne.n	56c6 <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    56b0:	9b01      	ldr	r3, [sp, #4]
    56b2:	685b      	ldr	r3, [r3, #4]
    56b4:	6999      	ldr	r1, [r3, #24]
    56b6:	9b01      	ldr	r3, [sp, #4]
    56b8:	689b      	ldr	r3, [r3, #8]
    56ba:	2201      	movs	r2, #1
    56bc:	409a      	lsls	r2, r3
    56be:	9b01      	ldr	r3, [sp, #4]
    56c0:	685b      	ldr	r3, [r3, #4]
    56c2:	430a      	orrs	r2, r1
    56c4:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    56c6:	f002 fc1b 	bl	7f00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    56ca:	9b01      	ldr	r3, [sp, #4]
    56cc:	681b      	ldr	r3, [r3, #0]
    56ce:	9a01      	ldr	r2, [sp, #4]
    56d0:	6892      	ldr	r2, [r2, #8]
    56d2:	9905      	ldr	r1, [sp, #20]
    56d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    56d8:	bf00      	nop
    56da:	b007      	add	sp, #28
    56dc:	f85d fb04 	ldr.w	pc, [sp], #4

000056e0 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    56e0:	b500      	push	{lr}
    56e2:	b085      	sub	sp, #20
    56e4:	9001      	str	r0, [sp, #4]
    56e6:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    56e8:	2300      	movs	r3, #0
    56ea:	9303      	str	r3, [sp, #12]
    56ec:	e00d      	b.n	570a <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    56ee:	9a03      	ldr	r2, [sp, #12]
    56f0:	4613      	mov	r3, r2
    56f2:	009b      	lsls	r3, r3, #2
    56f4:	4413      	add	r3, r2
    56f6:	00db      	lsls	r3, r3, #3
    56f8:	461a      	mov	r2, r3
    56fa:	9b00      	ldr	r3, [sp, #0]
    56fc:	4413      	add	r3, r2
    56fe:	4618      	mov	r0, r3
    5700:	f7ff ff06 	bl	5510 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    5704:	9b03      	ldr	r3, [sp, #12]
    5706:	3301      	adds	r3, #1
    5708:	9303      	str	r3, [sp, #12]
    570a:	9a03      	ldr	r2, [sp, #12]
    570c:	9b01      	ldr	r3, [sp, #4]
    570e:	429a      	cmp	r2, r3
    5710:	d3ed      	bcc.n	56ee <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    5712:	2300      	movs	r3, #0
}
    5714:	4618      	mov	r0, r3
    5716:	b005      	add	sp, #20
    5718:	f85d fb04 	ldr.w	pc, [sp], #4

0000571c <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    571c:	b500      	push	{lr}
    571e:	b087      	sub	sp, #28
    5720:	9003      	str	r0, [sp, #12]
    5722:	9102      	str	r1, [sp, #8]
    5724:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    5726:	9a01      	ldr	r2, [sp, #4]
    5728:	9902      	ldr	r1, [sp, #8]
    572a:	9803      	ldr	r0, [sp, #12]
    572c:	f7ff febc 	bl	54a8 <Port_Ci_Port_Ip_ConfigureInterleave>
    5730:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    5732:	f002 fc5d 	bl	7ff0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    5736:	9b03      	ldr	r3, [sp, #12]
    5738:	9a02      	ldr	r2, [sp, #8]
    573a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    573e:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    5740:	9b04      	ldr	r3, [sp, #16]
    5742:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    5746:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    5748:	9b05      	ldr	r3, [sp, #20]
    574a:	021b      	lsls	r3, r3, #8
    574c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5750:	9a04      	ldr	r2, [sp, #16]
    5752:	4313      	orrs	r3, r2
    5754:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    5756:	9b03      	ldr	r3, [sp, #12]
    5758:	9a02      	ldr	r2, [sp, #8]
    575a:	9904      	ldr	r1, [sp, #16]
    575c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    5760:	f002 fc72 	bl	8048 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    5764:	bf00      	nop
    5766:	b007      	add	sp, #28
    5768:	f85d fb04 	ldr.w	pc, [sp], #4

0000576c <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    576c:	b500      	push	{lr}
    576e:	b083      	sub	sp, #12
    5770:	9001      	str	r0, [sp, #4]
    5772:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    5774:	f002 fc8e 	bl	8094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    5778:	9b01      	ldr	r3, [sp, #4]
    577a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    577e:	2101      	movs	r1, #1
    5780:	9b00      	ldr	r3, [sp, #0]
    5782:	fa01 f303 	lsl.w	r3, r1, r3
    5786:	431a      	orrs	r2, r3
    5788:	9b01      	ldr	r3, [sp, #4]
    578a:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    578e:	f002 fcad 	bl	80ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    5792:	bf00      	nop
    5794:	b003      	add	sp, #12
    5796:	f85d fb04 	ldr.w	pc, [sp], #4

0000579a <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    579a:	b500      	push	{lr}
    579c:	b083      	sub	sp, #12
    579e:	9001      	str	r0, [sp, #4]
    57a0:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    57a2:	f002 fcc9 	bl	8138 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    57a6:	9b01      	ldr	r3, [sp, #4]
    57a8:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    57ac:	2101      	movs	r1, #1
    57ae:	9b00      	ldr	r3, [sp, #0]
    57b0:	fa01 f303 	lsl.w	r3, r1, r3
    57b4:	43db      	mvns	r3, r3
    57b6:	401a      	ands	r2, r3
    57b8:	9b01      	ldr	r3, [sp, #4]
    57ba:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    57be:	f002 fce7 	bl	8190 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    57c2:	bf00      	nop
    57c4:	b003      	add	sp, #12
    57c6:	f85d fb04 	ldr.w	pc, [sp], #4

000057ca <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    57ca:	b082      	sub	sp, #8
    57cc:	9001      	str	r0, [sp, #4]
    57ce:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    57d0:	9b00      	ldr	r3, [sp, #0]
    57d2:	785b      	ldrb	r3, [r3, #1]
    57d4:	f003 0201 	and.w	r2, r3, #1
    57d8:	9b01      	ldr	r3, [sp, #4]
    57da:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    57de:	9b00      	ldr	r3, [sp, #0]
    57e0:	789b      	ldrb	r3, [r3, #2]
    57e2:	f003 021f 	and.w	r2, r3, #31
    57e6:	9b01      	ldr	r3, [sp, #4]
    57e8:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    57ec:	bf00      	nop
    57ee:	b002      	add	sp, #8
    57f0:	4770      	bx	lr

000057f2 <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    57f2:	b086      	sub	sp, #24
    57f4:	9003      	str	r0, [sp, #12]
    57f6:	9301      	str	r3, [sp, #4]
    57f8:	460b      	mov	r3, r1
    57fa:	f8ad 300a 	strh.w	r3, [sp, #10]
    57fe:	4613      	mov	r3, r2
    5800:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    5804:	2300      	movs	r3, #0
    5806:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    580a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    580e:	f043 0301 	orr.w	r3, r3, #1
    5812:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    5816:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    581a:	f043 0302 	orr.w	r3, r3, #2
    581e:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    5822:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5826:	f043 0310 	orr.w	r3, r3, #16
    582a:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    582e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5832:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5836:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    583a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    583e:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    5842:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    5846:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    584a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    584e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    5852:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    5856:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    585a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    585e:	4013      	ands	r3, r2
    5860:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    5864:	9b01      	ldr	r3, [sp, #4]
    5866:	2b00      	cmp	r3, #0
    5868:	d003      	beq.n	5872 <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    586a:	9b01      	ldr	r3, [sp, #4]
    586c:	2b01      	cmp	r3, #1
    586e:	d00a      	beq.n	5886 <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    5870:	e013      	b.n	589a <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    5872:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5876:	041a      	lsls	r2, r3, #16
    5878:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    587c:	431a      	orrs	r2, r3
    587e:	9b03      	ldr	r3, [sp, #12]
    5880:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    5884:	e009      	b.n	589a <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    5886:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    588a:	041a      	lsls	r2, r3, #16
    588c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5890:	431a      	orrs	r2, r3
    5892:	9b03      	ldr	r3, [sp, #12]
    5894:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    5898:	bf00      	nop
    }
}
    589a:	bf00      	nop
    589c:	b006      	add	sp, #24
    589e:	4770      	bx	lr

000058a0 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    58a0:	b500      	push	{lr}
    58a2:	b087      	sub	sp, #28
    58a4:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    58a6:	9b01      	ldr	r3, [sp, #4]
    58a8:	885b      	ldrh	r3, [r3, #2]
    58aa:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    58ae:	9b01      	ldr	r3, [sp, #4]
    58b0:	689b      	ldr	r3, [r3, #8]
    58b2:	7a1b      	ldrb	r3, [r3, #8]
    58b4:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    58b8:	9b01      	ldr	r3, [sp, #4]
    58ba:	689b      	ldr	r3, [r3, #8]
    58bc:	681b      	ldr	r3, [r3, #0]
    58be:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    58c0:	9b01      	ldr	r3, [sp, #4]
    58c2:	689b      	ldr	r3, [r3, #8]
    58c4:	685b      	ldr	r3, [r3, #4]
    58c6:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    58c8:	2300      	movs	r3, #0
    58ca:	f8ad 3016 	strh.w	r3, [sp, #22]
    58ce:	e111      	b.n	5af4 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    58d0:	9b02      	ldr	r3, [sp, #8]
    58d2:	2b02      	cmp	r3, #2
    58d4:	d169      	bne.n	59aa <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    58d6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    58da:	2b01      	cmp	r3, #1
    58dc:	d11a      	bne.n	5914 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    58de:	9b01      	ldr	r3, [sp, #4]
    58e0:	685a      	ldr	r2, [r3, #4]
    58e2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    58e6:	005b      	lsls	r3, r3, #1
    58e8:	4413      	add	r3, r2
    58ea:	881b      	ldrh	r3, [r3, #0]
    58ec:	f003 021f 	and.w	r2, r3, #31
    58f0:	9b01      	ldr	r3, [sp, #4]
    58f2:	6859      	ldr	r1, [r3, #4]
    58f4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    58f8:	005b      	lsls	r3, r3, #1
    58fa:	440b      	add	r3, r1
    58fc:	881b      	ldrh	r3, [r3, #0]
    58fe:	095b      	lsrs	r3, r3, #5
    5900:	b29b      	uxth	r3, r3
    5902:	4619      	mov	r1, r3
    5904:	4b81      	ldr	r3, [pc, #516]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5906:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    590a:	2101      	movs	r1, #1
    590c:	fa01 f202 	lsl.w	r2, r1, r2
    5910:	605a      	str	r2, [r3, #4]
    5912:	e01d      	b.n	5950 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    5914:	f89d 3013 	ldrb.w	r3, [sp, #19]
    5918:	2b00      	cmp	r3, #0
    591a:	d119      	bne.n	5950 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    591c:	9b01      	ldr	r3, [sp, #4]
    591e:	685a      	ldr	r2, [r3, #4]
    5920:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5924:	005b      	lsls	r3, r3, #1
    5926:	4413      	add	r3, r2
    5928:	881b      	ldrh	r3, [r3, #0]
    592a:	f003 021f 	and.w	r2, r3, #31
    592e:	9b01      	ldr	r3, [sp, #4]
    5930:	6859      	ldr	r1, [r3, #4]
    5932:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5936:	005b      	lsls	r3, r3, #1
    5938:	440b      	add	r3, r1
    593a:	881b      	ldrh	r3, [r3, #0]
    593c:	095b      	lsrs	r3, r3, #5
    593e:	b29b      	uxth	r3, r3
    5940:	4619      	mov	r1, r3
    5942:	4b72      	ldr	r3, [pc, #456]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5944:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5948:	2101      	movs	r1, #1
    594a:	fa01 f202 	lsl.w	r2, r1, r2
    594e:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    5950:	f002 fc44 	bl	81dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5954:	9b01      	ldr	r3, [sp, #4]
    5956:	685a      	ldr	r2, [r3, #4]
    5958:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    595c:	005b      	lsls	r3, r3, #1
    595e:	4413      	add	r3, r2
    5960:	881b      	ldrh	r3, [r3, #0]
    5962:	095b      	lsrs	r3, r3, #5
    5964:	b29b      	uxth	r3, r3
    5966:	461a      	mov	r2, r3
    5968:	4b68      	ldr	r3, [pc, #416]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    596a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    596e:	6959      	ldr	r1, [r3, #20]
    5970:	9b01      	ldr	r3, [sp, #4]
    5972:	685a      	ldr	r2, [r3, #4]
    5974:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5978:	005b      	lsls	r3, r3, #1
    597a:	4413      	add	r3, r2
    597c:	881b      	ldrh	r3, [r3, #0]
    597e:	f003 031f 	and.w	r3, r3, #31
    5982:	2201      	movs	r2, #1
    5984:	409a      	lsls	r2, r3
    5986:	9b01      	ldr	r3, [sp, #4]
    5988:	6858      	ldr	r0, [r3, #4]
    598a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    598e:	005b      	lsls	r3, r3, #1
    5990:	4403      	add	r3, r0
    5992:	881b      	ldrh	r3, [r3, #0]
    5994:	095b      	lsrs	r3, r3, #5
    5996:	b29b      	uxth	r3, r3
    5998:	4618      	mov	r0, r3
    599a:	4b5c      	ldr	r3, [pc, #368]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    599c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    59a0:	430a      	orrs	r2, r1
    59a2:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    59a4:	f002 fc46 	bl	8234 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    59a8:	e086      	b.n	5ab8 <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    59aa:	f002 fc17 	bl	81dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    59ae:	9b01      	ldr	r3, [sp, #4]
    59b0:	685a      	ldr	r2, [r3, #4]
    59b2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    59b6:	005b      	lsls	r3, r3, #1
    59b8:	4413      	add	r3, r2
    59ba:	881b      	ldrh	r3, [r3, #0]
    59bc:	095b      	lsrs	r3, r3, #5
    59be:	b29b      	uxth	r3, r3
    59c0:	461a      	mov	r2, r3
    59c2:	4b52      	ldr	r3, [pc, #328]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    59c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    59c8:	6959      	ldr	r1, [r3, #20]
    59ca:	9b01      	ldr	r3, [sp, #4]
    59cc:	685a      	ldr	r2, [r3, #4]
    59ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    59d2:	005b      	lsls	r3, r3, #1
    59d4:	4413      	add	r3, r2
    59d6:	881b      	ldrh	r3, [r3, #0]
    59d8:	f003 031f 	and.w	r3, r3, #31
    59dc:	2201      	movs	r2, #1
    59de:	fa02 f303 	lsl.w	r3, r2, r3
    59e2:	43da      	mvns	r2, r3
    59e4:	9b01      	ldr	r3, [sp, #4]
    59e6:	6858      	ldr	r0, [r3, #4]
    59e8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    59ec:	005b      	lsls	r3, r3, #1
    59ee:	4403      	add	r3, r0
    59f0:	881b      	ldrh	r3, [r3, #0]
    59f2:	095b      	lsrs	r3, r3, #5
    59f4:	b29b      	uxth	r3, r3
    59f6:	4618      	mov	r0, r3
    59f8:	4b44      	ldr	r3, [pc, #272]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    59fa:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    59fe:	400a      	ands	r2, r1
    5a00:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    5a02:	f002 fc17 	bl	8234 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    5a06:	f002 fc3b 	bl	8280 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5a0a:	9b01      	ldr	r3, [sp, #4]
    5a0c:	685a      	ldr	r2, [r3, #4]
    5a0e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a12:	005b      	lsls	r3, r3, #1
    5a14:	4413      	add	r3, r2
    5a16:	881b      	ldrh	r3, [r3, #0]
    5a18:	095b      	lsrs	r3, r3, #5
    5a1a:	b29b      	uxth	r3, r3
    5a1c:	461a      	mov	r2, r3
    5a1e:	4b3b      	ldr	r3, [pc, #236]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5a20:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5a24:	6999      	ldr	r1, [r3, #24]
    5a26:	9b01      	ldr	r3, [sp, #4]
    5a28:	685a      	ldr	r2, [r3, #4]
    5a2a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a2e:	005b      	lsls	r3, r3, #1
    5a30:	4413      	add	r3, r2
    5a32:	881b      	ldrh	r3, [r3, #0]
    5a34:	f003 031f 	and.w	r3, r3, #31
    5a38:	2201      	movs	r2, #1
    5a3a:	fa02 f303 	lsl.w	r3, r2, r3
    5a3e:	43da      	mvns	r2, r3
    5a40:	9b01      	ldr	r3, [sp, #4]
    5a42:	6858      	ldr	r0, [r3, #4]
    5a44:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a48:	005b      	lsls	r3, r3, #1
    5a4a:	4403      	add	r3, r0
    5a4c:	881b      	ldrh	r3, [r3, #0]
    5a4e:	095b      	lsrs	r3, r3, #5
    5a50:	b29b      	uxth	r3, r3
    5a52:	4618      	mov	r0, r3
    5a54:	4b2d      	ldr	r3, [pc, #180]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5a56:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5a5a:	400a      	ands	r2, r1
    5a5c:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    5a5e:	9b02      	ldr	r3, [sp, #8]
    5a60:	2b03      	cmp	r3, #3
    5a62:	d127      	bne.n	5ab4 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5a64:	9b01      	ldr	r3, [sp, #4]
    5a66:	685a      	ldr	r2, [r3, #4]
    5a68:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a6c:	005b      	lsls	r3, r3, #1
    5a6e:	4413      	add	r3, r2
    5a70:	881b      	ldrh	r3, [r3, #0]
    5a72:	095b      	lsrs	r3, r3, #5
    5a74:	b29b      	uxth	r3, r3
    5a76:	461a      	mov	r2, r3
    5a78:	4b24      	ldr	r3, [pc, #144]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5a7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5a7e:	6999      	ldr	r1, [r3, #24]
    5a80:	9b01      	ldr	r3, [sp, #4]
    5a82:	685a      	ldr	r2, [r3, #4]
    5a84:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a88:	005b      	lsls	r3, r3, #1
    5a8a:	4413      	add	r3, r2
    5a8c:	881b      	ldrh	r3, [r3, #0]
    5a8e:	f003 031f 	and.w	r3, r3, #31
    5a92:	2201      	movs	r2, #1
    5a94:	409a      	lsls	r2, r3
    5a96:	9b01      	ldr	r3, [sp, #4]
    5a98:	6858      	ldr	r0, [r3, #4]
    5a9a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5a9e:	005b      	lsls	r3, r3, #1
    5aa0:	4403      	add	r3, r0
    5aa2:	881b      	ldrh	r3, [r3, #0]
    5aa4:	095b      	lsrs	r3, r3, #5
    5aa6:	b29b      	uxth	r3, r3
    5aa8:	4618      	mov	r0, r3
    5aaa:	4b18      	ldr	r3, [pc, #96]	; (5b0c <Port_Ipw_Init_UnusedPins+0x26c>)
    5aac:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5ab0:	430a      	orrs	r2, r1
    5ab2:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    5ab4:	f002 fc10 	bl	82d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    5ab8:	9b01      	ldr	r3, [sp, #4]
    5aba:	685a      	ldr	r2, [r3, #4]
    5abc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5ac0:	005b      	lsls	r3, r3, #1
    5ac2:	4413      	add	r3, r2
    5ac4:	881b      	ldrh	r3, [r3, #0]
    5ac6:	095b      	lsrs	r3, r3, #5
    5ac8:	b29b      	uxth	r3, r3
    5aca:	461a      	mov	r2, r3
    5acc:	4b10      	ldr	r3, [pc, #64]	; (5b10 <Port_Ipw_Init_UnusedPins+0x270>)
    5ace:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5ad2:	9a01      	ldr	r2, [sp, #4]
    5ad4:	6851      	ldr	r1, [r2, #4]
    5ad6:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    5ada:	0052      	lsls	r2, r2, #1
    5adc:	440a      	add	r2, r1
    5ade:	8812      	ldrh	r2, [r2, #0]
    5ae0:	f002 021f 	and.w	r2, r2, #31
    5ae4:	9903      	ldr	r1, [sp, #12]
    5ae6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    5aea:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5aee:	3301      	adds	r3, #1
    5af0:	f8ad 3016 	strh.w	r3, [sp, #22]
    5af4:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    5af8:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    5afc:	429a      	cmp	r2, r3
    5afe:	f4ff aee7 	bcc.w	58d0 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    5b02:	bf00      	nop
    5b04:	bf00      	nop
    5b06:	b007      	add	sp, #28
    5b08:	f85d fb04 	ldr.w	pc, [sp], #4
    5b0c:	0000a1d0 	.word	0x0000a1d0
    5b10:	0000a1bc 	.word	0x0000a1bc

00005b14 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    5b14:	b500      	push	{lr}
    5b16:	b085      	sub	sp, #20
    5b18:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    5b1a:	9b01      	ldr	r3, [sp, #4]
    5b1c:	7c1b      	ldrb	r3, [r3, #16]
    5b1e:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5b22:	2300      	movs	r3, #0
    5b24:	f8ad 300e 	strh.w	r3, [sp, #14]
    5b28:	e035      	b.n	5b96 <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    5b2a:	9b01      	ldr	r3, [sp, #4]
    5b2c:	695a      	ldr	r2, [r3, #20]
    5b2e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b32:	00db      	lsls	r3, r3, #3
    5b34:	4413      	add	r3, r2
    5b36:	781b      	ldrb	r3, [r3, #0]
    5b38:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    5b3c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5b40:	4a1f      	ldr	r2, [pc, #124]	; (5bc0 <Port_Ipw_Init+0xac>)
    5b42:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    5b46:	9b01      	ldr	r3, [sp, #4]
    5b48:	695a      	ldr	r2, [r3, #20]
    5b4a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b4e:	00db      	lsls	r3, r3, #3
    5b50:	4413      	add	r3, r2
    5b52:	4619      	mov	r1, r3
    5b54:	f7ff fe39 	bl	57ca <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    5b58:	f002 fd2c 	bl	85b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    5b5c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5b60:	4a17      	ldr	r2, [pc, #92]	; (5bc0 <Port_Ipw_Init+0xac>)
    5b62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b66:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    5b6a:	9b01      	ldr	r3, [sp, #4]
    5b6c:	695a      	ldr	r2, [r3, #20]
    5b6e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b72:	00db      	lsls	r3, r3, #3
    5b74:	4413      	add	r3, r2
    5b76:	685a      	ldr	r2, [r3, #4]
    5b78:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5b7c:	4810      	ldr	r0, [pc, #64]	; (5bc0 <Port_Ipw_Init+0xac>)
    5b7e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5b82:	430a      	orrs	r2, r1
    5b84:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    5b88:	f002 fd40 	bl	860c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5b8c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b90:	3301      	adds	r3, #1
    5b92:	f8ad 300e 	strh.w	r3, [sp, #14]
    5b96:	f89d 300d 	ldrb.w	r3, [sp, #13]
    5b9a:	b29b      	uxth	r3, r3
    5b9c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5ba0:	429a      	cmp	r2, r3
    5ba2:	d3c2      	bcc.n	5b2a <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    5ba4:	9b01      	ldr	r3, [sp, #4]
    5ba6:	6a1b      	ldr	r3, [r3, #32]
    5ba8:	4619      	mov	r1, r3
    5baa:	2004      	movs	r0, #4
    5bac:	f7ff fd98 	bl	56e0 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    5bb0:	9801      	ldr	r0, [sp, #4]
    5bb2:	f7ff fe75 	bl	58a0 <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    5bb6:	bf00      	nop
    5bb8:	b005      	add	sp, #20
    5bba:	f85d fb04 	ldr.w	pc, [sp], #4
    5bbe:	bf00      	nop
    5bc0:	0000a1bc 	.word	0x0000a1bc

00005bc4 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    5bc4:	b500      	push	{lr}
    5bc6:	b085      	sub	sp, #20
    5bc8:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    5bca:	9b01      	ldr	r3, [sp, #4]
    5bcc:	881b      	ldrh	r3, [r3, #0]
    5bce:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    5bd2:	2300      	movs	r3, #0
    5bd4:	f8ad 300e 	strh.w	r3, [sp, #14]
    5bd8:	e0d2      	b.n	5d80 <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    5bda:	9b01      	ldr	r3, [sp, #4]
    5bdc:	68d9      	ldr	r1, [r3, #12]
    5bde:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5be2:	4613      	mov	r3, r2
    5be4:	009b      	lsls	r3, r3, #2
    5be6:	4413      	add	r3, r2
    5be8:	009b      	lsls	r3, r3, #2
    5bea:	440b      	add	r3, r1
    5bec:	7c5b      	ldrb	r3, [r3, #17]
    5bee:	f083 0301 	eor.w	r3, r3, #1
    5bf2:	b2db      	uxtb	r3, r3
    5bf4:	2b00      	cmp	r3, #0
    5bf6:	f000 80be 	beq.w	5d76 <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    5bfa:	9b01      	ldr	r3, [sp, #4]
    5bfc:	68d9      	ldr	r1, [r3, #12]
    5bfe:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5c02:	4613      	mov	r3, r2
    5c04:	009b      	lsls	r3, r3, #2
    5c06:	4413      	add	r3, r2
    5c08:	009b      	lsls	r3, r3, #2
    5c0a:	440b      	add	r3, r1
    5c0c:	7c1b      	ldrb	r3, [r3, #16]
    5c0e:	2b00      	cmp	r3, #0
    5c10:	f000 80b1 	beq.w	5d76 <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    5c14:	9b01      	ldr	r3, [sp, #4]
    5c16:	68d9      	ldr	r1, [r3, #12]
    5c18:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5c1c:	4613      	mov	r3, r2
    5c1e:	009b      	lsls	r3, r3, #2
    5c20:	4413      	add	r3, r2
    5c22:	009b      	lsls	r3, r3, #2
    5c24:	440b      	add	r3, r1
    5c26:	881b      	ldrh	r3, [r3, #0]
    5c28:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    5c2c:	9b01      	ldr	r3, [sp, #4]
    5c2e:	68d9      	ldr	r1, [r3, #12]
    5c30:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5c34:	4613      	mov	r3, r2
    5c36:	009b      	lsls	r3, r3, #2
    5c38:	4413      	add	r3, r2
    5c3a:	009b      	lsls	r3, r3, #2
    5c3c:	440b      	add	r3, r1
    5c3e:	68db      	ldr	r3, [r3, #12]
    5c40:	2b02      	cmp	r3, #2
    5c42:	d11d      	bne.n	5c80 <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    5c44:	f002 fdfe 	bl	8844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5c48:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5c4c:	095b      	lsrs	r3, r3, #5
    5c4e:	b29b      	uxth	r3, r3
    5c50:	461a      	mov	r2, r3
    5c52:	4b51      	ldr	r3, [pc, #324]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5c54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5c58:	6959      	ldr	r1, [r3, #20]
    5c5a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5c5e:	f003 031f 	and.w	r3, r3, #31
    5c62:	2201      	movs	r2, #1
    5c64:	409a      	lsls	r2, r3
    5c66:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5c6a:	095b      	lsrs	r3, r3, #5
    5c6c:	b29b      	uxth	r3, r3
    5c6e:	4618      	mov	r0, r3
    5c70:	4b49      	ldr	r3, [pc, #292]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5c72:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5c76:	430a      	orrs	r2, r1
    5c78:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    5c7a:	f002 fe0f 	bl	889c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    5c7e:	e07a      	b.n	5d76 <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    5c80:	9b01      	ldr	r3, [sp, #4]
    5c82:	68d9      	ldr	r1, [r3, #12]
    5c84:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5c88:	4613      	mov	r3, r2
    5c8a:	009b      	lsls	r3, r3, #2
    5c8c:	4413      	add	r3, r2
    5c8e:	009b      	lsls	r3, r3, #2
    5c90:	440b      	add	r3, r1
    5c92:	68db      	ldr	r3, [r3, #12]
    5c94:	2b01      	cmp	r3, #1
    5c96:	d00b      	beq.n	5cb0 <Port_Ipw_RefreshPortDirection+0xec>
    5c98:	9b01      	ldr	r3, [sp, #4]
    5c9a:	68d9      	ldr	r1, [r3, #12]
    5c9c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5ca0:	4613      	mov	r3, r2
    5ca2:	009b      	lsls	r3, r3, #2
    5ca4:	4413      	add	r3, r2
    5ca6:	009b      	lsls	r3, r3, #2
    5ca8:	440b      	add	r3, r1
    5caa:	68db      	ldr	r3, [r3, #12]
    5cac:	2b03      	cmp	r3, #3
    5cae:	d162      	bne.n	5d76 <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    5cb0:	f002 fdc8 	bl	8844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5cb4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5cb8:	095b      	lsrs	r3, r3, #5
    5cba:	b29b      	uxth	r3, r3
    5cbc:	461a      	mov	r2, r3
    5cbe:	4b36      	ldr	r3, [pc, #216]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5cc0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5cc4:	6959      	ldr	r1, [r3, #20]
    5cc6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5cca:	f003 031f 	and.w	r3, r3, #31
    5cce:	2201      	movs	r2, #1
    5cd0:	fa02 f303 	lsl.w	r3, r2, r3
    5cd4:	43da      	mvns	r2, r3
    5cd6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5cda:	095b      	lsrs	r3, r3, #5
    5cdc:	b29b      	uxth	r3, r3
    5cde:	4618      	mov	r0, r3
    5ce0:	4b2d      	ldr	r3, [pc, #180]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5ce2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5ce6:	400a      	ands	r2, r1
    5ce8:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    5cea:	f002 fdd7 	bl	889c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    5cee:	f002 fdfb 	bl	88e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5cf2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5cf6:	095b      	lsrs	r3, r3, #5
    5cf8:	b29b      	uxth	r3, r3
    5cfa:	461a      	mov	r2, r3
    5cfc:	4b26      	ldr	r3, [pc, #152]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5cfe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5d02:	6999      	ldr	r1, [r3, #24]
    5d04:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5d08:	f003 031f 	and.w	r3, r3, #31
    5d0c:	2201      	movs	r2, #1
    5d0e:	fa02 f303 	lsl.w	r3, r2, r3
    5d12:	43da      	mvns	r2, r3
    5d14:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5d18:	095b      	lsrs	r3, r3, #5
    5d1a:	b29b      	uxth	r3, r3
    5d1c:	4618      	mov	r0, r3
    5d1e:	4b1e      	ldr	r3, [pc, #120]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5d20:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5d24:	400a      	ands	r2, r1
    5d26:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    5d28:	9b01      	ldr	r3, [sp, #4]
    5d2a:	68d9      	ldr	r1, [r3, #12]
    5d2c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5d30:	4613      	mov	r3, r2
    5d32:	009b      	lsls	r3, r3, #2
    5d34:	4413      	add	r3, r2
    5d36:	009b      	lsls	r3, r3, #2
    5d38:	440b      	add	r3, r1
    5d3a:	68db      	ldr	r3, [r3, #12]
    5d3c:	2b03      	cmp	r3, #3
    5d3e:	d118      	bne.n	5d72 <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5d40:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5d44:	095b      	lsrs	r3, r3, #5
    5d46:	b29b      	uxth	r3, r3
    5d48:	461a      	mov	r2, r3
    5d4a:	4b13      	ldr	r3, [pc, #76]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5d4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5d50:	6999      	ldr	r1, [r3, #24]
    5d52:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5d56:	f003 031f 	and.w	r3, r3, #31
    5d5a:	2201      	movs	r2, #1
    5d5c:	409a      	lsls	r2, r3
    5d5e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5d62:	095b      	lsrs	r3, r3, #5
    5d64:	b29b      	uxth	r3, r3
    5d66:	4618      	mov	r0, r3
    5d68:	4b0b      	ldr	r3, [pc, #44]	; (5d98 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5d6a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5d6e:	430a      	orrs	r2, r1
    5d70:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    5d72:	f002 fde5 	bl	8940 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    5d76:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5d7a:	3301      	adds	r3, #1
    5d7c:	f8ad 300e 	strh.w	r3, [sp, #14]
    5d80:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5d84:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    5d88:	429a      	cmp	r2, r3
    5d8a:	f4ff af26 	bcc.w	5bda <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    5d8e:	bf00      	nop
    5d90:	bf00      	nop
    5d92:	b005      	add	sp, #20
    5d94:	f85d fb04 	ldr.w	pc, [sp], #4
    5d98:	0000a1d0 	.word	0x0000a1d0

00005d9c <Lpspi_Ip_ChannelFinished>:
* @param[in]     Instance            Index of the hardware instance.
* @param[in]     ErrorFlag           Save the status of transfer error flags
* @return void
*/
static void Lpspi_Ip_ChannelFinished(uint8 Instance, boolean ErrorFlag)
{
    5d9c:	b500      	push	{lr}
    5d9e:	b085      	sub	sp, #20
    5da0:	4603      	mov	r3, r0
    5da2:	460a      	mov	r2, r1
    5da4:	f88d 3007 	strb.w	r3, [sp, #7]
    5da8:	4613      	mov	r3, r2
    5daa:	f88d 3006 	strb.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    5dae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5db2:	4a12      	ldr	r2, [pc, #72]	; (5dfc <Lpspi_Ip_ChannelFinished+0x60>)
    5db4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5db8:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_EventType EventState = LPSPI_IP_EVENT_FAULT;
    5dba:	2301      	movs	r3, #1
    5dbc:	9303      	str	r3, [sp, #12]
    
    if(TRUE == ErrorFlag)
    5dbe:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5dc2:	2b00      	cmp	r3, #0
    5dc4:	d005      	beq.n	5dd2 <Lpspi_Ip_ChannelFinished+0x36>
    {
        State->Status = LPSPI_IP_FAULT;
    5dc6:	9b02      	ldr	r3, [sp, #8]
    5dc8:	2203      	movs	r2, #3
    5dca:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_FAULT;
    5dcc:	2301      	movs	r3, #1
    5dce:	9303      	str	r3, [sp, #12]
    5dd0:	e004      	b.n	5ddc <Lpspi_Ip_ChannelFinished+0x40>
    }
    else
    {
        State->Status = LPSPI_IP_IDLE;
    5dd2:	9b02      	ldr	r3, [sp, #8]
    5dd4:	2201      	movs	r2, #1
    5dd6:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_END_TRANSFER;
    5dd8:	2300      	movs	r3, #0
    5dda:	9303      	str	r3, [sp, #12]
    }

    if (NULL_PTR != State->Callback)
    5ddc:	9b02      	ldr	r3, [sp, #8]
    5dde:	691b      	ldr	r3, [r3, #16]
    5de0:	2b00      	cmp	r3, #0
    5de2:	d006      	beq.n	5df2 <Lpspi_Ip_ChannelFinished+0x56>
    {
        State->Callback(Instance, EventState);
    5de4:	9b02      	ldr	r3, [sp, #8]
    5de6:	691b      	ldr	r3, [r3, #16]
    5de8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5dec:	9903      	ldr	r1, [sp, #12]
    5dee:	4610      	mov	r0, r2
    5df0:	4798      	blx	r3
    }
}
    5df2:	bf00      	nop
    5df4:	b005      	add	sp, #20
    5df6:	f85d fb04 	ldr.w	pc, [sp], #4
    5dfa:	bf00      	nop
    5dfc:	1fff8d38 	.word	0x1fff8d38

00005e00 <Lpspi_Ip_TransferProcess>:
*
* @param[in]     Instance      Index of the hardware instance.
* @return void
*/
static void Lpspi_Ip_TransferProcess(uint8 Instance)
{
    5e00:	b510      	push	{r4, lr}
    5e02:	b092      	sub	sp, #72	; 0x48
    5e04:	4603      	mov	r3, r0
    5e06:	f88d 300f 	strb.w	r3, [sp, #15]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    5e0a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5e0e:	4aad      	ldr	r2, [pc, #692]	; (60c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    5e10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e14:	9310      	str	r3, [sp, #64]	; 0x40
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    5e16:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5e1a:	4aab      	ldr	r2, [pc, #684]	; (60c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    5e1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e20:	930f      	str	r3, [sp, #60]	; 0x3c
    uint32 SrStatusRegister;
    uint8 NumberOfWrites = 0u;
    5e22:	2300      	movs	r3, #0
    5e24:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    uint8 NumberOfReads = 0u;
    5e28:	2300      	movs	r3, #0
    5e2a:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
    boolean ErrorFlag = FALSE;
    5e2e:	2300      	movs	r3, #0
    5e30:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45

    if (LPSPI_IP_BUSY == State->Status)
    5e34:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5e36:	685b      	ldr	r3, [r3, #4]
    5e38:	2b02      	cmp	r3, #2
    5e3a:	f040 821e 	bne.w	627a <Lpspi_Ip_TransferProcess+0x47a>
    {
        /* Read Status and clear all flags. */
        SrStatusRegister = Base->SR;
    5e3e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5e40:	695b      	ldr	r3, [r3, #20]
    5e42:	930e      	str	r3, [sp, #56]	; 0x38
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    5e44:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5e46:	695b      	ldr	r3, [r3, #20]
    5e48:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    5e4c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5e4e:	615a      	str	r2, [r3, #20]
        
        if ((SrStatusRegister & (LPSPI_SR_REF_MASK | LPSPI_SR_TEF_MASK)) != 0u)
    5e50:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5e52:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
    5e56:	2b00      	cmp	r3, #0
    5e58:	d003      	beq.n	5e62 <Lpspi_Ip_TransferProcess+0x62>
        {
            /* mark error flag */
            ErrorFlag = TRUE;
    5e5a:	2301      	movs	r3, #1
    5e5c:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    5e60:	e1f6      	b.n	6250 <Lpspi_Ip_TransferProcess+0x450>
        }
        else
        {
            /* RECEIVE */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    5e62:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5e64:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    5e66:	0c1b      	lsrs	r3, r3, #16
    5e68:	b2db      	uxtb	r3, r3
    5e6a:	f003 0307 	and.w	r3, r3, #7
    5e6e:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
            if (NumberOfReads != 0u)
    5e72:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    5e76:	2b00      	cmp	r3, #0
    5e78:	f000 80cb 	beq.w	6012 <Lpspi_Ip_TransferProcess+0x212>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    5e7c:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
    5e80:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5e82:	8b1b      	ldrh	r3, [r3, #24]
    5e84:	4619      	mov	r1, r3
    5e86:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5e88:	8a9b      	ldrh	r3, [r3, #20]
    5e8a:	1acb      	subs	r3, r1, r3
    5e8c:	429a      	cmp	r2, r3
    5e8e:	dd08      	ble.n	5ea2 <Lpspi_Ip_TransferProcess+0xa2>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    5e90:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5e92:	8b1b      	ldrh	r3, [r3, #24]
    5e94:	b2da      	uxtb	r2, r3
    5e96:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5e98:	8a9b      	ldrh	r3, [r3, #20]
    5e9a:	b2db      	uxtb	r3, r3
    5e9c:	1ad3      	subs	r3, r2, r3
    5e9e:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out and
                  CurrentTxFifoSlot was minus 1 when prepare TX channel */
                if (0u == State->RxIndex)
    5ea2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5ea4:	8a9b      	ldrh	r3, [r3, #20]
    5ea6:	2b00      	cmp	r3, #0
    5ea8:	d107      	bne.n	5eba <Lpspi_Ip_TransferProcess+0xba>
                {
                    State->CurrentTxFifoSlot += 1u;
    5eaa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5eac:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    5eb0:	3301      	adds	r3, #1
    5eb2:	b2da      	uxtb	r2, r3
    5eb4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5eb6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    5eba:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5ebe:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    5ec2:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    5ec6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    5eca:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    5ece:	4a7d      	ldr	r2, [pc, #500]	; (60c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    5ed0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ed4:	930c      	str	r3, [sp, #48]	; 0x30
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    5ed6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    5eda:	4a7b      	ldr	r2, [pc, #492]	; (60c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    5edc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ee0:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 Data = 0u;
    5ee2:	2300      	movs	r3, #0
    5ee4:	930a      	str	r3, [sp, #40]	; 0x28
    uint8 Index = 0u;
    5ee6:	2300      	movs	r3, #0
    5ee8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    if (NULL_PTR != State->RxBuffer)
    5eec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5eee:	689b      	ldr	r3, [r3, #8]
    5ef0:	2b00      	cmp	r3, #0
    5ef2:	d069      	beq.n	5fc8 <Lpspi_Ip_TransferProcess+0x1c8>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    5ef4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5ef6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5ef8:	68db      	ldr	r3, [r3, #12]
    5efa:	881b      	ldrh	r3, [r3, #0]
    5efc:	2b08      	cmp	r3, #8
    5efe:	d81e      	bhi.n	5f3e <Lpspi_Ip_TransferProcess+0x13e>
            for (Index = 0; Index < NumberOfReads; Index++)
    5f00:	2300      	movs	r3, #0
    5f02:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5f06:	e013      	b.n	5f30 <Lpspi_Ip_TransferProcess+0x130>
                Data = Base->RDR;
    5f08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5f0a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    5f0c:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    5f0e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f10:	689b      	ldr	r3, [r3, #8]
    5f12:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    5f14:	8a92      	ldrh	r2, [r2, #20]
    5f16:	4611      	mov	r1, r2
    5f18:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    5f1c:	440a      	add	r2, r1
    5f1e:	4413      	add	r3, r2
    5f20:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    5f22:	b2d2      	uxtb	r2, r2
    5f24:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    5f26:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5f2a:	3301      	adds	r3, #1
    5f2c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5f30:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    5f34:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5f38:	429a      	cmp	r2, r3
    5f3a:	d8e5      	bhi.n	5f08 <Lpspi_Ip_TransferProcess+0x108>
    5f3c:	e055      	b.n	5fea <Lpspi_Ip_TransferProcess+0x1ea>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    5f3e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5f42:	68db      	ldr	r3, [r3, #12]
    5f44:	881b      	ldrh	r3, [r3, #0]
    5f46:	2b10      	cmp	r3, #16
    5f48:	d81f      	bhi.n	5f8a <Lpspi_Ip_TransferProcess+0x18a>
            for (Index = 0; Index < NumberOfReads; Index++)
    5f4a:	2300      	movs	r3, #0
    5f4c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5f50:	e014      	b.n	5f7c <Lpspi_Ip_TransferProcess+0x17c>
                Data = Base->RDR;
    5f52:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5f54:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    5f56:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    5f58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f5a:	689a      	ldr	r2, [r3, #8]
    5f5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f5e:	8a9b      	ldrh	r3, [r3, #20]
    5f60:	4619      	mov	r1, r3
    5f62:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5f66:	440b      	add	r3, r1
    5f68:	005b      	lsls	r3, r3, #1
    5f6a:	4413      	add	r3, r2
    5f6c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    5f6e:	b292      	uxth	r2, r2
    5f70:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    5f72:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5f76:	3301      	adds	r3, #1
    5f78:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5f7c:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    5f80:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5f84:	429a      	cmp	r2, r3
    5f86:	d8e4      	bhi.n	5f52 <Lpspi_Ip_TransferProcess+0x152>
    5f88:	e02f      	b.n	5fea <Lpspi_Ip_TransferProcess+0x1ea>
            for (Index = 0; Index < NumberOfReads; Index++)
    5f8a:	2300      	movs	r3, #0
    5f8c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5f90:	e013      	b.n	5fba <Lpspi_Ip_TransferProcess+0x1ba>
                Data = Base->RDR;
    5f92:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5f94:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    5f96:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    5f98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f9a:	689a      	ldr	r2, [r3, #8]
    5f9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5f9e:	8a9b      	ldrh	r3, [r3, #20]
    5fa0:	4619      	mov	r1, r3
    5fa2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5fa6:	440b      	add	r3, r1
    5fa8:	009b      	lsls	r3, r3, #2
    5faa:	4413      	add	r3, r2
    5fac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    5fae:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    5fb0:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5fb4:	3301      	adds	r3, #1
    5fb6:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5fba:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    5fbe:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5fc2:	429a      	cmp	r2, r3
    5fc4:	d8e5      	bhi.n	5f92 <Lpspi_Ip_TransferProcess+0x192>
    5fc6:	e010      	b.n	5fea <Lpspi_Ip_TransferProcess+0x1ea>
        for (Index = 0; Index < NumberOfReads; Index++)
    5fc8:	2300      	movs	r3, #0
    5fca:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5fce:	e006      	b.n	5fde <Lpspi_Ip_TransferProcess+0x1de>
            (void)Base->RDR;
    5fd0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5fd2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    5fd4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5fd8:	3301      	adds	r3, #1
    5fda:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5fde:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    5fe2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    5fe6:	429a      	cmp	r2, r3
    5fe8:	d8f2      	bhi.n	5fd0 <Lpspi_Ip_TransferProcess+0x1d0>
    State->RxIndex += NumberOfReads;
    5fea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5fec:	8a9a      	ldrh	r2, [r3, #20]
    5fee:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    5ff2:	b29b      	uxth	r3, r3
    5ff4:	4413      	add	r3, r2
    5ff6:	b29a      	uxth	r2, r3
    5ff8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5ffa:	829a      	strh	r2, [r3, #20]
}
    5ffc:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    5ffe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6000:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    6004:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    6008:	4413      	add	r3, r2
    600a:	b2da      	uxtb	r2, r3
    600c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    600e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            to fill TX FIFO. At that time, another interrupt occurred and preemptive current interrupt, and the time to process that interrupt is longer than the time to transfer all frames 
            in TX FIFO. So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from that interrupt and fill TX FIFO until full and exist SPI interrupt function. 
            And if there is a interrupt occurred with higher priority of SPI interrupt and the time to process that interrupt is longer than the time to transfer all frames in TX FIFO. 
            So, RX FIFO can be overflow due to SPI interrupt function is not serviced to read RX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (State->TxDoneFlag != TRUE))
    6012:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6014:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6018:	2b00      	cmp	r3, #0
    601a:	f000 8119 	beq.w	6250 <Lpspi_Ip_TransferProcess+0x450>
    601e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6020:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
    6024:	f083 0301 	eor.w	r3, r3, #1
    6028:	b2db      	uxtb	r3, r3
    602a:	2b00      	cmp	r3, #0
    602c:	f000 8110 	beq.w	6250 <Lpspi_Ip_TransferProcess+0x450>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    6030:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6032:	8b5a      	ldrh	r2, [r3, #26]
    6034:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6036:	8adb      	ldrh	r3, [r3, #22]
    6038:	429a      	cmp	r2, r3
    603a:	f000 80ca 	beq.w	61d2 <Lpspi_Ip_TransferProcess+0x3d2>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    603e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6040:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6044:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    6048:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
    604c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    604e:	8b5b      	ldrh	r3, [r3, #26]
    6050:	4619      	mov	r1, r3
    6052:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6054:	8adb      	ldrh	r3, [r3, #22]
    6056:	1acb      	subs	r3, r1, r3
    6058:	429a      	cmp	r2, r3
    605a:	dd08      	ble.n	606e <Lpspi_Ip_TransferProcess+0x26e>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    605c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    605e:	8b5b      	ldrh	r3, [r3, #26]
    6060:	b2da      	uxtb	r2, r3
    6062:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6064:	8adb      	ldrh	r3, [r3, #22]
    6066:	b2db      	uxtb	r3, r3
    6068:	1ad3      	subs	r3, r2, r3
    606a:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    606e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6072:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    6076:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    607a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    607e:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    6082:	4a10      	ldr	r2, [pc, #64]	; (60c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    6084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6088:	9308      	str	r3, [sp, #32]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    608a:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    608e:	4a0e      	ldr	r2, [pc, #56]	; (60c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    6090:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6094:	9307      	str	r3, [sp, #28]
    uint32 Data = 0u;
    6096:	2300      	movs	r3, #0
    6098:	9306      	str	r3, [sp, #24]
    uint8 Index = 0u;
    609a:	2300      	movs	r3, #0
    609c:	f88d 3017 	strb.w	r3, [sp, #23]
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    60a0:	9b07      	ldr	r3, [sp, #28]
    60a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    60a4:	68db      	ldr	r3, [r3, #12]
    60a6:	685b      	ldr	r3, [r3, #4]
    60a8:	9306      	str	r3, [sp, #24]
    if (NULL_PTR != State->TxBuffer)
    60aa:	9b07      	ldr	r3, [sp, #28]
    60ac:	68db      	ldr	r3, [r3, #12]
    60ae:	2b00      	cmp	r3, #0
    60b0:	d068      	beq.n	6184 <Lpspi_Ip_TransferProcess+0x384>
        if (State->TxFrameSize < 9u)
    60b2:	9b07      	ldr	r3, [sp, #28]
    60b4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    60b6:	2b08      	cmp	r3, #8
    60b8:	d822      	bhi.n	6100 <Lpspi_Ip_TransferProcess+0x300>
            for (Index = 0; Index < NumberOfWrites; Index++)
    60ba:	2300      	movs	r3, #0
    60bc:	f88d 3017 	strb.w	r3, [sp, #23]
    60c0:	e017      	b.n	60f2 <Lpspi_Ip_TransferProcess+0x2f2>
    60c2:	bf00      	nop
    60c4:	0000a1e4 	.word	0x0000a1e4
    60c8:	1fff8d38 	.word	0x1fff8d38
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    60cc:	9b07      	ldr	r3, [sp, #28]
    60ce:	68db      	ldr	r3, [r3, #12]
    60d0:	9a07      	ldr	r2, [sp, #28]
    60d2:	8ad2      	ldrh	r2, [r2, #22]
    60d4:	4611      	mov	r1, r2
    60d6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    60da:	440a      	add	r2, r1
    60dc:	4413      	add	r3, r2
    60de:	781b      	ldrb	r3, [r3, #0]
    60e0:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    60e2:	9b08      	ldr	r3, [sp, #32]
    60e4:	9a06      	ldr	r2, [sp, #24]
    60e6:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    60e8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    60ec:	3301      	adds	r3, #1
    60ee:	f88d 3017 	strb.w	r3, [sp, #23]
    60f2:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    60f6:	f89d 3017 	ldrb.w	r3, [sp, #23]
    60fa:	429a      	cmp	r2, r3
    60fc:	d8e6      	bhi.n	60cc <Lpspi_Ip_TransferProcess+0x2cc>
    60fe:	e053      	b.n	61a8 <Lpspi_Ip_TransferProcess+0x3a8>
        else if (State->TxFrameSize < 17u)
    6100:	9b07      	ldr	r3, [sp, #28]
    6102:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    6104:	2b10      	cmp	r3, #16
    6106:	d81e      	bhi.n	6146 <Lpspi_Ip_TransferProcess+0x346>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6108:	2300      	movs	r3, #0
    610a:	f88d 3017 	strb.w	r3, [sp, #23]
    610e:	e013      	b.n	6138 <Lpspi_Ip_TransferProcess+0x338>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    6110:	9b07      	ldr	r3, [sp, #28]
    6112:	68da      	ldr	r2, [r3, #12]
    6114:	9b07      	ldr	r3, [sp, #28]
    6116:	8adb      	ldrh	r3, [r3, #22]
    6118:	4619      	mov	r1, r3
    611a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    611e:	440b      	add	r3, r1
    6120:	005b      	lsls	r3, r3, #1
    6122:	4413      	add	r3, r2
    6124:	881b      	ldrh	r3, [r3, #0]
    6126:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    6128:	9b08      	ldr	r3, [sp, #32]
    612a:	9a06      	ldr	r2, [sp, #24]
    612c:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    612e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6132:	3301      	adds	r3, #1
    6134:	f88d 3017 	strb.w	r3, [sp, #23]
    6138:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    613c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6140:	429a      	cmp	r2, r3
    6142:	d8e5      	bhi.n	6110 <Lpspi_Ip_TransferProcess+0x310>
    6144:	e030      	b.n	61a8 <Lpspi_Ip_TransferProcess+0x3a8>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6146:	2300      	movs	r3, #0
    6148:	f88d 3017 	strb.w	r3, [sp, #23]
    614c:	e013      	b.n	6176 <Lpspi_Ip_TransferProcess+0x376>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    614e:	9b07      	ldr	r3, [sp, #28]
    6150:	68da      	ldr	r2, [r3, #12]
    6152:	9b07      	ldr	r3, [sp, #28]
    6154:	8adb      	ldrh	r3, [r3, #22]
    6156:	4619      	mov	r1, r3
    6158:	f89d 3017 	ldrb.w	r3, [sp, #23]
    615c:	440b      	add	r3, r1
    615e:	009b      	lsls	r3, r3, #2
    6160:	4413      	add	r3, r2
    6162:	681b      	ldr	r3, [r3, #0]
    6164:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    6166:	9b08      	ldr	r3, [sp, #32]
    6168:	9a06      	ldr	r2, [sp, #24]
    616a:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    616c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6170:	3301      	adds	r3, #1
    6172:	f88d 3017 	strb.w	r3, [sp, #23]
    6176:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    617a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    617e:	429a      	cmp	r2, r3
    6180:	d8e5      	bhi.n	614e <Lpspi_Ip_TransferProcess+0x34e>
    6182:	e011      	b.n	61a8 <Lpspi_Ip_TransferProcess+0x3a8>
        for (Index = 0; Index < NumberOfWrites; Index++)
    6184:	2300      	movs	r3, #0
    6186:	f88d 3017 	strb.w	r3, [sp, #23]
    618a:	e007      	b.n	619c <Lpspi_Ip_TransferProcess+0x39c>
            Base->TDR = Data;
    618c:	9b08      	ldr	r3, [sp, #32]
    618e:	9a06      	ldr	r2, [sp, #24]
    6190:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    6192:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6196:	3301      	adds	r3, #1
    6198:	f88d 3017 	strb.w	r3, [sp, #23]
    619c:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    61a0:	f89d 3017 	ldrb.w	r3, [sp, #23]
    61a4:	429a      	cmp	r2, r3
    61a6:	d8f1      	bhi.n	618c <Lpspi_Ip_TransferProcess+0x38c>
    State->TxIndex += NumberOfWrites;
    61a8:	9b07      	ldr	r3, [sp, #28]
    61aa:	8ada      	ldrh	r2, [r3, #22]
    61ac:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    61b0:	b29b      	uxth	r3, r3
    61b2:	4413      	add	r3, r2
    61b4:	b29a      	uxth	r2, r3
    61b6:	9b07      	ldr	r3, [sp, #28]
    61b8:	82da      	strh	r2, [r3, #22]
}
    61ba:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    61bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61be:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    61c2:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    61c6:	1ad3      	subs	r3, r2, r3
    61c8:	b2da      	uxtb	r2, r3
    61ca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61cc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    61d0:	e03e      	b.n	6250 <Lpspi_Ip_TransferProcess+0x450>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    61d2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61d4:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    61d8:	2b00      	cmp	r3, #0
    61da:	d01c      	beq.n	6216 <Lpspi_Ip_TransferProcess+0x416>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    61dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    61e0:	68db      	ldr	r3, [r3, #12]
    61e2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    61e4:	6b52      	ldr	r2, [r2, #52]	; 0x34
    61e6:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    61e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61ea:	2200      	movs	r2, #0
    61ec:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    61ee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61f0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    61f2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61f4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    61f6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61f8:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    61fc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    61fe:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    6200:	f89d 000f 	ldrb.w	r0, [sp, #15]
    6204:	9300      	str	r3, [sp, #0]
    6206:	4623      	mov	r3, r4
    6208:	f000 fb7a 	bl	6900 <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    620c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    620e:	2200      	movs	r2, #0
    6210:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    6214:	e01c      	b.n	6250 <Lpspi_Ip_TransferProcess+0x450>
                    }
                    else
                    {
                        State->TxDoneFlag = TRUE;
    6216:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6218:	2201      	movs	r2, #1
    621a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
                        /* Disable TX interrupt */
                        Base->IER &= ~LPSPI_IER_TDIE_MASK;
    621e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6220:	699b      	ldr	r3, [r3, #24]
    6222:	f023 0201 	bic.w	r2, r3, #1
    6226:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6228:	619a      	str	r2, [r3, #24]
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    622a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    622c:	7f1b      	ldrb	r3, [r3, #28]
    622e:	f083 0301 	eor.w	r3, r3, #1
    6232:	b2db      	uxtb	r3, r3
    6234:	2b00      	cmp	r3, #0
    6236:	d00b      	beq.n	6250 <Lpspi_Ip_TransferProcess+0x450>
    6238:	9b10      	ldr	r3, [sp, #64]	; 0x40
    623a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    623c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    6240:	2b00      	cmp	r3, #0
    6242:	d005      	beq.n	6250 <Lpspi_Ip_TransferProcess+0x450>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    6244:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6246:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6248:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    624c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    624e:	661a      	str	r2, [r3, #96]	; 0x60
                }
            }
        }
        
        /* End of transfer */
        if((State->RxIndex == State->ExpectedFifoReads) || (TRUE == ErrorFlag))
    6250:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6252:	8a9a      	ldrh	r2, [r3, #20]
    6254:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6256:	8b1b      	ldrh	r3, [r3, #24]
    6258:	429a      	cmp	r2, r3
    625a:	d003      	beq.n	6264 <Lpspi_Ip_TransferProcess+0x464>
    625c:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    6260:	2b00      	cmp	r3, #0
    6262:	d00a      	beq.n	627a <Lpspi_Ip_TransferProcess+0x47a>
                Base->TCR |= LPSPI_TCR_RXMSK(1);
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12();
            }
            #endif
            /* Disable interrupts */
            Base->IER = 0u;
    6264:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6266:	2200      	movs	r2, #0
    6268:	619a      	str	r2, [r3, #24]
            Lpspi_Ip_ChannelFinished(Instance, ErrorFlag);
    626a:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    626e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6272:	4611      	mov	r1, r2
    6274:	4618      	mov	r0, r3
    6276:	f7ff fd91 	bl	5d9c <Lpspi_Ip_ChannelFinished>
        }
    }
}
    627a:	bf00      	nop
    627c:	b012      	add	sp, #72	; 0x48
    627e:	bd10      	pop	{r4, pc}

00006280 <Lpspi_Ip_Init>:
    OsIf_Trusted_Call1param(Lpspi_Ip_SetUserAccess, Instance);
}
#endif /* LPSPI_IP_ENABLE_USER_MODE_SUPPORT */
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_Init(const Lpspi_Ip_ConfigType *PhyUnitConfigPtr)
{
    6280:	b500      	push	{lr}
    6282:	b087      	sub	sp, #28
    6284:	9001      	str	r0, [sp, #4]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6286:	2300      	movs	r3, #0
    6288:	9305      	str	r3, [sp, #20]
    uint8 Instance = 0u;
    628a:	2300      	movs	r3, #0
    628c:	f88d 3013 	strb.w	r3, [sp, #19]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(PhyUnitConfigPtr != NULL_PTR);
    #endif
    Instance = PhyUnitConfigPtr->Instance;
    6290:	9b01      	ldr	r3, [sp, #4]
    6292:	781b      	ldrb	r3, [r3, #0]
    6294:	f88d 3013 	strb.w	r3, [sp, #19]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6298:	f89d 3013 	ldrb.w	r3, [sp, #19]
    629c:	4a23      	ldr	r2, [pc, #140]	; (632c <Lpspi_Ip_Init+0xac>)
    629e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62a2:	9303      	str	r3, [sp, #12]
    Base = Lpspi_Ip_apxBases[Instance];
    62a4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    62a8:	4a21      	ldr	r2, [pc, #132]	; (6330 <Lpspi_Ip_Init+0xb0>)
    62aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62ae:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State == NULL_PTR);
    #endif
    Lpspi_Ip_apxStateStructureArray[Instance] = &Lpspi_Ip_axStateStructure[PhyUnitConfigPtr->StateIndex];
    62b0:	9b01      	ldr	r3, [sp, #4]
    62b2:	7c1b      	ldrb	r3, [r3, #16]
    62b4:	461a      	mov	r2, r3
    62b6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    62ba:	0192      	lsls	r2, r2, #6
    62bc:	491d      	ldr	r1, [pc, #116]	; (6334 <Lpspi_Ip_Init+0xb4>)
    62be:	440a      	add	r2, r1
    62c0:	491a      	ldr	r1, [pc, #104]	; (632c <Lpspi_Ip_Init+0xac>)
    62c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    62c6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    62ca:	4a18      	ldr	r2, [pc, #96]	; (632c <Lpspi_Ip_Init+0xac>)
    62cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62d0:	9303      	str	r3, [sp, #12]
    State->PhyUnitConfig = PhyUnitConfigPtr;
    62d2:	9b03      	ldr	r3, [sp, #12]
    62d4:	9a01      	ldr	r2, [sp, #4]
    62d6:	621a      	str	r2, [r3, #32]
    /* enable in debug mode to ensure CS will be kept when CPU halts at breakpoint */
    Base->CR = PhyUnitConfigPtr->Cr | LPSPI_CR_DBGEN_MASK;
    62d8:	9b01      	ldr	r3, [sp, #4]
    62da:	685b      	ldr	r3, [r3, #4]
    62dc:	f043 0208 	orr.w	r2, r3, #8
    62e0:	9b02      	ldr	r3, [sp, #8]
    62e2:	611a      	str	r2, [r3, #16]
    Base->CFGR1 = PhyUnitConfigPtr->Cfgr1;
    62e4:	9b01      	ldr	r3, [sp, #4]
    62e6:	689a      	ldr	r2, [r3, #8]
    62e8:	9b02      	ldr	r3, [sp, #8]
    62ea:	625a      	str	r2, [r3, #36]	; 0x24
    /* Set TX WATER. it will be set again in DMA mode */
    Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    62ec:	9b02      	ldr	r3, [sp, #8]
    62ee:	2203      	movs	r2, #3
    62f0:	659a      	str	r2, [r3, #88]	; 0x58
    #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    State->ClockMode = LPSPI_IP_NORMAL_CLOCK;
    #endif
    State->KeepCs = FALSE;
    62f2:	9b03      	ldr	r3, [sp, #12]
    62f4:	2200      	movs	r2, #0
    62f6:	771a      	strb	r2, [r3, #28]
    State->FirstCmd = TRUE;
    62f8:	9b03      	ldr	r3, [sp, #12]
    62fa:	2201      	movs	r2, #1
    62fc:	775a      	strb	r2, [r3, #29]
    #if ((STD_ON == LPSPI_IP_DMA_USED) && (STD_ON == LPSPI_IP_ENABLE_DMAFASTTRANSFER_SUPPORT))
    Lpspi_Ip_TxDmaTcdSGInit(Instance);
    Lpspi_Ip_RxDmaTcdSGInit(Instance);
    #endif
    /* set State to idle */
    State->Status = LPSPI_IP_IDLE;
    62fe:	9b03      	ldr	r3, [sp, #12]
    6300:	2201      	movs	r2, #1
    6302:	605a      	str	r2, [r3, #4]
    (void)Lpspi_Ip_UpdateTransferMode(Instance, PhyUnitConfigPtr->TransferMode);
    6304:	9b01      	ldr	r3, [sp, #4]
    6306:	68da      	ldr	r2, [r3, #12]
    6308:	f89d 3013 	ldrb.w	r3, [sp, #19]
    630c:	4611      	mov	r1, r2
    630e:	4618      	mov	r0, r3
    6310:	f000 fd10 	bl	6d34 <Lpspi_Ip_UpdateTransferMode>
    
    /* Enable SPI module */
    Base->CR |= LPSPI_CR_MEN_MASK;
    6314:	9b02      	ldr	r3, [sp, #8]
    6316:	691b      	ldr	r3, [r3, #16]
    6318:	f043 0201 	orr.w	r2, r3, #1
    631c:	9b02      	ldr	r3, [sp, #8]
    631e:	611a      	str	r2, [r3, #16]
    return Status;
    6320:	9b05      	ldr	r3, [sp, #20]
}
    6322:	4618      	mov	r0, r3
    6324:	b007      	add	sp, #28
    6326:	f85d fb04 	ldr.w	pc, [sp], #4
    632a:	bf00      	nop
    632c:	1fff8d38 	.word	0x1fff8d38
    6330:	0000a1e4 	.word	0x0000a1e4
    6334:	1fff8cf8 	.word	0x1fff8cf8

00006338 <Lpspi_Ip_DeInit>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_DeInit(uint8 Instance)
{
    6338:	b086      	sub	sp, #24
    633a:	4603      	mov	r3, r0
    633c:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6340:	2300      	movs	r3, #0
    6342:	9305      	str	r3, [sp, #20]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    6344:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6348:	4a11      	ldr	r2, [pc, #68]	; (6390 <Lpspi_Ip_DeInit+0x58>)
    634a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    634e:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6350:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6354:	4a0f      	ldr	r2, [pc, #60]	; (6394 <Lpspi_Ip_DeInit+0x5c>)
    6356:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    635a:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_BUSY == State->Status)
    635c:	9b03      	ldr	r3, [sp, #12]
    635e:	685b      	ldr	r3, [r3, #4]
    6360:	2b02      	cmp	r3, #2
    6362:	d102      	bne.n	636a <Lpspi_Ip_DeInit+0x32>
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6364:	2301      	movs	r3, #1
    6366:	9305      	str	r3, [sp, #20]
    6368:	e00e      	b.n	6388 <Lpspi_Ip_DeInit+0x50>
    }
    else
    {
        /* Use reset hardware feature. */
        Base->CR |= LPSPI_CR_RST(1u);
    636a:	9b04      	ldr	r3, [sp, #16]
    636c:	691b      	ldr	r3, [r3, #16]
    636e:	f043 0202 	orr.w	r2, r3, #2
    6372:	9b04      	ldr	r3, [sp, #16]
    6374:	611a      	str	r2, [r3, #16]
        Base->CR = 0;
    6376:	9b04      	ldr	r3, [sp, #16]
    6378:	2200      	movs	r2, #0
    637a:	611a      	str	r2, [r3, #16]

        Lpspi_Ip_apxStateStructureArray[Instance] = NULL_PTR;
    637c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6380:	4a04      	ldr	r2, [pc, #16]	; (6394 <Lpspi_Ip_DeInit+0x5c>)
    6382:	2100      	movs	r1, #0
    6384:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    }
    return Status;
    6388:	9b05      	ldr	r3, [sp, #20]
}
    638a:	4618      	mov	r0, r3
    638c:	b006      	add	sp, #24
    638e:	4770      	bx	lr
    6390:	0000a1e4 	.word	0x0000a1e4
    6394:	1fff8d38 	.word	0x1fff8d38

00006398 <Lpspi_Ip_SyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            uint32 TimeOut
                                         )
{
    6398:	b510      	push	{r4, lr}
    639a:	b09a      	sub	sp, #104	; 0x68
    639c:	9005      	str	r0, [sp, #20]
    639e:	9104      	str	r1, [sp, #16]
    63a0:	9203      	str	r2, [sp, #12]
    63a2:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type *Base;
    Lpspi_Ip_StateStructureType *State;
    uint8 NumberOfWrites, NumberOfReads;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    63a6:	2300      	movs	r3, #0
    63a8:	9318      	str	r3, [sp, #96]	; 0x60
    uint32 TimeoutTicks = OsIf_MicrosToTicks(TimeOut, LPSPI_IP_TIMEOUT_METHOD);
    63aa:	2100      	movs	r1, #0
    63ac:	981c      	ldr	r0, [sp, #112]	; 0x70
    63ae:	f7fa fe9f 	bl	10f0 <OsIf_MicrosToTicks>
    63b2:	9015      	str	r0, [sp, #84]	; 0x54
    uint32 CurrentTicks = 0u; /* initialize current counter */
    63b4:	2300      	movs	r3, #0
    63b6:	9307      	str	r3, [sp, #28]
    uint32 ElapsedTicks = 0u; /* elapsed will give timeout */
    63b8:	2300      	movs	r3, #0
    63ba:	9317      	str	r3, [sp, #92]	; 0x5c
    uint8 Instance = 0u;
    63bc:	2300      	movs	r3, #0
    63be:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    uint32 Cfgr1 = 0u;
    63c2:	2300      	movs	r3, #0
    63c4:	9313      	str	r3, [sp, #76]	; 0x4c
    boolean TxDoneFlag = FALSE;
    63c6:	2300      	movs	r3, #0
    63c8:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    DevAssert(0u != TimeOut);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    63cc:	9b05      	ldr	r3, [sp, #20]
    63ce:	781b      	ldrb	r3, [r3, #0]
    63d0:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    63d4:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    63d8:	4a92      	ldr	r2, [pc, #584]	; (6624 <Lpspi_Ip_SyncTransmit+0x28c>)
    63da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63de:	9312      	str	r3, [sp, #72]	; 0x48
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];    
    63e0:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    63e4:	4a90      	ldr	r2, [pc, #576]	; (6628 <Lpspi_Ip_SyncTransmit+0x290>)
    63e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63ea:	9311      	str	r3, [sp, #68]	; 0x44
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08();
    63ec:	f002 ff9c 	bl	9328 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>
    if (LPSPI_IP_BUSY == State->Status)
    63f0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    63f2:	685b      	ldr	r3, [r3, #4]
    63f4:	2b02      	cmp	r3, #2
    63f6:	d104      	bne.n	6402 <Lpspi_Ip_SyncTransmit+0x6a>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    63f8:	f002 ffc2 	bl	9380 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        Status = LPSPI_IP_STATUS_FAIL;
    63fc:	2301      	movs	r3, #1
    63fe:	9318      	str	r3, [sp, #96]	; 0x60
    6400:	e276      	b.n	68f0 <Lpspi_Ip_SyncTransmit+0x558>
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    6402:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6404:	2202      	movs	r2, #2
    6406:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    6408:	9b12      	ldr	r3, [sp, #72]	; 0x48
    640a:	9a05      	ldr	r2, [sp, #20]
    640c:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    640e:	f002 ffb7 	bl	9380 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        
        /* Disable DMA requests and all interrupts */
        Base->DER = 0u;
    6412:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6414:	2200      	movs	r2, #0
    6416:	61da      	str	r2, [r3, #28]
        Base->IER = 0u;
    6418:	9b11      	ldr	r3, [sp, #68]	; 0x44
    641a:	2200      	movs	r2, #0
    641c:	619a      	str	r2, [r3, #24]
        
        /* Update State structure. */
        State->NextTransferConfigAvailable = State->KeepCs;
    641e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6420:	7f1a      	ldrb	r2, [r3, #28]
    6422:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6424:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    6428:	9b12      	ldr	r3, [sp, #72]	; 0x48
    642a:	7f5b      	ldrb	r3, [r3, #29]
    642c:	2b00      	cmp	r3, #0
    642e:	d030      	beq.n	6492 <Lpspi_Ip_SyncTransmit+0xfa>
            /* Makes sure that FIFOs will be empty before start new transfer session. 
            There is maybe a frame in RX shifter register (previous transfer is broken and CS did not de-assert).
            So use reset FIFO do not prevent the potential issue. So reset module by software reset bit should be used here */
            /* Reset FIFOs using CR[RST] bit */
            /* store CFGR1 and restore after all registers are reset */
            Cfgr1 = Base->CFGR1;
    6430:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6432:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6434:	9313      	str	r3, [sp, #76]	; 0x4c
            Base->CR |= LPSPI_CR_RST_MASK;
    6436:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6438:	691b      	ldr	r3, [r3, #16]
    643a:	f043 0202 	orr.w	r2, r3, #2
    643e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6440:	611a      	str	r2, [r3, #16]
            Base->CR &= ~LPSPI_CR_RST_MASK;
    6442:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6444:	691b      	ldr	r3, [r3, #16]
    6446:	f023 0202 	bic.w	r2, r3, #2
    644a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    644c:	611a      	str	r2, [r3, #16]
            /* restore CFGR1 */
            Base->CFGR1 = Cfgr1;
    644e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6450:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    6452:	625a      	str	r2, [r3, #36]	; 0x24
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    6454:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6456:	695b      	ldr	r3, [r3, #20]
    6458:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    645c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    645e:	615a      	str	r2, [r3, #20]

            #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
            Base->CCR = ExternalDevice->Ccr[State->ClockMode];
            #else
            Base->CCR = ExternalDevice->Ccr;
    6460:	9b05      	ldr	r3, [sp, #20]
    6462:	685a      	ldr	r2, [r3, #4]
    6464:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6466:	641a      	str	r2, [r3, #64]	; 0x40
            #endif
                /* Reset current FIFO slots are available to fill at beginning of job (HLD).*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    6468:	9b12      	ldr	r3, [sp, #72]	; 0x48
    646a:	2204      	movs	r2, #4
    646c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    6470:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6472:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6474:	68db      	ldr	r3, [r3, #12]
    6476:	881a      	ldrh	r2, [r3, #0]
    6478:	9b12      	ldr	r3, [sp, #72]	; 0x48
    647a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    647c:	68db      	ldr	r3, [r3, #12]
    647e:	7899      	ldrb	r1, [r3, #2]
    6480:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    6484:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6488:	9300      	str	r3, [sp, #0]
    648a:	460b      	mov	r3, r1
    648c:	9904      	ldr	r1, [sp, #16]
    648e:	f000 fa37 	bl	6900 <Lpspi_TransmitTxInit>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    6492:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6494:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6496:	68db      	ldr	r3, [r3, #12]
    6498:	881a      	ldrh	r2, [r3, #0]
    649a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    649e:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    64a2:	9903      	ldr	r1, [sp, #12]
    64a4:	f000 facc 	bl	6a40 <Lpspi_TransmitRxInit>
        /* initialize current counter */
        CurrentTicks = OsIf_GetCounter(LPSPI_IP_TIMEOUT_METHOD);
    64a8:	2000      	movs	r0, #0
    64aa:	f7fa fdd5 	bl	1058 <OsIf_GetCounter>
    64ae:	4603      	mov	r3, r0
    64b0:	9307      	str	r3, [sp, #28]
        while(State->RxIndex != State->ExpectedFifoReads)
    64b2:	e202      	b.n	68ba <Lpspi_Ip_SyncTransmit+0x522>
        {
            /* RECEIVE DATA */
            /* The receiving should be performed first because maybe have a last frame in RX FIFO from previous channel
                , it should be read to clear RXFIFO before start a new write to TXFIFO */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    64b4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    64b6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    64b8:	0c1b      	lsrs	r3, r3, #16
    64ba:	b2db      	uxtb	r3, r3
    64bc:	f003 0307 	and.w	r3, r3, #7
    64c0:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
            /* Limits to remaining frames. */
            
            if (NumberOfReads != 0u)
    64c4:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    64c8:	2b00      	cmp	r3, #0
    64ca:	f000 80d2 	beq.w	6672 <Lpspi_Ip_SyncTransmit+0x2da>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    64ce:	f89d 2066 	ldrb.w	r2, [sp, #102]	; 0x66
    64d2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64d4:	8b1b      	ldrh	r3, [r3, #24]
    64d6:	4619      	mov	r1, r3
    64d8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64da:	8a9b      	ldrh	r3, [r3, #20]
    64dc:	1acb      	subs	r3, r1, r3
    64de:	429a      	cmp	r2, r3
    64e0:	dd08      	ble.n	64f4 <Lpspi_Ip_SyncTransmit+0x15c>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    64e2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64e4:	8b1b      	ldrh	r3, [r3, #24]
    64e6:	b2da      	uxtb	r2, r3
    64e8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64ea:	8a9b      	ldrh	r3, [r3, #20]
    64ec:	b2db      	uxtb	r3, r3
    64ee:	1ad3      	subs	r3, r2, r3
    64f0:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out */
                if (0u == State->RxIndex)
    64f4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64f6:	8a9b      	ldrh	r3, [r3, #20]
    64f8:	2b00      	cmp	r3, #0
    64fa:	d107      	bne.n	650c <Lpspi_Ip_SyncTransmit+0x174>
                {
                    State->CurrentTxFifoSlot += 1u;
    64fc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    64fe:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6502:	3301      	adds	r3, #1
    6504:	b2da      	uxtb	r2, r3
    6506:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6508:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    650c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    6510:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    6514:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    6518:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    651c:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    6520:	4a41      	ldr	r2, [pc, #260]	; (6628 <Lpspi_Ip_SyncTransmit+0x290>)
    6522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6526:	930f      	str	r3, [sp, #60]	; 0x3c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6528:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    652c:	4a3d      	ldr	r2, [pc, #244]	; (6624 <Lpspi_Ip_SyncTransmit+0x28c>)
    652e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6532:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 Data = 0u;
    6534:	2300      	movs	r3, #0
    6536:	930d      	str	r3, [sp, #52]	; 0x34
    uint8 Index = 0u;
    6538:	2300      	movs	r3, #0
    653a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    if (NULL_PTR != State->RxBuffer)
    653e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6540:	689b      	ldr	r3, [r3, #8]
    6542:	2b00      	cmp	r3, #0
    6544:	d069      	beq.n	661a <Lpspi_Ip_SyncTransmit+0x282>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    6546:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6548:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    654a:	68db      	ldr	r3, [r3, #12]
    654c:	881b      	ldrh	r3, [r3, #0]
    654e:	2b08      	cmp	r3, #8
    6550:	d81e      	bhi.n	6590 <Lpspi_Ip_SyncTransmit+0x1f8>
            for (Index = 0; Index < NumberOfReads; Index++)
    6552:	2300      	movs	r3, #0
    6554:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    6558:	e013      	b.n	6582 <Lpspi_Ip_SyncTransmit+0x1ea>
                Data = Base->RDR;
    655a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    655c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    655e:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    6560:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6562:	689b      	ldr	r3, [r3, #8]
    6564:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    6566:	8a92      	ldrh	r2, [r2, #20]
    6568:	4611      	mov	r1, r2
    656a:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
    656e:	440a      	add	r2, r1
    6570:	4413      	add	r3, r2
    6572:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6574:	b2d2      	uxtb	r2, r2
    6576:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    6578:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    657c:	3301      	adds	r3, #1
    657e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    6582:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    6586:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    658a:	429a      	cmp	r2, r3
    658c:	d8e5      	bhi.n	655a <Lpspi_Ip_SyncTransmit+0x1c2>
    658e:	e05a      	b.n	6646 <Lpspi_Ip_SyncTransmit+0x2ae>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    6590:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6592:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6594:	68db      	ldr	r3, [r3, #12]
    6596:	881b      	ldrh	r3, [r3, #0]
    6598:	2b10      	cmp	r3, #16
    659a:	d81f      	bhi.n	65dc <Lpspi_Ip_SyncTransmit+0x244>
            for (Index = 0; Index < NumberOfReads; Index++)
    659c:	2300      	movs	r3, #0
    659e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    65a2:	e014      	b.n	65ce <Lpspi_Ip_SyncTransmit+0x236>
                Data = Base->RDR;
    65a4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    65a6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    65a8:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    65aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    65ac:	689a      	ldr	r2, [r3, #8]
    65ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    65b0:	8a9b      	ldrh	r3, [r3, #20]
    65b2:	4619      	mov	r1, r3
    65b4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    65b8:	440b      	add	r3, r1
    65ba:	005b      	lsls	r3, r3, #1
    65bc:	4413      	add	r3, r2
    65be:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    65c0:	b292      	uxth	r2, r2
    65c2:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    65c4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    65c8:	3301      	adds	r3, #1
    65ca:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    65ce:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    65d2:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    65d6:	429a      	cmp	r2, r3
    65d8:	d8e4      	bhi.n	65a4 <Lpspi_Ip_SyncTransmit+0x20c>
    65da:	e034      	b.n	6646 <Lpspi_Ip_SyncTransmit+0x2ae>
            for (Index = 0; Index < NumberOfReads; Index++)
    65dc:	2300      	movs	r3, #0
    65de:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    65e2:	e013      	b.n	660c <Lpspi_Ip_SyncTransmit+0x274>
                Data = Base->RDR;
    65e4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    65e6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    65e8:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    65ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    65ec:	689a      	ldr	r2, [r3, #8]
    65ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    65f0:	8a9b      	ldrh	r3, [r3, #20]
    65f2:	4619      	mov	r1, r3
    65f4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    65f8:	440b      	add	r3, r1
    65fa:	009b      	lsls	r3, r3, #2
    65fc:	4413      	add	r3, r2
    65fe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6600:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    6602:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    6606:	3301      	adds	r3, #1
    6608:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    660c:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    6610:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    6614:	429a      	cmp	r2, r3
    6616:	d8e5      	bhi.n	65e4 <Lpspi_Ip_SyncTransmit+0x24c>
    6618:	e015      	b.n	6646 <Lpspi_Ip_SyncTransmit+0x2ae>
        for (Index = 0; Index < NumberOfReads; Index++)
    661a:	2300      	movs	r3, #0
    661c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    6620:	e00b      	b.n	663a <Lpspi_Ip_SyncTransmit+0x2a2>
    6622:	bf00      	nop
    6624:	1fff8d38 	.word	0x1fff8d38
    6628:	0000a1e4 	.word	0x0000a1e4
            (void)Base->RDR;
    662c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    662e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    6630:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    6634:	3301      	adds	r3, #1
    6636:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    663a:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    663e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    6642:	429a      	cmp	r2, r3
    6644:	d8f2      	bhi.n	662c <Lpspi_Ip_SyncTransmit+0x294>
    State->RxIndex += NumberOfReads;
    6646:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6648:	8a9a      	ldrh	r2, [r3, #20]
    664a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
    664e:	b29b      	uxth	r3, r3
    6650:	4413      	add	r3, r2
    6652:	b29a      	uxth	r2, r3
    6654:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6656:	829a      	strh	r2, [r3, #20]
}
    6658:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    665a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    665c:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    6660:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    6664:	4413      	add	r3, r2
    6666:	b2da      	uxtb	r2, r3
    6668:	9b12      	ldr	r3, [sp, #72]	; 0x48
    666a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                ElapsedTicks = 0u;
    666e:	2300      	movs	r3, #0
    6670:	9317      	str	r3, [sp, #92]	; 0x5c
            /* After driver code read all frames in RX FIFO, if there are still some frames in TX FIFO, at the time before driver code check number of frames available in TX FIFO 
            to prepare to fill TX FIFO. At that time, interrupt occurred, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO. 
            So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from interrupt and fill TX FIFO until full. 
            And there is a interrupt occurred after that before read all frames in RX FIFO, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (TxDoneFlag != TRUE))
    6672:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6674:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6678:	2b00      	cmp	r3, #0
    667a:	f000 810e 	beq.w	689a <Lpspi_Ip_SyncTransmit+0x502>
    667e:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
    6682:	f083 0301 	eor.w	r3, r3, #1
    6686:	b2db      	uxtb	r3, r3
    6688:	2b00      	cmp	r3, #0
    668a:	f000 8106 	beq.w	689a <Lpspi_Ip_SyncTransmit+0x502>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    668e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6690:	8b5a      	ldrh	r2, [r3, #26]
    6692:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6694:	8adb      	ldrh	r3, [r3, #22]
    6696:	429a      	cmp	r2, r3
    6698:	f000 80c7 	beq.w	682a <Lpspi_Ip_SyncTransmit+0x492>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    669c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    669e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    66a2:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    66a6:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
    66aa:	9b12      	ldr	r3, [sp, #72]	; 0x48
    66ac:	8b5b      	ldrh	r3, [r3, #26]
    66ae:	4619      	mov	r1, r3
    66b0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    66b2:	8adb      	ldrh	r3, [r3, #22]
    66b4:	1acb      	subs	r3, r1, r3
    66b6:	429a      	cmp	r2, r3
    66b8:	dd08      	ble.n	66cc <Lpspi_Ip_SyncTransmit+0x334>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    66ba:	9b12      	ldr	r3, [sp, #72]	; 0x48
    66bc:	8b5b      	ldrh	r3, [r3, #26]
    66be:	b2da      	uxtb	r2, r3
    66c0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    66c2:	8adb      	ldrh	r3, [r3, #22]
    66c4:	b2db      	uxtb	r3, r3
    66c6:	1ad3      	subs	r3, r2, r3
    66c8:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    66cc:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    66d0:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    66d4:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    66d8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    66dc:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    66e0:	4a85      	ldr	r2, [pc, #532]	; (68f8 <Lpspi_Ip_SyncTransmit+0x560>)
    66e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66e6:	930b      	str	r3, [sp, #44]	; 0x2c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    66e8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    66ec:	4a83      	ldr	r2, [pc, #524]	; (68fc <Lpspi_Ip_SyncTransmit+0x564>)
    66ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66f2:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 Data = 0u;
    66f4:	2300      	movs	r3, #0
    66f6:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Index = 0u;
    66f8:	2300      	movs	r3, #0
    66fa:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    66fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6700:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6702:	68db      	ldr	r3, [r3, #12]
    6704:	685b      	ldr	r3, [r3, #4]
    6706:	9309      	str	r3, [sp, #36]	; 0x24
    if (NULL_PTR != State->TxBuffer)
    6708:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    670a:	68db      	ldr	r3, [r3, #12]
    670c:	2b00      	cmp	r3, #0
    670e:	d063      	beq.n	67d8 <Lpspi_Ip_SyncTransmit+0x440>
        if (State->TxFrameSize < 9u)
    6710:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6712:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    6714:	2b08      	cmp	r3, #8
    6716:	d81d      	bhi.n	6754 <Lpspi_Ip_SyncTransmit+0x3bc>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6718:	2300      	movs	r3, #0
    671a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    671e:	e012      	b.n	6746 <Lpspi_Ip_SyncTransmit+0x3ae>
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    6720:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6722:	68db      	ldr	r3, [r3, #12]
    6724:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6726:	8ad2      	ldrh	r2, [r2, #22]
    6728:	4611      	mov	r1, r2
    672a:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    672e:	440a      	add	r2, r1
    6730:	4413      	add	r3, r2
    6732:	781b      	ldrb	r3, [r3, #0]
    6734:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    6736:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6738:	9a09      	ldr	r2, [sp, #36]	; 0x24
    673a:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    673c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6740:	3301      	adds	r3, #1
    6742:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    6746:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    674a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    674e:	429a      	cmp	r2, r3
    6750:	d8e6      	bhi.n	6720 <Lpspi_Ip_SyncTransmit+0x388>
    6752:	e053      	b.n	67fc <Lpspi_Ip_SyncTransmit+0x464>
        else if (State->TxFrameSize < 17u)
    6754:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6756:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    6758:	2b10      	cmp	r3, #16
    675a:	d81e      	bhi.n	679a <Lpspi_Ip_SyncTransmit+0x402>
            for (Index = 0; Index < NumberOfWrites; Index++)
    675c:	2300      	movs	r3, #0
    675e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    6762:	e013      	b.n	678c <Lpspi_Ip_SyncTransmit+0x3f4>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    6764:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6766:	68da      	ldr	r2, [r3, #12]
    6768:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    676a:	8adb      	ldrh	r3, [r3, #22]
    676c:	4619      	mov	r1, r3
    676e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6772:	440b      	add	r3, r1
    6774:	005b      	lsls	r3, r3, #1
    6776:	4413      	add	r3, r2
    6778:	881b      	ldrh	r3, [r3, #0]
    677a:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    677c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    677e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6780:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    6782:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6786:	3301      	adds	r3, #1
    6788:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    678c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    6790:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6794:	429a      	cmp	r2, r3
    6796:	d8e5      	bhi.n	6764 <Lpspi_Ip_SyncTransmit+0x3cc>
    6798:	e030      	b.n	67fc <Lpspi_Ip_SyncTransmit+0x464>
            for (Index = 0; Index < NumberOfWrites; Index++)
    679a:	2300      	movs	r3, #0
    679c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    67a0:	e013      	b.n	67ca <Lpspi_Ip_SyncTransmit+0x432>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    67a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    67a4:	68da      	ldr	r2, [r3, #12]
    67a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    67a8:	8adb      	ldrh	r3, [r3, #22]
    67aa:	4619      	mov	r1, r3
    67ac:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    67b0:	440b      	add	r3, r1
    67b2:	009b      	lsls	r3, r3, #2
    67b4:	4413      	add	r3, r2
    67b6:	681b      	ldr	r3, [r3, #0]
    67b8:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    67ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    67bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    67be:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    67c0:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    67c4:	3301      	adds	r3, #1
    67c6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    67ca:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    67ce:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    67d2:	429a      	cmp	r2, r3
    67d4:	d8e5      	bhi.n	67a2 <Lpspi_Ip_SyncTransmit+0x40a>
    67d6:	e011      	b.n	67fc <Lpspi_Ip_SyncTransmit+0x464>
        for (Index = 0; Index < NumberOfWrites; Index++)
    67d8:	2300      	movs	r3, #0
    67da:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    67de:	e007      	b.n	67f0 <Lpspi_Ip_SyncTransmit+0x458>
            Base->TDR = Data;
    67e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    67e2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    67e4:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    67e6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    67ea:	3301      	adds	r3, #1
    67ec:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    67f0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    67f4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    67f8:	429a      	cmp	r2, r3
    67fa:	d8f1      	bhi.n	67e0 <Lpspi_Ip_SyncTransmit+0x448>
    State->TxIndex += NumberOfWrites;
    67fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    67fe:	8ada      	ldrh	r2, [r3, #22]
    6800:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    6804:	b29b      	uxth	r3, r3
    6806:	4413      	add	r3, r2
    6808:	b29a      	uxth	r2, r3
    680a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    680c:	82da      	strh	r2, [r3, #22]
}
    680e:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    6810:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6812:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    6816:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    681a:	1ad3      	subs	r3, r2, r3
    681c:	b2da      	uxtb	r2, r3
    681e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6820:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                    ElapsedTicks = 0u;
    6824:	2300      	movs	r3, #0
    6826:	9317      	str	r3, [sp, #92]	; 0x5c
    6828:	e037      	b.n	689a <Lpspi_Ip_SyncTransmit+0x502>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    682a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    682c:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    6830:	2b00      	cmp	r3, #0
    6832:	d01c      	beq.n	686e <Lpspi_Ip_SyncTransmit+0x4d6>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    6834:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6836:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6838:	68db      	ldr	r3, [r3, #12]
    683a:	9a12      	ldr	r2, [sp, #72]	; 0x48
    683c:	6b52      	ldr	r2, [r2, #52]	; 0x34
    683e:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    6840:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6842:	2200      	movs	r2, #0
    6844:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    6846:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6848:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    684a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    684c:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    684e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6850:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    6854:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6856:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    6858:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    685c:	9300      	str	r3, [sp, #0]
    685e:	4623      	mov	r3, r4
    6860:	f000 f84e 	bl	6900 <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    6864:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6866:	2200      	movs	r2, #0
    6868:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    686c:	e015      	b.n	689a <Lpspi_Ip_SyncTransmit+0x502>
                    }
                    else
                    {
                        TxDoneFlag = TRUE;
    686e:	2301      	movs	r3, #1
    6870:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    6874:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6876:	7f1b      	ldrb	r3, [r3, #28]
    6878:	f083 0301 	eor.w	r3, r3, #1
    687c:	b2db      	uxtb	r3, r3
    687e:	2b00      	cmp	r3, #0
    6880:	d00b      	beq.n	689a <Lpspi_Ip_SyncTransmit+0x502>
    6882:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6884:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6886:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    688a:	2b00      	cmp	r3, #0
    688c:	d005      	beq.n	689a <Lpspi_Ip_SyncTransmit+0x502>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    688e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6890:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6892:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    6896:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6898:	661a      	str	r2, [r3, #96]	; 0x60
                        }
                    }
                }
            }
            ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, LPSPI_IP_TIMEOUT_METHOD);
    689a:	ab07      	add	r3, sp, #28
    689c:	2100      	movs	r1, #0
    689e:	4618      	mov	r0, r3
    68a0:	f7fa fbf3 	bl	108a <OsIf_GetElapsed>
    68a4:	4602      	mov	r2, r0
    68a6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    68a8:	4413      	add	r3, r2
    68aa:	9317      	str	r3, [sp, #92]	; 0x5c
            if (ElapsedTicks >= TimeoutTicks)
    68ac:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    68ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
    68b0:	429a      	cmp	r2, r3
    68b2:	d302      	bcc.n	68ba <Lpspi_Ip_SyncTransmit+0x522>
            {
                Status = LPSPI_IP_TIMEOUT;
    68b4:	2303      	movs	r3, #3
    68b6:	9318      	str	r3, [sp, #96]	; 0x60
                break;
    68b8:	e006      	b.n	68c8 <Lpspi_Ip_SyncTransmit+0x530>
        while(State->RxIndex != State->ExpectedFifoReads)
    68ba:	9b12      	ldr	r3, [sp, #72]	; 0x48
    68bc:	8a9a      	ldrh	r2, [r3, #20]
    68be:	9b12      	ldr	r3, [sp, #72]	; 0x48
    68c0:	8b1b      	ldrh	r3, [r3, #24]
    68c2:	429a      	cmp	r2, r3
    68c4:	f47f adf6 	bne.w	64b4 <Lpspi_Ip_SyncTransmit+0x11c>
            }
        }
        if ((LPSPI_IP_STATUS_SUCCESS != Status) || (0u == Length))
    68c8:	9b18      	ldr	r3, [sp, #96]	; 0x60
    68ca:	2b00      	cmp	r3, #0
    68cc:	d103      	bne.n	68d6 <Lpspi_Ip_SyncTransmit+0x53e>
    68ce:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    68d2:	2b00      	cmp	r3, #0
    68d4:	d109      	bne.n	68ea <Lpspi_Ip_SyncTransmit+0x552>
        {
#if (STD_OFF == LPSPI_IP_DEV_ERROR_DETECT)
            /* Return Fail status if length is 0. Error Detect is enabled, nothing need to be done here */
            if (0u == Length)
    68d6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    68da:	2b00      	cmp	r3, #0
    68dc:	d101      	bne.n	68e2 <Lpspi_Ip_SyncTransmit+0x54a>
            {
                Status = LPSPI_IP_STATUS_FAIL;
    68de:	2301      	movs	r3, #1
    68e0:	9318      	str	r3, [sp, #96]	; 0x60
            }
#endif
            State->Status = LPSPI_IP_FAULT;
    68e2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    68e4:	2203      	movs	r2, #3
    68e6:	605a      	str	r2, [r3, #4]
    68e8:	e002      	b.n	68f0 <Lpspi_Ip_SyncTransmit+0x558>
        }
        else
        {
            State->Status = LPSPI_IP_IDLE;
    68ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
    68ec:	2201      	movs	r2, #1
    68ee:	605a      	str	r2, [r3, #4]
        }
    }
    return Status;
    68f0:	9b18      	ldr	r3, [sp, #96]	; 0x60
}
    68f2:	4618      	mov	r0, r3
    68f4:	b01a      	add	sp, #104	; 0x68
    68f6:	bd10      	pop	{r4, pc}
    68f8:	0000a1e4 	.word	0x0000a1e4
    68fc:	1fff8d38 	.word	0x1fff8d38

00006900 <Lpspi_TransmitTxInit>:
                                 const uint8* TxBuffer,
                                 uint16 TxFrameSize,
                                 boolean TxLsb,
                                 uint16 BufLen
                                )
{
    6900:	b088      	sub	sp, #32
    6902:	9100      	str	r1, [sp, #0]
    6904:	4611      	mov	r1, r2
    6906:	461a      	mov	r2, r3
    6908:	4603      	mov	r3, r0
    690a:	f88d 3007 	strb.w	r3, [sp, #7]
    690e:	460b      	mov	r3, r1
    6910:	f8ad 3004 	strh.w	r3, [sp, #4]
    6914:	4613      	mov	r3, r2
    6916:	f88d 3006 	strb.w	r3, [sp, #6]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    691a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    691e:	4a46      	ldr	r2, [pc, #280]	; (6a38 <Lpspi_TransmitTxInit+0x138>)
    6920:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6924:	9307      	str	r3, [sp, #28]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6926:	f89d 3007 	ldrb.w	r3, [sp, #7]
    692a:	4a44      	ldr	r2, [pc, #272]	; (6a3c <Lpspi_TransmitTxInit+0x13c>)
    692c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6930:	9306      	str	r3, [sp, #24]
    uint32 TransferCommand = 0u;
    6932:	2300      	movs	r3, #0
    6934:	9305      	str	r3, [sp, #20]
    uint8 LsbWriteValue = TxLsb ? 1U : 0U;
    6936:	f89d 3006 	ldrb.w	r3, [sp, #6]
    693a:	2b00      	cmp	r3, #0
    693c:	d001      	beq.n	6942 <Lpspi_TransmitTxInit+0x42>
    693e:	2301      	movs	r3, #1
    6940:	e000      	b.n	6944 <Lpspi_TransmitTxInit+0x44>
    6942:	2300      	movs	r3, #0
    6944:	f88d 3013 	strb.w	r3, [sp, #19]

    State->TxFrameSize = TxFrameSize;
    6948:	9b06      	ldr	r3, [sp, #24]
    694a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    694e:	851a      	strh	r2, [r3, #40]	; 0x28
    State->TxLsb = TxLsb;
    6950:	9b06      	ldr	r3, [sp, #24]
    6952:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6956:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    /* Get transfer command */
#if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    TransferCommand = State->ExternalDevice->Tcr[State->ClockMode] | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
#else
    TransferCommand = State->ExternalDevice->Tcr | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
    695a:	9b06      	ldr	r3, [sp, #24]
    695c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    695e:	689a      	ldr	r2, [r3, #8]
    6960:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    6964:	3b01      	subs	r3, #1
    6966:	f3c3 030b 	ubfx	r3, r3, #0, #12
    696a:	431a      	orrs	r2, r3
    696c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6970:	05db      	lsls	r3, r3, #23
    6972:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
    6976:	4313      	orrs	r3, r2
    6978:	9305      	str	r3, [sp, #20]
        {
            TransferCommand &= ~LPSPI_TCR_CONT_MASK;
        }
        #endif
        
        if(TRUE == State->FirstCmd)
    697a:	9b06      	ldr	r3, [sp, #24]
    697c:	7f5b      	ldrb	r3, [r3, #29]
    697e:	2b00      	cmp	r3, #0
    6980:	d003      	beq.n	698a <Lpspi_TransmitTxInit+0x8a>
        {
            /* Set transfer command */
            Base->TCR = TransferCommand;
    6982:	9b07      	ldr	r3, [sp, #28]
    6984:	9a05      	ldr	r2, [sp, #20]
    6986:	661a      	str	r2, [r3, #96]	; 0x60
    6988:	e00d      	b.n	69a6 <Lpspi_TransmitTxInit+0xa6>
        }
        else
        {
            if (0u != (TransferCommand & LPSPI_TCR_CONT_MASK))
    698a:	9b05      	ldr	r3, [sp, #20]
    698c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    6990:	2b00      	cmp	r3, #0
    6992:	d005      	beq.n	69a0 <Lpspi_TransmitTxInit+0xa0>
            {
                Base->TCR = TransferCommand | LPSPI_TCR_CONTC_MASK;
    6994:	9b05      	ldr	r3, [sp, #20]
    6996:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    699a:	9b07      	ldr	r3, [sp, #28]
    699c:	661a      	str	r2, [r3, #96]	; 0x60
    699e:	e002      	b.n	69a6 <Lpspi_TransmitTxInit+0xa6>
            }
            else
            {
                Base->TCR = TransferCommand;
    69a0:	9b07      	ldr	r3, [sp, #28]
    69a2:	9a05      	ldr	r2, [sp, #20]
    69a4:	661a      	str	r2, [r3, #96]	; 0x60
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        if (LPSPI_IP_FULL_DUPLEX == State->ExternalDevice->DeviceParams->TransferType)
        #endif
        {
            /* CMD will take 1 slot in TXFIFO, update current TX FIFO slot. it will be plus 1 when the first frames of channel have recieved */
            State->CurrentTxFifoSlot -= 1u;
    69a6:	9b06      	ldr	r3, [sp, #24]
    69a8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    69ac:	3b01      	subs	r3, #1
    69ae:	b2da      	uxtb	r2, r3
    69b0:	9b06      	ldr	r3, [sp, #24]
    69b2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        }
    }
    
    /* Update State structure. */
    State->TxIndex = 0u;
    69b6:	9b06      	ldr	r3, [sp, #24]
    69b8:	2200      	movs	r2, #0
    69ba:	82da      	strh	r2, [r3, #22]
        (void)TxBuffer;
    }
    else
    #endif
    {
        State->TxBuffer = TxBuffer;
    69bc:	9b06      	ldr	r3, [sp, #24]
    69be:	9a00      	ldr	r2, [sp, #0]
    69c0:	60da      	str	r2, [r3, #12]
    69c2:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    69c6:	f8ad 3010 	strh.w	r3, [sp, #16]
    69ca:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    69ce:	f8ad 300e 	strh.w	r3, [sp, #14]
    if (FrameSize < 9u)
    69d2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    69d6:	2b08      	cmp	r3, #8
    69d8:	d804      	bhi.n	69e4 <Lpspi_TransmitTxInit+0xe4>
        Ret = Length;
    69da:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    69de:	f8ad 300c 	strh.w	r3, [sp, #12]
    69e2:	e022      	b.n	6a2a <Lpspi_TransmitTxInit+0x12a>
    else if (FrameSize < 17u)
    69e4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    69e8:	2b10      	cmp	r3, #16
    69ea:	d80c      	bhi.n	6a06 <Lpspi_TransmitTxInit+0x106>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    69ec:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    69f0:	085b      	lsrs	r3, r3, #1
    69f2:	b29a      	uxth	r2, r3
    69f4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    69f8:	f003 0301 	and.w	r3, r3, #1
    69fc:	b29b      	uxth	r3, r3
    69fe:	4413      	add	r3, r2
    6a00:	f8ad 300c 	strh.w	r3, [sp, #12]
    6a04:	e011      	b.n	6a2a <Lpspi_TransmitTxInit+0x12a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    6a06:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    6a0a:	089b      	lsrs	r3, r3, #2
    6a0c:	b29a      	uxth	r2, r3
    6a0e:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    6a12:	f003 0303 	and.w	r3, r3, #3
    6a16:	b29b      	uxth	r3, r3
    6a18:	2b00      	cmp	r3, #0
    6a1a:	bf14      	ite	ne
    6a1c:	2301      	movne	r3, #1
    6a1e:	2300      	moveq	r3, #0
    6a20:	b2db      	uxtb	r3, r3
    6a22:	b29b      	uxth	r3, r3
    6a24:	4413      	add	r3, r2
    6a26:	f8ad 300c 	strh.w	r3, [sp, #12]
    return Ret;
    6a2a:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    }

    State->ExpectedFifoWrites = Lpspi_Ip_GetWordsFromLength(BufLen, TxFrameSize);
    6a2e:	9b06      	ldr	r3, [sp, #24]
    6a30:	835a      	strh	r2, [r3, #26]
}
    6a32:	bf00      	nop
    6a34:	b008      	add	sp, #32
    6a36:	4770      	bx	lr
    6a38:	0000a1e4 	.word	0x0000a1e4
    6a3c:	1fff8d38 	.word	0x1fff8d38

00006a40 <Lpspi_TransmitRxInit>:
static void Lpspi_TransmitRxInit(uint8 Instance,
                                      uint8* RxBuffer,
                                      uint16 RxFrameSize,
                                      uint16 BufLen
                                     )
{
    6a40:	b088      	sub	sp, #32
    6a42:	9102      	str	r1, [sp, #8]
    6a44:	4611      	mov	r1, r2
    6a46:	461a      	mov	r2, r3
    6a48:	4603      	mov	r3, r0
    6a4a:	f88d 300f 	strb.w	r3, [sp, #15]
    6a4e:	460b      	mov	r3, r1
    6a50:	f8ad 300c 	strh.w	r3, [sp, #12]
    6a54:	4613      	mov	r3, r2
    6a56:	f8ad 3006 	strh.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6a5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6a5e:	4a22      	ldr	r2, [pc, #136]	; (6ae8 <Lpspi_TransmitRxInit+0xa8>)
    6a60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a64:	9307      	str	r3, [sp, #28]
    
    /* Update State structure. */
    State->RxIndex = 0u;
    6a66:	9b07      	ldr	r3, [sp, #28]
    6a68:	2200      	movs	r2, #0
    6a6a:	829a      	strh	r2, [r3, #20]
        (void)RxBuffer; 
    }
    else
    #endif        
    {
        State->RxBuffer = RxBuffer; 
    6a6c:	9b07      	ldr	r3, [sp, #28]
    6a6e:	9a02      	ldr	r2, [sp, #8]
    6a70:	609a      	str	r2, [r3, #8]
    6a72:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    6a76:	f8ad 301a 	strh.w	r3, [sp, #26]
    6a7a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    6a7e:	f8ad 3018 	strh.w	r3, [sp, #24]
    if (FrameSize < 9u)
    6a82:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    6a86:	2b08      	cmp	r3, #8
    6a88:	d804      	bhi.n	6a94 <Lpspi_TransmitRxInit+0x54>
        Ret = Length;
    6a8a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    6a8e:	f8ad 3016 	strh.w	r3, [sp, #22]
    6a92:	e022      	b.n	6ada <Lpspi_TransmitRxInit+0x9a>
    else if (FrameSize < 17u)
    6a94:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    6a98:	2b10      	cmp	r3, #16
    6a9a:	d80c      	bhi.n	6ab6 <Lpspi_TransmitRxInit+0x76>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    6a9c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    6aa0:	085b      	lsrs	r3, r3, #1
    6aa2:	b29a      	uxth	r2, r3
    6aa4:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    6aa8:	f003 0301 	and.w	r3, r3, #1
    6aac:	b29b      	uxth	r3, r3
    6aae:	4413      	add	r3, r2
    6ab0:	f8ad 3016 	strh.w	r3, [sp, #22]
    6ab4:	e011      	b.n	6ada <Lpspi_TransmitRxInit+0x9a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    6ab6:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    6aba:	089b      	lsrs	r3, r3, #2
    6abc:	b29a      	uxth	r2, r3
    6abe:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    6ac2:	f003 0303 	and.w	r3, r3, #3
    6ac6:	b29b      	uxth	r3, r3
    6ac8:	2b00      	cmp	r3, #0
    6aca:	bf14      	ite	ne
    6acc:	2301      	movne	r3, #1
    6ace:	2300      	moveq	r3, #0
    6ad0:	b2db      	uxtb	r3, r3
    6ad2:	b29b      	uxth	r3, r3
    6ad4:	4413      	add	r3, r2
    6ad6:	f8ad 3016 	strh.w	r3, [sp, #22]
    return Ret;
    6ada:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    }

    State->ExpectedFifoReads = Lpspi_Ip_GetWordsFromLength(BufLen, RxFrameSize);
    6ade:	9b07      	ldr	r3, [sp, #28]
    6ae0:	831a      	strh	r2, [r3, #24]
}
    6ae2:	bf00      	nop
    6ae4:	b008      	add	sp, #32
    6ae6:	4770      	bx	lr
    6ae8:	1fff8d38 	.word	0x1fff8d38

00006aec <Lpspi_Ip_AsyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            Lpspi_Ip_CallbackType EndCallback
                                          )
{
    6aec:	b500      	push	{lr}
    6aee:	b08b      	sub	sp, #44	; 0x2c
    6af0:	9005      	str	r0, [sp, #20]
    6af2:	9104      	str	r1, [sp, #16]
    6af4:	9203      	str	r2, [sp, #12]
    6af6:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6afa:	2300      	movs	r3, #0
    6afc:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Instance = 0u;
    6afe:	2300      	movs	r3, #0
    6b00:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    6b04:	9b05      	ldr	r3, [sp, #20]
    6b06:	781b      	ldrb	r3, [r3, #0]
    6b08:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6b0c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6b10:	4a3d      	ldr	r2, [pc, #244]	; (6c08 <Lpspi_Ip_AsyncTransmit+0x11c>)
    6b12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b16:	9307      	str	r3, [sp, #28]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];
    6b18:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    6b1c:	4a3b      	ldr	r2, [pc, #236]	; (6c0c <Lpspi_Ip_AsyncTransmit+0x120>)
    6b1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b22:	9306      	str	r3, [sp, #24]
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09();
    6b24:	f002 fc52 	bl	93cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>
    if (LPSPI_IP_BUSY == State->Status)
    6b28:	9b07      	ldr	r3, [sp, #28]
    6b2a:	685b      	ldr	r3, [r3, #4]
    6b2c:	2b02      	cmp	r3, #2
    6b2e:	d104      	bne.n	6b3a <Lpspi_Ip_AsyncTransmit+0x4e>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    6b30:	f002 fc78 	bl	9424 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        Status = LPSPI_IP_STATUS_FAIL;
    6b34:	2301      	movs	r3, #1
    6b36:	9309      	str	r3, [sp, #36]	; 0x24
    6b38:	e061      	b.n	6bfe <Lpspi_Ip_AsyncTransmit+0x112>
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    6b3a:	9b07      	ldr	r3, [sp, #28]
    6b3c:	2202      	movs	r2, #2
    6b3e:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    6b40:	9b07      	ldr	r3, [sp, #28]
    6b42:	9a05      	ldr	r2, [sp, #20]
    6b44:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    6b46:	f002 fc6d 	bl	9424 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        
        /* Update State structure. */
        State->Callback = EndCallback;
    6b4a:	9b07      	ldr	r3, [sp, #28]
    6b4c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    6b4e:	611a      	str	r2, [r3, #16]
        State->NextTransferConfigAvailable = State->KeepCs;
    6b50:	9b07      	ldr	r3, [sp, #28]
    6b52:	7f1a      	ldrb	r2, [r3, #28]
    6b54:	9b07      	ldr	r3, [sp, #28]
    6b56:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Reset TX done flag */
        State->TxDoneFlag = FALSE;
    6b5a:	9b07      	ldr	r3, [sp, #28]
    6b5c:	2200      	movs	r2, #0
    6b5e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    6b62:	9b07      	ldr	r3, [sp, #28]
    6b64:	7f5b      	ldrb	r3, [r3, #29]
    6b66:	2b00      	cmp	r3, #0
    6b68:	d028      	beq.n	6bbc <Lpspi_Ip_AsyncTransmit+0xd0>
        {
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11();
    6b6a:	f002 fcd3 	bl	9514 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>
            /* Make sure that FIFOs will be empty before start new transfer session */
            Base->CR |= LPSPI_CR_RTF_MASK|LPSPI_CR_RRF_MASK;
    6b6e:	9b06      	ldr	r3, [sp, #24]
    6b70:	691b      	ldr	r3, [r3, #16]
    6b72:	f443 7240 	orr.w	r2, r3, #768	; 0x300
    6b76:	9b06      	ldr	r3, [sp, #24]
    6b78:	611a      	str	r2, [r3, #16]
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    6b7a:	9b06      	ldr	r3, [sp, #24]
    6b7c:	695b      	ldr	r3, [r3, #20]
    6b7e:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    6b82:	9b06      	ldr	r3, [sp, #24]
    6b84:	615a      	str	r2, [r3, #20]
            #endif
            {
                #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
                Base->CCR = ExternalDevice->Ccr[State->ClockMode];
                #else
                Base->CCR = ExternalDevice->Ccr;
    6b86:	9b05      	ldr	r3, [sp, #20]
    6b88:	685a      	ldr	r2, [r3, #4]
    6b8a:	9b06      	ldr	r3, [sp, #24]
    6b8c:	641a      	str	r2, [r3, #64]	; 0x40
                #endif
            }
            /* Update current FIFO slots are available to fill .*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    6b8e:	9b07      	ldr	r3, [sp, #28]
    6b90:	2204      	movs	r2, #4
    6b92:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            /* In setting up Transmit command register, the RXMSK is also cleared */
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    6b96:	9b07      	ldr	r3, [sp, #28]
    6b98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6b9a:	68db      	ldr	r3, [r3, #12]
    6b9c:	881a      	ldrh	r2, [r3, #0]
    6b9e:	9b07      	ldr	r3, [sp, #28]
    6ba0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6ba2:	68db      	ldr	r3, [r3, #12]
    6ba4:	7899      	ldrb	r1, [r3, #2]
    6ba6:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    6baa:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6bae:	9300      	str	r3, [sp, #0]
    6bb0:	460b      	mov	r3, r1
    6bb2:	9904      	ldr	r1, [sp, #16]
    6bb4:	f7ff fea4 	bl	6900 <Lpspi_TransmitTxInit>
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11();
    6bb8:	f002 fcd8 	bl	956c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    6bbc:	9b07      	ldr	r3, [sp, #28]
    6bbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6bc0:	68db      	ldr	r3, [r3, #12]
    6bc2:	881a      	ldrh	r2, [r3, #0]
    6bc4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6bc8:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    6bcc:	9903      	ldr	r1, [sp, #12]
    6bce:	f7ff ff37 	bl	6a40 <Lpspi_TransmitRxInit>
            }
            else
            #endif
            {
                /* Set TX water */
                Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    6bd2:	9b06      	ldr	r3, [sp, #24]
    6bd4:	2203      	movs	r2, #3
    6bd6:	659a      	str	r2, [r3, #88]	; 0x58
            }
            
            /* Disable DMA requests */
            Base->DER = 0u;
    6bd8:	9b06      	ldr	r3, [sp, #24]
    6bda:	2200      	movs	r2, #0
    6bdc:	61da      	str	r2, [r3, #28]
            switch (State->TransferMode)
    6bde:	9b07      	ldr	r3, [sp, #28]
    6be0:	681b      	ldr	r3, [r3, #0]
    6be2:	2b00      	cmp	r3, #0
    6be4:	d002      	beq.n	6bec <Lpspi_Ip_AsyncTransmit+0x100>
    6be6:	2b01      	cmp	r3, #1
    6be8:	d004      	beq.n	6bf4 <Lpspi_Ip_AsyncTransmit+0x108>
                case LPSPI_IP_INTERRUPT:
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
                    break;
                default:
                    /* Nothing to do */
                    break;
    6bea:	e008      	b.n	6bfe <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = 0u;
    6bec:	9b06      	ldr	r3, [sp, #24]
    6bee:	2200      	movs	r2, #0
    6bf0:	619a      	str	r2, [r3, #24]
                    break;
    6bf2:	e004      	b.n	6bfe <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
    6bf4:	9b06      	ldr	r3, [sp, #24]
    6bf6:	f641 0203 	movw	r2, #6147	; 0x1803
    6bfa:	619a      	str	r2, [r3, #24]
                    break;
    6bfc:	bf00      	nop
            /* Enable DMA request. */
            Base->DER = LPSPI_DER_RDDE_MASK | LPSPI_DER_TDDE_MASK;
        }
        #endif
    }
    return Status;
    6bfe:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    6c00:	4618      	mov	r0, r3
    6c02:	b00b      	add	sp, #44	; 0x2c
    6c04:	f85d fb04 	ldr.w	pc, [sp], #4
    6c08:	1fff8d38 	.word	0x1fff8d38
    6c0c:	0000a1e4 	.word	0x0000a1e4

00006c10 <Lpspi_Ip_ManageBuffers>:
}
#endif
#endif

void Lpspi_Ip_ManageBuffers(uint8 Instance)
{
    6c10:	b500      	push	{lr}
    6c12:	b085      	sub	sp, #20
    6c14:	4603      	mov	r3, r0
    6c16:	f88d 3007 	strb.w	r3, [sp, #7]
    #endif

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    6c1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c1e:	4a14      	ldr	r2, [pc, #80]	; (6c70 <Lpspi_Ip_ManageBuffers+0x60>)
    6c20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c24:	9303      	str	r3, [sp, #12]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6c26:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c2a:	4a12      	ldr	r2, [pc, #72]	; (6c74 <Lpspi_Ip_ManageBuffers+0x64>)
    6c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c30:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_POLLING == State->TransferMode)
    6c32:	9b02      	ldr	r3, [sp, #8]
    6c34:	681b      	ldr	r3, [r3, #0]
    6c36:	2b00      	cmp	r3, #0
    6c38:	d115      	bne.n	6c66 <Lpspi_Ip_ManageBuffers+0x56>
                - Receive: Both TDF (push CDM) and DRF (receive data) are set.
               In half duplex Slave mode:
                - Transmit: TDF is set only, RDF will never be set by RX FIFO have masked.
                - Receive: Both TDF and RDF are set. But only process for RDF to receive data. In this case, State->CurrentTxFifoSlot will be set to 0 */
            if(
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    6c3a:	9b03      	ldr	r3, [sp, #12]
    6c3c:	695b      	ldr	r3, [r3, #20]
    6c3e:	f003 0302 	and.w	r3, r3, #2
            if(
    6c42:	2b00      	cmp	r3, #0
    6c44:	d10a      	bne.n	6c5c <Lpspi_Ip_ManageBuffers+0x4c>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    6c46:	9b03      	ldr	r3, [sp, #12]
    6c48:	695b      	ldr	r3, [r3, #20]
    6c4a:	f003 0301 	and.w	r3, r3, #1
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    6c4e:	2b00      	cmp	r3, #0
    6c50:	d009      	beq.n	6c66 <Lpspi_Ip_ManageBuffers+0x56>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    6c52:	9b02      	ldr	r3, [sp, #8]
    6c54:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6c58:	2b00      	cmp	r3, #0
    6c5a:	d004      	beq.n	6c66 <Lpspi_Ip_ManageBuffers+0x56>
                    Lpspi_Ip_TransferProcessHalfDuplex(Instance);
                }
                else
                #endif
                {
                    Lpspi_Ip_TransferProcess(Instance); 
    6c5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c60:	4618      	mov	r0, r3
    6c62:	f7ff f8cd 	bl	5e00 <Lpspi_Ip_TransferProcess>
                Lpspi_Ip_IrqTxDmaHandler(Instance);
            }
        }
        #endif
    }
}
    6c66:	bf00      	nop
    6c68:	b005      	add	sp, #20
    6c6a:	f85d fb04 	ldr.w	pc, [sp], #4
    6c6e:	bf00      	nop
    6c70:	0000a1e4 	.word	0x0000a1e4
    6c74:	1fff8d38 	.word	0x1fff8d38

00006c78 <Lpspi_Ip_UpdateFrameSize>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_UpdateFrameSize(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint16 FrameSize)
{
    6c78:	b084      	sub	sp, #16
    6c7a:	9001      	str	r0, [sp, #4]
    6c7c:	460b      	mov	r3, r1
    6c7e:	f8ad 3002 	strh.w	r3, [sp, #2]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6c82:	2300      	movs	r3, #0
    6c84:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    DevAssert(LPSPI_IP_FRAMESIZE_MAX_U16 >= FrameSize);
    DevAssert(LPSPI_IP_FRAMESIZE_MIN_U16 <= FrameSize);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    6c86:	9b01      	ldr	r3, [sp, #4]
    6c88:	781b      	ldrb	r3, [r3, #0]
    6c8a:	461a      	mov	r2, r3
    6c8c:	4b09      	ldr	r3, [pc, #36]	; (6cb4 <Lpspi_Ip_UpdateFrameSize+0x3c>)
    6c8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6c92:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Frame size can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    6c94:	9b02      	ldr	r3, [sp, #8]
    6c96:	685b      	ldr	r3, [r3, #4]
    6c98:	2b02      	cmp	r3, #2
    6c9a:	d005      	beq.n	6ca8 <Lpspi_Ip_UpdateFrameSize+0x30>
    {
        ExternalDevice->DeviceParams->FrameSize = FrameSize;
    6c9c:	9b01      	ldr	r3, [sp, #4]
    6c9e:	68db      	ldr	r3, [r3, #12]
    6ca0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    6ca4:	801a      	strh	r2, [r3, #0]
    6ca6:	e001      	b.n	6cac <Lpspi_Ip_UpdateFrameSize+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6ca8:	2301      	movs	r3, #1
    6caa:	9303      	str	r3, [sp, #12]
    }
    return Status;
    6cac:	9b03      	ldr	r3, [sp, #12]
}
    6cae:	4618      	mov	r0, r3
    6cb0:	b004      	add	sp, #16
    6cb2:	4770      	bx	lr
    6cb4:	1fff8d38 	.word	0x1fff8d38

00006cb8 <Lpspi_Ip_UpdateLsb>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateLsb(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, boolean Lsb)
{
    6cb8:	b084      	sub	sp, #16
    6cba:	9001      	str	r0, [sp, #4]
    6cbc:	460b      	mov	r3, r1
    6cbe:	f88d 3003 	strb.w	r3, [sp, #3]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6cc2:	2300      	movs	r3, #0
    6cc4:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    6cc6:	9b01      	ldr	r3, [sp, #4]
    6cc8:	781b      	ldrb	r3, [r3, #0]
    6cca:	461a      	mov	r2, r3
    6ccc:	4b09      	ldr	r3, [pc, #36]	; (6cf4 <Lpspi_Ip_UpdateLsb+0x3c>)
    6cce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6cd2:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    6cd4:	9b02      	ldr	r3, [sp, #8]
    6cd6:	685b      	ldr	r3, [r3, #4]
    6cd8:	2b02      	cmp	r3, #2
    6cda:	d005      	beq.n	6ce8 <Lpspi_Ip_UpdateLsb+0x30>
    {
        ExternalDevice->DeviceParams->Lsb = Lsb;
    6cdc:	9b01      	ldr	r3, [sp, #4]
    6cde:	68db      	ldr	r3, [r3, #12]
    6ce0:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6ce4:	709a      	strb	r2, [r3, #2]
    6ce6:	e001      	b.n	6cec <Lpspi_Ip_UpdateLsb+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6ce8:	2301      	movs	r3, #1
    6cea:	9303      	str	r3, [sp, #12]
    }
    return Status;
    6cec:	9b03      	ldr	r3, [sp, #12]
}
    6cee:	4618      	mov	r0, r3
    6cf0:	b004      	add	sp, #16
    6cf2:	4770      	bx	lr
    6cf4:	1fff8d38 	.word	0x1fff8d38

00006cf8 <Lpspi_Ip_UpdateDefaultTransmitData>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateDefaultTransmitData(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint32 DefaultData)
{
    6cf8:	b084      	sub	sp, #16
    6cfa:	9001      	str	r0, [sp, #4]
    6cfc:	9100      	str	r1, [sp, #0]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6cfe:	2300      	movs	r3, #0
    6d00:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    6d02:	9b01      	ldr	r3, [sp, #4]
    6d04:	781b      	ldrb	r3, [r3, #0]
    6d06:	461a      	mov	r2, r3
    6d08:	4b09      	ldr	r3, [pc, #36]	; (6d30 <Lpspi_Ip_UpdateDefaultTransmitData+0x38>)
    6d0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6d0e:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    6d10:	9b02      	ldr	r3, [sp, #8]
    6d12:	685b      	ldr	r3, [r3, #4]
    6d14:	2b02      	cmp	r3, #2
    6d16:	d004      	beq.n	6d22 <Lpspi_Ip_UpdateDefaultTransmitData+0x2a>
    {
        ExternalDevice->DeviceParams->DefaultData = DefaultData;
    6d18:	9b01      	ldr	r3, [sp, #4]
    6d1a:	68db      	ldr	r3, [r3, #12]
    6d1c:	9a00      	ldr	r2, [sp, #0]
    6d1e:	605a      	str	r2, [r3, #4]
    6d20:	e001      	b.n	6d26 <Lpspi_Ip_UpdateDefaultTransmitData+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6d22:	2301      	movs	r3, #1
    6d24:	9303      	str	r3, [sp, #12]
    }
    return Status;
    6d26:	9b03      	ldr	r3, [sp, #12]
}
    6d28:	4618      	mov	r0, r3
    6d2a:	b004      	add	sp, #16
    6d2c:	4770      	bx	lr
    6d2e:	bf00      	nop
    6d30:	1fff8d38 	.word	0x1fff8d38

00006d34 <Lpspi_Ip_UpdateTransferMode>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateTransferMode(uint8 Instance, Lpspi_Ip_ModeType Mode)
{
    6d34:	b084      	sub	sp, #16
    6d36:	4603      	mov	r3, r0
    6d38:	9100      	str	r1, [sp, #0]
    6d3a:	f88d 3007 	strb.w	r3, [sp, #7]
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6d3e:	2300      	movs	r3, #0
    6d40:	9303      	str	r3, [sp, #12]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6d42:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6d46:	4a09      	ldr	r2, [pc, #36]	; (6d6c <Lpspi_Ip_UpdateTransferMode+0x38>)
    6d48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d4c:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Transfer mode can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    6d4e:	9b02      	ldr	r3, [sp, #8]
    6d50:	685b      	ldr	r3, [r3, #4]
    6d52:	2b02      	cmp	r3, #2
    6d54:	d003      	beq.n	6d5e <Lpspi_Ip_UpdateTransferMode+0x2a>
    {
        State->TransferMode = Mode;
    6d56:	9b02      	ldr	r3, [sp, #8]
    6d58:	9a00      	ldr	r2, [sp, #0]
    6d5a:	601a      	str	r2, [r3, #0]
    6d5c:	e001      	b.n	6d62 <Lpspi_Ip_UpdateTransferMode+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6d5e:	2301      	movs	r3, #1
    6d60:	9303      	str	r3, [sp, #12]
    }
    return Status;
    6d62:	9b03      	ldr	r3, [sp, #12]
}
    6d64:	4618      	mov	r0, r3
    6d66:	b004      	add	sp, #16
    6d68:	4770      	bx	lr
    6d6a:	bf00      	nop
    6d6c:	1fff8d38 	.word	0x1fff8d38

00006d70 <Lpspi_Ip_Cancel>:

void Lpspi_Ip_Cancel(uint8 Instance)
{
    6d70:	b500      	push	{lr}
    6d72:	b087      	sub	sp, #28
    6d74:	4603      	mov	r3, r0
    6d76:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    uint32 Cfgr1 = 0u;
    6d7a:	2300      	movs	r3, #0
    6d7c:	9305      	str	r3, [sp, #20]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    6d7e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6d82:	4a18      	ldr	r2, [pc, #96]	; (6de4 <Lpspi_Ip_Cancel+0x74>)
    6d84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d88:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6d8a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6d8e:	4a16      	ldr	r2, [pc, #88]	; (6de8 <Lpspi_Ip_Cancel+0x78>)
    6d90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d94:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10();
    6d96:	f002 fb6b 	bl	9470 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>
    if (LPSPI_IP_BUSY == State->Status)
    6d9a:	9b03      	ldr	r3, [sp, #12]
    6d9c:	685b      	ldr	r3, [r3, #4]
    6d9e:	2b02      	cmp	r3, #2
    6da0:	d11a      	bne.n	6dd8 <Lpspi_Ip_Cancel+0x68>
    {
        /* Mask Rx to discard received data */
        Base->TCR |= LPSPI_TCR_RXMSK(1);
    6da2:	9b04      	ldr	r3, [sp, #16]
    6da4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6da6:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
    6daa:	9b04      	ldr	r3, [sp, #16]
    6dac:	661a      	str	r2, [r3, #96]	; 0x60
        /* store CFGR1 and restore after all registers are reset */
        Cfgr1 = Base->CFGR1;
    6dae:	9b04      	ldr	r3, [sp, #16]
    6db0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6db2:	9305      	str	r3, [sp, #20]
        /* Disable interrupts and DMA requests. */
        /* Clear FIFO */
        /* RTF and RRF will not clear shifter, so RST must be used to ensure old Data in shifter will also be cleared. */
        Base->CR |= LPSPI_CR_RST_MASK;
    6db4:	9b04      	ldr	r3, [sp, #16]
    6db6:	691b      	ldr	r3, [r3, #16]
    6db8:	f043 0202 	orr.w	r2, r3, #2
    6dbc:	9b04      	ldr	r3, [sp, #16]
    6dbe:	611a      	str	r2, [r3, #16]
        Base->CR &= ~LPSPI_CR_RST_MASK;
    6dc0:	9b04      	ldr	r3, [sp, #16]
    6dc2:	691b      	ldr	r3, [r3, #16]
    6dc4:	f023 0202 	bic.w	r2, r3, #2
    6dc8:	9b04      	ldr	r3, [sp, #16]
    6dca:	611a      	str	r2, [r3, #16]
        /* restore CFGR1 */
        Base->CFGR1 = Cfgr1;
    6dcc:	9b04      	ldr	r3, [sp, #16]
    6dce:	9a05      	ldr	r2, [sp, #20]
    6dd0:	625a      	str	r2, [r3, #36]	; 0x24
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->RxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->TxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
        }
        #endif
        /* set State to idle */
        State->Status = LPSPI_IP_IDLE;
    6dd2:	9b03      	ldr	r3, [sp, #12]
    6dd4:	2201      	movs	r2, #1
    6dd6:	605a      	str	r2, [r3, #4]
    }
    SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10();
    6dd8:	f002 fb76 	bl	94c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>
}
    6ddc:	bf00      	nop
    6dde:	b007      	add	sp, #28
    6de0:	f85d fb04 	ldr.w	pc, [sp], #4
    6de4:	0000a1e4 	.word	0x0000a1e4
    6de8:	1fff8d38 	.word	0x1fff8d38

00006dec <Lpspi_Ip_IrqHandler>:
* @param[in]     Instance            Instance of the hardware unit.
*
* @implements Lpspi_Ip_IrqHandler_Activity
*/
void Lpspi_Ip_IrqHandler(uint8 Instance)
{
    6dec:	b500      	push	{lr}
    6dee:	b087      	sub	sp, #28
    6df0:	4603      	mov	r3, r0
    6df2:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    6df6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6dfa:	4a18      	ldr	r2, [pc, #96]	; (6e5c <Lpspi_Ip_IrqHandler+0x70>)
    6dfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e00:	9305      	str	r3, [sp, #20]
    const Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6e02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6e06:	4a16      	ldr	r2, [pc, #88]	; (6e60 <Lpspi_Ip_IrqHandler+0x74>)
    6e08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e0c:	9304      	str	r3, [sp, #16]
    uint32 IrqFlags = 0u;
    6e0e:	2300      	movs	r3, #0
    6e10:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != State)
    6e12:	9b04      	ldr	r3, [sp, #16]
    6e14:	2b00      	cmp	r3, #0
    6e16:	d016      	beq.n	6e46 <Lpspi_Ip_IrqHandler+0x5a>
    {
        /* the driver has been initialized */
        IrqFlags = Base->SR & (LPSPI_SR_TDF_MASK | LPSPI_SR_RDF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK);
    6e18:	9b05      	ldr	r3, [sp, #20]
    6e1a:	695a      	ldr	r2, [r3, #20]
    6e1c:	f641 0303 	movw	r3, #6147	; 0x1803
    6e20:	4013      	ands	r3, r2
    6e22:	9303      	str	r3, [sp, #12]
        IrqFlags &= Base->IER & (LPSPI_IER_TDIE_MASK | LPSPI_IER_RDIE_MASK | LPSPI_IER_TEIE_MASK | LPSPI_IER_REIE_MASK);
    6e24:	9b05      	ldr	r3, [sp, #20]
    6e26:	699a      	ldr	r2, [r3, #24]
    6e28:	f641 0303 	movw	r3, #6147	; 0x1803
    6e2c:	4013      	ands	r3, r2
    6e2e:	9a03      	ldr	r2, [sp, #12]
    6e30:	4013      	ands	r3, r2
    6e32:	9303      	str	r3, [sp, #12]
        if (0u != IrqFlags)
    6e34:	9b03      	ldr	r3, [sp, #12]
    6e36:	2b00      	cmp	r3, #0
    6e38:	d00b      	beq.n	6e52 <Lpspi_Ip_IrqHandler+0x66>
                Lpspi_Ip_TransferProcessHalfDuplex(Instance);    
            }
            else
            #endif
            {
                Lpspi_Ip_TransferProcess(Instance); 
    6e3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6e3e:	4618      	mov	r0, r3
    6e40:	f7fe ffde 	bl	5e00 <Lpspi_Ip_TransferProcess>
    {
        /* the driver has not been initialized */
        /* clear all flags */
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    }
}
    6e44:	e005      	b.n	6e52 <Lpspi_Ip_IrqHandler+0x66>
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    6e46:	9b05      	ldr	r3, [sp, #20]
    6e48:	695b      	ldr	r3, [r3, #20]
    6e4a:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    6e4e:	9b05      	ldr	r3, [sp, #20]
    6e50:	615a      	str	r2, [r3, #20]
}
    6e52:	bf00      	nop
    6e54:	b007      	add	sp, #28
    6e56:	f85d fb04 	ldr.w	pc, [sp], #4
    6e5a:	bf00      	nop
    6e5c:	0000a1e4 	.word	0x0000a1e4
    6e60:	1fff8d38 	.word	0x1fff8d38

00006e64 <Lpspi_Ip_GetStatus>:
* @param[in]        Instance - SPI peripheral instance number.
*
* @return           Lpspi_Ip_HwStatusType
*/
Lpspi_Ip_HwStatusType Lpspi_Ip_GetStatus(uint8 Instance)
{
    6e64:	b084      	sub	sp, #16
    6e66:	4603      	mov	r3, r0
    6e68:	f88d 3007 	strb.w	r3, [sp, #7]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_HwStatusType Status = LPSPI_IP_UNINIT;
    6e6c:	2300      	movs	r3, #0
    6e6e:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6e70:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6e74:	4a06      	ldr	r2, [pc, #24]	; (6e90 <Lpspi_Ip_GetStatus+0x2c>)
    6e76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e7a:	9302      	str	r3, [sp, #8]
    if (State != NULL_PTR)
    6e7c:	9b02      	ldr	r3, [sp, #8]
    6e7e:	2b00      	cmp	r3, #0
    6e80:	d002      	beq.n	6e88 <Lpspi_Ip_GetStatus+0x24>
    {
        Status = State->Status;
    6e82:	9b02      	ldr	r3, [sp, #8]
    6e84:	685b      	ldr	r3, [r3, #4]
    6e86:	9303      	str	r3, [sp, #12]
    }
    
    return Status;
    6e88:	9b03      	ldr	r3, [sp, #12]
}
    6e8a:	4618      	mov	r0, r3
    6e8c:	b004      	add	sp, #16
    6e8e:	4770      	bx	lr
    6e90:	1fff8d38 	.word	0x1fff8d38

00006e94 <Spi_CheckInit>:
static inline Std_ReturnType Spi_CheckInit
    ( 
        const Spi_ConfigType *ConfigPtr,
        uint32 SpiCoreID
    )
{
    6e94:	b086      	sub	sp, #24
    6e96:	9001      	str	r0, [sp, #4]
    6e98:	9100      	str	r1, [sp, #0]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    6e9a:	2300      	movs	r3, #0
    6e9c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 Sequence;
#endif

#if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
    /* Configuration sizes must be checked for Post Build & Link Time configurations */
    Channel  = (uint32)(ConfigPtr->SpiMaxChannel);
    6ea0:	9b01      	ldr	r3, [sp, #4]
    6ea2:	789b      	ldrb	r3, [r3, #2]
    6ea4:	9304      	str	r3, [sp, #16]
    Job      = (uint32)(ConfigPtr->SpiMaxJob);
    6ea6:	9b01      	ldr	r3, [sp, #4]
    6ea8:	889b      	ldrh	r3, [r3, #4]
    6eaa:	9303      	str	r3, [sp, #12]
    Sequence = (uint32)(ConfigPtr->SpiMaxSequence);
    6eac:	9b01      	ldr	r3, [sp, #4]
    6eae:	799b      	ldrb	r3, [r3, #6]
    6eb0:	9302      	str	r3, [sp, #8]

    if ((Channel >= SPI_MAX_CHANNEL) || (Job >= SPI_MAX_JOB) || (Sequence >= SPI_MAX_SEQUENCE))
    6eb2:	9b04      	ldr	r3, [sp, #16]
    6eb4:	2b00      	cmp	r3, #0
    6eb6:	d105      	bne.n	6ec4 <Spi_CheckInit+0x30>
    6eb8:	9b03      	ldr	r3, [sp, #12]
    6eba:	2b00      	cmp	r3, #0
    6ebc:	d102      	bne.n	6ec4 <Spi_CheckInit+0x30>
    6ebe:	9b02      	ldr	r3, [sp, #8]
    6ec0:	2b00      	cmp	r3, #0
    6ec2:	d002      	beq.n	6eca <Spi_CheckInit+0x36>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    6ec4:	2301      	movs	r3, #1
    6ec6:	f88d 3017 	strb.w	r3, [sp, #23]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_CONFIG_OUT_OF_RANGE);
#endif
    }
    if (SpiCoreID != ConfigPtr->SpiCoreUse)
    6eca:	9b01      	ldr	r3, [sp, #4]
    6ecc:	689b      	ldr	r3, [r3, #8]
    6ece:	9a00      	ldr	r2, [sp, #0]
    6ed0:	429a      	cmp	r2, r3
    6ed2:	d002      	beq.n	6eda <Spi_CheckInit+0x46>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    6ed4:	2301      	movs	r3, #1
    6ed6:	f88d 3017 	strb.w	r3, [sp, #23]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_INVALID_POINTER);
#endif
    }
#endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */

    return CheckStatus;
    6eda:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    6ede:	4618      	mov	r0, r3
    6ee0:	b006      	add	sp, #24
    6ee2:	4770      	bx	lr

00006ee4 <Spi_SyncJobsTranfer>:
static Std_ReturnType Spi_SyncJobsTranfer
    (
        const Spi_SequenceConfigType *SequenceConfig,
        uint32 SpiCoreID
    )
{
    6ee4:	b500      	push	{lr}
    6ee6:	b089      	sub	sp, #36	; 0x24
    6ee8:	9001      	str	r0, [sp, #4]
    6eea:	9100      	str	r1, [sp, #0]
    Spi_JobType JobsCount;
    const Spi_JobType *JobIndexList;
    Spi_JobType Job;
    Spi_JobStateType *JobState;
    const Spi_JobConfigType *JobConfig;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    6eec:	2300      	movs	r3, #0
    6eee:	f88d 3017 	strb.w	r3, [sp, #23]
    
    /* Get the number of jobs in the sequence */
    JobsCount = SequenceConfig->NumJobs;
    6ef2:	9b01      	ldr	r3, [sp, #4]
    6ef4:	881b      	ldrh	r3, [r3, #0]
    6ef6:	f8ad 301e 	strh.w	r3, [sp, #30]
    JobIndexList = SequenceConfig->JobIndexList;
    6efa:	9b01      	ldr	r3, [sp, #4]
    6efc:	689b      	ldr	r3, [r3, #8]
    6efe:	9306      	str	r3, [sp, #24]
    while (0u < JobsCount)
    6f00:	e072      	b.n	6fe8 <Spi_SyncJobsTranfer+0x104>
    {
        /* Get the job id */
        Job = *JobIndexList;
    6f02:	9b06      	ldr	r3, [sp, #24]
    6f04:	881b      	ldrh	r3, [r3, #0]
    6f06:	f8ad 3014 	strh.w	r3, [sp, #20]
        /* Set the job status as pending */
        JobState = &Spi_axSpiJobState[Job];
    6f0a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f0e:	009b      	lsls	r3, r3, #2
    6f10:	4a3a      	ldr	r2, [pc, #232]	; (6ffc <Spi_SyncJobsTranfer+0x118>)
    6f12:	4413      	add	r3, r2
    6f14:	9304      	str	r3, [sp, #16]
        JobState->Result = SPI_JOB_PENDING;
    6f16:	9b04      	ldr	r3, [sp, #16]
    6f18:	2201      	movs	r2, #1
    6f1a:	601a      	str	r2, [r3, #0]
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    6f1c:	4a38      	ldr	r2, [pc, #224]	; (7000 <Spi_SyncJobsTranfer+0x11c>)
    6f1e:	9b00      	ldr	r3, [sp, #0]
    6f20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f24:	691a      	ldr	r2, [r3, #16]
    6f26:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f2a:	009b      	lsls	r3, r3, #2
    6f2c:	4413      	add	r3, r2
    6f2e:	681b      	ldr	r3, [r3, #0]
    6f30:	9303      	str	r3, [sp, #12]
        
        /* start job notification to assert the non-cs pin,
        when non-cs pin is used as chipselect*/
        if (NULL_PTR != JobConfig->StartNotification)
    6f32:	9b03      	ldr	r3, [sp, #12]
    6f34:	68db      	ldr	r3, [r3, #12]
    6f36:	2b00      	cmp	r3, #0
    6f38:	d002      	beq.n	6f40 <Spi_SyncJobsTranfer+0x5c>
        {
            JobConfig->StartNotification();
    6f3a:	9b03      	ldr	r3, [sp, #12]
    6f3c:	68db      	ldr	r3, [r3, #12]
    6f3e:	4798      	blx	r3
        else
        {
            /* Do nothing */
        }
        /* Mark HWUnit as busy */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_BUSY;
    6f40:	9b03      	ldr	r3, [sp, #12]
    6f42:	7f1b      	ldrb	r3, [r3, #28]
    6f44:	4619      	mov	r1, r3
    6f46:	4b2f      	ldr	r3, [pc, #188]	; (7004 <Spi_SyncJobsTranfer+0x120>)
    6f48:	2202      	movs	r2, #2
    6f4a:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        Status = Spi_Ipw_SyncTransmit(JobConfig, SpiCoreID);
    6f4e:	9900      	ldr	r1, [sp, #0]
    6f50:	9803      	ldr	r0, [sp, #12]
    6f52:	f000 fc5f 	bl	7814 <Spi_Ipw_SyncTransmit>
    6f56:	4603      	mov	r3, r0
    6f58:	f88d 3017 	strb.w	r3, [sp, #23]
        
        /* release HWUnit */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_IDLE;
    6f5c:	9b03      	ldr	r3, [sp, #12]
    6f5e:	7f1b      	ldrb	r3, [r3, #28]
    6f60:	4619      	mov	r1, r3
    6f62:	4b28      	ldr	r3, [pc, #160]	; (7004 <Spi_SyncJobsTranfer+0x120>)
    6f64:	2201      	movs	r2, #1
    6f66:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        if ((Std_ReturnType)E_OK == Status)
    6f6a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6f6e:	2b00      	cmp	r3, #0
    6f70:	d10a      	bne.n	6f88 <Spi_SyncJobsTranfer+0xa4>
        {
            /* Job is done set the status as OK */
            JobState->Result = SPI_JOB_OK;
    6f72:	9b04      	ldr	r3, [sp, #16]
    6f74:	2200      	movs	r2, #0
    6f76:	601a      	str	r2, [r3, #0]
            /* Perform job EndNotification (if there is one) */
            if (NULL_PTR != JobConfig->EndNotification)
    6f78:	9b03      	ldr	r3, [sp, #12]
    6f7a:	689b      	ldr	r3, [r3, #8]
    6f7c:	2b00      	cmp	r3, #0
    6f7e:	d02b      	beq.n	6fd8 <Spi_SyncJobsTranfer+0xf4>
            {
                JobConfig->EndNotification();
    6f80:	9b03      	ldr	r3, [sp, #12]
    6f82:	689b      	ldr	r3, [r3, #8]
    6f84:	4798      	blx	r3
    6f86:	e027      	b.n	6fd8 <Spi_SyncJobsTranfer+0xf4>
            /* transmission failed */
            /* set the remaining job status (including the current one) as FAILED */
            do
            {
                /* Set the job status as FAILED */
                Spi_axSpiJobState[*JobIndexList].Result = SPI_JOB_FAILED;
    6f88:	9b06      	ldr	r3, [sp, #24]
    6f8a:	881b      	ldrh	r3, [r3, #0]
    6f8c:	4619      	mov	r1, r3
    6f8e:	4b1b      	ldr	r3, [pc, #108]	; (6ffc <Spi_SyncJobsTranfer+0x118>)
    6f90:	2202      	movs	r2, #2
    6f92:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
                /* Update pointer position for JobConfig */
                JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[*JobIndexList].JobCfg;
    6f96:	4a1a      	ldr	r2, [pc, #104]	; (7000 <Spi_SyncJobsTranfer+0x11c>)
    6f98:	9b00      	ldr	r3, [sp, #0]
    6f9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f9e:	691a      	ldr	r2, [r3, #16]
    6fa0:	9b06      	ldr	r3, [sp, #24]
    6fa2:	881b      	ldrh	r3, [r3, #0]
    6fa4:	009b      	lsls	r3, r3, #2
    6fa6:	4413      	add	r3, r2
    6fa8:	681b      	ldr	r3, [r3, #0]
    6faa:	9303      	str	r3, [sp, #12]
                /* Perform job EndNotification (if there is one) */
                if (NULL_PTR != JobConfig->EndNotification)
    6fac:	9b03      	ldr	r3, [sp, #12]
    6fae:	689b      	ldr	r3, [r3, #8]
    6fb0:	2b00      	cmp	r3, #0
    6fb2:	d002      	beq.n	6fba <Spi_SyncJobsTranfer+0xd6>
                {
                    JobConfig->EndNotification();
    6fb4:	9b03      	ldr	r3, [sp, #12]
    6fb6:	689b      	ldr	r3, [r3, #8]
    6fb8:	4798      	blx	r3
                }
                else
                {
                    /* Do nothing */
                }
                JobIndexList++;
    6fba:	9b06      	ldr	r3, [sp, #24]
    6fbc:	3302      	adds	r3, #2
    6fbe:	9306      	str	r3, [sp, #24]
                JobsCount--;
    6fc0:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    6fc4:	3b01      	subs	r3, #1
    6fc6:	f8ad 301e 	strh.w	r3, [sp, #30]
            } while (0u < JobsCount);
    6fca:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    6fce:	2b00      	cmp	r3, #0
    6fd0:	d1da      	bne.n	6f88 <Spi_SyncJobsTranfer+0xa4>
            JobsCount = 1u;  /* needed to end correctly the outer loop */
    6fd2:	2301      	movs	r3, #1
    6fd4:	f8ad 301e 	strh.w	r3, [sp, #30]
        }
        /* iterate to next job in sequence */
        JobIndexList++;
    6fd8:	9b06      	ldr	r3, [sp, #24]
    6fda:	3302      	adds	r3, #2
    6fdc:	9306      	str	r3, [sp, #24]
        JobsCount--;
    6fde:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    6fe2:	3b01      	subs	r3, #1
    6fe4:	f8ad 301e 	strh.w	r3, [sp, #30]
    while (0u < JobsCount)
    6fe8:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    6fec:	2b00      	cmp	r3, #0
    6fee:	d188      	bne.n	6f02 <Spi_SyncJobsTranfer+0x1e>
    } /* while (JobsCount > 0u) */
    return Status;
    6ff0:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    6ff4:	4618      	mov	r0, r3
    6ff6:	b009      	add	sp, #36	; 0x24
    6ff8:	f85d fb04 	ldr.w	pc, [sp], #4
    6ffc:	1fff8d54 	.word	0x1fff8d54
    7000:	1fff8d4c 	.word	0x1fff8d4c
    7004:	1fff8d44 	.word	0x1fff8d44

00007008 <Spi_InitChannelsJobsSeqsState>:
*/
static void Spi_InitChannelsJobsSeqsState
    (
        uint32 SpiCoreID      
    )
{
    7008:	b088      	sub	sp, #32
    700a:	9001      	str	r0, [sp, #4]
#endif
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_JobConfigType *JobConfig;
    const Spi_SequenceConfigType *SequenceConfig;
    
    for (Channel = 0u;
    700c:	2300      	movs	r3, #0
    700e:	9307      	str	r3, [sp, #28]
    7010:	e034      	b.n	707c <Spi_InitChannelsJobsSeqsState+0x74>
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
        Channel++)
    {
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    7012:	4a4a      	ldr	r2, [pc, #296]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    7014:	9b01      	ldr	r3, [sp, #4]
    7016:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    701a:	68da      	ldr	r2, [r3, #12]
    701c:	9b07      	ldr	r3, [sp, #28]
    701e:	009b      	lsls	r3, r3, #2
    7020:	4413      	add	r3, r2
    7022:	681b      	ldr	r3, [r3, #0]
    7024:	9302      	str	r3, [sp, #8]
        /* Check which channel has assigned for current core */
        if((NULL_PTR != ChannelConfig) && (SpiCoreID == ChannelConfig->SpiCoreUse))
    7026:	9b02      	ldr	r3, [sp, #8]
    7028:	2b00      	cmp	r3, #0
    702a:	d024      	beq.n	7076 <Spi_InitChannelsJobsSeqsState+0x6e>
    702c:	9b02      	ldr	r3, [sp, #8]
    702e:	695b      	ldr	r3, [r3, #20]
    7030:	9a01      	ldr	r2, [sp, #4]
    7032:	429a      	cmp	r2, r3
    7034:	d11f      	bne.n	7076 <Spi_InitChannelsJobsSeqsState+0x6e>
        {
            /* Check if configured buffers are External (EB) */
            if (EB == ChannelConfig->BufferType)
    7036:	9b02      	ldr	r3, [sp, #8]
    7038:	681b      	ldr	r3, [r3, #0]
    703a:	2b01      	cmp	r3, #1
    703c:	d10e      	bne.n	705c <Spi_InitChannelsJobsSeqsState+0x54>
            {
                /* Initialize all buffers */
                ChannelConfig->BufferDescriptor->ExternalBufferTX = NULL_PTR;
    703e:	9b02      	ldr	r3, [sp, #8]
    7040:	691b      	ldr	r3, [r3, #16]
    7042:	2200      	movs	r2, #0
    7044:	601a      	str	r2, [r3, #0]
                ChannelConfig->BufferDescriptor->BufferRX = NULL_PTR;
    7046:	9b02      	ldr	r3, [sp, #8]
    7048:	691b      	ldr	r3, [r3, #16]
    704a:	2200      	movs	r2, #0
    704c:	609a      	str	r2, [r3, #8]
    
                /* Channel length is zero for unconfigured external buffers */
                Spi_axSpiChannelState[Channel].Length = (Spi_NumberOfDataType) 0;
    704e:	4a3c      	ldr	r2, [pc, #240]	; (7140 <Spi_InitChannelsJobsSeqsState+0x138>)
    7050:	9b07      	ldr	r3, [sp, #28]
    7052:	009b      	lsls	r3, r3, #2
    7054:	4413      	add	r3, r2
    7056:	2200      	movs	r2, #0
    7058:	805a      	strh	r2, [r3, #2]
    705a:	e007      	b.n	706c <Spi_InitChannelsJobsSeqsState+0x64>
            }
            else
            {
                /* Setup channel length according to configuration */
                Spi_axSpiChannelState[Channel].Length = ChannelConfig->Length;
    705c:	9b02      	ldr	r3, [sp, #8]
    705e:	8999      	ldrh	r1, [r3, #12]
    7060:	4a37      	ldr	r2, [pc, #220]	; (7140 <Spi_InitChannelsJobsSeqsState+0x138>)
    7062:	9b07      	ldr	r3, [sp, #28]
    7064:	009b      	lsls	r3, r3, #2
    7066:	4413      	add	r3, r2
    7068:	460a      	mov	r2, r1
    706a:	805a      	strh	r2, [r3, #2]
            }
            Spi_axSpiChannelState[Channel].Flags = SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    706c:	4a34      	ldr	r2, [pc, #208]	; (7140 <Spi_InitChannelsJobsSeqsState+0x138>)
    706e:	9b07      	ldr	r3, [sp, #28]
    7070:	2101      	movs	r1, #1
    7072:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
        Channel++)
    7076:	9b07      	ldr	r3, [sp, #28]
    7078:	3301      	adds	r3, #1
    707a:	9307      	str	r3, [sp, #28]
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
    707c:	4a2f      	ldr	r2, [pc, #188]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    707e:	9b01      	ldr	r3, [sp, #4]
    7080:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7084:	789b      	ldrb	r3, [r3, #2]
    7086:	461a      	mov	r2, r3
    for (Channel = 0u;
    7088:	9b07      	ldr	r3, [sp, #28]
    708a:	4293      	cmp	r3, r2
    708c:	d9c1      	bls.n	7012 <Spi_InitChannelsJobsSeqsState+0xa>
        }
    }
    
    /* initialize job results */
    for (Job = 0u;
    708e:	2300      	movs	r3, #0
    7090:	9306      	str	r3, [sp, #24]
    7092:	e019      	b.n	70c8 <Spi_InitChannelsJobsSeqsState+0xc0>
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
        Job++)
    {
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    7094:	4a29      	ldr	r2, [pc, #164]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    7096:	9b01      	ldr	r3, [sp, #4]
    7098:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    709c:	691a      	ldr	r2, [r3, #16]
    709e:	9b06      	ldr	r3, [sp, #24]
    70a0:	009b      	lsls	r3, r3, #2
    70a2:	4413      	add	r3, r2
    70a4:	681b      	ldr	r3, [r3, #0]
    70a6:	9303      	str	r3, [sp, #12]
        if((NULL_PTR != JobConfig) && (SpiCoreID == JobConfig->SpiCoreUse))
    70a8:	9b03      	ldr	r3, [sp, #12]
    70aa:	2b00      	cmp	r3, #0
    70ac:	d009      	beq.n	70c2 <Spi_InitChannelsJobsSeqsState+0xba>
    70ae:	9b03      	ldr	r3, [sp, #12]
    70b0:	695b      	ldr	r3, [r3, #20]
    70b2:	9a01      	ldr	r2, [sp, #4]
    70b4:	429a      	cmp	r2, r3
    70b6:	d104      	bne.n	70c2 <Spi_InitChannelsJobsSeqsState+0xba>
        {
            Spi_axSpiJobState[Job].Result = SPI_JOB_OK;
    70b8:	4a22      	ldr	r2, [pc, #136]	; (7144 <Spi_InitChannelsJobsSeqsState+0x13c>)
    70ba:	9b06      	ldr	r3, [sp, #24]
    70bc:	2100      	movs	r1, #0
    70be:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Job++)
    70c2:	9b06      	ldr	r3, [sp, #24]
    70c4:	3301      	adds	r3, #1
    70c6:	9306      	str	r3, [sp, #24]
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
    70c8:	4a1c      	ldr	r2, [pc, #112]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    70ca:	9b01      	ldr	r3, [sp, #4]
    70cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70d0:	889b      	ldrh	r3, [r3, #4]
    70d2:	461a      	mov	r2, r3
    for (Job = 0u;
    70d4:	9b06      	ldr	r3, [sp, #24]
    70d6:	4293      	cmp	r3, r2
    70d8:	d9dc      	bls.n	7094 <Spi_InitChannelsJobsSeqsState+0x8c>
            Spi_axSpiJobState[Job].AsyncCrtSequenceState = NULL_PTR;
        #endif
        }
    }
    
    for (Sequence = 0u;
    70da:	2300      	movs	r3, #0
    70dc:	9305      	str	r3, [sp, #20]
    70de:	e01f      	b.n	7120 <Spi_InitChannelsJobsSeqsState+0x118>
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
        Sequence++)
    {
        SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    70e0:	4a16      	ldr	r2, [pc, #88]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    70e2:	9b01      	ldr	r3, [sp, #4]
    70e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70e8:	695a      	ldr	r2, [r3, #20]
    70ea:	9b05      	ldr	r3, [sp, #20]
    70ec:	009b      	lsls	r3, r3, #2
    70ee:	4413      	add	r3, r2
    70f0:	681b      	ldr	r3, [r3, #0]
    70f2:	9304      	str	r3, [sp, #16]
        if ((NULL_PTR != SequenceConfig) && (SpiCoreID == SequenceConfig->SpiCoreUse))
    70f4:	9b04      	ldr	r3, [sp, #16]
    70f6:	2b00      	cmp	r3, #0
    70f8:	d00f      	beq.n	711a <Spi_InitChannelsJobsSeqsState+0x112>
    70fa:	9b04      	ldr	r3, [sp, #16]
    70fc:	685b      	ldr	r3, [r3, #4]
    70fe:	9a01      	ldr	r2, [sp, #4]
    7100:	429a      	cmp	r2, r3
    7102:	d10a      	bne.n	711a <Spi_InitChannelsJobsSeqsState+0x112>
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
            Spi_axSpiSequenceState[Sequence].Sequence = SequenceConfig;
            #endif
    
            /* initialize sequence results */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_OK;
    7104:	4a10      	ldr	r2, [pc, #64]	; (7148 <Spi_InitChannelsJobsSeqsState+0x140>)
    7106:	9b05      	ldr	r3, [sp, #20]
    7108:	2100      	movs	r1, #0
    710a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* SPI135: Spi_SyncTransmit() must fail if an other sync transmission
                    is ongoing.*/
            /* mark all HW units as used by the sync transmission, in order to
                force the mutual exclusion of Spi_SyncTransmit() calls */
    
            Spi_au32SpiSeqUsedHWUnits[Sequence] = 0xFFFFFFFFU;
    710e:	4a0f      	ldr	r2, [pc, #60]	; (714c <Spi_InitChannelsJobsSeqsState+0x144>)
    7110:	9b05      	ldr	r3, [sp, #20]
    7112:	f04f 31ff 	mov.w	r1, #4294967295
    7116:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Sequence++)
    711a:	9b05      	ldr	r3, [sp, #20]
    711c:	3301      	adds	r3, #1
    711e:	9305      	str	r3, [sp, #20]
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
    7120:	4a06      	ldr	r2, [pc, #24]	; (713c <Spi_InitChannelsJobsSeqsState+0x134>)
    7122:	9b01      	ldr	r3, [sp, #4]
    7124:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7128:	799b      	ldrb	r3, [r3, #6]
    712a:	461a      	mov	r2, r3
    for (Sequence = 0u;
    712c:	9b05      	ldr	r3, [sp, #20]
    712e:	4293      	cmp	r3, r2
    7130:	d9d6      	bls.n	70e0 <Spi_InitChannelsJobsSeqsState+0xd8>
        else
        {
            /* Do nothing */
        }
    }
}
    7132:	bf00      	nop
    7134:	bf00      	nop
    7136:	b008      	add	sp, #32
    7138:	4770      	bx	lr
    713a:	bf00      	nop
    713c:	1fff8d4c 	.word	0x1fff8d4c
    7140:	1fff8d58 	.word	0x1fff8d58
    7144:	1fff8d54 	.word	0x1fff8d54
    7148:	1fff8d50 	.word	0x1fff8d50
    714c:	1fff8d5c 	.word	0x1fff8d5c

00007150 <Spi_GetStatusAsyncCheckHwBusy>:
*/
static Spi_StatusType Spi_GetStatusAsyncCheckHwBusy
    (
        uint32 SpiCoreID
    )
{
    7150:	b084      	sub	sp, #16
    7152:	9001      	str	r0, [sp, #4]
    Spi_StatusType StatusFlag = SPI_IDLE;
    7154:	2301      	movs	r3, #1
    7156:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    7158:	2300      	movs	r3, #0
    715a:	f88d 300b 	strb.w	r3, [sp, #11]
    715e:	e028      	b.n	71b2 <Spi_GetStatusAsyncCheckHwBusy+0x62>
    {
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7160:	4a18      	ldr	r2, [pc, #96]	; (71c4 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    7162:	9b01      	ldr	r3, [sp, #4]
    7164:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7168:	69da      	ldr	r2, [r3, #28]
    716a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    716e:	009b      	lsls	r3, r3, #2
    7170:	4413      	add	r3, r2
    7172:	681b      	ldr	r3, [r3, #0]
    7174:	2b00      	cmp	r3, #0
    7176:	d017      	beq.n	71a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    7178:	4a12      	ldr	r2, [pc, #72]	; (71c4 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    717a:	9b01      	ldr	r3, [sp, #4]
    717c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7180:	69da      	ldr	r2, [r3, #28]
    7182:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7186:	009b      	lsls	r3, r3, #2
    7188:	4413      	add	r3, r2
    718a:	681b      	ldr	r3, [r3, #0]
    718c:	689b      	ldr	r3, [r3, #8]
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    718e:	9a01      	ldr	r2, [sp, #4]
    7190:	429a      	cmp	r2, r3
    7192:	d109      	bne.n	71a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
           )
        {
            if (SPI_BUSY == Spi_axSpiHwUnitQueueArray[HWUnit].Status)
    7194:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7198:	4a0b      	ldr	r2, [pc, #44]	; (71c8 <Spi_GetStatusAsyncCheckHwBusy+0x78>)
    719a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    719e:	2b02      	cmp	r3, #2
    71a0:	d102      	bne.n	71a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            {
                StatusFlag = SPI_BUSY;
    71a2:	2302      	movs	r3, #2
    71a4:	9303      	str	r3, [sp, #12]
                break;
    71a6:	e008      	b.n	71ba <Spi_GetStatusAsyncCheckHwBusy+0x6a>
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    71a8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    71ac:	3301      	adds	r3, #1
    71ae:	f88d 300b 	strb.w	r3, [sp, #11]
    71b2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    71b6:	2b00      	cmp	r3, #0
    71b8:	d0d2      	beq.n	7160 <Spi_GetStatusAsyncCheckHwBusy+0x10>
        else
        {
            /* Do nothing */
        }
    }
    return StatusFlag;
    71ba:	9b03      	ldr	r3, [sp, #12]
}
    71bc:	4618      	mov	r0, r3
    71be:	b004      	add	sp, #16
    71c0:	4770      	bx	lr
    71c2:	bf00      	nop
    71c4:	1fff8d4c 	.word	0x1fff8d4c
    71c8:	1fff8d44 	.word	0x1fff8d44

000071cc <Spi_GetVersionInfo>:
/** @implements Spi_GetVersionInfo_Activity */
void Spi_GetVersionInfo 
    (
        Std_VersionInfoType *versioninfo
    )
{
    71cc:	b082      	sub	sp, #8
    71ce:	9001      	str	r0, [sp, #4]
        (void)Det_ReportError((uint16)SPI_MODULE_ID,(uint8)0,SPI_GETVERSIONINFO_ID,SPI_E_PARAM_POINTER);
    }
    else
    {
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
    versioninfo->vendorID = (uint16)SPI_VENDOR_ID;
    71d0:	9b01      	ldr	r3, [sp, #4]
    71d2:	222b      	movs	r2, #43	; 0x2b
    71d4:	801a      	strh	r2, [r3, #0]
    versioninfo->moduleID = (uint8)SPI_MODULE_ID;
    71d6:	9b01      	ldr	r3, [sp, #4]
    71d8:	2253      	movs	r2, #83	; 0x53
    71da:	805a      	strh	r2, [r3, #2]
    versioninfo->sw_major_version = (uint8)SPI_SW_MAJOR_VERSION;
    71dc:	9b01      	ldr	r3, [sp, #4]
    71de:	2202      	movs	r2, #2
    71e0:	711a      	strb	r2, [r3, #4]
    versioninfo->sw_minor_version = (uint8)SPI_SW_MINOR_VERSION;
    71e2:	9b01      	ldr	r3, [sp, #4]
    71e4:	2200      	movs	r2, #0
    71e6:	715a      	strb	r2, [r3, #5]
    versioninfo->sw_patch_version = (uint8)SPI_SW_PATCH_VERSION;
    71e8:	9b01      	ldr	r3, [sp, #4]
    71ea:	2200      	movs	r2, #0
    71ec:	719a      	strb	r2, [r3, #6]
#if(SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
}
    71ee:	bf00      	nop
    71f0:	b002      	add	sp, #8
    71f2:	4770      	bx	lr

000071f4 <Spi_Init>:
/** @implements Spi_Init_Activity */
void Spi_Init
    (
        const Spi_ConfigType *ConfigPtr
    )
{
    71f4:	b500      	push	{lr}
    71f6:	b085      	sub	sp, #20
    71f8:	9001      	str	r0, [sp, #4]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    71fa:	2300      	movs	r3, #0
    71fc:	f88d 300e 	strb.w	r3, [sp, #14]

    SpiCoreID = Spi_GetCoreID;
    7200:	2300      	movs	r3, #0
    7202:	9302      	str	r3, [sp, #8]
    CheckStatus = Spi_InitCheckDemError(SpiCoreID, ConfigPtr);
    if ((Std_ReturnType)E_OK == CheckStatus) 
    {
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/

    CheckStatus = Spi_CheckInit(ConfigPtr, SpiCoreID);
    7204:	9902      	ldr	r1, [sp, #8]
    7206:	9801      	ldr	r0, [sp, #4]
    7208:	f7ff fe44 	bl	6e94 <Spi_CheckInit>
    720c:	4603      	mov	r3, r0
    720e:	f88d 300e 	strb.w	r3, [sp, #14]

    if((Std_ReturnType)E_OK == CheckStatus )
    7212:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7216:	2b00      	cmp	r3, #0
    7218:	d144      	bne.n	72a4 <Spi_Init+0xb0>
    {
    #if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
        Spi_apxSpiConfigPtr[SpiCoreID] = ConfigPtr;
    721a:	4924      	ldr	r1, [pc, #144]	; (72ac <Spi_Init+0xb8>)
    721c:	9b02      	ldr	r3, [sp, #8]
    721e:	9a01      	ldr	r2, [sp, #4]
    7220:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    #else /* (SPI_CONFIG_VARIANT == SPI_VARIANT_PRECOMPILE) */
        Spi_apxSpiConfigPtr[SpiCoreID] = Spi_PBCfgVariantPredefined[SpiCoreID];
    #endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */
    /* Initiate Channels, Jobs, Sequences state */
    Spi_InitChannelsJobsSeqsState(SpiCoreID);
    7224:	9802      	ldr	r0, [sp, #8]
    7226:	f7ff feef 	bl	7008 <Spi_InitChannelsJobsSeqsState>
        
        /* initialize all physical HWUnits */
        for (HWUnit = (Spi_HWUnitType) 0;
    722a:	2300      	movs	r3, #0
    722c:	f88d 300f 	strb.w	r3, [sp, #15]
    7230:	e034      	b.n	729c <Spi_Init+0xa8>
            HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
            HWUnit++)
        {
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7232:	4a1e      	ldr	r2, [pc, #120]	; (72ac <Spi_Init+0xb8>)
    7234:	9b02      	ldr	r3, [sp, #8]
    7236:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    723a:	69da      	ldr	r2, [r3, #28]
    723c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7240:	009b      	lsls	r3, r3, #2
    7242:	4413      	add	r3, r2
    7244:	681b      	ldr	r3, [r3, #0]
    7246:	2b00      	cmp	r3, #0
    7248:	d023      	beq.n	7292 <Spi_Init+0x9e>
               (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    724a:	4a18      	ldr	r2, [pc, #96]	; (72ac <Spi_Init+0xb8>)
    724c:	9b02      	ldr	r3, [sp, #8]
    724e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7252:	69da      	ldr	r2, [r3, #28]
    7254:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7258:	009b      	lsls	r3, r3, #2
    725a:	4413      	add	r3, r2
    725c:	681b      	ldr	r3, [r3, #0]
    725e:	689b      	ldr	r3, [r3, #8]
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7260:	9a02      	ldr	r2, [sp, #8]
    7262:	429a      	cmp	r2, r3
    7264:	d115      	bne.n	7292 <Spi_Init+0x9e>
              )
            {
                Spi_Ipw_Init(HWUnit, Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig);
    7266:	4a11      	ldr	r2, [pc, #68]	; (72ac <Spi_Init+0xb8>)
    7268:	9b02      	ldr	r3, [sp, #8]
    726a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    726e:	69da      	ldr	r2, [r3, #28]
    7270:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7274:	009b      	lsls	r3, r3, #2
    7276:	4413      	add	r3, r2
    7278:	681a      	ldr	r2, [r3, #0]
    727a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    727e:	4611      	mov	r1, r2
    7280:	4618      	mov	r0, r3
    7282:	f000 fa8c 	bl	779e <Spi_Ipw_Init>

#if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
                /* initialize the Job lists => no scheduled job for the unit */
                Spi_InitJobsList(HWUnit);
#endif
                Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_IDLE;
    7286:	f89d 300f 	ldrb.w	r3, [sp, #15]
    728a:	4a09      	ldr	r2, [pc, #36]	; (72b0 <Spi_Init+0xbc>)
    728c:	2101      	movs	r1, #1
    728e:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
            HWUnit++)
    7292:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7296:	3301      	adds	r3, #1
    7298:	f88d 300f 	strb.w	r3, [sp, #15]
        for (HWUnit = (Spi_HWUnitType) 0;
    729c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    72a0:	2b00      	cmp	r3, #0
    72a2:	d0c6      	beq.n	7232 <Spi_Init+0x3e>
    }

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/
}
    72a4:	bf00      	nop
    72a6:	b005      	add	sp, #20
    72a8:	f85d fb04 	ldr.w	pc, [sp], #4
    72ac:	1fff8d4c 	.word	0x1fff8d4c
    72b0:	1fff8d44 	.word	0x1fff8d44

000072b4 <Spi_DeInit>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_DeInit_Activity
*/
Std_ReturnType Spi_DeInit(void)
{
    72b4:	b500      	push	{lr}
    72b6:	b083      	sub	sp, #12
    Std_ReturnType TempExit = (Std_ReturnType)E_OK;
    72b8:	2300      	movs	r3, #0
    72ba:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;

    SpiCoreID = Spi_GetCoreID;
    72be:	2300      	movs	r3, #0
    72c0:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Check if Spi Status is Busy */
        if (SPI_BUSY == Spi_GetStatus())
    72c2:	f000 f8b1 	bl	7428 <Spi_GetStatus>
    72c6:	4603      	mov	r3, r0
    72c8:	2b02      	cmp	r3, #2
    72ca:	d103      	bne.n	72d4 <Spi_DeInit+0x20>
        {
            TempExit = E_NOT_OK;
    72cc:	2301      	movs	r3, #1
    72ce:	f88d 3007 	strb.w	r3, [sp, #7]
    72d2:	e037      	b.n	7344 <Spi_DeInit+0x90>
        }
        else
        {
            /* De-initialize all physical HWUnits */
            for (HWUnit = (Spi_HWUnitType) 0;
    72d4:	2300      	movs	r3, #0
    72d6:	f88d 3006 	strb.w	r3, [sp, #6]
    72da:	e02a      	b.n	7332 <Spi_DeInit+0x7e>
                 HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
                 HWUnit++)
            {
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    72dc:	4a1c      	ldr	r2, [pc, #112]	; (7350 <Spi_DeInit+0x9c>)
    72de:	9b00      	ldr	r3, [sp, #0]
    72e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72e4:	69da      	ldr	r2, [r3, #28]
    72e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    72ea:	009b      	lsls	r3, r3, #2
    72ec:	4413      	add	r3, r2
    72ee:	681b      	ldr	r3, [r3, #0]
    72f0:	2b00      	cmp	r3, #0
    72f2:	d019      	beq.n	7328 <Spi_DeInit+0x74>
                    (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    72f4:	4a16      	ldr	r2, [pc, #88]	; (7350 <Spi_DeInit+0x9c>)
    72f6:	9b00      	ldr	r3, [sp, #0]
    72f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72fc:	69da      	ldr	r2, [r3, #28]
    72fe:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7302:	009b      	lsls	r3, r3, #2
    7304:	4413      	add	r3, r2
    7306:	681b      	ldr	r3, [r3, #0]
    7308:	689b      	ldr	r3, [r3, #8]
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    730a:	9a00      	ldr	r2, [sp, #0]
    730c:	429a      	cmp	r2, r3
    730e:	d10b      	bne.n	7328 <Spi_DeInit+0x74>
                   )
                {
                    Spi_Ipw_DeInit(HWUnit, SpiCoreID);
    7310:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7314:	9900      	ldr	r1, [sp, #0]
    7316:	4618      	mov	r0, r3
    7318:	f000 fa54 	bl	77c4 <Spi_Ipw_DeInit>
    
                    Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_UNINIT;
    731c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7320:	4a0c      	ldr	r2, [pc, #48]	; (7354 <Spi_DeInit+0xa0>)
    7322:	2100      	movs	r1, #0
    7324:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
                 HWUnit++)
    7328:	f89d 3006 	ldrb.w	r3, [sp, #6]
    732c:	3301      	adds	r3, #1
    732e:	f88d 3006 	strb.w	r3, [sp, #6]
            for (HWUnit = (Spi_HWUnitType) 0;
    7332:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7336:	2b00      	cmp	r3, #0
    7338:	d0d0      	beq.n	72dc <Spi_DeInit+0x28>
                {
                    /* Do nothing */
                }
            }
            /* Reset configuration pointer */
            Spi_apxSpiConfigPtr[SpiCoreID] = NULL_PTR;
    733a:	4a05      	ldr	r2, [pc, #20]	; (7350 <Spi_DeInit+0x9c>)
    733c:	9b00      	ldr	r3, [sp, #0]
    733e:	2100      	movs	r1, #0
    7340:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return TempExit;
    7344:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    7348:	4618      	mov	r0, r3
    734a:	b003      	add	sp, #12
    734c:	f85d fb04 	ldr.w	pc, [sp], #4
    7350:	1fff8d4c 	.word	0x1fff8d4c
    7354:	1fff8d44 	.word	0x1fff8d44

00007358 <Spi_SetupEB>:
        Spi_ChannelType Channel,
        const Spi_DataBufferType  *SrcDataBufferPtr,
        Spi_DataBufferType *DesDataBufferPtr,
        Spi_NumberOfDataType Length
    )
{
    7358:	b500      	push	{lr}
    735a:	b089      	sub	sp, #36	; 0x24
    735c:	9102      	str	r1, [sp, #8]
    735e:	9201      	str	r2, [sp, #4]
    7360:	461a      	mov	r2, r3
    7362:	4603      	mov	r3, r0
    7364:	f88d 300f 	strb.w	r3, [sp, #15]
    7368:	4613      	mov	r3, r2
    736a:	f8ad 300c 	strh.w	r3, [sp, #12]
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    736e:	2300      	movs	r3, #0
    7370:	f88d 301f 	strb.w	r3, [sp, #31]
    Spi_ChannelStateType *ChannelState;
    const Spi_ChannelConfigType *ChannelConfig;
    uint32 SpiCoreID;

    /* get current coreID */
    SpiCoreID = Spi_GetCoreID;
    7374:	2300      	movs	r3, #0
    7376:	9306      	str	r3, [sp, #24]
        Status = (Std_ReturnType)E_NOT_OK;
    }
    else
    {
#endif
        ChannelState = &Spi_axSpiChannelState[Channel];
    7378:	f89d 300f 	ldrb.w	r3, [sp, #15]
    737c:	009b      	lsls	r3, r3, #2
    737e:	4a28      	ldr	r2, [pc, #160]	; (7420 <Spi_SetupEB+0xc8>)
    7380:	4413      	add	r3, r2
    7382:	9305      	str	r3, [sp, #20]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    7384:	4a27      	ldr	r2, [pc, #156]	; (7424 <Spi_SetupEB+0xcc>)
    7386:	9b06      	ldr	r3, [sp, #24]
    7388:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    738c:	68da      	ldr	r2, [r3, #12]
    738e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7392:	009b      	lsls	r3, r3, #2
    7394:	4413      	add	r3, r2
    7396:	681b      	ldr	r3, [r3, #0]
    7398:	9304      	str	r3, [sp, #16]
        /* exit early if this is the wrong buffer type */
        if (IB == ChannelConfig->BufferType)
    739a:	9b04      	ldr	r3, [sp, #16]
    739c:	681b      	ldr	r3, [r3, #0]
    739e:	2b00      	cmp	r3, #0
    73a0:	d103      	bne.n	73aa <Spi_SetupEB+0x52>
        {
            /* Call Det_ReportError */
#if (SPI_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_SETUPEB_ID,SPI_E_PARAM_CHANNEL);
#endif
            Status = (Std_ReturnType)E_NOT_OK;
    73a2:	2301      	movs	r3, #1
    73a4:	f88d 301f 	strb.w	r3, [sp, #31]
    73a8:	e033      	b.n	7412 <Spi_SetupEB+0xba>
            /* Length and Framesize - aren't compatible */
            /* If 8 < Framesize =< 16: Length must be divisible by 2 */
            /* If 16 < Framesize =< 32: Length must be divisible by 4 */
            Status = Spi_SetupEbCheckLength(ChannelConfig, Length);
#endif
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05();
    73aa:	f001 fec7 	bl	913c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>
            /* save the new parameters */
            ChannelConfig->BufferDescriptor->ExternalBufferTX = SrcDataBufferPtr;
    73ae:	9b04      	ldr	r3, [sp, #16]
    73b0:	691b      	ldr	r3, [r3, #16]
    73b2:	9a02      	ldr	r2, [sp, #8]
    73b4:	601a      	str	r2, [r3, #0]
            ChannelConfig->BufferDescriptor->BufferRX = DesDataBufferPtr;
    73b6:	9b04      	ldr	r3, [sp, #16]
    73b8:	691b      	ldr	r3, [r3, #16]
    73ba:	9a01      	ldr	r2, [sp, #4]
    73bc:	609a      	str	r2, [r3, #8]

            ChannelState->Length = Length;
    73be:	9b05      	ldr	r3, [sp, #20]
    73c0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    73c4:	805a      	strh	r2, [r3, #2]

            /* if source data pointer is zero, transmit default value */
            if (NULL_PTR == SrcDataBufferPtr)
    73c6:	9b02      	ldr	r3, [sp, #8]
    73c8:	2b00      	cmp	r3, #0
    73ca:	d107      	bne.n	73dc <Spi_SetupEB+0x84>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    73cc:	9b05      	ldr	r3, [sp, #20]
    73ce:	781b      	ldrb	r3, [r3, #0]
    73d0:	f043 0301 	orr.w	r3, r3, #1
    73d4:	b2da      	uxtb	r2, r3
    73d6:	9b05      	ldr	r3, [sp, #20]
    73d8:	701a      	strb	r2, [r3, #0]
    73da:	e006      	b.n	73ea <Spi_SetupEB+0x92>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_TX_DEFAULT_U8);
    73dc:	9b05      	ldr	r3, [sp, #20]
    73de:	781b      	ldrb	r3, [r3, #0]
    73e0:	f023 0301 	bic.w	r3, r3, #1
    73e4:	b2da      	uxtb	r2, r3
    73e6:	9b05      	ldr	r3, [sp, #20]
    73e8:	701a      	strb	r2, [r3, #0]
            }

            /* if destination data pointer is zero, discard receiving data */
            if (NULL_PTR == DesDataBufferPtr)
    73ea:	9b01      	ldr	r3, [sp, #4]
    73ec:	2b00      	cmp	r3, #0
    73ee:	d107      	bne.n	7400 <Spi_SetupEB+0xa8>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_RX_DISCARD_U8;
    73f0:	9b05      	ldr	r3, [sp, #20]
    73f2:	781b      	ldrb	r3, [r3, #0]
    73f4:	f043 0302 	orr.w	r3, r3, #2
    73f8:	b2da      	uxtb	r2, r3
    73fa:	9b05      	ldr	r3, [sp, #20]
    73fc:	701a      	strb	r2, [r3, #0]
    73fe:	e006      	b.n	740e <Spi_SetupEB+0xb6>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_RX_DISCARD_U8);
    7400:	9b05      	ldr	r3, [sp, #20]
    7402:	781b      	ldrb	r3, [r3, #0]
    7404:	f023 0302 	bic.w	r3, r3, #2
    7408:	b2da      	uxtb	r2, r3
    740a:	9b05      	ldr	r3, [sp, #20]
    740c:	701a      	strb	r2, [r3, #0]
            }
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05();
    740e:	f001 fec1 	bl	9194 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>
        }
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return Status;
    7412:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    7416:	4618      	mov	r0, r3
    7418:	b009      	add	sp, #36	; 0x24
    741a:	f85d fb04 	ldr.w	pc, [sp], #4
    741e:	bf00      	nop
    7420:	1fff8d58 	.word	0x1fff8d58
    7424:	1fff8d4c 	.word	0x1fff8d4c

00007428 <Spi_GetStatus>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_GetStatus_Activity
*/
Spi_StatusType Spi_GetStatus(void)
{
    7428:	b500      	push	{lr}
    742a:	b085      	sub	sp, #20
    Spi_StatusType StatusFlag = SPI_IDLE;
    742c:	2301      	movs	r3, #1
    742e:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    
    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    7430:	2300      	movs	r3, #0
    7432:	9301      	str	r3, [sp, #4]

    if (NULL_PTR == Spi_apxSpiConfigPtr[SpiCoreID])
    7434:	4a22      	ldr	r2, [pc, #136]	; (74c0 <Spi_GetStatus+0x98>)
    7436:	9b01      	ldr	r3, [sp, #4]
    7438:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    743c:	2b00      	cmp	r3, #0
    743e:	d102      	bne.n	7446 <Spi_GetStatus+0x1e>
        /* If Development Error Detection is enabled, report error if not */
        /* initialized */
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSTATUS_ID,SPI_E_UNINIT);
#endif
        StatusFlag = SPI_UNINIT;
    7440:	2300      	movs	r3, #0
    7442:	9303      	str	r3, [sp, #12]
    7444:	e037      	b.n	74b6 <Spi_GetStatus+0x8e>
    }
    else
    {
        /* The SPI Handler Driver software module shall be busy when any
           HWUnit is busy */
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    7446:	2300      	movs	r3, #0
    7448:	f88d 300b 	strb.w	r3, [sp, #11]
    744c:	e028      	b.n	74a0 <Spi_GetStatus+0x78>
        {
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    744e:	4a1c      	ldr	r2, [pc, #112]	; (74c0 <Spi_GetStatus+0x98>)
    7450:	9b01      	ldr	r3, [sp, #4]
    7452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7456:	69da      	ldr	r2, [r3, #28]
    7458:	f89d 300b 	ldrb.w	r3, [sp, #11]
    745c:	009b      	lsls	r3, r3, #2
    745e:	4413      	add	r3, r2
    7460:	681b      	ldr	r3, [r3, #0]
    7462:	2b00      	cmp	r3, #0
    7464:	d017      	beq.n	7496 <Spi_GetStatus+0x6e>
                (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    7466:	4a16      	ldr	r2, [pc, #88]	; (74c0 <Spi_GetStatus+0x98>)
    7468:	9b01      	ldr	r3, [sp, #4]
    746a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    746e:	69da      	ldr	r2, [r3, #28]
    7470:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7474:	009b      	lsls	r3, r3, #2
    7476:	4413      	add	r3, r2
    7478:	681b      	ldr	r3, [r3, #0]
    747a:	689b      	ldr	r3, [r3, #8]
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    747c:	9a01      	ldr	r2, [sp, #4]
    747e:	429a      	cmp	r2, r3
    7480:	d109      	bne.n	7496 <Spi_GetStatus+0x6e>
               )
            {
                if (1u == Spi_au32SpiBusySyncHWUnitsStatus[HWUnit])
    7482:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7486:	4a0f      	ldr	r2, [pc, #60]	; (74c4 <Spi_GetStatus+0x9c>)
    7488:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    748c:	2b01      	cmp	r3, #1
    748e:	d102      	bne.n	7496 <Spi_GetStatus+0x6e>
                {
                    StatusFlag = SPI_BUSY;
    7490:	2302      	movs	r3, #2
    7492:	9303      	str	r3, [sp, #12]
                    break;
    7494:	e008      	b.n	74a8 <Spi_GetStatus+0x80>
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    7496:	f89d 300b 	ldrb.w	r3, [sp, #11]
    749a:	3301      	adds	r3, #1
    749c:	f88d 300b 	strb.w	r3, [sp, #11]
    74a0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    74a4:	2b00      	cmp	r3, #0
    74a6:	d0d2      	beq.n	744e <Spi_GetStatus+0x26>
            {
                /* Do nothing */
            }
        }
        /* check for busy HWUnit in async transmissions */
        if (SPI_BUSY != StatusFlag)
    74a8:	9b03      	ldr	r3, [sp, #12]
    74aa:	2b02      	cmp	r3, #2
    74ac:	d003      	beq.n	74b6 <Spi_GetStatus+0x8e>
        {
            /* Note: Checking for IsSync attribute for HWUnit is not really needed
                 It is preferable to skip this check in order to have a more compact code
            */
            StatusFlag = Spi_GetStatusAsyncCheckHwBusy(SpiCoreID);
    74ae:	9801      	ldr	r0, [sp, #4]
    74b0:	f7ff fe4e 	bl	7150 <Spi_GetStatusAsyncCheckHwBusy>
    74b4:	9003      	str	r0, [sp, #12]
        else
        {
            /* Do notthing */
        }
    }
    return StatusFlag;
    74b6:	9b03      	ldr	r3, [sp, #12]
}
    74b8:	4618      	mov	r0, r3
    74ba:	b005      	add	sp, #20
    74bc:	f85d fb04 	ldr.w	pc, [sp], #4
    74c0:	1fff8d4c 	.word	0x1fff8d4c
    74c4:	1fff8d60 	.word	0x1fff8d60

000074c8 <Spi_GetJobResult>:
/** @implements Spi_GetJobResult_Activity */
Spi_JobResultType Spi_GetJobResult
    (
        Spi_JobType Job
    )
{
    74c8:	b084      	sub	sp, #16
    74ca:	4603      	mov	r3, r0
    74cc:	f8ad 3006 	strh.w	r3, [sp, #6]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETJOBRESULT_ID,SPI_E_PARAM_CONFIG);
    }
    else
    {
#endif
        JobResult = Spi_axSpiJobState[Job].Result;
    74d0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    74d4:	4a03      	ldr	r2, [pc, #12]	; (74e4 <Spi_GetJobResult+0x1c>)
    74d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74da:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return JobResult;
    74dc:	9b03      	ldr	r3, [sp, #12]
}
    74de:	4618      	mov	r0, r3
    74e0:	b004      	add	sp, #16
    74e2:	4770      	bx	lr
    74e4:	1fff8d54 	.word	0x1fff8d54

000074e8 <Spi_GetSequenceResult>:
/** @implements Spi_GetSequenceResult_Activity */
Spi_SeqResultType Spi_GetSequenceResult
    (
        Spi_SequenceType Sequence
    )
{
    74e8:	b084      	sub	sp, #16
    74ea:	4603      	mov	r3, r0
    74ec:	f88d 3007 	strb.w	r3, [sp, #7]
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSEQUENCERESULT_ID,SPI_E_PARAM_CONFIG);
        }
        else
        {
#endif
           SequenceResult = Spi_axSpiSequenceState[Sequence].Result;
    74f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    74f4:	4a03      	ldr	r2, [pc, #12]	; (7504 <Spi_GetSequenceResult+0x1c>)
    74f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74fa:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif

    return SequenceResult;
    74fc:	9b03      	ldr	r3, [sp, #12]
}
    74fe:	4618      	mov	r0, r3
    7500:	b004      	add	sp, #16
    7502:	4770      	bx	lr
    7504:	1fff8d50 	.word	0x1fff8d50

00007508 <Spi_SyncTransmit>:
/** @implements Spi_SyncTransmit_Activity */
Std_ReturnType Spi_SyncTransmit
    (
        Spi_SequenceType Sequence
    )
{
    7508:	b500      	push	{lr}
    750a:	b08b      	sub	sp, #44	; 0x2c
    750c:	4603      	mov	r3, r0
    750e:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_SequenceStateType *SequenceState;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    7512:	2300      	movs	r3, #0
    7514:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Spi_JobType Job;
    const Spi_JobConfigType *JobConfig;
    uint32 SpiCoreID;

    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    7518:	2300      	movs	r3, #0
    751a:	9308      	str	r3, [sp, #32]
        Status = Spi_SynctransmitCheckJobsIsValid(SequenceConfig, SpiCoreID);

        if ((Std_ReturnType)E_NOT_OK != Status)
        {
#endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    751c:	4a60      	ldr	r2, [pc, #384]	; (76a0 <Spi_SyncTransmit+0x198>)
    751e:	9b08      	ldr	r3, [sp, #32]
    7520:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7524:	695a      	ldr	r2, [r3, #20]
    7526:	f89d 3007 	ldrb.w	r3, [sp, #7]
    752a:	009b      	lsls	r3, r3, #2
    752c:	4413      	add	r3, r2
    752e:	681b      	ldr	r3, [r3, #0]
    7530:	9307      	str	r3, [sp, #28]
            /* Get the number of jobs in the sequence */
            NumJobsInSequence = SequenceConfig->NumJobs;
    7532:	9b07      	ldr	r3, [sp, #28]
    7534:	881b      	ldrh	r3, [r3, #0]
    7536:	f8ad 301a 	strh.w	r3, [sp, #26]

            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06();
    753a:	f001 fe51 	bl	91e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>
            /* check if there are HW units already running */
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    753e:	2300      	movs	r3, #0
    7540:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    7544:	e017      	b.n	7576 <Spi_SyncTransmit+0x6e>
            {
                if (0u != ((Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] << HWUnit) & Spi_au32SpiSeqUsedHWUnits[Sequence]))
    7546:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    754a:	4a56      	ldr	r2, [pc, #344]	; (76a4 <Spi_SyncTransmit+0x19c>)
    754c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    7550:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    7554:	409a      	lsls	r2, r3
    7556:	f89d 3007 	ldrb.w	r3, [sp, #7]
    755a:	4953      	ldr	r1, [pc, #332]	; (76a8 <Spi_SyncTransmit+0x1a0>)
    755c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    7560:	4013      	ands	r3, r2
    7562:	2b00      	cmp	r3, #0
    7564:	d002      	beq.n	756c <Spi_SyncTransmit+0x64>
                {
                    Status = (Std_ReturnType)E_NOT_OK;
    7566:	2301      	movs	r3, #1
    7568:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    756c:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    7570:	3301      	adds	r3, #1
    7572:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    7576:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    757a:	2b00      	cmp	r3, #0
    757c:	d0e3      	beq.n	7546 <Spi_SyncTransmit+0x3e>
                {
                    /* Do notthing */
                }
            }
            
            if ((Std_ReturnType)E_NOT_OK != Status)
    757e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    7582:	2b01      	cmp	r3, #1
    7584:	f000 8083 	beq.w	768e <Spi_SyncTransmit+0x186>
            {
                /* Set the sequence as pending */
                SequenceState = &Spi_axSpiSequenceState[Sequence];
    7588:	f89d 3007 	ldrb.w	r3, [sp, #7]
    758c:	009b      	lsls	r3, r3, #2
    758e:	4a47      	ldr	r2, [pc, #284]	; (76ac <Spi_SyncTransmit+0x1a4>)
    7590:	4413      	add	r3, r2
    7592:	9305      	str	r3, [sp, #20]
                SequenceState->Result = SPI_SEQ_PENDING;
    7594:	9b05      	ldr	r3, [sp, #20]
    7596:	2201      	movs	r2, #1
    7598:	601a      	str	r2, [r3, #0]
                /* set used HW units as busy */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    759a:	2300      	movs	r3, #0
    759c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    75a0:	e022      	b.n	75e8 <Spi_SyncTransmit+0xe0>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    75a2:	9b07      	ldr	r3, [sp, #28]
    75a4:	689a      	ldr	r2, [r3, #8]
    75a6:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    75aa:	005b      	lsls	r3, r3, #1
    75ac:	4413      	add	r3, r2
    75ae:	881b      	ldrh	r3, [r3, #0]
    75b0:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    75b4:	4a3a      	ldr	r2, [pc, #232]	; (76a0 <Spi_SyncTransmit+0x198>)
    75b6:	9b08      	ldr	r3, [sp, #32]
    75b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75bc:	691a      	ldr	r2, [r3, #16]
    75be:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    75c2:	009b      	lsls	r3, r3, #2
    75c4:	4413      	add	r3, r2
    75c6:	681b      	ldr	r3, [r3, #0]
    75c8:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    75ca:	9b03      	ldr	r3, [sp, #12]
    75cc:	7f1b      	ldrb	r3, [r3, #28]
    75ce:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 1u;
    75d2:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    75d6:	4a33      	ldr	r2, [pc, #204]	; (76a4 <Spi_SyncTransmit+0x19c>)
    75d8:	2101      	movs	r1, #1
    75da:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    75de:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    75e2:	3301      	adds	r3, #1
    75e4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    75e8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    75ec:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    75f0:	429a      	cmp	r2, r3
    75f2:	d3d6      	bcc.n	75a2 <Spi_SyncTransmit+0x9a>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    75f4:	f001 fe20 	bl	9238 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
                /* Transmit Jobs */
                Status = Spi_SyncJobsTranfer(SequenceConfig, SpiCoreID);
    75f8:	9908      	ldr	r1, [sp, #32]
    75fa:	9807      	ldr	r0, [sp, #28]
    75fc:	f7ff fc72 	bl	6ee4 <Spi_SyncJobsTranfer>
    7600:	4603      	mov	r3, r0
    7602:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                
                if ((Std_ReturnType)E_OK == Status)
    7606:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    760a:	2b00      	cmp	r3, #0
    760c:	d103      	bne.n	7616 <Spi_SyncTransmit+0x10e>
                {
                    /* Set the sequence as OK */
                    SequenceState->Result = SPI_SEQ_OK;
    760e:	9b05      	ldr	r3, [sp, #20]
    7610:	2200      	movs	r2, #0
    7612:	601a      	str	r2, [r3, #0]
    7614:	e002      	b.n	761c <Spi_SyncTransmit+0x114>
#endif
                }
                else
                {
                    /* Set the sequence as FAILED */
                    SequenceState->Result = SPI_SEQ_FAILED;
    7616:	9b05      	ldr	r3, [sp, #20]
    7618:	2202      	movs	r2, #2
    761a:	601a      	str	r2, [r3, #0]
                    /* Report to DEM */
                    Spi_DemReportStatus(SpiCoreID, DEM_EVENT_STATUS_FAILED);
#endif
                }
                
                SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07();
    761c:	f001 fe32 	bl	9284 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>
                /* set used HW units as idle */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    7620:	2300      	movs	r3, #0
    7622:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    7626:	e022      	b.n	766e <Spi_SyncTransmit+0x166>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    7628:	9b07      	ldr	r3, [sp, #28]
    762a:	689a      	ldr	r2, [r3, #8]
    762c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7630:	005b      	lsls	r3, r3, #1
    7632:	4413      	add	r3, r2
    7634:	881b      	ldrh	r3, [r3, #0]
    7636:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    763a:	4a19      	ldr	r2, [pc, #100]	; (76a0 <Spi_SyncTransmit+0x198>)
    763c:	9b08      	ldr	r3, [sp, #32]
    763e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7642:	691a      	ldr	r2, [r3, #16]
    7644:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    7648:	009b      	lsls	r3, r3, #2
    764a:	4413      	add	r3, r2
    764c:	681b      	ldr	r3, [r3, #0]
    764e:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    7650:	9b03      	ldr	r3, [sp, #12]
    7652:	7f1b      	ldrb	r3, [r3, #28]
    7654:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 0u;
    7658:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    765c:	4a11      	ldr	r2, [pc, #68]	; (76a4 <Spi_SyncTransmit+0x19c>)
    765e:	2100      	movs	r1, #0
    7660:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    7664:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7668:	3301      	adds	r3, #1
    766a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    766e:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    7672:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    7676:	429a      	cmp	r2, r3
    7678:	d3d6      	bcc.n	7628 <Spi_SyncTransmit+0x120>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07();
    767a:	f001 fe2f 	bl	92dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>
                
                /* End Sequence Notification */
                if (NULL_PTR != SequenceConfig->EndNotification)
    767e:	9b07      	ldr	r3, [sp, #28]
    7680:	68db      	ldr	r3, [r3, #12]
    7682:	2b00      	cmp	r3, #0
    7684:	d005      	beq.n	7692 <Spi_SyncTransmit+0x18a>
                {
                    SequenceConfig->EndNotification();
    7686:	9b07      	ldr	r3, [sp, #28]
    7688:	68db      	ldr	r3, [r3, #12]
    768a:	4798      	blx	r3
    768c:	e001      	b.n	7692 <Spi_SyncTransmit+0x18a>
                    /* Do nothing */
                }
            }
            else
            {
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    768e:	f001 fdd3 	bl	9238 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
            /* Do nothing */
        }
    }
#endif

    return Status;
    7692:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    7696:	4618      	mov	r0, r3
    7698:	b00b      	add	sp, #44	; 0x2c
    769a:	f85d fb04 	ldr.w	pc, [sp], #4
    769e:	bf00      	nop
    76a0:	1fff8d4c 	.word	0x1fff8d4c
    76a4:	1fff8d60 	.word	0x1fff8d60
    76a8:	1fff8d5c 	.word	0x1fff8d5c
    76ac:	1fff8d50 	.word	0x1fff8d50

000076b0 <Spi_GetHWUnitStatus>:
/** @implements Spi_GetHWUnitStatus_Activity */
Spi_StatusType Spi_GetHWUnitStatus
    (
        Spi_HWUnitType HWUnit
    )
{
    76b0:	b084      	sub	sp, #16
    76b2:	4603      	mov	r3, r0
    76b4:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_StatusType Status = SPI_UNINIT;
    76b8:	2300      	movs	r3, #0
    76ba:	9303      	str	r3, [sp, #12]
        /* Do nothing */
    }
    else
    {
#endif
        Status = Spi_axSpiHwUnitQueueArray[HWUnit].Status;
    76bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    76c0:	4a03      	ldr	r2, [pc, #12]	; (76d0 <Spi_GetHWUnitStatus+0x20>)
    76c2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    76c6:	9303      	str	r3, [sp, #12]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return Status;
    76c8:	9b03      	ldr	r3, [sp, #12]
}
    76ca:	4618      	mov	r0, r3
    76cc:	b004      	add	sp, #16
    76ce:	4770      	bx	lr
    76d0:	1fff8d44 	.word	0x1fff8d44

000076d4 <Spi_Cancel>:
*       undefined state due to cancelling a sequence transmission.
*
*/
/**  @implements Spi_Cancel_Activity */
void Spi_Cancel(Spi_SequenceType Sequence)
{
    76d4:	b082      	sub	sp, #8
    76d6:	4603      	mov	r3, r0
    76d8:	f88d 3007 	strb.w	r3, [sp, #7]
        }
        else
        {
#endif
            /* Set sequence state to Cancel */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_CANCELLED;
    76dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    76e0:	4a03      	ldr	r2, [pc, #12]	; (76f0 <Spi_Cancel+0x1c>)
    76e2:	2103      	movs	r1, #3
    76e4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            #endif
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif
}
    76e8:	bf00      	nop
    76ea:	b002      	add	sp, #8
    76ec:	4770      	bx	lr
    76ee:	bf00      	nop
    76f0:	1fff8d50 	.word	0x1fff8d50

000076f4 <Spi_MainFunction_Handling>:
                /*Do nothing */
            }
        }
    }
#endif /* #if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2) ) */
}
    76f4:	bf00      	nop
    76f6:	4770      	bx	lr

000076f8 <Spi_Ipw_SyncTransmitProcess>:
        const Spi_JobConfigType *JobConfig,
        const Spi_ChannelConfigType *ChannelConfig,
        Spi_DataBufferType *RxBuffer,
        const Spi_DataBufferType *TxBuffer
    )
{
    76f8:	b500      	push	{lr}
    76fa:	b08d      	sub	sp, #52	; 0x34
    76fc:	9005      	str	r0, [sp, #20]
    76fe:	9104      	str	r1, [sp, #16]
    7700:	9203      	str	r2, [sp, #12]
    7702:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_StatusType Lpspi_spiStatus = LPSPI_IP_STATUS_SUCCESS;
    7704:	2300      	movs	r3, #0
    7706:	930b      	str	r3, [sp, #44]	; 0x2c
    const Lpspi_Ip_ExternalDeviceType* LpspiExternalDevice;
#if (SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)
    Flexio_Spi_Ip_StatusType Flexio_spiStatus = FLEXIO_SPI_IP_STATUS_SUCCESS;
    const Flexio_Spi_Ip_ExternalDeviceType* Flexio_SpiExternalDevice;
#endif
    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    7708:	2300      	movs	r3, #0
    770a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    Spi_NumberOfDataType NumberOfBytes;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    770e:	9b05      	ldr	r3, [sp, #20]
    7710:	6a1b      	ldr	r3, [r3, #32]
    7712:	681b      	ldr	r3, [r3, #0]
    7714:	681b      	ldr	r3, [r3, #0]
    7716:	9309      	str	r3, [sp, #36]	; 0x24
        HalfDuplexMode = LPSPI_IP_FULL_DUPLEX;
        HalfDuplexModeSupport = FALSE;
    }
#endif
    
    NumberOfBytes = ChannelConfig->ChannelState->Length;
    7718:	9b04      	ldr	r3, [sp, #16]
    771a:	699b      	ldr	r3, [r3, #24]
    771c:	885b      	ldrh	r3, [r3, #2]
    771e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    if (SPI_OVER_LPSPI == IpType)
    7722:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7724:	2b00      	cmp	r3, #0
    7726:	d12e      	bne.n	7786 <Spi_Ipw_SyncTransmitProcess+0x8e>
    {
        LpspiExternalDevice = JobConfig->ExternalDeviceConfig->ExDeviceConfig->ExternalDeviceConfig.LpspiExternalDeviceConfig;
    7728:	9b05      	ldr	r3, [sp, #20]
    772a:	6a1b      	ldr	r3, [r3, #32]
    772c:	681b      	ldr	r3, [r3, #0]
    772e:	689b      	ldr	r3, [r3, #8]
    7730:	9307      	str	r3, [sp, #28]
        Lpspi_spiStatus = Lpspi_Ip_UpdateDefaultTransmitData(LpspiExternalDevice, ChannelConfig->DefaultTransmitValue);
    7732:	9b04      	ldr	r3, [sp, #16]
    7734:	689b      	ldr	r3, [r3, #8]
    7736:	4619      	mov	r1, r3
    7738:	9807      	ldr	r0, [sp, #28]
    773a:	f7ff fadd 	bl	6cf8 <Lpspi_Ip_UpdateDefaultTransmitData>
    773e:	900b      	str	r0, [sp, #44]	; 0x2c
        if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    7740:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7742:	2b00      	cmp	r3, #0
    7744:	d11f      	bne.n	7786 <Spi_Ipw_SyncTransmitProcess+0x8e>
        {
            Lpspi_spiStatus = Lpspi_Ip_UpdateFrameSize(LpspiExternalDevice, ChannelConfig->FrameSize);
    7746:	9b04      	ldr	r3, [sp, #16]
    7748:	791b      	ldrb	r3, [r3, #4]
    774a:	b29b      	uxth	r3, r3
    774c:	4619      	mov	r1, r3
    774e:	9807      	ldr	r0, [sp, #28]
    7750:	f7ff fa92 	bl	6c78 <Lpspi_Ip_UpdateFrameSize>
    7754:	900b      	str	r0, [sp, #44]	; 0x2c
            if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    7756:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7758:	2b00      	cmp	r3, #0
    775a:	d114      	bne.n	7786 <Spi_Ipw_SyncTransmitProcess+0x8e>
            {
                Lpspi_spiStatus = Lpspi_Ip_UpdateLsb(LpspiExternalDevice, ChannelConfig->Lsb);
    775c:	9b04      	ldr	r3, [sp, #16]
    775e:	795b      	ldrb	r3, [r3, #5]
    7760:	4619      	mov	r1, r3
    7762:	9807      	ldr	r0, [sp, #28]
    7764:	f7ff faa8 	bl	6cb8 <Lpspi_Ip_UpdateLsb>
    7768:	900b      	str	r0, [sp, #44]	; 0x2c
                if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    776a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    776c:	2b00      	cmp	r3, #0
    776e:	d10a      	bne.n	7786 <Spi_Ipw_SyncTransmitProcess+0x8e>
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmitHalfDuplex(LpspiExternalDevice, Buffer, NumberOfBytes, HalfDuplexMode, SPI_TIMEOUT_COUNTER_U32);
                    }
                    else
                    #endif
                    {
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmit(LpspiExternalDevice, (const uint8*)TxBuffer, RxBuffer, NumberOfBytes, SPI_TIMEOUT_COUNTER_U32);
    7770:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
    7774:	f24c 3250 	movw	r2, #50000	; 0xc350
    7778:	9200      	str	r2, [sp, #0]
    777a:	9a03      	ldr	r2, [sp, #12]
    777c:	9902      	ldr	r1, [sp, #8]
    777e:	9807      	ldr	r0, [sp, #28]
    7780:	f7fe fe0a 	bl	6398 <Lpspi_Ip_SyncTransmit>
    7784:	900b      	str	r0, [sp, #44]	; 0x2c
            }
        }
    }
    if( (LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus) || (FLEXIO_SPI_IP_STATUS_SUCCESS != Flexio_spiStatus))
#else
    if(LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus)
    7786:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7788:	2b00      	cmp	r3, #0
    778a:	d002      	beq.n	7792 <Spi_Ipw_SyncTransmitProcess+0x9a>
#endif /*(SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)*/
    {
        Ipw_Status = (Std_ReturnType)E_NOT_OK;
    778c:	2301      	movs	r3, #1
    778e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    }
    return Ipw_Status;
    7792:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
}
    7796:	4618      	mov	r0, r3
    7798:	b00d      	add	sp, #52	; 0x34
    779a:	f85d fb04 	ldr.w	pc, [sp], #4

0000779e <Spi_Ipw_Init>:
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
/* Spi_Ipw_Init */
void Spi_Ipw_Init(const Spi_HWUnitType HWUnitId, const Spi_HWUnitConfigType *HWUnit)
{
    779e:	b500      	push	{lr}
    77a0:	b083      	sub	sp, #12
    77a2:	4603      	mov	r3, r0
    77a4:	9100      	str	r1, [sp, #0]
    77a6:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == HWUnit->IpType)
    77aa:	9b00      	ldr	r3, [sp, #0]
    77ac:	681b      	ldr	r3, [r3, #0]
    77ae:	2b00      	cmp	r3, #0
    77b0:	d104      	bne.n	77bc <Spi_Ipw_Init+0x1e>
    #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
        Spi_Ipw_au8LpspiHWUnitMapping[HWUnit->Instance] = HWUnitId;
    #else
        (void)HWUnitId;
    #endif
        (void)Lpspi_Ip_Init(HWUnit->IpConfig.LpspiIpConfig);
    77b2:	9b00      	ldr	r3, [sp, #0]
    77b4:	68db      	ldr	r3, [r3, #12]
    77b6:	4618      	mov	r0, r3
    77b8:	f7fe fd62 	bl	6280 <Lpspi_Ip_Init>
        (void)HWUnitId;
    #endif
        (void)Flexio_Spi_Ip_Init(HWUnit->IpConfig.FlexioSpiIpConfig);
    }
#endif
}
    77bc:	bf00      	nop
    77be:	b003      	add	sp, #12
    77c0:	f85d fb04 	ldr.w	pc, [sp], #4

000077c4 <Spi_Ipw_DeInit>:

/* Spi_Ipw_DeInit */
void Spi_Ipw_DeInit(Spi_HWUnitType HWUnit, uint32 SpiCoreID)
{
    77c4:	b500      	push	{lr}
    77c6:	b083      	sub	sp, #12
    77c8:	4603      	mov	r3, r0
    77ca:	9100      	str	r1, [sp, #0]
    77cc:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->IpType)
    77d0:	4a0f      	ldr	r2, [pc, #60]	; (7810 <Spi_Ipw_DeInit+0x4c>)
    77d2:	9b00      	ldr	r3, [sp, #0]
    77d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77d8:	69da      	ldr	r2, [r3, #28]
    77da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77de:	009b      	lsls	r3, r3, #2
    77e0:	4413      	add	r3, r2
    77e2:	681b      	ldr	r3, [r3, #0]
    77e4:	681b      	ldr	r3, [r3, #0]
    77e6:	2b00      	cmp	r3, #0
    77e8:	d10d      	bne.n	7806 <Spi_Ipw_DeInit+0x42>
    {
        (void)Lpspi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    77ea:	4a09      	ldr	r2, [pc, #36]	; (7810 <Spi_Ipw_DeInit+0x4c>)
    77ec:	9b00      	ldr	r3, [sp, #0]
    77ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77f2:	69da      	ldr	r2, [r3, #28]
    77f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77f8:	009b      	lsls	r3, r3, #2
    77fa:	4413      	add	r3, r2
    77fc:	681b      	ldr	r3, [r3, #0]
    77fe:	791b      	ldrb	r3, [r3, #4]
    7800:	4618      	mov	r0, r3
    7802:	f7fe fd99 	bl	6338 <Lpspi_Ip_DeInit>
    else
    {
        (void)Flexio_Spi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    }
#endif
}
    7806:	bf00      	nop
    7808:	b003      	add	sp, #12
    780a:	f85d fb04 	ldr.w	pc, [sp], #4
    780e:	bf00      	nop
    7810:	1fff8d4c 	.word	0x1fff8d4c

00007814 <Spi_Ipw_SyncTransmit>:

/* Spi_Ipw_SyncTransmit */
#if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL2) || (SPI_LEVEL_DELIVERED == SPI_LEVEL0) )
Std_ReturnType Spi_Ipw_SyncTransmit(const Spi_JobConfigType *JobConfig, uint32 SpiCoreID)
{
    7814:	b500      	push	{lr}
    7816:	b08b      	sub	sp, #44	; 0x2c
    7818:	9001      	str	r0, [sp, #4]
    781a:	9100      	str	r1, [sp, #0]

    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    781c:	2300      	movs	r3, #0
    781e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_ChannelConfigType *NextChannelConfig;
    Spi_ChannelType ChannelID;
    Spi_ChannelType NumChannelsInJob;
    Spi_ChannelType ChannelIndex;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    7822:	9b01      	ldr	r3, [sp, #4]
    7824:	6a1b      	ldr	r3, [r3, #32]
    7826:	681b      	ldr	r3, [r3, #0]
    7828:	681b      	ldr	r3, [r3, #0]
    782a:	9306      	str	r3, [sp, #24]
    
    NumChannelsInJob = JobConfig->NumChannels;
    782c:	9b01      	ldr	r3, [sp, #4]
    782e:	781b      	ldrb	r3, [r3, #0]
    7830:	f88d 3017 	strb.w	r3, [sp, #23]
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    7834:	2300      	movs	r3, #0
    7836:	f88d 301f 	strb.w	r3, [sp, #31]
    783a:	e0e6      	b.n	7a0a <Spi_Ipw_SyncTransmit+0x1f6>
    {
        ChannelID = JobConfig->ChannelIndexList[ChannelIndex];
    783c:	9b01      	ldr	r3, [sp, #4]
    783e:	685a      	ldr	r2, [r3, #4]
    7840:	f89d 301f 	ldrb.w	r3, [sp, #31]
    7844:	4413      	add	r3, r2
    7846:	781b      	ldrb	r3, [r3, #0]
    7848:	f88d 3016 	strb.w	r3, [sp, #22]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[ChannelID].ChannelCfg;
    784c:	4a75      	ldr	r2, [pc, #468]	; (7a24 <Spi_Ipw_SyncTransmit+0x210>)
    784e:	9b00      	ldr	r3, [sp, #0]
    7850:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7854:	68da      	ldr	r2, [r3, #12]
    7856:	f89d 3016 	ldrb.w	r3, [sp, #22]
    785a:	009b      	lsls	r3, r3, #2
    785c:	4413      	add	r3, r2
    785e:	681b      	ldr	r3, [r3, #0]
    7860:	9304      	str	r3, [sp, #16]
        RxBuffer = ChannelConfig->BufferDescriptor->BufferRX;
    7862:	9b04      	ldr	r3, [sp, #16]
    7864:	691b      	ldr	r3, [r3, #16]
    7866:	689b      	ldr	r3, [r3, #8]
    7868:	9303      	str	r3, [sp, #12]
        if(0u != (ChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    786a:	9b04      	ldr	r3, [sp, #16]
    786c:	699b      	ldr	r3, [r3, #24]
    786e:	781b      	ldrb	r3, [r3, #0]
    7870:	f003 0301 	and.w	r3, r3, #1
    7874:	2b00      	cmp	r3, #0
    7876:	d002      	beq.n	787e <Spi_Ipw_SyncTransmit+0x6a>
        {
            TxBuffer = NULL_PTR;
    7878:	2300      	movs	r3, #0
    787a:	9308      	str	r3, [sp, #32]
    787c:	e00c      	b.n	7898 <Spi_Ipw_SyncTransmit+0x84>
        }
        else
        {
            if(EB == ChannelConfig->BufferType)
    787e:	9b04      	ldr	r3, [sp, #16]
    7880:	681b      	ldr	r3, [r3, #0]
    7882:	2b01      	cmp	r3, #1
    7884:	d104      	bne.n	7890 <Spi_Ipw_SyncTransmit+0x7c>
            {
                TxBuffer = ChannelConfig->BufferDescriptor->ExternalBufferTX;
    7886:	9b04      	ldr	r3, [sp, #16]
    7888:	691b      	ldr	r3, [r3, #16]
    788a:	681b      	ldr	r3, [r3, #0]
    788c:	9308      	str	r3, [sp, #32]
    788e:	e003      	b.n	7898 <Spi_Ipw_SyncTransmit+0x84>
            }
            else
            {
                TxBuffer = (const uint8*)(ChannelConfig->BufferDescriptor->InternalBufferTX);
    7890:	9b04      	ldr	r3, [sp, #16]
    7892:	691b      	ldr	r3, [r3, #16]
    7894:	685b      	ldr	r3, [r3, #4]
    7896:	9308      	str	r3, [sp, #32]
            }
        }
        
        if (SPI_OVER_LPSPI == IpType)
    7898:	9b06      	ldr	r3, [sp, #24]
    789a:	2b00      	cmp	r3, #0
    789c:	f040 80a7 	bne.w	79ee <Spi_Ipw_SyncTransmit+0x1da>
        {
            if(ChannelIndex == (NumChannelsInJob - 1u))
    78a0:	f89d 201f 	ldrb.w	r2, [sp, #31]
    78a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    78a8:	3b01      	subs	r3, #1
    78aa:	429a      	cmp	r2, r3
    78ac:	d10a      	bne.n	78c4 <Spi_Ipw_SyncTransmit+0xb0>
            {
                /* Clear CS after current channel */
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = FALSE;
    78ae:	9b01      	ldr	r3, [sp, #4]
    78b0:	6a1b      	ldr	r3, [r3, #32]
    78b2:	681b      	ldr	r3, [r3, #0]
    78b4:	791b      	ldrb	r3, [r3, #4]
    78b6:	461a      	mov	r2, r3
    78b8:	4b5b      	ldr	r3, [pc, #364]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    78ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    78be:	2200      	movs	r2, #0
    78c0:	771a      	strb	r2, [r3, #28]
    78c2:	e07b      	b.n	79bc <Spi_Ipw_SyncTransmit+0x1a8>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = TRUE;
    78c4:	9b01      	ldr	r3, [sp, #4]
    78c6:	6a1b      	ldr	r3, [r3, #32]
    78c8:	681b      	ldr	r3, [r3, #0]
    78ca:	791b      	ldrb	r3, [r3, #4]
    78cc:	461a      	mov	r2, r3
    78ce:	4b56      	ldr	r3, [pc, #344]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    78d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    78d4:	2201      	movs	r2, #1
    78d6:	771a      	strb	r2, [r3, #28]
                MCAL_DATA_SYNC_BARRIER();
    78d8:	f3bf 8f4f 	dsb	sy
                /* update data for next transfer */
                NextChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[JobConfig->ChannelIndexList[ChannelIndex + 1u]].ChannelCfg;
    78dc:	4a51      	ldr	r2, [pc, #324]	; (7a24 <Spi_Ipw_SyncTransmit+0x210>)
    78de:	9b00      	ldr	r3, [sp, #0]
    78e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78e4:	68da      	ldr	r2, [r3, #12]
    78e6:	9b01      	ldr	r3, [sp, #4]
    78e8:	6859      	ldr	r1, [r3, #4]
    78ea:	f89d 301f 	ldrb.w	r3, [sp, #31]
    78ee:	3301      	adds	r3, #1
    78f0:	440b      	add	r3, r1
    78f2:	781b      	ldrb	r3, [r3, #0]
    78f4:	009b      	lsls	r3, r3, #2
    78f6:	4413      	add	r3, r2
    78f8:	681b      	ldr	r3, [r3, #0]
    78fa:	9302      	str	r3, [sp, #8]
                MCAL_DATA_SYNC_BARRIER();
    78fc:	f3bf 8f4f 	dsb	sy
                if(0u != (NextChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    7900:	9b02      	ldr	r3, [sp, #8]
    7902:	699b      	ldr	r3, [r3, #24]
    7904:	781b      	ldrb	r3, [r3, #0]
    7906:	f003 0301 	and.w	r3, r3, #1
    790a:	2b00      	cmp	r3, #0
    790c:	d00a      	beq.n	7924 <Spi_Ipw_SyncTransmit+0x110>
                {
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NULL_PTR;
    790e:	9b01      	ldr	r3, [sp, #4]
    7910:	6a1b      	ldr	r3, [r3, #32]
    7912:	681b      	ldr	r3, [r3, #0]
    7914:	791b      	ldrb	r3, [r3, #4]
    7916:	461a      	mov	r2, r3
    7918:	4b43      	ldr	r3, [pc, #268]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    791a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    791e:	2200      	movs	r2, #0
    7920:	62da      	str	r2, [r3, #44]	; 0x2c
    7922:	e01c      	b.n	795e <Spi_Ipw_SyncTransmit+0x14a>
                }
                else
                {
                    if(EB == NextChannelConfig->BufferType)
    7924:	9b02      	ldr	r3, [sp, #8]
    7926:	681b      	ldr	r3, [r3, #0]
    7928:	2b01      	cmp	r3, #1
    792a:	d10c      	bne.n	7946 <Spi_Ipw_SyncTransmit+0x132>
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->ExternalBufferTX;
    792c:	9b02      	ldr	r3, [sp, #8]
    792e:	691a      	ldr	r2, [r3, #16]
    7930:	9b01      	ldr	r3, [sp, #4]
    7932:	6a1b      	ldr	r3, [r3, #32]
    7934:	681b      	ldr	r3, [r3, #0]
    7936:	791b      	ldrb	r3, [r3, #4]
    7938:	4619      	mov	r1, r3
    793a:	4b3b      	ldr	r3, [pc, #236]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    793c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    7940:	6812      	ldr	r2, [r2, #0]
    7942:	62da      	str	r2, [r3, #44]	; 0x2c
    7944:	e00b      	b.n	795e <Spi_Ipw_SyncTransmit+0x14a>
                    }
                    else
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->InternalBufferTX;
    7946:	9b02      	ldr	r3, [sp, #8]
    7948:	691a      	ldr	r2, [r3, #16]
    794a:	9b01      	ldr	r3, [sp, #4]
    794c:	6a1b      	ldr	r3, [r3, #32]
    794e:	681b      	ldr	r3, [r3, #0]
    7950:	791b      	ldrb	r3, [r3, #4]
    7952:	4619      	mov	r1, r3
    7954:	4b34      	ldr	r3, [pc, #208]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    7956:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    795a:	6852      	ldr	r2, [r2, #4]
    795c:	62da      	str	r2, [r3, #44]	; 0x2c
                    }
                }
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FrameSizeNext = NextChannelConfig->FrameSize;
    795e:	9b02      	ldr	r3, [sp, #8]
    7960:	791a      	ldrb	r2, [r3, #4]
    7962:	9b01      	ldr	r3, [sp, #4]
    7964:	6a1b      	ldr	r3, [r3, #32]
    7966:	681b      	ldr	r3, [r3, #0]
    7968:	791b      	ldrb	r3, [r3, #4]
    796a:	4619      	mov	r1, r3
    796c:	4b2e      	ldr	r3, [pc, #184]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    796e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    7972:	b292      	uxth	r2, r2
    7974:	861a      	strh	r2, [r3, #48]	; 0x30
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LsbNext = NextChannelConfig->Lsb;
    7976:	9b01      	ldr	r3, [sp, #4]
    7978:	6a1b      	ldr	r3, [r3, #32]
    797a:	681b      	ldr	r3, [r3, #0]
    797c:	791b      	ldrb	r3, [r3, #4]
    797e:	461a      	mov	r2, r3
    7980:	4b29      	ldr	r3, [pc, #164]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    7982:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7986:	9a02      	ldr	r2, [sp, #8]
    7988:	7952      	ldrb	r2, [r2, #5]
    798a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->DefaultDataNext = NextChannelConfig->DefaultTransmitValue;
    798e:	9b01      	ldr	r3, [sp, #4]
    7990:	6a1b      	ldr	r3, [r3, #32]
    7992:	681b      	ldr	r3, [r3, #0]
    7994:	791b      	ldrb	r3, [r3, #4]
    7996:	461a      	mov	r2, r3
    7998:	4b23      	ldr	r3, [pc, #140]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    799a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    799e:	9a02      	ldr	r2, [sp, #8]
    79a0:	6892      	ldr	r2, [r2, #8]
    79a2:	635a      	str	r2, [r3, #52]	; 0x34
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LengthNext = NextChannelConfig->ChannelState->Length;
    79a4:	9b02      	ldr	r3, [sp, #8]
    79a6:	699a      	ldr	r2, [r3, #24]
    79a8:	9b01      	ldr	r3, [sp, #4]
    79aa:	6a1b      	ldr	r3, [r3, #32]
    79ac:	681b      	ldr	r3, [r3, #0]
    79ae:	791b      	ldrb	r3, [r3, #4]
    79b0:	4619      	mov	r1, r3
    79b2:	4b1d      	ldr	r3, [pc, #116]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    79b4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    79b8:	8852      	ldrh	r2, [r2, #2]
    79ba:	871a      	strh	r2, [r3, #56]	; 0x38
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->NextChannelIsRX = FALSE;
                }
                #endif
            }
            
            if(0u == ChannelIndex)
    79bc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    79c0:	2b00      	cmp	r3, #0
    79c2:	d10a      	bne.n	79da <Spi_Ipw_SyncTransmit+0x1c6>
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = TRUE;
    79c4:	9b01      	ldr	r3, [sp, #4]
    79c6:	6a1b      	ldr	r3, [r3, #32]
    79c8:	681b      	ldr	r3, [r3, #0]
    79ca:	791b      	ldrb	r3, [r3, #4]
    79cc:	461a      	mov	r2, r3
    79ce:	4b16      	ldr	r3, [pc, #88]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    79d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    79d4:	2201      	movs	r2, #1
    79d6:	775a      	strb	r2, [r3, #29]
    79d8:	e009      	b.n	79ee <Spi_Ipw_SyncTransmit+0x1da>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = FALSE;
    79da:	9b01      	ldr	r3, [sp, #4]
    79dc:	6a1b      	ldr	r3, [r3, #32]
    79de:	681b      	ldr	r3, [r3, #0]
    79e0:	791b      	ldrb	r3, [r3, #4]
    79e2:	461a      	mov	r2, r3
    79e4:	4b10      	ldr	r3, [pc, #64]	; (7a28 <Spi_Ipw_SyncTransmit+0x214>)
    79e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    79ea:	2200      	movs	r2, #0
    79ec:	775a      	strb	r2, [r3, #29]
            }
        }
        Ipw_Status = Spi_Ipw_SyncTransmitProcess(JobConfig, ChannelConfig, RxBuffer, (const uint8*)TxBuffer);
    79ee:	9b08      	ldr	r3, [sp, #32]
    79f0:	9a03      	ldr	r2, [sp, #12]
    79f2:	9904      	ldr	r1, [sp, #16]
    79f4:	9801      	ldr	r0, [sp, #4]
    79f6:	f7ff fe7f 	bl	76f8 <Spi_Ipw_SyncTransmitProcess>
    79fa:	4603      	mov	r3, r0
    79fc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    7a00:	f89d 301f 	ldrb.w	r3, [sp, #31]
    7a04:	3301      	adds	r3, #1
    7a06:	f88d 301f 	strb.w	r3, [sp, #31]
    7a0a:	f89d 201f 	ldrb.w	r2, [sp, #31]
    7a0e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7a12:	429a      	cmp	r2, r3
    7a14:	f4ff af12 	bcc.w	783c <Spi_Ipw_SyncTransmit+0x28>
    }
    return Ipw_Status;
    7a18:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    7a1c:	4618      	mov	r0, r3
    7a1e:	b00b      	add	sp, #44	; 0x2c
    7a20:	f85d fb04 	ldr.w	pc, [sp], #4
    7a24:	1fff8d4c 	.word	0x1fff8d4c
    7a28:	1fff8d38 	.word	0x1fff8d38

00007a2c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    7a2c:	b500      	push	{lr}
    7a2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a30:	f7f9 f876 	bl	b20 <Sys_GetCoreID>
    7a34:	4603      	mov	r3, r0
    7a36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    7a38:	4a10      	ldr	r2, [pc, #64]	; (7a7c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    7a3a:	9b01      	ldr	r3, [sp, #4]
    7a3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a40:	2b00      	cmp	r3, #0
    7a42:	d10d      	bne.n	7a60 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7a44:	f7f8 ff8a 	bl	95c <Mcu_schm_read_msr>
    7a48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7a4a:	9b00      	ldr	r3, [sp, #0]
    7a4c:	f003 0301 	and.w	r3, r3, #1
    7a50:	2b00      	cmp	r3, #0
    7a52:	d100      	bne.n	7a56 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7a54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    7a56:	490a      	ldr	r1, [pc, #40]	; (7a80 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    7a58:	9b01      	ldr	r3, [sp, #4]
    7a5a:	9a00      	ldr	r2, [sp, #0]
    7a5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    7a60:	4a06      	ldr	r2, [pc, #24]	; (7a7c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    7a62:	9b01      	ldr	r3, [sp, #4]
    7a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a68:	1c5a      	adds	r2, r3, #1
    7a6a:	4904      	ldr	r1, [pc, #16]	; (7a7c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    7a6c:	9b01      	ldr	r3, [sp, #4]
    7a6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7a72:	bf00      	nop
    7a74:	b003      	add	sp, #12
    7a76:	f85d fb04 	ldr.w	pc, [sp], #4
    7a7a:	bf00      	nop
    7a7c:	1fff8d68 	.word	0x1fff8d68
    7a80:	1fff8d64 	.word	0x1fff8d64

00007a84 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    7a84:	b500      	push	{lr}
    7a86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a88:	f7f9 f84a 	bl	b20 <Sys_GetCoreID>
    7a8c:	4603      	mov	r3, r0
    7a8e:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    7a90:	4a0d      	ldr	r2, [pc, #52]	; (7ac8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    7a92:	9b01      	ldr	r3, [sp, #4]
    7a94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a98:	1e5a      	subs	r2, r3, #1
    7a9a:	490b      	ldr	r1, [pc, #44]	; (7ac8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    7a9c:	9b01      	ldr	r3, [sp, #4]
    7a9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    7aa2:	4a0a      	ldr	r2, [pc, #40]	; (7acc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    7aa4:	9b01      	ldr	r3, [sp, #4]
    7aa6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7aaa:	f003 0301 	and.w	r3, r3, #1
    7aae:	2b00      	cmp	r3, #0
    7ab0:	d106      	bne.n	7ac0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    7ab2:	4a05      	ldr	r2, [pc, #20]	; (7ac8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    7ab4:	9b01      	ldr	r3, [sp, #4]
    7ab6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7aba:	2b00      	cmp	r3, #0
    7abc:	d100      	bne.n	7ac0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7abe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7ac0:	bf00      	nop
    7ac2:	b003      	add	sp, #12
    7ac4:	f85d fb04 	ldr.w	pc, [sp], #4
    7ac8:	1fff8d68 	.word	0x1fff8d68
    7acc:	1fff8d64 	.word	0x1fff8d64

00007ad0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    7ad0:	b500      	push	{lr}
    7ad2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ad4:	f7f9 f824 	bl	b20 <Sys_GetCoreID>
    7ad8:	4603      	mov	r3, r0
    7ada:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    7adc:	4a10      	ldr	r2, [pc, #64]	; (7b20 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    7ade:	9b01      	ldr	r3, [sp, #4]
    7ae0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ae4:	2b00      	cmp	r3, #0
    7ae6:	d10d      	bne.n	7b04 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7ae8:	f7f8 ff38 	bl	95c <Mcu_schm_read_msr>
    7aec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7aee:	9b00      	ldr	r3, [sp, #0]
    7af0:	f003 0301 	and.w	r3, r3, #1
    7af4:	2b00      	cmp	r3, #0
    7af6:	d100      	bne.n	7afa <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7af8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    7afa:	490a      	ldr	r1, [pc, #40]	; (7b24 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    7afc:	9b01      	ldr	r3, [sp, #4]
    7afe:	9a00      	ldr	r2, [sp, #0]
    7b00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    7b04:	4a06      	ldr	r2, [pc, #24]	; (7b20 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    7b06:	9b01      	ldr	r3, [sp, #4]
    7b08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b0c:	1c5a      	adds	r2, r3, #1
    7b0e:	4904      	ldr	r1, [pc, #16]	; (7b20 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    7b10:	9b01      	ldr	r3, [sp, #4]
    7b12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7b16:	bf00      	nop
    7b18:	b003      	add	sp, #12
    7b1a:	f85d fb04 	ldr.w	pc, [sp], #4
    7b1e:	bf00      	nop
    7b20:	1fff8d70 	.word	0x1fff8d70
    7b24:	1fff8d6c 	.word	0x1fff8d6c

00007b28 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    7b28:	b500      	push	{lr}
    7b2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b2c:	f7f8 fff8 	bl	b20 <Sys_GetCoreID>
    7b30:	4603      	mov	r3, r0
    7b32:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    7b34:	4a0d      	ldr	r2, [pc, #52]	; (7b6c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    7b36:	9b01      	ldr	r3, [sp, #4]
    7b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b3c:	1e5a      	subs	r2, r3, #1
    7b3e:	490b      	ldr	r1, [pc, #44]	; (7b6c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    7b40:	9b01      	ldr	r3, [sp, #4]
    7b42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    7b46:	4a0a      	ldr	r2, [pc, #40]	; (7b70 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    7b48:	9b01      	ldr	r3, [sp, #4]
    7b4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b4e:	f003 0301 	and.w	r3, r3, #1
    7b52:	2b00      	cmp	r3, #0
    7b54:	d106      	bne.n	7b64 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    7b56:	4a05      	ldr	r2, [pc, #20]	; (7b6c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    7b58:	9b01      	ldr	r3, [sp, #4]
    7b5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b5e:	2b00      	cmp	r3, #0
    7b60:	d100      	bne.n	7b64 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7b62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7b64:	bf00      	nop
    7b66:	b003      	add	sp, #12
    7b68:	f85d fb04 	ldr.w	pc, [sp], #4
    7b6c:	1fff8d70 	.word	0x1fff8d70
    7b70:	1fff8d6c 	.word	0x1fff8d6c

00007b74 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    7b74:	b500      	push	{lr}
    7b76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b78:	f7f8 ffd2 	bl	b20 <Sys_GetCoreID>
    7b7c:	4603      	mov	r3, r0
    7b7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    7b80:	4a10      	ldr	r2, [pc, #64]	; (7bc4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    7b82:	9b01      	ldr	r3, [sp, #4]
    7b84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b88:	2b00      	cmp	r3, #0
    7b8a:	d10d      	bne.n	7ba8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7b8c:	f7f8 fee6 	bl	95c <Mcu_schm_read_msr>
    7b90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7b92:	9b00      	ldr	r3, [sp, #0]
    7b94:	f003 0301 	and.w	r3, r3, #1
    7b98:	2b00      	cmp	r3, #0
    7b9a:	d100      	bne.n	7b9e <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7b9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    7b9e:	490a      	ldr	r1, [pc, #40]	; (7bc8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    7ba0:	9b01      	ldr	r3, [sp, #4]
    7ba2:	9a00      	ldr	r2, [sp, #0]
    7ba4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    7ba8:	4a06      	ldr	r2, [pc, #24]	; (7bc4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    7baa:	9b01      	ldr	r3, [sp, #4]
    7bac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bb0:	1c5a      	adds	r2, r3, #1
    7bb2:	4904      	ldr	r1, [pc, #16]	; (7bc4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    7bb4:	9b01      	ldr	r3, [sp, #4]
    7bb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7bba:	bf00      	nop
    7bbc:	b003      	add	sp, #12
    7bbe:	f85d fb04 	ldr.w	pc, [sp], #4
    7bc2:	bf00      	nop
    7bc4:	1fff8d78 	.word	0x1fff8d78
    7bc8:	1fff8d74 	.word	0x1fff8d74

00007bcc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    7bcc:	b500      	push	{lr}
    7bce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7bd0:	f7f8 ffa6 	bl	b20 <Sys_GetCoreID>
    7bd4:	4603      	mov	r3, r0
    7bd6:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    7bd8:	4a0d      	ldr	r2, [pc, #52]	; (7c10 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    7bda:	9b01      	ldr	r3, [sp, #4]
    7bdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7be0:	1e5a      	subs	r2, r3, #1
    7be2:	490b      	ldr	r1, [pc, #44]	; (7c10 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    7be4:	9b01      	ldr	r3, [sp, #4]
    7be6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    7bea:	4a0a      	ldr	r2, [pc, #40]	; (7c14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    7bec:	9b01      	ldr	r3, [sp, #4]
    7bee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bf2:	f003 0301 	and.w	r3, r3, #1
    7bf6:	2b00      	cmp	r3, #0
    7bf8:	d106      	bne.n	7c08 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    7bfa:	4a05      	ldr	r2, [pc, #20]	; (7c10 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    7bfc:	9b01      	ldr	r3, [sp, #4]
    7bfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c02:	2b00      	cmp	r3, #0
    7c04:	d100      	bne.n	7c08 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7c06:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7c08:	bf00      	nop
    7c0a:	b003      	add	sp, #12
    7c0c:	f85d fb04 	ldr.w	pc, [sp], #4
    7c10:	1fff8d78 	.word	0x1fff8d78
    7c14:	1fff8d74 	.word	0x1fff8d74

00007c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    7c18:	b500      	push	{lr}
    7c1a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c1c:	f7f8 ff80 	bl	b20 <Sys_GetCoreID>
    7c20:	4603      	mov	r3, r0
    7c22:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    7c24:	4a10      	ldr	r2, [pc, #64]	; (7c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    7c26:	9b01      	ldr	r3, [sp, #4]
    7c28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c2c:	2b00      	cmp	r3, #0
    7c2e:	d10d      	bne.n	7c4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7c30:	f7f8 fe9d 	bl	96e <Port_schm_read_msr>
    7c34:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7c36:	9b00      	ldr	r3, [sp, #0]
    7c38:	f003 0301 	and.w	r3, r3, #1
    7c3c:	2b00      	cmp	r3, #0
    7c3e:	d100      	bne.n	7c42 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7c40:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    7c42:	490a      	ldr	r1, [pc, #40]	; (7c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    7c44:	9b01      	ldr	r3, [sp, #4]
    7c46:	9a00      	ldr	r2, [sp, #0]
    7c48:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    7c4c:	4a06      	ldr	r2, [pc, #24]	; (7c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    7c4e:	9b01      	ldr	r3, [sp, #4]
    7c50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c54:	1c5a      	adds	r2, r3, #1
    7c56:	4904      	ldr	r1, [pc, #16]	; (7c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    7c58:	9b01      	ldr	r3, [sp, #4]
    7c5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7c5e:	bf00      	nop
    7c60:	b003      	add	sp, #12
    7c62:	f85d fb04 	ldr.w	pc, [sp], #4
    7c66:	bf00      	nop
    7c68:	1fff8d80 	.word	0x1fff8d80
    7c6c:	1fff8d7c 	.word	0x1fff8d7c

00007c70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    7c70:	b500      	push	{lr}
    7c72:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c74:	f7f8 ff54 	bl	b20 <Sys_GetCoreID>
    7c78:	4603      	mov	r3, r0
    7c7a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    7c7c:	4a0d      	ldr	r2, [pc, #52]	; (7cb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    7c7e:	9b01      	ldr	r3, [sp, #4]
    7c80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c84:	1e5a      	subs	r2, r3, #1
    7c86:	490b      	ldr	r1, [pc, #44]	; (7cb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    7c88:	9b01      	ldr	r3, [sp, #4]
    7c8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    7c8e:	4a0a      	ldr	r2, [pc, #40]	; (7cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    7c90:	9b01      	ldr	r3, [sp, #4]
    7c92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c96:	f003 0301 	and.w	r3, r3, #1
    7c9a:	2b00      	cmp	r3, #0
    7c9c:	d106      	bne.n	7cac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    7c9e:	4a05      	ldr	r2, [pc, #20]	; (7cb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    7ca0:	9b01      	ldr	r3, [sp, #4]
    7ca2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ca6:	2b00      	cmp	r3, #0
    7ca8:	d100      	bne.n	7cac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7caa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7cac:	bf00      	nop
    7cae:	b003      	add	sp, #12
    7cb0:	f85d fb04 	ldr.w	pc, [sp], #4
    7cb4:	1fff8d80 	.word	0x1fff8d80
    7cb8:	1fff8d7c 	.word	0x1fff8d7c

00007cbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    7cbc:	b500      	push	{lr}
    7cbe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7cc0:	f7f8 ff2e 	bl	b20 <Sys_GetCoreID>
    7cc4:	4603      	mov	r3, r0
    7cc6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    7cc8:	4a10      	ldr	r2, [pc, #64]	; (7d0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    7cca:	9b01      	ldr	r3, [sp, #4]
    7ccc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cd0:	2b00      	cmp	r3, #0
    7cd2:	d10d      	bne.n	7cf0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7cd4:	f7f8 fe4b 	bl	96e <Port_schm_read_msr>
    7cd8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7cda:	9b00      	ldr	r3, [sp, #0]
    7cdc:	f003 0301 	and.w	r3, r3, #1
    7ce0:	2b00      	cmp	r3, #0
    7ce2:	d100      	bne.n	7ce6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7ce4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    7ce6:	490a      	ldr	r1, [pc, #40]	; (7d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    7ce8:	9b01      	ldr	r3, [sp, #4]
    7cea:	9a00      	ldr	r2, [sp, #0]
    7cec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    7cf0:	4a06      	ldr	r2, [pc, #24]	; (7d0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    7cf2:	9b01      	ldr	r3, [sp, #4]
    7cf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cf8:	1c5a      	adds	r2, r3, #1
    7cfa:	4904      	ldr	r1, [pc, #16]	; (7d0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    7cfc:	9b01      	ldr	r3, [sp, #4]
    7cfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7d02:	bf00      	nop
    7d04:	b003      	add	sp, #12
    7d06:	f85d fb04 	ldr.w	pc, [sp], #4
    7d0a:	bf00      	nop
    7d0c:	1fff8d88 	.word	0x1fff8d88
    7d10:	1fff8d84 	.word	0x1fff8d84

00007d14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    7d14:	b500      	push	{lr}
    7d16:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d18:	f7f8 ff02 	bl	b20 <Sys_GetCoreID>
    7d1c:	4603      	mov	r3, r0
    7d1e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    7d20:	4a0d      	ldr	r2, [pc, #52]	; (7d58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    7d22:	9b01      	ldr	r3, [sp, #4]
    7d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d28:	1e5a      	subs	r2, r3, #1
    7d2a:	490b      	ldr	r1, [pc, #44]	; (7d58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    7d2c:	9b01      	ldr	r3, [sp, #4]
    7d2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    7d32:	4a0a      	ldr	r2, [pc, #40]	; (7d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    7d34:	9b01      	ldr	r3, [sp, #4]
    7d36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d3a:	f003 0301 	and.w	r3, r3, #1
    7d3e:	2b00      	cmp	r3, #0
    7d40:	d106      	bne.n	7d50 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    7d42:	4a05      	ldr	r2, [pc, #20]	; (7d58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    7d44:	9b01      	ldr	r3, [sp, #4]
    7d46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d4a:	2b00      	cmp	r3, #0
    7d4c:	d100      	bne.n	7d50 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7d4e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7d50:	bf00      	nop
    7d52:	b003      	add	sp, #12
    7d54:	f85d fb04 	ldr.w	pc, [sp], #4
    7d58:	1fff8d88 	.word	0x1fff8d88
    7d5c:	1fff8d84 	.word	0x1fff8d84

00007d60 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    7d60:	b500      	push	{lr}
    7d62:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d64:	f7f8 fedc 	bl	b20 <Sys_GetCoreID>
    7d68:	4603      	mov	r3, r0
    7d6a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    7d6c:	4a10      	ldr	r2, [pc, #64]	; (7db0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    7d6e:	9b01      	ldr	r3, [sp, #4]
    7d70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d74:	2b00      	cmp	r3, #0
    7d76:	d10d      	bne.n	7d94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7d78:	f7f8 fdf9 	bl	96e <Port_schm_read_msr>
    7d7c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7d7e:	9b00      	ldr	r3, [sp, #0]
    7d80:	f003 0301 	and.w	r3, r3, #1
    7d84:	2b00      	cmp	r3, #0
    7d86:	d100      	bne.n	7d8a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7d88:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    7d8a:	490a      	ldr	r1, [pc, #40]	; (7db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    7d8c:	9b01      	ldr	r3, [sp, #4]
    7d8e:	9a00      	ldr	r2, [sp, #0]
    7d90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    7d94:	4a06      	ldr	r2, [pc, #24]	; (7db0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    7d96:	9b01      	ldr	r3, [sp, #4]
    7d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d9c:	1c5a      	adds	r2, r3, #1
    7d9e:	4904      	ldr	r1, [pc, #16]	; (7db0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    7da0:	9b01      	ldr	r3, [sp, #4]
    7da2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7da6:	bf00      	nop
    7da8:	b003      	add	sp, #12
    7daa:	f85d fb04 	ldr.w	pc, [sp], #4
    7dae:	bf00      	nop
    7db0:	1fff8d90 	.word	0x1fff8d90
    7db4:	1fff8d8c 	.word	0x1fff8d8c

00007db8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    7db8:	b500      	push	{lr}
    7dba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7dbc:	f7f8 feb0 	bl	b20 <Sys_GetCoreID>
    7dc0:	4603      	mov	r3, r0
    7dc2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    7dc4:	4a0d      	ldr	r2, [pc, #52]	; (7dfc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    7dc6:	9b01      	ldr	r3, [sp, #4]
    7dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dcc:	1e5a      	subs	r2, r3, #1
    7dce:	490b      	ldr	r1, [pc, #44]	; (7dfc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    7dd0:	9b01      	ldr	r3, [sp, #4]
    7dd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    7dd6:	4a0a      	ldr	r2, [pc, #40]	; (7e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    7dd8:	9b01      	ldr	r3, [sp, #4]
    7dda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dde:	f003 0301 	and.w	r3, r3, #1
    7de2:	2b00      	cmp	r3, #0
    7de4:	d106      	bne.n	7df4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    7de6:	4a05      	ldr	r2, [pc, #20]	; (7dfc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    7de8:	9b01      	ldr	r3, [sp, #4]
    7dea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dee:	2b00      	cmp	r3, #0
    7df0:	d100      	bne.n	7df4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7df2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7df4:	bf00      	nop
    7df6:	b003      	add	sp, #12
    7df8:	f85d fb04 	ldr.w	pc, [sp], #4
    7dfc:	1fff8d90 	.word	0x1fff8d90
    7e00:	1fff8d8c 	.word	0x1fff8d8c

00007e04 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    7e04:	b500      	push	{lr}
    7e06:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e08:	f7f8 fe8a 	bl	b20 <Sys_GetCoreID>
    7e0c:	4603      	mov	r3, r0
    7e0e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    7e10:	4a10      	ldr	r2, [pc, #64]	; (7e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    7e12:	9b01      	ldr	r3, [sp, #4]
    7e14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e18:	2b00      	cmp	r3, #0
    7e1a:	d10d      	bne.n	7e38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7e1c:	f7f8 fda7 	bl	96e <Port_schm_read_msr>
    7e20:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7e22:	9b00      	ldr	r3, [sp, #0]
    7e24:	f003 0301 	and.w	r3, r3, #1
    7e28:	2b00      	cmp	r3, #0
    7e2a:	d100      	bne.n	7e2e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7e2c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    7e2e:	490a      	ldr	r1, [pc, #40]	; (7e58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    7e30:	9b01      	ldr	r3, [sp, #4]
    7e32:	9a00      	ldr	r2, [sp, #0]
    7e34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    7e38:	4a06      	ldr	r2, [pc, #24]	; (7e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    7e3a:	9b01      	ldr	r3, [sp, #4]
    7e3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e40:	1c5a      	adds	r2, r3, #1
    7e42:	4904      	ldr	r1, [pc, #16]	; (7e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    7e44:	9b01      	ldr	r3, [sp, #4]
    7e46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7e4a:	bf00      	nop
    7e4c:	b003      	add	sp, #12
    7e4e:	f85d fb04 	ldr.w	pc, [sp], #4
    7e52:	bf00      	nop
    7e54:	1fff8d98 	.word	0x1fff8d98
    7e58:	1fff8d94 	.word	0x1fff8d94

00007e5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    7e5c:	b500      	push	{lr}
    7e5e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e60:	f7f8 fe5e 	bl	b20 <Sys_GetCoreID>
    7e64:	4603      	mov	r3, r0
    7e66:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    7e68:	4a0d      	ldr	r2, [pc, #52]	; (7ea0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    7e6a:	9b01      	ldr	r3, [sp, #4]
    7e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e70:	1e5a      	subs	r2, r3, #1
    7e72:	490b      	ldr	r1, [pc, #44]	; (7ea0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    7e74:	9b01      	ldr	r3, [sp, #4]
    7e76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    7e7a:	4a0a      	ldr	r2, [pc, #40]	; (7ea4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    7e7c:	9b01      	ldr	r3, [sp, #4]
    7e7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e82:	f003 0301 	and.w	r3, r3, #1
    7e86:	2b00      	cmp	r3, #0
    7e88:	d106      	bne.n	7e98 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    7e8a:	4a05      	ldr	r2, [pc, #20]	; (7ea0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    7e8c:	9b01      	ldr	r3, [sp, #4]
    7e8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e92:	2b00      	cmp	r3, #0
    7e94:	d100      	bne.n	7e98 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7e96:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7e98:	bf00      	nop
    7e9a:	b003      	add	sp, #12
    7e9c:	f85d fb04 	ldr.w	pc, [sp], #4
    7ea0:	1fff8d98 	.word	0x1fff8d98
    7ea4:	1fff8d94 	.word	0x1fff8d94

00007ea8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    7ea8:	b500      	push	{lr}
    7eaa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7eac:	f7f8 fe38 	bl	b20 <Sys_GetCoreID>
    7eb0:	4603      	mov	r3, r0
    7eb2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    7eb4:	4a10      	ldr	r2, [pc, #64]	; (7ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    7eb6:	9b01      	ldr	r3, [sp, #4]
    7eb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ebc:	2b00      	cmp	r3, #0
    7ebe:	d10d      	bne.n	7edc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7ec0:	f7f8 fd55 	bl	96e <Port_schm_read_msr>
    7ec4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7ec6:	9b00      	ldr	r3, [sp, #0]
    7ec8:	f003 0301 	and.w	r3, r3, #1
    7ecc:	2b00      	cmp	r3, #0
    7ece:	d100      	bne.n	7ed2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7ed0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    7ed2:	490a      	ldr	r1, [pc, #40]	; (7efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    7ed4:	9b01      	ldr	r3, [sp, #4]
    7ed6:	9a00      	ldr	r2, [sp, #0]
    7ed8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    7edc:	4a06      	ldr	r2, [pc, #24]	; (7ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    7ede:	9b01      	ldr	r3, [sp, #4]
    7ee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ee4:	1c5a      	adds	r2, r3, #1
    7ee6:	4904      	ldr	r1, [pc, #16]	; (7ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    7ee8:	9b01      	ldr	r3, [sp, #4]
    7eea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7eee:	bf00      	nop
    7ef0:	b003      	add	sp, #12
    7ef2:	f85d fb04 	ldr.w	pc, [sp], #4
    7ef6:	bf00      	nop
    7ef8:	1fff8da0 	.word	0x1fff8da0
    7efc:	1fff8d9c 	.word	0x1fff8d9c

00007f00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    7f00:	b500      	push	{lr}
    7f02:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7f04:	f7f8 fe0c 	bl	b20 <Sys_GetCoreID>
    7f08:	4603      	mov	r3, r0
    7f0a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    7f0c:	4a0d      	ldr	r2, [pc, #52]	; (7f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7f0e:	9b01      	ldr	r3, [sp, #4]
    7f10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f14:	1e5a      	subs	r2, r3, #1
    7f16:	490b      	ldr	r1, [pc, #44]	; (7f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7f18:	9b01      	ldr	r3, [sp, #4]
    7f1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    7f1e:	4a0a      	ldr	r2, [pc, #40]	; (7f48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    7f20:	9b01      	ldr	r3, [sp, #4]
    7f22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f26:	f003 0301 	and.w	r3, r3, #1
    7f2a:	2b00      	cmp	r3, #0
    7f2c:	d106      	bne.n	7f3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    7f2e:	4a05      	ldr	r2, [pc, #20]	; (7f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7f30:	9b01      	ldr	r3, [sp, #4]
    7f32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f36:	2b00      	cmp	r3, #0
    7f38:	d100      	bne.n	7f3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7f3a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7f3c:	bf00      	nop
    7f3e:	b003      	add	sp, #12
    7f40:	f85d fb04 	ldr.w	pc, [sp], #4
    7f44:	1fff8da0 	.word	0x1fff8da0
    7f48:	1fff8d9c 	.word	0x1fff8d9c

00007f4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    7f4c:	b500      	push	{lr}
    7f4e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7f50:	f7f8 fde6 	bl	b20 <Sys_GetCoreID>
    7f54:	4603      	mov	r3, r0
    7f56:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    7f58:	4a10      	ldr	r2, [pc, #64]	; (7f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    7f5a:	9b01      	ldr	r3, [sp, #4]
    7f5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f60:	2b00      	cmp	r3, #0
    7f62:	d10d      	bne.n	7f80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7f64:	f7f8 fd03 	bl	96e <Port_schm_read_msr>
    7f68:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7f6a:	9b00      	ldr	r3, [sp, #0]
    7f6c:	f003 0301 	and.w	r3, r3, #1
    7f70:	2b00      	cmp	r3, #0
    7f72:	d100      	bne.n	7f76 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7f74:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    7f76:	490a      	ldr	r1, [pc, #40]	; (7fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    7f78:	9b01      	ldr	r3, [sp, #4]
    7f7a:	9a00      	ldr	r2, [sp, #0]
    7f7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    7f80:	4a06      	ldr	r2, [pc, #24]	; (7f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    7f82:	9b01      	ldr	r3, [sp, #4]
    7f84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f88:	1c5a      	adds	r2, r3, #1
    7f8a:	4904      	ldr	r1, [pc, #16]	; (7f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    7f8c:	9b01      	ldr	r3, [sp, #4]
    7f8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7f92:	bf00      	nop
    7f94:	b003      	add	sp, #12
    7f96:	f85d fb04 	ldr.w	pc, [sp], #4
    7f9a:	bf00      	nop
    7f9c:	1fff8da8 	.word	0x1fff8da8
    7fa0:	1fff8da4 	.word	0x1fff8da4

00007fa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    7fa4:	b500      	push	{lr}
    7fa6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7fa8:	f7f8 fdba 	bl	b20 <Sys_GetCoreID>
    7fac:	4603      	mov	r3, r0
    7fae:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    7fb0:	4a0d      	ldr	r2, [pc, #52]	; (7fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    7fb2:	9b01      	ldr	r3, [sp, #4]
    7fb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fb8:	1e5a      	subs	r2, r3, #1
    7fba:	490b      	ldr	r1, [pc, #44]	; (7fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    7fbc:	9b01      	ldr	r3, [sp, #4]
    7fbe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    7fc2:	4a0a      	ldr	r2, [pc, #40]	; (7fec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    7fc4:	9b01      	ldr	r3, [sp, #4]
    7fc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fca:	f003 0301 	and.w	r3, r3, #1
    7fce:	2b00      	cmp	r3, #0
    7fd0:	d106      	bne.n	7fe0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    7fd2:	4a05      	ldr	r2, [pc, #20]	; (7fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    7fd4:	9b01      	ldr	r3, [sp, #4]
    7fd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fda:	2b00      	cmp	r3, #0
    7fdc:	d100      	bne.n	7fe0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7fde:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7fe0:	bf00      	nop
    7fe2:	b003      	add	sp, #12
    7fe4:	f85d fb04 	ldr.w	pc, [sp], #4
    7fe8:	1fff8da8 	.word	0x1fff8da8
    7fec:	1fff8da4 	.word	0x1fff8da4

00007ff0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    7ff0:	b500      	push	{lr}
    7ff2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ff4:	f7f8 fd94 	bl	b20 <Sys_GetCoreID>
    7ff8:	4603      	mov	r3, r0
    7ffa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    7ffc:	4a10      	ldr	r2, [pc, #64]	; (8040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    7ffe:	9b01      	ldr	r3, [sp, #4]
    8000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8004:	2b00      	cmp	r3, #0
    8006:	d10d      	bne.n	8024 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8008:	f7f8 fcb1 	bl	96e <Port_schm_read_msr>
    800c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    800e:	9b00      	ldr	r3, [sp, #0]
    8010:	f003 0301 	and.w	r3, r3, #1
    8014:	2b00      	cmp	r3, #0
    8016:	d100      	bne.n	801a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8018:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    801a:	490a      	ldr	r1, [pc, #40]	; (8044 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    801c:	9b01      	ldr	r3, [sp, #4]
    801e:	9a00      	ldr	r2, [sp, #0]
    8020:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    8024:	4a06      	ldr	r2, [pc, #24]	; (8040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    8026:	9b01      	ldr	r3, [sp, #4]
    8028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    802c:	1c5a      	adds	r2, r3, #1
    802e:	4904      	ldr	r1, [pc, #16]	; (8040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    8030:	9b01      	ldr	r3, [sp, #4]
    8032:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8036:	bf00      	nop
    8038:	b003      	add	sp, #12
    803a:	f85d fb04 	ldr.w	pc, [sp], #4
    803e:	bf00      	nop
    8040:	1fff8db0 	.word	0x1fff8db0
    8044:	1fff8dac 	.word	0x1fff8dac

00008048 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    8048:	b500      	push	{lr}
    804a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    804c:	f7f8 fd68 	bl	b20 <Sys_GetCoreID>
    8050:	4603      	mov	r3, r0
    8052:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    8054:	4a0d      	ldr	r2, [pc, #52]	; (808c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8056:	9b01      	ldr	r3, [sp, #4]
    8058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    805c:	1e5a      	subs	r2, r3, #1
    805e:	490b      	ldr	r1, [pc, #44]	; (808c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8060:	9b01      	ldr	r3, [sp, #4]
    8062:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    8066:	4a0a      	ldr	r2, [pc, #40]	; (8090 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    8068:	9b01      	ldr	r3, [sp, #4]
    806a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    806e:	f003 0301 	and.w	r3, r3, #1
    8072:	2b00      	cmp	r3, #0
    8074:	d106      	bne.n	8084 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    8076:	4a05      	ldr	r2, [pc, #20]	; (808c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8078:	9b01      	ldr	r3, [sp, #4]
    807a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    807e:	2b00      	cmp	r3, #0
    8080:	d100      	bne.n	8084 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8082:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8084:	bf00      	nop
    8086:	b003      	add	sp, #12
    8088:	f85d fb04 	ldr.w	pc, [sp], #4
    808c:	1fff8db0 	.word	0x1fff8db0
    8090:	1fff8dac 	.word	0x1fff8dac

00008094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    8094:	b500      	push	{lr}
    8096:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8098:	f7f8 fd42 	bl	b20 <Sys_GetCoreID>
    809c:	4603      	mov	r3, r0
    809e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    80a0:	4a10      	ldr	r2, [pc, #64]	; (80e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    80a2:	9b01      	ldr	r3, [sp, #4]
    80a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80a8:	2b00      	cmp	r3, #0
    80aa:	d10d      	bne.n	80c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    80ac:	f7f8 fc5f 	bl	96e <Port_schm_read_msr>
    80b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    80b2:	9b00      	ldr	r3, [sp, #0]
    80b4:	f003 0301 	and.w	r3, r3, #1
    80b8:	2b00      	cmp	r3, #0
    80ba:	d100      	bne.n	80be <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    80bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    80be:	490a      	ldr	r1, [pc, #40]	; (80e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    80c0:	9b01      	ldr	r3, [sp, #4]
    80c2:	9a00      	ldr	r2, [sp, #0]
    80c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    80c8:	4a06      	ldr	r2, [pc, #24]	; (80e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    80ca:	9b01      	ldr	r3, [sp, #4]
    80cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80d0:	1c5a      	adds	r2, r3, #1
    80d2:	4904      	ldr	r1, [pc, #16]	; (80e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    80d4:	9b01      	ldr	r3, [sp, #4]
    80d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    80da:	bf00      	nop
    80dc:	b003      	add	sp, #12
    80de:	f85d fb04 	ldr.w	pc, [sp], #4
    80e2:	bf00      	nop
    80e4:	1fff8db8 	.word	0x1fff8db8
    80e8:	1fff8db4 	.word	0x1fff8db4

000080ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    80ec:	b500      	push	{lr}
    80ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    80f0:	f7f8 fd16 	bl	b20 <Sys_GetCoreID>
    80f4:	4603      	mov	r3, r0
    80f6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    80f8:	4a0d      	ldr	r2, [pc, #52]	; (8130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    80fa:	9b01      	ldr	r3, [sp, #4]
    80fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8100:	1e5a      	subs	r2, r3, #1
    8102:	490b      	ldr	r1, [pc, #44]	; (8130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    8104:	9b01      	ldr	r3, [sp, #4]
    8106:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    810a:	4a0a      	ldr	r2, [pc, #40]	; (8134 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    810c:	9b01      	ldr	r3, [sp, #4]
    810e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8112:	f003 0301 	and.w	r3, r3, #1
    8116:	2b00      	cmp	r3, #0
    8118:	d106      	bne.n	8128 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    811a:	4a05      	ldr	r2, [pc, #20]	; (8130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    811c:	9b01      	ldr	r3, [sp, #4]
    811e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8122:	2b00      	cmp	r3, #0
    8124:	d100      	bne.n	8128 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8126:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8128:	bf00      	nop
    812a:	b003      	add	sp, #12
    812c:	f85d fb04 	ldr.w	pc, [sp], #4
    8130:	1fff8db8 	.word	0x1fff8db8
    8134:	1fff8db4 	.word	0x1fff8db4

00008138 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    8138:	b500      	push	{lr}
    813a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    813c:	f7f8 fcf0 	bl	b20 <Sys_GetCoreID>
    8140:	4603      	mov	r3, r0
    8142:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    8144:	4a10      	ldr	r2, [pc, #64]	; (8188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    8146:	9b01      	ldr	r3, [sp, #4]
    8148:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    814c:	2b00      	cmp	r3, #0
    814e:	d10d      	bne.n	816c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8150:	f7f8 fc0d 	bl	96e <Port_schm_read_msr>
    8154:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8156:	9b00      	ldr	r3, [sp, #0]
    8158:	f003 0301 	and.w	r3, r3, #1
    815c:	2b00      	cmp	r3, #0
    815e:	d100      	bne.n	8162 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8160:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    8162:	490a      	ldr	r1, [pc, #40]	; (818c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    8164:	9b01      	ldr	r3, [sp, #4]
    8166:	9a00      	ldr	r2, [sp, #0]
    8168:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    816c:	4a06      	ldr	r2, [pc, #24]	; (8188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    816e:	9b01      	ldr	r3, [sp, #4]
    8170:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8174:	1c5a      	adds	r2, r3, #1
    8176:	4904      	ldr	r1, [pc, #16]	; (8188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    8178:	9b01      	ldr	r3, [sp, #4]
    817a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    817e:	bf00      	nop
    8180:	b003      	add	sp, #12
    8182:	f85d fb04 	ldr.w	pc, [sp], #4
    8186:	bf00      	nop
    8188:	1fff8dc0 	.word	0x1fff8dc0
    818c:	1fff8dbc 	.word	0x1fff8dbc

00008190 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    8190:	b500      	push	{lr}
    8192:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8194:	f7f8 fcc4 	bl	b20 <Sys_GetCoreID>
    8198:	4603      	mov	r3, r0
    819a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    819c:	4a0d      	ldr	r2, [pc, #52]	; (81d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    819e:	9b01      	ldr	r3, [sp, #4]
    81a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81a4:	1e5a      	subs	r2, r3, #1
    81a6:	490b      	ldr	r1, [pc, #44]	; (81d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    81a8:	9b01      	ldr	r3, [sp, #4]
    81aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    81ae:	4a0a      	ldr	r2, [pc, #40]	; (81d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    81b0:	9b01      	ldr	r3, [sp, #4]
    81b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81b6:	f003 0301 	and.w	r3, r3, #1
    81ba:	2b00      	cmp	r3, #0
    81bc:	d106      	bne.n	81cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    81be:	4a05      	ldr	r2, [pc, #20]	; (81d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    81c0:	9b01      	ldr	r3, [sp, #4]
    81c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81c6:	2b00      	cmp	r3, #0
    81c8:	d100      	bne.n	81cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    81ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    81cc:	bf00      	nop
    81ce:	b003      	add	sp, #12
    81d0:	f85d fb04 	ldr.w	pc, [sp], #4
    81d4:	1fff8dc0 	.word	0x1fff8dc0
    81d8:	1fff8dbc 	.word	0x1fff8dbc

000081dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    81dc:	b500      	push	{lr}
    81de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    81e0:	f7f8 fc9e 	bl	b20 <Sys_GetCoreID>
    81e4:	4603      	mov	r3, r0
    81e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    81e8:	4a10      	ldr	r2, [pc, #64]	; (822c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    81ea:	9b01      	ldr	r3, [sp, #4]
    81ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81f0:	2b00      	cmp	r3, #0
    81f2:	d10d      	bne.n	8210 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    81f4:	f7f8 fbbb 	bl	96e <Port_schm_read_msr>
    81f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    81fa:	9b00      	ldr	r3, [sp, #0]
    81fc:	f003 0301 	and.w	r3, r3, #1
    8200:	2b00      	cmp	r3, #0
    8202:	d100      	bne.n	8206 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8204:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    8206:	490a      	ldr	r1, [pc, #40]	; (8230 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    8208:	9b01      	ldr	r3, [sp, #4]
    820a:	9a00      	ldr	r2, [sp, #0]
    820c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    8210:	4a06      	ldr	r2, [pc, #24]	; (822c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    8212:	9b01      	ldr	r3, [sp, #4]
    8214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8218:	1c5a      	adds	r2, r3, #1
    821a:	4904      	ldr	r1, [pc, #16]	; (822c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    821c:	9b01      	ldr	r3, [sp, #4]
    821e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8222:	bf00      	nop
    8224:	b003      	add	sp, #12
    8226:	f85d fb04 	ldr.w	pc, [sp], #4
    822a:	bf00      	nop
    822c:	1fff8dc8 	.word	0x1fff8dc8
    8230:	1fff8dc4 	.word	0x1fff8dc4

00008234 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    8234:	b500      	push	{lr}
    8236:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8238:	f7f8 fc72 	bl	b20 <Sys_GetCoreID>
    823c:	4603      	mov	r3, r0
    823e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    8240:	4a0d      	ldr	r2, [pc, #52]	; (8278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    8242:	9b01      	ldr	r3, [sp, #4]
    8244:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8248:	1e5a      	subs	r2, r3, #1
    824a:	490b      	ldr	r1, [pc, #44]	; (8278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    824c:	9b01      	ldr	r3, [sp, #4]
    824e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    8252:	4a0a      	ldr	r2, [pc, #40]	; (827c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    8254:	9b01      	ldr	r3, [sp, #4]
    8256:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    825a:	f003 0301 	and.w	r3, r3, #1
    825e:	2b00      	cmp	r3, #0
    8260:	d106      	bne.n	8270 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    8262:	4a05      	ldr	r2, [pc, #20]	; (8278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    8264:	9b01      	ldr	r3, [sp, #4]
    8266:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    826a:	2b00      	cmp	r3, #0
    826c:	d100      	bne.n	8270 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    826e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8270:	bf00      	nop
    8272:	b003      	add	sp, #12
    8274:	f85d fb04 	ldr.w	pc, [sp], #4
    8278:	1fff8dc8 	.word	0x1fff8dc8
    827c:	1fff8dc4 	.word	0x1fff8dc4

00008280 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    8280:	b500      	push	{lr}
    8282:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8284:	f7f8 fc4c 	bl	b20 <Sys_GetCoreID>
    8288:	4603      	mov	r3, r0
    828a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    828c:	4a10      	ldr	r2, [pc, #64]	; (82d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    828e:	9b01      	ldr	r3, [sp, #4]
    8290:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8294:	2b00      	cmp	r3, #0
    8296:	d10d      	bne.n	82b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8298:	f7f8 fb69 	bl	96e <Port_schm_read_msr>
    829c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    829e:	9b00      	ldr	r3, [sp, #0]
    82a0:	f003 0301 	and.w	r3, r3, #1
    82a4:	2b00      	cmp	r3, #0
    82a6:	d100      	bne.n	82aa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    82a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    82aa:	490a      	ldr	r1, [pc, #40]	; (82d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    82ac:	9b01      	ldr	r3, [sp, #4]
    82ae:	9a00      	ldr	r2, [sp, #0]
    82b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    82b4:	4a06      	ldr	r2, [pc, #24]	; (82d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    82b6:	9b01      	ldr	r3, [sp, #4]
    82b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82bc:	1c5a      	adds	r2, r3, #1
    82be:	4904      	ldr	r1, [pc, #16]	; (82d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    82c0:	9b01      	ldr	r3, [sp, #4]
    82c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    82c6:	bf00      	nop
    82c8:	b003      	add	sp, #12
    82ca:	f85d fb04 	ldr.w	pc, [sp], #4
    82ce:	bf00      	nop
    82d0:	1fff8dd0 	.word	0x1fff8dd0
    82d4:	1fff8dcc 	.word	0x1fff8dcc

000082d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    82d8:	b500      	push	{lr}
    82da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    82dc:	f7f8 fc20 	bl	b20 <Sys_GetCoreID>
    82e0:	4603      	mov	r3, r0
    82e2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    82e4:	4a0d      	ldr	r2, [pc, #52]	; (831c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    82e6:	9b01      	ldr	r3, [sp, #4]
    82e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82ec:	1e5a      	subs	r2, r3, #1
    82ee:	490b      	ldr	r1, [pc, #44]	; (831c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    82f0:	9b01      	ldr	r3, [sp, #4]
    82f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    82f6:	4a0a      	ldr	r2, [pc, #40]	; (8320 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    82f8:	9b01      	ldr	r3, [sp, #4]
    82fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82fe:	f003 0301 	and.w	r3, r3, #1
    8302:	2b00      	cmp	r3, #0
    8304:	d106      	bne.n	8314 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    8306:	4a05      	ldr	r2, [pc, #20]	; (831c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    8308:	9b01      	ldr	r3, [sp, #4]
    830a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    830e:	2b00      	cmp	r3, #0
    8310:	d100      	bne.n	8314 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8312:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8314:	bf00      	nop
    8316:	b003      	add	sp, #12
    8318:	f85d fb04 	ldr.w	pc, [sp], #4
    831c:	1fff8dd0 	.word	0x1fff8dd0
    8320:	1fff8dcc 	.word	0x1fff8dcc

00008324 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    8324:	b500      	push	{lr}
    8326:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8328:	f7f8 fbfa 	bl	b20 <Sys_GetCoreID>
    832c:	4603      	mov	r3, r0
    832e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    8330:	4a10      	ldr	r2, [pc, #64]	; (8374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    8332:	9b01      	ldr	r3, [sp, #4]
    8334:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8338:	2b00      	cmp	r3, #0
    833a:	d10d      	bne.n	8358 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    833c:	f7f8 fb17 	bl	96e <Port_schm_read_msr>
    8340:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8342:	9b00      	ldr	r3, [sp, #0]
    8344:	f003 0301 	and.w	r3, r3, #1
    8348:	2b00      	cmp	r3, #0
    834a:	d100      	bne.n	834e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    834c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    834e:	490a      	ldr	r1, [pc, #40]	; (8378 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    8350:	9b01      	ldr	r3, [sp, #4]
    8352:	9a00      	ldr	r2, [sp, #0]
    8354:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    8358:	4a06      	ldr	r2, [pc, #24]	; (8374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    835a:	9b01      	ldr	r3, [sp, #4]
    835c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8360:	1c5a      	adds	r2, r3, #1
    8362:	4904      	ldr	r1, [pc, #16]	; (8374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    8364:	9b01      	ldr	r3, [sp, #4]
    8366:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    836a:	bf00      	nop
    836c:	b003      	add	sp, #12
    836e:	f85d fb04 	ldr.w	pc, [sp], #4
    8372:	bf00      	nop
    8374:	1fff8dd8 	.word	0x1fff8dd8
    8378:	1fff8dd4 	.word	0x1fff8dd4

0000837c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    837c:	b500      	push	{lr}
    837e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8380:	f7f8 fbce 	bl	b20 <Sys_GetCoreID>
    8384:	4603      	mov	r3, r0
    8386:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    8388:	4a0d      	ldr	r2, [pc, #52]	; (83c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    838a:	9b01      	ldr	r3, [sp, #4]
    838c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8390:	1e5a      	subs	r2, r3, #1
    8392:	490b      	ldr	r1, [pc, #44]	; (83c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    8394:	9b01      	ldr	r3, [sp, #4]
    8396:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    839a:	4a0a      	ldr	r2, [pc, #40]	; (83c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    839c:	9b01      	ldr	r3, [sp, #4]
    839e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83a2:	f003 0301 	and.w	r3, r3, #1
    83a6:	2b00      	cmp	r3, #0
    83a8:	d106      	bne.n	83b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    83aa:	4a05      	ldr	r2, [pc, #20]	; (83c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    83ac:	9b01      	ldr	r3, [sp, #4]
    83ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83b2:	2b00      	cmp	r3, #0
    83b4:	d100      	bne.n	83b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    83b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    83b8:	bf00      	nop
    83ba:	b003      	add	sp, #12
    83bc:	f85d fb04 	ldr.w	pc, [sp], #4
    83c0:	1fff8dd8 	.word	0x1fff8dd8
    83c4:	1fff8dd4 	.word	0x1fff8dd4

000083c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    83c8:	b500      	push	{lr}
    83ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    83cc:	f7f8 fba8 	bl	b20 <Sys_GetCoreID>
    83d0:	4603      	mov	r3, r0
    83d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    83d4:	4a10      	ldr	r2, [pc, #64]	; (8418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    83d6:	9b01      	ldr	r3, [sp, #4]
    83d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83dc:	2b00      	cmp	r3, #0
    83de:	d10d      	bne.n	83fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    83e0:	f7f8 fac5 	bl	96e <Port_schm_read_msr>
    83e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    83e6:	9b00      	ldr	r3, [sp, #0]
    83e8:	f003 0301 	and.w	r3, r3, #1
    83ec:	2b00      	cmp	r3, #0
    83ee:	d100      	bne.n	83f2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    83f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    83f2:	490a      	ldr	r1, [pc, #40]	; (841c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    83f4:	9b01      	ldr	r3, [sp, #4]
    83f6:	9a00      	ldr	r2, [sp, #0]
    83f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    83fc:	4a06      	ldr	r2, [pc, #24]	; (8418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    83fe:	9b01      	ldr	r3, [sp, #4]
    8400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8404:	1c5a      	adds	r2, r3, #1
    8406:	4904      	ldr	r1, [pc, #16]	; (8418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    8408:	9b01      	ldr	r3, [sp, #4]
    840a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    840e:	bf00      	nop
    8410:	b003      	add	sp, #12
    8412:	f85d fb04 	ldr.w	pc, [sp], #4
    8416:	bf00      	nop
    8418:	1fff8de0 	.word	0x1fff8de0
    841c:	1fff8ddc 	.word	0x1fff8ddc

00008420 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    8420:	b500      	push	{lr}
    8422:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8424:	f7f8 fb7c 	bl	b20 <Sys_GetCoreID>
    8428:	4603      	mov	r3, r0
    842a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    842c:	4a0d      	ldr	r2, [pc, #52]	; (8464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    842e:	9b01      	ldr	r3, [sp, #4]
    8430:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8434:	1e5a      	subs	r2, r3, #1
    8436:	490b      	ldr	r1, [pc, #44]	; (8464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    8438:	9b01      	ldr	r3, [sp, #4]
    843a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    843e:	4a0a      	ldr	r2, [pc, #40]	; (8468 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    8440:	9b01      	ldr	r3, [sp, #4]
    8442:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8446:	f003 0301 	and.w	r3, r3, #1
    844a:	2b00      	cmp	r3, #0
    844c:	d106      	bne.n	845c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    844e:	4a05      	ldr	r2, [pc, #20]	; (8464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    8450:	9b01      	ldr	r3, [sp, #4]
    8452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8456:	2b00      	cmp	r3, #0
    8458:	d100      	bne.n	845c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    845a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    845c:	bf00      	nop
    845e:	b003      	add	sp, #12
    8460:	f85d fb04 	ldr.w	pc, [sp], #4
    8464:	1fff8de0 	.word	0x1fff8de0
    8468:	1fff8ddc 	.word	0x1fff8ddc

0000846c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    846c:	b500      	push	{lr}
    846e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8470:	f7f8 fb56 	bl	b20 <Sys_GetCoreID>
    8474:	4603      	mov	r3, r0
    8476:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    8478:	4a10      	ldr	r2, [pc, #64]	; (84bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    847a:	9b01      	ldr	r3, [sp, #4]
    847c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8480:	2b00      	cmp	r3, #0
    8482:	d10d      	bne.n	84a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8484:	f7f8 fa73 	bl	96e <Port_schm_read_msr>
    8488:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    848a:	9b00      	ldr	r3, [sp, #0]
    848c:	f003 0301 	and.w	r3, r3, #1
    8490:	2b00      	cmp	r3, #0
    8492:	d100      	bne.n	8496 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8494:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    8496:	490a      	ldr	r1, [pc, #40]	; (84c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    8498:	9b01      	ldr	r3, [sp, #4]
    849a:	9a00      	ldr	r2, [sp, #0]
    849c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    84a0:	4a06      	ldr	r2, [pc, #24]	; (84bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    84a2:	9b01      	ldr	r3, [sp, #4]
    84a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84a8:	1c5a      	adds	r2, r3, #1
    84aa:	4904      	ldr	r1, [pc, #16]	; (84bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    84ac:	9b01      	ldr	r3, [sp, #4]
    84ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    84b2:	bf00      	nop
    84b4:	b003      	add	sp, #12
    84b6:	f85d fb04 	ldr.w	pc, [sp], #4
    84ba:	bf00      	nop
    84bc:	1fff8de8 	.word	0x1fff8de8
    84c0:	1fff8de4 	.word	0x1fff8de4

000084c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    84c4:	b500      	push	{lr}
    84c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    84c8:	f7f8 fb2a 	bl	b20 <Sys_GetCoreID>
    84cc:	4603      	mov	r3, r0
    84ce:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    84d0:	4a0d      	ldr	r2, [pc, #52]	; (8508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    84d2:	9b01      	ldr	r3, [sp, #4]
    84d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84d8:	1e5a      	subs	r2, r3, #1
    84da:	490b      	ldr	r1, [pc, #44]	; (8508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    84dc:	9b01      	ldr	r3, [sp, #4]
    84de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    84e2:	4a0a      	ldr	r2, [pc, #40]	; (850c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    84e4:	9b01      	ldr	r3, [sp, #4]
    84e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84ea:	f003 0301 	and.w	r3, r3, #1
    84ee:	2b00      	cmp	r3, #0
    84f0:	d106      	bne.n	8500 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    84f2:	4a05      	ldr	r2, [pc, #20]	; (8508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    84f4:	9b01      	ldr	r3, [sp, #4]
    84f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84fa:	2b00      	cmp	r3, #0
    84fc:	d100      	bne.n	8500 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    84fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8500:	bf00      	nop
    8502:	b003      	add	sp, #12
    8504:	f85d fb04 	ldr.w	pc, [sp], #4
    8508:	1fff8de8 	.word	0x1fff8de8
    850c:	1fff8de4 	.word	0x1fff8de4

00008510 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    8510:	b500      	push	{lr}
    8512:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8514:	f7f8 fb04 	bl	b20 <Sys_GetCoreID>
    8518:	4603      	mov	r3, r0
    851a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    851c:	4a10      	ldr	r2, [pc, #64]	; (8560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    851e:	9b01      	ldr	r3, [sp, #4]
    8520:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8524:	2b00      	cmp	r3, #0
    8526:	d10d      	bne.n	8544 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8528:	f7f8 fa21 	bl	96e <Port_schm_read_msr>
    852c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    852e:	9b00      	ldr	r3, [sp, #0]
    8530:	f003 0301 	and.w	r3, r3, #1
    8534:	2b00      	cmp	r3, #0
    8536:	d100      	bne.n	853a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8538:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    853a:	490a      	ldr	r1, [pc, #40]	; (8564 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    853c:	9b01      	ldr	r3, [sp, #4]
    853e:	9a00      	ldr	r2, [sp, #0]
    8540:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    8544:	4a06      	ldr	r2, [pc, #24]	; (8560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    8546:	9b01      	ldr	r3, [sp, #4]
    8548:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    854c:	1c5a      	adds	r2, r3, #1
    854e:	4904      	ldr	r1, [pc, #16]	; (8560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    8550:	9b01      	ldr	r3, [sp, #4]
    8552:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8556:	bf00      	nop
    8558:	b003      	add	sp, #12
    855a:	f85d fb04 	ldr.w	pc, [sp], #4
    855e:	bf00      	nop
    8560:	1fff8df0 	.word	0x1fff8df0
    8564:	1fff8dec 	.word	0x1fff8dec

00008568 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    8568:	b500      	push	{lr}
    856a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    856c:	f7f8 fad8 	bl	b20 <Sys_GetCoreID>
    8570:	4603      	mov	r3, r0
    8572:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    8574:	4a0d      	ldr	r2, [pc, #52]	; (85ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    8576:	9b01      	ldr	r3, [sp, #4]
    8578:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    857c:	1e5a      	subs	r2, r3, #1
    857e:	490b      	ldr	r1, [pc, #44]	; (85ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    8580:	9b01      	ldr	r3, [sp, #4]
    8582:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    8586:	4a0a      	ldr	r2, [pc, #40]	; (85b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    8588:	9b01      	ldr	r3, [sp, #4]
    858a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    858e:	f003 0301 	and.w	r3, r3, #1
    8592:	2b00      	cmp	r3, #0
    8594:	d106      	bne.n	85a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    8596:	4a05      	ldr	r2, [pc, #20]	; (85ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    8598:	9b01      	ldr	r3, [sp, #4]
    859a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    859e:	2b00      	cmp	r3, #0
    85a0:	d100      	bne.n	85a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    85a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    85a4:	bf00      	nop
    85a6:	b003      	add	sp, #12
    85a8:	f85d fb04 	ldr.w	pc, [sp], #4
    85ac:	1fff8df0 	.word	0x1fff8df0
    85b0:	1fff8dec 	.word	0x1fff8dec

000085b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    85b4:	b500      	push	{lr}
    85b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    85b8:	f7f8 fab2 	bl	b20 <Sys_GetCoreID>
    85bc:	4603      	mov	r3, r0
    85be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    85c0:	4a10      	ldr	r2, [pc, #64]	; (8604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    85c2:	9b01      	ldr	r3, [sp, #4]
    85c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85c8:	2b00      	cmp	r3, #0
    85ca:	d10d      	bne.n	85e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    85cc:	f7f8 f9cf 	bl	96e <Port_schm_read_msr>
    85d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    85d2:	9b00      	ldr	r3, [sp, #0]
    85d4:	f003 0301 	and.w	r3, r3, #1
    85d8:	2b00      	cmp	r3, #0
    85da:	d100      	bne.n	85de <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    85dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    85de:	490a      	ldr	r1, [pc, #40]	; (8608 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    85e0:	9b01      	ldr	r3, [sp, #4]
    85e2:	9a00      	ldr	r2, [sp, #0]
    85e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    85e8:	4a06      	ldr	r2, [pc, #24]	; (8604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    85ea:	9b01      	ldr	r3, [sp, #4]
    85ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85f0:	1c5a      	adds	r2, r3, #1
    85f2:	4904      	ldr	r1, [pc, #16]	; (8604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    85f4:	9b01      	ldr	r3, [sp, #4]
    85f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    85fa:	bf00      	nop
    85fc:	b003      	add	sp, #12
    85fe:	f85d fb04 	ldr.w	pc, [sp], #4
    8602:	bf00      	nop
    8604:	1fff8df8 	.word	0x1fff8df8
    8608:	1fff8df4 	.word	0x1fff8df4

0000860c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    860c:	b500      	push	{lr}
    860e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8610:	f7f8 fa86 	bl	b20 <Sys_GetCoreID>
    8614:	4603      	mov	r3, r0
    8616:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    8618:	4a0d      	ldr	r2, [pc, #52]	; (8650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    861a:	9b01      	ldr	r3, [sp, #4]
    861c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8620:	1e5a      	subs	r2, r3, #1
    8622:	490b      	ldr	r1, [pc, #44]	; (8650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    8624:	9b01      	ldr	r3, [sp, #4]
    8626:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    862a:	4a0a      	ldr	r2, [pc, #40]	; (8654 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    862c:	9b01      	ldr	r3, [sp, #4]
    862e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8632:	f003 0301 	and.w	r3, r3, #1
    8636:	2b00      	cmp	r3, #0
    8638:	d106      	bne.n	8648 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    863a:	4a05      	ldr	r2, [pc, #20]	; (8650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    863c:	9b01      	ldr	r3, [sp, #4]
    863e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8642:	2b00      	cmp	r3, #0
    8644:	d100      	bne.n	8648 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8646:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8648:	bf00      	nop
    864a:	b003      	add	sp, #12
    864c:	f85d fb04 	ldr.w	pc, [sp], #4
    8650:	1fff8df8 	.word	0x1fff8df8
    8654:	1fff8df4 	.word	0x1fff8df4

00008658 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    8658:	b500      	push	{lr}
    865a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    865c:	f7f8 fa60 	bl	b20 <Sys_GetCoreID>
    8660:	4603      	mov	r3, r0
    8662:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    8664:	4a10      	ldr	r2, [pc, #64]	; (86a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    8666:	9b01      	ldr	r3, [sp, #4]
    8668:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    866c:	2b00      	cmp	r3, #0
    866e:	d10d      	bne.n	868c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8670:	f7f8 f97d 	bl	96e <Port_schm_read_msr>
    8674:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8676:	9b00      	ldr	r3, [sp, #0]
    8678:	f003 0301 	and.w	r3, r3, #1
    867c:	2b00      	cmp	r3, #0
    867e:	d100      	bne.n	8682 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8680:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    8682:	490a      	ldr	r1, [pc, #40]	; (86ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    8684:	9b01      	ldr	r3, [sp, #4]
    8686:	9a00      	ldr	r2, [sp, #0]
    8688:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    868c:	4a06      	ldr	r2, [pc, #24]	; (86a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    868e:	9b01      	ldr	r3, [sp, #4]
    8690:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8694:	1c5a      	adds	r2, r3, #1
    8696:	4904      	ldr	r1, [pc, #16]	; (86a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    8698:	9b01      	ldr	r3, [sp, #4]
    869a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    869e:	bf00      	nop
    86a0:	b003      	add	sp, #12
    86a2:	f85d fb04 	ldr.w	pc, [sp], #4
    86a6:	bf00      	nop
    86a8:	1fff8e00 	.word	0x1fff8e00
    86ac:	1fff8dfc 	.word	0x1fff8dfc

000086b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    86b0:	b500      	push	{lr}
    86b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    86b4:	f7f8 fa34 	bl	b20 <Sys_GetCoreID>
    86b8:	4603      	mov	r3, r0
    86ba:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    86bc:	4a0d      	ldr	r2, [pc, #52]	; (86f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    86be:	9b01      	ldr	r3, [sp, #4]
    86c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86c4:	1e5a      	subs	r2, r3, #1
    86c6:	490b      	ldr	r1, [pc, #44]	; (86f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    86c8:	9b01      	ldr	r3, [sp, #4]
    86ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    86ce:	4a0a      	ldr	r2, [pc, #40]	; (86f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    86d0:	9b01      	ldr	r3, [sp, #4]
    86d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86d6:	f003 0301 	and.w	r3, r3, #1
    86da:	2b00      	cmp	r3, #0
    86dc:	d106      	bne.n	86ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    86de:	4a05      	ldr	r2, [pc, #20]	; (86f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    86e0:	9b01      	ldr	r3, [sp, #4]
    86e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86e6:	2b00      	cmp	r3, #0
    86e8:	d100      	bne.n	86ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    86ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    86ec:	bf00      	nop
    86ee:	b003      	add	sp, #12
    86f0:	f85d fb04 	ldr.w	pc, [sp], #4
    86f4:	1fff8e00 	.word	0x1fff8e00
    86f8:	1fff8dfc 	.word	0x1fff8dfc

000086fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    86fc:	b500      	push	{lr}
    86fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8700:	f7f8 fa0e 	bl	b20 <Sys_GetCoreID>
    8704:	4603      	mov	r3, r0
    8706:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    8708:	4a10      	ldr	r2, [pc, #64]	; (874c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    870a:	9b01      	ldr	r3, [sp, #4]
    870c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8710:	2b00      	cmp	r3, #0
    8712:	d10d      	bne.n	8730 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8714:	f7f8 f92b 	bl	96e <Port_schm_read_msr>
    8718:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    871a:	9b00      	ldr	r3, [sp, #0]
    871c:	f003 0301 	and.w	r3, r3, #1
    8720:	2b00      	cmp	r3, #0
    8722:	d100      	bne.n	8726 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8724:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    8726:	490a      	ldr	r1, [pc, #40]	; (8750 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    8728:	9b01      	ldr	r3, [sp, #4]
    872a:	9a00      	ldr	r2, [sp, #0]
    872c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    8730:	4a06      	ldr	r2, [pc, #24]	; (874c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    8732:	9b01      	ldr	r3, [sp, #4]
    8734:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8738:	1c5a      	adds	r2, r3, #1
    873a:	4904      	ldr	r1, [pc, #16]	; (874c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    873c:	9b01      	ldr	r3, [sp, #4]
    873e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8742:	bf00      	nop
    8744:	b003      	add	sp, #12
    8746:	f85d fb04 	ldr.w	pc, [sp], #4
    874a:	bf00      	nop
    874c:	1fff8e08 	.word	0x1fff8e08
    8750:	1fff8e04 	.word	0x1fff8e04

00008754 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    8754:	b500      	push	{lr}
    8756:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8758:	f7f8 f9e2 	bl	b20 <Sys_GetCoreID>
    875c:	4603      	mov	r3, r0
    875e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    8760:	4a0d      	ldr	r2, [pc, #52]	; (8798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    8762:	9b01      	ldr	r3, [sp, #4]
    8764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8768:	1e5a      	subs	r2, r3, #1
    876a:	490b      	ldr	r1, [pc, #44]	; (8798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    876c:	9b01      	ldr	r3, [sp, #4]
    876e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    8772:	4a0a      	ldr	r2, [pc, #40]	; (879c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    8774:	9b01      	ldr	r3, [sp, #4]
    8776:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    877a:	f003 0301 	and.w	r3, r3, #1
    877e:	2b00      	cmp	r3, #0
    8780:	d106      	bne.n	8790 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    8782:	4a05      	ldr	r2, [pc, #20]	; (8798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    8784:	9b01      	ldr	r3, [sp, #4]
    8786:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    878a:	2b00      	cmp	r3, #0
    878c:	d100      	bne.n	8790 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    878e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8790:	bf00      	nop
    8792:	b003      	add	sp, #12
    8794:	f85d fb04 	ldr.w	pc, [sp], #4
    8798:	1fff8e08 	.word	0x1fff8e08
    879c:	1fff8e04 	.word	0x1fff8e04

000087a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    87a0:	b500      	push	{lr}
    87a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87a4:	f7f8 f9bc 	bl	b20 <Sys_GetCoreID>
    87a8:	4603      	mov	r3, r0
    87aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    87ac:	4a10      	ldr	r2, [pc, #64]	; (87f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    87ae:	9b01      	ldr	r3, [sp, #4]
    87b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87b4:	2b00      	cmp	r3, #0
    87b6:	d10d      	bne.n	87d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    87b8:	f7f8 f8d9 	bl	96e <Port_schm_read_msr>
    87bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    87be:	9b00      	ldr	r3, [sp, #0]
    87c0:	f003 0301 	and.w	r3, r3, #1
    87c4:	2b00      	cmp	r3, #0
    87c6:	d100      	bne.n	87ca <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    87c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    87ca:	490a      	ldr	r1, [pc, #40]	; (87f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    87cc:	9b01      	ldr	r3, [sp, #4]
    87ce:	9a00      	ldr	r2, [sp, #0]
    87d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    87d4:	4a06      	ldr	r2, [pc, #24]	; (87f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    87d6:	9b01      	ldr	r3, [sp, #4]
    87d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87dc:	1c5a      	adds	r2, r3, #1
    87de:	4904      	ldr	r1, [pc, #16]	; (87f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    87e0:	9b01      	ldr	r3, [sp, #4]
    87e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    87e6:	bf00      	nop
    87e8:	b003      	add	sp, #12
    87ea:	f85d fb04 	ldr.w	pc, [sp], #4
    87ee:	bf00      	nop
    87f0:	1fff8e10 	.word	0x1fff8e10
    87f4:	1fff8e0c 	.word	0x1fff8e0c

000087f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    87f8:	b500      	push	{lr}
    87fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87fc:	f7f8 f990 	bl	b20 <Sys_GetCoreID>
    8800:	4603      	mov	r3, r0
    8802:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    8804:	4a0d      	ldr	r2, [pc, #52]	; (883c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    8806:	9b01      	ldr	r3, [sp, #4]
    8808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    880c:	1e5a      	subs	r2, r3, #1
    880e:	490b      	ldr	r1, [pc, #44]	; (883c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    8810:	9b01      	ldr	r3, [sp, #4]
    8812:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    8816:	4a0a      	ldr	r2, [pc, #40]	; (8840 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    8818:	9b01      	ldr	r3, [sp, #4]
    881a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    881e:	f003 0301 	and.w	r3, r3, #1
    8822:	2b00      	cmp	r3, #0
    8824:	d106      	bne.n	8834 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    8826:	4a05      	ldr	r2, [pc, #20]	; (883c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    8828:	9b01      	ldr	r3, [sp, #4]
    882a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    882e:	2b00      	cmp	r3, #0
    8830:	d100      	bne.n	8834 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8832:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8834:	bf00      	nop
    8836:	b003      	add	sp, #12
    8838:	f85d fb04 	ldr.w	pc, [sp], #4
    883c:	1fff8e10 	.word	0x1fff8e10
    8840:	1fff8e0c 	.word	0x1fff8e0c

00008844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    8844:	b500      	push	{lr}
    8846:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8848:	f7f8 f96a 	bl	b20 <Sys_GetCoreID>
    884c:	4603      	mov	r3, r0
    884e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    8850:	4a10      	ldr	r2, [pc, #64]	; (8894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    8852:	9b01      	ldr	r3, [sp, #4]
    8854:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8858:	2b00      	cmp	r3, #0
    885a:	d10d      	bne.n	8878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    885c:	f7f8 f887 	bl	96e <Port_schm_read_msr>
    8860:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8862:	9b00      	ldr	r3, [sp, #0]
    8864:	f003 0301 	and.w	r3, r3, #1
    8868:	2b00      	cmp	r3, #0
    886a:	d100      	bne.n	886e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    886c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    886e:	490a      	ldr	r1, [pc, #40]	; (8898 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    8870:	9b01      	ldr	r3, [sp, #4]
    8872:	9a00      	ldr	r2, [sp, #0]
    8874:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    8878:	4a06      	ldr	r2, [pc, #24]	; (8894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    887a:	9b01      	ldr	r3, [sp, #4]
    887c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8880:	1c5a      	adds	r2, r3, #1
    8882:	4904      	ldr	r1, [pc, #16]	; (8894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    8884:	9b01      	ldr	r3, [sp, #4]
    8886:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    888a:	bf00      	nop
    888c:	b003      	add	sp, #12
    888e:	f85d fb04 	ldr.w	pc, [sp], #4
    8892:	bf00      	nop
    8894:	1fff8e18 	.word	0x1fff8e18
    8898:	1fff8e14 	.word	0x1fff8e14

0000889c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    889c:	b500      	push	{lr}
    889e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    88a0:	f7f8 f93e 	bl	b20 <Sys_GetCoreID>
    88a4:	4603      	mov	r3, r0
    88a6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    88a8:	4a0d      	ldr	r2, [pc, #52]	; (88e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    88aa:	9b01      	ldr	r3, [sp, #4]
    88ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88b0:	1e5a      	subs	r2, r3, #1
    88b2:	490b      	ldr	r1, [pc, #44]	; (88e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    88b4:	9b01      	ldr	r3, [sp, #4]
    88b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    88ba:	4a0a      	ldr	r2, [pc, #40]	; (88e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    88bc:	9b01      	ldr	r3, [sp, #4]
    88be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88c2:	f003 0301 	and.w	r3, r3, #1
    88c6:	2b00      	cmp	r3, #0
    88c8:	d106      	bne.n	88d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    88ca:	4a05      	ldr	r2, [pc, #20]	; (88e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    88cc:	9b01      	ldr	r3, [sp, #4]
    88ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88d2:	2b00      	cmp	r3, #0
    88d4:	d100      	bne.n	88d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    88d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    88d8:	bf00      	nop
    88da:	b003      	add	sp, #12
    88dc:	f85d fb04 	ldr.w	pc, [sp], #4
    88e0:	1fff8e18 	.word	0x1fff8e18
    88e4:	1fff8e14 	.word	0x1fff8e14

000088e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    88e8:	b500      	push	{lr}
    88ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    88ec:	f7f8 f918 	bl	b20 <Sys_GetCoreID>
    88f0:	4603      	mov	r3, r0
    88f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    88f4:	4a10      	ldr	r2, [pc, #64]	; (8938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    88f6:	9b01      	ldr	r3, [sp, #4]
    88f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88fc:	2b00      	cmp	r3, #0
    88fe:	d10d      	bne.n	891c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8900:	f7f8 f835 	bl	96e <Port_schm_read_msr>
    8904:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8906:	9b00      	ldr	r3, [sp, #0]
    8908:	f003 0301 	and.w	r3, r3, #1
    890c:	2b00      	cmp	r3, #0
    890e:	d100      	bne.n	8912 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8910:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    8912:	490a      	ldr	r1, [pc, #40]	; (893c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    8914:	9b01      	ldr	r3, [sp, #4]
    8916:	9a00      	ldr	r2, [sp, #0]
    8918:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    891c:	4a06      	ldr	r2, [pc, #24]	; (8938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    891e:	9b01      	ldr	r3, [sp, #4]
    8920:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8924:	1c5a      	adds	r2, r3, #1
    8926:	4904      	ldr	r1, [pc, #16]	; (8938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    8928:	9b01      	ldr	r3, [sp, #4]
    892a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    892e:	bf00      	nop
    8930:	b003      	add	sp, #12
    8932:	f85d fb04 	ldr.w	pc, [sp], #4
    8936:	bf00      	nop
    8938:	1fff8e20 	.word	0x1fff8e20
    893c:	1fff8e1c 	.word	0x1fff8e1c

00008940 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    8940:	b500      	push	{lr}
    8942:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8944:	f7f8 f8ec 	bl	b20 <Sys_GetCoreID>
    8948:	4603      	mov	r3, r0
    894a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    894c:	4a0d      	ldr	r2, [pc, #52]	; (8984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    894e:	9b01      	ldr	r3, [sp, #4]
    8950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8954:	1e5a      	subs	r2, r3, #1
    8956:	490b      	ldr	r1, [pc, #44]	; (8984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    8958:	9b01      	ldr	r3, [sp, #4]
    895a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    895e:	4a0a      	ldr	r2, [pc, #40]	; (8988 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    8960:	9b01      	ldr	r3, [sp, #4]
    8962:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8966:	f003 0301 	and.w	r3, r3, #1
    896a:	2b00      	cmp	r3, #0
    896c:	d106      	bne.n	897c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    896e:	4a05      	ldr	r2, [pc, #20]	; (8984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    8970:	9b01      	ldr	r3, [sp, #4]
    8972:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8976:	2b00      	cmp	r3, #0
    8978:	d100      	bne.n	897c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    897a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    897c:	bf00      	nop
    897e:	b003      	add	sp, #12
    8980:	f85d fb04 	ldr.w	pc, [sp], #4
    8984:	1fff8e20 	.word	0x1fff8e20
    8988:	1fff8e1c 	.word	0x1fff8e1c

0000898c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    898c:	b500      	push	{lr}
    898e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8990:	f7f8 f8c6 	bl	b20 <Sys_GetCoreID>
    8994:	4603      	mov	r3, r0
    8996:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    8998:	4a10      	ldr	r2, [pc, #64]	; (89dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    899a:	9b01      	ldr	r3, [sp, #4]
    899c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89a0:	2b00      	cmp	r3, #0
    89a2:	d10d      	bne.n	89c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    89a4:	f7f7 ffe3 	bl	96e <Port_schm_read_msr>
    89a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    89aa:	9b00      	ldr	r3, [sp, #0]
    89ac:	f003 0301 	and.w	r3, r3, #1
    89b0:	2b00      	cmp	r3, #0
    89b2:	d100      	bne.n	89b6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    89b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    89b6:	490a      	ldr	r1, [pc, #40]	; (89e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    89b8:	9b01      	ldr	r3, [sp, #4]
    89ba:	9a00      	ldr	r2, [sp, #0]
    89bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    89c0:	4a06      	ldr	r2, [pc, #24]	; (89dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    89c2:	9b01      	ldr	r3, [sp, #4]
    89c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89c8:	1c5a      	adds	r2, r3, #1
    89ca:	4904      	ldr	r1, [pc, #16]	; (89dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    89cc:	9b01      	ldr	r3, [sp, #4]
    89ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    89d2:	bf00      	nop
    89d4:	b003      	add	sp, #12
    89d6:	f85d fb04 	ldr.w	pc, [sp], #4
    89da:	bf00      	nop
    89dc:	1fff8e28 	.word	0x1fff8e28
    89e0:	1fff8e24 	.word	0x1fff8e24

000089e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    89e4:	b500      	push	{lr}
    89e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    89e8:	f7f8 f89a 	bl	b20 <Sys_GetCoreID>
    89ec:	4603      	mov	r3, r0
    89ee:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    89f0:	4a0d      	ldr	r2, [pc, #52]	; (8a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    89f2:	9b01      	ldr	r3, [sp, #4]
    89f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89f8:	1e5a      	subs	r2, r3, #1
    89fa:	490b      	ldr	r1, [pc, #44]	; (8a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    89fc:	9b01      	ldr	r3, [sp, #4]
    89fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    8a02:	4a0a      	ldr	r2, [pc, #40]	; (8a2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    8a04:	9b01      	ldr	r3, [sp, #4]
    8a06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a0a:	f003 0301 	and.w	r3, r3, #1
    8a0e:	2b00      	cmp	r3, #0
    8a10:	d106      	bne.n	8a20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    8a12:	4a05      	ldr	r2, [pc, #20]	; (8a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    8a14:	9b01      	ldr	r3, [sp, #4]
    8a16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a1a:	2b00      	cmp	r3, #0
    8a1c:	d100      	bne.n	8a20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8a1e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8a20:	bf00      	nop
    8a22:	b003      	add	sp, #12
    8a24:	f85d fb04 	ldr.w	pc, [sp], #4
    8a28:	1fff8e28 	.word	0x1fff8e28
    8a2c:	1fff8e24 	.word	0x1fff8e24

00008a30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    8a30:	b500      	push	{lr}
    8a32:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a34:	f7f8 f874 	bl	b20 <Sys_GetCoreID>
    8a38:	4603      	mov	r3, r0
    8a3a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    8a3c:	4a10      	ldr	r2, [pc, #64]	; (8a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    8a3e:	9b01      	ldr	r3, [sp, #4]
    8a40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a44:	2b00      	cmp	r3, #0
    8a46:	d10d      	bne.n	8a64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8a48:	f7f7 ff91 	bl	96e <Port_schm_read_msr>
    8a4c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8a4e:	9b00      	ldr	r3, [sp, #0]
    8a50:	f003 0301 	and.w	r3, r3, #1
    8a54:	2b00      	cmp	r3, #0
    8a56:	d100      	bne.n	8a5a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8a58:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    8a5a:	490a      	ldr	r1, [pc, #40]	; (8a84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    8a5c:	9b01      	ldr	r3, [sp, #4]
    8a5e:	9a00      	ldr	r2, [sp, #0]
    8a60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    8a64:	4a06      	ldr	r2, [pc, #24]	; (8a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    8a66:	9b01      	ldr	r3, [sp, #4]
    8a68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a6c:	1c5a      	adds	r2, r3, #1
    8a6e:	4904      	ldr	r1, [pc, #16]	; (8a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    8a70:	9b01      	ldr	r3, [sp, #4]
    8a72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8a76:	bf00      	nop
    8a78:	b003      	add	sp, #12
    8a7a:	f85d fb04 	ldr.w	pc, [sp], #4
    8a7e:	bf00      	nop
    8a80:	1fff8e30 	.word	0x1fff8e30
    8a84:	1fff8e2c 	.word	0x1fff8e2c

00008a88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    8a88:	b500      	push	{lr}
    8a8a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a8c:	f7f8 f848 	bl	b20 <Sys_GetCoreID>
    8a90:	4603      	mov	r3, r0
    8a92:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    8a94:	4a0d      	ldr	r2, [pc, #52]	; (8acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    8a96:	9b01      	ldr	r3, [sp, #4]
    8a98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a9c:	1e5a      	subs	r2, r3, #1
    8a9e:	490b      	ldr	r1, [pc, #44]	; (8acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    8aa0:	9b01      	ldr	r3, [sp, #4]
    8aa2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    8aa6:	4a0a      	ldr	r2, [pc, #40]	; (8ad0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    8aa8:	9b01      	ldr	r3, [sp, #4]
    8aaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aae:	f003 0301 	and.w	r3, r3, #1
    8ab2:	2b00      	cmp	r3, #0
    8ab4:	d106      	bne.n	8ac4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    8ab6:	4a05      	ldr	r2, [pc, #20]	; (8acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    8ab8:	9b01      	ldr	r3, [sp, #4]
    8aba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8abe:	2b00      	cmp	r3, #0
    8ac0:	d100      	bne.n	8ac4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8ac2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8ac4:	bf00      	nop
    8ac6:	b003      	add	sp, #12
    8ac8:	f85d fb04 	ldr.w	pc, [sp], #4
    8acc:	1fff8e30 	.word	0x1fff8e30
    8ad0:	1fff8e2c 	.word	0x1fff8e2c

00008ad4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    8ad4:	b500      	push	{lr}
    8ad6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ad8:	f7f8 f822 	bl	b20 <Sys_GetCoreID>
    8adc:	4603      	mov	r3, r0
    8ade:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    8ae0:	4a10      	ldr	r2, [pc, #64]	; (8b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    8ae2:	9b01      	ldr	r3, [sp, #4]
    8ae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ae8:	2b00      	cmp	r3, #0
    8aea:	d10d      	bne.n	8b08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8aec:	f7f7 ff3f 	bl	96e <Port_schm_read_msr>
    8af0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8af2:	9b00      	ldr	r3, [sp, #0]
    8af4:	f003 0301 	and.w	r3, r3, #1
    8af8:	2b00      	cmp	r3, #0
    8afa:	d100      	bne.n	8afe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8afc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    8afe:	490a      	ldr	r1, [pc, #40]	; (8b28 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    8b00:	9b01      	ldr	r3, [sp, #4]
    8b02:	9a00      	ldr	r2, [sp, #0]
    8b04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    8b08:	4a06      	ldr	r2, [pc, #24]	; (8b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    8b0a:	9b01      	ldr	r3, [sp, #4]
    8b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b10:	1c5a      	adds	r2, r3, #1
    8b12:	4904      	ldr	r1, [pc, #16]	; (8b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    8b14:	9b01      	ldr	r3, [sp, #4]
    8b16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8b1a:	bf00      	nop
    8b1c:	b003      	add	sp, #12
    8b1e:	f85d fb04 	ldr.w	pc, [sp], #4
    8b22:	bf00      	nop
    8b24:	1fff8e38 	.word	0x1fff8e38
    8b28:	1fff8e34 	.word	0x1fff8e34

00008b2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    8b2c:	b500      	push	{lr}
    8b2e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b30:	f7f7 fff6 	bl	b20 <Sys_GetCoreID>
    8b34:	4603      	mov	r3, r0
    8b36:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    8b38:	4a0d      	ldr	r2, [pc, #52]	; (8b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    8b3a:	9b01      	ldr	r3, [sp, #4]
    8b3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b40:	1e5a      	subs	r2, r3, #1
    8b42:	490b      	ldr	r1, [pc, #44]	; (8b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    8b44:	9b01      	ldr	r3, [sp, #4]
    8b46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    8b4a:	4a0a      	ldr	r2, [pc, #40]	; (8b74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    8b4c:	9b01      	ldr	r3, [sp, #4]
    8b4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b52:	f003 0301 	and.w	r3, r3, #1
    8b56:	2b00      	cmp	r3, #0
    8b58:	d106      	bne.n	8b68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    8b5a:	4a05      	ldr	r2, [pc, #20]	; (8b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    8b5c:	9b01      	ldr	r3, [sp, #4]
    8b5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b62:	2b00      	cmp	r3, #0
    8b64:	d100      	bne.n	8b68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8b66:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8b68:	bf00      	nop
    8b6a:	b003      	add	sp, #12
    8b6c:	f85d fb04 	ldr.w	pc, [sp], #4
    8b70:	1fff8e38 	.word	0x1fff8e38
    8b74:	1fff8e34 	.word	0x1fff8e34

00008b78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    8b78:	b500      	push	{lr}
    8b7a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b7c:	f7f7 ffd0 	bl	b20 <Sys_GetCoreID>
    8b80:	4603      	mov	r3, r0
    8b82:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    8b84:	4a10      	ldr	r2, [pc, #64]	; (8bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    8b86:	9b01      	ldr	r3, [sp, #4]
    8b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b8c:	2b00      	cmp	r3, #0
    8b8e:	d10d      	bne.n	8bac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8b90:	f7f7 feed 	bl	96e <Port_schm_read_msr>
    8b94:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8b96:	9b00      	ldr	r3, [sp, #0]
    8b98:	f003 0301 	and.w	r3, r3, #1
    8b9c:	2b00      	cmp	r3, #0
    8b9e:	d100      	bne.n	8ba2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8ba0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    8ba2:	490a      	ldr	r1, [pc, #40]	; (8bcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    8ba4:	9b01      	ldr	r3, [sp, #4]
    8ba6:	9a00      	ldr	r2, [sp, #0]
    8ba8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    8bac:	4a06      	ldr	r2, [pc, #24]	; (8bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    8bae:	9b01      	ldr	r3, [sp, #4]
    8bb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bb4:	1c5a      	adds	r2, r3, #1
    8bb6:	4904      	ldr	r1, [pc, #16]	; (8bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    8bb8:	9b01      	ldr	r3, [sp, #4]
    8bba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8bbe:	bf00      	nop
    8bc0:	b003      	add	sp, #12
    8bc2:	f85d fb04 	ldr.w	pc, [sp], #4
    8bc6:	bf00      	nop
    8bc8:	1fff8e40 	.word	0x1fff8e40
    8bcc:	1fff8e3c 	.word	0x1fff8e3c

00008bd0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    8bd0:	b500      	push	{lr}
    8bd2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8bd4:	f7f7 ffa4 	bl	b20 <Sys_GetCoreID>
    8bd8:	4603      	mov	r3, r0
    8bda:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    8bdc:	4a0d      	ldr	r2, [pc, #52]	; (8c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    8bde:	9b01      	ldr	r3, [sp, #4]
    8be0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8be4:	1e5a      	subs	r2, r3, #1
    8be6:	490b      	ldr	r1, [pc, #44]	; (8c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    8be8:	9b01      	ldr	r3, [sp, #4]
    8bea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    8bee:	4a0a      	ldr	r2, [pc, #40]	; (8c18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    8bf0:	9b01      	ldr	r3, [sp, #4]
    8bf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bf6:	f003 0301 	and.w	r3, r3, #1
    8bfa:	2b00      	cmp	r3, #0
    8bfc:	d106      	bne.n	8c0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    8bfe:	4a05      	ldr	r2, [pc, #20]	; (8c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    8c00:	9b01      	ldr	r3, [sp, #4]
    8c02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c06:	2b00      	cmp	r3, #0
    8c08:	d100      	bne.n	8c0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8c0a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8c0c:	bf00      	nop
    8c0e:	b003      	add	sp, #12
    8c10:	f85d fb04 	ldr.w	pc, [sp], #4
    8c14:	1fff8e40 	.word	0x1fff8e40
    8c18:	1fff8e3c 	.word	0x1fff8e3c

00008c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    8c1c:	b500      	push	{lr}
    8c1e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c20:	f7f7 ff7e 	bl	b20 <Sys_GetCoreID>
    8c24:	4603      	mov	r3, r0
    8c26:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    8c28:	4a10      	ldr	r2, [pc, #64]	; (8c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    8c2a:	9b01      	ldr	r3, [sp, #4]
    8c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c30:	2b00      	cmp	r3, #0
    8c32:	d10d      	bne.n	8c50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8c34:	f7f7 fe9b 	bl	96e <Port_schm_read_msr>
    8c38:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8c3a:	9b00      	ldr	r3, [sp, #0]
    8c3c:	f003 0301 	and.w	r3, r3, #1
    8c40:	2b00      	cmp	r3, #0
    8c42:	d100      	bne.n	8c46 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8c44:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    8c46:	490a      	ldr	r1, [pc, #40]	; (8c70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    8c48:	9b01      	ldr	r3, [sp, #4]
    8c4a:	9a00      	ldr	r2, [sp, #0]
    8c4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    8c50:	4a06      	ldr	r2, [pc, #24]	; (8c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    8c52:	9b01      	ldr	r3, [sp, #4]
    8c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c58:	1c5a      	adds	r2, r3, #1
    8c5a:	4904      	ldr	r1, [pc, #16]	; (8c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    8c5c:	9b01      	ldr	r3, [sp, #4]
    8c5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8c62:	bf00      	nop
    8c64:	b003      	add	sp, #12
    8c66:	f85d fb04 	ldr.w	pc, [sp], #4
    8c6a:	bf00      	nop
    8c6c:	1fff8e48 	.word	0x1fff8e48
    8c70:	1fff8e44 	.word	0x1fff8e44

00008c74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    8c74:	b500      	push	{lr}
    8c76:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c78:	f7f7 ff52 	bl	b20 <Sys_GetCoreID>
    8c7c:	4603      	mov	r3, r0
    8c7e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    8c80:	4a0d      	ldr	r2, [pc, #52]	; (8cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    8c82:	9b01      	ldr	r3, [sp, #4]
    8c84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c88:	1e5a      	subs	r2, r3, #1
    8c8a:	490b      	ldr	r1, [pc, #44]	; (8cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    8c8c:	9b01      	ldr	r3, [sp, #4]
    8c8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    8c92:	4a0a      	ldr	r2, [pc, #40]	; (8cbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    8c94:	9b01      	ldr	r3, [sp, #4]
    8c96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c9a:	f003 0301 	and.w	r3, r3, #1
    8c9e:	2b00      	cmp	r3, #0
    8ca0:	d106      	bne.n	8cb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    8ca2:	4a05      	ldr	r2, [pc, #20]	; (8cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    8ca4:	9b01      	ldr	r3, [sp, #4]
    8ca6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8caa:	2b00      	cmp	r3, #0
    8cac:	d100      	bne.n	8cb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8cae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8cb0:	bf00      	nop
    8cb2:	b003      	add	sp, #12
    8cb4:	f85d fb04 	ldr.w	pc, [sp], #4
    8cb8:	1fff8e48 	.word	0x1fff8e48
    8cbc:	1fff8e44 	.word	0x1fff8e44

00008cc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    8cc0:	b500      	push	{lr}
    8cc2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8cc4:	f7f7 ff2c 	bl	b20 <Sys_GetCoreID>
    8cc8:	4603      	mov	r3, r0
    8cca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    8ccc:	4a10      	ldr	r2, [pc, #64]	; (8d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    8cce:	9b01      	ldr	r3, [sp, #4]
    8cd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cd4:	2b00      	cmp	r3, #0
    8cd6:	d10d      	bne.n	8cf4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8cd8:	f7f7 fe49 	bl	96e <Port_schm_read_msr>
    8cdc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8cde:	9b00      	ldr	r3, [sp, #0]
    8ce0:	f003 0301 	and.w	r3, r3, #1
    8ce4:	2b00      	cmp	r3, #0
    8ce6:	d100      	bne.n	8cea <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8ce8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    8cea:	490a      	ldr	r1, [pc, #40]	; (8d14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    8cec:	9b01      	ldr	r3, [sp, #4]
    8cee:	9a00      	ldr	r2, [sp, #0]
    8cf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    8cf4:	4a06      	ldr	r2, [pc, #24]	; (8d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    8cf6:	9b01      	ldr	r3, [sp, #4]
    8cf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cfc:	1c5a      	adds	r2, r3, #1
    8cfe:	4904      	ldr	r1, [pc, #16]	; (8d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    8d00:	9b01      	ldr	r3, [sp, #4]
    8d02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8d06:	bf00      	nop
    8d08:	b003      	add	sp, #12
    8d0a:	f85d fb04 	ldr.w	pc, [sp], #4
    8d0e:	bf00      	nop
    8d10:	1fff8e50 	.word	0x1fff8e50
    8d14:	1fff8e4c 	.word	0x1fff8e4c

00008d18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    8d18:	b500      	push	{lr}
    8d1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d1c:	f7f7 ff00 	bl	b20 <Sys_GetCoreID>
    8d20:	4603      	mov	r3, r0
    8d22:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    8d24:	4a0d      	ldr	r2, [pc, #52]	; (8d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    8d26:	9b01      	ldr	r3, [sp, #4]
    8d28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d2c:	1e5a      	subs	r2, r3, #1
    8d2e:	490b      	ldr	r1, [pc, #44]	; (8d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    8d30:	9b01      	ldr	r3, [sp, #4]
    8d32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    8d36:	4a0a      	ldr	r2, [pc, #40]	; (8d60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    8d38:	9b01      	ldr	r3, [sp, #4]
    8d3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d3e:	f003 0301 	and.w	r3, r3, #1
    8d42:	2b00      	cmp	r3, #0
    8d44:	d106      	bne.n	8d54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    8d46:	4a05      	ldr	r2, [pc, #20]	; (8d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    8d48:	9b01      	ldr	r3, [sp, #4]
    8d4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d4e:	2b00      	cmp	r3, #0
    8d50:	d100      	bne.n	8d54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8d52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8d54:	bf00      	nop
    8d56:	b003      	add	sp, #12
    8d58:	f85d fb04 	ldr.w	pc, [sp], #4
    8d5c:	1fff8e50 	.word	0x1fff8e50
    8d60:	1fff8e4c 	.word	0x1fff8e4c

00008d64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    8d64:	b500      	push	{lr}
    8d66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d68:	f7f7 feda 	bl	b20 <Sys_GetCoreID>
    8d6c:	4603      	mov	r3, r0
    8d6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    8d70:	4a10      	ldr	r2, [pc, #64]	; (8db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    8d72:	9b01      	ldr	r3, [sp, #4]
    8d74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d78:	2b00      	cmp	r3, #0
    8d7a:	d10d      	bne.n	8d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8d7c:	f7f7 fdf7 	bl	96e <Port_schm_read_msr>
    8d80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8d82:	9b00      	ldr	r3, [sp, #0]
    8d84:	f003 0301 	and.w	r3, r3, #1
    8d88:	2b00      	cmp	r3, #0
    8d8a:	d100      	bne.n	8d8e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8d8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    8d8e:	490a      	ldr	r1, [pc, #40]	; (8db8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    8d90:	9b01      	ldr	r3, [sp, #4]
    8d92:	9a00      	ldr	r2, [sp, #0]
    8d94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    8d98:	4a06      	ldr	r2, [pc, #24]	; (8db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    8d9a:	9b01      	ldr	r3, [sp, #4]
    8d9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8da0:	1c5a      	adds	r2, r3, #1
    8da2:	4904      	ldr	r1, [pc, #16]	; (8db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    8da4:	9b01      	ldr	r3, [sp, #4]
    8da6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8daa:	bf00      	nop
    8dac:	b003      	add	sp, #12
    8dae:	f85d fb04 	ldr.w	pc, [sp], #4
    8db2:	bf00      	nop
    8db4:	1fff8e58 	.word	0x1fff8e58
    8db8:	1fff8e54 	.word	0x1fff8e54

00008dbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    8dbc:	b500      	push	{lr}
    8dbe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8dc0:	f7f7 feae 	bl	b20 <Sys_GetCoreID>
    8dc4:	4603      	mov	r3, r0
    8dc6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    8dc8:	4a0d      	ldr	r2, [pc, #52]	; (8e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    8dca:	9b01      	ldr	r3, [sp, #4]
    8dcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dd0:	1e5a      	subs	r2, r3, #1
    8dd2:	490b      	ldr	r1, [pc, #44]	; (8e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    8dd4:	9b01      	ldr	r3, [sp, #4]
    8dd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    8dda:	4a0a      	ldr	r2, [pc, #40]	; (8e04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    8ddc:	9b01      	ldr	r3, [sp, #4]
    8dde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8de2:	f003 0301 	and.w	r3, r3, #1
    8de6:	2b00      	cmp	r3, #0
    8de8:	d106      	bne.n	8df8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    8dea:	4a05      	ldr	r2, [pc, #20]	; (8e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    8dec:	9b01      	ldr	r3, [sp, #4]
    8dee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8df2:	2b00      	cmp	r3, #0
    8df4:	d100      	bne.n	8df8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8df6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8df8:	bf00      	nop
    8dfa:	b003      	add	sp, #12
    8dfc:	f85d fb04 	ldr.w	pc, [sp], #4
    8e00:	1fff8e58 	.word	0x1fff8e58
    8e04:	1fff8e54 	.word	0x1fff8e54

00008e08 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
    8e08:	b500      	push	{lr}
    8e0a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e0c:	f7f7 fe88 	bl	b20 <Sys_GetCoreID>
    8e10:	4603      	mov	r3, r0
    8e12:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId])
    8e14:	4a10      	ldr	r2, [pc, #64]	; (8e58 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    8e16:	9b01      	ldr	r3, [sp, #4]
    8e18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e1c:	2b00      	cmp	r3, #0
    8e1e:	d10d      	bne.n	8e3c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8e20:	f7f7 fdae 	bl	980 <Spi_schm_read_msr>
    8e24:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8e26:	9b00      	ldr	r3, [sp, #0]
    8e28:	f003 0301 	and.w	r3, r3, #1
    8e2c:	2b00      	cmp	r3, #0
    8e2e:	d100      	bne.n	8e32 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8e30:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    8e32:	490a      	ldr	r1, [pc, #40]	; (8e5c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x54>)
    8e34:	9b01      	ldr	r3, [sp, #4]
    8e36:	9a00      	ldr	r2, [sp, #0]
    8e38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]++;
    8e3c:	4a06      	ldr	r2, [pc, #24]	; (8e58 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    8e3e:	9b01      	ldr	r3, [sp, #4]
    8e40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e44:	1c5a      	adds	r2, r3, #1
    8e46:	4904      	ldr	r1, [pc, #16]	; (8e58 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    8e48:	9b01      	ldr	r3, [sp, #4]
    8e4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8e4e:	bf00      	nop
    8e50:	b003      	add	sp, #12
    8e52:	f85d fb04 	ldr.w	pc, [sp], #4
    8e56:	bf00      	nop
    8e58:	1fff8e60 	.word	0x1fff8e60
    8e5c:	1fff8e5c 	.word	0x1fff8e5c

00008e60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
    8e60:	b500      	push	{lr}
    8e62:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e64:	f7f7 fe5c 	bl	b20 <Sys_GetCoreID>
    8e68:	4603      	mov	r3, r0
    8e6a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]--;
    8e6c:	4a0d      	ldr	r2, [pc, #52]	; (8ea4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    8e6e:	9b01      	ldr	r3, [sp, #4]
    8e70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e74:	1e5a      	subs	r2, r3, #1
    8e76:	490b      	ldr	r1, [pc, #44]	; (8ea4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    8e78:	9b01      	ldr	r3, [sp, #4]
    8e7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    8e7e:	4a0a      	ldr	r2, [pc, #40]	; (8ea8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x48>)
    8e80:	9b01      	ldr	r3, [sp, #4]
    8e82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e86:	f003 0301 	and.w	r3, r3, #1
    8e8a:	2b00      	cmp	r3, #0
    8e8c:	d106      	bne.n	8e9c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
    8e8e:	4a05      	ldr	r2, [pc, #20]	; (8ea4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    8e90:	9b01      	ldr	r3, [sp, #4]
    8e92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e96:	2b00      	cmp	r3, #0
    8e98:	d100      	bne.n	8e9c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8e9a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8e9c:	bf00      	nop
    8e9e:	b003      	add	sp, #12
    8ea0:	f85d fb04 	ldr.w	pc, [sp], #4
    8ea4:	1fff8e60 	.word	0x1fff8e60
    8ea8:	1fff8e5c 	.word	0x1fff8e5c

00008eac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
    8eac:	b500      	push	{lr}
    8eae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8eb0:	f7f7 fe36 	bl	b20 <Sys_GetCoreID>
    8eb4:	4603      	mov	r3, r0
    8eb6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId])
    8eb8:	4a10      	ldr	r2, [pc, #64]	; (8efc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    8eba:	9b01      	ldr	r3, [sp, #4]
    8ebc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ec0:	2b00      	cmp	r3, #0
    8ec2:	d10d      	bne.n	8ee0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8ec4:	f7f7 fd5c 	bl	980 <Spi_schm_read_msr>
    8ec8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8eca:	9b00      	ldr	r3, [sp, #0]
    8ecc:	f003 0301 	and.w	r3, r3, #1
    8ed0:	2b00      	cmp	r3, #0
    8ed2:	d100      	bne.n	8ed6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8ed4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    8ed6:	490a      	ldr	r1, [pc, #40]	; (8f00 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x54>)
    8ed8:	9b01      	ldr	r3, [sp, #4]
    8eda:	9a00      	ldr	r2, [sp, #0]
    8edc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]++;
    8ee0:	4a06      	ldr	r2, [pc, #24]	; (8efc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    8ee2:	9b01      	ldr	r3, [sp, #4]
    8ee4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ee8:	1c5a      	adds	r2, r3, #1
    8eea:	4904      	ldr	r1, [pc, #16]	; (8efc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    8eec:	9b01      	ldr	r3, [sp, #4]
    8eee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8ef2:	bf00      	nop
    8ef4:	b003      	add	sp, #12
    8ef6:	f85d fb04 	ldr.w	pc, [sp], #4
    8efa:	bf00      	nop
    8efc:	1fff8e68 	.word	0x1fff8e68
    8f00:	1fff8e64 	.word	0x1fff8e64

00008f04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
    8f04:	b500      	push	{lr}
    8f06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f08:	f7f7 fe0a 	bl	b20 <Sys_GetCoreID>
    8f0c:	4603      	mov	r3, r0
    8f0e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]--;
    8f10:	4a0d      	ldr	r2, [pc, #52]	; (8f48 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    8f12:	9b01      	ldr	r3, [sp, #4]
    8f14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f18:	1e5a      	subs	r2, r3, #1
    8f1a:	490b      	ldr	r1, [pc, #44]	; (8f48 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    8f1c:	9b01      	ldr	r3, [sp, #4]
    8f1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    8f22:	4a0a      	ldr	r2, [pc, #40]	; (8f4c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x48>)
    8f24:	9b01      	ldr	r3, [sp, #4]
    8f26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f2a:	f003 0301 	and.w	r3, r3, #1
    8f2e:	2b00      	cmp	r3, #0
    8f30:	d106      	bne.n	8f40 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
    8f32:	4a05      	ldr	r2, [pc, #20]	; (8f48 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    8f34:	9b01      	ldr	r3, [sp, #4]
    8f36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f3a:	2b00      	cmp	r3, #0
    8f3c:	d100      	bne.n	8f40 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8f3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8f40:	bf00      	nop
    8f42:	b003      	add	sp, #12
    8f44:	f85d fb04 	ldr.w	pc, [sp], #4
    8f48:	1fff8e68 	.word	0x1fff8e68
    8f4c:	1fff8e64 	.word	0x1fff8e64

00008f50 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
    8f50:	b500      	push	{lr}
    8f52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f54:	f7f7 fde4 	bl	b20 <Sys_GetCoreID>
    8f58:	4603      	mov	r3, r0
    8f5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId])
    8f5c:	4a10      	ldr	r2, [pc, #64]	; (8fa0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    8f5e:	9b01      	ldr	r3, [sp, #4]
    8f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f64:	2b00      	cmp	r3, #0
    8f66:	d10d      	bne.n	8f84 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8f68:	f7f7 fd0a 	bl	980 <Spi_schm_read_msr>
    8f6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8f6e:	9b00      	ldr	r3, [sp, #0]
    8f70:	f003 0301 	and.w	r3, r3, #1
    8f74:	2b00      	cmp	r3, #0
    8f76:	d100      	bne.n	8f7a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8f78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    8f7a:	490a      	ldr	r1, [pc, #40]	; (8fa4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x54>)
    8f7c:	9b01      	ldr	r3, [sp, #4]
    8f7e:	9a00      	ldr	r2, [sp, #0]
    8f80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]++;
    8f84:	4a06      	ldr	r2, [pc, #24]	; (8fa0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    8f86:	9b01      	ldr	r3, [sp, #4]
    8f88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f8c:	1c5a      	adds	r2, r3, #1
    8f8e:	4904      	ldr	r1, [pc, #16]	; (8fa0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    8f90:	9b01      	ldr	r3, [sp, #4]
    8f92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8f96:	bf00      	nop
    8f98:	b003      	add	sp, #12
    8f9a:	f85d fb04 	ldr.w	pc, [sp], #4
    8f9e:	bf00      	nop
    8fa0:	1fff8e70 	.word	0x1fff8e70
    8fa4:	1fff8e6c 	.word	0x1fff8e6c

00008fa8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
    8fa8:	b500      	push	{lr}
    8faa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8fac:	f7f7 fdb8 	bl	b20 <Sys_GetCoreID>
    8fb0:	4603      	mov	r3, r0
    8fb2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]--;
    8fb4:	4a0d      	ldr	r2, [pc, #52]	; (8fec <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    8fb6:	9b01      	ldr	r3, [sp, #4]
    8fb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fbc:	1e5a      	subs	r2, r3, #1
    8fbe:	490b      	ldr	r1, [pc, #44]	; (8fec <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    8fc0:	9b01      	ldr	r3, [sp, #4]
    8fc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    8fc6:	4a0a      	ldr	r2, [pc, #40]	; (8ff0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x48>)
    8fc8:	9b01      	ldr	r3, [sp, #4]
    8fca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fce:	f003 0301 	and.w	r3, r3, #1
    8fd2:	2b00      	cmp	r3, #0
    8fd4:	d106      	bne.n	8fe4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
    8fd6:	4a05      	ldr	r2, [pc, #20]	; (8fec <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    8fd8:	9b01      	ldr	r3, [sp, #4]
    8fda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fde:	2b00      	cmp	r3, #0
    8fe0:	d100      	bne.n	8fe4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8fe2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8fe4:	bf00      	nop
    8fe6:	b003      	add	sp, #12
    8fe8:	f85d fb04 	ldr.w	pc, [sp], #4
    8fec:	1fff8e70 	.word	0x1fff8e70
    8ff0:	1fff8e6c 	.word	0x1fff8e6c

00008ff4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
    8ff4:	b500      	push	{lr}
    8ff6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ff8:	f7f7 fd92 	bl	b20 <Sys_GetCoreID>
    8ffc:	4603      	mov	r3, r0
    8ffe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId])
    9000:	4a10      	ldr	r2, [pc, #64]	; (9044 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    9002:	9b01      	ldr	r3, [sp, #4]
    9004:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9008:	2b00      	cmp	r3, #0
    900a:	d10d      	bne.n	9028 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    900c:	f7f7 fcb8 	bl	980 <Spi_schm_read_msr>
    9010:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9012:	9b00      	ldr	r3, [sp, #0]
    9014:	f003 0301 	and.w	r3, r3, #1
    9018:	2b00      	cmp	r3, #0
    901a:	d100      	bne.n	901e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    901c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    901e:	490a      	ldr	r1, [pc, #40]	; (9048 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x54>)
    9020:	9b01      	ldr	r3, [sp, #4]
    9022:	9a00      	ldr	r2, [sp, #0]
    9024:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]++;
    9028:	4a06      	ldr	r2, [pc, #24]	; (9044 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    902a:	9b01      	ldr	r3, [sp, #4]
    902c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9030:	1c5a      	adds	r2, r3, #1
    9032:	4904      	ldr	r1, [pc, #16]	; (9044 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    9034:	9b01      	ldr	r3, [sp, #4]
    9036:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    903a:	bf00      	nop
    903c:	b003      	add	sp, #12
    903e:	f85d fb04 	ldr.w	pc, [sp], #4
    9042:	bf00      	nop
    9044:	1fff8e78 	.word	0x1fff8e78
    9048:	1fff8e74 	.word	0x1fff8e74

0000904c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
    904c:	b500      	push	{lr}
    904e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9050:	f7f7 fd66 	bl	b20 <Sys_GetCoreID>
    9054:	4603      	mov	r3, r0
    9056:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]--;
    9058:	4a0d      	ldr	r2, [pc, #52]	; (9090 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    905a:	9b01      	ldr	r3, [sp, #4]
    905c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9060:	1e5a      	subs	r2, r3, #1
    9062:	490b      	ldr	r1, [pc, #44]	; (9090 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    9064:	9b01      	ldr	r3, [sp, #4]
    9066:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    906a:	4a0a      	ldr	r2, [pc, #40]	; (9094 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x48>)
    906c:	9b01      	ldr	r3, [sp, #4]
    906e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9072:	f003 0301 	and.w	r3, r3, #1
    9076:	2b00      	cmp	r3, #0
    9078:	d106      	bne.n	9088 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
    907a:	4a05      	ldr	r2, [pc, #20]	; (9090 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    907c:	9b01      	ldr	r3, [sp, #4]
    907e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9082:	2b00      	cmp	r3, #0
    9084:	d100      	bne.n	9088 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9086:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9088:	bf00      	nop
    908a:	b003      	add	sp, #12
    908c:	f85d fb04 	ldr.w	pc, [sp], #4
    9090:	1fff8e78 	.word	0x1fff8e78
    9094:	1fff8e74 	.word	0x1fff8e74

00009098 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
    9098:	b500      	push	{lr}
    909a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    909c:	f7f7 fd40 	bl	b20 <Sys_GetCoreID>
    90a0:	4603      	mov	r3, r0
    90a2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId])
    90a4:	4a10      	ldr	r2, [pc, #64]	; (90e8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    90a6:	9b01      	ldr	r3, [sp, #4]
    90a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90ac:	2b00      	cmp	r3, #0
    90ae:	d10d      	bne.n	90cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    90b0:	f7f7 fc66 	bl	980 <Spi_schm_read_msr>
    90b4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    90b6:	9b00      	ldr	r3, [sp, #0]
    90b8:	f003 0301 	and.w	r3, r3, #1
    90bc:	2b00      	cmp	r3, #0
    90be:	d100      	bne.n	90c2 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    90c0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    90c2:	490a      	ldr	r1, [pc, #40]	; (90ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x54>)
    90c4:	9b01      	ldr	r3, [sp, #4]
    90c6:	9a00      	ldr	r2, [sp, #0]
    90c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]++;
    90cc:	4a06      	ldr	r2, [pc, #24]	; (90e8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    90ce:	9b01      	ldr	r3, [sp, #4]
    90d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90d4:	1c5a      	adds	r2, r3, #1
    90d6:	4904      	ldr	r1, [pc, #16]	; (90e8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    90d8:	9b01      	ldr	r3, [sp, #4]
    90da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    90de:	bf00      	nop
    90e0:	b003      	add	sp, #12
    90e2:	f85d fb04 	ldr.w	pc, [sp], #4
    90e6:	bf00      	nop
    90e8:	1fff8e80 	.word	0x1fff8e80
    90ec:	1fff8e7c 	.word	0x1fff8e7c

000090f0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
    90f0:	b500      	push	{lr}
    90f2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    90f4:	f7f7 fd14 	bl	b20 <Sys_GetCoreID>
    90f8:	4603      	mov	r3, r0
    90fa:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]--;
    90fc:	4a0d      	ldr	r2, [pc, #52]	; (9134 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    90fe:	9b01      	ldr	r3, [sp, #4]
    9100:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9104:	1e5a      	subs	r2, r3, #1
    9106:	490b      	ldr	r1, [pc, #44]	; (9134 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    9108:	9b01      	ldr	r3, [sp, #4]
    910a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    910e:	4a0a      	ldr	r2, [pc, #40]	; (9138 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x48>)
    9110:	9b01      	ldr	r3, [sp, #4]
    9112:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9116:	f003 0301 	and.w	r3, r3, #1
    911a:	2b00      	cmp	r3, #0
    911c:	d106      	bne.n	912c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
    911e:	4a05      	ldr	r2, [pc, #20]	; (9134 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    9120:	9b01      	ldr	r3, [sp, #4]
    9122:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9126:	2b00      	cmp	r3, #0
    9128:	d100      	bne.n	912c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    912a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    912c:	bf00      	nop
    912e:	b003      	add	sp, #12
    9130:	f85d fb04 	ldr.w	pc, [sp], #4
    9134:	1fff8e80 	.word	0x1fff8e80
    9138:	1fff8e7c 	.word	0x1fff8e7c

0000913c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
    913c:	b500      	push	{lr}
    913e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9140:	f7f7 fcee 	bl	b20 <Sys_GetCoreID>
    9144:	4603      	mov	r3, r0
    9146:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId])
    9148:	4a10      	ldr	r2, [pc, #64]	; (918c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    914a:	9b01      	ldr	r3, [sp, #4]
    914c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9150:	2b00      	cmp	r3, #0
    9152:	d10d      	bne.n	9170 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9154:	f7f7 fc14 	bl	980 <Spi_schm_read_msr>
    9158:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    915a:	9b00      	ldr	r3, [sp, #0]
    915c:	f003 0301 	and.w	r3, r3, #1
    9160:	2b00      	cmp	r3, #0
    9162:	d100      	bne.n	9166 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9164:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    9166:	490a      	ldr	r1, [pc, #40]	; (9190 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x54>)
    9168:	9b01      	ldr	r3, [sp, #4]
    916a:	9a00      	ldr	r2, [sp, #0]
    916c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]++;
    9170:	4a06      	ldr	r2, [pc, #24]	; (918c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    9172:	9b01      	ldr	r3, [sp, #4]
    9174:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9178:	1c5a      	adds	r2, r3, #1
    917a:	4904      	ldr	r1, [pc, #16]	; (918c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    917c:	9b01      	ldr	r3, [sp, #4]
    917e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9182:	bf00      	nop
    9184:	b003      	add	sp, #12
    9186:	f85d fb04 	ldr.w	pc, [sp], #4
    918a:	bf00      	nop
    918c:	1fff8e88 	.word	0x1fff8e88
    9190:	1fff8e84 	.word	0x1fff8e84

00009194 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
    9194:	b500      	push	{lr}
    9196:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9198:	f7f7 fcc2 	bl	b20 <Sys_GetCoreID>
    919c:	4603      	mov	r3, r0
    919e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]--;
    91a0:	4a0d      	ldr	r2, [pc, #52]	; (91d8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    91a2:	9b01      	ldr	r3, [sp, #4]
    91a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91a8:	1e5a      	subs	r2, r3, #1
    91aa:	490b      	ldr	r1, [pc, #44]	; (91d8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    91ac:	9b01      	ldr	r3, [sp, #4]
    91ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    91b2:	4a0a      	ldr	r2, [pc, #40]	; (91dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x48>)
    91b4:	9b01      	ldr	r3, [sp, #4]
    91b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91ba:	f003 0301 	and.w	r3, r3, #1
    91be:	2b00      	cmp	r3, #0
    91c0:	d106      	bne.n	91d0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
    91c2:	4a05      	ldr	r2, [pc, #20]	; (91d8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    91c4:	9b01      	ldr	r3, [sp, #4]
    91c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91ca:	2b00      	cmp	r3, #0
    91cc:	d100      	bne.n	91d0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    91ce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    91d0:	bf00      	nop
    91d2:	b003      	add	sp, #12
    91d4:	f85d fb04 	ldr.w	pc, [sp], #4
    91d8:	1fff8e88 	.word	0x1fff8e88
    91dc:	1fff8e84 	.word	0x1fff8e84

000091e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
    91e0:	b500      	push	{lr}
    91e2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    91e4:	f7f7 fc9c 	bl	b20 <Sys_GetCoreID>
    91e8:	4603      	mov	r3, r0
    91ea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId])
    91ec:	4a10      	ldr	r2, [pc, #64]	; (9230 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    91ee:	9b01      	ldr	r3, [sp, #4]
    91f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91f4:	2b00      	cmp	r3, #0
    91f6:	d10d      	bne.n	9214 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    91f8:	f7f7 fbc2 	bl	980 <Spi_schm_read_msr>
    91fc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    91fe:	9b00      	ldr	r3, [sp, #0]
    9200:	f003 0301 	and.w	r3, r3, #1
    9204:	2b00      	cmp	r3, #0
    9206:	d100      	bne.n	920a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9208:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    920a:	490a      	ldr	r1, [pc, #40]	; (9234 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x54>)
    920c:	9b01      	ldr	r3, [sp, #4]
    920e:	9a00      	ldr	r2, [sp, #0]
    9210:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]++;
    9214:	4a06      	ldr	r2, [pc, #24]	; (9230 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    9216:	9b01      	ldr	r3, [sp, #4]
    9218:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    921c:	1c5a      	adds	r2, r3, #1
    921e:	4904      	ldr	r1, [pc, #16]	; (9230 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    9220:	9b01      	ldr	r3, [sp, #4]
    9222:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9226:	bf00      	nop
    9228:	b003      	add	sp, #12
    922a:	f85d fb04 	ldr.w	pc, [sp], #4
    922e:	bf00      	nop
    9230:	1fff8e90 	.word	0x1fff8e90
    9234:	1fff8e8c 	.word	0x1fff8e8c

00009238 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
    9238:	b500      	push	{lr}
    923a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    923c:	f7f7 fc70 	bl	b20 <Sys_GetCoreID>
    9240:	4603      	mov	r3, r0
    9242:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]--;
    9244:	4a0d      	ldr	r2, [pc, #52]	; (927c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9246:	9b01      	ldr	r3, [sp, #4]
    9248:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    924c:	1e5a      	subs	r2, r3, #1
    924e:	490b      	ldr	r1, [pc, #44]	; (927c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9250:	9b01      	ldr	r3, [sp, #4]
    9252:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    9256:	4a0a      	ldr	r2, [pc, #40]	; (9280 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x48>)
    9258:	9b01      	ldr	r3, [sp, #4]
    925a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    925e:	f003 0301 	and.w	r3, r3, #1
    9262:	2b00      	cmp	r3, #0
    9264:	d106      	bne.n	9274 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
    9266:	4a05      	ldr	r2, [pc, #20]	; (927c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9268:	9b01      	ldr	r3, [sp, #4]
    926a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    926e:	2b00      	cmp	r3, #0
    9270:	d100      	bne.n	9274 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9272:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9274:	bf00      	nop
    9276:	b003      	add	sp, #12
    9278:	f85d fb04 	ldr.w	pc, [sp], #4
    927c:	1fff8e90 	.word	0x1fff8e90
    9280:	1fff8e8c 	.word	0x1fff8e8c

00009284 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
    9284:	b500      	push	{lr}
    9286:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9288:	f7f7 fc4a 	bl	b20 <Sys_GetCoreID>
    928c:	4603      	mov	r3, r0
    928e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId])
    9290:	4a10      	ldr	r2, [pc, #64]	; (92d4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    9292:	9b01      	ldr	r3, [sp, #4]
    9294:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9298:	2b00      	cmp	r3, #0
    929a:	d10d      	bne.n	92b8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    929c:	f7f7 fb70 	bl	980 <Spi_schm_read_msr>
    92a0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    92a2:	9b00      	ldr	r3, [sp, #0]
    92a4:	f003 0301 	and.w	r3, r3, #1
    92a8:	2b00      	cmp	r3, #0
    92aa:	d100      	bne.n	92ae <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    92ac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    92ae:	490a      	ldr	r1, [pc, #40]	; (92d8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x54>)
    92b0:	9b01      	ldr	r3, [sp, #4]
    92b2:	9a00      	ldr	r2, [sp, #0]
    92b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]++;
    92b8:	4a06      	ldr	r2, [pc, #24]	; (92d4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    92ba:	9b01      	ldr	r3, [sp, #4]
    92bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92c0:	1c5a      	adds	r2, r3, #1
    92c2:	4904      	ldr	r1, [pc, #16]	; (92d4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    92c4:	9b01      	ldr	r3, [sp, #4]
    92c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    92ca:	bf00      	nop
    92cc:	b003      	add	sp, #12
    92ce:	f85d fb04 	ldr.w	pc, [sp], #4
    92d2:	bf00      	nop
    92d4:	1fff8e98 	.word	0x1fff8e98
    92d8:	1fff8e94 	.word	0x1fff8e94

000092dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
    92dc:	b500      	push	{lr}
    92de:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    92e0:	f7f7 fc1e 	bl	b20 <Sys_GetCoreID>
    92e4:	4603      	mov	r3, r0
    92e6:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]--;
    92e8:	4a0d      	ldr	r2, [pc, #52]	; (9320 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    92ea:	9b01      	ldr	r3, [sp, #4]
    92ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92f0:	1e5a      	subs	r2, r3, #1
    92f2:	490b      	ldr	r1, [pc, #44]	; (9320 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    92f4:	9b01      	ldr	r3, [sp, #4]
    92f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    92fa:	4a0a      	ldr	r2, [pc, #40]	; (9324 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x48>)
    92fc:	9b01      	ldr	r3, [sp, #4]
    92fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9302:	f003 0301 	and.w	r3, r3, #1
    9306:	2b00      	cmp	r3, #0
    9308:	d106      	bne.n	9318 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
    930a:	4a05      	ldr	r2, [pc, #20]	; (9320 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    930c:	9b01      	ldr	r3, [sp, #4]
    930e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9312:	2b00      	cmp	r3, #0
    9314:	d100      	bne.n	9318 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9316:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9318:	bf00      	nop
    931a:	b003      	add	sp, #12
    931c:	f85d fb04 	ldr.w	pc, [sp], #4
    9320:	1fff8e98 	.word	0x1fff8e98
    9324:	1fff8e94 	.word	0x1fff8e94

00009328 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
    9328:	b500      	push	{lr}
    932a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    932c:	f7f7 fbf8 	bl	b20 <Sys_GetCoreID>
    9330:	4603      	mov	r3, r0
    9332:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId])
    9334:	4a10      	ldr	r2, [pc, #64]	; (9378 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    9336:	9b01      	ldr	r3, [sp, #4]
    9338:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    933c:	2b00      	cmp	r3, #0
    933e:	d10d      	bne.n	935c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9340:	f7f7 fb1e 	bl	980 <Spi_schm_read_msr>
    9344:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9346:	9b00      	ldr	r3, [sp, #0]
    9348:	f003 0301 	and.w	r3, r3, #1
    934c:	2b00      	cmp	r3, #0
    934e:	d100      	bne.n	9352 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9350:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    9352:	490a      	ldr	r1, [pc, #40]	; (937c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x54>)
    9354:	9b01      	ldr	r3, [sp, #4]
    9356:	9a00      	ldr	r2, [sp, #0]
    9358:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]++;
    935c:	4a06      	ldr	r2, [pc, #24]	; (9378 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    935e:	9b01      	ldr	r3, [sp, #4]
    9360:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9364:	1c5a      	adds	r2, r3, #1
    9366:	4904      	ldr	r1, [pc, #16]	; (9378 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    9368:	9b01      	ldr	r3, [sp, #4]
    936a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    936e:	bf00      	nop
    9370:	b003      	add	sp, #12
    9372:	f85d fb04 	ldr.w	pc, [sp], #4
    9376:	bf00      	nop
    9378:	1fff8ea0 	.word	0x1fff8ea0
    937c:	1fff8e9c 	.word	0x1fff8e9c

00009380 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
    9380:	b500      	push	{lr}
    9382:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9384:	f7f7 fbcc 	bl	b20 <Sys_GetCoreID>
    9388:	4603      	mov	r3, r0
    938a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]--;
    938c:	4a0d      	ldr	r2, [pc, #52]	; (93c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    938e:	9b01      	ldr	r3, [sp, #4]
    9390:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9394:	1e5a      	subs	r2, r3, #1
    9396:	490b      	ldr	r1, [pc, #44]	; (93c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    9398:	9b01      	ldr	r3, [sp, #4]
    939a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    939e:	4a0a      	ldr	r2, [pc, #40]	; (93c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x48>)
    93a0:	9b01      	ldr	r3, [sp, #4]
    93a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93a6:	f003 0301 	and.w	r3, r3, #1
    93aa:	2b00      	cmp	r3, #0
    93ac:	d106      	bne.n	93bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
    93ae:	4a05      	ldr	r2, [pc, #20]	; (93c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    93b0:	9b01      	ldr	r3, [sp, #4]
    93b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93b6:	2b00      	cmp	r3, #0
    93b8:	d100      	bne.n	93bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    93ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    93bc:	bf00      	nop
    93be:	b003      	add	sp, #12
    93c0:	f85d fb04 	ldr.w	pc, [sp], #4
    93c4:	1fff8ea0 	.word	0x1fff8ea0
    93c8:	1fff8e9c 	.word	0x1fff8e9c

000093cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
    93cc:	b500      	push	{lr}
    93ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    93d0:	f7f7 fba6 	bl	b20 <Sys_GetCoreID>
    93d4:	4603      	mov	r3, r0
    93d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId])
    93d8:	4a10      	ldr	r2, [pc, #64]	; (941c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    93da:	9b01      	ldr	r3, [sp, #4]
    93dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93e0:	2b00      	cmp	r3, #0
    93e2:	d10d      	bne.n	9400 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    93e4:	f7f7 facc 	bl	980 <Spi_schm_read_msr>
    93e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    93ea:	9b00      	ldr	r3, [sp, #0]
    93ec:	f003 0301 	and.w	r3, r3, #1
    93f0:	2b00      	cmp	r3, #0
    93f2:	d100      	bne.n	93f6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    93f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    93f6:	490a      	ldr	r1, [pc, #40]	; (9420 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x54>)
    93f8:	9b01      	ldr	r3, [sp, #4]
    93fa:	9a00      	ldr	r2, [sp, #0]
    93fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]++;
    9400:	4a06      	ldr	r2, [pc, #24]	; (941c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    9402:	9b01      	ldr	r3, [sp, #4]
    9404:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9408:	1c5a      	adds	r2, r3, #1
    940a:	4904      	ldr	r1, [pc, #16]	; (941c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    940c:	9b01      	ldr	r3, [sp, #4]
    940e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9412:	bf00      	nop
    9414:	b003      	add	sp, #12
    9416:	f85d fb04 	ldr.w	pc, [sp], #4
    941a:	bf00      	nop
    941c:	1fff8ea8 	.word	0x1fff8ea8
    9420:	1fff8ea4 	.word	0x1fff8ea4

00009424 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
    9424:	b500      	push	{lr}
    9426:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9428:	f7f7 fb7a 	bl	b20 <Sys_GetCoreID>
    942c:	4603      	mov	r3, r0
    942e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]--;
    9430:	4a0d      	ldr	r2, [pc, #52]	; (9468 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    9432:	9b01      	ldr	r3, [sp, #4]
    9434:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9438:	1e5a      	subs	r2, r3, #1
    943a:	490b      	ldr	r1, [pc, #44]	; (9468 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    943c:	9b01      	ldr	r3, [sp, #4]
    943e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    9442:	4a0a      	ldr	r2, [pc, #40]	; (946c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x48>)
    9444:	9b01      	ldr	r3, [sp, #4]
    9446:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    944a:	f003 0301 	and.w	r3, r3, #1
    944e:	2b00      	cmp	r3, #0
    9450:	d106      	bne.n	9460 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
    9452:	4a05      	ldr	r2, [pc, #20]	; (9468 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    9454:	9b01      	ldr	r3, [sp, #4]
    9456:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    945a:	2b00      	cmp	r3, #0
    945c:	d100      	bne.n	9460 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    945e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9460:	bf00      	nop
    9462:	b003      	add	sp, #12
    9464:	f85d fb04 	ldr.w	pc, [sp], #4
    9468:	1fff8ea8 	.word	0x1fff8ea8
    946c:	1fff8ea4 	.word	0x1fff8ea4

00009470 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
    9470:	b500      	push	{lr}
    9472:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9474:	f7f7 fb54 	bl	b20 <Sys_GetCoreID>
    9478:	4603      	mov	r3, r0
    947a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId])
    947c:	4a10      	ldr	r2, [pc, #64]	; (94c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    947e:	9b01      	ldr	r3, [sp, #4]
    9480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9484:	2b00      	cmp	r3, #0
    9486:	d10d      	bne.n	94a4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9488:	f7f7 fa7a 	bl	980 <Spi_schm_read_msr>
    948c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    948e:	9b00      	ldr	r3, [sp, #0]
    9490:	f003 0301 	and.w	r3, r3, #1
    9494:	2b00      	cmp	r3, #0
    9496:	d100      	bne.n	949a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9498:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    949a:	490a      	ldr	r1, [pc, #40]	; (94c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x54>)
    949c:	9b01      	ldr	r3, [sp, #4]
    949e:	9a00      	ldr	r2, [sp, #0]
    94a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]++;
    94a4:	4a06      	ldr	r2, [pc, #24]	; (94c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    94a6:	9b01      	ldr	r3, [sp, #4]
    94a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94ac:	1c5a      	adds	r2, r3, #1
    94ae:	4904      	ldr	r1, [pc, #16]	; (94c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    94b0:	9b01      	ldr	r3, [sp, #4]
    94b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    94b6:	bf00      	nop
    94b8:	b003      	add	sp, #12
    94ba:	f85d fb04 	ldr.w	pc, [sp], #4
    94be:	bf00      	nop
    94c0:	1fff8eb0 	.word	0x1fff8eb0
    94c4:	1fff8eac 	.word	0x1fff8eac

000094c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
    94c8:	b500      	push	{lr}
    94ca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    94cc:	f7f7 fb28 	bl	b20 <Sys_GetCoreID>
    94d0:	4603      	mov	r3, r0
    94d2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]--;
    94d4:	4a0d      	ldr	r2, [pc, #52]	; (950c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    94d6:	9b01      	ldr	r3, [sp, #4]
    94d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94dc:	1e5a      	subs	r2, r3, #1
    94de:	490b      	ldr	r1, [pc, #44]	; (950c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    94e0:	9b01      	ldr	r3, [sp, #4]
    94e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    94e6:	4a0a      	ldr	r2, [pc, #40]	; (9510 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x48>)
    94e8:	9b01      	ldr	r3, [sp, #4]
    94ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94ee:	f003 0301 	and.w	r3, r3, #1
    94f2:	2b00      	cmp	r3, #0
    94f4:	d106      	bne.n	9504 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
    94f6:	4a05      	ldr	r2, [pc, #20]	; (950c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    94f8:	9b01      	ldr	r3, [sp, #4]
    94fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94fe:	2b00      	cmp	r3, #0
    9500:	d100      	bne.n	9504 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9502:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9504:	bf00      	nop
    9506:	b003      	add	sp, #12
    9508:	f85d fb04 	ldr.w	pc, [sp], #4
    950c:	1fff8eb0 	.word	0x1fff8eb0
    9510:	1fff8eac 	.word	0x1fff8eac

00009514 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
    9514:	b500      	push	{lr}
    9516:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9518:	f7f7 fb02 	bl	b20 <Sys_GetCoreID>
    951c:	4603      	mov	r3, r0
    951e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId])
    9520:	4a10      	ldr	r2, [pc, #64]	; (9564 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    9522:	9b01      	ldr	r3, [sp, #4]
    9524:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9528:	2b00      	cmp	r3, #0
    952a:	d10d      	bne.n	9548 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    952c:	f7f7 fa28 	bl	980 <Spi_schm_read_msr>
    9530:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9532:	9b00      	ldr	r3, [sp, #0]
    9534:	f003 0301 	and.w	r3, r3, #1
    9538:	2b00      	cmp	r3, #0
    953a:	d100      	bne.n	953e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    953c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    953e:	490a      	ldr	r1, [pc, #40]	; (9568 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x54>)
    9540:	9b01      	ldr	r3, [sp, #4]
    9542:	9a00      	ldr	r2, [sp, #0]
    9544:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]++;
    9548:	4a06      	ldr	r2, [pc, #24]	; (9564 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    954a:	9b01      	ldr	r3, [sp, #4]
    954c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9550:	1c5a      	adds	r2, r3, #1
    9552:	4904      	ldr	r1, [pc, #16]	; (9564 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    9554:	9b01      	ldr	r3, [sp, #4]
    9556:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    955a:	bf00      	nop
    955c:	b003      	add	sp, #12
    955e:	f85d fb04 	ldr.w	pc, [sp], #4
    9562:	bf00      	nop
    9564:	1fff8eb8 	.word	0x1fff8eb8
    9568:	1fff8eb4 	.word	0x1fff8eb4

0000956c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
    956c:	b500      	push	{lr}
    956e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9570:	f7f7 fad6 	bl	b20 <Sys_GetCoreID>
    9574:	4603      	mov	r3, r0
    9576:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]--;
    9578:	4a0d      	ldr	r2, [pc, #52]	; (95b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    957a:	9b01      	ldr	r3, [sp, #4]
    957c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9580:	1e5a      	subs	r2, r3, #1
    9582:	490b      	ldr	r1, [pc, #44]	; (95b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    9584:	9b01      	ldr	r3, [sp, #4]
    9586:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    958a:	4a0a      	ldr	r2, [pc, #40]	; (95b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x48>)
    958c:	9b01      	ldr	r3, [sp, #4]
    958e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9592:	f003 0301 	and.w	r3, r3, #1
    9596:	2b00      	cmp	r3, #0
    9598:	d106      	bne.n	95a8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
    959a:	4a05      	ldr	r2, [pc, #20]	; (95b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    959c:	9b01      	ldr	r3, [sp, #4]
    959e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95a2:	2b00      	cmp	r3, #0
    95a4:	d100      	bne.n	95a8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    95a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    95a8:	bf00      	nop
    95aa:	b003      	add	sp, #12
    95ac:	f85d fb04 	ldr.w	pc, [sp], #4
    95b0:	1fff8eb8 	.word	0x1fff8eb8
    95b4:	1fff8eb4 	.word	0x1fff8eb4

000095b8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
    95b8:	b500      	push	{lr}
    95ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    95bc:	f7f7 fab0 	bl	b20 <Sys_GetCoreID>
    95c0:	4603      	mov	r3, r0
    95c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId])
    95c4:	4a10      	ldr	r2, [pc, #64]	; (9608 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    95c6:	9b01      	ldr	r3, [sp, #4]
    95c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95cc:	2b00      	cmp	r3, #0
    95ce:	d10d      	bne.n	95ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    95d0:	f7f7 f9d6 	bl	980 <Spi_schm_read_msr>
    95d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    95d6:	9b00      	ldr	r3, [sp, #0]
    95d8:	f003 0301 	and.w	r3, r3, #1
    95dc:	2b00      	cmp	r3, #0
    95de:	d100      	bne.n	95e2 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    95e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    95e2:	490a      	ldr	r1, [pc, #40]	; (960c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x54>)
    95e4:	9b01      	ldr	r3, [sp, #4]
    95e6:	9a00      	ldr	r2, [sp, #0]
    95e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]++;
    95ec:	4a06      	ldr	r2, [pc, #24]	; (9608 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    95ee:	9b01      	ldr	r3, [sp, #4]
    95f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95f4:	1c5a      	adds	r2, r3, #1
    95f6:	4904      	ldr	r1, [pc, #16]	; (9608 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    95f8:	9b01      	ldr	r3, [sp, #4]
    95fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    95fe:	bf00      	nop
    9600:	b003      	add	sp, #12
    9602:	f85d fb04 	ldr.w	pc, [sp], #4
    9606:	bf00      	nop
    9608:	1fff8ec0 	.word	0x1fff8ec0
    960c:	1fff8ebc 	.word	0x1fff8ebc

00009610 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
    9610:	b500      	push	{lr}
    9612:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9614:	f7f7 fa84 	bl	b20 <Sys_GetCoreID>
    9618:	4603      	mov	r3, r0
    961a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]--;
    961c:	4a0d      	ldr	r2, [pc, #52]	; (9654 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    961e:	9b01      	ldr	r3, [sp, #4]
    9620:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9624:	1e5a      	subs	r2, r3, #1
    9626:	490b      	ldr	r1, [pc, #44]	; (9654 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    9628:	9b01      	ldr	r3, [sp, #4]
    962a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    962e:	4a0a      	ldr	r2, [pc, #40]	; (9658 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x48>)
    9630:	9b01      	ldr	r3, [sp, #4]
    9632:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9636:	f003 0301 	and.w	r3, r3, #1
    963a:	2b00      	cmp	r3, #0
    963c:	d106      	bne.n	964c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
    963e:	4a05      	ldr	r2, [pc, #20]	; (9654 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    9640:	9b01      	ldr	r3, [sp, #4]
    9642:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9646:	2b00      	cmp	r3, #0
    9648:	d100      	bne.n	964c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    964a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    964c:	bf00      	nop
    964e:	b003      	add	sp, #12
    9650:	f85d fb04 	ldr.w	pc, [sp], #4
    9654:	1fff8ec0 	.word	0x1fff8ec0
    9658:	1fff8ebc 	.word	0x1fff8ebc

0000965c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
    965c:	b500      	push	{lr}
    965e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9660:	f7f7 fa5e 	bl	b20 <Sys_GetCoreID>
    9664:	4603      	mov	r3, r0
    9666:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId])
    9668:	4a10      	ldr	r2, [pc, #64]	; (96ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    966a:	9b01      	ldr	r3, [sp, #4]
    966c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9670:	2b00      	cmp	r3, #0
    9672:	d10d      	bne.n	9690 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9674:	f7f7 f984 	bl	980 <Spi_schm_read_msr>
    9678:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    967a:	9b00      	ldr	r3, [sp, #0]
    967c:	f003 0301 	and.w	r3, r3, #1
    9680:	2b00      	cmp	r3, #0
    9682:	d100      	bne.n	9686 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9684:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    9686:	490a      	ldr	r1, [pc, #40]	; (96b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x54>)
    9688:	9b01      	ldr	r3, [sp, #4]
    968a:	9a00      	ldr	r2, [sp, #0]
    968c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]++;
    9690:	4a06      	ldr	r2, [pc, #24]	; (96ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    9692:	9b01      	ldr	r3, [sp, #4]
    9694:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9698:	1c5a      	adds	r2, r3, #1
    969a:	4904      	ldr	r1, [pc, #16]	; (96ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    969c:	9b01      	ldr	r3, [sp, #4]
    969e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    96a2:	bf00      	nop
    96a4:	b003      	add	sp, #12
    96a6:	f85d fb04 	ldr.w	pc, [sp], #4
    96aa:	bf00      	nop
    96ac:	1fff8ec8 	.word	0x1fff8ec8
    96b0:	1fff8ec4 	.word	0x1fff8ec4

000096b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
    96b4:	b500      	push	{lr}
    96b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    96b8:	f7f7 fa32 	bl	b20 <Sys_GetCoreID>
    96bc:	4603      	mov	r3, r0
    96be:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]--;
    96c0:	4a0d      	ldr	r2, [pc, #52]	; (96f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    96c2:	9b01      	ldr	r3, [sp, #4]
    96c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96c8:	1e5a      	subs	r2, r3, #1
    96ca:	490b      	ldr	r1, [pc, #44]	; (96f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    96cc:	9b01      	ldr	r3, [sp, #4]
    96ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    96d2:	4a0a      	ldr	r2, [pc, #40]	; (96fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x48>)
    96d4:	9b01      	ldr	r3, [sp, #4]
    96d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96da:	f003 0301 	and.w	r3, r3, #1
    96de:	2b00      	cmp	r3, #0
    96e0:	d106      	bne.n	96f0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
    96e2:	4a05      	ldr	r2, [pc, #20]	; (96f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    96e4:	9b01      	ldr	r3, [sp, #4]
    96e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96ea:	2b00      	cmp	r3, #0
    96ec:	d100      	bne.n	96f0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    96ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    96f0:	bf00      	nop
    96f2:	b003      	add	sp, #12
    96f4:	f85d fb04 	ldr.w	pc, [sp], #4
    96f8:	1fff8ec8 	.word	0x1fff8ec8
    96fc:	1fff8ec4 	.word	0x1fff8ec4

00009700 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
    9700:	b500      	push	{lr}
    9702:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9704:	f7f7 fa0c 	bl	b20 <Sys_GetCoreID>
    9708:	4603      	mov	r3, r0
    970a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId])
    970c:	4a10      	ldr	r2, [pc, #64]	; (9750 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    970e:	9b01      	ldr	r3, [sp, #4]
    9710:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9714:	2b00      	cmp	r3, #0
    9716:	d10d      	bne.n	9734 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9718:	f7f7 f932 	bl	980 <Spi_schm_read_msr>
    971c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    971e:	9b00      	ldr	r3, [sp, #0]
    9720:	f003 0301 	and.w	r3, r3, #1
    9724:	2b00      	cmp	r3, #0
    9726:	d100      	bne.n	972a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9728:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    972a:	490a      	ldr	r1, [pc, #40]	; (9754 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x54>)
    972c:	9b01      	ldr	r3, [sp, #4]
    972e:	9a00      	ldr	r2, [sp, #0]
    9730:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]++;
    9734:	4a06      	ldr	r2, [pc, #24]	; (9750 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    9736:	9b01      	ldr	r3, [sp, #4]
    9738:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    973c:	1c5a      	adds	r2, r3, #1
    973e:	4904      	ldr	r1, [pc, #16]	; (9750 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    9740:	9b01      	ldr	r3, [sp, #4]
    9742:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9746:	bf00      	nop
    9748:	b003      	add	sp, #12
    974a:	f85d fb04 	ldr.w	pc, [sp], #4
    974e:	bf00      	nop
    9750:	1fff8ed0 	.word	0x1fff8ed0
    9754:	1fff8ecc 	.word	0x1fff8ecc

00009758 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
    9758:	b500      	push	{lr}
    975a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    975c:	f7f7 f9e0 	bl	b20 <Sys_GetCoreID>
    9760:	4603      	mov	r3, r0
    9762:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]--;
    9764:	4a0d      	ldr	r2, [pc, #52]	; (979c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    9766:	9b01      	ldr	r3, [sp, #4]
    9768:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    976c:	1e5a      	subs	r2, r3, #1
    976e:	490b      	ldr	r1, [pc, #44]	; (979c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    9770:	9b01      	ldr	r3, [sp, #4]
    9772:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    9776:	4a0a      	ldr	r2, [pc, #40]	; (97a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x48>)
    9778:	9b01      	ldr	r3, [sp, #4]
    977a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    977e:	f003 0301 	and.w	r3, r3, #1
    9782:	2b00      	cmp	r3, #0
    9784:	d106      	bne.n	9794 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
    9786:	4a05      	ldr	r2, [pc, #20]	; (979c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    9788:	9b01      	ldr	r3, [sp, #4]
    978a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    978e:	2b00      	cmp	r3, #0
    9790:	d100      	bne.n	9794 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9792:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9794:	bf00      	nop
    9796:	b003      	add	sp, #12
    9798:	f85d fb04 	ldr.w	pc, [sp], #4
    979c:	1fff8ed0 	.word	0x1fff8ed0
    97a0:	1fff8ecc 	.word	0x1fff8ecc

000097a4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
    97a4:	b500      	push	{lr}
    97a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    97a8:	f7f7 f9ba 	bl	b20 <Sys_GetCoreID>
    97ac:	4603      	mov	r3, r0
    97ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId])
    97b0:	4a10      	ldr	r2, [pc, #64]	; (97f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    97b2:	9b01      	ldr	r3, [sp, #4]
    97b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97b8:	2b00      	cmp	r3, #0
    97ba:	d10d      	bne.n	97d8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    97bc:	f7f7 f8e0 	bl	980 <Spi_schm_read_msr>
    97c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    97c2:	9b00      	ldr	r3, [sp, #0]
    97c4:	f003 0301 	and.w	r3, r3, #1
    97c8:	2b00      	cmp	r3, #0
    97ca:	d100      	bne.n	97ce <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    97cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    97ce:	490a      	ldr	r1, [pc, #40]	; (97f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x54>)
    97d0:	9b01      	ldr	r3, [sp, #4]
    97d2:	9a00      	ldr	r2, [sp, #0]
    97d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]++;
    97d8:	4a06      	ldr	r2, [pc, #24]	; (97f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    97da:	9b01      	ldr	r3, [sp, #4]
    97dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97e0:	1c5a      	adds	r2, r3, #1
    97e2:	4904      	ldr	r1, [pc, #16]	; (97f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    97e4:	9b01      	ldr	r3, [sp, #4]
    97e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    97ea:	bf00      	nop
    97ec:	b003      	add	sp, #12
    97ee:	f85d fb04 	ldr.w	pc, [sp], #4
    97f2:	bf00      	nop
    97f4:	1fff8ed8 	.word	0x1fff8ed8
    97f8:	1fff8ed4 	.word	0x1fff8ed4

000097fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
    97fc:	b500      	push	{lr}
    97fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9800:	f7f7 f98e 	bl	b20 <Sys_GetCoreID>
    9804:	4603      	mov	r3, r0
    9806:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]--;
    9808:	4a0d      	ldr	r2, [pc, #52]	; (9840 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    980a:	9b01      	ldr	r3, [sp, #4]
    980c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9810:	1e5a      	subs	r2, r3, #1
    9812:	490b      	ldr	r1, [pc, #44]	; (9840 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    9814:	9b01      	ldr	r3, [sp, #4]
    9816:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    981a:	4a0a      	ldr	r2, [pc, #40]	; (9844 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x48>)
    981c:	9b01      	ldr	r3, [sp, #4]
    981e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9822:	f003 0301 	and.w	r3, r3, #1
    9826:	2b00      	cmp	r3, #0
    9828:	d106      	bne.n	9838 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
    982a:	4a05      	ldr	r2, [pc, #20]	; (9840 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    982c:	9b01      	ldr	r3, [sp, #4]
    982e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9832:	2b00      	cmp	r3, #0
    9834:	d100      	bne.n	9838 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9836:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9838:	bf00      	nop
    983a:	b003      	add	sp, #12
    983c:	f85d fb04 	ldr.w	pc, [sp], #4
    9840:	1fff8ed8 	.word	0x1fff8ed8
    9844:	1fff8ed4 	.word	0x1fff8ed4

00009848 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
    9848:	b500      	push	{lr}
    984a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    984c:	f7f7 f968 	bl	b20 <Sys_GetCoreID>
    9850:	4603      	mov	r3, r0
    9852:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId])
    9854:	4a10      	ldr	r2, [pc, #64]	; (9898 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    9856:	9b01      	ldr	r3, [sp, #4]
    9858:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    985c:	2b00      	cmp	r3, #0
    985e:	d10d      	bne.n	987c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9860:	f7f7 f88e 	bl	980 <Spi_schm_read_msr>
    9864:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9866:	9b00      	ldr	r3, [sp, #0]
    9868:	f003 0301 	and.w	r3, r3, #1
    986c:	2b00      	cmp	r3, #0
    986e:	d100      	bne.n	9872 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9870:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    9872:	490a      	ldr	r1, [pc, #40]	; (989c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x54>)
    9874:	9b01      	ldr	r3, [sp, #4]
    9876:	9a00      	ldr	r2, [sp, #0]
    9878:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]++;
    987c:	4a06      	ldr	r2, [pc, #24]	; (9898 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    987e:	9b01      	ldr	r3, [sp, #4]
    9880:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9884:	1c5a      	adds	r2, r3, #1
    9886:	4904      	ldr	r1, [pc, #16]	; (9898 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    9888:	9b01      	ldr	r3, [sp, #4]
    988a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    988e:	bf00      	nop
    9890:	b003      	add	sp, #12
    9892:	f85d fb04 	ldr.w	pc, [sp], #4
    9896:	bf00      	nop
    9898:	1fff8ee0 	.word	0x1fff8ee0
    989c:	1fff8edc 	.word	0x1fff8edc

000098a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
    98a0:	b500      	push	{lr}
    98a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    98a4:	f7f7 f93c 	bl	b20 <Sys_GetCoreID>
    98a8:	4603      	mov	r3, r0
    98aa:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]--;
    98ac:	4a0d      	ldr	r2, [pc, #52]	; (98e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    98ae:	9b01      	ldr	r3, [sp, #4]
    98b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98b4:	1e5a      	subs	r2, r3, #1
    98b6:	490b      	ldr	r1, [pc, #44]	; (98e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    98b8:	9b01      	ldr	r3, [sp, #4]
    98ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    98be:	4a0a      	ldr	r2, [pc, #40]	; (98e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x48>)
    98c0:	9b01      	ldr	r3, [sp, #4]
    98c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98c6:	f003 0301 	and.w	r3, r3, #1
    98ca:	2b00      	cmp	r3, #0
    98cc:	d106      	bne.n	98dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
    98ce:	4a05      	ldr	r2, [pc, #20]	; (98e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    98d0:	9b01      	ldr	r3, [sp, #4]
    98d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98d6:	2b00      	cmp	r3, #0
    98d8:	d100      	bne.n	98dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    98da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    98dc:	bf00      	nop
    98de:	b003      	add	sp, #12
    98e0:	f85d fb04 	ldr.w	pc, [sp], #4
    98e4:	1fff8ee0 	.word	0x1fff8ee0
    98e8:	1fff8edc 	.word	0x1fff8edc

000098ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
    98ec:	b500      	push	{lr}
    98ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    98f0:	f7f7 f916 	bl	b20 <Sys_GetCoreID>
    98f4:	4603      	mov	r3, r0
    98f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId])
    98f8:	4a10      	ldr	r2, [pc, #64]	; (993c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    98fa:	9b01      	ldr	r3, [sp, #4]
    98fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9900:	2b00      	cmp	r3, #0
    9902:	d10d      	bne.n	9920 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9904:	f7f7 f83c 	bl	980 <Spi_schm_read_msr>
    9908:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    990a:	9b00      	ldr	r3, [sp, #0]
    990c:	f003 0301 	and.w	r3, r3, #1
    9910:	2b00      	cmp	r3, #0
    9912:	d100      	bne.n	9916 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9914:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    9916:	490a      	ldr	r1, [pc, #40]	; (9940 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x54>)
    9918:	9b01      	ldr	r3, [sp, #4]
    991a:	9a00      	ldr	r2, [sp, #0]
    991c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]++;
    9920:	4a06      	ldr	r2, [pc, #24]	; (993c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    9922:	9b01      	ldr	r3, [sp, #4]
    9924:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9928:	1c5a      	adds	r2, r3, #1
    992a:	4904      	ldr	r1, [pc, #16]	; (993c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    992c:	9b01      	ldr	r3, [sp, #4]
    992e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9932:	bf00      	nop
    9934:	b003      	add	sp, #12
    9936:	f85d fb04 	ldr.w	pc, [sp], #4
    993a:	bf00      	nop
    993c:	1fff8ee8 	.word	0x1fff8ee8
    9940:	1fff8ee4 	.word	0x1fff8ee4

00009944 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
    9944:	b500      	push	{lr}
    9946:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9948:	f7f7 f8ea 	bl	b20 <Sys_GetCoreID>
    994c:	4603      	mov	r3, r0
    994e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]--;
    9950:	4a0d      	ldr	r2, [pc, #52]	; (9988 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    9952:	9b01      	ldr	r3, [sp, #4]
    9954:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9958:	1e5a      	subs	r2, r3, #1
    995a:	490b      	ldr	r1, [pc, #44]	; (9988 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    995c:	9b01      	ldr	r3, [sp, #4]
    995e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    9962:	4a0a      	ldr	r2, [pc, #40]	; (998c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x48>)
    9964:	9b01      	ldr	r3, [sp, #4]
    9966:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    996a:	f003 0301 	and.w	r3, r3, #1
    996e:	2b00      	cmp	r3, #0
    9970:	d106      	bne.n	9980 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
    9972:	4a05      	ldr	r2, [pc, #20]	; (9988 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    9974:	9b01      	ldr	r3, [sp, #4]
    9976:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    997a:	2b00      	cmp	r3, #0
    997c:	d100      	bne.n	9980 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    997e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9980:	bf00      	nop
    9982:	b003      	add	sp, #12
    9984:	f85d fb04 	ldr.w	pc, [sp], #4
    9988:	1fff8ee8 	.word	0x1fff8ee8
    998c:	1fff8ee4 	.word	0x1fff8ee4

00009990 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
    9990:	b500      	push	{lr}
    9992:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9994:	f7f7 f8c4 	bl	b20 <Sys_GetCoreID>
    9998:	4603      	mov	r3, r0
    999a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId])
    999c:	4a10      	ldr	r2, [pc, #64]	; (99e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    999e:	9b01      	ldr	r3, [sp, #4]
    99a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99a4:	2b00      	cmp	r3, #0
    99a6:	d10d      	bne.n	99c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    99a8:	f7f6 ffea 	bl	980 <Spi_schm_read_msr>
    99ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    99ae:	9b00      	ldr	r3, [sp, #0]
    99b0:	f003 0301 	and.w	r3, r3, #1
    99b4:	2b00      	cmp	r3, #0
    99b6:	d100      	bne.n	99ba <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    99b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    99ba:	490a      	ldr	r1, [pc, #40]	; (99e4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x54>)
    99bc:	9b01      	ldr	r3, [sp, #4]
    99be:	9a00      	ldr	r2, [sp, #0]
    99c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]++;
    99c4:	4a06      	ldr	r2, [pc, #24]	; (99e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    99c6:	9b01      	ldr	r3, [sp, #4]
    99c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99cc:	1c5a      	adds	r2, r3, #1
    99ce:	4904      	ldr	r1, [pc, #16]	; (99e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    99d0:	9b01      	ldr	r3, [sp, #4]
    99d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    99d6:	bf00      	nop
    99d8:	b003      	add	sp, #12
    99da:	f85d fb04 	ldr.w	pc, [sp], #4
    99de:	bf00      	nop
    99e0:	1fff8ef0 	.word	0x1fff8ef0
    99e4:	1fff8eec 	.word	0x1fff8eec

000099e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
    99e8:	b500      	push	{lr}
    99ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    99ec:	f7f7 f898 	bl	b20 <Sys_GetCoreID>
    99f0:	4603      	mov	r3, r0
    99f2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]--;
    99f4:	4a0d      	ldr	r2, [pc, #52]	; (9a2c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    99f6:	9b01      	ldr	r3, [sp, #4]
    99f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99fc:	1e5a      	subs	r2, r3, #1
    99fe:	490b      	ldr	r1, [pc, #44]	; (9a2c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    9a00:	9b01      	ldr	r3, [sp, #4]
    9a02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    9a06:	4a0a      	ldr	r2, [pc, #40]	; (9a30 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x48>)
    9a08:	9b01      	ldr	r3, [sp, #4]
    9a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a0e:	f003 0301 	and.w	r3, r3, #1
    9a12:	2b00      	cmp	r3, #0
    9a14:	d106      	bne.n	9a24 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
    9a16:	4a05      	ldr	r2, [pc, #20]	; (9a2c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    9a18:	9b01      	ldr	r3, [sp, #4]
    9a1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1e:	2b00      	cmp	r3, #0
    9a20:	d100      	bne.n	9a24 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9a22:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9a24:	bf00      	nop
    9a26:	b003      	add	sp, #12
    9a28:	f85d fb04 	ldr.w	pc, [sp], #4
    9a2c:	1fff8ef0 	.word	0x1fff8ef0
    9a30:	1fff8eec 	.word	0x1fff8eec

00009a34 <Clock_Ip_au8DividerCallbackIndex>:
    9a34:	0e0d0c00 06030201 0a070409 000b0805     ................

00009a44 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

00009a54 <Clock_Ip_au8XoscCallbackIndex>:
    9a54:	00000100 00000000 00000000 00000000     ................

00009a64 <Clock_Ip_au8IrcoscCallbackIndex>:
    9a64:	03020100 00000004 00000000 00000000     ................

00009a74 <Clock_Ip_au8GateCallbackIndex>:
    9a74:	06010200 01040301 00000500 00000000     ................

00009a84 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

00009a94 <Clock_Ip_au8PllCallbackIndex>:
    9a94:	00000100 00000000 00000000 00000000     ................

00009aa4 <Clock_Ip_au8SelectorCallbackIndex>:
    9aa4:	0a090800 03020109 07060504 00000000     ................

00009ab4 <Clock_Ip_au8PcfsCallbackIndex>:
	...

00009ac4 <Clock_Ip_au8CmuCallbackIndex>:
	...

00009ad4 <Clock_Ip_au8ClockFeatures>:
	...
    9ae4:	01000000 00000000 00000000 00000002     ................
    9af4:	00000000 00000300 00000000 00040000     ................
    9b04:	00000000 05000000 00000000 00000000     ................
    9b14:	00000006 00000000 00000100 00000000     ................
    9b24:	00010000 00000000 04000000 00000000     ................
    9b34:	00000000 00000005 00000001 00000401     ................
    9b44:	00000200 00050100 00030000 04020000     ................
    9b54:	04000000 02000000 00000005 00000005     ................
    9b64:	00000403 00000600 00050300 00070000     ................
    9b74:	05000000 00000000 00000000 00000006     ................
	...
    9bb4:	00050000 00000000 06000000 00000100     ................
    9bc4:	00000000 00030007 00000000 00000000     ................
    9bd4:	00000000 00060000 00000000 07000000     ................
    9be4:	00000100 00000000 00030008 00000000     ................
	...
    9bfc:	00090000 00000000 0a000000 00000100     ................
    9c0c:	00000000 0003000b 00000000 00000000     ................
    9c1c:	00000000 000c0000 00000000 0d000000     ................
    9c2c:	00000100 00000000 0003000e 00000000     ................
    9c3c:	00000800 00000000 00090000 00000000     ................
    9c4c:	0a000000 00000000 00000000 0000000b     ................
    9c5c:	00000000 00000b01 00000000 000b0200     ................
    9c6c:	00000000 0b030000 00000000 00000000     ................
	...
    9c84:	00000400 003b003b 00040000 27002700     ....;.;......'.'
    9c94:	01000000 00000000 00000000 00000007     ................
    9ca4:	00007300 00000700 00320000 00090000     .s........2.....
    9cb4:	02000000 07000000 00000000 00000021     ............!...
    9cc4:	00000009 00000400 00000900 00030000     ................
    9cd4:	00070000 61000000 07000000 00000000     .......a........
    9ce4:	00000024 00000007 00002500 00000700     $........%......
    9cf4:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
    9d04:	00000000 00000020 38000004 00003800     .... ......8.8..
    9d14:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
    9d24:	04000000 00260000 00000026 66000004     ......&.&......f
    9d34:	00006600 00000400 00370037 00040000     .f......7.7.....
    9d44:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
    9d54:	2e000004 00002e00 00000200 00404040     ............@@@.
    9d64:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
    9d74:	0000006b 6c000004 00006c00 00000900     k......l.l......
    9d84:	00010000 00090000 00000000 07000000     ................
    9d94:	00000000 00000036 00000007 00003100     ....6........1..
    9da4:	00000700 00490000 00070000 4a000000     ......I........J
    9db4:	07000000 00000000 0000004b 00000007     ........K.......
    9dc4:	00004c00 00000700 004d0000 00070000     .L........M.....
    9dd4:	3d000000 03000000 00000000 00000000     ...=............

00009de4 <Clock_Ip_au16SelectorEntryHardwareValue>:
    9de4:	01010a03 01010001 04040002 02000603     ................
    9df4:	00010810 02020100 00000000 00000007     ................
    9e04:	00000009 00000000 00000c0e 00000000     ................
	...

00009e3c <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    9e3c:	00020000 00000300 00000601 00000000     ................
	...

00009e6c <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    9e6c:	00000700 00000000 02020000 01010303     ................
    9e7c:	03020606 00000000 00000000 00000000     ................
	...

00009e9c <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    9e9c:	00000001 00000000 02020000 01010303     ................
    9eac:	03020606 00000000 00000000 00000000     ................
	...

00009ecc <Clock_Ip_au8DividerValueHardwareValue>:
    9ecc:	00020100 00000003 00000004 00000000     ................
    9edc:	00000005 00000000 00000000 00000000     ................
    9eec:	00000006 00000000 00000000 00000000     ................
	...
    9f0c:	00000007                                ....

00009f10 <Clock_Ip_apxScgPeriphAsyncDivs>:
    9f10:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

00009f20 <Clock_Ip_aeSourceTypeClockName>:
    9f20:	00000000 00000001 00000001 00000001     ................
    9f30:	00000001 00000001 00000001 00000001     ................
    9f40:	00000002 00000003 00000001 00000001     ................
    9f50:	00000001 00000001 00000002 00000002     ................
    9f60:	00000003 00000003 00000001 00000001     ................
    9f70:	00000004 00000004 00000004 00000004     ................
	...

00009fdc <Clock_Ip_aeHwPllName>:
    9fdc:	00000009                                ....

00009fe0 <Clock_Ip_aeHwDfsName>:
    9fe0:	00000057                                W...

00009fe4 <Clock_Ip_axDividerCallbacks>:
    9fe4:	00002119 00002123 0000213d 00002157     .!..#!..=!..W!..
    9ff4:	00002171 0000218b 000021a5 000021bf     q!...!...!...!..
    a004:	000021d9 000021f3 0000220d 00002227     .!...!..."..'"..
    a014:	00002241 0000225b 00002275              A"..["..u"..

0000a020 <Clock_Ip_axDividerTriggerCallbacks>:
    a020:	000025e9 000025e9                       .%...%..

0000a028 <Clock_Ip_axExtOscCallbacks>:
    a028:	000025f5 000025f5 000025f5 000025ff     .%...%...%...%..
    a038:	000025f5 00002609 00002623 0000263d     .%...&..#&..=&..
    a048:	000026c1 000026d5                       .&...&..

0000a050 <Clock_Ip_axFracDivCallbacks>:
    a050:	00002895 00002895 0000289f              .(...(...(..

0000a05c <Clock_Ip_axGateCallbacks>:
    a05c:	000028b9 000028c3 000029c3 000029dd     .(...(...)...)..
    a06c:	00002973 0000298d 00002923 0000293d     s)...)..#)..=)..
    a07c:	000028d3 000028ed 00002a13 00002a2d     .(...(...*..-*..
    a08c:	00002a63 00002a7d                       c*..}*..

0000a094 <Clock_Ip_axIntOscCallbacks>:
    a094:	00002c29 00002c29 00002c33 00002c3d     ),..),..3,..=,..
    a0a4:	00002c57 00002c71 00002c85 00002c9f     W,..q,...,...,..
    a0b4:	00002cb9 00002ccd 00002ce7 00002d01     .,...,...,...-..
    a0c4:	00002da9 00002dc3 00002ddd              .-...-...-..

0000a0d0 <Clock_Ip_axCmuCallbacks>:
    a0d0:	00003379 00003383 0000338f 00003379     y3...3...3..y3..

0000a0e0 <Clock_Ip_axPllCallbacks>:
    a0e0:	00003399 00003399 000033a3 00003399     .3...3...3...3..
    a0f0:	000033af 000033b9 000033d3 000033ed     .3...3...3...3..
    a100:	00003491 0000347d                       .4..}4..

0000a108 <Clock_Ip_axPcfsCallbacks>:
    a108:	000035ed                                .5..

0000a10c <Clock_Ip_axSelectorCallbacks>:
    a10c:	000035f9 000035f9 00003603 0000361d     .5...5...6...6..
    a11c:	000035f9 00003637 00003651 0000366b     .5..76..Q6..k6..
    a12c:	00003685 0000369f 000036b9 000036d3     .6...6...6...6..
    a13c:	000036ed 00003707 00003721 0000373b     .6...7..!7..;7..
    a14c:	00003755 0000376f 00003789 000037a3     U7..o7...7...7..
    a15c:	000037bd 000037d7                       .7...7..

0000a164 <ClockSource>:
    a164:	00000000 00000008 00000002 00000005     ................
	...
    a17c:	00000009                                ....

0000a180 <ResetReasonArray>:
    a180:	00000000 00000001 00000002 00000003     ................
    a190:	00000004 00000005 00000006 00000007     ................
    a1a0:	00000008 00000009 0000000a 0000000b     ................
    a1b0:	0000000c 0000000d 0000000e              ............

0000a1bc <Port_au32PortCiPortBaseAddr>:
    a1bc:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
    a1cc:	4004d000                                ...@

0000a1d0 <Port_au32PortCiGpioBaseAddr>:
    a1d0:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
    a1e0:	400ff100                                ...@

0000a1e4 <Lpspi_Ip_apxBases>:
    a1e4:	4002c000 4002d000 4002e000              ...@...@...@

0000a1f0 <Mcu_aClockConfigPB>:
	...
    a1f8:	1c000101 04000010 01000029 00000005     ........).......
    a208:	00000001 00000000 00000057 00000000     ........W.......
    a218:	00000000 00000008 007a1200 00000001     ..........z.....
    a228:	00000001 00000000 00000057 00000000     ........W.......
    a238:	00000057 00000000 00000000 00000000     W...............
	...
    a258:	00000019 00000005 0000001a 00000002     ................
    a268:	0000001b 00000005 0000002a 00000005     ........*.......
    a278:	00000028 0000000e 00000029 00000001     (.......).......
    a288:	00000056 0000001c 00000032 0000002a     V.......2...*...
    a298:	0000002b 00000014 0000002c 00000014     +.......,.......
    a2a8:	0000002d 00000014 0000002e 00000014     -...............
    a2b8:	0000003f 00000000 00000040 00000000     ?.......@.......
    a2c8:	00000041 00000000 00000042 00000000     A.......B.......
    a2d8:	00000031 00000000 00000045 0000000d     1.......E.......
    a2e8:	00000046 00000000 00000047 00000000     F.......G.......
    a2f8:	00000044 00000000 00000030 00000000     D.......0.......
    a308:	0000003d 00000000 00000043 00000000     =.......C.......
    a318:	00000049 00000000 0000004a 00000000     I.......J.......
    a328:	0000004b 00000000 00000048 00000000     K.......H.......
    a338:	0000000c 00000001 00000000 0000000d     ................
    a348:	00000002 00000000 0000000e 00000001     ................
    a358:	00000000 0000000f 00000001 00000000     ................
    a368:	0000001d 00000001 00000000 0000001e     ................
    a378:	00000008 00000000 0000001f 00000001     ................
    a388:	00000000 00000021 00000001 00000000     ....!...........
    a398:	00000022 00000002 00000000 00000023     "...........#...
    a3a8:	00000001 00000000 00000025 00000003     ........%.......
    a3b8:	00000000 00000026 00000004 00000000     ....&...........
    a3c8:	00000027 00000002 00000000 00000032     '...........2...
    a3d8:	00000001 00000000 00000048 00000001     ........H.......
    a3e8:	00000001 00000056 00000001 00000001     ....V...........
    a3f8:	00000057 00000000 00000000 00000057     W...........W...
	...
    a410:	00000057 00000000 00000000 00000057     W...........W...
	...
    a428:	00000057 00000000 00000057 00000057     W.......W...W...
	...
    a444:	00000014 00007d00 00000015 00007d00     .....}.......}..
    a454:	00000016 00007d00 00000017 00008000     .....}..........
    a464:	00000012 00000001 00000013 00000001     ................
    a474:	00000030 00000000 00000031 00000000     0.......1.......
    a484:	00000032 00000000 00000033 00000000     2.......3.......
    a494:	00000034 00000000 00000035 00000001     4.......5.......
    a4a4:	00000036 00000000 00000037 00000001     6.......7.......
    a4b4:	00000038 00000001 00000039 00000000     8.......9.......
    a4c4:	0000003a 00000000 0000003b 00000000     :.......;.......
    a4d4:	0000003c 00000000 0000003d 00000000     <.......=.......
    a4e4:	0000003e 00000000 0000003f 00000000     >.......?.......
    a4f4:	00000040 00000000 00000041 00000000     @.......A.......
    a504:	00000042 00000000 00000043 00000000     B.......C.......
    a514:	00000044 00000000 00000045 00000001     D.......E.......
    a524:	00000046 00000000 00000047 00000000     F.......G.......
    a534:	00000048 00000000 00000049 00000000     H.......I.......
    a544:	0000004a 00000000 0000004b 00000000     J.......K.......
    a554:	0000004c 00000001 0000004d 00000001     L.......M.......
    a564:	0000004e 00000000 0000004f 00000000     N.......O.......
    a574:	00000050 00000001 00000051 00000001     P.......Q.......
    a584:	00000052 00000001 00000053 00000001     R.......S.......
    a594:	00000054 00000001 00000055 00000000     T.......U.......
    a5a4:	00000056 00000001 00000057 00000000     V.......W.......
    a5b4:	00000000 00000057 00000000 00000057     ....W.......W...
	...

0000a5e8 <Lpspi_Ip_DeviceAttributes_SpiExternalDevice_0>:
    a5e8:	00000000 171716ee 08200000 1fff8b2c     .......... .,...

0000a5f8 <Lpspi_Ip_PhyUnitConfig_SpiPhyUnit_0>:
	...
    a600:	03000001 00000000 00000000              ............

0000a60c <Mcu_Config>:
    a60c:	0000005a 00000000 00000001 00000001     Z...............
    a61c:	0000a828 0000a1f0 0000a834              (.......4...

0000a628 <OsIf_xPredefinedConfig>:
    a628:	00000000 02dc6c00                       .....l..

0000a630 <OsIf_apxPredefinedConfig>:
    a630:	0000a628                                (...

0000a634 <Platform_uConfiguration>:
    a634:	0000a63c                                <...

0000a638 <Platform_Config>:
    a638:	0000a634                                4...

0000a63c <ipwConfig>:
	...

0000a644 <g_pin_mux_InitConfigArr>:
    a644:	4004a000 00000000 00000004 00000002     ...@............
    a654:	00000003 00000002 00000000 00000000     ................
	...
    a66c:	4004a000 00000000 00000003 00000002     ...@............
    a67c:	00000003 00000001 00000000 00000000     ................
	...
    a694:	4004a000 00000000 00000002 00000002     ...@............
    a6a4:	00000003 00000001 00000000 00000000     ................
	...
    a6bc:	4004a000 00000000 00000005 00000002     ...@............
    a6cc:	00000004 00000001 00000000 00000000     ................
	...

0000a6e4 <au8Port_PartitionList>:
    a6e4:	00000001                                ....

0000a6e8 <au32Port_PinToPartitionMap>:
    a6e8:	00000001 00000001 00000001 00000001     ................

0000a6f8 <Port_au16NoUnUsedPadsArrayDefault>:
    a6f8:	00010000 00030002 00070006 00090008     ................
    a708:	000c000b 000e000d 0010000f 00200011     .............. .
    a718:	00260021 00280027 002a0029 002c002b     !.&.'.(.).*.+.,.
    a728:	002e002d 0030002f 00400031 00420041     -.../.0.1.@.A.B.
    a738:	00460043 00480047 004a0049 004c004b     C.F.G.H.I.J.K.L.
    a748:	004e004d 0050004f 00600051 00620061     M.N.O.P.Q.`.a.b.
    a758:	00640063 00660065 00680067 006a0069     c.d.e.f.g.h.i.j.
    a768:	006c006b 006e006d 0070006f 00800071     k.l.m.n.o.p.q...
    a778:	00820081 00840083 00860085 00880087     ................
    a788:	008a0089 008c008b 008e008d 0090008f     ................

0000a798 <Port_UnUsedPin>:
    a798:	00000100 00000001 00000000              ............

0000a7a4 <Port_aPinConfigDefault>:
    a7a4:	00000024 00000300 00000000 00000002     $...............
    a7b4:	00010000 00000023 00000300 00000000     ....#...........
    a7c4:	00000001 00010000 00000022 00000300     ........".......
    a7d4:	00000000 00000001 00010000 00000025     ............%...
    a7e4:	00000400 00000000 00000001 00010000     ................

0000a7f4 <Port_Config>:
    a7f4:	00500004 0000a6f8 0000a798 0000a7a4     ..P.............
	...
    a80c:	0000a6e8 0000a6e4 0000a644              ........D...

0000a818 <Power_Ip_RCM_ConfigPB>:
	...

0000a820 <Power_Ip_PMC_ConfigPB>:
    a820:	00000000                                ....

0000a824 <Power_Ip_SMC_ConfigPB>:
    a824:	00000000                                ....

0000a828 <Power_Ip_aModeConfigPB>:
	...

0000a834 <Power_Ip_HwIPsConfigPB>:
    a834:	0000a818 0000a820 0000a824              .... ...$...

0000a840 <Spi_ExternalDeviceConfig_SpiExternalDevice_0>:
	...
    a848:	0000a5e8 00000000                       ........

0000a850 <Spi_aExternalDeviceConfigList>:
    a850:	0000a840                                @...

0000a854 <Spi_HwUnitConfig_SpiPhyUnit_0>:
	...
    a860:	0000a5f8 00000001                       ........

0000a868 <Spi_aHwUnitConfigList>:
    a868:	0000a854                                T...

0000a86c <Spi_ChannelConfig_SpiChannel_0>:
    a86c:	00000001 00000008 00000001 00000004     ................
    a87c:	1fff8ef8 00000000 1fff8d58              ........X...

0000a888 <Spi_aChannelConfigList>:
    a888:	0000a86c                                l...

0000a88c <Spi_SpiJob_0_ChannelAssignment>:
    a88c:	00000000                                ....

0000a890 <Spi_JobConfig_SpiJob_0>:
    a890:	00000001 0000a88c 00000000 00000000     ................
	...
    a8a8:	1fff8d54 00000000 0000a850              T.......P...

0000a8b4 <Spi_aJobConfigList>:
    a8b4:	0000a890                                ....

0000a8b8 <Spi_SpiSequence_0_JobAssignment>:
    a8b8:	00000000                                ....

0000a8bc <Spi_SequenceConfig_SpiSequence_0>:
    a8bc:	00000001 00000000 0000a8b8 00000000     ................
    a8cc:	00000000                                ....

0000a8d0 <Spi_aSequenceConfigList>:
    a8d0:	0000a8bc                                ....

0000a8d4 <Spi_Config>:
    a8d4:	00000001 00000000 00000000 0000a888     ................
    a8e4:	0000a8b4 0000a8d0 0000a850 0000a868     ........P...h...

0000a8f4 <__INIT_TABLE>:
    a8f4:	00000002 	.word	0x00000002
    a8f8:	1fff8b10 	.word	0x1fff8b10
    a8fc:	0000a91c 	.word	0x0000a91c
    a900:	0000a940 	.word	0x0000a940
    a904:	1fff8800 	.word	0x1fff8800
    a908:	00000000 	.word	0x00000000
    a90c:	00000310 	.word	0x00000310

0000a910 <__ZERO_TABLE>:
    a910:	00000001 	.word	0x00000001
    a914:	1fff8b40 	.word	0x1fff8b40
    a918:	1fff8f10 	.word	0x1fff8f10
