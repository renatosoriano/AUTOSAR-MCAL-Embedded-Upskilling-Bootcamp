
Marking local functions:


Marking externally visible functions: Can_43_FLEXCAN_Ipw_ProcessHwObject/25 Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 Can_43_FLEXCAN_Ipw_Write/22 Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter/21 Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter/20 Can_43_FLEXCAN_Ipw_GetControllerErrorState/19 Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_43_FLEXCAN_Ipw_DeInit/12 Can_43_FLEXCAN_Ipw_Init/11


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

CanIf_ControllerModeIndication/55 (CanIf_ControllerModeIndication) @0dc3d380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 
  Calls: 
FlexCAN_Ip_GetStartMode_Privileged/54 (FlexCAN_Ip_GetStartMode_Privileged) @0dc3d2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 
  Calls: 
FlexCAN_Ip_ConfigRxMb/53 (FlexCAN_Ip_ConfigRxMb) @0dc3d0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_InitRx/23 
  Calls: 
FlexCAN_Ip_SetRxMaskType_Privileged/52 (FlexCAN_Ip_SetRxMaskType_Privileged) @0dc3d000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_InitRx/23 
  Calls: 
FlexCAN_Ip_Send/51 (FlexCAN_Ip_Send) @0dc28e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_Write/22 
  Calls: 
FlexCAN_Ip_GetTransferStatus/50 (FlexCAN_Ip_GetTransferStatus) @0dc28d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_Write/22 
  Calls: 
FlexCAN_Ip_GetControllerRxErrorCounter/49 (FlexCAN_Ip_GetControllerRxErrorCounter) @0dc28b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter/21 
  Calls: 
FlexCAN_Ip_GetControllerTxErrorCounter/48 (FlexCAN_Ip_GetControllerTxErrorCounter) @0dc289a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter/20 
  Calls: 
FlexCAN_Ip_GetErrorStatus/47 (FlexCAN_Ip_GetErrorStatus) @0dc287e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_GetControllerErrorState/19 
  Calls: 
FlexCAN_Ip_AbortTransfer/46 (FlexCAN_Ip_AbortTransfer) @0dc28460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 
  Calls: 
FlexCAN_Ip_SetStartMode_Privileged/45 (FlexCAN_Ip_SetStartMode_Privileged) @0dc281c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 
  Calls: 
FlexCAN_Ip_EnableInterrupts_Privileged/44 (FlexCAN_Ip_EnableInterrupts_Privileged) @0dc280e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 
  Calls: 
FlexCAN_Ip_SetErrorInt_Privileged/43 (FlexCAN_Ip_SetErrorInt_Privileged) @0dc28000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 
  Calls: 
FlexCAN_Ip_EnterFreezeMode_Privileged/42 (FlexCAN_Ip_EnterFreezeMode_Privileged) @0d0ffa80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetBaudrate/13 
  Calls: 
FlexCAN_Ip_Deinit_Privileged/41 (FlexCAN_Ip_Deinit_Privileged) @0d0ff1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_DeInit/12 
  Calls: 
FlexCAN_Ip_SetStopMode_Privileged/40 (FlexCAN_Ip_SetStopMode_Privileged) @0d0ffe00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_43_FLEXCAN_Ipw_Init/11 
  Calls: 
FlexCAN_Ip_DisableInterrupts_Privileged/39 (FlexCAN_Ip_DisableInterrupts_Privileged) @0d0ffc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_Init/11 
  Calls: 
FlexCAN_Ip_Init_Privileged/38 (FlexCAN_Ip_Init_Privileged) @0d0ffb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_Init/11 
  Calls: 
FlexCAN_Ip_RxFifo/37 (FlexCAN_Ip_RxFifo) @0d0ff9a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 
  Calls: 
FlexCAN_Ip_Receive/36 (FlexCAN_Ip_Receive) @0d0ff8c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 
  Calls: 
CanIf_TxConfirmation/35 (CanIf_TxConfirmation) @0d0ff700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer/9 
  Calls: 
FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/34 (FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged) @0d0ff540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_43_FLEXCAN_Ipw_Init/11 Can_Ipw_InitBaudrate/8 
  Calls: 
FlexCAN_Ip_SetTDCOffset_Privileged/33 (FlexCAN_Ip_SetTDCOffset_Privileged) @0d0ff460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_43_FLEXCAN_Ipw_Init/11 Can_Ipw_InitBaudrate/8 
  Calls: 
FlexCAN_Ip_SetBitrateCbt_Privileged/32 (FlexCAN_Ip_SetBitrateCbt_Privileged) @0d0ff380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_Ipw_InitBaudrate/8 
  Calls: 
FlexCAN_Ip_SetBitrate_Privileged/31 (FlexCAN_Ip_SetBitrate_Privileged) @0d0ff2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_SetBaudrate/13 Can_Ipw_InitBaudrate/8 
  Calls: 
FlexCAN_Ip_ConfigRxFifo_Privileged/30 (FlexCAN_Ip_ConfigRxFifo_Privileged) @0d0ff0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_InitLegacyFifoFilter/7 
  Calls: 
FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/29 (FlexCAN_Ip_SetRxFifoGlobalMask_Privileged) @0d0ff000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_InitLegacyFifoFilter/7 
  Calls: 
FlexCAN_Ip_SetRxIndividualMask_Privileged/28 (FlexCAN_Ip_SetRxIndividualMask_Privileged) @0dbe97e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_InitRx/23 Can_Ipw_InitLegacyFifoFilter/7 
  Calls: 
CanIf_RxIndication/27 (CanIf_RxIndication) @0dbe9ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_Ipw_ParseData/6 
  Calls: 
Det_ReportRuntimeError/26 (Det_ReportRuntimeError) @0dbe9e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 Can_Ipw_ParseData/6 
  Calls: 
Can_43_FLEXCAN_Ipw_ProcessHwObject/25 (Can_43_FLEXCAN_Ipw_ProcessHwObject) @0dbe99a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer/9 
Can_43_FLEXCAN_Ipw_MainFunction_Mode/24 (Can_43_FLEXCAN_Ipw_MainFunction_Mode) @0dbe9700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: CanIf_ControllerModeIndication/55 FlexCAN_Ip_GetStartMode_Privileged/54 CanIf_ControllerModeIndication/55 FlexCAN_Ip_GetStartMode_Privileged/54 
Can_Ipw_InitRx/23 (Can_Ipw_InitRx) @0dbe9460
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 Can_43_FLEXCAN_Ipw_Init/11 
  Calls: Can_Ipw_InitLegacyFifoFilter/7 FlexCAN_Ip_SetRxIndividualMask_Privileged/28 FlexCAN_Ip_ConfigRxMb/53 FlexCAN_Ip_SetRxMaskType_Privileged/52 
Can_43_FLEXCAN_Ipw_Write/22 (Can_43_FLEXCAN_Ipw_Write) @0dbe9000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_au16ControllerBaudRateSel/4 (read) Can_Ipw_au16TxPduId/2 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_Send/51 FlexCAN_Ip_GetTransferStatus/50 
Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter/21 (Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter) @0dbdfc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_GetControllerRxErrorCounter/49 
Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter/20 (Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter) @0dbdf540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_GetControllerTxErrorCounter/48 
Can_43_FLEXCAN_Ipw_GetControllerErrorState/19 (Can_43_FLEXCAN_Ipw_GetControllerErrorState) @0dbdfe00
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_GetErrorStatus/47 
Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 (Can_43_FLEXCAN_Ipw_EnableControllerInterrupts) @0dbdfb60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_Ipw_abIsInterruptEnabled/5 (read) Can_Ipw_abIsInterruptEnabled/5 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_SetErrorInt_Privileged/43 FlexCAN_Ip_EnableInterrupts_Privileged/44 
Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 (Can_43_FLEXCAN_Ipw_DisableControllerInterrupts) @0dbdf7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_Ipw_abIsInterruptEnabled/5 (read) Can_Ipw_abIsInterruptEnabled/5 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_SetErrorInt_Privileged/43 FlexCAN_Ip_DisableInterrupts_Privileged/39 
Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 (Can_43_FLEXCAN_Ipw_SetControllerToStopMode) @0dbdf460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_Ipw_abIsInterruptEnabled/5 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_SetStopMode_Privileged/40 FlexCAN_Ip_AbortTransfer/46 FlexCAN_Ip_AbortTransfer/46 FlexCAN_Ip_SetErrorInt_Privileged/43 FlexCAN_Ip_DisableInterrupts_Privileged/39 FlexCAN_Ip_EnterFreezeMode_Privileged/42 
Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 (Can_43_FLEXCAN_Ipw_SetControllerToStartMode) @0dbdf0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_Ipw_xStatus0/0 (addr) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 FlexCAN_Ip_RxFifo/37 FlexCAN_Ip_Receive/36 Can_Ipw_InitRx/23 Can_Ipw_InitBaudrate/8 FlexCAN_Ip_DisableInterrupts_Privileged/39 FlexCAN_Ip_Init_Privileged/38 
Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 (Can_43_FLEXCAN_Ipw_SetControlerErrorInit) @0dbd42a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Can_Ipw_abIsInterruptEnabled/5 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 
  Calls: FlexCAN_Ip_SetStartMode_Privileged/45 FlexCAN_Ip_EnableInterrupts_Privileged/44 FlexCAN_Ip_SetErrorInt_Privileged/43 
Can_43_FLEXCAN_Ipw_SetBaudrate/13 (Can_43_FLEXCAN_Ipw_SetBaudrate) @0dbd4c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_au16ControllerBaudRateSel/4 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_SetStopMode_Privileged/40 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/34 FlexCAN_Ip_SetTDCOffset_Privileged/33 FlexCAN_Ip_SetBitrateCbt_Privileged/32 FlexCAN_Ip_SetBitrate_Privileged/31 FlexCAN_Ip_EnterFreezeMode_Privileged/42 
Can_43_FLEXCAN_Ipw_DeInit/12 (Can_43_FLEXCAN_Ipw_DeInit) @0dbd4460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_Deinit_Privileged/41 
Can_43_FLEXCAN_Ipw_Init/11 (Can_43_FLEXCAN_Ipw_Init) @0dbd41c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Can_au16ControllerBaudRateSel/4 (write) Can_Ipw_xStatus0/0 (addr) Can_Ipw_abIsInterruptEnabled/5 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) Can_Ipw_au16MbIdxToObjIDMap/3 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Ip_SetStopMode_Privileged/40 Can_Ipw_InitRx/23 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/34 FlexCAN_Ip_SetTDCOffset_Privileged/33 FlexCAN_Ip_DisableInterrupts_Privileged/39 FlexCAN_Ip_Init_Privileged/38 
Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 (Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer) @0dbc8e00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Can_Ipw_au16MbIdxToObjIDMap/3 (read) Can_Ipw_xStatus0/0 (addr) Can_Ipw_xStatus0/0 (addr) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_ProcessHwObject/25 Can_43_FLEXCAN_Ipw_ProcessHwObject/25 
  Calls: FlexCAN_Ip_RxFifo/37 Can_Ipw_ParseData/6 Det_ReportRuntimeError/26 FlexCAN_Ip_Receive/36 Can_Ipw_ParseData/6 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer/9 (Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer) @0dbc8a80
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Can_Ipw_au16MbIdxToObjIDMap/3 (read) Can_Ipw_au16TxPduId/2 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_ProcessHwObject/25 
  Calls: CanIf_TxConfirmation/35 
Can_Ipw_InitBaudrate/8 (Can_Ipw_InitBaudrate) @0dbc87e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Can_au16ControllerBaudRateSel/4 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 
  Calls: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/34 FlexCAN_Ip_SetTDCOffset_Privileged/33 FlexCAN_Ip_SetBitrateCbt_Privileged/32 FlexCAN_Ip_SetBitrate_Privileged/31 
Can_Ipw_InitLegacyFifoFilter/7 (Can_Ipw_InitLegacyFifoFilter) @0dbc8000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_Ipw_InitRx/23 
  Calls: FlexCAN_Ip_ConfigRxFifo_Privileged/30 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/29 FlexCAN_Ip_SetRxIndividualMask_Privileged/28 
Can_Ipw_ParseData/6 (Can_Ipw_ParseData) @0da15ee0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 
  Calls: CanIf_RxIndication/27 Det_ReportRuntimeError/26 
Can_Ipw_abIsInterruptEnabled/5 (Can_Ipw_abIsInterruptEnabled) @0da11d38
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_SetControlerErrorInit/14 (read) Can_43_FLEXCAN_Ipw_SetControllerToStopMode/16 (read) Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 (read) Can_43_FLEXCAN_Ipw_DisableControllerInterrupts/17 (write) Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 (read) Can_43_FLEXCAN_Ipw_EnableControllerInterrupts/18 (write) 
  Availability: available
  Varpool flags:
Can_au16ControllerBaudRateSel/4 (Can_au16ControllerBaudRateSel) @0da11ca8
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: Can_Ipw_InitBaudrate/8 (read) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_SetBaudrate/13 (write) Can_43_FLEXCAN_Ipw_Write/22 (read) 
  Availability: available
  Varpool flags:
Can_Ipw_au16MbIdxToObjIDMap/3 (Can_Ipw_au16MbIdxToObjIDMap) @0da11c18
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer/9 (read) Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 (read) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_Init/11 (write) Can_43_FLEXCAN_Ipw_Init/11 (write) 
  Availability: available
  Varpool flags:
Can_Ipw_au16TxPduId/2 (Can_Ipw_au16TxPduId) @0da11af8
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer/9 (read) Can_43_FLEXCAN_Ipw_Write/22 (write) 
  Availability: available
  Varpool flags:
Can_Ipw_apxStatus/1 (Can_Ipw_apxStatus) @0da11a68
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Can_Ipw_xStatus0/0 (addr) 
  Referring: 
  Availability: available
  Varpool flags: initialized read-only const-value-known
Can_Ipw_xStatus0/0 (Can_Ipw_xStatus0) @0da11318
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: Can_Ipw_apxStatus/1 (addr) Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 (addr) Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer/10 (addr) Can_43_FLEXCAN_Ipw_Init/11 (addr) Can_43_FLEXCAN_Ipw_SetControllerToStartMode/15 (addr) 
  Availability: available
  Varpool flags:
Can_43_FLEXCAN_Ipw_ProcessHwObject (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, const struct Can_43_FLEXCAN_ConfigType * Can_pConfig, uint8 u8MbIdx, Can_43_FLEXCAN_MbType mbType)
{
  <bb 2> :
  switch (mbType) <default: <L3> [INV], case 0: <L1> [INV], case 1: <L2> [INV], case 3: <L0> [INV]>

  <bb 3> :
<L0>:
  _1 = Can_pConfig->Can_pHwObjectConfig;
  Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer (Can_pControllerConfig, _1, u8MbIdx);
  goto <bb 7>; [INV]

  <bb 4> :
<L1>:
  _2 = Can_pConfig->Can_pHwObjectConfig;
  Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer (Can_pControllerConfig, _2, u8MbIdx);
  goto <bb 7>; [INV]

  <bb 5> :
<L2>:
  _3 = Can_pConfig->Can_pHwObjectConfig;
  Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer (Can_pControllerConfig, _3, u8MbIdx);
  goto <bb 7>; [INV]

  <bb 6> :
<L3>:

  <bb 7> :
  return;

}


Can_43_FLEXCAN_Ipw_MainFunction_Mode (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, Can_ControllerStateType * Can_pControllerState)
{
  <bb 2> :
  _1 = *Can_pControllerState;
  if (_1 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _2 = Can_pControllerConfig->Can_u8ControllerOffset;
  _3 = FlexCAN_Ip_GetStartMode_Privileged (_2);
  _4 = ~_3;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  *Can_pControllerState = 2;
  _5 = Can_pControllerConfig->Can_u8AbstControllerID;
  CanIf_ControllerModeIndication (_5, 2);
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = *Can_pControllerState;
  if (_6 == 2)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _7 = Can_pControllerConfig->Can_u8ControllerOffset;
  _8 = FlexCAN_Ip_GetStartMode_Privileged (_7);
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  *Can_pControllerState = 1;
  _9 = Can_pControllerConfig->Can_u8AbstControllerID;
  CanIf_ControllerModeIndication (_9, 1);

  <bb 8> :
  return;

}


Can_Ipw_InitRx (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pController)
{
  struct Flexcan_Ip_DataInfoType DataInfo;
  const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
  uint8 u8HwObjRefIdx;

  <bb 2> :
  u8HwObjRefIdx = 0;
  _1 = Can_pController->Can_u8ControllerOffset;
  FlexCAN_Ip_SetRxMaskType_Privileged (_1, 1);
  u8HwObjRefIdx = 0;
  goto <bb 11>; [INV]

  <bb 3> :
  _2 = Can_pController->Can_ppHwObject;
  _3 = (unsigned int) u8HwObjRefIdx;
  _4 = _3 * 4;
  _5 = _2 + _4;
  Can_pHwObject = *_5;
  _6 = Can_pHwObject->Can_eReceiveType;
  if (_6 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  DataInfo.fd_enable = 0;
  DataInfo.data_length = 0;
  _7 = Can_pHwObject->Can_IdMessage;
  if (_7 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  DataInfo.msg_id_type = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  DataInfo.msg_id_type = 0;

  <bb 7> :
  _8 = Can_pController->Can_u8ControllerOffset;
  _9 = Can_pHwObject->Can_u8HwBufferIndex;
  _10 = Can_pHwObject->Can_pHwFilterConfig;
  _11 = _10->Can_u32HwFilterCode;
  FlexCAN_Ip_ConfigRxMb (_8, _9, &DataInfo, _11);
  _12 = Can_pController->Can_u8ControllerOffset;
  _13 = Can_pHwObject->Can_u8HwBufferIndex;
  _14 = Can_pHwObject->Can_pHwFilterConfig;
  _15 = _14->Can_u32HwFilterMask;
  FlexCAN_Ip_SetRxIndividualMask_Privileged (_12, _13, _15);

  <bb 8> :
  _16 = Can_pHwObject->Can_eReceiveType;
  if (_16 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  Can_Ipw_InitLegacyFifoFilter (Can_pController, Can_pHwObject);

  <bb 10> :
  u8HwObjRefIdx.10_17 = u8HwObjRefIdx;
  u8HwObjRefIdx = u8HwObjRefIdx.10_17 + 1;

  <bb 11> :
  _18 = Can_pController->Can_u8HwObjectRefCount;
  if (u8HwObjRefIdx < _18)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  DataInfo = {CLOBBER};
  return;

}


Can_43_FLEXCAN_Ipw_Write (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig, const struct Can_PduType * PduInfo)
{
  uint8 u8ObjIdx;
  struct Flexcan_Ip_DataInfoType DataInfo;
  Flexcan_Ip_StatusType eRetVal;
  Std_ReturnType iftmp.9;
  Std_ReturnType D.7070;

  <bb 2> :
  eRetVal = 1;
  u8ObjIdx = 0;
  DataInfo.msg_id_type = 0;
  DataInfo.data_length = 0;
  DataInfo.fd_padding = 0;
  DataInfo.fd_enable = 0;
  DataInfo.enable_brs = 0;
  DataInfo.is_remote = 0;
  DataInfo.is_polling = 0;
  _1 = Can_pHwObjectConfig->Can_eReceiveType;
  if (_1 == 3)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _2 = PduInfo->id;
  _3 = _2 >> 31;
  DataInfo.msg_id_type = _3;
  _4 = Can_pHwObjectConfig->Can_u8PayloadLength;
  _5 = PduInfo->length;
  if (_4 <= _5)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = Can_pHwObjectConfig->Can_u8PayloadLength;
  _7 = (long unsigned int) _6;
  DataInfo.data_length = _7;
  goto <bb 6>; [INV]

  <bb 5> :
  _8 = PduInfo->length;
  _9 = (long unsigned int) _8;
  DataInfo.data_length = _9;

  <bb 6> :
  _10 = Can_pHwObjectConfig->Can_u8PaddingValue;
  DataInfo.fd_padding = _10;
  _11 = PduInfo->id;
  _12 = _11 >> 30;
  _13 = (int) _12;
  _14 = _13 & 1;
  _15 = _14 != 0;
  DataInfo.fd_enable = _15;
  _16 = Can_pControllerConfig->Can_pBaudrateConfig;
  _17 = Can_pControllerConfig->Can_u8ControllerID;
  _18 = (int) _17;
  _19 = Can_au16ControllerBaudRateSel[_18];
  _20 = (unsigned int) _19;
  _21 = _20 * 22;
  _22 = _16 + _21;
  _23 = _22->Can_bBitRateSwitch;
  DataInfo.enable_brs = _23;
  DataInfo.is_remote = 0;
  _24 = Can_pHwObjectConfig->Can_bHwObjectUsesPolling;
  DataInfo.is_polling = _24;

  <bb 7> :
  _25 = Can_pControllerConfig->Can_u8ControllerOffset;
  _26 = Can_pHwObjectConfig->Can_u8HwBufferIndex;
  _27 = u8ObjIdx + _26;
  eRetVal = FlexCAN_Ip_GetTransferStatus (_25, _27);
  if (eRetVal == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _28 = Can_pControllerConfig->Can_u8ControllerID;
  _29 = (int) _28;
  _30 = Can_pHwObjectConfig->Can_u8HwBufferIndex;
  _31 = (int) _30;
  _32 = (int) u8ObjIdx;
  _33 = _31 + _32;
  _34 = PduInfo->swPduHandle;
  Can_Ipw_au16TxPduId[_29][_33] = _34;
  _35 = Can_pControllerConfig->Can_u8ControllerOffset;
  _36 = Can_pHwObjectConfig->Can_u8HwBufferIndex;
  _37 = u8ObjIdx + _36;
  _38 = PduInfo->id;
  _39 = PduInfo->sdu;
  eRetVal = FlexCAN_Ip_Send (_35, _37, &DataInfo, _38, _39);

  <bb 9> :
  u8ObjIdx.8_40 = u8ObjIdx;
  u8ObjIdx = u8ObjIdx.8_40 + 1;
  _41 = Can_pHwObjectConfig->Can_u8ObjectCount;
  if (u8ObjIdx < _41)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  if (eRetVal == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (eRetVal != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  if (eRetVal != 2)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  eRetVal = 1;

  <bb 14> :
  if (eRetVal != 2)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  iftmp.9 = (Std_ReturnType) eRetVal;
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.9 = 2;

  <bb 17> :
  D.7070 = iftmp.9;
  DataInfo = {CLOBBER};

  <bb 18> :
<L18>:
  return D.7070;

}


Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
  Std_ReturnType D.7056;

  <bb 2> :
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  _2 = FlexCAN_Ip_GetControllerRxErrorCounter (_1);
  *pValue = _2;
  D.7056 = 0;

  <bb 3> :
<L0>:
  return D.7056;

}


Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
  Std_ReturnType D.7054;

  <bb 2> :
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  _2 = FlexCAN_Ip_GetControllerTxErrorCounter (_1);
  *pValue = _2;
  D.7054 = 0;

  <bb 3> :
<L0>:
  return D.7054;

}


Can_43_FLEXCAN_Ipw_GetControllerErrorState (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
  uint32 Error;
  Std_ReturnType D.7052;

  <bb 2> :
  Error = 0;
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  Error = FlexCAN_Ip_GetErrorStatus (_1);
  _2 = Error >> 4;
  _3 = (unsigned char) _2;
  _4 = _3 & 3;
  *pValue = _4;
  D.7052 = 0;

  <bb 3> :
<L0>:
  return D.7052;

}


Can_43_FLEXCAN_Ipw_EnableControllerInterrupts (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  <bb 2> :
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = Can_Ipw_abIsInterruptEnabled[_2];
  _4 = ~_3;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _5 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_EnableInterrupts_Privileged (_5);
  _6 = Can_pControllerConfig->Can_bBusOffUsesPolling;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _8 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetErrorInt_Privileged (_8, 4, 1);

  <bb 5> :
  _9 = Can_pControllerConfig->Can_u8ControllerID;
  _10 = (int) _9;
  Can_Ipw_abIsInterruptEnabled[_10] = 1;

  <bb 6> :
  return;

}


Can_43_FLEXCAN_Ipw_DisableControllerInterrupts (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  <bb 2> :
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = Can_Ipw_abIsInterruptEnabled[_2];
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _4 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_DisableInterrupts_Privileged (_4);
  _5 = Can_pControllerConfig->Can_u8ControllerID;
  _6 = (int) _5;
  Can_Ipw_abIsInterruptEnabled[_6] = 0;
  _7 = Can_pControllerConfig->Can_bBusOffUsesPolling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _9 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetErrorInt_Privileged (_9, 4, 0);

  <bb 5> :
  return;

}


Can_43_FLEXCAN_Ipw_SetControllerToStopMode (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  uint8 u8Idx;
  const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
  uint8 u8HwObjRefIdx;
  Std_ReturnType eReturnValue;
  Std_ReturnType D.7042;

  <bb 2> :
  u8HwObjRefIdx = 0;
  u8Idx = 0;
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  _2 = FlexCAN_Ip_EnterFreezeMode_Privileged (_1);
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 3> :
  _3 = Can_pControllerConfig->Can_u8ControllerID;
  _4 = (int) _3;
  _5 = Can_Ipw_abIsInterruptEnabled[_4];
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _6 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_DisableInterrupts_Privileged (_6);
  _7 = Can_pControllerConfig->Can_bBusOffUsesPolling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetErrorInt_Privileged (_9, 4, 0);

  <bb 6> :
  u8HwObjRefIdx = 0;
  goto <bb 12>; [INV]

  <bb 7> :
  _10 = Can_pControllerConfig->Can_ppHwObject;
  _11 = (unsigned int) u8HwObjRefIdx;
  _12 = _11 * 4;
  _13 = _10 + _12;
  Can_pHwObject = *_13;
  _14 = Can_pHwObject->Can_eReceiveType;
  if (_14 == 3)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  u8Idx = 0;

  <bb 9> :
  _15 = Can_pControllerConfig->Can_u8ControllerOffset;
  _16 = Can_pHwObject->Can_u8HwBufferIndex;
  _17 = u8Idx + _16;
  FlexCAN_Ip_AbortTransfer (_15, _17);
  u8Idx.6_18 = u8Idx;
  u8Idx = u8Idx.6_18 + 1;
  _19 = Can_pHwObject->Can_u8ObjectCount;
  if (u8Idx < _19)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _20 = Can_pControllerConfig->Can_u8ControllerOffset;
  _21 = Can_pHwObject->Can_u8HwBufferIndex;
  FlexCAN_Ip_AbortTransfer (_20, _21);

  <bb 11> :
  u8HwObjRefIdx.7_22 = u8HwObjRefIdx;
  u8HwObjRefIdx = u8HwObjRefIdx.7_22 + 1;

  <bb 12> :
  _23 = Can_pControllerConfig->Can_u8HwObjectRefCount;
  if (u8HwObjRefIdx < _23)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _24 = Can_pControllerConfig->Can_u8ControllerOffset;
  _25 = FlexCAN_Ip_SetStopMode_Privileged (_24);
  eReturnValue = (Std_ReturnType) _25;
  goto <bb 15>; [INV]

  <bb 14> :
  eReturnValue = 1;

  <bb 15> :
  D.7042 = eReturnValue;

  <bb 16> :
<L15>:
  return D.7042;

}


Can_43_FLEXCAN_Ipw_SetControllerToStartMode (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  Flexcan_Ip_StatusType eRetVal;
  const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
  uint8 u8HwObjRefIdx;
  Std_ReturnType D.7030;

  <bb 2> :
  u8HwObjRefIdx = 0;
  Can_pHwObject = 0B;
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  _2 = Can_pControllerConfig->Can_u8ControllerID;
  _3 = (int) _2;
  _4 = &Can_Ipw_xStatus0;
  _5 = Can_pControllerConfig->HwChannelIpConfig;
  _6 = _5->pFlexcanIpHwConfig;
  eRetVal = FlexCAN_Ip_Init_Privileged (_1, _4, _6);
  if (eRetVal == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 3> :
  _7 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_DisableInterrupts_Privileged (_7);
  Can_Ipw_InitBaudrate (Can_pControllerConfig);
  Can_Ipw_InitRx (Can_pControllerConfig);
  u8HwObjRefIdx = 0;
  goto <bb 10>; [INV]

  <bb 4> :
  _8 = Can_pControllerConfig->Can_ppHwObject;
  _9 = (unsigned int) u8HwObjRefIdx;
  _10 = _9 * 4;
  _11 = _8 + _10;
  Can_pHwObject = *_11;
  _12 = Can_pHwObject->Can_bHwObjectUsesPolling;
  _13 = ~_12;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _14 = Can_pHwObject->Can_eReceiveType;
  switch (_14) <default: <L6> [INV], case 0: <L3> [INV], case 1 ... 2: <L4> [INV]>

  <bb 6> :
<L3>:
  _15 = Can_pControllerConfig->Can_u8ControllerOffset;
  _16 = Can_pHwObject->Can_u8HwBufferIndex;
  _17 = Can_pHwObject->Can_bHwObjectUsesPolling;
  FlexCAN_Ip_Receive (_15, _16, 0B, _17);
  goto <bb 9>; [INV]

  <bb 7> :
<L4>:
  _18 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_RxFifo (_18, 0B);
  goto <bb 9>; [INV]

  <bb 8> :
<L6>:

  <bb 9> :
  u8HwObjRefIdx.5_19 = u8HwObjRefIdx;
  u8HwObjRefIdx = u8HwObjRefIdx.5_19 + 1;

  <bb 10> :
  _20 = Can_pControllerConfig->Can_u8HwObjectRefCount;
  if (u8HwObjRefIdx < _20)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _21 = Can_43_FLEXCAN_Ipw_SetControlerErrorInit (Can_pControllerConfig);
  _22 = _21 != 0;
  eRetVal = (Flexcan_Ip_StatusType) _22;

  <bb 12> :
  D.7030 = (Std_ReturnType) eRetVal;

  <bb 13> :
<L12>:
  return D.7030;

}


Can_43_FLEXCAN_Ipw_SetControlerErrorInit (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  Flexcan_Ip_StatusType eRetVal;
  Std_ReturnType D.7024;

  <bb 2> :
  eRetVal = 0;
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = Can_Ipw_abIsInterruptEnabled[_2];
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _4 = Can_pControllerConfig->Can_bBusOffUsesPolling;
  _5 = ~_4;
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetErrorInt_Privileged (_6, 4, 1);

  <bb 5> :
  _7 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_EnableInterrupts_Privileged (_7);

  <bb 6> :
  _8 = Can_pControllerConfig->Can_u8ControllerOffset;
  eRetVal = FlexCAN_Ip_SetStartMode_Privileged (_8);
  D.7024 = (Std_ReturnType) eRetVal;

  <bb 7> :
<L4>:
  return D.7024;

}


Can_43_FLEXCAN_Ipw_SetBaudrate (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint16 BaudRateConfigID)
{
  struct Flexcan_Ip_TimeSegmentType FlexCANTimeSeg;
  Flexcan_Ip_StatusType eRetVal;
  Std_ReturnType D.7017;

  <bb 2> :
  eRetVal = 1;
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  eRetVal = FlexCAN_Ip_EnterFreezeMode_Privileged (_1);
  if (eRetVal == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _2 = Can_pControllerConfig->Can_pBaudrateConfig;
  _3 = (unsigned int) BaudRateConfigID;
  _4 = _3 * 22;
  _5 = _2 + _4;
  _6 = _5->Can_NominalBitRate.Can_u16Prescaler;
  _7 = (long unsigned int) _6;
  FlexCANTimeSeg.preDivider = _7;
  _8 = Can_pControllerConfig->Can_pBaudrateConfig;
  _9 = (unsigned int) BaudRateConfigID;
  _10 = _9 * 22;
  _11 = _8 + _10;
  _12 = _11->Can_NominalBitRate.Can_u8PropSeg;
  _13 = (long unsigned int) _12;
  FlexCANTimeSeg.propSeg = _13;
  _14 = Can_pControllerConfig->Can_pBaudrateConfig;
  _15 = (unsigned int) BaudRateConfigID;
  _16 = _15 * 22;
  _17 = _14 + _16;
  _18 = _17->Can_NominalBitRate.Can_u8PhaseSeg1;
  _19 = (long unsigned int) _18;
  FlexCANTimeSeg.phaseSeg1 = _19;
  _20 = Can_pControllerConfig->Can_pBaudrateConfig;
  _21 = (unsigned int) BaudRateConfigID;
  _22 = _21 * 22;
  _23 = _20 + _22;
  _24 = _23->Can_NominalBitRate.Can_u8PhaseSeg2;
  _25 = (long unsigned int) _24;
  FlexCANTimeSeg.phaseSeg2 = _25;
  _26 = Can_pControllerConfig->Can_pBaudrateConfig;
  _27 = (unsigned int) BaudRateConfigID;
  _28 = _27 * 22;
  _29 = _26 + _28;
  _30 = _29->Can_NominalBitRate.Can_u8ResyncJumpWidth;
  _31 = (long unsigned int) _30;
  FlexCANTimeSeg.rJumpwidth = _31;
  _32 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetBitrate_Privileged (_32, &FlexCANTimeSeg, 0);
  _33 = Can_pControllerConfig->Can_pBaudrateConfig;
  _34 = (unsigned int) BaudRateConfigID;
  _35 = _34 * 22;
  _36 = _33 + _35;
  _37 = _36->Can_DataBitRate.Can_u16Prescaler;
  _38 = (long unsigned int) _37;
  FlexCANTimeSeg.preDivider = _38;
  _39 = Can_pControllerConfig->Can_pBaudrateConfig;
  _40 = (unsigned int) BaudRateConfigID;
  _41 = _40 * 22;
  _42 = _39 + _41;
  _43 = _42->Can_bFDFrame;
  if (_43 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _44 = Can_pControllerConfig->Can_pBaudrateConfig;
  _45 = (unsigned int) BaudRateConfigID;
  _46 = _45 * 22;
  _47 = _44 + _46;
  _48 = _47->Can_DataBitRate.Can_u8PropSeg;
  _49 = (long unsigned int) _48;
  FlexCANTimeSeg.propSeg = _49;
  _50 = Can_pControllerConfig->Can_pBaudrateConfig;
  _51 = (unsigned int) BaudRateConfigID;
  _52 = _51 * 22;
  _53 = _50 + _52;
  _54 = _53->Can_DataBitRate.Can_u8PhaseSeg1;
  _55 = (long unsigned int) _54;
  FlexCANTimeSeg.phaseSeg1 = _55;
  _56 = Can_pControllerConfig->Can_pBaudrateConfig;
  _57 = (unsigned int) BaudRateConfigID;
  _58 = _57 * 22;
  _59 = _56 + _58;
  _60 = _59->Can_DataBitRate.Can_u8PhaseSeg2;
  _61 = (long unsigned int) _60;
  FlexCANTimeSeg.phaseSeg2 = _61;
  _62 = Can_pControllerConfig->Can_pBaudrateConfig;
  _63 = (unsigned int) BaudRateConfigID;
  _64 = _63 * 22;
  _65 = _62 + _64;
  _66 = _65->Can_DataBitRate.Can_u8ResyncJumpWidth;
  _67 = (long unsigned int) _66;
  FlexCANTimeSeg.rJumpwidth = _67;
  _68 = Can_pControllerConfig->Can_u8ControllerOffset;
  _69 = Can_pControllerConfig->Can_pBaudrateConfig;
  _70 = (unsigned int) BaudRateConfigID;
  _71 = _70 * 22;
  _72 = _69 + _71;
  _73 = _72->Can_bBitRateSwitch;
  FlexCAN_Ip_SetBitrateCbt_Privileged (_68, &FlexCANTimeSeg, _73);
  _74 = Can_pControllerConfig->Can_u8ControllerOffset;
  _75 = Can_pControllerConfig->Can_pBaudrateConfig;
  _76 = (unsigned int) BaudRateConfigID;
  _77 = _76 * 22;
  _78 = _75 + _77;
  _79 = _78->Can_bTrcvDelayEnable;
  _80 = Can_pControllerConfig->Can_pBaudrateConfig;
  _81 = (unsigned int) BaudRateConfigID;
  _82 = _81 * 22;
  _83 = _80 + _82;
  _84 = _83->Can_u8TrcvDelayCompOffset;
  FlexCAN_Ip_SetTDCOffset_Privileged (_74, _79, _84);

  <bb 5> :
  _85 = Can_pControllerConfig->Can_u8ControllerOffset;
  _86 = Can_pControllerConfig->Can_pBaudrateConfig;
  _87 = (unsigned int) BaudRateConfigID;
  _88 = _87 * 22;
  _89 = _86 + _88;
  _90 = _89->Can_u8TxArbitrationStartDelay;
  FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (_85, _90);
  _91 = Can_pControllerConfig->Can_u8ControllerOffset;
  eRetVal = FlexCAN_Ip_SetStopMode_Privileged (_91);
  if (eRetVal == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _92 = Can_pControllerConfig->Can_u8ControllerID;
  _93 = (int) _92;
  Can_au16ControllerBaudRateSel[_93] = BaudRateConfigID;

  <bb 7> :
  _94 = eRetVal != 0;
  D.7017 = (Std_ReturnType) _94;
  FlexCANTimeSeg = {CLOBBER};

  <bb 8> :
<L7>:
  return D.7017;

}


Can_43_FLEXCAN_Ipw_DeInit (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  <bb 2> :
  _1 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_Deinit_Privileged (_1);
  return;

}


Can_43_FLEXCAN_Ipw_Init (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
  uint8 u8HwBufferCount;
  const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
  uint8 u8ObjIdx;
  uint8 u8HwObjRefIdx;
  Std_ReturnType eRetVal;
  Std_ReturnType D.7009;

  <bb 2> :
  eRetVal = 1;
  u8HwObjRefIdx = 0;
  u8ObjIdx = 0;
  Can_pHwObject = 0B;
  u8HwBufferCount = 0;
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = Can_pControllerConfig->Can_u16DefaultBaudrateID;
  Can_au16ControllerBaudRateSel[_2] = _3;
  _4 = Can_pControllerConfig->Can_u8ControllerOffset;
  _5 = Can_pControllerConfig->Can_u8ControllerID;
  _6 = (int) _5;
  _7 = &Can_Ipw_xStatus0;
  _8 = Can_pControllerConfig->HwChannelIpConfig;
  _9 = _8->pFlexcanIpHwConfig;
  _10 = FlexCAN_Ip_Init_Privileged (_4, _7, _9);
  eRetVal = (Std_ReturnType) _10;
  _11 = Can_pControllerConfig->Can_u8ControllerID;
  _12 = (int) _11;
  Can_Ipw_abIsInterruptEnabled[_12] = 1;
  if (eRetVal == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _13 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_DisableInterrupts_Privileged (_13);
  _14 = Can_pControllerConfig->Can_pBaudrateConfig;
  _15 = Can_pControllerConfig->Can_u16DefaultBaudrateID;
  _16 = (unsigned int) _15;
  _17 = _16 * 22;
  _18 = _14 + _17;
  _19 = _18->Can_bFDFrame;
  if (_19 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _20 = Can_pControllerConfig->Can_u8ControllerOffset;
  _21 = Can_pControllerConfig->Can_pBaudrateConfig;
  _22 = Can_pControllerConfig->Can_u16DefaultBaudrateID;
  _23 = (unsigned int) _22;
  _24 = _23 * 22;
  _25 = _21 + _24;
  _26 = _25->Can_bTrcvDelayEnable;
  _27 = Can_pControllerConfig->Can_pBaudrateConfig;
  _28 = Can_pControllerConfig->Can_u16DefaultBaudrateID;
  _29 = (unsigned int) _28;
  _30 = _29 * 22;
  _31 = _27 + _30;
  _32 = _31->Can_u8TrcvDelayCompOffset;
  FlexCAN_Ip_SetTDCOffset_Privileged (_20, _26, _32);

  <bb 5> :
  _33 = Can_pControllerConfig->Can_u8ControllerOffset;
  _34 = Can_pControllerConfig->Can_pBaudrateConfig;
  _35 = Can_pControllerConfig->Can_u16DefaultBaudrateID;
  _36 = (unsigned int) _35;
  _37 = _36 * 22;
  _38 = _34 + _37;
  _39 = _38->Can_u8TxArbitrationStartDelay;
  FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (_33, _39);
  Can_Ipw_InitRx (Can_pControllerConfig);

  <bb 6> :
  u8HwBufferCount = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _40 = Can_pControllerConfig->Can_u8ControllerID;
  _41 = (int) _40;
  _42 = (int) u8HwBufferCount;
  Can_Ipw_au16MbIdxToObjIDMap[_41][_42] = 65535;
  u8HwBufferCount.2_43 = u8HwBufferCount;
  u8HwBufferCount = u8HwBufferCount.2_43 + 1;

  <bb 8> :
  if (u8HwBufferCount <= 31)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  u8HwObjRefIdx = 0;
  goto <bb 19>; [INV]

  <bb 10> :
  _44 = Can_pControllerConfig->Can_ppHwObject;
  _45 = (unsigned int) u8HwObjRefIdx;
  _46 = _45 * 4;
  _47 = _44 + _46;
  Can_pHwObject = *_47;
  _48 = Can_pHwObject->Can_eReceiveType;
  switch (_48) <default: <L14> [INV], case 0: <L12> [INV], case 1: <L13> [INV], case 3: <L8> [INV]>

  <bb 11> :
<L8>:
  u8ObjIdx = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  _49 = Can_pControllerConfig->Can_u8ControllerID;
  _50 = (int) _49;
  _51 = Can_pHwObject->Can_u8HwBufferIndex;
  _52 = (int) _51;
  _53 = (int) u8ObjIdx;
  _54 = _52 + _53;
  _55 = Can_pHwObject->Can_HwObjectID;
  Can_Ipw_au16MbIdxToObjIDMap[_50][_54] = _55;
  u8ObjIdx.3_56 = u8ObjIdx;
  u8ObjIdx = u8ObjIdx.3_56 + 1;

  <bb 13> :
  _57 = Can_pHwObject->Can_u8ObjectCount;
  if (u8ObjIdx < _57)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  goto <bb 18>; [INV]

  <bb 15> :
<L12>:
  _58 = Can_pControllerConfig->Can_u8ControllerID;
  _59 = (int) _58;
  _60 = Can_pHwObject->Can_u8HwBufferIndex;
  _61 = (int) _60;
  _62 = Can_pHwObject->Can_HwObjectID;
  Can_Ipw_au16MbIdxToObjIDMap[_59][_61] = _62;
  goto <bb 18>; [INV]

  <bb 16> :
<L13>:
  _63 = Can_pControllerConfig->Can_u8ControllerID;
  _64 = (int) _63;
  _65 = Can_pHwObject->Can_u8HwBufferIndex;
  _66 = (int) _65;
  _67 = Can_pHwObject->Can_HwObjectID;
  Can_Ipw_au16MbIdxToObjIDMap[_64][_66] = _67;
  _68 = Can_pControllerConfig->Can_u8ControllerID;
  _69 = (int) _68;
  _70 = Can_pHwObject->Can_HwObjectID;
  Can_Ipw_au16MbIdxToObjIDMap[_69][6] = _70;
  _71 = Can_pControllerConfig->Can_u8ControllerID;
  _72 = (int) _71;
  _73 = Can_pHwObject->Can_HwObjectID;
  Can_Ipw_au16MbIdxToObjIDMap[_72][7] = _73;
  goto <bb 18>; [INV]

  <bb 17> :
<L14>:

  <bb 18> :
  u8HwObjRefIdx.4_74 = u8HwObjRefIdx;
  u8HwObjRefIdx = u8HwObjRefIdx.4_74 + 1;

  <bb 19> :
  _75 = Can_pControllerConfig->Can_u8HwObjectRefCount;
  if (u8HwObjRefIdx < _75)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _76 = Can_pControllerConfig->Can_u8ControllerOffset;
  _77 = FlexCAN_Ip_SetStopMode_Privileged (_76);
  eRetVal = (Std_ReturnType) _77;
  D.7009 = eRetVal;

  <bb 21> :
<L18>:
  return D.7009;

}


Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig, uint8 u8MbIdx)
{
  struct Flexcan_Ip_MsgBuffType * pReceivedDataBuffer;
  const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
  struct PduInfoType CanIf_PduInfo;
  struct Can_HwType CanIf_Mailbox;
  Can_HwHandleType u8HwObjectID;

  <bb 2> :
  u8HwObjectID = 0;
  Can_pHwObject = 0B;
  pReceivedDataBuffer = 0B;
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = (int) u8MbIdx;
  u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[_2][_3];
  if (u8HwObjectID != 65535)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 3> :
  _4 = (unsigned int) u8HwObjectID;
  _5 = _4 * 36;
  _6 = Can_pHwObjectConfig + _5;
  _7 = _6->Can_bHwObjectUsesPolling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 4> :
  _9 = (unsigned int) u8HwObjectID;
  _10 = _9 * 36;
  Can_pHwObject = Can_pHwObjectConfig + _10;
  _11 = Can_pHwObject->Can_eReceiveType;
  if (_11 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _12 = Can_pControllerConfig->Can_u8ControllerID;
  _13 = (int) _12;
  _14 = &Can_Ipw_xStatus0;
  _15 = Can_pHwObject->Can_u8HwBufferIndex;
  _16 = (int) _15;
  pReceivedDataBuffer = _14->mbs[_16].pMBmessage;
  Can_Ipw_ParseData (&CanIf_Mailbox, &CanIf_PduInfo, pReceivedDataBuffer, Can_pControllerConfig, Can_pHwObject);
  _17 = Can_pControllerConfig->Can_u8ControllerOffset;
  _18 = Can_pHwObject->Can_u8HwBufferIndex;
  _19 = Can_pHwObject->Can_bHwObjectUsesPolling;
  FlexCAN_Ip_Receive (_17, _18, 0B, _19);
  goto <bb 14>; [INV]

  <bb 6> :
  _20 = Can_pHwObject->Can_eReceiveType;
  if (_20 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 7> :
  if (u8MbIdx == 7)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  Det_ReportRuntimeError (80, 0, 8, 1);
  _21 = Can_pControllerConfig->Can_pLegacyFiFoOvfNotif;
  if (_21 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 9> :
  _22 = Can_pControllerConfig->Can_pLegacyFiFoOvfNotif;
  _22 ();
  goto <bb 14>; [INV]

  <bb 10> :
  if (u8MbIdx == 6)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  _23 = Can_pControllerConfig->Can_pLegacyFiFoWarnNotif;
  if (_23 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  _24 = Can_pControllerConfig->Can_pLegacyFiFoWarnNotif;
  _24 ();
  goto <bb 14>; [INV]

  <bb 13> :
  _25 = Can_pControllerConfig->Can_u8ControllerID;
  _26 = (int) _25;
  _27 = &Can_Ipw_xStatus0;
  _28 = Can_pHwObject->Can_u8HwBufferIndex;
  _29 = (int) _28;
  pReceivedDataBuffer = _27->mbs[_29].pMBmessage;
  Can_Ipw_ParseData (&CanIf_Mailbox, &CanIf_PduInfo, pReceivedDataBuffer, Can_pControllerConfig, Can_pHwObject);
  _30 = Can_pControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_RxFifo (_30, 0B);

  <bb 14> :
  CanIf_Mailbox = {CLOBBER};
  CanIf_PduInfo = {CLOBBER};
  return;

}


Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig, uint8 u8MbIdx)
{
  Can_HwHandleType u8HwObjectID;

  <bb 2> :
  u8HwObjectID = 0;
  _1 = Can_pControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  _3 = (int) u8MbIdx;
  u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[_2][_3];
  if (u8HwObjectID != 65535)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _4 = (unsigned int) u8HwObjectID;
  _5 = _4 * 36;
  _6 = Can_pHwObjectConfig + _5;
  _7 = _6->Can_bHwObjectUsesPolling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _9 = (unsigned int) u8HwObjectID;
  _10 = _9 * 36;
  _11 = Can_pHwObjectConfig + _10;
  _12 = _11->Can_eReceiveType;
  if (_12 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _13 = Can_pControllerConfig->Can_u8ControllerID;
  _14 = (int) _13;
  _15 = (int) u8MbIdx;
  _16 = Can_Ipw_au16TxPduId[_14][_15];
  CanIf_TxConfirmation (_16);

  <bb 6> :
  return;

}


Can_Ipw_InitBaudrate (const struct Can_43_FLEXCAN_ControllerConfigType * ControllerConfig)
{
  struct Flexcan_Ip_TimeSegmentType FlexCANTimeSeg;
  uint16 BaudRateConfigID;

  <bb 2> :
  _1 = ControllerConfig->Can_u8ControllerID;
  _2 = (int) _1;
  BaudRateConfigID = Can_au16ControllerBaudRateSel[_2];
  _3 = ControllerConfig->Can_pBaudrateConfig;
  _4 = (unsigned int) BaudRateConfigID;
  _5 = _4 * 22;
  _6 = _3 + _5;
  _7 = _6->Can_NominalBitRate.Can_u16Prescaler;
  _8 = (long unsigned int) _7;
  FlexCANTimeSeg.preDivider = _8;
  _9 = ControllerConfig->Can_pBaudrateConfig;
  _10 = (unsigned int) BaudRateConfigID;
  _11 = _10 * 22;
  _12 = _9 + _11;
  _13 = _12->Can_NominalBitRate.Can_u8PropSeg;
  _14 = (long unsigned int) _13;
  FlexCANTimeSeg.propSeg = _14;
  _15 = ControllerConfig->Can_pBaudrateConfig;
  _16 = (unsigned int) BaudRateConfigID;
  _17 = _16 * 22;
  _18 = _15 + _17;
  _19 = _18->Can_NominalBitRate.Can_u8PhaseSeg1;
  _20 = (long unsigned int) _19;
  FlexCANTimeSeg.phaseSeg1 = _20;
  _21 = ControllerConfig->Can_pBaudrateConfig;
  _22 = (unsigned int) BaudRateConfigID;
  _23 = _22 * 22;
  _24 = _21 + _23;
  _25 = _24->Can_NominalBitRate.Can_u8PhaseSeg2;
  _26 = (long unsigned int) _25;
  FlexCANTimeSeg.phaseSeg2 = _26;
  _27 = ControllerConfig->Can_pBaudrateConfig;
  _28 = (unsigned int) BaudRateConfigID;
  _29 = _28 * 22;
  _30 = _27 + _29;
  _31 = _30->Can_NominalBitRate.Can_u8ResyncJumpWidth;
  _32 = (long unsigned int) _31;
  FlexCANTimeSeg.rJumpwidth = _32;
  _33 = ControllerConfig->Can_u8ControllerOffset;
  FlexCAN_Ip_SetBitrate_Privileged (_33, &FlexCANTimeSeg, 0);
  _34 = ControllerConfig->Can_pBaudrateConfig;
  _35 = (unsigned int) BaudRateConfigID;
  _36 = _35 * 22;
  _37 = _34 + _36;
  _38 = _37->Can_bFDFrame;
  if (_38 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _39 = ControllerConfig->Can_pBaudrateConfig;
  _40 = (unsigned int) BaudRateConfigID;
  _41 = _40 * 22;
  _42 = _39 + _41;
  _43 = _42->Can_DataBitRate.Can_u16Prescaler;
  _44 = (long unsigned int) _43;
  FlexCANTimeSeg.preDivider = _44;
  _45 = ControllerConfig->Can_pBaudrateConfig;
  _46 = (unsigned int) BaudRateConfigID;
  _47 = _46 * 22;
  _48 = _45 + _47;
  _49 = _48->Can_DataBitRate.Can_u8PropSeg;
  _50 = (long unsigned int) _49;
  FlexCANTimeSeg.propSeg = _50;
  _51 = ControllerConfig->Can_pBaudrateConfig;
  _52 = (unsigned int) BaudRateConfigID;
  _53 = _52 * 22;
  _54 = _51 + _53;
  _55 = _54->Can_DataBitRate.Can_u8PhaseSeg1;
  _56 = (long unsigned int) _55;
  FlexCANTimeSeg.phaseSeg1 = _56;
  _57 = ControllerConfig->Can_pBaudrateConfig;
  _58 = (unsigned int) BaudRateConfigID;
  _59 = _58 * 22;
  _60 = _57 + _59;
  _61 = _60->Can_DataBitRate.Can_u8PhaseSeg2;
  _62 = (long unsigned int) _61;
  FlexCANTimeSeg.phaseSeg2 = _62;
  _63 = ControllerConfig->Can_pBaudrateConfig;
  _64 = (unsigned int) BaudRateConfigID;
  _65 = _64 * 22;
  _66 = _63 + _65;
  _67 = _66->Can_DataBitRate.Can_u8ResyncJumpWidth;
  _68 = (long unsigned int) _67;
  FlexCANTimeSeg.rJumpwidth = _68;
  _69 = ControllerConfig->Can_u8ControllerOffset;
  _70 = ControllerConfig->Can_pBaudrateConfig;
  _71 = (unsigned int) BaudRateConfigID;
  _72 = _71 * 22;
  _73 = _70 + _72;
  _74 = _73->Can_bBitRateSwitch;
  FlexCAN_Ip_SetBitrateCbt_Privileged (_69, &FlexCANTimeSeg, _74);
  _75 = ControllerConfig->Can_u8ControllerOffset;
  _76 = ControllerConfig->Can_pBaudrateConfig;
  _77 = (unsigned int) BaudRateConfigID;
  _78 = _77 * 22;
  _79 = _76 + _78;
  _80 = _79->Can_bTrcvDelayEnable;
  _81 = ControllerConfig->Can_pBaudrateConfig;
  _82 = (unsigned int) BaudRateConfigID;
  _83 = _82 * 22;
  _84 = _81 + _83;
  _85 = _84->Can_u8TrcvDelayCompOffset;
  FlexCAN_Ip_SetTDCOffset_Privileged (_75, _80, _85);

  <bb 4> :
  _86 = ControllerConfig->Can_u8ControllerOffset;
  _87 = ControllerConfig->Can_pBaudrateConfig;
  _88 = (unsigned int) BaudRateConfigID;
  _89 = _88 * 22;
  _90 = _87 + _89;
  _91 = _90->Can_u8TxArbitrationStartDelay;
  FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (_86, _91);
  FlexCANTimeSeg = {CLOBBER};
  return;

}


Can_Ipw_InitLegacyFifoFilter (const struct Can_43_FLEXCAN_ControllerConfigType * Can_pController, const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject)
{
  struct Flexcan_Ip_IdTableType RxFifoFilters[128];
  Flexcan_Ip_RxFifoIdElementFormatType eElementFormat;
  uint8 u8FiFoFilterIndvCount;
  uint32 u32HwFilterMask;
  uint8 u8HwFilterCount;
  uint8 u8FilterIdx;

  <bb 2> :
  u8FilterIdx = 0;
  u8HwFilterCount = 0;
  u32HwFilterMask = 0;
  u8FiFoFilterIndvCount = 0;
  eElementFormat = 0;
  _1 = Can_pHwObject->Can_u8HwFilterCount;
  _2 = _1 / 4;
  _3 = (unsigned int) _2;
  _4 = _3 + 6;
  if (_4 <= 32)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = Can_pHwObject->Can_u8HwFilterCount;
  _6 = _5 / 4;
  u8FiFoFilterIndvCount = _6 + 6;
  goto <bb 5>; [INV]

  <bb 4> :
  u8FiFoFilterIndvCount = 32;

  <bb 5> :
  u8FilterIdx = 0;
  goto <bb 18>; [INV]

  <bb 6> :
  _7 = Can_pController->Can_eLegacyAcceptanceMode;
  if (_7 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  u8HwFilterCount = Can_pHwObject->Can_u8HwFilterCount;
  u32HwFilterMask = 3221225472;
  eElementFormat = 0;
  _8 = Can_pHwObject->Can_IdMessage;
  if (_8 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _9 = Can_pHwObject->Can_pHwFilterConfig;
  _10 = (unsigned int) u8FilterIdx;
  _11 = _10 * 8;
  _12 = _9 + _11;
  _13 = _12->Can_u32HwFilterMask;
  _14 = _13 << 1;
  u32HwFilterMask = u32HwFilterMask | _14;
  goto <bb 17>; [INV]

  <bb 9> :
  _15 = Can_pHwObject->Can_pHwFilterConfig;
  _16 = (unsigned int) u8FilterIdx;
  _17 = _16 * 8;
  _18 = _15 + _17;
  _19 = _18->Can_u32HwFilterMask;
  _20 = _19 << 19;
  u32HwFilterMask = u32HwFilterMask | _20;
  goto <bb 17>; [INV]

  <bb 10> :
  _21 = Can_pController->Can_eLegacyAcceptanceMode;
  if (_21 == 1)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _22 = Can_pHwObject->Can_u8HwFilterCount;
  u8HwFilterCount = _22 * 2;
  u32HwFilterMask = 3221274624;
  eElementFormat = 1;
  _23 = Can_pHwObject->Can_IdMessage;
  if (_23 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _24 = Can_pHwObject->Can_pHwFilterConfig;
  _25 = (unsigned int) u8FilterIdx;
  _26 = _25 * 16;
  _27 = _24 + _26;
  _28 = _27->Can_u32HwFilterMask;
  _29 = _28 >> 15;
  _30 = _29 << 16;
  u32HwFilterMask = u32HwFilterMask | _30;
  _31 = Can_pHwObject->Can_pHwFilterConfig;
  _32 = (unsigned int) u8FilterIdx;
  _33 = _32 * 16;
  _34 = _33 + 8;
  _35 = _31 + _34;
  _36 = _35->Can_u32HwFilterMask;
  _37 = _36 >> 15;
  u32HwFilterMask = u32HwFilterMask | _37;
  goto <bb 17>; [INV]

  <bb 13> :
  _38 = Can_pHwObject->Can_pHwFilterConfig;
  _39 = (unsigned int) u8FilterIdx;
  _40 = _39 * 16;
  _41 = _38 + _40;
  _42 = _41->Can_u32HwFilterMask;
  _43 = _42 << 19;
  u32HwFilterMask = u32HwFilterMask | _43;
  _44 = Can_pHwObject->Can_pHwFilterConfig;
  _45 = (unsigned int) u8FilterIdx;
  _46 = _45 * 16;
  _47 = _46 + 8;
  _48 = _44 + _47;
  _49 = _48->Can_u32HwFilterMask;
  _50 = _49 << 3;
  u32HwFilterMask = u32HwFilterMask | _50;
  goto <bb 17>; [INV]

  <bb 14> :
  _51 = Can_pHwObject->Can_u8HwFilterCount;
  u8HwFilterCount = _51 * 4;
  u32HwFilterMask = 0;
  eElementFormat = 2;
  _52 = Can_pHwObject->Can_IdMessage;
  if (_52 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _53 = Can_pHwObject->Can_pHwFilterConfig;
  _54 = (unsigned int) u8FilterIdx;
  _55 = _54 * 32;
  _56 = _53 + _55;
  _57 = _56->Can_u32HwFilterMask;
  _58 = _57 >> 21;
  _59 = _58 << 24;
  u32HwFilterMask = u32HwFilterMask | _59;
  _60 = Can_pHwObject->Can_pHwFilterConfig;
  _61 = (unsigned int) u8FilterIdx;
  _62 = _61 * 32;
  _63 = _62 + 8;
  _64 = _60 + _63;
  _65 = _64->Can_u32HwFilterMask;
  _66 = _65 >> 21;
  _67 = _66 << 16;
  u32HwFilterMask = u32HwFilterMask | _67;
  _68 = Can_pHwObject->Can_pHwFilterConfig;
  _69 = (unsigned int) u8FilterIdx;
  _70 = _69 * 32;
  _71 = _70 + 16;
  _72 = _68 + _71;
  _73 = _72->Can_u32HwFilterMask;
  _74 = _73 >> 21;
  _75 = _74 << 8;
  u32HwFilterMask = u32HwFilterMask | _75;
  _76 = Can_pHwObject->Can_pHwFilterConfig;
  _77 = (unsigned int) u8FilterIdx;
  _78 = _77 * 32;
  _79 = _78 + 24;
  _80 = _76 + _79;
  _81 = _80->Can_u32HwFilterMask;
  _82 = _81 >> 21;
  u32HwFilterMask = u32HwFilterMask | _82;
  goto <bb 17>; [INV]

  <bb 16> :
  _83 = Can_pHwObject->Can_pHwFilterConfig;
  _84 = (unsigned int) u8FilterIdx;
  _85 = _84 * 32;
  _86 = _83 + _85;
  _87 = _86->Can_u32HwFilterMask;
  _88 = _87 >> 3;
  _89 = _88 << 24;
  u32HwFilterMask = u32HwFilterMask | _89;
  _90 = Can_pHwObject->Can_pHwFilterConfig;
  _91 = (unsigned int) u8FilterIdx;
  _92 = _91 * 32;
  _93 = _92 + 8;
  _94 = _90 + _93;
  _95 = _94->Can_u32HwFilterMask;
  _96 = _95 >> 3;
  _97 = _96 << 16;
  u32HwFilterMask = u32HwFilterMask | _97;
  _98 = Can_pHwObject->Can_pHwFilterConfig;
  _99 = (unsigned int) u8FilterIdx;
  _100 = _99 * 32;
  _101 = _100 + 16;
  _102 = _98 + _101;
  _103 = _102->Can_u32HwFilterMask;
  _104 = _103 >> 3;
  _105 = _104 << 8;
  u32HwFilterMask = u32HwFilterMask | _105;
  _106 = Can_pHwObject->Can_pHwFilterConfig;
  _107 = (unsigned int) u8FilterIdx;
  _108 = _107 * 32;
  _109 = _108 + 24;
  _110 = _106 + _109;
  _111 = _110->Can_u32HwFilterMask;
  _112 = _111 >> 3;
  u32HwFilterMask = u32HwFilterMask | _112;

  <bb 17> :
  _113 = Can_pController->Can_u8ControllerOffset;
  FlexCAN_Ip_SetRxIndividualMask_Privileged (_113, u8FilterIdx, u32HwFilterMask);
  u8FilterIdx.0_114 = u8FilterIdx;
  u8FilterIdx = u8FilterIdx.0_114 + 1;

  <bb 18> :
  if (u8FilterIdx < u8FiFoFilterIndvCount)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _115 = Can_pHwObject->Can_u8HwFilterCount;
  if (u8FilterIdx < _115)
    goto <bb 6>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _116 = Can_pController->Can_u8ControllerOffset;
  _117 = Can_pController->Can_u32LegacyGlobalMask;
  FlexCAN_Ip_SetRxFifoGlobalMask_Privileged (_116, _117);
  if (u8HwFilterCount != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 21> :
  u8FilterIdx = 0;
  goto <bb 26>; [INV]

  <bb 22> :
  _118 = Can_pHwObject->Can_pHwFilterConfig;
  _119 = (unsigned int) u8FilterIdx;
  _120 = _119 * 8;
  _121 = _118 + _120;
  _122 = (int) u8FilterIdx;
  _123 = _121->Can_u32HwFilterCode;
  RxFifoFilters[_122].id = _123;
  _124 = Can_pHwObject->Can_IdMessage;
  if (_124 != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _125 = (int) u8FilterIdx;
  RxFifoFilters[_125].isExtendedFrame = 1;
  goto <bb 25>; [INV]

  <bb 24> :
  _126 = (int) u8FilterIdx;
  RxFifoFilters[_126].isExtendedFrame = 0;

  <bb 25> :
  _127 = (int) u8FilterIdx;
  RxFifoFilters[_127].isRemoteFrame = 0;
  u8FilterIdx.1_128 = u8FilterIdx;
  u8FilterIdx = u8FilterIdx.1_128 + 1;

  <bb 26> :
  if (u8FilterIdx < u8HwFilterCount)
    goto <bb 22>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  _129 = Can_pController->Can_u8ControllerOffset;
  FlexCAN_Ip_ConfigRxFifo_Privileged (_129, eElementFormat, &RxFifoFilters);

  <bb 28> :
  RxFifoFilters = {CLOBBER};
  return;

}


Can_Ipw_ParseData (struct Can_HwType * CanIf_Mailbox, struct PduInfoType * CanIf_PduInfo, struct Flexcan_Ip_MsgBuffType * pReceivedDataBuffer, const struct Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, const struct Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig)
{
  <bb 2> :
  _1 = pReceivedDataBuffer->msgId;
  CanIf_Mailbox->CanId = _1;
  _2 = pReceivedDataBuffer->cs;
  _3 = _2 & 2097152;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = CanIf_Mailbox->CanId;
  _5 = _4 | 2147483648;
  CanIf_Mailbox->CanId = _5;

  <bb 4> :
  _6 = Can_pHwObjectConfig->Can_eReceiveType;
  if (_6 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _7 = pReceivedDataBuffer->cs;
  _8 = _7 & 251658240;
  if (_8 == 100663296)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  Det_ReportRuntimeError (80, 0, 8, 1);

  <bb 7> :
  _9 = Can_pHwObjectConfig->Can_eReceiveType;
  if (_9 != 1)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _10 = pReceivedDataBuffer->cs;
  _11 = (signed int) _10;
  if (_11 < 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _12 = CanIf_Mailbox->CanId;
  _13 = _12 | 1073741824;
  CanIf_Mailbox->CanId = _13;

  <bb 10> :
  _14 = Can_pHwObjectConfig->Can_u8PayloadLength;
  _15 = pReceivedDataBuffer->dataLen;
  if (_14 <= _15)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _16 = Can_pHwObjectConfig->Can_u8PayloadLength;
  _17 = (long unsigned int) _16;
  CanIf_PduInfo->SduLength = _17;
  goto <bb 13>; [INV]

  <bb 12> :
  _18 = pReceivedDataBuffer->dataLen;
  _19 = (long unsigned int) _18;
  CanIf_PduInfo->SduLength = _19;

  <bb 13> :
  _20 = Can_pHwObjectConfig->Can_HwObjectID;
  CanIf_Mailbox->Hoh = _20;
  _21 = Can_pControllerConfig->Can_u8AbstControllerID;
  CanIf_Mailbox->ControllerId = _21;
  _22 = &pReceivedDataBuffer->data[0];
  CanIf_PduInfo->SduDataPtr = _22;
  CanIf_RxIndication (CanIf_Mailbox, CanIf_PduInfo);
  return;

}


