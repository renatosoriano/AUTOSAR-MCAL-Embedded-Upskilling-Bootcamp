
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00001287 	.word	0x00001287
  10:	00001289 	.word	0x00001289
  14:	0000128b 	.word	0x0000128b
  18:	0000128d 	.word	0x0000128d
	...
  2c:	0000128f 	.word	0x0000128f
  30:	00001291 	.word	0x00001291
  34:	00000000 	.word	0x00000000
  38:	00001293 	.word	0x00001293
  3c:	00001295 	.word	0x00001295
  40:	00001297 	.word	0x00001297
  44:	00001297 	.word	0x00001297
  48:	00001297 	.word	0x00001297
  4c:	00001297 	.word	0x00001297
  50:	00001297 	.word	0x00001297
  54:	00001297 	.word	0x00001297
  58:	00001297 	.word	0x00001297
  5c:	00001297 	.word	0x00001297
  60:	00001297 	.word	0x00001297
  64:	00001297 	.word	0x00001297
  68:	00001297 	.word	0x00001297
  6c:	00001297 	.word	0x00001297
  70:	00001297 	.word	0x00001297
  74:	00001297 	.word	0x00001297
  78:	00001297 	.word	0x00001297
  7c:	00001297 	.word	0x00001297
  80:	00001297 	.word	0x00001297
  84:	00001297 	.word	0x00001297
  88:	00001297 	.word	0x00001297
  8c:	00001297 	.word	0x00001297
  90:	00001297 	.word	0x00001297
  94:	00001297 	.word	0x00001297
  98:	00001297 	.word	0x00001297
  9c:	00001297 	.word	0x00001297
  a0:	00001297 	.word	0x00001297
  a4:	00001297 	.word	0x00001297
  a8:	00001297 	.word	0x00001297
  ac:	00001297 	.word	0x00001297
  b0:	00001297 	.word	0x00001297
  b4:	00001297 	.word	0x00001297
  b8:	00001297 	.word	0x00001297
  bc:	00001297 	.word	0x00001297
  c0:	00001297 	.word	0x00001297
  c4:	00001297 	.word	0x00001297
  c8:	00001297 	.word	0x00001297
  cc:	00001297 	.word	0x00001297
  d0:	00001297 	.word	0x00001297
  d4:	00001297 	.word	0x00001297
  d8:	00001297 	.word	0x00001297
  dc:	00001297 	.word	0x00001297
  e0:	00001297 	.word	0x00001297
  e4:	00001297 	.word	0x00001297
  e8:	00001297 	.word	0x00001297
  ec:	00001297 	.word	0x00001297
  f0:	00001297 	.word	0x00001297
  f4:	00001297 	.word	0x00001297
  f8:	00001297 	.word	0x00001297
  fc:	00001297 	.word	0x00001297
 100:	00001297 	.word	0x00001297
 104:	00001297 	.word	0x00001297
 108:	00001297 	.word	0x00001297
 10c:	00001297 	.word	0x00001297
 110:	00001297 	.word	0x00001297
 114:	00001297 	.word	0x00001297
 118:	00001297 	.word	0x00001297
 11c:	00001297 	.word	0x00001297
 120:	00001297 	.word	0x00001297
 124:	00001297 	.word	0x00001297
 128:	00001297 	.word	0x00001297
 12c:	00001297 	.word	0x00001297
 130:	00001297 	.word	0x00001297
 134:	00001297 	.word	0x00001297
 138:	00001297 	.word	0x00001297
 13c:	00001297 	.word	0x00001297
 140:	00001297 	.word	0x00001297
 144:	00001297 	.word	0x00001297
 148:	00001297 	.word	0x00001297
 14c:	00001297 	.word	0x00001297
 150:	00001297 	.word	0x00001297
 154:	00001297 	.word	0x00001297
 158:	00001297 	.word	0x00001297
 15c:	00001297 	.word	0x00001297
 160:	00001297 	.word	0x00001297
 164:	00001297 	.word	0x00001297
 168:	00001297 	.word	0x00001297
 16c:	00001297 	.word	0x00001297
 170:	00001297 	.word	0x00001297
 174:	00001297 	.word	0x00001297
 178:	00001297 	.word	0x00001297
 17c:	00001297 	.word	0x00001297
 180:	00001297 	.word	0x00001297
 184:	00001297 	.word	0x00001297
 188:	00001297 	.word	0x00001297
 18c:	00001297 	.word	0x00001297
 190:	00001297 	.word	0x00001297
 194:	00001297 	.word	0x00001297
 198:	00001297 	.word	0x00001297
 19c:	00001297 	.word	0x00001297
 1a0:	00001297 	.word	0x00001297
 1a4:	00001297 	.word	0x00001297
 1a8:	00001297 	.word	0x00001297
 1ac:	00001297 	.word	0x00001297
 1b0:	00001297 	.word	0x00001297
 1b4:	00001297 	.word	0x00001297
 1b8:	00001297 	.word	0x00001297
 1bc:	00001297 	.word	0x00001297
 1c0:	00001297 	.word	0x00001297
 1c4:	00001297 	.word	0x00001297
 1c8:	00001297 	.word	0x00001297
 1cc:	00001297 	.word	0x00001297
 1d0:	00001297 	.word	0x00001297
 1d4:	00001297 	.word	0x00001297
 1d8:	00001297 	.word	0x00001297
 1dc:	00001297 	.word	0x00001297
 1e0:	00001297 	.word	0x00001297
 1e4:	00001297 	.word	0x00001297
 1e8:	00001297 	.word	0x00001297
 1ec:	00001297 	.word	0x00001297
 1f0:	00001297 	.word	0x00001297
 1f4:	00001297 	.word	0x00001297
 1f8:	00001297 	.word	0x00001297
 1fc:	00001297 	.word	0x00001297
 200:	00001297 	.word	0x00001297
 204:	00001297 	.word	0x00001297
 208:	00001297 	.word	0x00001297
 20c:	00001297 	.word	0x00001297
 210:	00001297 	.word	0x00001297
 214:	00001297 	.word	0x00001297
 218:	00001297 	.word	0x00001297
 21c:	00001297 	.word	0x00001297
 220:	00001297 	.word	0x00001297
 224:	00001297 	.word	0x00001297
 228:	00001297 	.word	0x00001297
 22c:	00001297 	.word	0x00001297
 230:	00001297 	.word	0x00001297
 234:	00001297 	.word	0x00001297
 238:	00001297 	.word	0x00001297
 23c:	00001297 	.word	0x00001297
 240:	00001297 	.word	0x00001297
 244:	00001297 	.word	0x00001297
 248:	00001297 	.word	0x00001297
 24c:	00001297 	.word	0x00001297
 250:	00001297 	.word	0x00001297
 254:	00001297 	.word	0x00001297
 258:	00001297 	.word	0x00001297
 25c:	00001297 	.word	0x00001297
 260:	00001297 	.word	0x00001297
 264:	00001297 	.word	0x00001297
 268:	00001297 	.word	0x00001297
 26c:	00001297 	.word	0x00001297
 270:	00001297 	.word	0x00001297
 274:	00001297 	.word	0x00001297
 278:	00001297 	.word	0x00001297
 27c:	00001297 	.word	0x00001297
 280:	00001297 	.word	0x00001297
 284:	00001297 	.word	0x00001297
 288:	00001297 	.word	0x00001297
 28c:	00001297 	.word	0x00001297
 290:	00001297 	.word	0x00001297
 294:	00001297 	.word	0x00001297
 298:	00001297 	.word	0x00001297
 29c:	00001297 	.word	0x00001297
 2a0:	00001297 	.word	0x00001297
 2a4:	00001297 	.word	0x00001297
 2a8:	00001297 	.word	0x00001297
 2ac:	00001297 	.word	0x00001297
 2b0:	00001297 	.word	0x00001297
 2b4:	00001297 	.word	0x00001297
 2b8:	00001297 	.word	0x00001297
 2bc:	00001297 	.word	0x00001297
 2c0:	00001297 	.word	0x00001297
 2c4:	00001297 	.word	0x00001297
 2c8:	00001297 	.word	0x00001297
 2cc:	00001297 	.word	0x00001297
 2d0:	00001297 	.word	0x00001297
 2d4:	00001297 	.word	0x00001297
 2d8:	00001297 	.word	0x00001297
 2dc:	00001297 	.word	0x00001297
 2e0:	00001297 	.word	0x00001297
 2e4:	00001297 	.word	0x00001297
 2e8:	00001297 	.word	0x00001297
 2ec:	00001297 	.word	0x00001297
 2f0:	00001297 	.word	0x00001297
 2f4:	00001297 	.word	0x00001297
 2f8:	00001297 	.word	0x00001297
 2fc:	00001297 	.word	0x00001297
 300:	00001297 	.word	0x00001297
 304:	00001297 	.word	0x00001297
 308:	00001297 	.word	0x00001297
 30c:	00001297 	.word	0x00001297

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fe37 	bl	10f4 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fef6 	bl	127c <startup_go_to_user_mode>
     490:	f000 fa70 	bl	974 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff91dc 	.word	0x1fff91dc

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fe41 	bl	1220 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <Delay>:
void EcuM_Init( void );

/*this is dummy delay function prepare just for this example, in a real application 
no delay shall be used*/
void Delay( uint32 ms )
{
     8b0:	b500      	push	{lr}
     8b2:	b087      	sub	sp, #28
     8b4:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
     8b6:	9b01      	ldr	r3, [sp, #4]
     8b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8bc:	fb02 f303 	mul.w	r3, r2, r3
     8c0:	2101      	movs	r1, #1
     8c2:	4618      	mov	r0, r3
     8c4:	f001 fce8 	bl	2298 <OsIf_MicrosToTicks>
     8c8:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
     8ca:	2001      	movs	r0, #1
     8cc:	f001 fc98 	bl	2200 <OsIf_GetCounter>
     8d0:	4603      	mov	r3, r0
     8d2:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
     8d4:	2300      	movs	r3, #0
     8d6:	9305      	str	r3, [sp, #20]
    do{
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     8d8:	ab03      	add	r3, sp, #12
     8da:	2101      	movs	r1, #1
     8dc:	4618      	mov	r0, r3
     8de:	f001 fca8 	bl	2232 <OsIf_GetElapsed>
     8e2:	4602      	mov	r2, r0
     8e4:	9b05      	ldr	r3, [sp, #20]
     8e6:	4413      	add	r3, r2
     8e8:	9305      	str	r3, [sp, #20]
    }
    while( ElapsedTime < Timeout );
     8ea:	9a05      	ldr	r2, [sp, #20]
     8ec:	9b04      	ldr	r3, [sp, #16]
     8ee:	429a      	cmp	r2, r3
     8f0:	d3f2      	bcc.n	8d8 <Delay+0x28>
}
     8f2:	bf00      	nop
     8f4:	bf00      	nop
     8f6:	b007      	add	sp, #28
     8f8:	f85d fb04 	ldr.w	pc, [sp], #4

000008fc <CDD_UserTxConfirmation0x154>:

/*Callback function to indicate that the message was transmitted. The reference
to function shall be defined in file Autosar/CanIf/CanIf_Cdd.h, such file
must be created manualy, we define this same function notification for both Pdus*/
void CDD_UserTxConfirmation0x154( PduIdType TxPduId, Std_ReturnType result )
{
     8fc:	b082      	sub	sp, #8
     8fe:	4603      	mov	r3, r0
     900:	460a      	mov	r2, r1
     902:	f8ad 3006 	strh.w	r3, [sp, #6]
     906:	4613      	mov	r3, r2
     908:	f88d 3005 	strb.w	r3, [sp, #5]
    (void)TxPduId;
    if( result == E_OK )
     90c:	f89d 3005 	ldrb.w	r3, [sp, #5]
     910:	2b00      	cmp	r3, #0
     912:	d102      	bne.n	91a <CDD_UserTxConfirmation0x154+0x1e>
    {
        CanIf_bTxFlag = TRUE;
     914:	4b02      	ldr	r3, [pc, #8]	; (920 <CDD_UserTxConfirmation0x154+0x24>)
     916:	2201      	movs	r2, #1
     918:	701a      	strb	r2, [r3, #0]
    }
}
     91a:	bf00      	nop
     91c:	b002      	add	sp, #8
     91e:	4770      	bx	lr
     920:	1fff8b40 	.word	0x1fff8b40

00000924 <CDD_UserTxConfirmation0x233>:

/*Callback function to indicate that the message was transmitted. The reference
to function shall be defined in file Autosar/CanIf/CanIf_Cdd.h, such file
must be created manualy, we define this same function notification for both Pdus*/
void CDD_UserTxConfirmation0x233( PduIdType TxPduId, Std_ReturnType result )
{
     924:	b082      	sub	sp, #8
     926:	4603      	mov	r3, r0
     928:	460a      	mov	r2, r1
     92a:	f8ad 3006 	strh.w	r3, [sp, #6]
     92e:	4613      	mov	r3, r2
     930:	f88d 3005 	strb.w	r3, [sp, #5]
    (void)TxPduId;
    if( result == E_OK )
     934:	f89d 3005 	ldrb.w	r3, [sp, #5]
     938:	2b00      	cmp	r3, #0
     93a:	d102      	bne.n	942 <CDD_UserTxConfirmation0x233+0x1e>
    {
        CanIf_bTxFlag = TRUE;
     93c:	4b02      	ldr	r3, [pc, #8]	; (948 <CDD_UserTxConfirmation0x233+0x24>)
     93e:	2201      	movs	r2, #1
     940:	701a      	strb	r2, [r3, #0]
    }
}
     942:	bf00      	nop
     944:	b002      	add	sp, #8
     946:	4770      	bx	lr
     948:	1fff8b40 	.word	0x1fff8b40

0000094c <CDD_UserTxConfirmation0x382>:

/*Callback function to indicate that the message was transmitted. The reference
to function shall be defined in file Autosar/CanIf/CanIf_Cdd.h, such file
must be created manualy, we define this same function notification for both Pdus*/
void CDD_UserTxConfirmation0x382( PduIdType TxPduId, Std_ReturnType result )
{
     94c:	b082      	sub	sp, #8
     94e:	4603      	mov	r3, r0
     950:	460a      	mov	r2, r1
     952:	f8ad 3006 	strh.w	r3, [sp, #6]
     956:	4613      	mov	r3, r2
     958:	f88d 3005 	strb.w	r3, [sp, #5]
    (void)TxPduId;
    if( result == E_OK )
     95c:	f89d 3005 	ldrb.w	r3, [sp, #5]
     960:	2b00      	cmp	r3, #0
     962:	d102      	bne.n	96a <CDD_UserTxConfirmation0x382+0x1e>
    {
        CanIf_bTxFlag = TRUE;
     964:	4b02      	ldr	r3, [pc, #8]	; (970 <CDD_UserTxConfirmation0x382+0x24>)
     966:	2201      	movs	r2, #1
     968:	701a      	strb	r2, [r3, #0]
    }
}
     96a:	bf00      	nop
     96c:	b002      	add	sp, #8
     96e:	4770      	bx	lr
     970:	1fff8b40 	.word	0x1fff8b40

00000974 <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     974:	b500      	push	{lr}
     976:	b085      	sub	sp, #20
    EcuM_Init();
     978:	f000 f970 	bl	c5c <EcuM_Init>

    /* Intiliaze RTT library */
    SEGGER_RTT_Init();
     97c:	f000 fe1e 	bl	15bc <SEGGER_RTT_Init>

    PduInfoType PduInfo;

    uint8 RealEvent = 0;     // Actual event of button.
     980:	2300      	movs	r3, #0
     982:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 ButtonFlag = 0;    // Button Flag for Msg Tx
     986:	2300      	movs	r3, #0
     988:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Set the specified baudrate */
    if (Can_43_FLEXCAN_SetBaudrate(CanController_0, CAN_BAUDRATE_500kbps_ID ) == E_OK) {
     98c:	2102      	movs	r1, #2
     98e:	2000      	movs	r0, #0
     990:	f006 fe24 	bl	75dc <Can_43_FLEXCAN_SetBaudrate>
     994:	4603      	mov	r3, r0
     996:	2b00      	cmp	r3, #0
     998:	d104      	bne.n	9a4 <main+0x30>
        SEGGER_RTT_printf( 0, "CAN baud rate set successfully. \n" );
     99a:	499b      	ldr	r1, [pc, #620]	; (c08 <__BSS_SRAM_SIZE+0xa8>)
     99c:	2000      	movs	r0, #0
     99e:	f001 f975 	bl	1c8c <SEGGER_RTT_printf>
     9a2:	e003      	b.n	9ac <main+0x38>

    } else {
        SEGGER_RTT_printf( 0, "Failed to set CAN baud rate. \n" );
     9a4:	4999      	ldr	r1, [pc, #612]	; (c0c <__BSS_SRAM_SIZE+0xac>)
     9a6:	2000      	movs	r0, #0
     9a8:	f001 f970 	bl	1c8c <SEGGER_RTT_printf>
    /* Start the CAN controller and make it active in the CAN bus network */
    /* The CAN module notifies the upper layer (CanIf_ControllerModeIndication) after 
    a successful state transition about the new state. The monitoring whether the 
    requested state is achieved is part of an upper layer module and is not part of 
    the Can module. */
    if (Can_43_FLEXCAN_SetControllerMode( CanController_0, CAN_CS_STARTED ) == E_OK) {
     9ac:	2101      	movs	r1, #1
     9ae:	2000      	movs	r0, #0
     9b0:	f006 fe4c 	bl	764c <Can_43_FLEXCAN_SetControllerMode>
     9b4:	4603      	mov	r3, r0
     9b6:	2b00      	cmp	r3, #0
     9b8:	d104      	bne.n	9c4 <main+0x50>
        SEGGER_RTT_printf( 0, "CAN controller state machine set successfully. \n" );
     9ba:	4995      	ldr	r1, [pc, #596]	; (c10 <__BSS_SRAM_SIZE+0xb0>)
     9bc:	2000      	movs	r0, #0
     9be:	f001 f965 	bl	1c8c <SEGGER_RTT_printf>
     9c2:	e003      	b.n	9cc <main+0x58>

    } else {
        SEGGER_RTT_printf( 0, "Failed to set CAN controller state machine. \n" );
     9c4:	4993      	ldr	r1, [pc, #588]	; (c14 <__BSS_SRAM_SIZE+0xb4>)
     9c6:	2000      	movs	r0, #0
     9c8:	f001 f960 	bl	1c8c <SEGGER_RTT_printf>
    }

    /* Set the information to transmit */
    PduInfo.SduDataPtr = Can_au8Sdu8bytes;
     9cc:	4b92      	ldr	r3, [pc, #584]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     9ce:	9300      	str	r3, [sp, #0]
    PduInfo.SduLength = 8u;
     9d0:	2308      	movs	r3, #8
     9d2:	9302      	str	r3, [sp, #8]
    PduInfo.MetaDataPtr = NULL_PTR;
     9d4:	2300      	movs	r3, #0
     9d6:	9301      	str	r3, [sp, #4]

    while( 1u )
    {
        HwIoAb_Buttons_MainFunction();
     9d8:	f000 f9da 	bl	d90 <HwIoAb_Buttons_MainFunction>
        Delay( 10 ); 
     9dc:	200a      	movs	r0, #10
     9de:	f7ff ff67 	bl	8b0 <Delay>

        for ( uint8 CurrentButton = 0; CurrentButton < HWIOAB_BUTTONS_MAX; CurrentButton++ )    // Checking each button and its event detected.
     9e2:	2300      	movs	r3, #0
     9e4:	f88d 300e 	strb.w	r3, [sp, #14]
     9e8:	e0a4      	b.n	b34 <main+0x1c0>
        {  
            RealEvent =  HwIoAb_Buttons_GetEvent( CurrentButton );   // Obtaining event of actual button.
     9ea:	f89d 300e 	ldrb.w	r3, [sp, #14]
     9ee:	4618      	mov	r0, r3
     9f0:	f000 f9b0 	bl	d54 <HwIoAb_Buttons_GetEvent>
     9f4:	4603      	mov	r3, r0
     9f6:	f88d 300d 	strb.w	r3, [sp, #13]

            if ( RealEvent != HWIOAB_BTN_EVENT_IDLE )    // A click was detected
     9fa:	f89d 300d 	ldrb.w	r3, [sp, #13]
     9fe:	2b00      	cmp	r3, #0
     a00:	f000 8090 	beq.w	b24 <main+0x1b0>
            {
                switch( CurrentButton )
     a04:	f89d 300e 	ldrb.w	r3, [sp, #14]
     a08:	2b02      	cmp	r3, #2
     a0a:	d05f      	beq.n	acc <main+0x158>
     a0c:	2b02      	cmp	r3, #2
     a0e:	f300 808b 	bgt.w	b28 <main+0x1b4>
     a12:	2b00      	cmp	r3, #0
     a14:	d002      	beq.n	a1c <main+0xa8>
     a16:	2b01      	cmp	r3, #1
     a18:	d02c      	beq.n	a74 <main+0x100>
                            break;
                        }
                    break;
                    default :
                      // If jump here is an error
                    break;
     a1a:	e085      	b.n	b28 <main+0x1b4>
                        switch( RealEvent )
     a1c:	f89d 300d 	ldrb.w	r3, [sp, #13]
     a20:	3b01      	subs	r3, #1
     a22:	2b03      	cmp	r3, #3
     a24:	d824      	bhi.n	a70 <main+0xfc>
     a26:	a201      	add	r2, pc, #4	; (adr r2, a2c <main+0xb8>)
     a28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     a2c:	00000a3d 	.word	0x00000a3d
     a30:	00000a53 	.word	0x00000a53
     a34:	00000a5d 	.word	0x00000a5d
     a38:	00000a67 	.word	0x00000a67
                                HwIoAb_Leds_TurnToggle( HWIOAB_LED_BLUE_ID );
     a3c:	2000      	movs	r0, #0
     a3e:	f000 fb31 	bl	10a4 <HwIoAb_Leds_TurnToggle>
                                SEGGER_RTT_printf( 0, "Button 1 action: SINGLE_CLICK \n" );
     a42:	4976      	ldr	r1, [pc, #472]	; (c1c <__BSS_SRAM_SIZE+0xbc>)
     a44:	2000      	movs	r0, #0
     a46:	f001 f921 	bl	1c8c <SEGGER_RTT_printf>
                                ButtonFlag = 1;
     a4a:	2301      	movs	r3, #1
     a4c:	f88d 300f 	strb.w	r3, [sp, #15]
                            break;
     a50:	e00f      	b.n	a72 <main+0xfe>
                                SEGGER_RTT_printf( 0, "Button 1 action: DOUBLE_CLICK \n" );
     a52:	4973      	ldr	r1, [pc, #460]	; (c20 <__BSS_SRAM_SIZE+0xc0>)
     a54:	2000      	movs	r0, #0
     a56:	f001 f919 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     a5a:	e00a      	b.n	a72 <main+0xfe>
                                SEGGER_RTT_printf( 0, "Button 1 action: HOLD_CLICK \n" );
     a5c:	4971      	ldr	r1, [pc, #452]	; (c24 <__BSS_SRAM_SIZE+0xc4>)
     a5e:	2000      	movs	r0, #0
     a60:	f001 f914 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     a64:	e005      	b.n	a72 <main+0xfe>
                                SEGGER_RTT_printf( 0, "Button 1 action: RELEASE \n" );
     a66:	4970      	ldr	r1, [pc, #448]	; (c28 <__BSS_SRAM_SIZE+0xc8>)
     a68:	2000      	movs	r0, #0
     a6a:	f001 f90f 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     a6e:	e000      	b.n	a72 <main+0xfe>
                            break;
     a70:	bf00      	nop
                    break;
     a72:	e05a      	b.n	b2a <main+0x1b6>
                        switch( RealEvent )
     a74:	f89d 300d 	ldrb.w	r3, [sp, #13]
     a78:	3b01      	subs	r3, #1
     a7a:	2b03      	cmp	r3, #3
     a7c:	d824      	bhi.n	ac8 <main+0x154>
     a7e:	a201      	add	r2, pc, #4	; (adr r2, a84 <main+0x110>)
     a80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     a84:	00000a95 	.word	0x00000a95
     a88:	00000aab 	.word	0x00000aab
     a8c:	00000ab5 	.word	0x00000ab5
     a90:	00000abf 	.word	0x00000abf
                                HwIoAb_Leds_TurnToggle( HWIOAB_LED_RED_ID );
     a94:	2001      	movs	r0, #1
     a96:	f000 fb05 	bl	10a4 <HwIoAb_Leds_TurnToggle>
                                SEGGER_RTT_printf( 0, "Button 2 action: SINGLE_CLICK \n" );
     a9a:	4964      	ldr	r1, [pc, #400]	; (c2c <__BSS_SRAM_SIZE+0xcc>)
     a9c:	2000      	movs	r0, #0
     a9e:	f001 f8f5 	bl	1c8c <SEGGER_RTT_printf>
                                ButtonFlag = 2;
     aa2:	2302      	movs	r3, #2
     aa4:	f88d 300f 	strb.w	r3, [sp, #15]
                            break;
     aa8:	e00f      	b.n	aca <main+0x156>
                                SEGGER_RTT_printf( 0, "Button 2 action: DOUBLE_CLICK \n" );
     aaa:	4961      	ldr	r1, [pc, #388]	; (c30 <__BSS_SRAM_SIZE+0xd0>)
     aac:	2000      	movs	r0, #0
     aae:	f001 f8ed 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     ab2:	e00a      	b.n	aca <main+0x156>
                                SEGGER_RTT_printf( 0, "Button 2 action: HOLD_CLICK \n" );
     ab4:	495f      	ldr	r1, [pc, #380]	; (c34 <__BSS_SRAM_SIZE+0xd4>)
     ab6:	2000      	movs	r0, #0
     ab8:	f001 f8e8 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     abc:	e005      	b.n	aca <main+0x156>
                                SEGGER_RTT_printf( 0, "Button 2 action: RELEASE \n" );
     abe:	495e      	ldr	r1, [pc, #376]	; (c38 <__BSS_SRAM_SIZE+0xd8>)
     ac0:	2000      	movs	r0, #0
     ac2:	f001 f8e3 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     ac6:	e000      	b.n	aca <main+0x156>
                            break;
     ac8:	bf00      	nop
                    break;
     aca:	e02e      	b.n	b2a <main+0x1b6>
                        switch( RealEvent )
     acc:	f89d 300d 	ldrb.w	r3, [sp, #13]
     ad0:	3b01      	subs	r3, #1
     ad2:	2b03      	cmp	r3, #3
     ad4:	d824      	bhi.n	b20 <main+0x1ac>
     ad6:	a201      	add	r2, pc, #4	; (adr r2, adc <main+0x168>)
     ad8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     adc:	00000aed 	.word	0x00000aed
     ae0:	00000b03 	.word	0x00000b03
     ae4:	00000b0d 	.word	0x00000b0d
     ae8:	00000b17 	.word	0x00000b17
                                HwIoAb_Leds_TurnToggle( HWIOAB_LED_GREEN_ID );
     aec:	2002      	movs	r0, #2
     aee:	f000 fad9 	bl	10a4 <HwIoAb_Leds_TurnToggle>
                                SEGGER_RTT_printf( 0, "Button 3 action: SINGLE_CLICK \n" );
     af2:	4952      	ldr	r1, [pc, #328]	; (c3c <__BSS_SRAM_SIZE+0xdc>)
     af4:	2000      	movs	r0, #0
     af6:	f001 f8c9 	bl	1c8c <SEGGER_RTT_printf>
                                ButtonFlag = 3;
     afa:	2303      	movs	r3, #3
     afc:	f88d 300f 	strb.w	r3, [sp, #15]
                            break;
     b00:	e00f      	b.n	b22 <main+0x1ae>
                                SEGGER_RTT_printf( 0, "Button 3 action: DOUBLE_CLICK \n" );
     b02:	494f      	ldr	r1, [pc, #316]	; (c40 <__BSS_SRAM_SIZE+0xe0>)
     b04:	2000      	movs	r0, #0
     b06:	f001 f8c1 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     b0a:	e00a      	b.n	b22 <main+0x1ae>
                                SEGGER_RTT_printf( 0, "Button 3 action: HOLD_CLICK \n" );
     b0c:	494d      	ldr	r1, [pc, #308]	; (c44 <__BSS_SRAM_SIZE+0xe4>)
     b0e:	2000      	movs	r0, #0
     b10:	f001 f8bc 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     b14:	e005      	b.n	b22 <main+0x1ae>
                                SEGGER_RTT_printf( 0, "Button 3 action: RELEASE \n" );
     b16:	494c      	ldr	r1, [pc, #304]	; (c48 <__BSS_SRAM_SIZE+0xe8>)
     b18:	2000      	movs	r0, #0
     b1a:	f001 f8b7 	bl	1c8c <SEGGER_RTT_printf>
                            break;
     b1e:	e000      	b.n	b22 <main+0x1ae>
                            break;
     b20:	bf00      	nop
                    break;
     b22:	e002      	b.n	b2a <main+0x1b6>
                }  
            }
     b24:	bf00      	nop
     b26:	e000      	b.n	b2a <main+0x1b6>
                    break;
     b28:	bf00      	nop
        for ( uint8 CurrentButton = 0; CurrentButton < HWIOAB_BUTTONS_MAX; CurrentButton++ )    // Checking each button and its event detected.
     b2a:	f89d 300e 	ldrb.w	r3, [sp, #14]
     b2e:	3301      	adds	r3, #1
     b30:	f88d 300e 	strb.w	r3, [sp, #14]
     b34:	f89d 300e 	ldrb.w	r3, [sp, #14]
     b38:	2b02      	cmp	r3, #2
     b3a:	f67f af56 	bls.w	9ea <main+0x76>
        }

        if(ButtonFlag == 1)
     b3e:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b42:	2b01      	cmp	r3, #1
     b44:	d11c      	bne.n	b80 <__BSS_SRAM_SIZE+0x20>
        {
            ButtonFlag = 0;
     b46:	2300      	movs	r3, #0
     b48:	f88d 300f 	strb.w	r3, [sp, #15]
            Can_au8Sdu8bytes[7] = 0x01U; 
     b4c:	4b32      	ldr	r3, [pc, #200]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     b4e:	2201      	movs	r2, #1
     b50:	71da      	strb	r2, [r3, #7]
            /* Set the FlexCAN peripheral to transmit the message, the message will be
            transmitted by the CAN interrupt, this function will call the low level
            Can_43_FLEXCAN_Write with the low level data according de PDU configured */
            CanIf_Transmit( CanIfTxPduCfg_0, &PduInfo );
     b52:	466b      	mov	r3, sp
     b54:	4619      	mov	r1, r3
     b56:	2000      	movs	r0, #0
     b58:	f00e fe46 	bl	f7e8 <CanIf_Transmit>
            SEGGER_RTT_printf( 0, "CAN msg 0x154 transmitted at 500kbps using Button: %d \n", Can_au8Sdu8bytes[7] );
     b5c:	4b2e      	ldr	r3, [pc, #184]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     b5e:	79db      	ldrb	r3, [r3, #7]
     b60:	461a      	mov	r2, r3
     b62:	493a      	ldr	r1, [pc, #232]	; (c4c <__BSS_SRAM_SIZE+0xec>)
     b64:	2000      	movs	r0, #0
     b66:	f001 f891 	bl	1c8c <SEGGER_RTT_printf>
            /* Wait until the CAN interrupt transmit message, waiting is not the
            suitable way, but good enough for ilustration purposes, flag is 
            updated by the callback function CanIf_TxConfirmation */
            while( CanIf_bTxFlag == FALSE );
     b6a:	bf00      	nop
     b6c:	4b38      	ldr	r3, [pc, #224]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     b6e:	781b      	ldrb	r3, [r3, #0]
     b70:	f083 0301 	eor.w	r3, r3, #1
     b74:	b2db      	uxtb	r3, r3
     b76:	2b00      	cmp	r3, #0
     b78:	d1f8      	bne.n	b6c <__BSS_SRAM_SIZE+0xc>
            /* Clear the Tx flag */
            CanIf_bTxFlag = FALSE;
     b7a:	4b35      	ldr	r3, [pc, #212]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     b7c:	2200      	movs	r2, #0
     b7e:	701a      	strb	r2, [r3, #0]
        }
        if(ButtonFlag == 2)
     b80:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b84:	2b02      	cmp	r3, #2
     b86:	d11c      	bne.n	bc2 <__BSS_SRAM_SIZE+0x62>
        {
            ButtonFlag = 0;
     b88:	2300      	movs	r3, #0
     b8a:	f88d 300f 	strb.w	r3, [sp, #15]
            Can_au8Sdu8bytes[7] = 0x02U;  
     b8e:	4b22      	ldr	r3, [pc, #136]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     b90:	2202      	movs	r2, #2
     b92:	71da      	strb	r2, [r3, #7]
            /* Set the FlexCAN peripheral to transmit the message, the message will be
            transmitted by the CAN interrupt, this function will call the low level
            Can_43_FLEXCAN_Write with the low level data according de PDU configured */
            CanIf_Transmit( CanIfTxPduCfg_1, &PduInfo );
     b94:	466b      	mov	r3, sp
     b96:	4619      	mov	r1, r3
     b98:	2001      	movs	r0, #1
     b9a:	f00e fe25 	bl	f7e8 <CanIf_Transmit>
            SEGGER_RTT_printf( 0, "CAN msg 0x233 transmitted at 500kbps using Button: %d \n", Can_au8Sdu8bytes[7] );
     b9e:	4b1e      	ldr	r3, [pc, #120]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     ba0:	79db      	ldrb	r3, [r3, #7]
     ba2:	461a      	mov	r2, r3
     ba4:	492b      	ldr	r1, [pc, #172]	; (c54 <__BSS_SRAM_SIZE+0xf4>)
     ba6:	2000      	movs	r0, #0
     ba8:	f001 f870 	bl	1c8c <SEGGER_RTT_printf>
            /* Wait until the CAN interrupt transmit message, waiting is not the
            suitable way, but good enough for ilustration purposes, flag is 
            updated by the callback function CanIf_TxConfirmation */
            while( CanIf_bTxFlag == FALSE );
     bac:	bf00      	nop
     bae:	4b28      	ldr	r3, [pc, #160]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     bb0:	781b      	ldrb	r3, [r3, #0]
     bb2:	f083 0301 	eor.w	r3, r3, #1
     bb6:	b2db      	uxtb	r3, r3
     bb8:	2b00      	cmp	r3, #0
     bba:	d1f8      	bne.n	bae <__BSS_SRAM_SIZE+0x4e>
            /* Clear the Tx flag */
            CanIf_bTxFlag = FALSE;
     bbc:	4b24      	ldr	r3, [pc, #144]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     bbe:	2200      	movs	r2, #0
     bc0:	701a      	strb	r2, [r3, #0]
        }
        if(ButtonFlag == 3)
     bc2:	f89d 300f 	ldrb.w	r3, [sp, #15]
     bc6:	2b03      	cmp	r3, #3
     bc8:	f47f af06 	bne.w	9d8 <main+0x64>
        {
            ButtonFlag = 0;
     bcc:	2300      	movs	r3, #0
     bce:	f88d 300f 	strb.w	r3, [sp, #15]
            Can_au8Sdu8bytes[7] = 0x03U;  
     bd2:	4b11      	ldr	r3, [pc, #68]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     bd4:	2203      	movs	r2, #3
     bd6:	71da      	strb	r2, [r3, #7]
            /* Set the FlexCAN peripheral to transmit the message, the message will be
            transmitted by the CAN interrupt, this function will call the low level
            Can_43_FLEXCAN_Write with the low level data according de PDU configured */
            CanIf_Transmit( CanIfTxPduCfg_2, &PduInfo );
     bd8:	466b      	mov	r3, sp
     bda:	4619      	mov	r1, r3
     bdc:	2002      	movs	r0, #2
     bde:	f00e fe03 	bl	f7e8 <CanIf_Transmit>
            SEGGER_RTT_printf( 0, "CAN msg 0x382 transmitted at 500kbps using Button: %d \n", Can_au8Sdu8bytes[7] );
     be2:	4b0d      	ldr	r3, [pc, #52]	; (c18 <__BSS_SRAM_SIZE+0xb8>)
     be4:	79db      	ldrb	r3, [r3, #7]
     be6:	461a      	mov	r2, r3
     be8:	491b      	ldr	r1, [pc, #108]	; (c58 <__BSS_SRAM_SIZE+0xf8>)
     bea:	2000      	movs	r0, #0
     bec:	f001 f84e 	bl	1c8c <SEGGER_RTT_printf>
            /* Wait until the CAN interrupt transmit message, waiting is not the
            suitable way, but good enough for ilustration purposes, flag is 
            updated by the callback function CanIf_TxConfirmation */
            while( CanIf_bTxFlag == FALSE );
     bf0:	bf00      	nop
     bf2:	4b17      	ldr	r3, [pc, #92]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     bf4:	781b      	ldrb	r3, [r3, #0]
     bf6:	f083 0301 	eor.w	r3, r3, #1
     bfa:	b2db      	uxtb	r3, r3
     bfc:	2b00      	cmp	r3, #0
     bfe:	d1f8      	bne.n	bf2 <__BSS_SRAM_SIZE+0x92>
            /* Clear the Tx flag */
            CanIf_bTxFlag = FALSE;
     c00:	4b13      	ldr	r3, [pc, #76]	; (c50 <__BSS_SRAM_SIZE+0xf0>)
     c02:	2200      	movs	r2, #0
     c04:	701a      	strb	r2, [r3, #0]
        HwIoAb_Buttons_MainFunction();
     c06:	e6e7      	b.n	9d8 <main+0x64>
     c08:	0000faac 	.word	0x0000faac
     c0c:	0000fad0 	.word	0x0000fad0
     c10:	0000faf0 	.word	0x0000faf0
     c14:	0000fb24 	.word	0x0000fb24
     c18:	1fff8b44 	.word	0x1fff8b44
     c1c:	0000fb54 	.word	0x0000fb54
     c20:	0000fb74 	.word	0x0000fb74
     c24:	0000fb94 	.word	0x0000fb94
     c28:	0000fbb4 	.word	0x0000fbb4
     c2c:	0000fbd0 	.word	0x0000fbd0
     c30:	0000fbf0 	.word	0x0000fbf0
     c34:	0000fc10 	.word	0x0000fc10
     c38:	0000fc30 	.word	0x0000fc30
     c3c:	0000fc4c 	.word	0x0000fc4c
     c40:	0000fc6c 	.word	0x0000fc6c
     c44:	0000fc8c 	.word	0x0000fc8c
     c48:	0000fcac 	.word	0x0000fcac
     c4c:	0000fcc8 	.word	0x0000fcc8
     c50:	1fff8b40 	.word	0x1fff8b40
     c54:	0000fd00 	.word	0x0000fd00
     c58:	0000fd38 	.word	0x0000fd38

00000c5c <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     c5c:	b508      	push	{r3, lr}
    /* Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h */
    Mcu_Init( &Mcu_Config );
     c5e:	480e      	ldr	r0, [pc, #56]	; (c98 <EcuM_Init+0x3c>)
     c60:	f005 f85a 	bl	5d18 <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     c64:	2000      	movs	r0, #0
     c66:	f005 f8ab 	bl	5dc0 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     c6a:	2000      	movs	r0, #0
     c6c:	f005 f8cc 	bl	5e08 <Mcu_SetMode>
    /* Init the internal tick reference Systick Timer */
    OsIf_Init( NULL_PTR );
     c70:	2000      	movs	r0, #0
     c72:	f001 fabc 	bl	21ee <OsIf_Init>
    
    /* Enable and setup interrupts in use by the Can Driver */
    Platform_Init( NULL_PTR );
     c76:	2000      	movs	r0, #0
     c78:	f001 f9b6 	bl	1fe8 <Platform_Init>

    /* Apply all the Pin Port microcontroller configuration */
    Port_Init( &Port_Config );
     c7c:	4807      	ldr	r0, [pc, #28]	; (c9c <EcuM_Init+0x40>)
     c7e:	f005 fc4d 	bl	651c <Port_Init>

    /* Init the FlexCAN2 with the paramters set in Tresos WITHOUT loop back mode */
    Can_43_FLEXCAN_Init( &Can_43_FLEXCAN_Config );
     c82:	4807      	ldr	r0, [pc, #28]	; (ca0 <EcuM_Init+0x44>)
     c84:	f006 fc3c 	bl	7500 <Can_43_FLEXCAN_Init>
    CanIf_Init( &CanIf_Config );
     c88:	4806      	ldr	r0, [pc, #24]	; (ca4 <EcuM_Init+0x48>)
     c8a:	f00e fda3 	bl	f7d4 <CanIf_Init>

    /* Initializing IO Hardware Abstractions with the module ID 0 */
    IoHwAb_Init0( NULL_PTR );
     c8e:	2000      	movs	r0, #0
     c90:	f000 fa1e 	bl	10d0 <IoHwAb_Init0>
}
     c94:	bf00      	nop
     c96:	bd08      	pop	{r3, pc}
     c98:	00010ba0 	.word	0x00010ba0
     c9c:	00011070 	.word	0x00011070
     ca0:	00010714 	.word	0x00010714
     ca4:	0001064c 	.word	0x0001064c

00000ca8 <Can_43_FLEXCAN_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Can_43_FLEXCAN_schm_read_msr(void)
{
     ca8:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     caa:	f3ef 8310 	mrs	r3, PRIMASK
     cae:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     cb0:	4623      	mov	r3, r4
}
     cb2:	4618      	mov	r0, r3
     cb4:	f85d 4b04 	ldr.w	r4, [sp], #4
     cb8:	4770      	bx	lr

00000cba <Dio_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Dio_schm_read_msr(void)
{
     cba:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     cbc:	f3ef 8310 	mrs	r3, PRIMASK
     cc0:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     cc2:	4623      	mov	r3, r4
}
     cc4:	4618      	mov	r0, r3
     cc6:	f85d 4b04 	ldr.w	r4, [sp], #4
     cca:	4770      	bx	lr

00000ccc <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     ccc:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     cce:	f3ef 8310 	mrs	r3, PRIMASK
     cd2:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     cd4:	4623      	mov	r3, r4
}
     cd6:	4618      	mov	r0, r3
     cd8:	f85d 4b04 	ldr.w	r4, [sp], #4
     cdc:	4770      	bx	lr

00000cde <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     cde:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     ce0:	f3ef 8310 	mrs	r3, PRIMASK
     ce4:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     ce6:	4623      	mov	r3, r4
}
     ce8:	4618      	mov	r0, r3
     cea:	f85d 4b04 	ldr.w	r4, [sp], #4
     cee:	4770      	bx	lr

00000cf0 <HwIoAb_Buttons_Init>:
 * the responsibility of the function to initialize any hardware. 
 * 
 * @param Buttons_Config Pointer to configuration array.
 */
void HwIoAb_Buttons_Init( const HwIoAb_Buttons_Config * Buttons_Config )
{
     cf0:	b084      	sub	sp, #16
     cf2:	9001      	str	r0, [sp, #4]
    ButtonsControl_Ptr->Buttons = HWIOAB_BUTTONS_MAX;
     cf4:	4b16      	ldr	r3, [pc, #88]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     cf6:	681b      	ldr	r3, [r3, #0]
     cf8:	2203      	movs	r2, #3
     cfa:	701a      	strb	r2, [r3, #0]
    ButtonsControl_Ptr->ButtonsConfig_Ptr = Buttons_Config;
     cfc:	4b14      	ldr	r3, [pc, #80]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     cfe:	681b      	ldr	r3, [r3, #0]
     d00:	9a01      	ldr	r2, [sp, #4]
     d02:	605a      	str	r2, [r3, #4]

    for(uint8 i = 0; i < ButtonsControl_Ptr->Buttons; i++)   // All button states and events to IDLE.
     d04:	2300      	movs	r3, #0
     d06:	f88d 300f 	strb.w	r3, [sp, #15]
     d0a:	e012      	b.n	d32 <HwIoAb_Buttons_Init+0x42>
    {
        ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_IDLE;
     d0c:	4b10      	ldr	r3, [pc, #64]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     d0e:	681a      	ldr	r2, [r3, #0]
     d10:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d14:	4413      	add	r3, r2
     d16:	2200      	movs	r2, #0
     d18:	721a      	strb	r2, [r3, #8]
        ButtonsControl_Ptr->Events[i] = HWIOAB_BTN_EVENT_IDLE;
     d1a:	4b0d      	ldr	r3, [pc, #52]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     d1c:	681a      	ldr	r2, [r3, #0]
     d1e:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d22:	4413      	add	r3, r2
     d24:	2200      	movs	r2, #0
     d26:	72da      	strb	r2, [r3, #11]
    for(uint8 i = 0; i < ButtonsControl_Ptr->Buttons; i++)   // All button states and events to IDLE.
     d28:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d2c:	3301      	adds	r3, #1
     d2e:	f88d 300f 	strb.w	r3, [sp, #15]
     d32:	4b07      	ldr	r3, [pc, #28]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     d34:	681b      	ldr	r3, [r3, #0]
     d36:	781b      	ldrb	r3, [r3, #0]
     d38:	f89d 200f 	ldrb.w	r2, [sp, #15]
     d3c:	429a      	cmp	r2, r3
     d3e:	d3e5      	bcc.n	d0c <HwIoAb_Buttons_Init+0x1c>
    }

    ButtonsControl_Ptr->Buttons_init = TRUE;
     d40:	4b03      	ldr	r3, [pc, #12]	; (d50 <HwIoAb_Buttons_Init+0x60>)
     d42:	681b      	ldr	r3, [r3, #0]
     d44:	2201      	movs	r2, #1
     d46:	739a      	strb	r2, [r3, #14]
}
     d48:	bf00      	nop
     d4a:	b004      	add	sp, #16
     d4c:	4770      	bx	lr
     d4e:	bf00      	nop
     d50:	1fff8b38 	.word	0x1fff8b38

00000d54 <HwIoAb_Buttons_GetEvent>:
 * @return event Last event detected in button.
 * 
 * @note The Button ID must be valid.
 */
uint8 HwIoAb_Buttons_GetEvent( uint8 Button )
{
     d54:	b084      	sub	sp, #16
     d56:	4603      	mov	r3, r0
     d58:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 temp = 0;
     d5c:	2300      	movs	r3, #0
     d5e:	f88d 300f 	strb.w	r3, [sp, #15]
    temp = ButtonsControl_Ptr->Events[Button];                      // Obtaining last event.
     d62:	4b0a      	ldr	r3, [pc, #40]	; (d8c <HwIoAb_Buttons_GetEvent+0x38>)
     d64:	681a      	ldr	r2, [r3, #0]
     d66:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d6a:	4413      	add	r3, r2
     d6c:	7adb      	ldrb	r3, [r3, #11]
     d6e:	f88d 300f 	strb.w	r3, [sp, #15]
    ButtonsControl_Ptr->Events[Button] = HWIOAB_BTN_EVENT_IDLE;     // Clearing event of button.
     d72:	4b06      	ldr	r3, [pc, #24]	; (d8c <HwIoAb_Buttons_GetEvent+0x38>)
     d74:	681a      	ldr	r2, [r3, #0]
     d76:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d7a:	4413      	add	r3, r2
     d7c:	2200      	movs	r2, #0
     d7e:	72da      	strb	r2, [r3, #11]
    return temp;
     d80:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     d84:	4618      	mov	r0, r3
     d86:	b004      	add	sp, #16
     d88:	4770      	bx	lr
     d8a:	bf00      	nop
     d8c:	1fff8b38 	.word	0x1fff8b38

00000d90 <HwIoAb_Buttons_MainFunction>:
 * @note Remember that the timeout count is for detecting a hold click when the button is pressed 1 and 2 times.
 * @note Each button has its own dedicated count.
 * 
 */
void HwIoAb_Buttons_MainFunction( void )
{
     d90:	b500      	push	{lr}
     d92:	b083      	sub	sp, #12
    static uint32 Counters[HWIOAB_BUTTONS_MAX] = {0, 0, 0};

    for( uint8 i = 0; i < ButtonsControl_Ptr->Buttons; i++ )    // Executing state machine for each button.
     d94:	2300      	movs	r3, #0
     d96:	f88d 3007 	strb.w	r3, [sp, #7]
     d9a:	e15d      	b.n	1058 <HwIoAb_Buttons_MainFunction+0x2c8>
    {
        switch( ButtonsControl_Ptr->States[i] )
     d9c:	4bb5      	ldr	r3, [pc, #724]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     d9e:	681a      	ldr	r2, [r3, #0]
     da0:	f89d 3007 	ldrb.w	r3, [sp, #7]
     da4:	4413      	add	r3, r2
     da6:	7a1b      	ldrb	r3, [r3, #8]
     da8:	2b04      	cmp	r3, #4
     daa:	f200 8145 	bhi.w	1038 <HwIoAb_Buttons_MainFunction+0x2a8>
     dae:	a201      	add	r2, pc, #4	; (adr r2, db4 <HwIoAb_Buttons_MainFunction+0x24>)
     db0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     db4:	00000dc9 	.word	0x00000dc9
     db8:	00000e15 	.word	0x00000e15
     dbc:	00000f3d 	.word	0x00000f3d
     dc0:	00000fd5 	.word	0x00000fd5
     dc4:	00000ea1 	.word	0x00000ea1
        {
            case HWIOAB_BTN_STATE_IDLE :
                // Query for the first time the button is pressed.
                if(Dio_ReadChannel( ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Button ) == ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Active)   // 0x0 = PRESSED
     dc8:	4baa      	ldr	r3, [pc, #680]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     dca:	681b      	ldr	r3, [r3, #0]
     dcc:	685a      	ldr	r2, [r3, #4]
     dce:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dd2:	00db      	lsls	r3, r3, #3
     dd4:	4413      	add	r3, r2
     dd6:	881b      	ldrh	r3, [r3, #0]
     dd8:	4618      	mov	r0, r3
     dda:	f006 f8b3 	bl	6f44 <Dio_ReadChannel>
     dde:	4603      	mov	r3, r0
     de0:	4619      	mov	r1, r3
     de2:	4ba4      	ldr	r3, [pc, #656]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     de4:	681b      	ldr	r3, [r3, #0]
     de6:	685a      	ldr	r2, [r3, #4]
     de8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dec:	00db      	lsls	r3, r3, #3
     dee:	4413      	add	r3, r2
     df0:	789b      	ldrb	r3, [r3, #2]
     df2:	4299      	cmp	r1, r3
     df4:	f040 8122 	bne.w	103c <HwIoAb_Buttons_MainFunction+0x2ac>
                {
                    // Start the 300ms counter if there is a press.
                    Counters[i] = 0;
     df8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dfc:	4a9e      	ldr	r2, [pc, #632]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     dfe:	2100      	movs	r1, #0
     e00:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_SINGLE_CLICK;
     e04:	4b9b      	ldr	r3, [pc, #620]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e06:	681a      	ldr	r2, [r3, #0]
     e08:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e0c:	4413      	add	r3, r2
     e0e:	2201      	movs	r2, #1
     e10:	721a      	strb	r2, [r3, #8]

                }
            break;
     e12:	e113      	b.n	103c <HwIoAb_Buttons_MainFunction+0x2ac>
            case HWIOAB_BTN_STATE_SINGLE_CLICK :
                Counters[i] += HWIOAB_BUTTONS_PERIOD;
     e14:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e18:	4a97      	ldr	r2, [pc, #604]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     e1a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     e1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e22:	320a      	adds	r2, #10
     e24:	4994      	ldr	r1, [pc, #592]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     e26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                // Query if there is a timeout, if the elapsed time is already equal or bigger than the timeout.
                if(Counters[i] == ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Timeout)
     e2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e2e:	4a92      	ldr	r2, [pc, #584]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     e30:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     e34:	4b8f      	ldr	r3, [pc, #572]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e36:	681b      	ldr	r3, [r3, #0]
     e38:	6859      	ldr	r1, [r3, #4]
     e3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e3e:	00db      	lsls	r3, r3, #3
     e40:	440b      	add	r3, r1
     e42:	685b      	ldr	r3, [r3, #4]
     e44:	429a      	cmp	r2, r3
     e46:	d106      	bne.n	e56 <HwIoAb_Buttons_MainFunction+0xc6>
                {
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_HOLD_CLICK;
     e48:	4b8a      	ldr	r3, [pc, #552]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e4a:	681a      	ldr	r2, [r3, #0]
     e4c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e50:	4413      	add	r3, r2
     e52:	2203      	movs	r2, #3
     e54:	721a      	strb	r2, [r3, #8]
                }

                // Query if there is a release.
                if(Dio_ReadChannel( ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Button ) == !ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Active)   // 0x1 = UNPRESSED
     e56:	4b87      	ldr	r3, [pc, #540]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e58:	681b      	ldr	r3, [r3, #0]
     e5a:	685a      	ldr	r2, [r3, #4]
     e5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e60:	00db      	lsls	r3, r3, #3
     e62:	4413      	add	r3, r2
     e64:	881b      	ldrh	r3, [r3, #0]
     e66:	4618      	mov	r0, r3
     e68:	f006 f86c 	bl	6f44 <Dio_ReadChannel>
     e6c:	4603      	mov	r3, r0
     e6e:	4619      	mov	r1, r3
     e70:	4b80      	ldr	r3, [pc, #512]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e72:	681b      	ldr	r3, [r3, #0]
     e74:	685a      	ldr	r2, [r3, #4]
     e76:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e7a:	00db      	lsls	r3, r3, #3
     e7c:	4413      	add	r3, r2
     e7e:	789b      	ldrb	r3, [r3, #2]
     e80:	2b00      	cmp	r3, #0
     e82:	bf0c      	ite	eq
     e84:	2301      	moveq	r3, #1
     e86:	2300      	movne	r3, #0
     e88:	b2db      	uxtb	r3, r3
     e8a:	4299      	cmp	r1, r3
     e8c:	f040 80d8 	bne.w	1040 <HwIoAb_Buttons_MainFunction+0x2b0>
                {
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_RELEASE;
     e90:	4b78      	ldr	r3, [pc, #480]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     e92:	681a      	ldr	r2, [r3, #0]
     e94:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e98:	4413      	add	r3, r2
     e9a:	2204      	movs	r2, #4
     e9c:	721a      	strb	r2, [r3, #8]
                }    
            break;
     e9e:	e0cf      	b.n	1040 <HwIoAb_Buttons_MainFunction+0x2b0>
            case HWIOAB_BTN_STATE_RELEASE :
                Counters[i] += HWIOAB_BUTTONS_PERIOD;
     ea0:	f89d 3007 	ldrb.w	r3, [sp, #7]
     ea4:	4a74      	ldr	r2, [pc, #464]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     ea6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     eaa:	f89d 3007 	ldrb.w	r3, [sp, #7]
     eae:	320a      	adds	r2, #10
     eb0:	4971      	ldr	r1, [pc, #452]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     eb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                // Query if timeout, if timeout is a single click.
                if(Counters[i] == ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Timeout)
     eb6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     eba:	4a6f      	ldr	r2, [pc, #444]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     ebc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     ec0:	4b6c      	ldr	r3, [pc, #432]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     ec2:	681b      	ldr	r3, [r3, #0]
     ec4:	6859      	ldr	r1, [r3, #4]
     ec6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     eca:	00db      	lsls	r3, r3, #3
     ecc:	440b      	add	r3, r1
     ece:	685b      	ldr	r3, [r3, #4]
     ed0:	429a      	cmp	r2, r3
     ed2:	d10d      	bne.n	ef0 <HwIoAb_Buttons_MainFunction+0x160>
                {
                    ButtonsControl_Ptr->Events[i] = HWIOAB_BTN_EVENT_SINGLE_CLICK;
     ed4:	4b67      	ldr	r3, [pc, #412]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     ed6:	681a      	ldr	r2, [r3, #0]
     ed8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     edc:	4413      	add	r3, r2
     ede:	2201      	movs	r2, #1
     ee0:	72da      	strb	r2, [r3, #11]
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_IDLE;
     ee2:	4b64      	ldr	r3, [pc, #400]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     ee4:	681a      	ldr	r2, [r3, #0]
     ee6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     eea:	4413      	add	r3, r2
     eec:	2200      	movs	r2, #0
     eee:	721a      	strb	r2, [r3, #8]
                } 

                // Query if a press, if press start 300ms counter again.
                if(Dio_ReadChannel( ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Button ) == ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Active)   // 0x0 = PRESSED
     ef0:	4b60      	ldr	r3, [pc, #384]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     ef2:	681b      	ldr	r3, [r3, #0]
     ef4:	685a      	ldr	r2, [r3, #4]
     ef6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     efa:	00db      	lsls	r3, r3, #3
     efc:	4413      	add	r3, r2
     efe:	881b      	ldrh	r3, [r3, #0]
     f00:	4618      	mov	r0, r3
     f02:	f006 f81f 	bl	6f44 <Dio_ReadChannel>
     f06:	4603      	mov	r3, r0
     f08:	4619      	mov	r1, r3
     f0a:	4b5a      	ldr	r3, [pc, #360]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f0c:	681b      	ldr	r3, [r3, #0]
     f0e:	685a      	ldr	r2, [r3, #4]
     f10:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f14:	00db      	lsls	r3, r3, #3
     f16:	4413      	add	r3, r2
     f18:	789b      	ldrb	r3, [r3, #2]
     f1a:	4299      	cmp	r1, r3
     f1c:	f040 8092 	bne.w	1044 <HwIoAb_Buttons_MainFunction+0x2b4>
                {
                    // Restart the 300ms counter if there is a press.
                    Counters[i] = 0;
     f20:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f24:	4a54      	ldr	r2, [pc, #336]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     f26:	2100      	movs	r1, #0
     f28:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_DOUBLE_CLICK;
     f2c:	4b51      	ldr	r3, [pc, #324]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f2e:	681a      	ldr	r2, [r3, #0]
     f30:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f34:	4413      	add	r3, r2
     f36:	2202      	movs	r2, #2
     f38:	721a      	strb	r2, [r3, #8]
                } 
            break;
     f3a:	e083      	b.n	1044 <HwIoAb_Buttons_MainFunction+0x2b4>
            case HWIOAB_BTN_STATE_DOUBLE_CLICK :
                Counters[i] += HWIOAB_BUTTONS_PERIOD;
     f3c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f40:	4a4d      	ldr	r2, [pc, #308]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     f42:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     f46:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f4a:	320a      	adds	r2, #10
     f4c:	494a      	ldr	r1, [pc, #296]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     f4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                // Query if timeout, if timeout is hold 
                if(Counters[i] == ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Timeout)
     f52:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f56:	4a48      	ldr	r2, [pc, #288]	; (1078 <HwIoAb_Buttons_MainFunction+0x2e8>)
     f58:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     f5c:	4b45      	ldr	r3, [pc, #276]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f5e:	681b      	ldr	r3, [r3, #0]
     f60:	6859      	ldr	r1, [r3, #4]
     f62:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f66:	00db      	lsls	r3, r3, #3
     f68:	440b      	add	r3, r1
     f6a:	685b      	ldr	r3, [r3, #4]
     f6c:	429a      	cmp	r2, r3
     f6e:	d106      	bne.n	f7e <HwIoAb_Buttons_MainFunction+0x1ee>
                {
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_HOLD_CLICK;
     f70:	4b40      	ldr	r3, [pc, #256]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f72:	681a      	ldr	r2, [r3, #0]
     f74:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f78:	4413      	add	r3, r2
     f7a:	2203      	movs	r2, #3
     f7c:	721a      	strb	r2, [r3, #8]
                } 

                // Query if release, if release is a double click
                if(Dio_ReadChannel( ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Button ) == !ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Active)   // 0x1 = UNPRESSED
     f7e:	4b3d      	ldr	r3, [pc, #244]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f80:	681b      	ldr	r3, [r3, #0]
     f82:	685a      	ldr	r2, [r3, #4]
     f84:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f88:	00db      	lsls	r3, r3, #3
     f8a:	4413      	add	r3, r2
     f8c:	881b      	ldrh	r3, [r3, #0]
     f8e:	4618      	mov	r0, r3
     f90:	f005 ffd8 	bl	6f44 <Dio_ReadChannel>
     f94:	4603      	mov	r3, r0
     f96:	4619      	mov	r1, r3
     f98:	4b36      	ldr	r3, [pc, #216]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     f9a:	681b      	ldr	r3, [r3, #0]
     f9c:	685a      	ldr	r2, [r3, #4]
     f9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fa2:	00db      	lsls	r3, r3, #3
     fa4:	4413      	add	r3, r2
     fa6:	789b      	ldrb	r3, [r3, #2]
     fa8:	2b00      	cmp	r3, #0
     faa:	bf0c      	ite	eq
     fac:	2301      	moveq	r3, #1
     fae:	2300      	movne	r3, #0
     fb0:	b2db      	uxtb	r3, r3
     fb2:	4299      	cmp	r1, r3
     fb4:	d148      	bne.n	1048 <HwIoAb_Buttons_MainFunction+0x2b8>
                {
                    ButtonsControl_Ptr->Events[i] = HWIOAB_BTN_EVENT_DOUBLE_CLICK;
     fb6:	4b2f      	ldr	r3, [pc, #188]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     fb8:	681a      	ldr	r2, [r3, #0]
     fba:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fbe:	4413      	add	r3, r2
     fc0:	2202      	movs	r2, #2
     fc2:	72da      	strb	r2, [r3, #11]
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_IDLE;
     fc4:	4b2b      	ldr	r3, [pc, #172]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     fc6:	681a      	ldr	r2, [r3, #0]
     fc8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fcc:	4413      	add	r3, r2
     fce:	2200      	movs	r2, #0
     fd0:	721a      	strb	r2, [r3, #8]
                } 
            break;
     fd2:	e039      	b.n	1048 <HwIoAb_Buttons_MainFunction+0x2b8>
            case HWIOAB_BTN_STATE_HOLD_CLICK :
                ButtonsControl_Ptr->Events[i] = HWIOAB_BTN_EVENT_HOLD_CLICK;
     fd4:	4b27      	ldr	r3, [pc, #156]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     fd6:	681a      	ldr	r2, [r3, #0]
     fd8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fdc:	4413      	add	r3, r2
     fde:	2203      	movs	r2, #3
     fe0:	72da      	strb	r2, [r3, #11]
                // If state jumps here is a hold click, wait until botton is released and go back to IDLE
                if(Dio_ReadChannel( ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Button ) == !ButtonsControl_Ptr->ButtonsConfig_Ptr[i].Active)   // 0x1 = UNPRESSED
     fe2:	4b24      	ldr	r3, [pc, #144]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     fe4:	681b      	ldr	r3, [r3, #0]
     fe6:	685a      	ldr	r2, [r3, #4]
     fe8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fec:	00db      	lsls	r3, r3, #3
     fee:	4413      	add	r3, r2
     ff0:	881b      	ldrh	r3, [r3, #0]
     ff2:	4618      	mov	r0, r3
     ff4:	f005 ffa6 	bl	6f44 <Dio_ReadChannel>
     ff8:	4603      	mov	r3, r0
     ffa:	4619      	mov	r1, r3
     ffc:	4b1d      	ldr	r3, [pc, #116]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
     ffe:	681b      	ldr	r3, [r3, #0]
    1000:	685a      	ldr	r2, [r3, #4]
    1002:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1006:	00db      	lsls	r3, r3, #3
    1008:	4413      	add	r3, r2
    100a:	789b      	ldrb	r3, [r3, #2]
    100c:	2b00      	cmp	r3, #0
    100e:	bf0c      	ite	eq
    1010:	2301      	moveq	r3, #1
    1012:	2300      	movne	r3, #0
    1014:	b2db      	uxtb	r3, r3
    1016:	4299      	cmp	r1, r3
    1018:	d118      	bne.n	104c <HwIoAb_Buttons_MainFunction+0x2bc>
                {
                    ButtonsControl_Ptr->Events[i] = HWIOAB_BTN_EVENT_RELEASE;
    101a:	4b16      	ldr	r3, [pc, #88]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
    101c:	681a      	ldr	r2, [r3, #0]
    101e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1022:	4413      	add	r3, r2
    1024:	2204      	movs	r2, #4
    1026:	72da      	strb	r2, [r3, #11]
                    ButtonsControl_Ptr->States[i] = HWIOAB_BTN_STATE_IDLE;
    1028:	4b12      	ldr	r3, [pc, #72]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
    102a:	681a      	ldr	r2, [r3, #0]
    102c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1030:	4413      	add	r3, r2
    1032:	2200      	movs	r2, #0
    1034:	721a      	strb	r2, [r3, #8]
                }
            break;
    1036:	e009      	b.n	104c <HwIoAb_Buttons_MainFunction+0x2bc>
            default :
              // If jump here is an error
            break;
    1038:	bf00      	nop
    103a:	e008      	b.n	104e <HwIoAb_Buttons_MainFunction+0x2be>
            break;
    103c:	bf00      	nop
    103e:	e006      	b.n	104e <HwIoAb_Buttons_MainFunction+0x2be>
            break;
    1040:	bf00      	nop
    1042:	e004      	b.n	104e <HwIoAb_Buttons_MainFunction+0x2be>
            break;
    1044:	bf00      	nop
    1046:	e002      	b.n	104e <HwIoAb_Buttons_MainFunction+0x2be>
            break;
    1048:	bf00      	nop
    104a:	e000      	b.n	104e <HwIoAb_Buttons_MainFunction+0x2be>
            break;
    104c:	bf00      	nop
    for( uint8 i = 0; i < ButtonsControl_Ptr->Buttons; i++ )    // Executing state machine for each button.
    104e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1052:	3301      	adds	r3, #1
    1054:	f88d 3007 	strb.w	r3, [sp, #7]
    1058:	4b06      	ldr	r3, [pc, #24]	; (1074 <HwIoAb_Buttons_MainFunction+0x2e4>)
    105a:	681b      	ldr	r3, [r3, #0]
    105c:	781b      	ldrb	r3, [r3, #0]
    105e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    1062:	429a      	cmp	r2, r3
    1064:	f4ff ae9a 	bcc.w	d9c <HwIoAb_Buttons_MainFunction+0xc>
        }
    }
}   
    1068:	bf00      	nop
    106a:	bf00      	nop
    106c:	b003      	add	sp, #12
    106e:	f85d fb04 	ldr.w	pc, [sp], #4
    1072:	bf00      	nop
    1074:	1fff8b38 	.word	0x1fff8b38
    1078:	1fff91c4 	.word	0x1fff91c4

0000107c <HwIoAb_Leds_Init>:
 * the responsibility of the function to initialize any hardware. 
 * 
 * @param Leds_Config Pointer to configuration array.
 */
void HwIoAb_Leds_Init( const HwIoAb_Leds_Config * Leds_Config )
{
    107c:	b082      	sub	sp, #8
    107e:	9001      	str	r0, [sp, #4]
    LedsControl_Ptr->Leds = HWIOAB_LEDS_MAX;
    1080:	4b07      	ldr	r3, [pc, #28]	; (10a0 <HwIoAb_Leds_Init+0x24>)
    1082:	681b      	ldr	r3, [r3, #0]
    1084:	220b      	movs	r2, #11
    1086:	701a      	strb	r2, [r3, #0]
    LedsControl_Ptr->LedsConfig_Ptr = Leds_Config;
    1088:	4b05      	ldr	r3, [pc, #20]	; (10a0 <HwIoAb_Leds_Init+0x24>)
    108a:	681b      	ldr	r3, [r3, #0]
    108c:	9a01      	ldr	r2, [sp, #4]
    108e:	605a      	str	r2, [r3, #4]
    LedsControl_Ptr->Leds_init = TRUE;
    1090:	4b03      	ldr	r3, [pc, #12]	; (10a0 <HwIoAb_Leds_Init+0x24>)
    1092:	681b      	ldr	r3, [r3, #0]
    1094:	2201      	movs	r2, #1
    1096:	721a      	strb	r2, [r3, #8]
}
    1098:	bf00      	nop
    109a:	b002      	add	sp, #8
    109c:	4770      	bx	lr
    109e:	bf00      	nop
    10a0:	1fff8b3c 	.word	0x1fff8b3c

000010a4 <HwIoAb_Leds_TurnToggle>:
 * @param Led Led ID.
 * 
 * @note The led ID must be valid.
 */
void HwIoAb_Leds_TurnToggle( uint8 Led ) 
{
    10a4:	b500      	push	{lr}
    10a6:	b083      	sub	sp, #12
    10a8:	4603      	mov	r3, r0
    10aa:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_FlipChannel( LedsControl_Ptr->LedsConfig_Ptr[ Led ].Led );
    10ae:	4b07      	ldr	r3, [pc, #28]	; (10cc <HwIoAb_Leds_TurnToggle+0x28>)
    10b0:	681b      	ldr	r3, [r3, #0]
    10b2:	685a      	ldr	r2, [r3, #4]
    10b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    10b8:	009b      	lsls	r3, r3, #2
    10ba:	4413      	add	r3, r2
    10bc:	881b      	ldrh	r3, [r3, #0]
    10be:	4618      	mov	r0, r3
    10c0:	f005 ff6b 	bl	6f9a <Dio_FlipChannel>
}
    10c4:	bf00      	nop
    10c6:	b003      	add	sp, #12
    10c8:	f85d fb04 	ldr.w	pc, [sp], #4
    10cc:	1fff8b3c 	.word	0x1fff8b3c

000010d0 <IoHwAb_Init0>:
 * @brief This function initialices all the IO hardware abstractions.
 * 
 * @param ConfigPtr Pointer to configuration structure instance, in this case is not used.
 */
void IoHwAb_Init0( const IoHwAb0_ConfigType* ConfigPtr ) 
{
    10d0:	b500      	push	{lr}
    10d2:	b083      	sub	sp, #12
    10d4:	9001      	str	r0, [sp, #4]
    /* Buttons init */
    HwIoAb_Buttons_Init( &ButtonsCfg );
    10d6:	4805      	ldr	r0, [pc, #20]	; (10ec <IoHwAb_Init0+0x1c>)
    10d8:	f7ff fe0a 	bl	cf0 <HwIoAb_Buttons_Init>
    /* RGB Leds init */
    HwIoAb_Leds_Init( &LedsCfg );
    10dc:	4804      	ldr	r0, [pc, #16]	; (10f0 <IoHwAb_Init0+0x20>)
    10de:	f7ff ffcd 	bl	107c <HwIoAb_Leds_Init>
    /* Pots init */
    //HwIoAb_Pots_Init( NULL_PTR );
    /* Buzzer init */
    //HwIoAb_Buzzer_Init( NULL_PTR );
}
    10e2:	bf00      	nop
    10e4:	b003      	add	sp, #12
    10e6:	f85d fb04 	ldr.w	pc, [sp], #4
    10ea:	bf00      	nop
    10ec:	000105a0 	.word	0x000105a0
    10f0:	000105b8 	.word	0x000105b8

000010f4 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
    10f4:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
    10f6:	2300      	movs	r3, #0
    10f8:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
    10fa:	2300      	movs	r3, #0
    10fc:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
    10fe:	2300      	movs	r3, #0
    1100:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
    1102:	2300      	movs	r3, #0
    1104:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
    1106:	4b44      	ldr	r3, [pc, #272]	; (1218 <init_data_bss+0x124>)
    1108:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
    110a:	4b44      	ldr	r3, [pc, #272]	; (121c <init_data_bss+0x128>)
    110c:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
    110e:	9b05      	ldr	r3, [sp, #20]
    1110:	681b      	ldr	r3, [r3, #0]
    1112:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
    1114:	9b05      	ldr	r3, [sp, #20]
    1116:	3304      	adds	r3, #4
    1118:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    111a:	9b05      	ldr	r3, [sp, #20]
    111c:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
    111e:	2300      	movs	r3, #0
    1120:	9309      	str	r3, [sp, #36]	; 0x24
    1122:	e03d      	b.n	11a0 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
    1124:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1126:	4613      	mov	r3, r2
    1128:	005b      	lsls	r3, r3, #1
    112a:	4413      	add	r3, r2
    112c:	009b      	lsls	r3, r3, #2
    112e:	461a      	mov	r2, r3
    1130:	9b03      	ldr	r3, [sp, #12]
    1132:	4413      	add	r3, r2
    1134:	685b      	ldr	r3, [r3, #4]
    1136:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
    1138:	9a09      	ldr	r2, [sp, #36]	; 0x24
    113a:	4613      	mov	r3, r2
    113c:	005b      	lsls	r3, r3, #1
    113e:	4413      	add	r3, r2
    1140:	009b      	lsls	r3, r3, #2
    1142:	461a      	mov	r2, r3
    1144:	9b03      	ldr	r3, [sp, #12]
    1146:	4413      	add	r3, r2
    1148:	681b      	ldr	r3, [r3, #0]
    114a:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
    114c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    114e:	4613      	mov	r3, r2
    1150:	005b      	lsls	r3, r3, #1
    1152:	4413      	add	r3, r2
    1154:	009b      	lsls	r3, r3, #2
    1156:	461a      	mov	r2, r3
    1158:	9b03      	ldr	r3, [sp, #12]
    115a:	4413      	add	r3, r2
    115c:	689b      	ldr	r3, [r3, #8]
    115e:	4619      	mov	r1, r3
    1160:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1162:	4613      	mov	r3, r2
    1164:	005b      	lsls	r3, r3, #1
    1166:	4413      	add	r3, r2
    1168:	009b      	lsls	r3, r3, #2
    116a:	461a      	mov	r2, r3
    116c:	9b03      	ldr	r3, [sp, #12]
    116e:	4413      	add	r3, r2
    1170:	685b      	ldr	r3, [r3, #4]
    1172:	1acb      	subs	r3, r1, r3
    1174:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
    1176:	2300      	movs	r3, #0
    1178:	9308      	str	r3, [sp, #32]
    117a:	e00a      	b.n	1192 <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
    117c:	9a00      	ldr	r2, [sp, #0]
    117e:	9b08      	ldr	r3, [sp, #32]
    1180:	441a      	add	r2, r3
    1182:	9901      	ldr	r1, [sp, #4]
    1184:	9b08      	ldr	r3, [sp, #32]
    1186:	440b      	add	r3, r1
    1188:	7812      	ldrb	r2, [r2, #0]
    118a:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
    118c:	9b08      	ldr	r3, [sp, #32]
    118e:	3301      	adds	r3, #1
    1190:	9308      	str	r3, [sp, #32]
    1192:	9a08      	ldr	r2, [sp, #32]
    1194:	9b06      	ldr	r3, [sp, #24]
    1196:	429a      	cmp	r2, r3
    1198:	d3f0      	bcc.n	117c <init_data_bss+0x88>
    for(i = 0; i < len; i++)
    119a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    119c:	3301      	adds	r3, #1
    119e:	9309      	str	r3, [sp, #36]	; 0x24
    11a0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    11a2:	9b07      	ldr	r3, [sp, #28]
    11a4:	429a      	cmp	r2, r3
    11a6:	d3bd      	bcc.n	1124 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
    11a8:	9b04      	ldr	r3, [sp, #16]
    11aa:	681b      	ldr	r3, [r3, #0]
    11ac:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
    11ae:	9b04      	ldr	r3, [sp, #16]
    11b0:	3304      	adds	r3, #4
    11b2:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
    11b4:	9b04      	ldr	r3, [sp, #16]
    11b6:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
    11b8:	2300      	movs	r3, #0
    11ba:	9309      	str	r3, [sp, #36]	; 0x24
    11bc:	e024      	b.n	1208 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
    11be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11c0:	00db      	lsls	r3, r3, #3
    11c2:	9a02      	ldr	r2, [sp, #8]
    11c4:	4413      	add	r3, r2
    11c6:	681b      	ldr	r3, [r3, #0]
    11c8:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
    11ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11cc:	00db      	lsls	r3, r3, #3
    11ce:	9a02      	ldr	r2, [sp, #8]
    11d0:	4413      	add	r3, r2
    11d2:	685b      	ldr	r3, [r3, #4]
    11d4:	4619      	mov	r1, r3
    11d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11d8:	00db      	lsls	r3, r3, #3
    11da:	9a02      	ldr	r2, [sp, #8]
    11dc:	4413      	add	r3, r2
    11de:	681b      	ldr	r3, [r3, #0]
    11e0:	1acb      	subs	r3, r1, r3
    11e2:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
    11e4:	2300      	movs	r3, #0
    11e6:	9308      	str	r3, [sp, #32]
    11e8:	e007      	b.n	11fa <init_data_bss+0x106>
        {
            ram[j] = 0U;
    11ea:	9a01      	ldr	r2, [sp, #4]
    11ec:	9b08      	ldr	r3, [sp, #32]
    11ee:	4413      	add	r3, r2
    11f0:	2200      	movs	r2, #0
    11f2:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
    11f4:	9b08      	ldr	r3, [sp, #32]
    11f6:	3301      	adds	r3, #1
    11f8:	9308      	str	r3, [sp, #32]
    11fa:	9a08      	ldr	r2, [sp, #32]
    11fc:	9b06      	ldr	r3, [sp, #24]
    11fe:	429a      	cmp	r2, r3
    1200:	d3f3      	bcc.n	11ea <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
    1202:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1204:	3301      	adds	r3, #1
    1206:	9309      	str	r3, [sp, #36]	; 0x24
    1208:	9a09      	ldr	r2, [sp, #36]	; 0x24
    120a:	9b07      	ldr	r3, [sp, #28]
    120c:	429a      	cmp	r2, r3
    120e:	d3d6      	bcc.n	11be <init_data_bss+0xca>
        }
    }
}
    1210:	bf00      	nop
    1212:	bf00      	nop
    1214:	b00a      	add	sp, #40	; 0x28
    1216:	4770      	bx	lr
    1218:	000110e0 	.word	0x000110e0
    121c:	000110fc 	.word	0x000110fc

00001220 <sys_m4_cache_init>:
{
    1220:	b084      	sub	sp, #16
    1222:	4603      	mov	r3, r0
    1224:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
    1228:	2300      	movs	r3, #0
    122a:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
    122e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1232:	2b00      	cmp	r3, #0
    1234:	d118      	bne.n	1268 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
    1236:	4b10      	ldr	r3, [pc, #64]	; (1278 <sys_m4_cache_init+0x58>)
    1238:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
    123c:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
    123e:	4b0e      	ldr	r3, [pc, #56]	; (1278 <sys_m4_cache_init+0x58>)
    1240:	681b      	ldr	r3, [r3, #0]
    1242:	4a0d      	ldr	r2, [pc, #52]	; (1278 <sys_m4_cache_init+0x58>)
    1244:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    1248:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
    124a:	bf00      	nop
    124c:	4b0a      	ldr	r3, [pc, #40]	; (1278 <sys_m4_cache_init+0x58>)
    124e:	681b      	ldr	r3, [r3, #0]
    1250:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    1254:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    1258:	d0f8      	beq.n	124c <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
    125a:	4b07      	ldr	r3, [pc, #28]	; (1278 <sys_m4_cache_init+0x58>)
    125c:	681b      	ldr	r3, [r3, #0]
    125e:	4a06      	ldr	r2, [pc, #24]	; (1278 <sys_m4_cache_init+0x58>)
    1260:	f043 0301 	orr.w	r3, r3, #1
    1264:	6013      	str	r3, [r2, #0]
    1266:	e002      	b.n	126e <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
    1268:	2301      	movs	r3, #1
    126a:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
    126e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1272:	4618      	mov	r0, r3
    1274:	b004      	add	sp, #16
    1276:	4770      	bx	lr
    1278:	e0082000 	.word	0xe0082000

0000127c <startup_go_to_user_mode>:
}
    127c:	bf00      	nop
    127e:	4770      	bx	lr

00001280 <Sys_GetCoreID>:
    return 0U;
    1280:	2300      	movs	r3, #0
}
    1282:	4618      	mov	r0, r3
    1284:	4770      	bx	lr

00001286 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
    1286:	e7fe      	b.n	1286 <HardFault_Handler>

00001288 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
    1288:	e7fe      	b.n	1288 <MemManage_Handler>

0000128a <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
    128a:	e7fe      	b.n	128a <BusFault_Handler>

0000128c <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
    128c:	e7fe      	b.n	128c <UsageFault_Handler>

0000128e <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
    128e:	e7fe      	b.n	128e <SVC_Handler>

00001290 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
    1290:	e7fe      	b.n	1290 <DebugMon_Handler>

00001292 <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
    1292:	e7fe      	b.n	1292 <PendSV_Handler>

00001294 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
    1294:	e7fe      	b.n	1294 <SysTick_Handler>

00001296 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
    1296:	e7fe      	b.n	1296 <undefined_handler>

00001298 <_DoInit>:
      if (pRTTCBInit->acID[0] != 'S') {                                                      \
        _DoInit();                                                                           \
      }                                                                                      \
    } while (0)

static void _DoInit(void) {
    1298:	b500      	push	{lr}
    129a:	b083      	sub	sp, #12
  static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
    129c:	4b26      	ldr	r3, [pc, #152]	; (1338 <_DoInit+0xa0>)
    129e:	9300      	str	r3, [sp, #0]
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    12a0:	22a8      	movs	r2, #168	; 0xa8
    12a2:	2100      	movs	r1, #0
    12a4:	9800      	ldr	r0, [sp, #0]
    12a6:	f000 fd13 	bl	1cd0 <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    12aa:	9b00      	ldr	r3, [sp, #0]
    12ac:	2203      	movs	r2, #3
    12ae:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    12b0:	9b00      	ldr	r3, [sp, #0]
    12b2:	2203      	movs	r2, #3
    12b4:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    12b6:	9b00      	ldr	r3, [sp, #0]
    12b8:	4a20      	ldr	r2, [pc, #128]	; (133c <_DoInit+0xa4>)
    12ba:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    12bc:	9b00      	ldr	r3, [sp, #0]
    12be:	4a20      	ldr	r2, [pc, #128]	; (1340 <_DoInit+0xa8>)
    12c0:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    12c2:	9b00      	ldr	r3, [sp, #0]
    12c4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    12c8:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
    12ca:	9b00      	ldr	r3, [sp, #0]
    12cc:	2200      	movs	r2, #0
    12ce:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    12d0:	9b00      	ldr	r3, [sp, #0]
    12d2:	2200      	movs	r2, #0
    12d4:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    12d6:	9b00      	ldr	r3, [sp, #0]
    12d8:	2200      	movs	r2, #0
    12da:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    12dc:	9b00      	ldr	r3, [sp, #0]
    12de:	4a17      	ldr	r2, [pc, #92]	; (133c <_DoInit+0xa4>)
    12e0:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    12e2:	9b00      	ldr	r3, [sp, #0]
    12e4:	4a17      	ldr	r2, [pc, #92]	; (1344 <_DoInit+0xac>)
    12e6:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    12e8:	9b00      	ldr	r3, [sp, #0]
    12ea:	2210      	movs	r2, #16
    12ec:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    12ee:	9b00      	ldr	r3, [sp, #0]
    12f0:	2200      	movs	r2, #0
    12f2:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    12f4:	9b00      	ldr	r3, [sp, #0]
    12f6:	2200      	movs	r2, #0
    12f8:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    12fa:	9b00      	ldr	r3, [sp, #0]
    12fc:	2200      	movs	r2, #0
    12fe:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    1300:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    1304:	2300      	movs	r3, #0
    1306:	9301      	str	r3, [sp, #4]
    1308:	e00c      	b.n	1324 <_DoInit+0x8c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
    130a:	9b01      	ldr	r3, [sp, #4]
    130c:	f1c3 030f 	rsb	r3, r3, #15
    1310:	4a0d      	ldr	r2, [pc, #52]	; (1348 <_DoInit+0xb0>)
    1312:	5cd1      	ldrb	r1, [r2, r3]
    1314:	9a00      	ldr	r2, [sp, #0]
    1316:	9b01      	ldr	r3, [sp, #4]
    1318:	4413      	add	r3, r2
    131a:	460a      	mov	r2, r1
    131c:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    131e:	9b01      	ldr	r3, [sp, #4]
    1320:	3301      	adds	r3, #1
    1322:	9301      	str	r3, [sp, #4]
    1324:	9b01      	ldr	r3, [sp, #4]
    1326:	2b0f      	cmp	r3, #15
    1328:	d9ef      	bls.n	130a <_DoInit+0x72>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    132a:	f3bf 8f5f 	dmb	sy
}
    132e:	bf00      	nop
    1330:	b003      	add	sp, #12
    1332:	f85d fb04 	ldr.w	pc, [sp], #4
    1336:	bf00      	nop
    1338:	1fff91e0 	.word	0x1fff91e0
    133c:	0000fd70 	.word	0x0000fd70
    1340:	1fff9288 	.word	0x1fff9288
    1344:	1fff9688 	.word	0x1fff9688
    1348:	000110bc 	.word	0x000110bc

0000134c <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    134c:	b500      	push	{lr}
    134e:	b08b      	sub	sp, #44	; 0x2c
    1350:	9003      	str	r0, [sp, #12]
    1352:	9102      	str	r1, [sp, #8]
    1354:	9201      	str	r2, [sp, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
    1356:	2300      	movs	r3, #0
    1358:	9308      	str	r3, [sp, #32]
  WrOff = pRing->WrOff;
    135a:	9b03      	ldr	r3, [sp, #12]
    135c:	68db      	ldr	r3, [r3, #12]
    135e:	9307      	str	r3, [sp, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    1360:	9b03      	ldr	r3, [sp, #12]
    1362:	691b      	ldr	r3, [r3, #16]
    1364:	9306      	str	r3, [sp, #24]
    if (RdOff > WrOff) {
    1366:	9a06      	ldr	r2, [sp, #24]
    1368:	9b07      	ldr	r3, [sp, #28]
    136a:	429a      	cmp	r2, r3
    136c:	d905      	bls.n	137a <_WriteBlocking+0x2e>
      NumBytesToWrite = RdOff - WrOff - 1u;
    136e:	9a06      	ldr	r2, [sp, #24]
    1370:	9b07      	ldr	r3, [sp, #28]
    1372:	1ad3      	subs	r3, r2, r3
    1374:	3b01      	subs	r3, #1
    1376:	9309      	str	r3, [sp, #36]	; 0x24
    1378:	e007      	b.n	138a <_WriteBlocking+0x3e>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    137a:	9b03      	ldr	r3, [sp, #12]
    137c:	689a      	ldr	r2, [r3, #8]
    137e:	9906      	ldr	r1, [sp, #24]
    1380:	9b07      	ldr	r3, [sp, #28]
    1382:	1acb      	subs	r3, r1, r3
    1384:	4413      	add	r3, r2
    1386:	3b01      	subs	r3, #1
    1388:	9309      	str	r3, [sp, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    138a:	9b03      	ldr	r3, [sp, #12]
    138c:	689a      	ldr	r2, [r3, #8]
    138e:	9b07      	ldr	r3, [sp, #28]
    1390:	1ad3      	subs	r3, r2, r3
    1392:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1394:	4293      	cmp	r3, r2
    1396:	bf28      	it	cs
    1398:	4613      	movcs	r3, r2
    139a:	9309      	str	r3, [sp, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    139c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    139e:	9b01      	ldr	r3, [sp, #4]
    13a0:	4293      	cmp	r3, r2
    13a2:	bf28      	it	cs
    13a4:	4613      	movcs	r3, r2
    13a6:	9309      	str	r3, [sp, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    13a8:	9b03      	ldr	r3, [sp, #12]
    13aa:	685a      	ldr	r2, [r3, #4]
    13ac:	9b07      	ldr	r3, [sp, #28]
    13ae:	4413      	add	r3, r2
    13b0:	9305      	str	r3, [sp, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    13b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    13b4:	9902      	ldr	r1, [sp, #8]
    13b6:	9805      	ldr	r0, [sp, #20]
    13b8:	f000 fc7c 	bl	1cb4 <memcpy>
    NumBytesWritten += NumBytesToWrite;
    13bc:	9a08      	ldr	r2, [sp, #32]
    13be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    13c0:	4413      	add	r3, r2
    13c2:	9308      	str	r3, [sp, #32]
    pBuffer         += NumBytesToWrite;
    13c4:	9a02      	ldr	r2, [sp, #8]
    13c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    13c8:	4413      	add	r3, r2
    13ca:	9302      	str	r3, [sp, #8]
    NumBytes        -= NumBytesToWrite;
    13cc:	9a01      	ldr	r2, [sp, #4]
    13ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
    13d0:	1ad3      	subs	r3, r2, r3
    13d2:	9301      	str	r3, [sp, #4]
    WrOff           += NumBytesToWrite;
    13d4:	9a07      	ldr	r2, [sp, #28]
    13d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    13d8:	4413      	add	r3, r2
    13da:	9307      	str	r3, [sp, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
    13dc:	9b03      	ldr	r3, [sp, #12]
    13de:	689b      	ldr	r3, [r3, #8]
    13e0:	9a07      	ldr	r2, [sp, #28]
    13e2:	429a      	cmp	r2, r3
    13e4:	d101      	bne.n	13ea <_WriteBlocking+0x9e>
      WrOff = 0u;
    13e6:	2300      	movs	r3, #0
    13e8:	9307      	str	r3, [sp, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    13ea:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
    13ee:	9b03      	ldr	r3, [sp, #12]
    13f0:	9a07      	ldr	r2, [sp, #28]
    13f2:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
    13f4:	9b01      	ldr	r3, [sp, #4]
    13f6:	2b00      	cmp	r3, #0
    13f8:	d1b2      	bne.n	1360 <_WriteBlocking+0x14>
  return NumBytesWritten;
    13fa:	9b08      	ldr	r3, [sp, #32]
}
    13fc:	4618      	mov	r0, r3
    13fe:	b00b      	add	sp, #44	; 0x2c
    1400:	f85d fb04 	ldr.w	pc, [sp], #4

00001404 <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    1404:	b500      	push	{lr}
    1406:	b089      	sub	sp, #36	; 0x24
    1408:	9003      	str	r0, [sp, #12]
    140a:	9102      	str	r1, [sp, #8]
    140c:	9201      	str	r2, [sp, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
    140e:	9b03      	ldr	r3, [sp, #12]
    1410:	68db      	ldr	r3, [r3, #12]
    1412:	9307      	str	r3, [sp, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
    1414:	9b03      	ldr	r3, [sp, #12]
    1416:	689a      	ldr	r2, [r3, #8]
    1418:	9b07      	ldr	r3, [sp, #28]
    141a:	1ad3      	subs	r3, r2, r3
    141c:	9306      	str	r3, [sp, #24]
  if (Rem > NumBytes) {
    141e:	9a06      	ldr	r2, [sp, #24]
    1420:	9b01      	ldr	r3, [sp, #4]
    1422:	429a      	cmp	r2, r3
    1424:	d911      	bls.n	144a <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    1426:	9b03      	ldr	r3, [sp, #12]
    1428:	685a      	ldr	r2, [r3, #4]
    142a:	9b07      	ldr	r3, [sp, #28]
    142c:	4413      	add	r3, r2
    142e:	9304      	str	r3, [sp, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    1430:	9a01      	ldr	r2, [sp, #4]
    1432:	9902      	ldr	r1, [sp, #8]
    1434:	9804      	ldr	r0, [sp, #16]
    1436:	f000 fc3d 	bl	1cb4 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    143a:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
    143e:	9a07      	ldr	r2, [sp, #28]
    1440:	9b01      	ldr	r3, [sp, #4]
    1442:	441a      	add	r2, r3
    1444:	9b03      	ldr	r3, [sp, #12]
    1446:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
    1448:	e01f      	b.n	148a <_WriteNoCheck+0x86>
    NumBytesAtOnce = Rem;
    144a:	9b06      	ldr	r3, [sp, #24]
    144c:	9305      	str	r3, [sp, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    144e:	9b03      	ldr	r3, [sp, #12]
    1450:	685a      	ldr	r2, [r3, #4]
    1452:	9b07      	ldr	r3, [sp, #28]
    1454:	4413      	add	r3, r2
    1456:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    1458:	9a05      	ldr	r2, [sp, #20]
    145a:	9902      	ldr	r1, [sp, #8]
    145c:	9804      	ldr	r0, [sp, #16]
    145e:	f000 fc29 	bl	1cb4 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
    1462:	9a01      	ldr	r2, [sp, #4]
    1464:	9b06      	ldr	r3, [sp, #24]
    1466:	1ad3      	subs	r3, r2, r3
    1468:	9305      	str	r3, [sp, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    146a:	9b03      	ldr	r3, [sp, #12]
    146c:	685b      	ldr	r3, [r3, #4]
    146e:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    1470:	9a02      	ldr	r2, [sp, #8]
    1472:	9b06      	ldr	r3, [sp, #24]
    1474:	4413      	add	r3, r2
    1476:	9a05      	ldr	r2, [sp, #20]
    1478:	4619      	mov	r1, r3
    147a:	9804      	ldr	r0, [sp, #16]
    147c:	f000 fc1a 	bl	1cb4 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    1480:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
    1484:	9b03      	ldr	r3, [sp, #12]
    1486:	9a05      	ldr	r2, [sp, #20]
    1488:	60da      	str	r2, [r3, #12]
}
    148a:	bf00      	nop
    148c:	b009      	add	sp, #36	; 0x24
    148e:	f85d fb04 	ldr.w	pc, [sp], #4

00001492 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
    1492:	b086      	sub	sp, #24
    1494:	9001      	str	r0, [sp, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
    1496:	9b01      	ldr	r3, [sp, #4]
    1498:	691b      	ldr	r3, [r3, #16]
    149a:	9304      	str	r3, [sp, #16]
  WrOff = pRing->WrOff;
    149c:	9b01      	ldr	r3, [sp, #4]
    149e:	68db      	ldr	r3, [r3, #12]
    14a0:	9303      	str	r3, [sp, #12]
  if (RdOff <= WrOff) {
    14a2:	9a04      	ldr	r2, [sp, #16]
    14a4:	9b03      	ldr	r3, [sp, #12]
    14a6:	429a      	cmp	r2, r3
    14a8:	d808      	bhi.n	14bc <_GetAvailWriteSpace+0x2a>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    14aa:	9b01      	ldr	r3, [sp, #4]
    14ac:	689a      	ldr	r2, [r3, #8]
    14ae:	9b03      	ldr	r3, [sp, #12]
    14b0:	1ad2      	subs	r2, r2, r3
    14b2:	9b04      	ldr	r3, [sp, #16]
    14b4:	4413      	add	r3, r2
    14b6:	3b01      	subs	r3, #1
    14b8:	9305      	str	r3, [sp, #20]
    14ba:	e004      	b.n	14c6 <_GetAvailWriteSpace+0x34>
  } else {
    r = RdOff - WrOff - 1u;
    14bc:	9a04      	ldr	r2, [sp, #16]
    14be:	9b03      	ldr	r3, [sp, #12]
    14c0:	1ad3      	subs	r3, r2, r3
    14c2:	3b01      	subs	r3, #1
    14c4:	9305      	str	r3, [sp, #20]
  }
  return r;
    14c6:	9b05      	ldr	r3, [sp, #20]
}
    14c8:	4618      	mov	r0, r3
    14ca:	b006      	add	sp, #24
    14cc:	4770      	bx	lr
	...

000014d0 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    14d0:	b500      	push	{lr}
    14d2:	b089      	sub	sp, #36	; 0x24
    14d4:	9003      	str	r0, [sp, #12]
    14d6:	9102      	str	r1, [sp, #8]
    14d8:	9201      	str	r2, [sp, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
    14da:	9b02      	ldr	r3, [sp, #8]
    14dc:	9306      	str	r3, [sp, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    14de:	9b03      	ldr	r3, [sp, #12]
    14e0:	1c5a      	adds	r2, r3, #1
    14e2:	4613      	mov	r3, r2
    14e4:	005b      	lsls	r3, r3, #1
    14e6:	4413      	add	r3, r2
    14e8:	00db      	lsls	r3, r3, #3
    14ea:	4a20      	ldr	r2, [pc, #128]	; (156c <SEGGER_RTT_WriteNoLock+0x9c>)
    14ec:	4413      	add	r3, r2
    14ee:	9305      	str	r3, [sp, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    14f0:	9b05      	ldr	r3, [sp, #20]
    14f2:	695b      	ldr	r3, [r3, #20]
    14f4:	2b02      	cmp	r3, #2
    14f6:	d029      	beq.n	154c <SEGGER_RTT_WriteNoLock+0x7c>
    14f8:	2b02      	cmp	r3, #2
    14fa:	d82e      	bhi.n	155a <SEGGER_RTT_WriteNoLock+0x8a>
    14fc:	2b00      	cmp	r3, #0
    14fe:	d002      	beq.n	1506 <SEGGER_RTT_WriteNoLock+0x36>
    1500:	2b01      	cmp	r3, #1
    1502:	d013      	beq.n	152c <SEGGER_RTT_WriteNoLock+0x5c>
    1504:	e029      	b.n	155a <SEGGER_RTT_WriteNoLock+0x8a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
    1506:	9805      	ldr	r0, [sp, #20]
    1508:	f7ff ffc3 	bl	1492 <_GetAvailWriteSpace>
    150c:	9004      	str	r0, [sp, #16]
    if (Avail < NumBytes) {
    150e:	9a04      	ldr	r2, [sp, #16]
    1510:	9b01      	ldr	r3, [sp, #4]
    1512:	429a      	cmp	r2, r3
    1514:	d202      	bcs.n	151c <SEGGER_RTT_WriteNoLock+0x4c>
      Status = 0u;
    1516:	2300      	movs	r3, #0
    1518:	9307      	str	r3, [sp, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
    151a:	e021      	b.n	1560 <SEGGER_RTT_WriteNoLock+0x90>
      Status = NumBytes;
    151c:	9b01      	ldr	r3, [sp, #4]
    151e:	9307      	str	r3, [sp, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
    1520:	9a01      	ldr	r2, [sp, #4]
    1522:	9906      	ldr	r1, [sp, #24]
    1524:	9805      	ldr	r0, [sp, #20]
    1526:	f7ff ff6d 	bl	1404 <_WriteNoCheck>
    break;
    152a:	e019      	b.n	1560 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
    152c:	9805      	ldr	r0, [sp, #20]
    152e:	f7ff ffb0 	bl	1492 <_GetAvailWriteSpace>
    1532:	9004      	str	r0, [sp, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
    1534:	9a01      	ldr	r2, [sp, #4]
    1536:	9b04      	ldr	r3, [sp, #16]
    1538:	4293      	cmp	r3, r2
    153a:	bf28      	it	cs
    153c:	4613      	movcs	r3, r2
    153e:	9307      	str	r3, [sp, #28]
    _WriteNoCheck(pRing, pData, Status);
    1540:	9a07      	ldr	r2, [sp, #28]
    1542:	9906      	ldr	r1, [sp, #24]
    1544:	9805      	ldr	r0, [sp, #20]
    1546:	f7ff ff5d 	bl	1404 <_WriteNoCheck>
    break;
    154a:	e009      	b.n	1560 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
    154c:	9a01      	ldr	r2, [sp, #4]
    154e:	9906      	ldr	r1, [sp, #24]
    1550:	9805      	ldr	r0, [sp, #20]
    1552:	f7ff fefb 	bl	134c <_WriteBlocking>
    1556:	9007      	str	r0, [sp, #28]
    break;
    1558:	e002      	b.n	1560 <SEGGER_RTT_WriteNoLock+0x90>
  default:
    Status = 0u;
    155a:	2300      	movs	r3, #0
    155c:	9307      	str	r3, [sp, #28]
    break;
    155e:	bf00      	nop
  }
  //
  // Finish up.
  //
  return Status;
    1560:	9b07      	ldr	r3, [sp, #28]
}
    1562:	4618      	mov	r0, r3
    1564:	b009      	add	sp, #36	; 0x24
    1566:	f85d fb04 	ldr.w	pc, [sp], #4
    156a:	bf00      	nop
    156c:	1fff91e0 	.word	0x1fff91e0

00001570 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    1570:	b500      	push	{lr}
    1572:	b089      	sub	sp, #36	; 0x24
    1574:	9003      	str	r0, [sp, #12]
    1576:	9102      	str	r1, [sp, #8]
    1578:	9201      	str	r2, [sp, #4]
  unsigned Status;

  INIT();
    157a:	4b0f      	ldr	r3, [pc, #60]	; (15b8 <SEGGER_RTT_Write+0x48>)
    157c:	9307      	str	r3, [sp, #28]
    157e:	9b07      	ldr	r3, [sp, #28]
    1580:	781b      	ldrb	r3, [r3, #0]
    1582:	b2db      	uxtb	r3, r3
    1584:	2b53      	cmp	r3, #83	; 0x53
    1586:	d001      	beq.n	158c <SEGGER_RTT_Write+0x1c>
    1588:	f7ff fe86 	bl	1298 <_DoInit>
  SEGGER_RTT_LOCK();
    158c:	f3ef 8311 	mrs	r3, BASEPRI
    1590:	f04f 0120 	mov.w	r1, #32
    1594:	f381 8811 	msr	BASEPRI, r1
    1598:	9306      	str	r3, [sp, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
    159a:	9a01      	ldr	r2, [sp, #4]
    159c:	9902      	ldr	r1, [sp, #8]
    159e:	9803      	ldr	r0, [sp, #12]
    15a0:	f7ff ff96 	bl	14d0 <SEGGER_RTT_WriteNoLock>
    15a4:	9005      	str	r0, [sp, #20]
  SEGGER_RTT_UNLOCK();
    15a6:	9b06      	ldr	r3, [sp, #24]
    15a8:	f383 8811 	msr	BASEPRI, r3
  return Status;
    15ac:	9b05      	ldr	r3, [sp, #20]
}
    15ae:	4618      	mov	r0, r3
    15b0:	b009      	add	sp, #36	; 0x24
    15b2:	f85d fb04 	ldr.w	pc, [sp], #4
    15b6:	bf00      	nop
    15b8:	1fff91e0 	.word	0x1fff91e0

000015bc <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    15bc:	b508      	push	{r3, lr}
  _DoInit();
    15be:	f7ff fe6b 	bl	1298 <_DoInit>
}
    15c2:	bf00      	nop
    15c4:	bd08      	pop	{r3, pc}

000015c6 <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
    15c6:	b500      	push	{lr}
    15c8:	b085      	sub	sp, #20
    15ca:	9001      	str	r0, [sp, #4]
    15cc:	460b      	mov	r3, r1
    15ce:	f88d 3003 	strb.w	r3, [sp, #3]
  unsigned Cnt;

  Cnt = p->Cnt;
    15d2:	9b01      	ldr	r3, [sp, #4]
    15d4:	689b      	ldr	r3, [r3, #8]
    15d6:	9303      	str	r3, [sp, #12]
  if ((Cnt + 1u) <= p->BufferSize) {
    15d8:	9b03      	ldr	r3, [sp, #12]
    15da:	1c5a      	adds	r2, r3, #1
    15dc:	9b01      	ldr	r3, [sp, #4]
    15de:	685b      	ldr	r3, [r3, #4]
    15e0:	429a      	cmp	r2, r3
    15e2:	d80f      	bhi.n	1604 <_StoreChar+0x3e>
    *(p->pBuffer + Cnt) = c;
    15e4:	9b01      	ldr	r3, [sp, #4]
    15e6:	681a      	ldr	r2, [r3, #0]
    15e8:	9b03      	ldr	r3, [sp, #12]
    15ea:	4413      	add	r3, r2
    15ec:	f89d 2003 	ldrb.w	r2, [sp, #3]
    15f0:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
    15f2:	9b03      	ldr	r3, [sp, #12]
    15f4:	1c5a      	adds	r2, r3, #1
    15f6:	9b01      	ldr	r3, [sp, #4]
    15f8:	609a      	str	r2, [r3, #8]
    p->ReturnValue++;
    15fa:	9b01      	ldr	r3, [sp, #4]
    15fc:	68db      	ldr	r3, [r3, #12]
    15fe:	1c5a      	adds	r2, r3, #1
    1600:	9b01      	ldr	r3, [sp, #4]
    1602:	60da      	str	r2, [r3, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
    1604:	9b01      	ldr	r3, [sp, #4]
    1606:	689a      	ldr	r2, [r3, #8]
    1608:	9b01      	ldr	r3, [sp, #4]
    160a:	685b      	ldr	r3, [r3, #4]
    160c:	429a      	cmp	r2, r3
    160e:	d115      	bne.n	163c <_StoreChar+0x76>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
    1610:	9b01      	ldr	r3, [sp, #4]
    1612:	6918      	ldr	r0, [r3, #16]
    1614:	9b01      	ldr	r3, [sp, #4]
    1616:	6819      	ldr	r1, [r3, #0]
    1618:	9b01      	ldr	r3, [sp, #4]
    161a:	689b      	ldr	r3, [r3, #8]
    161c:	461a      	mov	r2, r3
    161e:	f7ff ffa7 	bl	1570 <SEGGER_RTT_Write>
    1622:	4602      	mov	r2, r0
    1624:	9b01      	ldr	r3, [sp, #4]
    1626:	689b      	ldr	r3, [r3, #8]
    1628:	429a      	cmp	r2, r3
    162a:	d004      	beq.n	1636 <_StoreChar+0x70>
      p->ReturnValue = -1;
    162c:	9b01      	ldr	r3, [sp, #4]
    162e:	f04f 32ff 	mov.w	r2, #4294967295
    1632:	60da      	str	r2, [r3, #12]
    } else {
      p->Cnt = 0u;
    }
  }
}
    1634:	e002      	b.n	163c <_StoreChar+0x76>
      p->Cnt = 0u;
    1636:	9b01      	ldr	r3, [sp, #4]
    1638:	2200      	movs	r2, #0
    163a:	609a      	str	r2, [r3, #8]
}
    163c:	bf00      	nop
    163e:	b005      	add	sp, #20
    1640:	f85d fb04 	ldr.w	pc, [sp], #4

00001644 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    1644:	b500      	push	{lr}
    1646:	b08b      	sub	sp, #44	; 0x2c
    1648:	9003      	str	r0, [sp, #12]
    164a:	9102      	str	r1, [sp, #8]
    164c:	9201      	str	r2, [sp, #4]
    164e:	9300      	str	r3, [sp, #0]
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
    1650:	9b02      	ldr	r3, [sp, #8]
    1652:	9308      	str	r3, [sp, #32]
  Digit = 1u;
    1654:	2301      	movs	r3, #1
    1656:	9309      	str	r3, [sp, #36]	; 0x24
  //
  // Get actual field width
  //
  Width = 1u;
    1658:	2301      	movs	r3, #1
    165a:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    165c:	e007      	b.n	166e <_PrintUnsigned+0x2a>
    Number = (Number / Base);
    165e:	9a08      	ldr	r2, [sp, #32]
    1660:	9b01      	ldr	r3, [sp, #4]
    1662:	fbb2 f3f3 	udiv	r3, r2, r3
    1666:	9308      	str	r3, [sp, #32]
    Width++;
    1668:	9b07      	ldr	r3, [sp, #28]
    166a:	3301      	adds	r3, #1
    166c:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    166e:	9a08      	ldr	r2, [sp, #32]
    1670:	9b01      	ldr	r3, [sp, #4]
    1672:	429a      	cmp	r2, r3
    1674:	d2f3      	bcs.n	165e <_PrintUnsigned+0x1a>
  }
  if (NumDigits > Width) {
    1676:	9a00      	ldr	r2, [sp, #0]
    1678:	9b07      	ldr	r3, [sp, #28]
    167a:	429a      	cmp	r2, r3
    167c:	d901      	bls.n	1682 <_PrintUnsigned+0x3e>
    Width = NumDigits;
    167e:	9b00      	ldr	r3, [sp, #0]
    1680:	9307      	str	r3, [sp, #28]
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
    1682:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1684:	f003 0301 	and.w	r3, r3, #1
    1688:	2b00      	cmp	r3, #0
    168a:	d128      	bne.n	16de <_PrintUnsigned+0x9a>
    if (FieldWidth != 0u) {
    168c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    168e:	2b00      	cmp	r3, #0
    1690:	d025      	beq.n	16de <_PrintUnsigned+0x9a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
    1692:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1694:	f003 0302 	and.w	r3, r3, #2
    1698:	2b00      	cmp	r3, #0
    169a:	d006      	beq.n	16aa <_PrintUnsigned+0x66>
    169c:	9b00      	ldr	r3, [sp, #0]
    169e:	2b00      	cmp	r3, #0
    16a0:	d103      	bne.n	16aa <_PrintUnsigned+0x66>
        c = '0';
    16a2:	2330      	movs	r3, #48	; 0x30
    16a4:	f88d 301b 	strb.w	r3, [sp, #27]
    16a8:	e002      	b.n	16b0 <_PrintUnsigned+0x6c>
      } else {
        c = ' ';
    16aa:	2320      	movs	r3, #32
    16ac:	f88d 301b 	strb.w	r3, [sp, #27]
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    16b0:	e00c      	b.n	16cc <_PrintUnsigned+0x88>
        FieldWidth--;
    16b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    16b4:	3b01      	subs	r3, #1
    16b6:	930c      	str	r3, [sp, #48]	; 0x30
        _StoreChar(pBufferDesc, c);
    16b8:	f89d 301b 	ldrb.w	r3, [sp, #27]
    16bc:	4619      	mov	r1, r3
    16be:	9803      	ldr	r0, [sp, #12]
    16c0:	f7ff ff81 	bl	15c6 <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    16c4:	9b03      	ldr	r3, [sp, #12]
    16c6:	68db      	ldr	r3, [r3, #12]
    16c8:	2b00      	cmp	r3, #0
    16ca:	db07      	blt.n	16dc <_PrintUnsigned+0x98>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    16cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    16ce:	2b00      	cmp	r3, #0
    16d0:	d005      	beq.n	16de <_PrintUnsigned+0x9a>
    16d2:	9a07      	ldr	r2, [sp, #28]
    16d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    16d6:	429a      	cmp	r2, r3
    16d8:	d3eb      	bcc.n	16b2 <_PrintUnsigned+0x6e>
    16da:	e000      	b.n	16de <_PrintUnsigned+0x9a>
          break;
    16dc:	bf00      	nop
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
    16de:	9b03      	ldr	r3, [sp, #12]
    16e0:	68db      	ldr	r3, [r3, #12]
    16e2:	2b00      	cmp	r3, #0
    16e4:	db55      	blt.n	1792 <_PrintUnsigned+0x14e>
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    16e6:	9b00      	ldr	r3, [sp, #0]
    16e8:	2b01      	cmp	r3, #1
    16ea:	d903      	bls.n	16f4 <_PrintUnsigned+0xb0>
        NumDigits--;
    16ec:	9b00      	ldr	r3, [sp, #0]
    16ee:	3b01      	subs	r3, #1
    16f0:	9300      	str	r3, [sp, #0]
    16f2:	e009      	b.n	1708 <_PrintUnsigned+0xc4>
      } else {
        Div = v / Digit;
    16f4:	9a02      	ldr	r2, [sp, #8]
    16f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    16f8:	fbb2 f3f3 	udiv	r3, r2, r3
    16fc:	9305      	str	r3, [sp, #20]
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    16fe:	9a05      	ldr	r2, [sp, #20]
    1700:	9b01      	ldr	r3, [sp, #4]
    1702:	429a      	cmp	r2, r3
    1704:	d200      	bcs.n	1708 <_PrintUnsigned+0xc4>
          break;
    1706:	e005      	b.n	1714 <_PrintUnsigned+0xd0>
        }
      }
      Digit *= Base;
    1708:	9b09      	ldr	r3, [sp, #36]	; 0x24
    170a:	9a01      	ldr	r2, [sp, #4]
    170c:	fb02 f303 	mul.w	r3, r2, r3
    1710:	9309      	str	r3, [sp, #36]	; 0x24
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    1712:	e7e8      	b.n	16e6 <_PrintUnsigned+0xa2>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    1714:	9a02      	ldr	r2, [sp, #8]
    1716:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1718:	fbb2 f3f3 	udiv	r3, r2, r3
    171c:	9305      	str	r3, [sp, #20]
      v -= Div * Digit;
    171e:	9b05      	ldr	r3, [sp, #20]
    1720:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1722:	fb02 f303 	mul.w	r3, r2, r3
    1726:	9a02      	ldr	r2, [sp, #8]
    1728:	1ad3      	subs	r3, r2, r3
    172a:	9302      	str	r3, [sp, #8]
      _StoreChar(pBufferDesc, _aV2C[Div]);
    172c:	4a1b      	ldr	r2, [pc, #108]	; (179c <_PrintUnsigned+0x158>)
    172e:	9b05      	ldr	r3, [sp, #20]
    1730:	4413      	add	r3, r2
    1732:	781b      	ldrb	r3, [r3, #0]
    1734:	4619      	mov	r1, r3
    1736:	9803      	ldr	r0, [sp, #12]
    1738:	f7ff ff45 	bl	15c6 <_StoreChar>
      if (pBufferDesc->ReturnValue < 0) {
    173c:	9b03      	ldr	r3, [sp, #12]
    173e:	68db      	ldr	r3, [r3, #12]
    1740:	2b00      	cmp	r3, #0
    1742:	db08      	blt.n	1756 <_PrintUnsigned+0x112>
        break;
      }
      Digit /= Base;
    1744:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1746:	9b01      	ldr	r3, [sp, #4]
    1748:	fbb2 f3f3 	udiv	r3, r2, r3
    174c:	9309      	str	r3, [sp, #36]	; 0x24
    } while (Digit);
    174e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1750:	2b00      	cmp	r3, #0
    1752:	d1df      	bne.n	1714 <_PrintUnsigned+0xd0>
    1754:	e000      	b.n	1758 <_PrintUnsigned+0x114>
        break;
    1756:	bf00      	nop
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    1758:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    175a:	f003 0301 	and.w	r3, r3, #1
    175e:	2b00      	cmp	r3, #0
    1760:	d017      	beq.n	1792 <_PrintUnsigned+0x14e>
      if (FieldWidth != 0u) {
    1762:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1764:	2b00      	cmp	r3, #0
    1766:	d014      	beq.n	1792 <_PrintUnsigned+0x14e>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1768:	e00a      	b.n	1780 <_PrintUnsigned+0x13c>
          FieldWidth--;
    176a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    176c:	3b01      	subs	r3, #1
    176e:	930c      	str	r3, [sp, #48]	; 0x30
          _StoreChar(pBufferDesc, ' ');
    1770:	2120      	movs	r1, #32
    1772:	9803      	ldr	r0, [sp, #12]
    1774:	f7ff ff27 	bl	15c6 <_StoreChar>
          if (pBufferDesc->ReturnValue < 0) {
    1778:	9b03      	ldr	r3, [sp, #12]
    177a:	68db      	ldr	r3, [r3, #12]
    177c:	2b00      	cmp	r3, #0
    177e:	db07      	blt.n	1790 <_PrintUnsigned+0x14c>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1780:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1782:	2b00      	cmp	r3, #0
    1784:	d005      	beq.n	1792 <_PrintUnsigned+0x14e>
    1786:	9a07      	ldr	r2, [sp, #28]
    1788:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    178a:	429a      	cmp	r2, r3
    178c:	d3ed      	bcc.n	176a <_PrintUnsigned+0x126>
          }
        }
      }
    }
  }
}
    178e:	e000      	b.n	1792 <_PrintUnsigned+0x14e>
            break;
    1790:	bf00      	nop
}
    1792:	bf00      	nop
    1794:	b00b      	add	sp, #44	; 0x2c
    1796:	f85d fb04 	ldr.w	pc, [sp], #4
    179a:	bf00      	nop
    179c:	000110d0 	.word	0x000110d0

000017a0 <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    17a0:	b500      	push	{lr}
    17a2:	b089      	sub	sp, #36	; 0x24
    17a4:	9005      	str	r0, [sp, #20]
    17a6:	9104      	str	r1, [sp, #16]
    17a8:	9203      	str	r2, [sp, #12]
    17aa:	9302      	str	r3, [sp, #8]
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    17ac:	9b04      	ldr	r3, [sp, #16]
    17ae:	2b00      	cmp	r3, #0
    17b0:	bfb8      	it	lt
    17b2:	425b      	neglt	r3, r3
    17b4:	9306      	str	r3, [sp, #24]

  //
  // Get actual field width
  //
  Width = 1u;
    17b6:	2301      	movs	r3, #1
    17b8:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    17ba:	e007      	b.n	17cc <_PrintInt+0x2c>
    Number = (Number / (int)Base);
    17bc:	9b03      	ldr	r3, [sp, #12]
    17be:	9a06      	ldr	r2, [sp, #24]
    17c0:	fb92 f3f3 	sdiv	r3, r2, r3
    17c4:	9306      	str	r3, [sp, #24]
    Width++;
    17c6:	9b07      	ldr	r3, [sp, #28]
    17c8:	3301      	adds	r3, #1
    17ca:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    17cc:	9b03      	ldr	r3, [sp, #12]
    17ce:	9a06      	ldr	r2, [sp, #24]
    17d0:	429a      	cmp	r2, r3
    17d2:	daf3      	bge.n	17bc <_PrintInt+0x1c>
  }
  if (NumDigits > Width) {
    17d4:	9a02      	ldr	r2, [sp, #8]
    17d6:	9b07      	ldr	r3, [sp, #28]
    17d8:	429a      	cmp	r2, r3
    17da:	d901      	bls.n	17e0 <_PrintInt+0x40>
    Width = NumDigits;
    17dc:	9b02      	ldr	r3, [sp, #8]
    17de:	9307      	str	r3, [sp, #28]
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    17e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    17e2:	2b00      	cmp	r3, #0
    17e4:	d00a      	beq.n	17fc <_PrintInt+0x5c>
    17e6:	9b04      	ldr	r3, [sp, #16]
    17e8:	2b00      	cmp	r3, #0
    17ea:	db04      	blt.n	17f6 <_PrintInt+0x56>
    17ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    17ee:	f003 0304 	and.w	r3, r3, #4
    17f2:	2b00      	cmp	r3, #0
    17f4:	d002      	beq.n	17fc <_PrintInt+0x5c>
    FieldWidth--;
    17f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    17f8:	3b01      	subs	r3, #1
    17fa:	930a      	str	r3, [sp, #40]	; 0x28
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    17fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    17fe:	f003 0302 	and.w	r3, r3, #2
    1802:	2b00      	cmp	r3, #0
    1804:	d002      	beq.n	180c <_PrintInt+0x6c>
    1806:	9b02      	ldr	r3, [sp, #8]
    1808:	2b00      	cmp	r3, #0
    180a:	d01c      	beq.n	1846 <_PrintInt+0xa6>
    180c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    180e:	f003 0301 	and.w	r3, r3, #1
    1812:	2b00      	cmp	r3, #0
    1814:	d117      	bne.n	1846 <_PrintInt+0xa6>
    if (FieldWidth != 0u) {
    1816:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1818:	2b00      	cmp	r3, #0
    181a:	d014      	beq.n	1846 <_PrintInt+0xa6>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    181c:	e00a      	b.n	1834 <_PrintInt+0x94>
        FieldWidth--;
    181e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1820:	3b01      	subs	r3, #1
    1822:	930a      	str	r3, [sp, #40]	; 0x28
        _StoreChar(pBufferDesc, ' ');
    1824:	2120      	movs	r1, #32
    1826:	9805      	ldr	r0, [sp, #20]
    1828:	f7ff fecd 	bl	15c6 <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    182c:	9b05      	ldr	r3, [sp, #20]
    182e:	68db      	ldr	r3, [r3, #12]
    1830:	2b00      	cmp	r3, #0
    1832:	db07      	blt.n	1844 <_PrintInt+0xa4>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1834:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1836:	2b00      	cmp	r3, #0
    1838:	d005      	beq.n	1846 <_PrintInt+0xa6>
    183a:	9a07      	ldr	r2, [sp, #28]
    183c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    183e:	429a      	cmp	r2, r3
    1840:	d3ed      	bcc.n	181e <_PrintInt+0x7e>
    1842:	e000      	b.n	1846 <_PrintInt+0xa6>
          break;
    1844:	bf00      	nop
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    1846:	9b05      	ldr	r3, [sp, #20]
    1848:	68db      	ldr	r3, [r3, #12]
    184a:	2b00      	cmp	r3, #0
    184c:	db4a      	blt.n	18e4 <_PrintInt+0x144>
    if (v < 0) {
    184e:	9b04      	ldr	r3, [sp, #16]
    1850:	2b00      	cmp	r3, #0
    1852:	da07      	bge.n	1864 <_PrintInt+0xc4>
      v = -v;
    1854:	9b04      	ldr	r3, [sp, #16]
    1856:	425b      	negs	r3, r3
    1858:	9304      	str	r3, [sp, #16]
      _StoreChar(pBufferDesc, '-');
    185a:	212d      	movs	r1, #45	; 0x2d
    185c:	9805      	ldr	r0, [sp, #20]
    185e:	f7ff feb2 	bl	15c6 <_StoreChar>
    1862:	e008      	b.n	1876 <_PrintInt+0xd6>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    1864:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1866:	f003 0304 	and.w	r3, r3, #4
    186a:	2b00      	cmp	r3, #0
    186c:	d003      	beq.n	1876 <_PrintInt+0xd6>
      _StoreChar(pBufferDesc, '+');
    186e:	212b      	movs	r1, #43	; 0x2b
    1870:	9805      	ldr	r0, [sp, #20]
    1872:	f7ff fea8 	bl	15c6 <_StoreChar>
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    1876:	9b05      	ldr	r3, [sp, #20]
    1878:	68db      	ldr	r3, [r3, #12]
    187a:	2b00      	cmp	r3, #0
    187c:	db32      	blt.n	18e4 <_PrintInt+0x144>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    187e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1880:	f003 0302 	and.w	r3, r3, #2
    1884:	2b00      	cmp	r3, #0
    1886:	d01f      	beq.n	18c8 <_PrintInt+0x128>
    1888:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    188a:	f003 0301 	and.w	r3, r3, #1
    188e:	2b00      	cmp	r3, #0
    1890:	d11a      	bne.n	18c8 <_PrintInt+0x128>
    1892:	9b02      	ldr	r3, [sp, #8]
    1894:	2b00      	cmp	r3, #0
    1896:	d117      	bne.n	18c8 <_PrintInt+0x128>
        if (FieldWidth != 0u) {
    1898:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    189a:	2b00      	cmp	r3, #0
    189c:	d014      	beq.n	18c8 <_PrintInt+0x128>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    189e:	e00a      	b.n	18b6 <_PrintInt+0x116>
            FieldWidth--;
    18a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    18a2:	3b01      	subs	r3, #1
    18a4:	930a      	str	r3, [sp, #40]	; 0x28
            _StoreChar(pBufferDesc, '0');
    18a6:	2130      	movs	r1, #48	; 0x30
    18a8:	9805      	ldr	r0, [sp, #20]
    18aa:	f7ff fe8c 	bl	15c6 <_StoreChar>
            if (pBufferDesc->ReturnValue < 0) {
    18ae:	9b05      	ldr	r3, [sp, #20]
    18b0:	68db      	ldr	r3, [r3, #12]
    18b2:	2b00      	cmp	r3, #0
    18b4:	db07      	blt.n	18c6 <_PrintInt+0x126>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    18b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    18b8:	2b00      	cmp	r3, #0
    18ba:	d005      	beq.n	18c8 <_PrintInt+0x128>
    18bc:	9a07      	ldr	r2, [sp, #28]
    18be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    18c0:	429a      	cmp	r2, r3
    18c2:	d3ed      	bcc.n	18a0 <_PrintInt+0x100>
    18c4:	e000      	b.n	18c8 <_PrintInt+0x128>
              break;
    18c6:	bf00      	nop
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    18c8:	9b05      	ldr	r3, [sp, #20]
    18ca:	68db      	ldr	r3, [r3, #12]
    18cc:	2b00      	cmp	r3, #0
    18ce:	db09      	blt.n	18e4 <_PrintInt+0x144>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    18d0:	9904      	ldr	r1, [sp, #16]
    18d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    18d4:	9301      	str	r3, [sp, #4]
    18d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    18d8:	9300      	str	r3, [sp, #0]
    18da:	9b02      	ldr	r3, [sp, #8]
    18dc:	9a03      	ldr	r2, [sp, #12]
    18de:	9805      	ldr	r0, [sp, #20]
    18e0:	f7ff feb0 	bl	1644 <_PrintUnsigned>
      }
    }
  }
}
    18e4:	bf00      	nop
    18e6:	b009      	add	sp, #36	; 0x24
    18e8:	f85d fb04 	ldr.w	pc, [sp], #4

000018ec <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    18ec:	b500      	push	{lr}
    18ee:	b0a3      	sub	sp, #140	; 0x8c
    18f0:	9005      	str	r0, [sp, #20]
    18f2:	9104      	str	r1, [sp, #16]
    18f4:	9203      	str	r2, [sp, #12]
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    18f6:	ab06      	add	r3, sp, #24
    18f8:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    18fa:	2340      	movs	r3, #64	; 0x40
    18fc:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.Cnt            = 0u;
    18fe:	2300      	movs	r3, #0
    1900:	9318      	str	r3, [sp, #96]	; 0x60
  BufferDesc.RTTBufferIndex = BufferIndex;
    1902:	9b05      	ldr	r3, [sp, #20]
    1904:	931a      	str	r3, [sp, #104]	; 0x68
  BufferDesc.ReturnValue    = 0;
    1906:	2300      	movs	r3, #0
    1908:	9319      	str	r3, [sp, #100]	; 0x64

  do {
    c = *sFormat;
    190a:	9b04      	ldr	r3, [sp, #16]
    190c:	781b      	ldrb	r3, [r3, #0]
    190e:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    sFormat++;
    1912:	9b04      	ldr	r3, [sp, #16]
    1914:	3301      	adds	r3, #1
    1916:	9304      	str	r3, [sp, #16]
    if (c == 0u) {
    1918:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    191c:	2b00      	cmp	r3, #0
    191e:	f000 819c 	beq.w	1c5a <SEGGER_RTT_vprintf+0x36e>
      break;
    }
    if (c == '%') {
    1922:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1926:	2b25      	cmp	r3, #37	; 0x25
    1928:	f040 818b 	bne.w	1c42 <SEGGER_RTT_vprintf+0x356>
      //
      // Filter out flags
      //
      FormatFlags = 0u;
    192c:	2300      	movs	r3, #0
    192e:	931e      	str	r3, [sp, #120]	; 0x78
      v = 1;
    1930:	2301      	movs	r3, #1
    1932:	9320      	str	r3, [sp, #128]	; 0x80
      do {
        c = *sFormat;
    1934:	9b04      	ldr	r3, [sp, #16]
    1936:	781b      	ldrb	r3, [r3, #0]
    1938:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        switch (c) {
    193c:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1940:	3b23      	subs	r3, #35	; 0x23
    1942:	2b0d      	cmp	r3, #13
    1944:	d83e      	bhi.n	19c4 <SEGGER_RTT_vprintf+0xd8>
    1946:	a201      	add	r2, pc, #4	; (adr r2, 194c <SEGGER_RTT_vprintf+0x60>)
    1948:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    194c:	000019b5 	.word	0x000019b5
    1950:	000019c5 	.word	0x000019c5
    1954:	000019c5 	.word	0x000019c5
    1958:	000019c5 	.word	0x000019c5
    195c:	000019c5 	.word	0x000019c5
    1960:	000019c5 	.word	0x000019c5
    1964:	000019c5 	.word	0x000019c5
    1968:	000019c5 	.word	0x000019c5
    196c:	000019a5 	.word	0x000019a5
    1970:	000019c5 	.word	0x000019c5
    1974:	00001985 	.word	0x00001985
    1978:	000019c5 	.word	0x000019c5
    197c:	000019c5 	.word	0x000019c5
    1980:	00001995 	.word	0x00001995
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    1984:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1986:	f043 0301 	orr.w	r3, r3, #1
    198a:	931e      	str	r3, [sp, #120]	; 0x78
    198c:	9b04      	ldr	r3, [sp, #16]
    198e:	3301      	adds	r3, #1
    1990:	9304      	str	r3, [sp, #16]
    1992:	e01a      	b.n	19ca <SEGGER_RTT_vprintf+0xde>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    1994:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1996:	f043 0302 	orr.w	r3, r3, #2
    199a:	931e      	str	r3, [sp, #120]	; 0x78
    199c:	9b04      	ldr	r3, [sp, #16]
    199e:	3301      	adds	r3, #1
    19a0:	9304      	str	r3, [sp, #16]
    19a2:	e012      	b.n	19ca <SEGGER_RTT_vprintf+0xde>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    19a4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    19a6:	f043 0304 	orr.w	r3, r3, #4
    19aa:	931e      	str	r3, [sp, #120]	; 0x78
    19ac:	9b04      	ldr	r3, [sp, #16]
    19ae:	3301      	adds	r3, #1
    19b0:	9304      	str	r3, [sp, #16]
    19b2:	e00a      	b.n	19ca <SEGGER_RTT_vprintf+0xde>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    19b4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    19b6:	f043 0308 	orr.w	r3, r3, #8
    19ba:	931e      	str	r3, [sp, #120]	; 0x78
    19bc:	9b04      	ldr	r3, [sp, #16]
    19be:	3301      	adds	r3, #1
    19c0:	9304      	str	r3, [sp, #16]
    19c2:	e002      	b.n	19ca <SEGGER_RTT_vprintf+0xde>
        default:  v = 0; break;
    19c4:	2300      	movs	r3, #0
    19c6:	9320      	str	r3, [sp, #128]	; 0x80
    19c8:	bf00      	nop
        }
      } while (v);
    19ca:	9b20      	ldr	r3, [sp, #128]	; 0x80
    19cc:	2b00      	cmp	r3, #0
    19ce:	d1b1      	bne.n	1934 <SEGGER_RTT_vprintf+0x48>
      //
      // filter out field with
      //
      FieldWidth = 0u;
    19d0:	2300      	movs	r3, #0
    19d2:	931d      	str	r3, [sp, #116]	; 0x74
      do {
        c = *sFormat;
    19d4:	9b04      	ldr	r3, [sp, #16]
    19d6:	781b      	ldrb	r3, [r3, #0]
    19d8:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c < '0') || (c > '9')) {
    19dc:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    19e0:	2b2f      	cmp	r3, #47	; 0x2f
    19e2:	d912      	bls.n	1a0a <SEGGER_RTT_vprintf+0x11e>
    19e4:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    19e8:	2b39      	cmp	r3, #57	; 0x39
    19ea:	d80e      	bhi.n	1a0a <SEGGER_RTT_vprintf+0x11e>
          break;
        }
        sFormat++;
    19ec:	9b04      	ldr	r3, [sp, #16]
    19ee:	3301      	adds	r3, #1
    19f0:	9304      	str	r3, [sp, #16]
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    19f2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    19f4:	4613      	mov	r3, r2
    19f6:	009b      	lsls	r3, r3, #2
    19f8:	4413      	add	r3, r2
    19fa:	005b      	lsls	r3, r3, #1
    19fc:	461a      	mov	r2, r3
    19fe:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a02:	4413      	add	r3, r2
    1a04:	3b30      	subs	r3, #48	; 0x30
    1a06:	931d      	str	r3, [sp, #116]	; 0x74
        c = *sFormat;
    1a08:	e7e4      	b.n	19d4 <SEGGER_RTT_vprintf+0xe8>
      } while (1);

      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
    1a0a:	2300      	movs	r3, #0
    1a0c:	931f      	str	r3, [sp, #124]	; 0x7c
      c = *sFormat;
    1a0e:	9b04      	ldr	r3, [sp, #16]
    1a10:	781b      	ldrb	r3, [r3, #0]
    1a12:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      if (c == '.') {
    1a16:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a1a:	2b2e      	cmp	r3, #46	; 0x2e
    1a1c:	d11d      	bne.n	1a5a <SEGGER_RTT_vprintf+0x16e>
        sFormat++;
    1a1e:	9b04      	ldr	r3, [sp, #16]
    1a20:	3301      	adds	r3, #1
    1a22:	9304      	str	r3, [sp, #16]
        do {
          c = *sFormat;
    1a24:	9b04      	ldr	r3, [sp, #16]
    1a26:	781b      	ldrb	r3, [r3, #0]
    1a28:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
          if ((c < '0') || (c > '9')) {
    1a2c:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a30:	2b2f      	cmp	r3, #47	; 0x2f
    1a32:	d912      	bls.n	1a5a <SEGGER_RTT_vprintf+0x16e>
    1a34:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a38:	2b39      	cmp	r3, #57	; 0x39
    1a3a:	d80e      	bhi.n	1a5a <SEGGER_RTT_vprintf+0x16e>
            break;
          }
          sFormat++;
    1a3c:	9b04      	ldr	r3, [sp, #16]
    1a3e:	3301      	adds	r3, #1
    1a40:	9304      	str	r3, [sp, #16]
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    1a42:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    1a44:	4613      	mov	r3, r2
    1a46:	009b      	lsls	r3, r3, #2
    1a48:	4413      	add	r3, r2
    1a4a:	005b      	lsls	r3, r3, #1
    1a4c:	461a      	mov	r2, r3
    1a4e:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a52:	4413      	add	r3, r2
    1a54:	3b30      	subs	r3, #48	; 0x30
    1a56:	931f      	str	r3, [sp, #124]	; 0x7c
          c = *sFormat;
    1a58:	e7e4      	b.n	1a24 <SEGGER_RTT_vprintf+0x138>
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    1a5a:	9b04      	ldr	r3, [sp, #16]
    1a5c:	781b      	ldrb	r3, [r3, #0]
    1a5e:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      do {
        if ((c == 'l') || (c == 'h')) {
    1a62:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a66:	2b6c      	cmp	r3, #108	; 0x6c
    1a68:	d003      	beq.n	1a72 <SEGGER_RTT_vprintf+0x186>
    1a6a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a6e:	2b68      	cmp	r3, #104	; 0x68
    1a70:	d107      	bne.n	1a82 <SEGGER_RTT_vprintf+0x196>
          sFormat++;
    1a72:	9b04      	ldr	r3, [sp, #16]
    1a74:	3301      	adds	r3, #1
    1a76:	9304      	str	r3, [sp, #16]
          c = *sFormat;
    1a78:	9b04      	ldr	r3, [sp, #16]
    1a7a:	781b      	ldrb	r3, [r3, #0]
    1a7c:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c == 'l') || (c == 'h')) {
    1a80:	e7ef      	b.n	1a62 <SEGGER_RTT_vprintf+0x176>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    1a82:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1a86:	2b25      	cmp	r3, #37	; 0x25
    1a88:	f000 80d0 	beq.w	1c2c <SEGGER_RTT_vprintf+0x340>
    1a8c:	2b25      	cmp	r3, #37	; 0x25
    1a8e:	f2c0 80d3 	blt.w	1c38 <SEGGER_RTT_vprintf+0x34c>
    1a92:	2b78      	cmp	r3, #120	; 0x78
    1a94:	f300 80d0 	bgt.w	1c38 <SEGGER_RTT_vprintf+0x34c>
    1a98:	2b58      	cmp	r3, #88	; 0x58
    1a9a:	f2c0 80cd 	blt.w	1c38 <SEGGER_RTT_vprintf+0x34c>
    1a9e:	3b58      	subs	r3, #88	; 0x58
    1aa0:	2b20      	cmp	r3, #32
    1aa2:	f200 80c9 	bhi.w	1c38 <SEGGER_RTT_vprintf+0x34c>
    1aa6:	a201      	add	r2, pc, #4	; (adr r2, 1aac <SEGGER_RTT_vprintf+0x1c0>)
    1aa8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1aac:	00001b9d 	.word	0x00001b9d
    1ab0:	00001c39 	.word	0x00001c39
    1ab4:	00001c39 	.word	0x00001c39
    1ab8:	00001c39 	.word	0x00001c39
    1abc:	00001c39 	.word	0x00001c39
    1ac0:	00001c39 	.word	0x00001c39
    1ac4:	00001c39 	.word	0x00001c39
    1ac8:	00001c39 	.word	0x00001c39
    1acc:	00001c39 	.word	0x00001c39
    1ad0:	00001c39 	.word	0x00001c39
    1ad4:	00001c39 	.word	0x00001c39
    1ad8:	00001b31 	.word	0x00001b31
    1adc:	00001b55 	.word	0x00001b55
    1ae0:	00001c39 	.word	0x00001c39
    1ae4:	00001c39 	.word	0x00001c39
    1ae8:	00001c39 	.word	0x00001c39
    1aec:	00001c39 	.word	0x00001c39
    1af0:	00001c39 	.word	0x00001c39
    1af4:	00001c39 	.word	0x00001c39
    1af8:	00001c39 	.word	0x00001c39
    1afc:	00001c39 	.word	0x00001c39
    1b00:	00001c39 	.word	0x00001c39
    1b04:	00001c39 	.word	0x00001c39
    1b08:	00001c39 	.word	0x00001c39
    1b0c:	00001c09 	.word	0x00001c09
    1b10:	00001c39 	.word	0x00001c39
    1b14:	00001c39 	.word	0x00001c39
    1b18:	00001bc1 	.word	0x00001bc1
    1b1c:	00001c39 	.word	0x00001c39
    1b20:	00001b79 	.word	0x00001b79
    1b24:	00001c39 	.word	0x00001c39
    1b28:	00001c39 	.word	0x00001c39
    1b2c:	00001b9d 	.word	0x00001b9d
      case 'c': {
        char c0;
        v = va_arg(*pParamList, int);
    1b30:	9b03      	ldr	r3, [sp, #12]
    1b32:	681b      	ldr	r3, [r3, #0]
    1b34:	1d19      	adds	r1, r3, #4
    1b36:	9a03      	ldr	r2, [sp, #12]
    1b38:	6011      	str	r1, [r2, #0]
    1b3a:	681b      	ldr	r3, [r3, #0]
    1b3c:	9320      	str	r3, [sp, #128]	; 0x80
        c0 = (char)v;
    1b3e:	9b20      	ldr	r3, [sp, #128]	; 0x80
    1b40:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
        _StoreChar(&BufferDesc, c0);
    1b44:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
    1b48:	ab16      	add	r3, sp, #88	; 0x58
    1b4a:	4611      	mov	r1, r2
    1b4c:	4618      	mov	r0, r3
    1b4e:	f7ff fd3a 	bl	15c6 <_StoreChar>
        break;
    1b52:	e072      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      }
      case 'd':
        v = va_arg(*pParamList, int);
    1b54:	9b03      	ldr	r3, [sp, #12]
    1b56:	681b      	ldr	r3, [r3, #0]
    1b58:	1d19      	adds	r1, r3, #4
    1b5a:	9a03      	ldr	r2, [sp, #12]
    1b5c:	6011      	str	r1, [r2, #0]
    1b5e:	681b      	ldr	r3, [r3, #0]
    1b60:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    1b62:	a816      	add	r0, sp, #88	; 0x58
    1b64:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1b66:	9301      	str	r3, [sp, #4]
    1b68:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1b6a:	9300      	str	r3, [sp, #0]
    1b6c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1b6e:	220a      	movs	r2, #10
    1b70:	9920      	ldr	r1, [sp, #128]	; 0x80
    1b72:	f7ff fe15 	bl	17a0 <_PrintInt>
        break;
    1b76:	e060      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      case 'u':
        v = va_arg(*pParamList, int);
    1b78:	9b03      	ldr	r3, [sp, #12]
    1b7a:	681b      	ldr	r3, [r3, #0]
    1b7c:	1d19      	adds	r1, r3, #4
    1b7e:	9a03      	ldr	r2, [sp, #12]
    1b80:	6011      	str	r1, [r2, #0]
    1b82:	681b      	ldr	r3, [r3, #0]
    1b84:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    1b86:	9920      	ldr	r1, [sp, #128]	; 0x80
    1b88:	a816      	add	r0, sp, #88	; 0x58
    1b8a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1b8c:	9301      	str	r3, [sp, #4]
    1b8e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1b90:	9300      	str	r3, [sp, #0]
    1b92:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1b94:	220a      	movs	r2, #10
    1b96:	f7ff fd55 	bl	1644 <_PrintUnsigned>
        break;
    1b9a:	e04e      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      case 'x':
      case 'X':
        v = va_arg(*pParamList, int);
    1b9c:	9b03      	ldr	r3, [sp, #12]
    1b9e:	681b      	ldr	r3, [r3, #0]
    1ba0:	1d19      	adds	r1, r3, #4
    1ba2:	9a03      	ldr	r2, [sp, #12]
    1ba4:	6011      	str	r1, [r2, #0]
    1ba6:	681b      	ldr	r3, [r3, #0]
    1ba8:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    1baa:	9920      	ldr	r1, [sp, #128]	; 0x80
    1bac:	a816      	add	r0, sp, #88	; 0x58
    1bae:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1bb0:	9301      	str	r3, [sp, #4]
    1bb2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1bb4:	9300      	str	r3, [sp, #0]
    1bb6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1bb8:	2210      	movs	r2, #16
    1bba:	f7ff fd43 	bl	1644 <_PrintUnsigned>
        break;
    1bbe:	e03c      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      case 's':
        {
          const char * s = va_arg(*pParamList, const char *);
    1bc0:	9b03      	ldr	r3, [sp, #12]
    1bc2:	681b      	ldr	r3, [r3, #0]
    1bc4:	1d19      	adds	r1, r3, #4
    1bc6:	9a03      	ldr	r2, [sp, #12]
    1bc8:	6011      	str	r1, [r2, #0]
    1bca:	681b      	ldr	r3, [r3, #0]
    1bcc:	931c      	str	r3, [sp, #112]	; 0x70
          if (s == NULL) {
    1bce:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    1bd0:	2b00      	cmp	r3, #0
    1bd2:	d101      	bne.n	1bd8 <SEGGER_RTT_vprintf+0x2ec>
            s = "(NULL)";  // Print (NULL) instead of crashing or breaking, as it is more informative to the user.
    1bd4:	4b2c      	ldr	r3, [pc, #176]	; (1c88 <SEGGER_RTT_vprintf+0x39c>)
    1bd6:	931c      	str	r3, [sp, #112]	; 0x70
          }
          do {
            c = *s;
    1bd8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    1bda:	781b      	ldrb	r3, [r3, #0]
    1bdc:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
            s++;
    1be0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    1be2:	3301      	adds	r3, #1
    1be4:	931c      	str	r3, [sp, #112]	; 0x70
            if (c == '\0') {
    1be6:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1bea:	2b00      	cmp	r3, #0
    1bec:	d00a      	beq.n	1c04 <SEGGER_RTT_vprintf+0x318>
              break;
            }
           _StoreChar(&BufferDesc, c);
    1bee:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    1bf2:	ab16      	add	r3, sp, #88	; 0x58
    1bf4:	4611      	mov	r1, r2
    1bf6:	4618      	mov	r0, r3
    1bf8:	f7ff fce5 	bl	15c6 <_StoreChar>
          } while (BufferDesc.ReturnValue >= 0);
    1bfc:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1bfe:	2b00      	cmp	r3, #0
    1c00:	daea      	bge.n	1bd8 <SEGGER_RTT_vprintf+0x2ec>
        }
        break;
    1c02:	e01a      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
              break;
    1c04:	bf00      	nop
        break;
    1c06:	e018      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      case 'p':
        v = va_arg(*pParamList, int);
    1c08:	9b03      	ldr	r3, [sp, #12]
    1c0a:	681b      	ldr	r3, [r3, #0]
    1c0c:	1d19      	adds	r1, r3, #4
    1c0e:	9a03      	ldr	r2, [sp, #12]
    1c10:	6011      	str	r1, [r2, #0]
    1c12:	681b      	ldr	r3, [r3, #0]
    1c14:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    1c16:	9920      	ldr	r1, [sp, #128]	; 0x80
    1c18:	a816      	add	r0, sp, #88	; 0x58
    1c1a:	2300      	movs	r3, #0
    1c1c:	9301      	str	r3, [sp, #4]
    1c1e:	2308      	movs	r3, #8
    1c20:	9300      	str	r3, [sp, #0]
    1c22:	2308      	movs	r3, #8
    1c24:	2210      	movs	r2, #16
    1c26:	f7ff fd0d 	bl	1644 <_PrintUnsigned>
        break;
    1c2a:	e006      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      case '%':
        _StoreChar(&BufferDesc, '%');
    1c2c:	ab16      	add	r3, sp, #88	; 0x58
    1c2e:	2125      	movs	r1, #37	; 0x25
    1c30:	4618      	mov	r0, r3
    1c32:	f7ff fcc8 	bl	15c6 <_StoreChar>
        break;
    1c36:	e000      	b.n	1c3a <SEGGER_RTT_vprintf+0x34e>
      default:
        break;
    1c38:	bf00      	nop
      }
      sFormat++;
    1c3a:	9b04      	ldr	r3, [sp, #16]
    1c3c:	3301      	adds	r3, #1
    1c3e:	9304      	str	r3, [sp, #16]
    1c40:	e006      	b.n	1c50 <SEGGER_RTT_vprintf+0x364>
    } else {
      _StoreChar(&BufferDesc, c);
    1c42:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    1c46:	ab16      	add	r3, sp, #88	; 0x58
    1c48:	4611      	mov	r1, r2
    1c4a:	4618      	mov	r0, r3
    1c4c:	f7ff fcbb 	bl	15c6 <_StoreChar>
    }
  } while (BufferDesc.ReturnValue >= 0);
    1c50:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1c52:	2b00      	cmp	r3, #0
    1c54:	f6bf ae59 	bge.w	190a <SEGGER_RTT_vprintf+0x1e>
    1c58:	e000      	b.n	1c5c <SEGGER_RTT_vprintf+0x370>
      break;
    1c5a:	bf00      	nop

  if (BufferDesc.ReturnValue > 0) {
    1c5c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1c5e:	2b00      	cmp	r3, #0
    1c60:	dd0c      	ble.n	1c7c <SEGGER_RTT_vprintf+0x390>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    1c62:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1c64:	2b00      	cmp	r3, #0
    1c66:	d005      	beq.n	1c74 <SEGGER_RTT_vprintf+0x388>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    1c68:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1c6a:	ab06      	add	r3, sp, #24
    1c6c:	4619      	mov	r1, r3
    1c6e:	9805      	ldr	r0, [sp, #20]
    1c70:	f7ff fc7e 	bl	1570 <SEGGER_RTT_Write>
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    1c74:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1c76:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1c78:	4413      	add	r3, r2
    1c7a:	9319      	str	r3, [sp, #100]	; 0x64
  }
  return BufferDesc.ReturnValue;
    1c7c:	9b19      	ldr	r3, [sp, #100]	; 0x64
}
    1c7e:	4618      	mov	r0, r3
    1c80:	b023      	add	sp, #140	; 0x8c
    1c82:	f85d fb04 	ldr.w	pc, [sp], #4
    1c86:	bf00      	nop
    1c88:	0000fd7c 	.word	0x0000fd7c

00001c8c <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    1c8c:	b40e      	push	{r1, r2, r3}
    1c8e:	b500      	push	{lr}
    1c90:	b084      	sub	sp, #16
    1c92:	9001      	str	r0, [sp, #4]
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    1c94:	ab06      	add	r3, sp, #24
    1c96:	9302      	str	r3, [sp, #8]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    1c98:	ab02      	add	r3, sp, #8
    1c9a:	461a      	mov	r2, r3
    1c9c:	9905      	ldr	r1, [sp, #20]
    1c9e:	9801      	ldr	r0, [sp, #4]
    1ca0:	f7ff fe24 	bl	18ec <SEGGER_RTT_vprintf>
    1ca4:	9003      	str	r0, [sp, #12]
  va_end(ParamList);
  return r;
    1ca6:	9b03      	ldr	r3, [sp, #12]
}
    1ca8:	4618      	mov	r0, r3
    1caa:	b004      	add	sp, #16
    1cac:	f85d eb04 	ldr.w	lr, [sp], #4
    1cb0:	b003      	add	sp, #12
    1cb2:	4770      	bx	lr

00001cb4 <memcpy>:
    1cb4:	440a      	add	r2, r1
    1cb6:	4291      	cmp	r1, r2
    1cb8:	f100 33ff 	add.w	r3, r0, #4294967295
    1cbc:	d100      	bne.n	1cc0 <memcpy+0xc>
    1cbe:	4770      	bx	lr
    1cc0:	b510      	push	{r4, lr}
    1cc2:	f811 4b01 	ldrb.w	r4, [r1], #1
    1cc6:	f803 4f01 	strb.w	r4, [r3, #1]!
    1cca:	4291      	cmp	r1, r2
    1ccc:	d1f9      	bne.n	1cc2 <memcpy+0xe>
    1cce:	bd10      	pop	{r4, pc}

00001cd0 <memset>:
    1cd0:	4402      	add	r2, r0
    1cd2:	4603      	mov	r3, r0
    1cd4:	4293      	cmp	r3, r2
    1cd6:	d100      	bne.n	1cda <memset+0xa>
    1cd8:	4770      	bx	lr
    1cda:	f803 1b01 	strb.w	r1, [r3], #1
    1cde:	e7f9      	b.n	1cd4 <memset+0x4>

00001ce0 <IntCtrl_Ip_InstallHandlerPrivileged>:
#endif

void IntCtrl_Ip_InstallHandlerPrivileged(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1ce0:	b086      	sub	sp, #24
    1ce2:	9003      	str	r0, [sp, #12]
    1ce4:	9102      	str	r1, [sp, #8]
    1ce6:	9201      	str	r2, [sp, #4]

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber)] = pfNewHandler;
    OsIf_ResumeAllInterrupts();
#else
    IntCtrl_Ip_IrqHandlerType *pVectorRam = (IntCtrl_Ip_IrqHandlerType *)S32_SCB->VTOR;
    1ce8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1cec:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    1cf0:	9305      	str	r3, [sp, #20]

    /* Save the former handler pointer */
    if (pfOldHandler != NULL_PTR)
    1cf2:	9b01      	ldr	r3, [sp, #4]
    1cf4:	2b00      	cmp	r3, #0
    1cf6:	d007      	beq.n	1d08 <IntCtrl_Ip_InstallHandlerPrivileged+0x28>
    {
        *pfOldHandler = (IntCtrl_Ip_IrqHandlerType)pVectorRam[((sint32)eIrqNumber) + 16];
    1cf8:	9b03      	ldr	r3, [sp, #12]
    1cfa:	3310      	adds	r3, #16
    1cfc:	009b      	lsls	r3, r3, #2
    1cfe:	9a05      	ldr	r2, [sp, #20]
    1d00:	4413      	add	r3, r2
    1d02:	681a      	ldr	r2, [r3, #0]
    1d04:	9b01      	ldr	r3, [sp, #4]
    1d06:	601a      	str	r2, [r3, #0]
    }

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber) + 16] = pfNewHandler;
    1d08:	9b03      	ldr	r3, [sp, #12]
    1d0a:	3310      	adds	r3, #16
    1d0c:	009b      	lsls	r3, r3, #2
    1d0e:	9a05      	ldr	r2, [sp, #20]
    1d10:	4413      	add	r3, r2
    1d12:	9a02      	ldr	r2, [sp, #8]
    1d14:	601a      	str	r2, [r3, #0]
    S32_SCB->ICIALLU = 0UL;
#endif
    
#endif /* (INT_CTRL_IP_CORTEXR == STD_ON) || (INT_CTRL_IP_CORTEXA == STD_ON) */
/*LDRA_NOANALYSIS*/
    MCAL_INSTRUCTION_SYNC_BARRIER();
    1d16:	f3bf 8f6f 	isb	sy
    MCAL_DATA_SYNC_BARRIER();
    1d1a:	f3bf 8f4f 	dsb	sy
/*LDRA_ANALYSIS*/    
}
    1d1e:	bf00      	nop
    1d20:	b006      	add	sp, #24
    1d22:	4770      	bx	lr

00001d24 <IntCtrl_Ip_EnableIrqPrivileged>:

void IntCtrl_Ip_EnableIrqPrivileged(IRQn_Type eIrqNumber)
{
    1d24:	b082      	sub	sp, #8
    1d26:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ISENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ISER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1d28:	9b01      	ldr	r3, [sp, #4]
    1d2a:	f003 021f 	and.w	r2, r3, #31
    1d2e:	4905      	ldr	r1, [pc, #20]	; (1d44 <IntCtrl_Ip_EnableIrqPrivileged+0x20>)
    1d30:	9b01      	ldr	r3, [sp, #4]
    1d32:	095b      	lsrs	r3, r3, #5
    1d34:	2001      	movs	r0, #1
    1d36:	fa00 f202 	lsl.w	r2, r0, r2
    1d3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    1d3e:	bf00      	nop
    1d40:	b002      	add	sp, #8
    1d42:	4770      	bx	lr
    1d44:	e000e100 	.word	0xe000e100

00001d48 <IntCtrl_Ip_DisableIrqPrivileged>:

void IntCtrl_Ip_DisableIrqPrivileged(IRQn_Type eIrqNumber)
{
    1d48:	b082      	sub	sp, #8
    1d4a:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ICENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ICER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1d4c:	9b01      	ldr	r3, [sp, #4]
    1d4e:	f003 021f 	and.w	r2, r3, #31
    1d52:	4906      	ldr	r1, [pc, #24]	; (1d6c <IntCtrl_Ip_DisableIrqPrivileged+0x24>)
    1d54:	9b01      	ldr	r3, [sp, #4]
    1d56:	095b      	lsrs	r3, r3, #5
    1d58:	2001      	movs	r0, #1
    1d5a:	fa00 f202 	lsl.w	r2, r0, r2
    1d5e:	3320      	adds	r3, #32
    1d60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    1d64:	bf00      	nop
    1d66:	b002      	add	sp, #8
    1d68:	4770      	bx	lr
    1d6a:	bf00      	nop
    1d6c:	e000e100 	.word	0xe000e100

00001d70 <IntCtrl_Ip_SetPriorityPrivileged>:

void IntCtrl_Ip_SetPriorityPrivileged(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1d70:	b084      	sub	sp, #16
    1d72:	9001      	str	r0, [sp, #4]
    1d74:	460b      	mov	r3, r1
    1d76:	f88d 3003 	strb.w	r3, [sp, #3]
#endif

#endif /* (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON) */

#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8) (8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    1d7a:	2304      	movs	r3, #4
    1d7c:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Set Priority for device specific Interrupts */
        S32_NVIC->IP[(uint32)(eIrqNumber)] = (uint8)((((uint32)u8Priority) << shift) & 0xFFUL);
    1d80:	f89d 2003 	ldrb.w	r2, [sp, #3]
    1d84:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1d88:	fa02 f103 	lsl.w	r1, r2, r3
    1d8c:	4a04      	ldr	r2, [pc, #16]	; (1da0 <IntCtrl_Ip_SetPriorityPrivileged+0x30>)
    1d8e:	9b01      	ldr	r3, [sp, #4]
    1d90:	b2c9      	uxtb	r1, r1
    1d92:	4413      	add	r3, r2
    1d94:	460a      	mov	r2, r1
    1d96:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] &= ~(0xFFUL << priByteShift);
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] |= ((uint32)(((((uint32)u8Priority) << shift_gic)) & 0xFFUL)) << priByteShift;
        }
    #endif
#endif
}
    1d9a:	bf00      	nop
    1d9c:	b004      	add	sp, #16
    1d9e:	4770      	bx	lr
    1da0:	e000e100 	.word	0xe000e100

00001da4 <IntCtrl_Ip_GetPriorityPrivileged>:

uint8 IntCtrl_Ip_GetPriorityPrivileged(IRQn_Type eIrqNumber)
{
    1da4:	b084      	sub	sp, #16
    1da6:	9001      	str	r0, [sp, #4]

    uint8 priority;


#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8)(8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    1da8:	2304      	movs	r3, #4
    1daa:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Get Priority for device specific Interrupts  */
        priority = (uint8)(S32_NVIC->IP[(uint32)(eIrqNumber)] >> shift);
    1dae:	4a09      	ldr	r2, [pc, #36]	; (1dd4 <IntCtrl_Ip_GetPriorityPrivileged+0x30>)
    1db0:	9b01      	ldr	r3, [sp, #4]
    1db2:	4413      	add	r3, r2
    1db4:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
    1db8:	b2db      	uxtb	r3, r3
    1dba:	461a      	mov	r2, r3
    1dbc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1dc0:	fa42 f303 	asr.w	r3, r2, r3
    1dc4:	f88d 300e 	strb.w	r3, [sp, #14]
            uint8 priByteShift = (uint8)((((uint8)(eIrqNumber)) & 0x3U) << 3U);
            priority = ((uint8)(IP_GIC500->GICD.IPRIORITYR[iprVectorId] >> priByteShift)) >> shift_gic;
        }
    #endif
#endif
    return priority;
    1dc8:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    1dcc:	4618      	mov	r0, r3
    1dce:	b004      	add	sp, #16
    1dd0:	4770      	bx	lr
    1dd2:	bf00      	nop
    1dd4:	e000e100 	.word	0xe000e100

00001dd8 <IntCtrl_Ip_ClearPendingPrivileged>:

void IntCtrl_Ip_ClearPendingPrivileged(IRQn_Type eIrqNumber)
{
    1dd8:	b082      	sub	sp, #8
    1dda:	9001      	str	r0, [sp, #4]
    }
#endif

#else
    /* Clear Pending Interrupt */
    S32_NVIC->ICPR[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1ddc:	9b01      	ldr	r3, [sp, #4]
    1dde:	f003 021f 	and.w	r2, r3, #31
    1de2:	4906      	ldr	r1, [pc, #24]	; (1dfc <IntCtrl_Ip_ClearPendingPrivileged+0x24>)
    1de4:	9b01      	ldr	r3, [sp, #4]
    1de6:	095b      	lsrs	r3, r3, #5
    1de8:	2001      	movs	r0, #1
    1dea:	fa00 f202 	lsl.w	r2, r0, r2
    1dee:	3360      	adds	r3, #96	; 0x60
    1df0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
    1df4:	bf00      	nop
    1df6:	b002      	add	sp, #8
    1df8:	4770      	bx	lr
    1dfa:	bf00      	nop
    1dfc:	e000e100 	.word	0xe000e100

00001e00 <IntCtrl_Ip_Init>:
 * @internal
 * @brief         Initializes the configured interrupts at interrupt controller level.
 * @implements    IntCtrl_Ip_Init_Activity
 */
IntCtrl_Ip_StatusType IntCtrl_Ip_Init(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1e00:	b500      	push	{lr}
    1e02:	b085      	sub	sp, #20
    1e04:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(pIntCtrlCtrlConfig != NULL_PTR);
    DevAssert(pIntCtrlCtrlConfig->u32ConfigIrqCount <= INT_CTRL_IP_IRQ_COUNT);
#endif
    uint32 irqIdx;
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1e06:	2300      	movs	r3, #0
    1e08:	9303      	str	r3, [sp, #12]
    1e0a:	e05d      	b.n	1ec8 <IntCtrl_Ip_Init+0xc8>
    {
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1e0c:	9b01      	ldr	r3, [sp, #4]
    1e0e:	6859      	ldr	r1, [r3, #4]
    1e10:	9a03      	ldr	r2, [sp, #12]
    1e12:	4613      	mov	r3, r2
    1e14:	005b      	lsls	r3, r3, #1
    1e16:	4413      	add	r3, r2
    1e18:	009b      	lsls	r3, r3, #2
    1e1a:	440b      	add	r3, r1
    1e1c:	681b      	ldr	r3, [r3, #0]
    1e1e:	4618      	mov	r0, r3
    1e20:	f000 f899 	bl	1f56 <IntCtrl_Ip_ClearPending>
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e24:	9b01      	ldr	r3, [sp, #4]
    1e26:	6859      	ldr	r1, [r3, #4]
    1e28:	9a03      	ldr	r2, [sp, #12]
    1e2a:	4613      	mov	r3, r2
    1e2c:	005b      	lsls	r3, r3, #1
    1e2e:	4413      	add	r3, r2
    1e30:	009b      	lsls	r3, r3, #2
    1e32:	440b      	add	r3, r1
    1e34:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1e36:	9b01      	ldr	r3, [sp, #4]
    1e38:	6859      	ldr	r1, [r3, #4]
    1e3a:	9a03      	ldr	r2, [sp, #12]
    1e3c:	4613      	mov	r3, r2
    1e3e:	005b      	lsls	r3, r3, #1
    1e40:	4413      	add	r3, r2
    1e42:	009b      	lsls	r3, r3, #2
    1e44:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e46:	795b      	ldrb	r3, [r3, #5]
    1e48:	4619      	mov	r1, r3
    1e4a:	f000 f869 	bl	1f20 <IntCtrl_Ip_SetPriority>

        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e4e:	9b01      	ldr	r3, [sp, #4]
    1e50:	6859      	ldr	r1, [r3, #4]
    1e52:	9a03      	ldr	r2, [sp, #12]
    1e54:	4613      	mov	r3, r2
    1e56:	005b      	lsls	r3, r3, #1
    1e58:	4413      	add	r3, r2
    1e5a:	009b      	lsls	r3, r3, #2
    1e5c:	440b      	add	r3, r1
    1e5e:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1e60:	9b01      	ldr	r3, [sp, #4]
    1e62:	6859      	ldr	r1, [r3, #4]
    1e64:	9a03      	ldr	r2, [sp, #12]
    1e66:	4613      	mov	r3, r2
    1e68:	005b      	lsls	r3, r3, #1
    1e6a:	4413      	add	r3, r2
    1e6c:	009b      	lsls	r3, r3, #2
    1e6e:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e70:	689b      	ldr	r3, [r3, #8]
    1e72:	2200      	movs	r2, #0
    1e74:	4619      	mov	r1, r3
    1e76:	f000 f831 	bl	1edc <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1e7a:	9b01      	ldr	r3, [sp, #4]
    1e7c:	6859      	ldr	r1, [r3, #4]
    1e7e:	9a03      	ldr	r2, [sp, #12]
    1e80:	4613      	mov	r3, r2
    1e82:	005b      	lsls	r3, r3, #1
    1e84:	4413      	add	r3, r2
    1e86:	009b      	lsls	r3, r3, #2
    1e88:	440b      	add	r3, r1
    1e8a:	791b      	ldrb	r3, [r3, #4]
    1e8c:	2b00      	cmp	r3, #0
    1e8e:	d00c      	beq.n	1eaa <IntCtrl_Ip_Init+0xaa>
        {
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1e90:	9b01      	ldr	r3, [sp, #4]
    1e92:	6859      	ldr	r1, [r3, #4]
    1e94:	9a03      	ldr	r2, [sp, #12]
    1e96:	4613      	mov	r3, r2
    1e98:	005b      	lsls	r3, r3, #1
    1e9a:	4413      	add	r3, r2
    1e9c:	009b      	lsls	r3, r3, #2
    1e9e:	440b      	add	r3, r1
    1ea0:	681b      	ldr	r3, [r3, #0]
    1ea2:	4618      	mov	r0, r3
    1ea4:	f000 f828 	bl	1ef8 <IntCtrl_Ip_EnableIrq>
    1ea8:	e00b      	b.n	1ec2 <IntCtrl_Ip_Init+0xc2>
        }
        else
        {
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1eaa:	9b01      	ldr	r3, [sp, #4]
    1eac:	6859      	ldr	r1, [r3, #4]
    1eae:	9a03      	ldr	r2, [sp, #12]
    1eb0:	4613      	mov	r3, r2
    1eb2:	005b      	lsls	r3, r3, #1
    1eb4:	4413      	add	r3, r2
    1eb6:	009b      	lsls	r3, r3, #2
    1eb8:	440b      	add	r3, r1
    1eba:	681b      	ldr	r3, [r3, #0]
    1ebc:	4618      	mov	r0, r3
    1ebe:	f000 f825 	bl	1f0c <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1ec2:	9b03      	ldr	r3, [sp, #12]
    1ec4:	3301      	adds	r3, #1
    1ec6:	9303      	str	r3, [sp, #12]
    1ec8:	9b01      	ldr	r3, [sp, #4]
    1eca:	681b      	ldr	r3, [r3, #0]
    1ecc:	9a03      	ldr	r2, [sp, #12]
    1ece:	429a      	cmp	r2, r3
    1ed0:	d39c      	bcc.n	1e0c <IntCtrl_Ip_Init+0xc>
        }
    }

    return INTCTRL_IP_STATUS_SUCCESS;
    1ed2:	2300      	movs	r3, #0
}
    1ed4:	4618      	mov	r0, r3
    1ed6:	b005      	add	sp, #20
    1ed8:	f85d fb04 	ldr.w	pc, [sp], #4

00001edc <IntCtrl_Ip_InstallHandler>:
 * @implements    IntCtrl_Ip_InstallHandler_Activity
 */
void IntCtrl_Ip_InstallHandler(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1edc:	b500      	push	{lr}
    1ede:	b085      	sub	sp, #20
    1ee0:	9003      	str	r0, [sp, #12]
    1ee2:	9102      	str	r1, [sp, #8]
    1ee4:	9201      	str	r2, [sp, #4]
    Call_IntCtrl_Ip_InstallHandlerPrivileged(eIrqNumber,pfNewHandler,pfOldHandler);
    1ee6:	9a01      	ldr	r2, [sp, #4]
    1ee8:	9902      	ldr	r1, [sp, #8]
    1eea:	9803      	ldr	r0, [sp, #12]
    1eec:	f7ff fef8 	bl	1ce0 <IntCtrl_Ip_InstallHandlerPrivileged>
}
    1ef0:	bf00      	nop
    1ef2:	b005      	add	sp, #20
    1ef4:	f85d fb04 	ldr.w	pc, [sp], #4

00001ef8 <IntCtrl_Ip_EnableIrq>:
 * @internal
 * @brief         Enables an interrupt request.
 * @implements    IntCtrl_Ip_EnableIrq_Activity
 */
void IntCtrl_Ip_EnableIrq(IRQn_Type eIrqNumber)
{
    1ef8:	b500      	push	{lr}
    1efa:	b083      	sub	sp, #12
    1efc:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_EnableIrqPrivileged(eIrqNumber);
    1efe:	9801      	ldr	r0, [sp, #4]
    1f00:	f7ff ff10 	bl	1d24 <IntCtrl_Ip_EnableIrqPrivileged>
}
    1f04:	bf00      	nop
    1f06:	b003      	add	sp, #12
    1f08:	f85d fb04 	ldr.w	pc, [sp], #4

00001f0c <IntCtrl_Ip_DisableIrq>:
 * @internal
 * @brief         Disables an interrupt request.
 * @implements    IntCtrl_Ip_DisableIrq_Activity
 */
void IntCtrl_Ip_DisableIrq(IRQn_Type eIrqNumber)
{
    1f0c:	b500      	push	{lr}
    1f0e:	b083      	sub	sp, #12
    1f10:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_DisableIrqPrivileged(eIrqNumber);
    1f12:	9801      	ldr	r0, [sp, #4]
    1f14:	f7ff ff18 	bl	1d48 <IntCtrl_Ip_DisableIrqPrivileged>
}
    1f18:	bf00      	nop
    1f1a:	b003      	add	sp, #12
    1f1c:	f85d fb04 	ldr.w	pc, [sp], #4

00001f20 <IntCtrl_Ip_SetPriority>:
 * @internal
 * @brief         Sets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_SetPriority_Activity
 */
void IntCtrl_Ip_SetPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1f20:	b500      	push	{lr}
    1f22:	b083      	sub	sp, #12
    1f24:	9001      	str	r0, [sp, #4]
    1f26:	460b      	mov	r3, r1
    1f28:	f88d 3003 	strb.w	r3, [sp, #3]
    Call_IntCtrl_Ip_SetPriorityPrivileged(eIrqNumber,u8Priority);
    1f2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1f30:	4619      	mov	r1, r3
    1f32:	9801      	ldr	r0, [sp, #4]
    1f34:	f7ff ff1c 	bl	1d70 <IntCtrl_Ip_SetPriorityPrivileged>
}
    1f38:	bf00      	nop
    1f3a:	b003      	add	sp, #12
    1f3c:	f85d fb04 	ldr.w	pc, [sp], #4

00001f40 <IntCtrl_Ip_GetPriority>:
 * @internal
 * @brief         Gets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_GetPriority_Activity
 */
uint8 IntCtrl_Ip_GetPriority(IRQn_Type eIrqNumber)
{
    1f40:	b500      	push	{lr}
    1f42:	b083      	sub	sp, #12
    1f44:	9001      	str	r0, [sp, #4]
    return (uint8)Call_IntCtrl_Ip_GetPriorityPrivileged(eIrqNumber);
    1f46:	9801      	ldr	r0, [sp, #4]
    1f48:	f7ff ff2c 	bl	1da4 <IntCtrl_Ip_GetPriorityPrivileged>
    1f4c:	4603      	mov	r3, r0
}
    1f4e:	4618      	mov	r0, r3
    1f50:	b003      	add	sp, #12
    1f52:	f85d fb04 	ldr.w	pc, [sp], #4

00001f56 <IntCtrl_Ip_ClearPending>:
 * @internal
 * @brief         Clears the pending flag for an interrupt request.
 * @implements    IntCtrl_Ip_ClearPending_Activity
 */
void IntCtrl_Ip_ClearPending(IRQn_Type eIrqNumber)
{
    1f56:	b500      	push	{lr}
    1f58:	b083      	sub	sp, #12
    1f5a:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_ClearPendingPrivileged(eIrqNumber);
    1f5c:	9801      	ldr	r0, [sp, #4]
    1f5e:	f7ff ff3b 	bl	1dd8 <IntCtrl_Ip_ClearPendingPrivileged>
}
    1f62:	bf00      	nop
    1f64:	b003      	add	sp, #12
    1f66:	f85d fb04 	ldr.w	pc, [sp], #4
    1f6a:	bf00      	nop

00001f6c <Platform_Ipw_SetIrq>:
/**
 * @internal
 * @brief         Enables/disables an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1f6c:	b500      	push	{lr}
    1f6e:	b083      	sub	sp, #12
    1f70:	9001      	str	r0, [sp, #4]
    1f72:	460b      	mov	r3, r1
    1f74:	f88d 3003 	strb.w	r3, [sp, #3]
    if (bEnable)
    1f78:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1f7c:	2b00      	cmp	r3, #0
    1f7e:	d003      	beq.n	1f88 <Platform_Ipw_SetIrq+0x1c>
    {
        IntCtrl_Ip_EnableIrq(eIrqNumber);
    1f80:	9801      	ldr	r0, [sp, #4]
    1f82:	f7ff ffb9 	bl	1ef8 <IntCtrl_Ip_EnableIrq>
    }
    else
    {
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    }
}
    1f86:	e002      	b.n	1f8e <Platform_Ipw_SetIrq+0x22>
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    1f88:	9801      	ldr	r0, [sp, #4]
    1f8a:	f7ff ffbf 	bl	1f0c <IntCtrl_Ip_DisableIrq>
}
    1f8e:	bf00      	nop
    1f90:	b003      	add	sp, #12
    1f92:	f85d fb04 	ldr.w	pc, [sp], #4

00001f96 <Platform_Ipw_SetIrqPriority>:
/**
 * @internal
 * @brief         Sets the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1f96:	b500      	push	{lr}
    1f98:	b083      	sub	sp, #12
    1f9a:	9001      	str	r0, [sp, #4]
    1f9c:	460b      	mov	r3, r1
    1f9e:	f88d 3003 	strb.w	r3, [sp, #3]
    IntCtrl_Ip_SetPriority(eIrqNumber, u8Priority);
    1fa2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1fa6:	4619      	mov	r1, r3
    1fa8:	9801      	ldr	r0, [sp, #4]
    1faa:	f7ff ffb9 	bl	1f20 <IntCtrl_Ip_SetPriority>
}
    1fae:	bf00      	nop
    1fb0:	b003      	add	sp, #12
    1fb2:	f85d fb04 	ldr.w	pc, [sp], #4

00001fb6 <Platform_Ipw_GetIrqPriority>:
/**
 * @internal
 * @brief         Returns the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline uint8 Platform_Ipw_GetIrqPriority(IRQn_Type eIrqNumber)
{
    1fb6:	b500      	push	{lr}
    1fb8:	b083      	sub	sp, #12
    1fba:	9001      	str	r0, [sp, #4]
    return IntCtrl_Ip_GetPriority(eIrqNumber);
    1fbc:	9801      	ldr	r0, [sp, #4]
    1fbe:	f7ff ffbf 	bl	1f40 <IntCtrl_Ip_GetPriority>
    1fc2:	4603      	mov	r3, r0
}
    1fc4:	4618      	mov	r0, r3
    1fc6:	b003      	add	sp, #12
    1fc8:	f85d fb04 	ldr.w	pc, [sp], #4

00001fcc <Platform_Ipw_InstallIrqHandler>:
 * @brief         Installs a new interrupt handler by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_InstallIrqHandler(IRQn_Type eIrqNumber,
                                                  const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                                                  IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1fcc:	b500      	push	{lr}
    1fce:	b085      	sub	sp, #20
    1fd0:	9003      	str	r0, [sp, #12]
    1fd2:	9102      	str	r1, [sp, #8]
    1fd4:	9201      	str	r2, [sp, #4]
    IntCtrl_Ip_InstallHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1fd6:	9a01      	ldr	r2, [sp, #4]
    1fd8:	9902      	ldr	r1, [sp, #8]
    1fda:	9803      	ldr	r0, [sp, #12]
    1fdc:	f7ff ff7e 	bl	1edc <IntCtrl_Ip_InstallHandler>
}
    1fe0:	bf00      	nop
    1fe2:	b005      	add	sp, #20
    1fe4:	f85d fb04 	ldr.w	pc, [sp], #4

00001fe8 <Platform_Init>:
 * @internal
 * @brief         Initializes the platform settings based on user configuration.
 * @implements    Platform_Init_Activity
 */
void Platform_Init(const Platform_ConfigType *pConfig)
{
    1fe8:	b500      	push	{lr}
    1fea:	b085      	sub	sp, #20
    1fec:	9001      	str	r0, [sp, #4]
    uint8 u8CoreId;

    u8CoreId = (uint8)Platform_GetCoreID();
    1fee:	2300      	movs	r3, #0
    1ff0:	f88d 300f 	strb.w	r3, [sp, #15]
        {
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
#endif /*(PLATFORM_DEV_ERROR_DETECT == STD_ON)*/


            Platform_Ipw_Init(Platform_Config[u8CoreId]->pIpwConfig);
    1ff4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1ff8:	4a05      	ldr	r2, [pc, #20]	; (2010 <Platform_Init+0x28>)
    1ffa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1ffe:	681b      	ldr	r3, [r3, #0]
    2000:	4618      	mov	r0, r3
    2002:	f000 f8c7 	bl	2194 <Platform_Ipw_Init>
        }
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
    }
#endif /* (PLATFORM_DEV_ERROR_DETECT == STD_ON)*/

}
    2006:	bf00      	nop
    2008:	b005      	add	sp, #20
    200a:	f85d fb04 	ldr.w	pc, [sp], #4
    200e:	bf00      	nop
    2010:	00010bcc 	.word	0x00010bcc

00002014 <Platform_SetIrq>:
 * @internal
 * @brief         Configures (enables/disables) an interrupt request.
 * @implements    Platform_SetIrq_Activity
 */
Std_ReturnType Platform_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    2014:	b500      	push	{lr}
    2016:	b085      	sub	sp, #20
    2018:	9001      	str	r0, [sp, #4]
    201a:	460b      	mov	r3, r1
    201c:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    2020:	2300      	movs	r3, #0
    2022:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrq(eIrqNumber, bEnable);
    2026:	f89d 3003 	ldrb.w	r3, [sp, #3]
    202a:	4619      	mov	r1, r3
    202c:	9801      	ldr	r0, [sp, #4]
    202e:	f7ff ff9d 	bl	1f6c <Platform_Ipw_SetIrq>
    }
    return RetValue;
    2032:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2036:	4618      	mov	r0, r3
    2038:	b005      	add	sp, #20
    203a:	f85d fb04 	ldr.w	pc, [sp], #4

0000203e <Platform_SetIrqPriority>:
 * @internal
 * @brief         Configures the priority of an interrupt request.
 * @implements    Platform_SetIrqPriority_Activity
 */
Std_ReturnType Platform_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    203e:	b500      	push	{lr}
    2040:	b085      	sub	sp, #20
    2042:	9001      	str	r0, [sp, #4]
    2044:	460b      	mov	r3, r1
    2046:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    204a:	2300      	movs	r3, #0
    204c:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrqPriority(eIrqNumber, u8Priority);
    2050:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2054:	4619      	mov	r1, r3
    2056:	9801      	ldr	r0, [sp, #4]
    2058:	f7ff ff9d 	bl	1f96 <Platform_Ipw_SetIrqPriority>
    }
    return RetValue;
    205c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2060:	4618      	mov	r0, r3
    2062:	b005      	add	sp, #20
    2064:	f85d fb04 	ldr.w	pc, [sp], #4

00002068 <Platform_GetIrqPriority>:
 * @internal
 * @brief         Returns the priority of an interrupt request.
 * @implements    Platform_GetIrqPriority_Activity
 */
Std_ReturnType Platform_GetIrqPriority(IRQn_Type eIrqNumber, uint8 * u8Priority)
{
    2068:	b500      	push	{lr}
    206a:	b085      	sub	sp, #20
    206c:	9001      	str	r0, [sp, #4]
    206e:	9100      	str	r1, [sp, #0]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    2070:	2300      	movs	r3, #0
    2072:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        *u8Priority = Platform_Ipw_GetIrqPriority(eIrqNumber);
    2076:	9801      	ldr	r0, [sp, #4]
    2078:	f7ff ff9d 	bl	1fb6 <Platform_Ipw_GetIrqPriority>
    207c:	4603      	mov	r3, r0
    207e:	461a      	mov	r2, r3
    2080:	9b00      	ldr	r3, [sp, #0]
    2082:	701a      	strb	r2, [r3, #0]
    }

    return RetValue;
    2084:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2088:	4618      	mov	r0, r3
    208a:	b005      	add	sp, #20
    208c:	f85d fb04 	ldr.w	pc, [sp], #4

00002090 <Platform_InstallIrqHandler>:
 * @implements    Platform_InstallIrqHandler_Activity
 */
Std_ReturnType Platform_InstallIrqHandler(IRQn_Type eIrqNumber,
                                          const Platform_IrqHandlerType pfNewHandler,
                                          Platform_IrqHandlerType* const pfOldHandler)
{
    2090:	b500      	push	{lr}
    2092:	b087      	sub	sp, #28
    2094:	9003      	str	r0, [sp, #12]
    2096:	9102      	str	r1, [sp, #8]
    2098:	9201      	str	r2, [sp, #4]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    209a:	2300      	movs	r3, #0
    209c:	f88d 3017 	strb.w	r3, [sp, #23]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_InstallIrqHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    20a0:	9a01      	ldr	r2, [sp, #4]
    20a2:	9902      	ldr	r1, [sp, #8]
    20a4:	9803      	ldr	r0, [sp, #12]
    20a6:	f7ff ff91 	bl	1fcc <Platform_Ipw_InstallIrqHandler>
    }
    return RetValue;
    20aa:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    20ae:	4618      	mov	r0, r3
    20b0:	b007      	add	sp, #28
    20b2:	f85d fb04 	ldr.w	pc, [sp], #4
    20b6:	bf00      	nop

000020b8 <Platform_Ipw_InitIntCtrl>:
#endif



static Std_ReturnType Platform_Ipw_InitIntCtrl(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    20b8:	b500      	push	{lr}
    20ba:	b085      	sub	sp, #20
    20bc:	9001      	str	r0, [sp, #4]
    uint32 irqIdx;
    
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    20be:	2300      	movs	r3, #0
    20c0:	9303      	str	r3, [sp, #12]
    20c2:	e05d      	b.n	2180 <Platform_Ipw_InitIntCtrl+0xc8>
    {   
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    20c4:	9b01      	ldr	r3, [sp, #4]
    20c6:	6859      	ldr	r1, [r3, #4]
    20c8:	9a03      	ldr	r2, [sp, #12]
    20ca:	4613      	mov	r3, r2
    20cc:	005b      	lsls	r3, r3, #1
    20ce:	4413      	add	r3, r2
    20d0:	009b      	lsls	r3, r3, #2
    20d2:	440b      	add	r3, r1
    20d4:	681b      	ldr	r3, [r3, #0]
    20d6:	4618      	mov	r0, r3
    20d8:	f7ff ff3d 	bl	1f56 <IntCtrl_Ip_ClearPending>
        /* interrupt number for which the priority is set */
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    20dc:	9b01      	ldr	r3, [sp, #4]
    20de:	6859      	ldr	r1, [r3, #4]
    20e0:	9a03      	ldr	r2, [sp, #12]
    20e2:	4613      	mov	r3, r2
    20e4:	005b      	lsls	r3, r3, #1
    20e6:	4413      	add	r3, r2
    20e8:	009b      	lsls	r3, r3, #2
    20ea:	440b      	add	r3, r1
    20ec:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    20ee:	9b01      	ldr	r3, [sp, #4]
    20f0:	6859      	ldr	r1, [r3, #4]
    20f2:	9a03      	ldr	r2, [sp, #12]
    20f4:	4613      	mov	r3, r2
    20f6:	005b      	lsls	r3, r3, #1
    20f8:	4413      	add	r3, r2
    20fa:	009b      	lsls	r3, r3, #2
    20fc:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    20fe:	795b      	ldrb	r3, [r3, #5]
    2100:	4619      	mov	r1, r3
    2102:	f7ff ff0d 	bl	1f20 <IntCtrl_Ip_SetPriority>
        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    2106:	9b01      	ldr	r3, [sp, #4]
    2108:	6859      	ldr	r1, [r3, #4]
    210a:	9a03      	ldr	r2, [sp, #12]
    210c:	4613      	mov	r3, r2
    210e:	005b      	lsls	r3, r3, #1
    2110:	4413      	add	r3, r2
    2112:	009b      	lsls	r3, r3, #2
    2114:	440b      	add	r3, r1
    2116:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    2118:	9b01      	ldr	r3, [sp, #4]
    211a:	6859      	ldr	r1, [r3, #4]
    211c:	9a03      	ldr	r2, [sp, #12]
    211e:	4613      	mov	r3, r2
    2120:	005b      	lsls	r3, r3, #1
    2122:	4413      	add	r3, r2
    2124:	009b      	lsls	r3, r3, #2
    2126:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    2128:	689b      	ldr	r3, [r3, #8]
    212a:	2200      	movs	r2, #0
    212c:	4619      	mov	r1, r3
    212e:	f7ff fed5 	bl	1edc <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        /* Enable interrupt */                       
        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    2132:	9b01      	ldr	r3, [sp, #4]
    2134:	6859      	ldr	r1, [r3, #4]
    2136:	9a03      	ldr	r2, [sp, #12]
    2138:	4613      	mov	r3, r2
    213a:	005b      	lsls	r3, r3, #1
    213c:	4413      	add	r3, r2
    213e:	009b      	lsls	r3, r3, #2
    2140:	440b      	add	r3, r1
    2142:	791b      	ldrb	r3, [r3, #4]
    2144:	2b00      	cmp	r3, #0
    2146:	d00c      	beq.n	2162 <Platform_Ipw_InitIntCtrl+0xaa>
        {   
            /* enables the interrupt request at interrupt controller level. */
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    2148:	9b01      	ldr	r3, [sp, #4]
    214a:	6859      	ldr	r1, [r3, #4]
    214c:	9a03      	ldr	r2, [sp, #12]
    214e:	4613      	mov	r3, r2
    2150:	005b      	lsls	r3, r3, #1
    2152:	4413      	add	r3, r2
    2154:	009b      	lsls	r3, r3, #2
    2156:	440b      	add	r3, r1
    2158:	681b      	ldr	r3, [r3, #0]
    215a:	4618      	mov	r0, r3
    215c:	f7ff fecc 	bl	1ef8 <IntCtrl_Ip_EnableIrq>
    2160:	e00b      	b.n	217a <Platform_Ipw_InitIntCtrl+0xc2>
        }
        else
        {   
            /* disables the interrupt request at interrupt controller level.*/
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    2162:	9b01      	ldr	r3, [sp, #4]
    2164:	6859      	ldr	r1, [r3, #4]
    2166:	9a03      	ldr	r2, [sp, #12]
    2168:	4613      	mov	r3, r2
    216a:	005b      	lsls	r3, r3, #1
    216c:	4413      	add	r3, r2
    216e:	009b      	lsls	r3, r3, #2
    2170:	440b      	add	r3, r1
    2172:	681b      	ldr	r3, [r3, #0]
    2174:	4618      	mov	r0, r3
    2176:	f7ff fec9 	bl	1f0c <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    217a:	9b03      	ldr	r3, [sp, #12]
    217c:	3301      	adds	r3, #1
    217e:	9303      	str	r3, [sp, #12]
    2180:	9b01      	ldr	r3, [sp, #4]
    2182:	681b      	ldr	r3, [r3, #0]
    2184:	9a03      	ldr	r2, [sp, #12]
    2186:	429a      	cmp	r2, r3
    2188:	d39c      	bcc.n	20c4 <Platform_Ipw_InitIntCtrl+0xc>
        }
    }

    return E_OK;
    218a:	2300      	movs	r3, #0
}
    218c:	4618      	mov	r0, r3
    218e:	b005      	add	sp, #20
    2190:	f85d fb04 	ldr.w	pc, [sp], #4

00002194 <Platform_Ipw_Init>:

/**
 * @brief         Initializes the platform settings based on user configuration.
 */
void Platform_Ipw_Init(const Platform_Ipw_ConfigType *pConfig)
{    
    2194:	b500      	push	{lr}
    2196:	b085      	sub	sp, #20
    2198:	9001      	str	r0, [sp, #4]
#if ((PLATFORM_SYS_CFG == STD_ON)&&(INT_CTRL_IP_CORTEXM == STD_ON))
    uint8 irqIdx;
#endif
    Std_ReturnType ret = (Std_ReturnType)E_OK;
    219a:	2300      	movs	r3, #0
    219c:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Initialize interrupts at interrupt controller level */
    if (NULL_PTR != pConfig->pIntCtrlConfig)
    21a0:	9b01      	ldr	r3, [sp, #4]
    21a2:	681b      	ldr	r3, [r3, #0]
    21a4:	2b00      	cmp	r3, #0
    21a6:	d007      	beq.n	21b8 <Platform_Ipw_Init+0x24>
    {
        ret = Platform_Ipw_InitIntCtrl(pConfig->pIntCtrlConfig);
    21a8:	9b01      	ldr	r3, [sp, #4]
    21aa:	681b      	ldr	r3, [r3, #0]
    21ac:	4618      	mov	r0, r3
    21ae:	f7ff ff83 	bl	20b8 <Platform_Ipw_InitIntCtrl>
    21b2:	4603      	mov	r3, r0
    21b4:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    if(ret == (Std_ReturnType)E_OK)
    21b8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    21bc:	2b00      	cmp	r3, #0
            /* Call_System_Ip_SetAhbSlavePriority((pConfig->aSystemConfig)->bAhbSlavePriority); */
#endif
        }  
#endif
    }
}
    21be:	bf00      	nop
    21c0:	b005      	add	sp, #20
    21c2:	f85d fb04 	ldr.w	pc, [sp], #4

000021c6 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
    21c6:	2300      	movs	r3, #0
}
    21c8:	4618      	mov	r0, r3
    21ca:	4770      	bx	lr

000021cc <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    21cc:	b082      	sub	sp, #8
    21ce:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    21d0:	2301      	movs	r3, #1
}
    21d2:	4618      	mov	r0, r3
    21d4:	b002      	add	sp, #8
    21d6:	4770      	bx	lr

000021d8 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    21d8:	b082      	sub	sp, #8
    21da:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    21dc:	bf00      	nop
    21de:	b002      	add	sp, #8
    21e0:	4770      	bx	lr

000021e2 <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    21e2:	b082      	sub	sp, #8
    21e4:	9001      	str	r0, [sp, #4]
    return Micros;
    21e6:	9b01      	ldr	r3, [sp, #4]
}
    21e8:	4618      	mov	r0, r3
    21ea:	b002      	add	sp, #8
    21ec:	4770      	bx	lr

000021ee <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    21ee:	b500      	push	{lr}
    21f0:	b083      	sub	sp, #12
    21f2:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    21f4:	f000 f86c 	bl	22d0 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    21f8:	bf00      	nop
    21fa:	b003      	add	sp, #12
    21fc:	f85d fb04 	ldr.w	pc, [sp], #4

00002200 <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    2200:	b500      	push	{lr}
    2202:	b085      	sub	sp, #20
    2204:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    2206:	2300      	movs	r3, #0
    2208:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    220a:	9b01      	ldr	r3, [sp, #4]
    220c:	2b00      	cmp	r3, #0
    220e:	d003      	beq.n	2218 <OsIf_GetCounter+0x18>
    2210:	9b01      	ldr	r3, [sp, #4]
    2212:	2b01      	cmp	r3, #1
    2214:	d004      	beq.n	2220 <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    2216:	e007      	b.n	2228 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    2218:	f7ff ffd5 	bl	21c6 <OsIf_Timer_Dummy_GetCounter>
    221c:	9003      	str	r0, [sp, #12]
            break;
    221e:	e003      	b.n	2228 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    2220:	f000 f872 	bl	2308 <OsIf_Timer_System_GetCounter>
    2224:	9003      	str	r0, [sp, #12]
            break;
    2226:	bf00      	nop
    }

    return Value;
    2228:	9b03      	ldr	r3, [sp, #12]
}
    222a:	4618      	mov	r0, r3
    222c:	b005      	add	sp, #20
    222e:	f85d fb04 	ldr.w	pc, [sp], #4

00002232 <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    2232:	b500      	push	{lr}
    2234:	b085      	sub	sp, #20
    2236:	9001      	str	r0, [sp, #4]
    2238:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    223a:	2300      	movs	r3, #0
    223c:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    223e:	9b00      	ldr	r3, [sp, #0]
    2240:	2b00      	cmp	r3, #0
    2242:	d003      	beq.n	224c <OsIf_GetElapsed+0x1a>
    2244:	9b00      	ldr	r3, [sp, #0]
    2246:	2b01      	cmp	r3, #1
    2248:	d005      	beq.n	2256 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    224a:	e009      	b.n	2260 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    224c:	9801      	ldr	r0, [sp, #4]
    224e:	f7ff ffbd 	bl	21cc <OsIf_Timer_Dummy_GetElapsed>
    2252:	9003      	str	r0, [sp, #12]
            break;
    2254:	e004      	b.n	2260 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    2256:	9801      	ldr	r0, [sp, #4]
    2258:	f000 f864 	bl	2324 <OsIf_Timer_System_GetElapsed>
    225c:	9003      	str	r0, [sp, #12]
            break;
    225e:	bf00      	nop
    }

    return Value;
    2260:	9b03      	ldr	r3, [sp, #12]
}
    2262:	4618      	mov	r0, r3
    2264:	b005      	add	sp, #20
    2266:	f85d fb04 	ldr.w	pc, [sp], #4

0000226a <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    226a:	b500      	push	{lr}
    226c:	b083      	sub	sp, #12
    226e:	9001      	str	r0, [sp, #4]
    2270:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    2272:	9b00      	ldr	r3, [sp, #0]
    2274:	2b00      	cmp	r3, #0
    2276:	d003      	beq.n	2280 <OsIf_SetTimerFrequency+0x16>
    2278:	9b00      	ldr	r3, [sp, #0]
    227a:	2b01      	cmp	r3, #1
    227c:	d004      	beq.n	2288 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    227e:	e007      	b.n	2290 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    2280:	9801      	ldr	r0, [sp, #4]
    2282:	f7ff ffa9 	bl	21d8 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    2286:	e003      	b.n	2290 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    2288:	9801      	ldr	r0, [sp, #4]
    228a:	f000 f85b 	bl	2344 <OsIf_Timer_System_SetTimerFrequency>
            break;
    228e:	bf00      	nop
    }
}
    2290:	bf00      	nop
    2292:	b003      	add	sp, #12
    2294:	f85d fb04 	ldr.w	pc, [sp], #4

00002298 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    2298:	b500      	push	{lr}
    229a:	b085      	sub	sp, #20
    229c:	9001      	str	r0, [sp, #4]
    229e:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    22a0:	2300      	movs	r3, #0
    22a2:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    22a4:	9b00      	ldr	r3, [sp, #0]
    22a6:	2b00      	cmp	r3, #0
    22a8:	d003      	beq.n	22b2 <OsIf_MicrosToTicks+0x1a>
    22aa:	9b00      	ldr	r3, [sp, #0]
    22ac:	2b01      	cmp	r3, #1
    22ae:	d005      	beq.n	22bc <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    22b0:	e009      	b.n	22c6 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    22b2:	9801      	ldr	r0, [sp, #4]
    22b4:	f7ff ff95 	bl	21e2 <OsIf_Timer_Dummy_MicrosToTicks>
    22b8:	9003      	str	r0, [sp, #12]
            break;
    22ba:	e004      	b.n	22c6 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    22bc:	9801      	ldr	r0, [sp, #4]
    22be:	f000 f84f 	bl	2360 <OsIf_Timer_System_MicrosToTicks>
    22c2:	9003      	str	r0, [sp, #12]
            break;
    22c4:	bf00      	nop
    }

    return Value;
    22c6:	9b03      	ldr	r3, [sp, #12]
}
    22c8:	4618      	mov	r0, r3
    22ca:	b005      	add	sp, #20
    22cc:	f85d fb04 	ldr.w	pc, [sp], #4

000022d0 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    22d0:	b500      	push	{lr}
    22d2:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    22d4:	2300      	movs	r3, #0
    22d6:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    22d8:	4a09      	ldr	r2, [pc, #36]	; (2300 <OsIf_Timer_System_Init+0x30>)
    22da:	9b01      	ldr	r3, [sp, #4]
    22dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22e0:	685a      	ldr	r2, [r3, #4]
    22e2:	4908      	ldr	r1, [pc, #32]	; (2304 <OsIf_Timer_System_Init+0x34>)
    22e4:	9b01      	ldr	r3, [sp, #4]
    22e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    22ea:	4a06      	ldr	r2, [pc, #24]	; (2304 <OsIf_Timer_System_Init+0x34>)
    22ec:	9b01      	ldr	r3, [sp, #4]
    22ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22f2:	4618      	mov	r0, r3
    22f4:	f000 f868 	bl	23c8 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    22f8:	bf00      	nop
    22fa:	b003      	add	sp, #12
    22fc:	f85d fb04 	ldr.w	pc, [sp], #4
    2300:	00010bc4 	.word	0x00010bc4
    2304:	1fff8b4c 	.word	0x1fff8b4c

00002308 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    2308:	b500      	push	{lr}
    230a:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    230c:	2300      	movs	r3, #0
    230e:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    2310:	2300      	movs	r3, #0
    2312:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    2314:	f000 f86c 	bl	23f0 <OsIf_Timer_System_Internal_GetCounter>
    2318:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    231a:	9b01      	ldr	r3, [sp, #4]
}
    231c:	4618      	mov	r0, r3
    231e:	b003      	add	sp, #12
    2320:	f85d fb04 	ldr.w	pc, [sp], #4

00002324 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    2324:	b500      	push	{lr}
    2326:	b085      	sub	sp, #20
    2328:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    232a:	2300      	movs	r3, #0
    232c:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    232e:	2300      	movs	r3, #0
    2330:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    2332:	9801      	ldr	r0, [sp, #4]
    2334:	f000 f864 	bl	2400 <OsIf_Timer_System_Internal_GetElapsed>
    2338:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    233a:	9b03      	ldr	r3, [sp, #12]
}
    233c:	4618      	mov	r0, r3
    233e:	b005      	add	sp, #20
    2340:	f85d fb04 	ldr.w	pc, [sp], #4

00002344 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    2344:	b084      	sub	sp, #16
    2346:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    2348:	2300      	movs	r3, #0
    234a:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    234c:	4903      	ldr	r1, [pc, #12]	; (235c <OsIf_Timer_System_SetTimerFrequency+0x18>)
    234e:	9b03      	ldr	r3, [sp, #12]
    2350:	9a01      	ldr	r2, [sp, #4]
    2352:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    2356:	bf00      	nop
    2358:	b004      	add	sp, #16
    235a:	4770      	bx	lr
    235c:	1fff8b4c 	.word	0x1fff8b4c

00002360 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    2360:	b5f0      	push	{r4, r5, r6, r7, lr}
    2362:	b087      	sub	sp, #28
    2364:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    2366:	2100      	movs	r1, #0
    2368:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    236a:	2100      	movs	r1, #0
    236c:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    236e:	9901      	ldr	r1, [sp, #4]
    2370:	2000      	movs	r0, #0
    2372:	460e      	mov	r6, r1
    2374:	4607      	mov	r7, r0
    2376:	4812      	ldr	r0, [pc, #72]	; (23c0 <OsIf_Timer_System_MicrosToTicks+0x60>)
    2378:	9904      	ldr	r1, [sp, #16]
    237a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    237e:	2000      	movs	r0, #0
    2380:	460c      	mov	r4, r1
    2382:	4605      	mov	r5, r0
    2384:	fb04 f007 	mul.w	r0, r4, r7
    2388:	fb06 f105 	mul.w	r1, r6, r5
    238c:	4401      	add	r1, r0
    238e:	fba6 2304 	umull	r2, r3, r6, r4
    2392:	4419      	add	r1, r3
    2394:	460b      	mov	r3, r1
    2396:	e9cd 2302 	strd	r2, r3, [sp, #8]
    239a:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    239e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    23a2:	4a08      	ldr	r2, [pc, #32]	; (23c4 <OsIf_Timer_System_MicrosToTicks+0x64>)
    23a4:	f04f 0300 	mov.w	r3, #0
    23a8:	f7fe f8fc 	bl	5a4 <__aeabi_uldivmod>
    23ac:	4602      	mov	r2, r0
    23ae:	460b      	mov	r3, r1
    23b0:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    23b4:	9b02      	ldr	r3, [sp, #8]
    23b6:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    23b8:	9b05      	ldr	r3, [sp, #20]
}
    23ba:	4618      	mov	r0, r3
    23bc:	b007      	add	sp, #28
    23be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    23c0:	1fff8b4c 	.word	0x1fff8b4c
    23c4:	000f4240 	.word	0x000f4240

000023c8 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    23c8:	b082      	sub	sp, #8
    23ca:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    23cc:	4b07      	ldr	r3, [pc, #28]	; (23ec <OsIf_Timer_System_Internal_Init+0x24>)
    23ce:	2200      	movs	r2, #0
    23d0:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    23d2:	4b06      	ldr	r3, [pc, #24]	; (23ec <OsIf_Timer_System_Internal_Init+0x24>)
    23d4:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    23d8:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    23da:	4b04      	ldr	r3, [pc, #16]	; (23ec <OsIf_Timer_System_Internal_Init+0x24>)
    23dc:	2200      	movs	r2, #0
    23de:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    23e0:	4b02      	ldr	r3, [pc, #8]	; (23ec <OsIf_Timer_System_Internal_Init+0x24>)
    23e2:	2205      	movs	r2, #5
    23e4:	601a      	str	r2, [r3, #0]
}
    23e6:	bf00      	nop
    23e8:	b002      	add	sp, #8
    23ea:	4770      	bx	lr
    23ec:	e000e010 	.word	0xe000e010

000023f0 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    23f0:	4b02      	ldr	r3, [pc, #8]	; (23fc <OsIf_Timer_System_Internal_GetCounter+0xc>)
    23f2:	689b      	ldr	r3, [r3, #8]
    23f4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    23f8:	4618      	mov	r0, r3
    23fa:	4770      	bx	lr
    23fc:	e000e010 	.word	0xe000e010

00002400 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    2400:	b084      	sub	sp, #16
    2402:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    2404:	4b10      	ldr	r3, [pc, #64]	; (2448 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    2406:	689b      	ldr	r3, [r3, #8]
    2408:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    240c:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    240e:	2300      	movs	r3, #0
    2410:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    2412:	9b01      	ldr	r3, [sp, #4]
    2414:	681b      	ldr	r3, [r3, #0]
    2416:	9a02      	ldr	r2, [sp, #8]
    2418:	429a      	cmp	r2, r3
    241a:	d909      	bls.n	2430 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    241c:	9b01      	ldr	r3, [sp, #4]
    241e:	681a      	ldr	r2, [r3, #0]
    2420:	9b02      	ldr	r3, [sp, #8]
    2422:	1ad3      	subs	r3, r2, r3
    2424:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    2428:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    242c:	9303      	str	r3, [sp, #12]
    242e:	e004      	b.n	243a <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    2430:	9b01      	ldr	r3, [sp, #4]
    2432:	681a      	ldr	r2, [r3, #0]
    2434:	9b02      	ldr	r3, [sp, #8]
    2436:	1ad3      	subs	r3, r2, r3
    2438:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    243a:	9b01      	ldr	r3, [sp, #4]
    243c:	9a02      	ldr	r2, [sp, #8]
    243e:	601a      	str	r2, [r3, #0]

    return dif;
    2440:	9b03      	ldr	r3, [sp, #12]
}
    2442:	4618      	mov	r0, r3
    2444:	b004      	add	sp, #16
    2446:	4770      	bx	lr
    2448:	e000e010 	.word	0xe000e010

0000244c <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    244c:	b082      	sub	sp, #8
    244e:	9001      	str	r0, [sp, #4]
    2450:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    2452:	bf00      	nop
    2454:	b002      	add	sp, #8
    2456:	4770      	bx	lr

00002458 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    2458:	b500      	push	{lr}
    245a:	b085      	sub	sp, #20
    245c:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    245e:	4b24      	ldr	r3, [pc, #144]	; (24f0 <Clock_Ip_UpdateDriverContext+0x98>)
    2460:	2201      	movs	r2, #1
    2462:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2464:	4b23      	ldr	r3, [pc, #140]	; (24f4 <Clock_Ip_UpdateDriverContext+0x9c>)
    2466:	681b      	ldr	r3, [r3, #0]
    2468:	2102      	movs	r1, #2
    246a:	4618      	mov	r0, r3
    246c:	f003 fc32 	bl	5cd4 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    2470:	2300      	movs	r3, #0
    2472:	f88d 300f 	strb.w	r3, [sp, #15]
    2476:	e015      	b.n	24a4 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    2478:	f89d 300f 	ldrb.w	r3, [sp, #15]
    247c:	9a01      	ldr	r2, [sp, #4]
    247e:	334a      	adds	r3, #74	; 0x4a
    2480:	00db      	lsls	r3, r3, #3
    2482:	4413      	add	r3, r2
    2484:	6858      	ldr	r0, [r3, #4]
    2486:	f89d 300f 	ldrb.w	r3, [sp, #15]
    248a:	9a01      	ldr	r2, [sp, #4]
    248c:	334a      	adds	r3, #74	; 0x4a
    248e:	00db      	lsls	r3, r3, #3
    2490:	4413      	add	r3, r2
    2492:	689b      	ldr	r3, [r3, #8]
    2494:	4619      	mov	r1, r3
    2496:	f001 fadc 	bl	3a52 <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    249a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    249e:	3301      	adds	r3, #1
    24a0:	f88d 300f 	strb.w	r3, [sp, #15]
    24a4:	9b01      	ldr	r3, [sp, #4]
    24a6:	7bdb      	ldrb	r3, [r3, #15]
    24a8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    24ac:	429a      	cmp	r2, r3
    24ae:	d3e3      	bcc.n	2478 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    24b0:	f000 f824 	bl	24fc <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    24b4:	2301      	movs	r3, #1
    24b6:	f88d 300f 	strb.w	r3, [sp, #15]
    24ba:	e00e      	b.n	24da <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    24bc:	f89d 200f 	ldrb.w	r2, [sp, #15]
    24c0:	9b01      	ldr	r3, [sp, #4]
    24c2:	327e      	adds	r2, #126	; 0x7e
    24c4:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    24c8:	490b      	ldr	r1, [pc, #44]	; (24f8 <Clock_Ip_UpdateDriverContext+0xa0>)
    24ca:	f89d 200f 	ldrb.w	r2, [sp, #15]
    24ce:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    24d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    24d4:	3301      	adds	r3, #1
    24d6:	f88d 300f 	strb.w	r3, [sp, #15]
    24da:	9b01      	ldr	r3, [sp, #4]
    24dc:	7cdb      	ldrb	r3, [r3, #19]
    24de:	f89d 200f 	ldrb.w	r2, [sp, #15]
    24e2:	429a      	cmp	r2, r3
    24e4:	d3ea      	bcc.n	24bc <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    24e6:	bf00      	nop
    24e8:	bf00      	nop
    24ea:	b005      	add	sp, #20
    24ec:	f85d fb04 	ldr.w	pc, [sp], #4
    24f0:	1fff8b10 	.word	0x1fff8b10
    24f4:	1fff8b50 	.word	0x1fff8b50
    24f8:	1fff8b5c 	.word	0x1fff8b5c

000024fc <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    24fc:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    24fe:	4b23      	ldr	r3, [pc, #140]	; (258c <Clock_Ip_CallEmptyCallbacks+0x90>)
    2500:	781b      	ldrb	r3, [r3, #0]
    2502:	f083 0301 	eor.w	r3, r3, #1
    2506:	b2db      	uxtb	r3, r3
    2508:	2b00      	cmp	r3, #0
    250a:	d03d      	beq.n	2588 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    250c:	4b1f      	ldr	r3, [pc, #124]	; (258c <Clock_Ip_CallEmptyCallbacks+0x90>)
    250e:	2201      	movs	r2, #1
    2510:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    2512:	4b1f      	ldr	r3, [pc, #124]	; (2590 <Clock_Ip_CallEmptyCallbacks+0x94>)
    2514:	685b      	ldr	r3, [r3, #4]
    2516:	2100      	movs	r1, #0
    2518:	2000      	movs	r0, #0
    251a:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    251c:	4b1c      	ldr	r3, [pc, #112]	; (2590 <Clock_Ip_CallEmptyCallbacks+0x94>)
    251e:	689b      	ldr	r3, [r3, #8]
    2520:	2057      	movs	r0, #87	; 0x57
    2522:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2524:	4b1b      	ldr	r3, [pc, #108]	; (2594 <Clock_Ip_CallEmptyCallbacks+0x98>)
    2526:	681b      	ldr	r3, [r3, #0]
    2528:	2000      	movs	r0, #0
    252a:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    252c:	4b1a      	ldr	r3, [pc, #104]	; (2598 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    252e:	681b      	ldr	r3, [r3, #0]
    2530:	2000      	movs	r0, #0
    2532:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    2534:	4b19      	ldr	r3, [pc, #100]	; (259c <Clock_Ip_CallEmptyCallbacks+0xa0>)
    2536:	681b      	ldr	r3, [r3, #0]
    2538:	2000      	movs	r0, #0
    253a:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    253c:	4b18      	ldr	r3, [pc, #96]	; (25a0 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    253e:	685b      	ldr	r3, [r3, #4]
    2540:	2000      	movs	r0, #0
    2542:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    2544:	4b16      	ldr	r3, [pc, #88]	; (25a0 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    2546:	689b      	ldr	r3, [r3, #8]
    2548:	2057      	movs	r0, #87	; 0x57
    254a:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    254c:	4b15      	ldr	r3, [pc, #84]	; (25a4 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    254e:	681b      	ldr	r3, [r3, #0]
    2550:	2000      	movs	r0, #0
    2552:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    2554:	4b13      	ldr	r3, [pc, #76]	; (25a4 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    2556:	685b      	ldr	r3, [r3, #4]
    2558:	2100      	movs	r1, #0
    255a:	2057      	movs	r0, #87	; 0x57
    255c:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    255e:	4b12      	ldr	r3, [pc, #72]	; (25a8 <Clock_Ip_CallEmptyCallbacks+0xac>)
    2560:	681b      	ldr	r3, [r3, #0]
    2562:	2000      	movs	r0, #0
    2564:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2566:	4b11      	ldr	r3, [pc, #68]	; (25ac <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2568:	685b      	ldr	r3, [r3, #4]
    256a:	2000      	movs	r0, #0
    256c:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    256e:	4b0f      	ldr	r3, [pc, #60]	; (25ac <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2570:	689b      	ldr	r3, [r3, #8]
    2572:	2057      	movs	r0, #87	; 0x57
    2574:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2576:	4b0e      	ldr	r3, [pc, #56]	; (25b0 <Clock_Ip_CallEmptyCallbacks+0xb4>)
    2578:	685b      	ldr	r3, [r3, #4]
    257a:	2000      	movs	r0, #0
    257c:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    257e:	4b0d      	ldr	r3, [pc, #52]	; (25b4 <Clock_Ip_CallEmptyCallbacks+0xb8>)
    2580:	681b      	ldr	r3, [r3, #0]
    2582:	2100      	movs	r1, #0
    2584:	2000      	movs	r0, #0
    2586:	4798      	blx	r3
    }
}
    2588:	bf00      	nop
    258a:	bd08      	pop	{r3, pc}
    258c:	1fff8b54 	.word	0x1fff8b54
    2590:	00010420 	.word	0x00010420
    2594:	00010334 	.word	0x00010334
    2598:	00010370 	.word	0x00010370
    259c:	00010378 	.word	0x00010378
    25a0:	000103a0 	.word	0x000103a0
    25a4:	000103ac 	.word	0x000103ac
    25a8:	000103e4 	.word	0x000103e4
    25ac:	00010430 	.word	0x00010430
    25b0:	0001045c 	.word	0x0001045c
    25b4:	00010458 	.word	0x00010458

000025b8 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    25b8:	b500      	push	{lr}
    25ba:	b085      	sub	sp, #20
    25bc:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    25be:	9b01      	ldr	r3, [sp, #4]
    25c0:	7adb      	ldrb	r3, [r3, #11]
    25c2:	9303      	str	r3, [sp, #12]
    25c4:	e01f      	b.n	2606 <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    25c6:	9b03      	ldr	r3, [sp, #12]
    25c8:	1e5a      	subs	r2, r3, #1
    25ca:	9b01      	ldr	r3, [sp, #4]
    25cc:	320d      	adds	r2, #13
    25ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    25d2:	495a      	ldr	r1, [pc, #360]	; (273c <Clock_Ip_ResetClockConfiguration+0x184>)
    25d4:	4613      	mov	r3, r2
    25d6:	00db      	lsls	r3, r3, #3
    25d8:	4413      	add	r3, r2
    25da:	440b      	add	r3, r1
    25dc:	3301      	adds	r3, #1
    25de:	781b      	ldrb	r3, [r3, #0]
    25e0:	461a      	mov	r2, r3
    25e2:	4b57      	ldr	r3, [pc, #348]	; (2740 <Clock_Ip_ResetClockConfiguration+0x188>)
    25e4:	5c9b      	ldrb	r3, [r3, r2]
    25e6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    25e8:	4a56      	ldr	r2, [pc, #344]	; (2744 <Clock_Ip_ResetClockConfiguration+0x18c>)
    25ea:	9b02      	ldr	r3, [sp, #8]
    25ec:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    25f0:	9a03      	ldr	r2, [sp, #12]
    25f2:	3a01      	subs	r2, #1
    25f4:	320d      	adds	r2, #13
    25f6:	00d2      	lsls	r2, r2, #3
    25f8:	9901      	ldr	r1, [sp, #4]
    25fa:	440a      	add	r2, r1
    25fc:	4610      	mov	r0, r2
    25fe:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    2600:	9b03      	ldr	r3, [sp, #12]
    2602:	3b01      	subs	r3, #1
    2604:	9303      	str	r3, [sp, #12]
    2606:	9b03      	ldr	r3, [sp, #12]
    2608:	2b00      	cmp	r3, #0
    260a:	d1dc      	bne.n	25c6 <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    260c:	9b01      	ldr	r3, [sp, #4]
    260e:	7b9b      	ldrb	r3, [r3, #14]
    2610:	9303      	str	r3, [sp, #12]
    2612:	e026      	b.n	2662 <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2614:	9b03      	ldr	r3, [sp, #12]
    2616:	3b01      	subs	r3, #1
    2618:	9a01      	ldr	r2, [sp, #4]
    261a:	3324      	adds	r3, #36	; 0x24
    261c:	011b      	lsls	r3, r3, #4
    261e:	4413      	add	r3, r2
    2620:	3304      	adds	r3, #4
    2622:	681a      	ldr	r2, [r3, #0]
    2624:	4945      	ldr	r1, [pc, #276]	; (273c <Clock_Ip_ResetClockConfiguration+0x184>)
    2626:	4613      	mov	r3, r2
    2628:	00db      	lsls	r3, r3, #3
    262a:	4413      	add	r3, r2
    262c:	440b      	add	r3, r1
    262e:	3301      	adds	r3, #1
    2630:	781b      	ldrb	r3, [r3, #0]
    2632:	461a      	mov	r2, r3
    2634:	4b44      	ldr	r3, [pc, #272]	; (2748 <Clock_Ip_ResetClockConfiguration+0x190>)
    2636:	5c9b      	ldrb	r3, [r3, r2]
    2638:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    263a:	4944      	ldr	r1, [pc, #272]	; (274c <Clock_Ip_ResetClockConfiguration+0x194>)
    263c:	9a02      	ldr	r2, [sp, #8]
    263e:	4613      	mov	r3, r2
    2640:	005b      	lsls	r3, r3, #1
    2642:	4413      	add	r3, r2
    2644:	009b      	lsls	r3, r3, #2
    2646:	440b      	add	r3, r1
    2648:	681b      	ldr	r3, [r3, #0]
    264a:	9a03      	ldr	r2, [sp, #12]
    264c:	3a01      	subs	r2, #1
    264e:	3224      	adds	r2, #36	; 0x24
    2650:	0112      	lsls	r2, r2, #4
    2652:	9901      	ldr	r1, [sp, #4]
    2654:	440a      	add	r2, r1
    2656:	3204      	adds	r2, #4
    2658:	4610      	mov	r0, r2
    265a:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    265c:	9b03      	ldr	r3, [sp, #12]
    265e:	3b01      	subs	r3, #1
    2660:	9303      	str	r3, [sp, #12]
    2662:	9b03      	ldr	r3, [sp, #12]
    2664:	2b00      	cmp	r3, #0
    2666:	d1d5      	bne.n	2614 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    2668:	9b01      	ldr	r3, [sp, #4]
    266a:	7a9b      	ldrb	r3, [r3, #10]
    266c:	9303      	str	r3, [sp, #12]
    266e:	e02a      	b.n	26c6 <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2670:	9b03      	ldr	r3, [sp, #12]
    2672:	1e5a      	subs	r2, r3, #1
    2674:	9901      	ldr	r1, [sp, #4]
    2676:	4613      	mov	r3, r2
    2678:	009b      	lsls	r3, r3, #2
    267a:	4413      	add	r3, r2
    267c:	00db      	lsls	r3, r3, #3
    267e:	440b      	add	r3, r1
    2680:	3340      	adds	r3, #64	; 0x40
    2682:	681a      	ldr	r2, [r3, #0]
    2684:	492d      	ldr	r1, [pc, #180]	; (273c <Clock_Ip_ResetClockConfiguration+0x184>)
    2686:	4613      	mov	r3, r2
    2688:	00db      	lsls	r3, r3, #3
    268a:	4413      	add	r3, r2
    268c:	440b      	add	r3, r1
    268e:	3301      	adds	r3, #1
    2690:	781b      	ldrb	r3, [r3, #0]
    2692:	461a      	mov	r2, r3
    2694:	4b2e      	ldr	r3, [pc, #184]	; (2750 <Clock_Ip_ResetClockConfiguration+0x198>)
    2696:	5c9b      	ldrb	r3, [r3, r2]
    2698:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    269a:	492e      	ldr	r1, [pc, #184]	; (2754 <Clock_Ip_ResetClockConfiguration+0x19c>)
    269c:	9a02      	ldr	r2, [sp, #8]
    269e:	4613      	mov	r3, r2
    26a0:	009b      	lsls	r3, r3, #2
    26a2:	4413      	add	r3, r2
    26a4:	009b      	lsls	r3, r3, #2
    26a6:	440b      	add	r3, r1
    26a8:	6819      	ldr	r1, [r3, #0]
    26aa:	9b03      	ldr	r3, [sp, #12]
    26ac:	1e5a      	subs	r2, r3, #1
    26ae:	4613      	mov	r3, r2
    26b0:	009b      	lsls	r3, r3, #2
    26b2:	4413      	add	r3, r2
    26b4:	00db      	lsls	r3, r3, #3
    26b6:	3340      	adds	r3, #64	; 0x40
    26b8:	9a01      	ldr	r2, [sp, #4]
    26ba:	4413      	add	r3, r2
    26bc:	4618      	mov	r0, r3
    26be:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    26c0:	9b03      	ldr	r3, [sp, #12]
    26c2:	3b01      	subs	r3, #1
    26c4:	9303      	str	r3, [sp, #12]
    26c6:	9b03      	ldr	r3, [sp, #12]
    26c8:	2b00      	cmp	r3, #0
    26ca:	d1d1      	bne.n	2670 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    26cc:	9b01      	ldr	r3, [sp, #4]
    26ce:	7a5b      	ldrb	r3, [r3, #9]
    26d0:	9303      	str	r3, [sp, #12]
    26d2:	e02b      	b.n	272c <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    26d4:	9b03      	ldr	r3, [sp, #12]
    26d6:	1e5a      	subs	r2, r3, #1
    26d8:	9901      	ldr	r1, [sp, #4]
    26da:	4613      	mov	r3, r2
    26dc:	009b      	lsls	r3, r3, #2
    26de:	4413      	add	r3, r2
    26e0:	009b      	lsls	r3, r3, #2
    26e2:	440b      	add	r3, r1
    26e4:	332c      	adds	r3, #44	; 0x2c
    26e6:	681a      	ldr	r2, [r3, #0]
    26e8:	4914      	ldr	r1, [pc, #80]	; (273c <Clock_Ip_ResetClockConfiguration+0x184>)
    26ea:	4613      	mov	r3, r2
    26ec:	00db      	lsls	r3, r3, #3
    26ee:	4413      	add	r3, r2
    26f0:	440b      	add	r3, r1
    26f2:	3301      	adds	r3, #1
    26f4:	781b      	ldrb	r3, [r3, #0]
    26f6:	461a      	mov	r2, r3
    26f8:	4b17      	ldr	r3, [pc, #92]	; (2758 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    26fa:	5c9b      	ldrb	r3, [r3, r2]
    26fc:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    26fe:	4917      	ldr	r1, [pc, #92]	; (275c <Clock_Ip_ResetClockConfiguration+0x1a4>)
    2700:	9a02      	ldr	r2, [sp, #8]
    2702:	4613      	mov	r3, r2
    2704:	009b      	lsls	r3, r3, #2
    2706:	4413      	add	r3, r2
    2708:	009b      	lsls	r3, r3, #2
    270a:	440b      	add	r3, r1
    270c:	6819      	ldr	r1, [r3, #0]
    270e:	9b03      	ldr	r3, [sp, #12]
    2710:	1e5a      	subs	r2, r3, #1
    2712:	4613      	mov	r3, r2
    2714:	009b      	lsls	r3, r3, #2
    2716:	4413      	add	r3, r2
    2718:	009b      	lsls	r3, r3, #2
    271a:	3328      	adds	r3, #40	; 0x28
    271c:	9a01      	ldr	r2, [sp, #4]
    271e:	4413      	add	r3, r2
    2720:	3304      	adds	r3, #4
    2722:	4618      	mov	r0, r3
    2724:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    2726:	9b03      	ldr	r3, [sp, #12]
    2728:	3b01      	subs	r3, #1
    272a:	9303      	str	r3, [sp, #12]
    272c:	9b03      	ldr	r3, [sp, #12]
    272e:	2b00      	cmp	r3, #0
    2730:	d1d0      	bne.n	26d4 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    2732:	bf00      	nop
    2734:	bf00      	nop
    2736:	b005      	add	sp, #20
    2738:	f85d fb04 	ldr.w	pc, [sp], #4
    273c:	0000fe24 	.word	0x0000fe24
    2740:	0000fdf4 	.word	0x0000fdf4
    2744:	0001045c 	.word	0x0001045c
    2748:	0000fdd4 	.word	0x0000fdd4
    274c:	000103a0 	.word	0x000103a0
    2750:	0000fde4 	.word	0x0000fde4
    2754:	00010430 	.word	0x00010430
    2758:	0000fda4 	.word	0x0000fda4
    275c:	00010378 	.word	0x00010378

00002760 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    2760:	b500      	push	{lr}
    2762:	b085      	sub	sp, #20
    2764:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    2766:	2301      	movs	r3, #1
    2768:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    276a:	9801      	ldr	r0, [sp, #4]
    276c:	f000 f818 	bl	27a0 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    2770:	4b0a      	ldr	r3, [pc, #40]	; (279c <Clock_Ip_Init+0x3c>)
    2772:	781b      	ldrb	r3, [r3, #0]
    2774:	2b00      	cmp	r3, #0
    2776:	d00a      	beq.n	278e <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    2778:	f000 fb74 	bl	2e64 <Clock_Ip_GetPllStatus>
    277c:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    277e:	9b02      	ldr	r3, [sp, #8]
    2780:	2b00      	cmp	r3, #0
    2782:	d106      	bne.n	2792 <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    2784:	f000 fbf2 	bl	2f6c <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    2788:	2300      	movs	r3, #0
    278a:	9303      	str	r3, [sp, #12]
    278c:	e001      	b.n	2792 <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    278e:	2300      	movs	r3, #0
    2790:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    2792:	9b03      	ldr	r3, [sp, #12]
}
    2794:	4618      	mov	r0, r3
    2796:	b005      	add	sp, #20
    2798:	f85d fb04 	ldr.w	pc, [sp], #4
    279c:	1fff8b58 	.word	0x1fff8b58

000027a0 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    27a0:	b510      	push	{r4, lr}
    27a2:	b084      	sub	sp, #16
    27a4:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    27a6:	4a9f      	ldr	r2, [pc, #636]	; (2a24 <Clock_Ip_InitClock+0x284>)
    27a8:	9b01      	ldr	r3, [sp, #4]
    27aa:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    27ac:	2101      	movs	r1, #1
    27ae:	9801      	ldr	r0, [sp, #4]
    27b0:	f003 fa90 	bl	5cd4 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    27b4:	4b9b      	ldr	r3, [pc, #620]	; (2a24 <Clock_Ip_InitClock+0x284>)
    27b6:	681b      	ldr	r3, [r3, #0]
    27b8:	2b00      	cmp	r3, #0
    27ba:	d030      	beq.n	281e <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    27bc:	2300      	movs	r3, #0
    27be:	9303      	str	r3, [sp, #12]
    27c0:	e027      	b.n	2812 <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    27c2:	9901      	ldr	r1, [sp, #4]
    27c4:	9a03      	ldr	r2, [sp, #12]
    27c6:	4613      	mov	r3, r2
    27c8:	009b      	lsls	r3, r3, #2
    27ca:	4413      	add	r3, r2
    27cc:	009b      	lsls	r3, r3, #2
    27ce:	440b      	add	r3, r1
    27d0:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    27d4:	681a      	ldr	r2, [r3, #0]
    27d6:	4994      	ldr	r1, [pc, #592]	; (2a28 <Clock_Ip_InitClock+0x288>)
    27d8:	4613      	mov	r3, r2
    27da:	00db      	lsls	r3, r3, #3
    27dc:	4413      	add	r3, r2
    27de:	440b      	add	r3, r1
    27e0:	3301      	adds	r3, #1
    27e2:	781b      	ldrb	r3, [r3, #0]
    27e4:	461a      	mov	r2, r3
    27e6:	4b91      	ldr	r3, [pc, #580]	; (2a2c <Clock_Ip_InitClock+0x28c>)
    27e8:	5c9b      	ldrb	r3, [r3, r2]
    27ea:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    27ec:	4a90      	ldr	r2, [pc, #576]	; (2a30 <Clock_Ip_InitClock+0x290>)
    27ee:	9b02      	ldr	r3, [sp, #8]
    27f0:	011b      	lsls	r3, r3, #4
    27f2:	4413      	add	r3, r2
    27f4:	6819      	ldr	r1, [r3, #0]
    27f6:	9a03      	ldr	r2, [sp, #12]
    27f8:	4613      	mov	r3, r2
    27fa:	009b      	lsls	r3, r3, #2
    27fc:	4413      	add	r3, r2
    27fe:	009b      	lsls	r3, r3, #2
    2800:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2804:	9a01      	ldr	r2, [sp, #4]
    2806:	4413      	add	r3, r2
    2808:	4618      	mov	r0, r3
    280a:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    280c:	9b03      	ldr	r3, [sp, #12]
    280e:	3301      	adds	r3, #1
    2810:	9303      	str	r3, [sp, #12]
    2812:	9b01      	ldr	r3, [sp, #4]
    2814:	7c9b      	ldrb	r3, [r3, #18]
    2816:	461a      	mov	r2, r3
    2818:	9b03      	ldr	r3, [sp, #12]
    281a:	4293      	cmp	r3, r2
    281c:	d3d1      	bcc.n	27c2 <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    281e:	9801      	ldr	r0, [sp, #4]
    2820:	f7ff feca 	bl	25b8 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2824:	2300      	movs	r3, #0
    2826:	9303      	str	r3, [sp, #12]
    2828:	e029      	b.n	287e <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    282a:	9901      	ldr	r1, [sp, #4]
    282c:	9a03      	ldr	r2, [sp, #12]
    282e:	4613      	mov	r3, r2
    2830:	005b      	lsls	r3, r3, #1
    2832:	4413      	add	r3, r2
    2834:	009b      	lsls	r3, r3, #2
    2836:	440b      	add	r3, r1
    2838:	3314      	adds	r3, #20
    283a:	681a      	ldr	r2, [r3, #0]
    283c:	497a      	ldr	r1, [pc, #488]	; (2a28 <Clock_Ip_InitClock+0x288>)
    283e:	4613      	mov	r3, r2
    2840:	00db      	lsls	r3, r3, #3
    2842:	4413      	add	r3, r2
    2844:	440b      	add	r3, r1
    2846:	3301      	adds	r3, #1
    2848:	781b      	ldrb	r3, [r3, #0]
    284a:	461a      	mov	r2, r3
    284c:	4b79      	ldr	r3, [pc, #484]	; (2a34 <Clock_Ip_InitClock+0x294>)
    284e:	5c9b      	ldrb	r3, [r3, r2]
    2850:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    2852:	4979      	ldr	r1, [pc, #484]	; (2a38 <Clock_Ip_InitClock+0x298>)
    2854:	9a02      	ldr	r2, [sp, #8]
    2856:	4613      	mov	r3, r2
    2858:	005b      	lsls	r3, r3, #1
    285a:	4413      	add	r3, r2
    285c:	009b      	lsls	r3, r3, #2
    285e:	440b      	add	r3, r1
    2860:	6819      	ldr	r1, [r3, #0]
    2862:	9a03      	ldr	r2, [sp, #12]
    2864:	4613      	mov	r3, r2
    2866:	005b      	lsls	r3, r3, #1
    2868:	4413      	add	r3, r2
    286a:	009b      	lsls	r3, r3, #2
    286c:	3310      	adds	r3, #16
    286e:	9a01      	ldr	r2, [sp, #4]
    2870:	4413      	add	r3, r2
    2872:	3304      	adds	r3, #4
    2874:	4618      	mov	r0, r3
    2876:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2878:	9b03      	ldr	r3, [sp, #12]
    287a:	3301      	adds	r3, #1
    287c:	9303      	str	r3, [sp, #12]
    287e:	9b01      	ldr	r3, [sp, #4]
    2880:	7a1b      	ldrb	r3, [r3, #8]
    2882:	461a      	mov	r2, r3
    2884:	9b03      	ldr	r3, [sp, #12]
    2886:	4293      	cmp	r3, r2
    2888:	d3cf      	bcc.n	282a <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    288a:	2300      	movs	r3, #0
    288c:	9303      	str	r3, [sp, #12]
    288e:	e02a      	b.n	28e6 <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2890:	9901      	ldr	r1, [sp, #4]
    2892:	9a03      	ldr	r2, [sp, #12]
    2894:	4613      	mov	r3, r2
    2896:	009b      	lsls	r3, r3, #2
    2898:	4413      	add	r3, r2
    289a:	009b      	lsls	r3, r3, #2
    289c:	440b      	add	r3, r1
    289e:	332c      	adds	r3, #44	; 0x2c
    28a0:	681a      	ldr	r2, [r3, #0]
    28a2:	4961      	ldr	r1, [pc, #388]	; (2a28 <Clock_Ip_InitClock+0x288>)
    28a4:	4613      	mov	r3, r2
    28a6:	00db      	lsls	r3, r3, #3
    28a8:	4413      	add	r3, r2
    28aa:	440b      	add	r3, r1
    28ac:	3301      	adds	r3, #1
    28ae:	781b      	ldrb	r3, [r3, #0]
    28b0:	461a      	mov	r2, r3
    28b2:	4b62      	ldr	r3, [pc, #392]	; (2a3c <Clock_Ip_InitClock+0x29c>)
    28b4:	5c9b      	ldrb	r3, [r3, r2]
    28b6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    28b8:	4961      	ldr	r1, [pc, #388]	; (2a40 <Clock_Ip_InitClock+0x2a0>)
    28ba:	9a02      	ldr	r2, [sp, #8]
    28bc:	4613      	mov	r3, r2
    28be:	009b      	lsls	r3, r3, #2
    28c0:	4413      	add	r3, r2
    28c2:	009b      	lsls	r3, r3, #2
    28c4:	440b      	add	r3, r1
    28c6:	3304      	adds	r3, #4
    28c8:	6819      	ldr	r1, [r3, #0]
    28ca:	9a03      	ldr	r2, [sp, #12]
    28cc:	4613      	mov	r3, r2
    28ce:	009b      	lsls	r3, r3, #2
    28d0:	4413      	add	r3, r2
    28d2:	009b      	lsls	r3, r3, #2
    28d4:	3328      	adds	r3, #40	; 0x28
    28d6:	9a01      	ldr	r2, [sp, #4]
    28d8:	4413      	add	r3, r2
    28da:	3304      	adds	r3, #4
    28dc:	4618      	mov	r0, r3
    28de:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    28e0:	9b03      	ldr	r3, [sp, #12]
    28e2:	3301      	adds	r3, #1
    28e4:	9303      	str	r3, [sp, #12]
    28e6:	9b01      	ldr	r3, [sp, #4]
    28e8:	7a5b      	ldrb	r3, [r3, #9]
    28ea:	461a      	mov	r2, r3
    28ec:	9b03      	ldr	r3, [sp, #12]
    28ee:	4293      	cmp	r3, r2
    28f0:	d3ce      	bcc.n	2890 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    28f2:	9801      	ldr	r0, [sp, #4]
    28f4:	f7ff fdb0 	bl	2458 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    28f8:	2300      	movs	r3, #0
    28fa:	9303      	str	r3, [sp, #12]
    28fc:	e028      	b.n	2950 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    28fe:	9901      	ldr	r1, [sp, #4]
    2900:	9a03      	ldr	r2, [sp, #12]
    2902:	4613      	mov	r3, r2
    2904:	009b      	lsls	r3, r3, #2
    2906:	4413      	add	r3, r2
    2908:	009b      	lsls	r3, r3, #2
    290a:	440b      	add	r3, r1
    290c:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    2910:	681a      	ldr	r2, [r3, #0]
    2912:	4945      	ldr	r1, [pc, #276]	; (2a28 <Clock_Ip_InitClock+0x288>)
    2914:	4613      	mov	r3, r2
    2916:	00db      	lsls	r3, r3, #3
    2918:	4413      	add	r3, r2
    291a:	440b      	add	r3, r1
    291c:	3301      	adds	r3, #1
    291e:	781b      	ldrb	r3, [r3, #0]
    2920:	461a      	mov	r2, r3
    2922:	4b48      	ldr	r3, [pc, #288]	; (2a44 <Clock_Ip_InitClock+0x2a4>)
    2924:	5c9b      	ldrb	r3, [r3, r2]
    2926:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    2928:	4a47      	ldr	r2, [pc, #284]	; (2a48 <Clock_Ip_InitClock+0x2a8>)
    292a:	9b02      	ldr	r3, [sp, #8]
    292c:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    2930:	9a03      	ldr	r2, [sp, #12]
    2932:	4613      	mov	r3, r2
    2934:	009b      	lsls	r3, r3, #2
    2936:	4413      	add	r3, r2
    2938:	009b      	lsls	r3, r3, #2
    293a:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    293e:	9a01      	ldr	r2, [sp, #4]
    2940:	4413      	add	r3, r2
    2942:	3304      	adds	r3, #4
    2944:	9903      	ldr	r1, [sp, #12]
    2946:	4618      	mov	r0, r3
    2948:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    294a:	9b03      	ldr	r3, [sp, #12]
    294c:	3301      	adds	r3, #1
    294e:	9303      	str	r3, [sp, #12]
    2950:	9b01      	ldr	r3, [sp, #4]
    2952:	7c5b      	ldrb	r3, [r3, #17]
    2954:	461a      	mov	r2, r3
    2956:	9b03      	ldr	r3, [sp, #12]
    2958:	4293      	cmp	r3, r2
    295a:	d3d0      	bcc.n	28fe <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    295c:	2300      	movs	r3, #0
    295e:	9303      	str	r3, [sp, #12]
    2960:	e026      	b.n	29b0 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2962:	9901      	ldr	r1, [sp, #4]
    2964:	9a03      	ldr	r2, [sp, #12]
    2966:	4613      	mov	r3, r2
    2968:	005b      	lsls	r3, r3, #1
    296a:	4413      	add	r3, r2
    296c:	009b      	lsls	r3, r3, #2
    296e:	440b      	add	r3, r1
    2970:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2974:	681a      	ldr	r2, [r3, #0]
    2976:	492c      	ldr	r1, [pc, #176]	; (2a28 <Clock_Ip_InitClock+0x288>)
    2978:	4613      	mov	r3, r2
    297a:	00db      	lsls	r3, r3, #3
    297c:	4413      	add	r3, r2
    297e:	440b      	add	r3, r1
    2980:	3301      	adds	r3, #1
    2982:	781b      	ldrb	r3, [r3, #0]
    2984:	461a      	mov	r2, r3
    2986:	4b31      	ldr	r3, [pc, #196]	; (2a4c <Clock_Ip_InitClock+0x2ac>)
    2988:	5c9b      	ldrb	r3, [r3, r2]
    298a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    298c:	4a30      	ldr	r2, [pc, #192]	; (2a50 <Clock_Ip_InitClock+0x2b0>)
    298e:	9b02      	ldr	r3, [sp, #8]
    2990:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    2994:	9a03      	ldr	r2, [sp, #12]
    2996:	4613      	mov	r3, r2
    2998:	005b      	lsls	r3, r3, #1
    299a:	4413      	add	r3, r2
    299c:	009b      	lsls	r3, r3, #2
    299e:	f503 730e 	add.w	r3, r3, #568	; 0x238
    29a2:	9a01      	ldr	r2, [sp, #4]
    29a4:	4413      	add	r3, r2
    29a6:	4618      	mov	r0, r3
    29a8:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    29aa:	9b03      	ldr	r3, [sp, #12]
    29ac:	3301      	adds	r3, #1
    29ae:	9303      	str	r3, [sp, #12]
    29b0:	9b01      	ldr	r3, [sp, #4]
    29b2:	7b5b      	ldrb	r3, [r3, #13]
    29b4:	461a      	mov	r2, r3
    29b6:	9b03      	ldr	r3, [sp, #12]
    29b8:	4293      	cmp	r3, r2
    29ba:	d3d2      	bcc.n	2962 <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    29bc:	2300      	movs	r3, #0
    29be:	9303      	str	r3, [sp, #12]
    29c0:	e026      	b.n	2a10 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    29c2:	9901      	ldr	r1, [sp, #4]
    29c4:	9a03      	ldr	r2, [sp, #12]
    29c6:	4613      	mov	r3, r2
    29c8:	005b      	lsls	r3, r3, #1
    29ca:	4413      	add	r3, r2
    29cc:	009b      	lsls	r3, r3, #2
    29ce:	440b      	add	r3, r1
    29d0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    29d4:	681a      	ldr	r2, [r3, #0]
    29d6:	4914      	ldr	r1, [pc, #80]	; (2a28 <Clock_Ip_InitClock+0x288>)
    29d8:	4613      	mov	r3, r2
    29da:	00db      	lsls	r3, r3, #3
    29dc:	4413      	add	r3, r2
    29de:	440b      	add	r3, r1
    29e0:	3301      	adds	r3, #1
    29e2:	781b      	ldrb	r3, [r3, #0]
    29e4:	461a      	mov	r2, r3
    29e6:	4b1b      	ldr	r3, [pc, #108]	; (2a54 <Clock_Ip_InitClock+0x2b4>)
    29e8:	5c9b      	ldrb	r3, [r3, r2]
    29ea:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    29ec:	4a1a      	ldr	r2, [pc, #104]	; (2a58 <Clock_Ip_InitClock+0x2b8>)
    29ee:	9b02      	ldr	r3, [sp, #8]
    29f0:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    29f4:	9a03      	ldr	r2, [sp, #12]
    29f6:	4613      	mov	r3, r2
    29f8:	005b      	lsls	r3, r3, #1
    29fa:	4413      	add	r3, r2
    29fc:	009b      	lsls	r3, r3, #2
    29fe:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2a02:	9a01      	ldr	r2, [sp, #4]
    2a04:	4413      	add	r3, r2
    2a06:	4618      	mov	r0, r3
    2a08:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    2a0a:	9b03      	ldr	r3, [sp, #12]
    2a0c:	3301      	adds	r3, #1
    2a0e:	9303      	str	r3, [sp, #12]
    2a10:	9b01      	ldr	r3, [sp, #4]
    2a12:	7b1b      	ldrb	r3, [r3, #12]
    2a14:	461a      	mov	r2, r3
    2a16:	9b03      	ldr	r3, [sp, #12]
    2a18:	4293      	cmp	r3, r2
    2a1a:	d3d2      	bcc.n	29c2 <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2a1c:	2300      	movs	r3, #0
    2a1e:	9303      	str	r3, [sp, #12]
    2a20:	e044      	b.n	2aac <Clock_Ip_InitClock+0x30c>
    2a22:	bf00      	nop
    2a24:	1fff8b50 	.word	0x1fff8b50
    2a28:	0000fe24 	.word	0x0000fe24
    2a2c:	0000fe14 	.word	0x0000fe14
    2a30:	00010420 	.word	0x00010420
    2a34:	0000fdb4 	.word	0x0000fdb4
    2a38:	000103e4 	.word	0x000103e4
    2a3c:	0000fda4 	.word	0x0000fda4
    2a40:	00010378 	.word	0x00010378
    2a44:	0000fe04 	.word	0x0000fe04
    2a48:	00010458 	.word	0x00010458
    2a4c:	0000fd94 	.word	0x0000fd94
    2a50:	00010370 	.word	0x00010370
    2a54:	0000fd84 	.word	0x0000fd84
    2a58:	00010334 	.word	0x00010334
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2a5c:	9901      	ldr	r1, [sp, #4]
    2a5e:	9a03      	ldr	r2, [sp, #12]
    2a60:	4613      	mov	r3, r2
    2a62:	005b      	lsls	r3, r3, #1
    2a64:	4413      	add	r3, r2
    2a66:	009b      	lsls	r3, r3, #2
    2a68:	440b      	add	r3, r1
    2a6a:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2a6e:	681a      	ldr	r2, [r3, #0]
    2a70:	49ac      	ldr	r1, [pc, #688]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2a72:	4613      	mov	r3, r2
    2a74:	00db      	lsls	r3, r3, #3
    2a76:	4413      	add	r3, r2
    2a78:	440b      	add	r3, r1
    2a7a:	3301      	adds	r3, #1
    2a7c:	781b      	ldrb	r3, [r3, #0]
    2a7e:	461a      	mov	r2, r3
    2a80:	4ba9      	ldr	r3, [pc, #676]	; (2d28 <Clock_Ip_InitClock+0x588>)
    2a82:	5c9b      	ldrb	r3, [r3, r2]
    2a84:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    2a86:	4aa9      	ldr	r2, [pc, #676]	; (2d2c <Clock_Ip_InitClock+0x58c>)
    2a88:	9b02      	ldr	r3, [sp, #8]
    2a8a:	00db      	lsls	r3, r3, #3
    2a8c:	4413      	add	r3, r2
    2a8e:	6859      	ldr	r1, [r3, #4]
    2a90:	9a03      	ldr	r2, [sp, #12]
    2a92:	4613      	mov	r3, r2
    2a94:	005b      	lsls	r3, r3, #1
    2a96:	4413      	add	r3, r2
    2a98:	009b      	lsls	r3, r3, #2
    2a9a:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2a9e:	9a01      	ldr	r2, [sp, #4]
    2aa0:	4413      	add	r3, r2
    2aa2:	4618      	mov	r0, r3
    2aa4:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2aa6:	9b03      	ldr	r3, [sp, #12]
    2aa8:	3301      	adds	r3, #1
    2aaa:	9303      	str	r3, [sp, #12]
    2aac:	9b01      	ldr	r3, [sp, #4]
    2aae:	7b5b      	ldrb	r3, [r3, #13]
    2ab0:	461a      	mov	r2, r3
    2ab2:	9b03      	ldr	r3, [sp, #12]
    2ab4:	4293      	cmp	r3, r2
    2ab6:	d3d1      	bcc.n	2a5c <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2ab8:	2300      	movs	r3, #0
    2aba:	9303      	str	r3, [sp, #12]
    2abc:	e029      	b.n	2b12 <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    2abe:	9901      	ldr	r1, [sp, #4]
    2ac0:	9a03      	ldr	r2, [sp, #12]
    2ac2:	4613      	mov	r3, r2
    2ac4:	009b      	lsls	r3, r3, #2
    2ac6:	4413      	add	r3, r2
    2ac8:	00db      	lsls	r3, r3, #3
    2aca:	440b      	add	r3, r1
    2acc:	3340      	adds	r3, #64	; 0x40
    2ace:	681a      	ldr	r2, [r3, #0]
    2ad0:	4994      	ldr	r1, [pc, #592]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2ad2:	4613      	mov	r3, r2
    2ad4:	00db      	lsls	r3, r3, #3
    2ad6:	4413      	add	r3, r2
    2ad8:	440b      	add	r3, r1
    2ada:	3301      	adds	r3, #1
    2adc:	781b      	ldrb	r3, [r3, #0]
    2ade:	461a      	mov	r2, r3
    2ae0:	4b93      	ldr	r3, [pc, #588]	; (2d30 <Clock_Ip_InitClock+0x590>)
    2ae2:	5c9b      	ldrb	r3, [r3, r2]
    2ae4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    2ae6:	4993      	ldr	r1, [pc, #588]	; (2d34 <Clock_Ip_InitClock+0x594>)
    2ae8:	9a02      	ldr	r2, [sp, #8]
    2aea:	4613      	mov	r3, r2
    2aec:	009b      	lsls	r3, r3, #2
    2aee:	4413      	add	r3, r2
    2af0:	009b      	lsls	r3, r3, #2
    2af2:	440b      	add	r3, r1
    2af4:	3304      	adds	r3, #4
    2af6:	6819      	ldr	r1, [r3, #0]
    2af8:	9a03      	ldr	r2, [sp, #12]
    2afa:	4613      	mov	r3, r2
    2afc:	009b      	lsls	r3, r3, #2
    2afe:	4413      	add	r3, r2
    2b00:	00db      	lsls	r3, r3, #3
    2b02:	3340      	adds	r3, #64	; 0x40
    2b04:	9a01      	ldr	r2, [sp, #4]
    2b06:	4413      	add	r3, r2
    2b08:	4618      	mov	r0, r3
    2b0a:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2b0c:	9b03      	ldr	r3, [sp, #12]
    2b0e:	3301      	adds	r3, #1
    2b10:	9303      	str	r3, [sp, #12]
    2b12:	9b01      	ldr	r3, [sp, #4]
    2b14:	7a9b      	ldrb	r3, [r3, #10]
    2b16:	461a      	mov	r2, r3
    2b18:	9b03      	ldr	r3, [sp, #12]
    2b1a:	4293      	cmp	r3, r2
    2b1c:	d3cf      	bcc.n	2abe <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2b1e:	2300      	movs	r3, #0
    2b20:	9303      	str	r3, [sp, #12]
    2b22:	e029      	b.n	2b78 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2b24:	9901      	ldr	r1, [sp, #4]
    2b26:	9a03      	ldr	r2, [sp, #12]
    2b28:	4613      	mov	r3, r2
    2b2a:	009b      	lsls	r3, r3, #2
    2b2c:	4413      	add	r3, r2
    2b2e:	009b      	lsls	r3, r3, #2
    2b30:	440b      	add	r3, r1
    2b32:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2b36:	681a      	ldr	r2, [r3, #0]
    2b38:	497a      	ldr	r1, [pc, #488]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2b3a:	4613      	mov	r3, r2
    2b3c:	00db      	lsls	r3, r3, #3
    2b3e:	4413      	add	r3, r2
    2b40:	440b      	add	r3, r1
    2b42:	3301      	adds	r3, #1
    2b44:	781b      	ldrb	r3, [r3, #0]
    2b46:	461a      	mov	r2, r3
    2b48:	4b7b      	ldr	r3, [pc, #492]	; (2d38 <Clock_Ip_InitClock+0x598>)
    2b4a:	5c9b      	ldrb	r3, [r3, r2]
    2b4c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    2b4e:	4a7b      	ldr	r2, [pc, #492]	; (2d3c <Clock_Ip_InitClock+0x59c>)
    2b50:	9b02      	ldr	r3, [sp, #8]
    2b52:	011b      	lsls	r3, r3, #4
    2b54:	4413      	add	r3, r2
    2b56:	3304      	adds	r3, #4
    2b58:	681c      	ldr	r4, [r3, #0]
    2b5a:	9a03      	ldr	r2, [sp, #12]
    2b5c:	4613      	mov	r3, r2
    2b5e:	009b      	lsls	r3, r3, #2
    2b60:	4413      	add	r3, r2
    2b62:	009b      	lsls	r3, r3, #2
    2b64:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2b68:	9a01      	ldr	r2, [sp, #4]
    2b6a:	4413      	add	r3, r2
    2b6c:	9903      	ldr	r1, [sp, #12]
    2b6e:	4618      	mov	r0, r3
    2b70:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2b72:	9b03      	ldr	r3, [sp, #12]
    2b74:	3301      	adds	r3, #1
    2b76:	9303      	str	r3, [sp, #12]
    2b78:	9b01      	ldr	r3, [sp, #4]
    2b7a:	7c9b      	ldrb	r3, [r3, #18]
    2b7c:	461a      	mov	r2, r3
    2b7e:	9b03      	ldr	r3, [sp, #12]
    2b80:	4293      	cmp	r3, r2
    2b82:	d3cf      	bcc.n	2b24 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2b84:	2300      	movs	r3, #0
    2b86:	9303      	str	r3, [sp, #12]
    2b88:	e02a      	b.n	2be0 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2b8a:	9901      	ldr	r1, [sp, #4]
    2b8c:	9a03      	ldr	r2, [sp, #12]
    2b8e:	4613      	mov	r3, r2
    2b90:	009b      	lsls	r3, r3, #2
    2b92:	4413      	add	r3, r2
    2b94:	009b      	lsls	r3, r3, #2
    2b96:	440b      	add	r3, r1
    2b98:	332c      	adds	r3, #44	; 0x2c
    2b9a:	681a      	ldr	r2, [r3, #0]
    2b9c:	4961      	ldr	r1, [pc, #388]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2b9e:	4613      	mov	r3, r2
    2ba0:	00db      	lsls	r3, r3, #3
    2ba2:	4413      	add	r3, r2
    2ba4:	440b      	add	r3, r1
    2ba6:	3301      	adds	r3, #1
    2ba8:	781b      	ldrb	r3, [r3, #0]
    2baa:	461a      	mov	r2, r3
    2bac:	4b64      	ldr	r3, [pc, #400]	; (2d40 <Clock_Ip_InitClock+0x5a0>)
    2bae:	5c9b      	ldrb	r3, [r3, r2]
    2bb0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    2bb2:	4964      	ldr	r1, [pc, #400]	; (2d44 <Clock_Ip_InitClock+0x5a4>)
    2bb4:	9a02      	ldr	r2, [sp, #8]
    2bb6:	4613      	mov	r3, r2
    2bb8:	009b      	lsls	r3, r3, #2
    2bba:	4413      	add	r3, r2
    2bbc:	009b      	lsls	r3, r3, #2
    2bbe:	440b      	add	r3, r1
    2bc0:	3308      	adds	r3, #8
    2bc2:	6819      	ldr	r1, [r3, #0]
    2bc4:	9a03      	ldr	r2, [sp, #12]
    2bc6:	4613      	mov	r3, r2
    2bc8:	009b      	lsls	r3, r3, #2
    2bca:	4413      	add	r3, r2
    2bcc:	009b      	lsls	r3, r3, #2
    2bce:	3328      	adds	r3, #40	; 0x28
    2bd0:	9a01      	ldr	r2, [sp, #4]
    2bd2:	4413      	add	r3, r2
    2bd4:	3304      	adds	r3, #4
    2bd6:	4618      	mov	r0, r3
    2bd8:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2bda:	9b03      	ldr	r3, [sp, #12]
    2bdc:	3301      	adds	r3, #1
    2bde:	9303      	str	r3, [sp, #12]
    2be0:	9b01      	ldr	r3, [sp, #4]
    2be2:	7a5b      	ldrb	r3, [r3, #9]
    2be4:	461a      	mov	r2, r3
    2be6:	9b03      	ldr	r3, [sp, #12]
    2be8:	4293      	cmp	r3, r2
    2bea:	d3ce      	bcc.n	2b8a <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2bec:	2300      	movs	r3, #0
    2bee:	9303      	str	r3, [sp, #12]
    2bf0:	e029      	b.n	2c46 <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    2bf2:	9901      	ldr	r1, [sp, #4]
    2bf4:	9a03      	ldr	r2, [sp, #12]
    2bf6:	4613      	mov	r3, r2
    2bf8:	009b      	lsls	r3, r3, #2
    2bfa:	4413      	add	r3, r2
    2bfc:	00db      	lsls	r3, r3, #3
    2bfe:	440b      	add	r3, r1
    2c00:	3340      	adds	r3, #64	; 0x40
    2c02:	681a      	ldr	r2, [r3, #0]
    2c04:	4947      	ldr	r1, [pc, #284]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2c06:	4613      	mov	r3, r2
    2c08:	00db      	lsls	r3, r3, #3
    2c0a:	4413      	add	r3, r2
    2c0c:	440b      	add	r3, r1
    2c0e:	3301      	adds	r3, #1
    2c10:	781b      	ldrb	r3, [r3, #0]
    2c12:	461a      	mov	r2, r3
    2c14:	4b46      	ldr	r3, [pc, #280]	; (2d30 <Clock_Ip_InitClock+0x590>)
    2c16:	5c9b      	ldrb	r3, [r3, r2]
    2c18:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    2c1a:	4946      	ldr	r1, [pc, #280]	; (2d34 <Clock_Ip_InitClock+0x594>)
    2c1c:	9a02      	ldr	r2, [sp, #8]
    2c1e:	4613      	mov	r3, r2
    2c20:	009b      	lsls	r3, r3, #2
    2c22:	4413      	add	r3, r2
    2c24:	009b      	lsls	r3, r3, #2
    2c26:	440b      	add	r3, r1
    2c28:	330c      	adds	r3, #12
    2c2a:	6819      	ldr	r1, [r3, #0]
    2c2c:	9a03      	ldr	r2, [sp, #12]
    2c2e:	4613      	mov	r3, r2
    2c30:	009b      	lsls	r3, r3, #2
    2c32:	4413      	add	r3, r2
    2c34:	00db      	lsls	r3, r3, #3
    2c36:	3340      	adds	r3, #64	; 0x40
    2c38:	9a01      	ldr	r2, [sp, #4]
    2c3a:	4413      	add	r3, r2
    2c3c:	4618      	mov	r0, r3
    2c3e:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2c40:	9b03      	ldr	r3, [sp, #12]
    2c42:	3301      	adds	r3, #1
    2c44:	9303      	str	r3, [sp, #12]
    2c46:	9b01      	ldr	r3, [sp, #4]
    2c48:	7a9b      	ldrb	r3, [r3, #10]
    2c4a:	461a      	mov	r2, r3
    2c4c:	9b03      	ldr	r3, [sp, #12]
    2c4e:	4293      	cmp	r3, r2
    2c50:	d3cf      	bcc.n	2bf2 <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    2c52:	2300      	movs	r3, #0
    2c54:	9303      	str	r3, [sp, #12]
    2c56:	e025      	b.n	2ca4 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    2c58:	9a01      	ldr	r2, [sp, #4]
    2c5a:	9b03      	ldr	r3, [sp, #12]
    2c5c:	3324      	adds	r3, #36	; 0x24
    2c5e:	011b      	lsls	r3, r3, #4
    2c60:	4413      	add	r3, r2
    2c62:	3304      	adds	r3, #4
    2c64:	681a      	ldr	r2, [r3, #0]
    2c66:	492f      	ldr	r1, [pc, #188]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2c68:	4613      	mov	r3, r2
    2c6a:	00db      	lsls	r3, r3, #3
    2c6c:	4413      	add	r3, r2
    2c6e:	440b      	add	r3, r1
    2c70:	3301      	adds	r3, #1
    2c72:	781b      	ldrb	r3, [r3, #0]
    2c74:	461a      	mov	r2, r3
    2c76:	4b34      	ldr	r3, [pc, #208]	; (2d48 <Clock_Ip_InitClock+0x5a8>)
    2c78:	5c9b      	ldrb	r3, [r3, r2]
    2c7a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    2c7c:	4933      	ldr	r1, [pc, #204]	; (2d4c <Clock_Ip_InitClock+0x5ac>)
    2c7e:	9a02      	ldr	r2, [sp, #8]
    2c80:	4613      	mov	r3, r2
    2c82:	005b      	lsls	r3, r3, #1
    2c84:	4413      	add	r3, r2
    2c86:	009b      	lsls	r3, r3, #2
    2c88:	440b      	add	r3, r1
    2c8a:	3304      	adds	r3, #4
    2c8c:	681b      	ldr	r3, [r3, #0]
    2c8e:	9a03      	ldr	r2, [sp, #12]
    2c90:	3224      	adds	r2, #36	; 0x24
    2c92:	0112      	lsls	r2, r2, #4
    2c94:	9901      	ldr	r1, [sp, #4]
    2c96:	440a      	add	r2, r1
    2c98:	3204      	adds	r2, #4
    2c9a:	4610      	mov	r0, r2
    2c9c:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    2c9e:	9b03      	ldr	r3, [sp, #12]
    2ca0:	3301      	adds	r3, #1
    2ca2:	9303      	str	r3, [sp, #12]
    2ca4:	9b01      	ldr	r3, [sp, #4]
    2ca6:	7b9b      	ldrb	r3, [r3, #14]
    2ca8:	461a      	mov	r2, r3
    2caa:	9b03      	ldr	r3, [sp, #12]
    2cac:	4293      	cmp	r3, r2
    2cae:	d3d3      	bcc.n	2c58 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    2cb0:	4b27      	ldr	r3, [pc, #156]	; (2d50 <Clock_Ip_InitClock+0x5b0>)
    2cb2:	2200      	movs	r2, #0
    2cb4:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    2cb6:	4b26      	ldr	r3, [pc, #152]	; (2d50 <Clock_Ip_InitClock+0x5b0>)
    2cb8:	2200      	movs	r2, #0
    2cba:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    2cbc:	4b24      	ldr	r3, [pc, #144]	; (2d50 <Clock_Ip_InitClock+0x5b0>)
    2cbe:	2201      	movs	r2, #1
    2cc0:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    2cc2:	4b23      	ldr	r3, [pc, #140]	; (2d50 <Clock_Ip_InitClock+0x5b0>)
    2cc4:	2200      	movs	r2, #0
    2cc6:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    2cc8:	f000 fa9c 	bl	3204 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2ccc:	2300      	movs	r3, #0
    2cce:	9303      	str	r3, [sp, #12]
    2cd0:	e04c      	b.n	2d6c <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    2cd2:	9a01      	ldr	r2, [sp, #4]
    2cd4:	9b03      	ldr	r3, [sp, #12]
    2cd6:	330d      	adds	r3, #13
    2cd8:	00db      	lsls	r3, r3, #3
    2cda:	4413      	add	r3, r2
    2cdc:	685b      	ldr	r3, [r3, #4]
    2cde:	4a1d      	ldr	r2, [pc, #116]	; (2d54 <Clock_Ip_InitClock+0x5b4>)
    2ce0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2ce4:	2b03      	cmp	r3, #3
    2ce6:	d03b      	beq.n	2d60 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2ce8:	9b01      	ldr	r3, [sp, #4]
    2cea:	9a03      	ldr	r2, [sp, #12]
    2cec:	320d      	adds	r2, #13
    2cee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2cf2:	490c      	ldr	r1, [pc, #48]	; (2d24 <Clock_Ip_InitClock+0x584>)
    2cf4:	4613      	mov	r3, r2
    2cf6:	00db      	lsls	r3, r3, #3
    2cf8:	4413      	add	r3, r2
    2cfa:	440b      	add	r3, r1
    2cfc:	3301      	adds	r3, #1
    2cfe:	781b      	ldrb	r3, [r3, #0]
    2d00:	461a      	mov	r2, r3
    2d02:	4b15      	ldr	r3, [pc, #84]	; (2d58 <Clock_Ip_InitClock+0x5b8>)
    2d04:	5c9b      	ldrb	r3, [r3, r2]
    2d06:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    2d08:	4a14      	ldr	r2, [pc, #80]	; (2d5c <Clock_Ip_InitClock+0x5bc>)
    2d0a:	9b02      	ldr	r3, [sp, #8]
    2d0c:	00db      	lsls	r3, r3, #3
    2d0e:	4413      	add	r3, r2
    2d10:	685b      	ldr	r3, [r3, #4]
    2d12:	9a03      	ldr	r2, [sp, #12]
    2d14:	320d      	adds	r2, #13
    2d16:	00d2      	lsls	r2, r2, #3
    2d18:	9901      	ldr	r1, [sp, #4]
    2d1a:	440a      	add	r2, r1
    2d1c:	4610      	mov	r0, r2
    2d1e:	4798      	blx	r3
    2d20:	e021      	b.n	2d66 <Clock_Ip_InitClock+0x5c6>
    2d22:	bf00      	nop
    2d24:	0000fe24 	.word	0x0000fe24
    2d28:	0000fd94 	.word	0x0000fd94
    2d2c:	00010370 	.word	0x00010370
    2d30:	0000fde4 	.word	0x0000fde4
    2d34:	00010430 	.word	0x00010430
    2d38:	0000fe14 	.word	0x0000fe14
    2d3c:	00010420 	.word	0x00010420
    2d40:	0000fda4 	.word	0x0000fda4
    2d44:	00010378 	.word	0x00010378
    2d48:	0000fdd4 	.word	0x0000fdd4
    2d4c:	000103a0 	.word	0x000103a0
    2d50:	1fff8b58 	.word	0x1fff8b58
    2d54:	00010270 	.word	0x00010270
    2d58:	0000fdf4 	.word	0x0000fdf4
    2d5c:	0001045c 	.word	0x0001045c
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    2d60:	4b3a      	ldr	r3, [pc, #232]	; (2e4c <Clock_Ip_InitClock+0x6ac>)
    2d62:	2201      	movs	r2, #1
    2d64:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2d66:	9b03      	ldr	r3, [sp, #12]
    2d68:	3301      	adds	r3, #1
    2d6a:	9303      	str	r3, [sp, #12]
    2d6c:	9b01      	ldr	r3, [sp, #4]
    2d6e:	7adb      	ldrb	r3, [r3, #11]
    2d70:	461a      	mov	r2, r3
    2d72:	9b03      	ldr	r3, [sp, #12]
    2d74:	4293      	cmp	r3, r2
    2d76:	d3ac      	bcc.n	2cd2 <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    2d78:	4b34      	ldr	r3, [pc, #208]	; (2e4c <Clock_Ip_InitClock+0x6ac>)
    2d7a:	781b      	ldrb	r3, [r3, #0]
    2d7c:	f083 0301 	eor.w	r3, r3, #1
    2d80:	b2db      	uxtb	r3, r3
    2d82:	2b00      	cmp	r3, #0
    2d84:	d05e      	beq.n	2e44 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2d86:	2300      	movs	r3, #0
    2d88:	9303      	str	r3, [sp, #12]
    2d8a:	e01f      	b.n	2dcc <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2d8c:	9a01      	ldr	r2, [sp, #4]
    2d8e:	9b03      	ldr	r3, [sp, #12]
    2d90:	334e      	adds	r3, #78	; 0x4e
    2d92:	00db      	lsls	r3, r3, #3
    2d94:	4413      	add	r3, r2
    2d96:	685a      	ldr	r2, [r3, #4]
    2d98:	492d      	ldr	r1, [pc, #180]	; (2e50 <Clock_Ip_InitClock+0x6b0>)
    2d9a:	4613      	mov	r3, r2
    2d9c:	00db      	lsls	r3, r3, #3
    2d9e:	4413      	add	r3, r2
    2da0:	440b      	add	r3, r1
    2da2:	3301      	adds	r3, #1
    2da4:	781b      	ldrb	r3, [r3, #0]
    2da6:	461a      	mov	r2, r3
    2da8:	4b2a      	ldr	r3, [pc, #168]	; (2e54 <Clock_Ip_InitClock+0x6b4>)
    2daa:	5c9b      	ldrb	r3, [r3, r2]
    2dac:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    2dae:	4a2a      	ldr	r2, [pc, #168]	; (2e58 <Clock_Ip_InitClock+0x6b8>)
    2db0:	9b02      	ldr	r3, [sp, #8]
    2db2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2db6:	9a03      	ldr	r2, [sp, #12]
    2db8:	324e      	adds	r2, #78	; 0x4e
    2dba:	00d2      	lsls	r2, r2, #3
    2dbc:	9901      	ldr	r1, [sp, #4]
    2dbe:	440a      	add	r2, r1
    2dc0:	3204      	adds	r2, #4
    2dc2:	4610      	mov	r0, r2
    2dc4:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2dc6:	9b03      	ldr	r3, [sp, #12]
    2dc8:	3301      	adds	r3, #1
    2dca:	9303      	str	r3, [sp, #12]
    2dcc:	9b01      	ldr	r3, [sp, #4]
    2dce:	7c1b      	ldrb	r3, [r3, #16]
    2dd0:	461a      	mov	r2, r3
    2dd2:	9b03      	ldr	r3, [sp, #12]
    2dd4:	4293      	cmp	r3, r2
    2dd6:	d3d9      	bcc.n	2d8c <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    2dd8:	2300      	movs	r3, #0
    2dda:	9303      	str	r3, [sp, #12]
    2ddc:	e028      	b.n	2e30 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2dde:	9901      	ldr	r1, [sp, #4]
    2de0:	9a03      	ldr	r2, [sp, #12]
    2de2:	4613      	mov	r3, r2
    2de4:	009b      	lsls	r3, r3, #2
    2de6:	4413      	add	r3, r2
    2de8:	009b      	lsls	r3, r3, #2
    2dea:	440b      	add	r3, r1
    2dec:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2df0:	681a      	ldr	r2, [r3, #0]
    2df2:	4917      	ldr	r1, [pc, #92]	; (2e50 <Clock_Ip_InitClock+0x6b0>)
    2df4:	4613      	mov	r3, r2
    2df6:	00db      	lsls	r3, r3, #3
    2df8:	4413      	add	r3, r2
    2dfa:	440b      	add	r3, r1
    2dfc:	3301      	adds	r3, #1
    2dfe:	781b      	ldrb	r3, [r3, #0]
    2e00:	461a      	mov	r2, r3
    2e02:	4b16      	ldr	r3, [pc, #88]	; (2e5c <Clock_Ip_InitClock+0x6bc>)
    2e04:	5c9b      	ldrb	r3, [r3, r2]
    2e06:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    2e08:	4a15      	ldr	r2, [pc, #84]	; (2e60 <Clock_Ip_InitClock+0x6c0>)
    2e0a:	9b02      	ldr	r3, [sp, #8]
    2e0c:	011b      	lsls	r3, r3, #4
    2e0e:	4413      	add	r3, r2
    2e10:	330c      	adds	r3, #12
    2e12:	6819      	ldr	r1, [r3, #0]
    2e14:	9a03      	ldr	r2, [sp, #12]
    2e16:	4613      	mov	r3, r2
    2e18:	009b      	lsls	r3, r3, #2
    2e1a:	4413      	add	r3, r2
    2e1c:	009b      	lsls	r3, r3, #2
    2e1e:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2e22:	9a01      	ldr	r2, [sp, #4]
    2e24:	4413      	add	r3, r2
    2e26:	4618      	mov	r0, r3
    2e28:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    2e2a:	9b03      	ldr	r3, [sp, #12]
    2e2c:	3301      	adds	r3, #1
    2e2e:	9303      	str	r3, [sp, #12]
    2e30:	9b01      	ldr	r3, [sp, #4]
    2e32:	7c9b      	ldrb	r3, [r3, #18]
    2e34:	461a      	mov	r2, r3
    2e36:	9b03      	ldr	r3, [sp, #12]
    2e38:	4293      	cmp	r3, r2
    2e3a:	d3d0      	bcc.n	2dde <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2e3c:	2104      	movs	r1, #4
    2e3e:	9801      	ldr	r0, [sp, #4]
    2e40:	f002 ff48 	bl	5cd4 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    2e44:	bf00      	nop
    2e46:	b004      	add	sp, #16
    2e48:	bd10      	pop	{r4, pc}
    2e4a:	bf00      	nop
    2e4c:	1fff8b58 	.word	0x1fff8b58
    2e50:	0000fe24 	.word	0x0000fe24
    2e54:	0000fdc4 	.word	0x0000fdc4
    2e58:	000103ac 	.word	0x000103ac
    2e5c:	0000fe14 	.word	0x0000fe14
    2e60:	00010420 	.word	0x00010420

00002e64 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    2e64:	b500      	push	{lr}
    2e66:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    2e68:	2302      	movs	r3, #2
    2e6a:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2e6c:	2300      	movs	r3, #0
    2e6e:	9304      	str	r3, [sp, #16]
    2e70:	e02c      	b.n	2ecc <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    2e72:	4a36      	ldr	r2, [pc, #216]	; (2f4c <Clock_Ip_GetPllStatus+0xe8>)
    2e74:	9b04      	ldr	r3, [sp, #16]
    2e76:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2e7a:	4935      	ldr	r1, [pc, #212]	; (2f50 <Clock_Ip_GetPllStatus+0xec>)
    2e7c:	4613      	mov	r3, r2
    2e7e:	00db      	lsls	r3, r3, #3
    2e80:	4413      	add	r3, r2
    2e82:	440b      	add	r3, r1
    2e84:	3301      	adds	r3, #1
    2e86:	781b      	ldrb	r3, [r3, #0]
    2e88:	461a      	mov	r2, r3
    2e8a:	4b32      	ldr	r3, [pc, #200]	; (2f54 <Clock_Ip_GetPllStatus+0xf0>)
    2e8c:	5c9b      	ldrb	r3, [r3, r2]
    2e8e:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    2e90:	4931      	ldr	r1, [pc, #196]	; (2f58 <Clock_Ip_GetPllStatus+0xf4>)
    2e92:	9a03      	ldr	r2, [sp, #12]
    2e94:	4613      	mov	r3, r2
    2e96:	009b      	lsls	r3, r3, #2
    2e98:	4413      	add	r3, r2
    2e9a:	009b      	lsls	r3, r3, #2
    2e9c:	440b      	add	r3, r1
    2e9e:	3308      	adds	r3, #8
    2ea0:	681b      	ldr	r3, [r3, #0]
    2ea2:	492a      	ldr	r1, [pc, #168]	; (2f4c <Clock_Ip_GetPllStatus+0xe8>)
    2ea4:	9a04      	ldr	r2, [sp, #16]
    2ea6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2eaa:	4610      	mov	r0, r2
    2eac:	4798      	blx	r3
    2eae:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    2eb0:	9b02      	ldr	r3, [sp, #8]
    2eb2:	2b01      	cmp	r3, #1
    2eb4:	d102      	bne.n	2ebc <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    2eb6:	2301      	movs	r3, #1
    2eb8:	9305      	str	r3, [sp, #20]
            break;
    2eba:	e00d      	b.n	2ed8 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    2ebc:	9b02      	ldr	r3, [sp, #8]
    2ebe:	2b02      	cmp	r3, #2
    2ec0:	d101      	bne.n	2ec6 <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    2ec2:	2300      	movs	r3, #0
    2ec4:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2ec6:	9b04      	ldr	r3, [sp, #16]
    2ec8:	3301      	adds	r3, #1
    2eca:	9304      	str	r3, [sp, #16]
    2ecc:	4b23      	ldr	r3, [pc, #140]	; (2f5c <Clock_Ip_GetPllStatus+0xf8>)
    2ece:	789b      	ldrb	r3, [r3, #2]
    2ed0:	461a      	mov	r2, r3
    2ed2:	9b04      	ldr	r3, [sp, #16]
    2ed4:	4293      	cmp	r3, r2
    2ed6:	d3cc      	bcc.n	2e72 <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    2ed8:	9b05      	ldr	r3, [sp, #20]
    2eda:	2b00      	cmp	r3, #0
    2edc:	d130      	bne.n	2f40 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2ede:	2300      	movs	r3, #0
    2ee0:	9304      	str	r3, [sp, #16]
    2ee2:	e027      	b.n	2f34 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    2ee4:	4a1e      	ldr	r2, [pc, #120]	; (2f60 <Clock_Ip_GetPllStatus+0xfc>)
    2ee6:	9b04      	ldr	r3, [sp, #16]
    2ee8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2eec:	4918      	ldr	r1, [pc, #96]	; (2f50 <Clock_Ip_GetPllStatus+0xec>)
    2eee:	4613      	mov	r3, r2
    2ef0:	00db      	lsls	r3, r3, #3
    2ef2:	4413      	add	r3, r2
    2ef4:	440b      	add	r3, r1
    2ef6:	3301      	adds	r3, #1
    2ef8:	781b      	ldrb	r3, [r3, #0]
    2efa:	461a      	mov	r2, r3
    2efc:	4b19      	ldr	r3, [pc, #100]	; (2f64 <Clock_Ip_GetPllStatus+0x100>)
    2efe:	5c9b      	ldrb	r3, [r3, r2]
    2f00:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    2f02:	4919      	ldr	r1, [pc, #100]	; (2f68 <Clock_Ip_GetPllStatus+0x104>)
    2f04:	9a03      	ldr	r2, [sp, #12]
    2f06:	4613      	mov	r3, r2
    2f08:	005b      	lsls	r3, r3, #1
    2f0a:	4413      	add	r3, r2
    2f0c:	009b      	lsls	r3, r3, #2
    2f0e:	440b      	add	r3, r1
    2f10:	3308      	adds	r3, #8
    2f12:	681b      	ldr	r3, [r3, #0]
    2f14:	4912      	ldr	r1, [pc, #72]	; (2f60 <Clock_Ip_GetPllStatus+0xfc>)
    2f16:	9a04      	ldr	r2, [sp, #16]
    2f18:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2f1c:	4610      	mov	r0, r2
    2f1e:	4798      	blx	r3
    2f20:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    2f22:	9b01      	ldr	r3, [sp, #4]
    2f24:	2b01      	cmp	r3, #1
    2f26:	d102      	bne.n	2f2e <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    2f28:	2301      	movs	r3, #1
    2f2a:	9305      	str	r3, [sp, #20]
                break;
    2f2c:	e008      	b.n	2f40 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2f2e:	9b04      	ldr	r3, [sp, #16]
    2f30:	3301      	adds	r3, #1
    2f32:	9304      	str	r3, [sp, #16]
    2f34:	4b09      	ldr	r3, [pc, #36]	; (2f5c <Clock_Ip_GetPllStatus+0xf8>)
    2f36:	78db      	ldrb	r3, [r3, #3]
    2f38:	461a      	mov	r2, r3
    2f3a:	9b04      	ldr	r3, [sp, #16]
    2f3c:	4293      	cmp	r3, r2
    2f3e:	d3d1      	bcc.n	2ee4 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    2f40:	9b05      	ldr	r3, [sp, #20]
}
    2f42:	4618      	mov	r0, r3
    2f44:	b007      	add	sp, #28
    2f46:	f85d fb04 	ldr.w	pc, [sp], #4
    2f4a:	bf00      	nop
    2f4c:	0001032c 	.word	0x0001032c
    2f50:	0000fe24 	.word	0x0000fe24
    2f54:	0000fde4 	.word	0x0000fde4
    2f58:	00010430 	.word	0x00010430
    2f5c:	1fff8b58 	.word	0x1fff8b58
    2f60:	00010330 	.word	0x00010330
    2f64:	0000fdd4 	.word	0x0000fdd4
    2f68:	000103a0 	.word	0x000103a0

00002f6c <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    2f6c:	b500      	push	{lr}
    2f6e:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2f70:	4b55      	ldr	r3, [pc, #340]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2f72:	681b      	ldr	r3, [r3, #0]
    2f74:	2b00      	cmp	r3, #0
    2f76:	f000 80a2 	beq.w	30be <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2f7a:	2300      	movs	r3, #0
    2f7c:	9301      	str	r3, [sp, #4]
    2f7e:	e02c      	b.n	2fda <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    2f80:	4b51      	ldr	r3, [pc, #324]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2f82:	681a      	ldr	r2, [r3, #0]
    2f84:	9b01      	ldr	r3, [sp, #4]
    2f86:	330d      	adds	r3, #13
    2f88:	00db      	lsls	r3, r3, #3
    2f8a:	4413      	add	r3, r2
    2f8c:	685b      	ldr	r3, [r3, #4]
    2f8e:	4a4f      	ldr	r2, [pc, #316]	; (30cc <Clock_Ip_DistributePll+0x160>)
    2f90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2f94:	2b03      	cmp	r3, #3
    2f96:	d11d      	bne.n	2fd4 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2f98:	4b4b      	ldr	r3, [pc, #300]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2f9a:	681b      	ldr	r3, [r3, #0]
    2f9c:	9a01      	ldr	r2, [sp, #4]
    2f9e:	320d      	adds	r2, #13
    2fa0:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2fa4:	494a      	ldr	r1, [pc, #296]	; (30d0 <Clock_Ip_DistributePll+0x164>)
    2fa6:	4613      	mov	r3, r2
    2fa8:	00db      	lsls	r3, r3, #3
    2faa:	4413      	add	r3, r2
    2fac:	440b      	add	r3, r1
    2fae:	3301      	adds	r3, #1
    2fb0:	781b      	ldrb	r3, [r3, #0]
    2fb2:	461a      	mov	r2, r3
    2fb4:	4b47      	ldr	r3, [pc, #284]	; (30d4 <Clock_Ip_DistributePll+0x168>)
    2fb6:	5c9b      	ldrb	r3, [r3, r2]
    2fb8:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    2fba:	4a47      	ldr	r2, [pc, #284]	; (30d8 <Clock_Ip_DistributePll+0x16c>)
    2fbc:	9b00      	ldr	r3, [sp, #0]
    2fbe:	00db      	lsls	r3, r3, #3
    2fc0:	4413      	add	r3, r2
    2fc2:	685b      	ldr	r3, [r3, #4]
    2fc4:	4a40      	ldr	r2, [pc, #256]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2fc6:	6811      	ldr	r1, [r2, #0]
    2fc8:	9a01      	ldr	r2, [sp, #4]
    2fca:	320d      	adds	r2, #13
    2fcc:	00d2      	lsls	r2, r2, #3
    2fce:	440a      	add	r2, r1
    2fd0:	4610      	mov	r0, r2
    2fd2:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2fd4:	9b01      	ldr	r3, [sp, #4]
    2fd6:	3301      	adds	r3, #1
    2fd8:	9301      	str	r3, [sp, #4]
    2fda:	4b3b      	ldr	r3, [pc, #236]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2fdc:	681b      	ldr	r3, [r3, #0]
    2fde:	7adb      	ldrb	r3, [r3, #11]
    2fe0:	461a      	mov	r2, r3
    2fe2:	9b01      	ldr	r3, [sp, #4]
    2fe4:	4293      	cmp	r3, r2
    2fe6:	d3cb      	bcc.n	2f80 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    2fe8:	4b3c      	ldr	r3, [pc, #240]	; (30dc <Clock_Ip_DistributePll+0x170>)
    2fea:	781b      	ldrb	r3, [r3, #0]
    2fec:	2b00      	cmp	r3, #0
    2fee:	d066      	beq.n	30be <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2ff0:	2300      	movs	r3, #0
    2ff2:	9301      	str	r3, [sp, #4]
    2ff4:	e021      	b.n	303a <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2ff6:	4b34      	ldr	r3, [pc, #208]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    2ff8:	681a      	ldr	r2, [r3, #0]
    2ffa:	9b01      	ldr	r3, [sp, #4]
    2ffc:	334e      	adds	r3, #78	; 0x4e
    2ffe:	00db      	lsls	r3, r3, #3
    3000:	4413      	add	r3, r2
    3002:	685a      	ldr	r2, [r3, #4]
    3004:	4932      	ldr	r1, [pc, #200]	; (30d0 <Clock_Ip_DistributePll+0x164>)
    3006:	4613      	mov	r3, r2
    3008:	00db      	lsls	r3, r3, #3
    300a:	4413      	add	r3, r2
    300c:	440b      	add	r3, r1
    300e:	3301      	adds	r3, #1
    3010:	781b      	ldrb	r3, [r3, #0]
    3012:	461a      	mov	r2, r3
    3014:	4b32      	ldr	r3, [pc, #200]	; (30e0 <Clock_Ip_DistributePll+0x174>)
    3016:	5c9b      	ldrb	r3, [r3, r2]
    3018:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    301a:	4a32      	ldr	r2, [pc, #200]	; (30e4 <Clock_Ip_DistributePll+0x178>)
    301c:	9b00      	ldr	r3, [sp, #0]
    301e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    3022:	4a29      	ldr	r2, [pc, #164]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    3024:	6811      	ldr	r1, [r2, #0]
    3026:	9a01      	ldr	r2, [sp, #4]
    3028:	324e      	adds	r2, #78	; 0x4e
    302a:	00d2      	lsls	r2, r2, #3
    302c:	440a      	add	r2, r1
    302e:	3204      	adds	r2, #4
    3030:	4610      	mov	r0, r2
    3032:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3034:	9b01      	ldr	r3, [sp, #4]
    3036:	3301      	adds	r3, #1
    3038:	9301      	str	r3, [sp, #4]
    303a:	4b23      	ldr	r3, [pc, #140]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    303c:	681b      	ldr	r3, [r3, #0]
    303e:	7c1b      	ldrb	r3, [r3, #16]
    3040:	461a      	mov	r2, r3
    3042:	9b01      	ldr	r3, [sp, #4]
    3044:	4293      	cmp	r3, r2
    3046:	d3d6      	bcc.n	2ff6 <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    3048:	2300      	movs	r3, #0
    304a:	9301      	str	r3, [sp, #4]
    304c:	e02a      	b.n	30a4 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    304e:	4b1e      	ldr	r3, [pc, #120]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    3050:	6819      	ldr	r1, [r3, #0]
    3052:	9a01      	ldr	r2, [sp, #4]
    3054:	4613      	mov	r3, r2
    3056:	009b      	lsls	r3, r3, #2
    3058:	4413      	add	r3, r2
    305a:	009b      	lsls	r3, r3, #2
    305c:	440b      	add	r3, r1
    305e:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    3062:	681a      	ldr	r2, [r3, #0]
    3064:	491a      	ldr	r1, [pc, #104]	; (30d0 <Clock_Ip_DistributePll+0x164>)
    3066:	4613      	mov	r3, r2
    3068:	00db      	lsls	r3, r3, #3
    306a:	4413      	add	r3, r2
    306c:	440b      	add	r3, r1
    306e:	3301      	adds	r3, #1
    3070:	781b      	ldrb	r3, [r3, #0]
    3072:	461a      	mov	r2, r3
    3074:	4b1c      	ldr	r3, [pc, #112]	; (30e8 <Clock_Ip_DistributePll+0x17c>)
    3076:	5c9b      	ldrb	r3, [r3, r2]
    3078:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    307a:	4a1c      	ldr	r2, [pc, #112]	; (30ec <Clock_Ip_DistributePll+0x180>)
    307c:	9b00      	ldr	r3, [sp, #0]
    307e:	011b      	lsls	r3, r3, #4
    3080:	4413      	add	r3, r2
    3082:	330c      	adds	r3, #12
    3084:	6819      	ldr	r1, [r3, #0]
    3086:	4b10      	ldr	r3, [pc, #64]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    3088:	6818      	ldr	r0, [r3, #0]
    308a:	9a01      	ldr	r2, [sp, #4]
    308c:	4613      	mov	r3, r2
    308e:	009b      	lsls	r3, r3, #2
    3090:	4413      	add	r3, r2
    3092:	009b      	lsls	r3, r3, #2
    3094:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    3098:	4403      	add	r3, r0
    309a:	4618      	mov	r0, r3
    309c:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    309e:	9b01      	ldr	r3, [sp, #4]
    30a0:	3301      	adds	r3, #1
    30a2:	9301      	str	r3, [sp, #4]
    30a4:	4b08      	ldr	r3, [pc, #32]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    30a6:	681b      	ldr	r3, [r3, #0]
    30a8:	7c9b      	ldrb	r3, [r3, #18]
    30aa:	461a      	mov	r2, r3
    30ac:	9b01      	ldr	r3, [sp, #4]
    30ae:	4293      	cmp	r3, r2
    30b0:	d3cd      	bcc.n	304e <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    30b2:	4b05      	ldr	r3, [pc, #20]	; (30c8 <Clock_Ip_DistributePll+0x15c>)
    30b4:	681b      	ldr	r3, [r3, #0]
    30b6:	2104      	movs	r1, #4
    30b8:	4618      	mov	r0, r3
    30ba:	f002 fe0b 	bl	5cd4 <Clock_Ip_Command>
        }
    }
}
    30be:	bf00      	nop
    30c0:	b003      	add	sp, #12
    30c2:	f85d fb04 	ldr.w	pc, [sp], #4
    30c6:	bf00      	nop
    30c8:	1fff8b50 	.word	0x1fff8b50
    30cc:	00010270 	.word	0x00010270
    30d0:	0000fe24 	.word	0x0000fe24
    30d4:	0000fdf4 	.word	0x0000fdf4
    30d8:	0001045c 	.word	0x0001045c
    30dc:	1fff8b58 	.word	0x1fff8b58
    30e0:	0000fdc4 	.word	0x0000fdc4
    30e4:	000103ac 	.word	0x000103ac
    30e8:	0000fe14 	.word	0x0000fe14
    30ec:	00010420 	.word	0x00010420

000030f0 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    30f0:	b500      	push	{lr}
    30f2:	b085      	sub	sp, #20
    30f4:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    30f6:	490c      	ldr	r1, [pc, #48]	; (3128 <Clock_Ip_DisableClockMonitor+0x38>)
    30f8:	9a01      	ldr	r2, [sp, #4]
    30fa:	4613      	mov	r3, r2
    30fc:	00db      	lsls	r3, r3, #3
    30fe:	4413      	add	r3, r2
    3100:	440b      	add	r3, r1
    3102:	3301      	adds	r3, #1
    3104:	781b      	ldrb	r3, [r3, #0]
    3106:	461a      	mov	r2, r3
    3108:	4b08      	ldr	r3, [pc, #32]	; (312c <Clock_Ip_DisableClockMonitor+0x3c>)
    310a:	5c9b      	ldrb	r3, [r3, r2]
    310c:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    310e:	4a08      	ldr	r2, [pc, #32]	; (3130 <Clock_Ip_DisableClockMonitor+0x40>)
    3110:	9b03      	ldr	r3, [sp, #12]
    3112:	011b      	lsls	r3, r3, #4
    3114:	4413      	add	r3, r2
    3116:	3308      	adds	r3, #8
    3118:	681b      	ldr	r3, [r3, #0]
    311a:	9801      	ldr	r0, [sp, #4]
    311c:	4798      	blx	r3
}
    311e:	bf00      	nop
    3120:	b005      	add	sp, #20
    3122:	f85d fb04 	ldr.w	pc, [sp], #4
    3126:	bf00      	nop
    3128:	0000fe24 	.word	0x0000fe24
    312c:	0000fe14 	.word	0x0000fe14
    3130:	00010420 	.word	0x00010420

00003134 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    3134:	b082      	sub	sp, #8
    3136:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    3138:	4a02      	ldr	r2, [pc, #8]	; (3144 <Clock_Ip_InstallNotificationsCallback+0x10>)
    313a:	9b01      	ldr	r3, [sp, #4]
    313c:	6013      	str	r3, [r2, #0]
}
    313e:	bf00      	nop
    3140:	b002      	add	sp, #8
    3142:	4770      	bx	lr
    3144:	1fff8b14 	.word	0x1fff8b14

00003148 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    3148:	b500      	push	{lr}
    314a:	b085      	sub	sp, #20
    314c:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    314e:	490c      	ldr	r1, [pc, #48]	; (3180 <Clock_Ip_DisableModuleClock+0x38>)
    3150:	9a01      	ldr	r2, [sp, #4]
    3152:	4613      	mov	r3, r2
    3154:	00db      	lsls	r3, r3, #3
    3156:	4413      	add	r3, r2
    3158:	440b      	add	r3, r1
    315a:	3301      	adds	r3, #1
    315c:	781b      	ldrb	r3, [r3, #0]
    315e:	461a      	mov	r2, r3
    3160:	4b08      	ldr	r3, [pc, #32]	; (3184 <Clock_Ip_DisableModuleClock+0x3c>)
    3162:	5c9b      	ldrb	r3, [r3, r2]
    3164:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    3166:	4a08      	ldr	r2, [pc, #32]	; (3188 <Clock_Ip_DisableModuleClock+0x40>)
    3168:	9b03      	ldr	r3, [sp, #12]
    316a:	00db      	lsls	r3, r3, #3
    316c:	4413      	add	r3, r2
    316e:	685b      	ldr	r3, [r3, #4]
    3170:	2101      	movs	r1, #1
    3172:	9801      	ldr	r0, [sp, #4]
    3174:	4798      	blx	r3
}
    3176:	bf00      	nop
    3178:	b005      	add	sp, #20
    317a:	f85d fb04 	ldr.w	pc, [sp], #4
    317e:	bf00      	nop
    3180:	0000fe24 	.word	0x0000fe24
    3184:	0000fdc4 	.word	0x0000fdc4
    3188:	000103ac 	.word	0x000103ac

0000318c <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    318c:	b500      	push	{lr}
    318e:	b085      	sub	sp, #20
    3190:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    3192:	490c      	ldr	r1, [pc, #48]	; (31c4 <Clock_Ip_EnableModuleClock+0x38>)
    3194:	9a01      	ldr	r2, [sp, #4]
    3196:	4613      	mov	r3, r2
    3198:	00db      	lsls	r3, r3, #3
    319a:	4413      	add	r3, r2
    319c:	440b      	add	r3, r1
    319e:	3301      	adds	r3, #1
    31a0:	781b      	ldrb	r3, [r3, #0]
    31a2:	461a      	mov	r2, r3
    31a4:	4b08      	ldr	r3, [pc, #32]	; (31c8 <Clock_Ip_EnableModuleClock+0x3c>)
    31a6:	5c9b      	ldrb	r3, [r3, r2]
    31a8:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    31aa:	4a08      	ldr	r2, [pc, #32]	; (31cc <Clock_Ip_EnableModuleClock+0x40>)
    31ac:	9b03      	ldr	r3, [sp, #12]
    31ae:	00db      	lsls	r3, r3, #3
    31b0:	4413      	add	r3, r2
    31b2:	685b      	ldr	r3, [r3, #4]
    31b4:	2100      	movs	r1, #0
    31b6:	9801      	ldr	r0, [sp, #4]
    31b8:	4798      	blx	r3
}
    31ba:	bf00      	nop
    31bc:	b005      	add	sp, #20
    31be:	f85d fb04 	ldr.w	pc, [sp], #4
    31c2:	bf00      	nop
    31c4:	0000fe24 	.word	0x0000fe24
    31c8:	0000fdc4 	.word	0x0000fdc4
    31cc:	000103ac 	.word	0x000103ac

000031d0 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    31d0:	b500      	push	{lr}
    31d2:	b083      	sub	sp, #12
    31d4:	9001      	str	r0, [sp, #4]
    31d6:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    31d8:	4b08      	ldr	r3, [pc, #32]	; (31fc <Clock_Ip_PowerModeChangeNotification+0x2c>)
    31da:	2200      	movs	r2, #0
    31dc:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    31de:	4b08      	ldr	r3, [pc, #32]	; (3200 <Clock_Ip_PowerModeChangeNotification+0x30>)
    31e0:	681b      	ldr	r3, [r3, #0]
    31e2:	2102      	movs	r1, #2
    31e4:	4618      	mov	r0, r3
    31e6:	f002 fd75 	bl	5cd4 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    31ea:	9900      	ldr	r1, [sp, #0]
    31ec:	9801      	ldr	r0, [sp, #4]
    31ee:	f002 fc51 	bl	5a94 <Clock_Ip_ClockPowerModeChangeNotification>
}
    31f2:	bf00      	nop
    31f4:	b003      	add	sp, #12
    31f6:	f85d fb04 	ldr.w	pc, [sp], #4
    31fa:	bf00      	nop
    31fc:	1fff8b10 	.word	0x1fff8b10
    3200:	1fff8b50 	.word	0x1fff8b50

00003204 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    3204:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    3206:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    320a:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    320c:	4b06      	ldr	r3, [pc, #24]	; (3228 <Clock_Ip_SetWaitStates+0x24>)
    320e:	785b      	ldrb	r3, [r3, #1]
    3210:	2b00      	cmp	r3, #0
    3212:	d005      	beq.n	3220 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    3214:	9b01      	ldr	r3, [sp, #4]
    3216:	3b01      	subs	r3, #1
    3218:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    321a:	9b01      	ldr	r3, [sp, #4]
    321c:	2b00      	cmp	r3, #0
    321e:	d1f9      	bne.n	3214 <Clock_Ip_SetWaitStates+0x10>
    }
}
    3220:	bf00      	nop
    3222:	b002      	add	sp, #8
    3224:	4770      	bx	lr
    3226:	bf00      	nop
    3228:	1fff8b58 	.word	0x1fff8b58

0000322c <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    322c:	b500      	push	{lr}
    322e:	b083      	sub	sp, #12
    3230:	9001      	str	r0, [sp, #4]
    3232:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    3234:	4b04      	ldr	r3, [pc, #16]	; (3248 <Clock_Ip_ReportClockErrors+0x1c>)
    3236:	681b      	ldr	r3, [r3, #0]
    3238:	9900      	ldr	r1, [sp, #0]
    323a:	9801      	ldr	r0, [sp, #4]
    323c:	4798      	blx	r3
}
    323e:	bf00      	nop
    3240:	b003      	add	sp, #12
    3242:	f85d fb04 	ldr.w	pc, [sp], #4
    3246:	bf00      	nop
    3248:	1fff8b14 	.word	0x1fff8b14

0000324c <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    324c:	b500      	push	{lr}
    324e:	b085      	sub	sp, #20
    3250:	9003      	str	r0, [sp, #12]
    3252:	9102      	str	r1, [sp, #8]
    3254:	9201      	str	r2, [sp, #4]
    3256:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    3258:	2000      	movs	r0, #0
    325a:	f7fe ffd1 	bl	2200 <OsIf_GetCounter>
    325e:	4602      	mov	r2, r0
    3260:	9b03      	ldr	r3, [sp, #12]
    3262:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    3264:	9b02      	ldr	r3, [sp, #8]
    3266:	2200      	movs	r2, #0
    3268:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    326a:	2100      	movs	r1, #0
    326c:	9800      	ldr	r0, [sp, #0]
    326e:	f7ff f813 	bl	2298 <OsIf_MicrosToTicks>
    3272:	4602      	mov	r2, r0
    3274:	9b01      	ldr	r3, [sp, #4]
    3276:	601a      	str	r2, [r3, #0]
}
    3278:	bf00      	nop
    327a:	b005      	add	sp, #20
    327c:	f85d fb04 	ldr.w	pc, [sp], #4

00003280 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    3280:	b500      	push	{lr}
    3282:	b087      	sub	sp, #28
    3284:	9003      	str	r0, [sp, #12]
    3286:	9102      	str	r1, [sp, #8]
    3288:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    328a:	2300      	movs	r3, #0
    328c:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    3290:	2100      	movs	r1, #0
    3292:	9803      	ldr	r0, [sp, #12]
    3294:	f7fe ffcd 	bl	2232 <OsIf_GetElapsed>
    3298:	4602      	mov	r2, r0
    329a:	9b02      	ldr	r3, [sp, #8]
    329c:	681b      	ldr	r3, [r3, #0]
    329e:	441a      	add	r2, r3
    32a0:	9b02      	ldr	r3, [sp, #8]
    32a2:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    32a4:	9b02      	ldr	r3, [sp, #8]
    32a6:	681b      	ldr	r3, [r3, #0]
    32a8:	9a01      	ldr	r2, [sp, #4]
    32aa:	429a      	cmp	r2, r3
    32ac:	d802      	bhi.n	32b4 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    32ae:	2301      	movs	r3, #1
    32b0:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    32b4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    32b8:	4618      	mov	r0, r3
    32ba:	b007      	add	sp, #28
    32bc:	f85d fb04 	ldr.w	pc, [sp], #4

000032c0 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    32c0:	b082      	sub	sp, #8
    32c2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    32c4:	bf00      	nop
    32c6:	b002      	add	sp, #8
    32c8:	4770      	bx	lr

000032ca <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    32ca:	b500      	push	{lr}
    32cc:	b083      	sub	sp, #12
    32ce:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    32d0:	9b01      	ldr	r3, [sp, #4]
    32d2:	2b00      	cmp	r3, #0
    32d4:	d002      	beq.n	32dc <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    32d6:	9801      	ldr	r0, [sp, #4]
    32d8:	f000 f8ad 	bl	3436 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32dc:	bf00      	nop
    32de:	b003      	add	sp, #12
    32e0:	f85d fb04 	ldr.w	pc, [sp], #4

000032e4 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    32e4:	b500      	push	{lr}
    32e6:	b083      	sub	sp, #12
    32e8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    32ea:	9b01      	ldr	r3, [sp, #4]
    32ec:	2b00      	cmp	r3, #0
    32ee:	d002      	beq.n	32f6 <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    32f0:	9801      	ldr	r0, [sp, #4]
    32f2:	f000 f8cd 	bl	3490 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32f6:	bf00      	nop
    32f8:	b003      	add	sp, #12
    32fa:	f85d fb04 	ldr.w	pc, [sp], #4

000032fe <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    32fe:	b500      	push	{lr}
    3300:	b083      	sub	sp, #12
    3302:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3304:	9b01      	ldr	r3, [sp, #4]
    3306:	2b00      	cmp	r3, #0
    3308:	d002      	beq.n	3310 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    330a:	9801      	ldr	r0, [sp, #4]
    330c:	f000 f8ee 	bl	34ec <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3310:	bf00      	nop
    3312:	b003      	add	sp, #12
    3314:	f85d fb04 	ldr.w	pc, [sp], #4

00003318 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    3318:	b500      	push	{lr}
    331a:	b083      	sub	sp, #12
    331c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    331e:	9b01      	ldr	r3, [sp, #4]
    3320:	2b00      	cmp	r3, #0
    3322:	d002      	beq.n	332a <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    3324:	9801      	ldr	r0, [sp, #4]
    3326:	f000 f8f9 	bl	351c <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    332a:	bf00      	nop
    332c:	b003      	add	sp, #12
    332e:	f85d fb04 	ldr.w	pc, [sp], #4

00003332 <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    3332:	b500      	push	{lr}
    3334:	b083      	sub	sp, #12
    3336:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3338:	9b01      	ldr	r3, [sp, #4]
    333a:	2b00      	cmp	r3, #0
    333c:	d002      	beq.n	3344 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    333e:	9801      	ldr	r0, [sp, #4]
    3340:	f000 f904 	bl	354c <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3344:	bf00      	nop
    3346:	b003      	add	sp, #12
    3348:	f85d fb04 	ldr.w	pc, [sp], #4

0000334c <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    334c:	b500      	push	{lr}
    334e:	b083      	sub	sp, #12
    3350:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3352:	9b01      	ldr	r3, [sp, #4]
    3354:	2b00      	cmp	r3, #0
    3356:	d002      	beq.n	335e <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    3358:	9801      	ldr	r0, [sp, #4]
    335a:	f000 f90f 	bl	357c <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    335e:	bf00      	nop
    3360:	b003      	add	sp, #12
    3362:	f85d fb04 	ldr.w	pc, [sp], #4

00003366 <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    3366:	b500      	push	{lr}
    3368:	b083      	sub	sp, #12
    336a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    336c:	9b01      	ldr	r3, [sp, #4]
    336e:	2b00      	cmp	r3, #0
    3370:	d002      	beq.n	3378 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    3372:	9801      	ldr	r0, [sp, #4]
    3374:	f000 f91a 	bl	35ac <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3378:	bf00      	nop
    337a:	b003      	add	sp, #12
    337c:	f85d fb04 	ldr.w	pc, [sp], #4

00003380 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    3380:	b500      	push	{lr}
    3382:	b083      	sub	sp, #12
    3384:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3386:	9b01      	ldr	r3, [sp, #4]
    3388:	2b00      	cmp	r3, #0
    338a:	d002      	beq.n	3392 <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    338c:	9801      	ldr	r0, [sp, #4]
    338e:	f000 f925 	bl	35dc <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3392:	bf00      	nop
    3394:	b003      	add	sp, #12
    3396:	f85d fb04 	ldr.w	pc, [sp], #4

0000339a <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    339a:	b500      	push	{lr}
    339c:	b083      	sub	sp, #12
    339e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33a0:	9b01      	ldr	r3, [sp, #4]
    33a2:	2b00      	cmp	r3, #0
    33a4:	d002      	beq.n	33ac <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    33a6:	9801      	ldr	r0, [sp, #4]
    33a8:	f000 f930 	bl	360c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33ac:	bf00      	nop
    33ae:	b003      	add	sp, #12
    33b0:	f85d fb04 	ldr.w	pc, [sp], #4

000033b4 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    33b4:	b500      	push	{lr}
    33b6:	b083      	sub	sp, #12
    33b8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33ba:	9b01      	ldr	r3, [sp, #4]
    33bc:	2b00      	cmp	r3, #0
    33be:	d002      	beq.n	33c6 <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    33c0:	9801      	ldr	r0, [sp, #4]
    33c2:	f000 f93b 	bl	363c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33c6:	bf00      	nop
    33c8:	b003      	add	sp, #12
    33ca:	f85d fb04 	ldr.w	pc, [sp], #4

000033ce <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    33ce:	b500      	push	{lr}
    33d0:	b083      	sub	sp, #12
    33d2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33d4:	9b01      	ldr	r3, [sp, #4]
    33d6:	2b00      	cmp	r3, #0
    33d8:	d002      	beq.n	33e0 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    33da:	9801      	ldr	r0, [sp, #4]
    33dc:	f000 f946 	bl	366c <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33e0:	bf00      	nop
    33e2:	b003      	add	sp, #12
    33e4:	f85d fb04 	ldr.w	pc, [sp], #4

000033e8 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    33e8:	b500      	push	{lr}
    33ea:	b083      	sub	sp, #12
    33ec:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33ee:	9b01      	ldr	r3, [sp, #4]
    33f0:	2b00      	cmp	r3, #0
    33f2:	d002      	beq.n	33fa <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    33f4:	9801      	ldr	r0, [sp, #4]
    33f6:	f000 f951 	bl	369c <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33fa:	bf00      	nop
    33fc:	b003      	add	sp, #12
    33fe:	f85d fb04 	ldr.w	pc, [sp], #4

00003402 <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    3402:	b500      	push	{lr}
    3404:	b083      	sub	sp, #12
    3406:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3408:	9b01      	ldr	r3, [sp, #4]
    340a:	2b00      	cmp	r3, #0
    340c:	d002      	beq.n	3414 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    340e:	9801      	ldr	r0, [sp, #4]
    3410:	f000 f95e 	bl	36d0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3414:	bf00      	nop
    3416:	b003      	add	sp, #12
    3418:	f85d fb04 	ldr.w	pc, [sp], #4

0000341c <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    341c:	b500      	push	{lr}
    341e:	b083      	sub	sp, #12
    3420:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3422:	9b01      	ldr	r3, [sp, #4]
    3424:	2b00      	cmp	r3, #0
    3426:	d002      	beq.n	342e <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    3428:	9801      	ldr	r0, [sp, #4]
    342a:	f000 f98b 	bl	3744 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    342e:	bf00      	nop
    3430:	b003      	add	sp, #12
    3432:	f85d fb04 	ldr.w	pc, [sp], #4

00003436 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3436:	b086      	sub	sp, #24
    3438:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    343a:	9b01      	ldr	r3, [sp, #4]
    343c:	681a      	ldr	r2, [r3, #0]
    343e:	4911      	ldr	r1, [pc, #68]	; (3484 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    3440:	4613      	mov	r3, r2
    3442:	00db      	lsls	r3, r3, #3
    3444:	4413      	add	r3, r2
    3446:	440b      	add	r3, r1
    3448:	781b      	ldrb	r3, [r3, #0]
    344a:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    344c:	9b01      	ldr	r3, [sp, #4]
    344e:	685b      	ldr	r3, [r3, #4]
    3450:	4a0d      	ldr	r2, [pc, #52]	; (3488 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    3452:	5cd3      	ldrb	r3, [r2, r3]
    3454:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    3456:	4a0d      	ldr	r2, [pc, #52]	; (348c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    3458:	9b05      	ldr	r3, [sp, #20]
    345a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    345e:	681b      	ldr	r3, [r3, #0]
    3460:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    3462:	9b03      	ldr	r3, [sp, #12]
    3464:	f023 0307 	bic.w	r3, r3, #7
    3468:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    346a:	9a03      	ldr	r2, [sp, #12]
    346c:	9b04      	ldr	r3, [sp, #16]
    346e:	4313      	orrs	r3, r2
    3470:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    3472:	4a06      	ldr	r2, [pc, #24]	; (348c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    3474:	9b05      	ldr	r3, [sp, #20]
    3476:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    347a:	9a03      	ldr	r2, [sp, #12]
    347c:	601a      	str	r2, [r3, #0]
}
    347e:	bf00      	nop
    3480:	b006      	add	sp, #24
    3482:	4770      	bx	lr
    3484:	0000fe24 	.word	0x0000fe24
    3488:	0001021c 	.word	0x0001021c
    348c:	00010260 	.word	0x00010260

00003490 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3490:	b086      	sub	sp, #24
    3492:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3494:	9b01      	ldr	r3, [sp, #4]
    3496:	681a      	ldr	r2, [r3, #0]
    3498:	4911      	ldr	r1, [pc, #68]	; (34e0 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    349a:	4613      	mov	r3, r2
    349c:	00db      	lsls	r3, r3, #3
    349e:	4413      	add	r3, r2
    34a0:	440b      	add	r3, r1
    34a2:	781b      	ldrb	r3, [r3, #0]
    34a4:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    34a6:	9b01      	ldr	r3, [sp, #4]
    34a8:	685b      	ldr	r3, [r3, #4]
    34aa:	4a0e      	ldr	r2, [pc, #56]	; (34e4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    34ac:	5cd3      	ldrb	r3, [r2, r3]
    34ae:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    34b0:	4a0d      	ldr	r2, [pc, #52]	; (34e8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    34b2:	9b05      	ldr	r3, [sp, #20]
    34b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    34b8:	681b      	ldr	r3, [r3, #0]
    34ba:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    34bc:	9b03      	ldr	r3, [sp, #12]
    34be:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    34c2:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    34c4:	9b04      	ldr	r3, [sp, #16]
    34c6:	021b      	lsls	r3, r3, #8
    34c8:	9a03      	ldr	r2, [sp, #12]
    34ca:	4313      	orrs	r3, r2
    34cc:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    34ce:	4a06      	ldr	r2, [pc, #24]	; (34e8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    34d0:	9b05      	ldr	r3, [sp, #20]
    34d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    34d6:	9a03      	ldr	r2, [sp, #12]
    34d8:	601a      	str	r2, [r3, #0]
}
    34da:	bf00      	nop
    34dc:	b006      	add	sp, #24
    34de:	4770      	bx	lr
    34e0:	0000fe24 	.word	0x0000fe24
    34e4:	0001021c 	.word	0x0001021c
    34e8:	00010260 	.word	0x00010260

000034ec <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    34ec:	b084      	sub	sp, #16
    34ee:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    34f0:	4b09      	ldr	r3, [pc, #36]	; (3518 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    34f2:	695b      	ldr	r3, [r3, #20]
    34f4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    34f6:	9b03      	ldr	r3, [sp, #12]
    34f8:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    34fc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    34fe:	9b01      	ldr	r3, [sp, #4]
    3500:	685b      	ldr	r3, [r3, #4]
    3502:	3b01      	subs	r3, #1
    3504:	041b      	lsls	r3, r3, #16
    3506:	9a03      	ldr	r2, [sp, #12]
    3508:	4313      	orrs	r3, r2
    350a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    350c:	4a02      	ldr	r2, [pc, #8]	; (3518 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    350e:	9b03      	ldr	r3, [sp, #12]
    3510:	6153      	str	r3, [r2, #20]
}
    3512:	bf00      	nop
    3514:	b004      	add	sp, #16
    3516:	4770      	bx	lr
    3518:	40064000 	.word	0x40064000

0000351c <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    351c:	b084      	sub	sp, #16
    351e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    3520:	4b09      	ldr	r3, [pc, #36]	; (3548 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    3522:	695b      	ldr	r3, [r3, #20]
    3524:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    3526:	9b03      	ldr	r3, [sp, #12]
    3528:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    352c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    352e:	9b01      	ldr	r3, [sp, #4]
    3530:	685b      	ldr	r3, [r3, #4]
    3532:	3b01      	subs	r3, #1
    3534:	011b      	lsls	r3, r3, #4
    3536:	9a03      	ldr	r2, [sp, #12]
    3538:	4313      	orrs	r3, r2
    353a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    353c:	4a02      	ldr	r2, [pc, #8]	; (3548 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    353e:	9b03      	ldr	r3, [sp, #12]
    3540:	6153      	str	r3, [r2, #20]
}
    3542:	bf00      	nop
    3544:	b004      	add	sp, #16
    3546:	4770      	bx	lr
    3548:	40064000 	.word	0x40064000

0000354c <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    354c:	b084      	sub	sp, #16
    354e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    3550:	4b09      	ldr	r3, [pc, #36]	; (3578 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    3552:	695b      	ldr	r3, [r3, #20]
    3554:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    3556:	9b03      	ldr	r3, [sp, #12]
    3558:	f023 030f 	bic.w	r3, r3, #15
    355c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    355e:	9b01      	ldr	r3, [sp, #4]
    3560:	685b      	ldr	r3, [r3, #4]
    3562:	3b01      	subs	r3, #1
    3564:	9a03      	ldr	r2, [sp, #12]
    3566:	4313      	orrs	r3, r2
    3568:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    356a:	4a03      	ldr	r2, [pc, #12]	; (3578 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    356c:	9b03      	ldr	r3, [sp, #12]
    356e:	6153      	str	r3, [r2, #20]
}
    3570:	bf00      	nop
    3572:	b004      	add	sp, #16
    3574:	4770      	bx	lr
    3576:	bf00      	nop
    3578:	40064000 	.word	0x40064000

0000357c <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    357c:	b084      	sub	sp, #16
    357e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    3580:	4b09      	ldr	r3, [pc, #36]	; (35a8 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    3582:	699b      	ldr	r3, [r3, #24]
    3584:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    3586:	9b03      	ldr	r3, [sp, #12]
    3588:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    358c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    358e:	9b01      	ldr	r3, [sp, #4]
    3590:	685b      	ldr	r3, [r3, #4]
    3592:	3b01      	subs	r3, #1
    3594:	041b      	lsls	r3, r3, #16
    3596:	9a03      	ldr	r2, [sp, #12]
    3598:	4313      	orrs	r3, r2
    359a:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    359c:	4a02      	ldr	r2, [pc, #8]	; (35a8 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    359e:	9b03      	ldr	r3, [sp, #12]
    35a0:	6193      	str	r3, [r2, #24]
}
    35a2:	bf00      	nop
    35a4:	b004      	add	sp, #16
    35a6:	4770      	bx	lr
    35a8:	40064000 	.word	0x40064000

000035ac <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    35ac:	b084      	sub	sp, #16
    35ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    35b0:	4b09      	ldr	r3, [pc, #36]	; (35d8 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    35b2:	699b      	ldr	r3, [r3, #24]
    35b4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    35b6:	9b03      	ldr	r3, [sp, #12]
    35b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    35bc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    35be:	9b01      	ldr	r3, [sp, #4]
    35c0:	685b      	ldr	r3, [r3, #4]
    35c2:	3b01      	subs	r3, #1
    35c4:	011b      	lsls	r3, r3, #4
    35c6:	9a03      	ldr	r2, [sp, #12]
    35c8:	4313      	orrs	r3, r2
    35ca:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    35cc:	4a02      	ldr	r2, [pc, #8]	; (35d8 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    35ce:	9b03      	ldr	r3, [sp, #12]
    35d0:	6193      	str	r3, [r2, #24]
}
    35d2:	bf00      	nop
    35d4:	b004      	add	sp, #16
    35d6:	4770      	bx	lr
    35d8:	40064000 	.word	0x40064000

000035dc <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    35dc:	b084      	sub	sp, #16
    35de:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    35e0:	4b09      	ldr	r3, [pc, #36]	; (3608 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    35e2:	699b      	ldr	r3, [r3, #24]
    35e4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    35e6:	9b03      	ldr	r3, [sp, #12]
    35e8:	f023 030f 	bic.w	r3, r3, #15
    35ec:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    35ee:	9b01      	ldr	r3, [sp, #4]
    35f0:	685b      	ldr	r3, [r3, #4]
    35f2:	3b01      	subs	r3, #1
    35f4:	9a03      	ldr	r2, [sp, #12]
    35f6:	4313      	orrs	r3, r2
    35f8:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    35fa:	4a03      	ldr	r2, [pc, #12]	; (3608 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    35fc:	9b03      	ldr	r3, [sp, #12]
    35fe:	6193      	str	r3, [r2, #24]
}
    3600:	bf00      	nop
    3602:	b004      	add	sp, #16
    3604:	4770      	bx	lr
    3606:	bf00      	nop
    3608:	40064000 	.word	0x40064000

0000360c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    360c:	b084      	sub	sp, #16
    360e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3610:	4b09      	ldr	r3, [pc, #36]	; (3638 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    3612:	69db      	ldr	r3, [r3, #28]
    3614:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    3616:	9b03      	ldr	r3, [sp, #12]
    3618:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    361c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    361e:	9b01      	ldr	r3, [sp, #4]
    3620:	685b      	ldr	r3, [r3, #4]
    3622:	3b01      	subs	r3, #1
    3624:	041b      	lsls	r3, r3, #16
    3626:	9a03      	ldr	r2, [sp, #12]
    3628:	4313      	orrs	r3, r2
    362a:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    362c:	4a02      	ldr	r2, [pc, #8]	; (3638 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    362e:	9b03      	ldr	r3, [sp, #12]
    3630:	61d3      	str	r3, [r2, #28]
}
    3632:	bf00      	nop
    3634:	b004      	add	sp, #16
    3636:	4770      	bx	lr
    3638:	40064000 	.word	0x40064000

0000363c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    363c:	b084      	sub	sp, #16
    363e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3640:	4b09      	ldr	r3, [pc, #36]	; (3668 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    3642:	69db      	ldr	r3, [r3, #28]
    3644:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    3646:	9b03      	ldr	r3, [sp, #12]
    3648:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    364c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    364e:	9b01      	ldr	r3, [sp, #4]
    3650:	685b      	ldr	r3, [r3, #4]
    3652:	3b01      	subs	r3, #1
    3654:	011b      	lsls	r3, r3, #4
    3656:	9a03      	ldr	r2, [sp, #12]
    3658:	4313      	orrs	r3, r2
    365a:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    365c:	4a02      	ldr	r2, [pc, #8]	; (3668 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    365e:	9b03      	ldr	r3, [sp, #12]
    3660:	61d3      	str	r3, [r2, #28]
}
    3662:	bf00      	nop
    3664:	b004      	add	sp, #16
    3666:	4770      	bx	lr
    3668:	40064000 	.word	0x40064000

0000366c <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    366c:	b084      	sub	sp, #16
    366e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3670:	4b09      	ldr	r3, [pc, #36]	; (3698 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    3672:	69db      	ldr	r3, [r3, #28]
    3674:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    3676:	9b03      	ldr	r3, [sp, #12]
    3678:	f023 030f 	bic.w	r3, r3, #15
    367c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    367e:	9b01      	ldr	r3, [sp, #4]
    3680:	685b      	ldr	r3, [r3, #4]
    3682:	3b01      	subs	r3, #1
    3684:	9a03      	ldr	r2, [sp, #12]
    3686:	4313      	orrs	r3, r2
    3688:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    368a:	4a03      	ldr	r2, [pc, #12]	; (3698 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    368c:	9b03      	ldr	r3, [sp, #12]
    368e:	61d3      	str	r3, [r2, #28]
}
    3690:	bf00      	nop
    3692:	b004      	add	sp, #16
    3694:	4770      	bx	lr
    3696:	bf00      	nop
    3698:	40064000 	.word	0x40064000

0000369c <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    369c:	b084      	sub	sp, #16
    369e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    36a0:	4b0a      	ldr	r3, [pc, #40]	; (36cc <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    36a2:	685b      	ldr	r3, [r3, #4]
    36a4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    36a6:	9b03      	ldr	r3, [sp, #12]
    36a8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    36ac:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    36ae:	9b01      	ldr	r3, [sp, #4]
    36b0:	685b      	ldr	r3, [r3, #4]
    36b2:	3b01      	subs	r3, #1
    36b4:	021b      	lsls	r3, r3, #8
    36b6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    36ba:	9a03      	ldr	r2, [sp, #12]
    36bc:	4313      	orrs	r3, r2
    36be:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    36c0:	4a02      	ldr	r2, [pc, #8]	; (36cc <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    36c2:	9b03      	ldr	r3, [sp, #12]
    36c4:	6053      	str	r3, [r2, #4]
}
    36c6:	bf00      	nop
    36c8:	b004      	add	sp, #16
    36ca:	4770      	bx	lr
    36cc:	40048000 	.word	0x40048000

000036d0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    36d0:	b084      	sub	sp, #16
    36d2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    36d4:	4919      	ldr	r1, [pc, #100]	; (373c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    36d6:	9b01      	ldr	r3, [sp, #4]
    36d8:	681a      	ldr	r2, [r3, #0]
    36da:	4819      	ldr	r0, [pc, #100]	; (3740 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    36dc:	4613      	mov	r3, r2
    36de:	00db      	lsls	r3, r3, #3
    36e0:	4413      	add	r3, r2
    36e2:	4403      	add	r3, r0
    36e4:	3305      	adds	r3, #5
    36e6:	781b      	ldrb	r3, [r3, #0]
    36e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    36ec:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    36ee:	9b03      	ldr	r3, [sp, #12]
    36f0:	f023 030f 	bic.w	r3, r3, #15
    36f4:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    36f6:	9b01      	ldr	r3, [sp, #4]
    36f8:	685b      	ldr	r3, [r3, #4]
    36fa:	3b01      	subs	r3, #1
    36fc:	f003 0307 	and.w	r3, r3, #7
    3700:	9a03      	ldr	r2, [sp, #12]
    3702:	4313      	orrs	r3, r2
    3704:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    3706:	9b01      	ldr	r3, [sp, #4]
    3708:	7a1b      	ldrb	r3, [r3, #8]
    370a:	3b01      	subs	r3, #1
    370c:	00db      	lsls	r3, r3, #3
    370e:	f003 0308 	and.w	r3, r3, #8
    3712:	9a03      	ldr	r2, [sp, #12]
    3714:	4313      	orrs	r3, r2
    3716:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    3718:	4908      	ldr	r1, [pc, #32]	; (373c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    371a:	9b01      	ldr	r3, [sp, #4]
    371c:	681a      	ldr	r2, [r3, #0]
    371e:	4808      	ldr	r0, [pc, #32]	; (3740 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    3720:	4613      	mov	r3, r2
    3722:	00db      	lsls	r3, r3, #3
    3724:	4413      	add	r3, r2
    3726:	4403      	add	r3, r0
    3728:	3305      	adds	r3, #5
    372a:	781b      	ldrb	r3, [r3, #0]
    372c:	461a      	mov	r2, r3
    372e:	9b03      	ldr	r3, [sp, #12]
    3730:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    3734:	bf00      	nop
    3736:	b004      	add	sp, #16
    3738:	4770      	bx	lr
    373a:	bf00      	nop
    373c:	40065000 	.word	0x40065000
    3740:	0000fe24 	.word	0x0000fe24

00003744 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3744:	b084      	sub	sp, #16
    3746:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3748:	4b10      	ldr	r3, [pc, #64]	; (378c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    374a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    374c:	4a0f      	ldr	r2, [pc, #60]	; (378c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    374e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    3752:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    3754:	4b0d      	ldr	r3, [pc, #52]	; (378c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3756:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3758:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    375a:	9b03      	ldr	r3, [sp, #12]
    375c:	f023 030f 	bic.w	r3, r3, #15
    3760:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    3762:	9b01      	ldr	r3, [sp, #4]
    3764:	685b      	ldr	r3, [r3, #4]
    3766:	3b01      	subs	r3, #1
    3768:	005b      	lsls	r3, r3, #1
    376a:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    376e:	9b01      	ldr	r3, [sp, #4]
    3770:	7a1b      	ldrb	r3, [r3, #8]
    3772:	3b01      	subs	r3, #1
    3774:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    3778:	4313      	orrs	r3, r2
    377a:	9a03      	ldr	r2, [sp, #12]
    377c:	4313      	orrs	r3, r2
    377e:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    3780:	4a02      	ldr	r2, [pc, #8]	; (378c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3782:	9b03      	ldr	r3, [sp, #12]
    3784:	6693      	str	r3, [r2, #104]	; 0x68
}
    3786:	bf00      	nop
    3788:	b004      	add	sp, #16
    378a:	4770      	bx	lr
    378c:	40048000 	.word	0x40048000

00003790 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    3790:	b082      	sub	sp, #8
    3792:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3794:	bf00      	nop
    3796:	b002      	add	sp, #8
    3798:	4770      	bx	lr
	...

0000379c <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    379c:	b082      	sub	sp, #8
    379e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    37a0:	bf00      	nop
    37a2:	b002      	add	sp, #8
    37a4:	4770      	bx	lr

000037a6 <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    37a6:	b082      	sub	sp, #8
    37a8:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    37aa:	bf00      	nop
    37ac:	b002      	add	sp, #8
    37ae:	4770      	bx	lr

000037b0 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    37b0:	b500      	push	{lr}
    37b2:	b083      	sub	sp, #12
    37b4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37b6:	9b01      	ldr	r3, [sp, #4]
    37b8:	2b00      	cmp	r3, #0
    37ba:	d002      	beq.n	37c2 <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    37bc:	9801      	ldr	r0, [sp, #4]
    37be:	f000 f86a 	bl	3896 <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37c2:	bf00      	nop
    37c4:	b003      	add	sp, #12
    37c6:	f85d fb04 	ldr.w	pc, [sp], #4

000037ca <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    37ca:	b500      	push	{lr}
    37cc:	b083      	sub	sp, #12
    37ce:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37d0:	9b01      	ldr	r3, [sp, #4]
    37d2:	2b00      	cmp	r3, #0
    37d4:	d002      	beq.n	37dc <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    37d6:	9801      	ldr	r0, [sp, #4]
    37d8:	f000 f884 	bl	38e4 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    37dc:	bf00      	nop
    37de:	b003      	add	sp, #12
    37e0:	f85d fb04 	ldr.w	pc, [sp], #4

000037e4 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    37e4:	b500      	push	{lr}
    37e6:	b089      	sub	sp, #36	; 0x24
    37e8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    37ea:	2300      	movs	r3, #0
    37ec:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    37f0:	9b01      	ldr	r3, [sp, #4]
    37f2:	2b00      	cmp	r3, #0
    37f4:	d031      	beq.n	385a <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    37f6:	4b1b      	ldr	r3, [pc, #108]	; (3864 <Clock_Ip_CompleteSOSC+0x80>)
    37f8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    37fc:	f003 0301 	and.w	r3, r3, #1
    3800:	2b00      	cmp	r3, #0
    3802:	d02a      	beq.n	385a <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3804:	aa03      	add	r2, sp, #12
    3806:	a904      	add	r1, sp, #16
    3808:	a805      	add	r0, sp, #20
    380a:	f24c 3350 	movw	r3, #50000	; 0xc350
    380e:	f7ff fd1d 	bl	324c <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    3812:	4b14      	ldr	r3, [pc, #80]	; (3864 <Clock_Ip_CompleteSOSC+0x80>)
    3814:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3818:	0e1b      	lsrs	r3, r3, #24
    381a:	f003 0301 	and.w	r3, r3, #1
    381e:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3820:	9a03      	ldr	r2, [sp, #12]
    3822:	a904      	add	r1, sp, #16
    3824:	ab05      	add	r3, sp, #20
    3826:	4618      	mov	r0, r3
    3828:	f7ff fd2a 	bl	3280 <Clock_Ip_TimeoutExpired>
    382c:	4603      	mov	r3, r0
    382e:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    3832:	9b06      	ldr	r3, [sp, #24]
    3834:	2b00      	cmp	r3, #0
    3836:	d106      	bne.n	3846 <Clock_Ip_CompleteSOSC+0x62>
    3838:	f89d 301f 	ldrb.w	r3, [sp, #31]
    383c:	f083 0301 	eor.w	r3, r3, #1
    3840:	b2db      	uxtb	r3, r3
    3842:	2b00      	cmp	r3, #0
    3844:	d1e5      	bne.n	3812 <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    3846:	f89d 301f 	ldrb.w	r3, [sp, #31]
    384a:	2b00      	cmp	r3, #0
    384c:	d005      	beq.n	385a <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    384e:	9b01      	ldr	r3, [sp, #4]
    3850:	681b      	ldr	r3, [r3, #0]
    3852:	4619      	mov	r1, r3
    3854:	2001      	movs	r0, #1
    3856:	f7ff fce9 	bl	322c <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    385a:	bf00      	nop
    385c:	b009      	add	sp, #36	; 0x24
    385e:	f85d fb04 	ldr.w	pc, [sp], #4
    3862:	bf00      	nop
    3864:	40064000 	.word	0x40064000

00003868 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    3868:	b500      	push	{lr}
    386a:	b083      	sub	sp, #12
    386c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    386e:	9801      	ldr	r0, [sp, #4]
    3870:	f000 f8c0 	bl	39f4 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3874:	bf00      	nop
    3876:	b003      	add	sp, #12
    3878:	f85d fb04 	ldr.w	pc, [sp], #4

0000387c <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    387c:	b500      	push	{lr}
    387e:	b083      	sub	sp, #12
    3880:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3882:	9b01      	ldr	r3, [sp, #4]
    3884:	2b00      	cmp	r3, #0
    3886:	d002      	beq.n	388e <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    3888:	9801      	ldr	r0, [sp, #4]
    388a:	f000 f8c3 	bl	3a14 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    388e:	bf00      	nop
    3890:	b003      	add	sp, #12
    3892:	f85d fb04 	ldr.w	pc, [sp], #4

00003896 <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3896:	b082      	sub	sp, #8
    3898:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    389a:	4b11      	ldr	r3, [pc, #68]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    389c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    38a0:	4a0f      	ldr	r2, [pc, #60]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38a2:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    38a6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    38aa:	4b0d      	ldr	r3, [pc, #52]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38ac:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    38b0:	4a0b      	ldr	r2, [pc, #44]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38b2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    38b6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    38ba:	4b09      	ldr	r3, [pc, #36]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38bc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    38c0:	4a07      	ldr	r2, [pc, #28]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38c2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    38c6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    38ca:	4b05      	ldr	r3, [pc, #20]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38cc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    38d0:	4a03      	ldr	r2, [pc, #12]	; (38e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    38d2:	f023 0301 	bic.w	r3, r3, #1
    38d6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    38da:	bf00      	nop
    38dc:	b002      	add	sp, #8
    38de:	4770      	bx	lr
    38e0:	40064000 	.word	0x40064000

000038e4 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    38e4:	b082      	sub	sp, #8
    38e6:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    38e8:	9b01      	ldr	r3, [sp, #4]
    38ea:	891b      	ldrh	r3, [r3, #8]
    38ec:	2b01      	cmp	r3, #1
    38ee:	d174      	bne.n	39da <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    38f0:	9b01      	ldr	r3, [sp, #4]
    38f2:	7bdb      	ldrb	r3, [r3, #15]
    38f4:	2b00      	cmp	r3, #0
    38f6:	d002      	beq.n	38fe <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    38f8:	2b01      	cmp	r3, #1
    38fa:	d009      	beq.n	3910 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    38fc:	e011      	b.n	3922 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    38fe:	4b39      	ldr	r3, [pc, #228]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3900:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3904:	4a37      	ldr	r2, [pc, #220]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3906:	f023 0308 	bic.w	r3, r3, #8
    390a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    390e:	e008      	b.n	3922 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    3910:	4b34      	ldr	r3, [pc, #208]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3912:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3916:	4a33      	ldr	r2, [pc, #204]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3918:	f043 0308 	orr.w	r3, r3, #8
    391c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    3920:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    3922:	4b30      	ldr	r3, [pc, #192]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3924:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3928:	4a2e      	ldr	r2, [pc, #184]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    392a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    392e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    3932:	9b01      	ldr	r3, [sp, #4]
    3934:	685b      	ldr	r3, [r3, #4]
    3936:	4a2c      	ldr	r2, [pc, #176]	; (39e8 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    3938:	4293      	cmp	r3, r2
    393a:	d90d      	bls.n	3958 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    393c:	9b01      	ldr	r3, [sp, #4]
    393e:	685b      	ldr	r3, [r3, #4]
    3940:	4a2a      	ldr	r2, [pc, #168]	; (39ec <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    3942:	4293      	cmp	r3, r2
    3944:	d208      	bcs.n	3958 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    3946:	4b27      	ldr	r3, [pc, #156]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3948:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    394c:	4a25      	ldr	r2, [pc, #148]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    394e:	f043 0320 	orr.w	r3, r3, #32
    3952:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    3956:	e007      	b.n	3968 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    3958:	4b22      	ldr	r3, [pc, #136]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    395a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    395e:	4a21      	ldr	r2, [pc, #132]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3960:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    3964:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    3968:	9b01      	ldr	r3, [sp, #4]
    396a:	7b1b      	ldrb	r3, [r3, #12]
    396c:	2b00      	cmp	r3, #0
    396e:	d108      	bne.n	3982 <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    3970:	4b1c      	ldr	r3, [pc, #112]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3972:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3976:	4a1b      	ldr	r2, [pc, #108]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3978:	f043 0304 	orr.w	r3, r3, #4
    397c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    3980:	e007      	b.n	3992 <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    3982:	4b18      	ldr	r3, [pc, #96]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3984:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3988:	4a16      	ldr	r2, [pc, #88]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    398a:	f023 0304 	bic.w	r3, r3, #4
    398e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    3992:	9b01      	ldr	r3, [sp, #4]
    3994:	7c1b      	ldrb	r3, [r3, #16]
    3996:	2b02      	cmp	r3, #2
    3998:	d011      	beq.n	39be <Clock_Ip_SetSOSC_TrustedCall+0xda>
    399a:	2b02      	cmp	r3, #2
    399c:	dc14      	bgt.n	39c8 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    399e:	2b00      	cmp	r3, #0
    39a0:	d002      	beq.n	39a8 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    39a2:	2b01      	cmp	r3, #1
    39a4:	d005      	beq.n	39b2 <Clock_Ip_SetSOSC_TrustedCall+0xce>
    39a6:	e00f      	b.n	39c8 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    39a8:	4b0e      	ldr	r3, [pc, #56]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    39aa:	2201      	movs	r2, #1
    39ac:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    39b0:	e014      	b.n	39dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    39b2:	4b0c      	ldr	r3, [pc, #48]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    39b4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    39b8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    39bc:	e00e      	b.n	39dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    39be:	4b09      	ldr	r3, [pc, #36]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    39c0:	4a0b      	ldr	r2, [pc, #44]	; (39f0 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    39c2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    39c6:	e009      	b.n	39dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    39c8:	4b06      	ldr	r3, [pc, #24]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    39ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    39ce:	4a05      	ldr	r2, [pc, #20]	; (39e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    39d0:	f043 0301 	orr.w	r3, r3, #1
    39d4:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    39d8:	e000      	b.n	39dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    39da:	bf00      	nop
}
    39dc:	bf00      	nop
    39de:	b002      	add	sp, #8
    39e0:	4770      	bx	lr
    39e2:	bf00      	nop
    39e4:	40064000 	.word	0x40064000
    39e8:	003d08ff 	.word	0x003d08ff
    39ec:	007a1200 	.word	0x007a1200
    39f0:	00030001 	.word	0x00030001

000039f4 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    39f4:	b082      	sub	sp, #8
    39f6:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    39f8:	4b05      	ldr	r3, [pc, #20]	; (3a10 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    39fa:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    39fe:	4a04      	ldr	r2, [pc, #16]	; (3a10 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    3a00:	f023 0301 	bic.w	r3, r3, #1
    3a04:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    3a08:	bf00      	nop
    3a0a:	b002      	add	sp, #8
    3a0c:	4770      	bx	lr
    3a0e:	bf00      	nop
    3a10:	40064000 	.word	0x40064000

00003a14 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3a14:	b082      	sub	sp, #8
    3a16:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3a18:	9b01      	ldr	r3, [sp, #4]
    3a1a:	891b      	ldrh	r3, [r3, #8]
    3a1c:	2b01      	cmp	r3, #1
    3a1e:	d107      	bne.n	3a30 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    3a20:	4b05      	ldr	r3, [pc, #20]	; (3a38 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    3a22:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3a26:	4a04      	ldr	r2, [pc, #16]	; (3a38 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    3a28:	f043 0301 	orr.w	r3, r3, #1
    3a2c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    3a30:	bf00      	nop
    3a32:	b002      	add	sp, #8
    3a34:	4770      	bx	lr
    3a36:	bf00      	nop
    3a38:	40064000 	.word	0x40064000

00003a3c <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    3a3c:	b082      	sub	sp, #8
    3a3e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3a40:	bf00      	nop
    3a42:	b002      	add	sp, #8
    3a44:	4770      	bx	lr

00003a46 <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    3a46:	b082      	sub	sp, #8
    3a48:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    3a4a:	2300      	movs	r3, #0
}
    3a4c:	4618      	mov	r0, r3
    3a4e:	b002      	add	sp, #8
    3a50:	4770      	bx	lr

00003a52 <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    3a52:	b082      	sub	sp, #8
    3a54:	9001      	str	r0, [sp, #4]
    3a56:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    3a58:	bf00      	nop
    3a5a:	b002      	add	sp, #8
    3a5c:	4770      	bx	lr
	...

00003a60 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    3a60:	b082      	sub	sp, #8
    3a62:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3a64:	bf00      	nop
    3a66:	b002      	add	sp, #8
    3a68:	4770      	bx	lr

00003a6a <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    3a6a:	b082      	sub	sp, #8
    3a6c:	9001      	str	r0, [sp, #4]
    3a6e:	460b      	mov	r3, r1
    3a70:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    3a74:	bf00      	nop
    3a76:	b002      	add	sp, #8
    3a78:	4770      	bx	lr

00003a7a <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    3a7a:	b500      	push	{lr}
    3a7c:	b083      	sub	sp, #12
    3a7e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3a80:	9b01      	ldr	r3, [sp, #4]
    3a82:	2b00      	cmp	r3, #0
    3a84:	d002      	beq.n	3a8c <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    3a86:	9801      	ldr	r0, [sp, #4]
    3a88:	f000 f8e7 	bl	3c5a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3a8c:	bf00      	nop
    3a8e:	b003      	add	sp, #12
    3a90:	f85d fb04 	ldr.w	pc, [sp], #4

00003a94 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3a94:	b500      	push	{lr}
    3a96:	b085      	sub	sp, #20
    3a98:	9001      	str	r0, [sp, #4]
    3a9a:	460b      	mov	r3, r1
    3a9c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3aa0:	9b01      	ldr	r3, [sp, #4]
    3aa2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3aa4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3aa8:	2b00      	cmp	r3, #0
    3aaa:	d003      	beq.n	3ab4 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    3aac:	2300      	movs	r3, #0
    3aae:	f8ad 300c 	strh.w	r3, [sp, #12]
    3ab2:	e002      	b.n	3aba <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3ab4:	2301      	movs	r3, #1
    3ab6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    3aba:	ab02      	add	r3, sp, #8
    3abc:	4618      	mov	r0, r3
    3abe:	f7ff ffdc 	bl	3a7a <Clock_Ip_ClockSetSimLPO1KEnable>
}
    3ac2:	bf00      	nop
    3ac4:	b005      	add	sp, #20
    3ac6:	f85d fb04 	ldr.w	pc, [sp], #4

00003aca <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    3aca:	b500      	push	{lr}
    3acc:	b083      	sub	sp, #12
    3ace:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3ad0:	9b01      	ldr	r3, [sp, #4]
    3ad2:	2b00      	cmp	r3, #0
    3ad4:	d002      	beq.n	3adc <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    3ad6:	9801      	ldr	r0, [sp, #4]
    3ad8:	f000 f8d6 	bl	3c88 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3adc:	bf00      	nop
    3ade:	b003      	add	sp, #12
    3ae0:	f85d fb04 	ldr.w	pc, [sp], #4

00003ae4 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3ae4:	b500      	push	{lr}
    3ae6:	b085      	sub	sp, #20
    3ae8:	9001      	str	r0, [sp, #4]
    3aea:	460b      	mov	r3, r1
    3aec:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3af0:	9b01      	ldr	r3, [sp, #4]
    3af2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3af4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3af8:	2b00      	cmp	r3, #0
    3afa:	d003      	beq.n	3b04 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    3afc:	2300      	movs	r3, #0
    3afe:	f8ad 300c 	strh.w	r3, [sp, #12]
    3b02:	e002      	b.n	3b0a <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3b04:	2301      	movs	r3, #1
    3b06:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    3b0a:	ab02      	add	r3, sp, #8
    3b0c:	4618      	mov	r0, r3
    3b0e:	f7ff ffdc 	bl	3aca <Clock_Ip_ClockSetSimLPO32KEnable>
}
    3b12:	bf00      	nop
    3b14:	b005      	add	sp, #20
    3b16:	f85d fb04 	ldr.w	pc, [sp], #4

00003b1a <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    3b1a:	b500      	push	{lr}
    3b1c:	b083      	sub	sp, #12
    3b1e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b20:	9b01      	ldr	r3, [sp, #4]
    3b22:	2b00      	cmp	r3, #0
    3b24:	d002      	beq.n	3b2c <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    3b26:	9801      	ldr	r0, [sp, #4]
    3b28:	f000 f8c6 	bl	3cb8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b2c:	bf00      	nop
    3b2e:	b003      	add	sp, #12
    3b30:	f85d fb04 	ldr.w	pc, [sp], #4

00003b34 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3b34:	b500      	push	{lr}
    3b36:	b085      	sub	sp, #20
    3b38:	9001      	str	r0, [sp, #4]
    3b3a:	460b      	mov	r3, r1
    3b3c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3b40:	9b01      	ldr	r3, [sp, #4]
    3b42:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3b44:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3b48:	2b00      	cmp	r3, #0
    3b4a:	d003      	beq.n	3b54 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    3b4c:	2300      	movs	r3, #0
    3b4e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3b52:	e002      	b.n	3b5a <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3b54:	2301      	movs	r3, #1
    3b56:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    3b5a:	ab02      	add	r3, sp, #8
    3b5c:	4618      	mov	r0, r3
    3b5e:	f7ff ffdc 	bl	3b1a <Clock_Ip_ClockSetSimClkoutEnable>
}
    3b62:	bf00      	nop
    3b64:	b005      	add	sp, #20
    3b66:	f85d fb04 	ldr.w	pc, [sp], #4

00003b6a <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    3b6a:	b500      	push	{lr}
    3b6c:	b083      	sub	sp, #12
    3b6e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b70:	9b01      	ldr	r3, [sp, #4]
    3b72:	2b00      	cmp	r3, #0
    3b74:	d002      	beq.n	3b7c <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    3b76:	9801      	ldr	r0, [sp, #4]
    3b78:	f000 f8b6 	bl	3ce8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b7c:	bf00      	nop
    3b7e:	b003      	add	sp, #12
    3b80:	f85d fb04 	ldr.w	pc, [sp], #4

00003b84 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3b84:	b500      	push	{lr}
    3b86:	b085      	sub	sp, #20
    3b88:	9001      	str	r0, [sp, #4]
    3b8a:	460b      	mov	r3, r1
    3b8c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3b90:	9b01      	ldr	r3, [sp, #4]
    3b92:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3b94:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3b98:	2b00      	cmp	r3, #0
    3b9a:	d003      	beq.n	3ba4 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    3b9c:	2300      	movs	r3, #0
    3b9e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3ba2:	e002      	b.n	3baa <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3ba4:	2301      	movs	r3, #1
    3ba6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    3baa:	ab02      	add	r3, sp, #8
    3bac:	4618      	mov	r0, r3
    3bae:	f7ff ffdc 	bl	3b6a <Clock_Ip_ClockSetPccCgcEnable>
}
    3bb2:	bf00      	nop
    3bb4:	b005      	add	sp, #20
    3bb6:	f85d fb04 	ldr.w	pc, [sp], #4

00003bba <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    3bba:	b500      	push	{lr}
    3bbc:	b083      	sub	sp, #12
    3bbe:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3bc0:	9b01      	ldr	r3, [sp, #4]
    3bc2:	2b00      	cmp	r3, #0
    3bc4:	d002      	beq.n	3bcc <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    3bc6:	9801      	ldr	r0, [sp, #4]
    3bc8:	f000 f8bc 	bl	3d44 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3bcc:	bf00      	nop
    3bce:	b003      	add	sp, #12
    3bd0:	f85d fb04 	ldr.w	pc, [sp], #4

00003bd4 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    3bd4:	b500      	push	{lr}
    3bd6:	b085      	sub	sp, #20
    3bd8:	9001      	str	r0, [sp, #4]
    3bda:	460b      	mov	r3, r1
    3bdc:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3be0:	9b01      	ldr	r3, [sp, #4]
    3be2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3be4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3be8:	2b00      	cmp	r3, #0
    3bea:	d003      	beq.n	3bf4 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    3bec:	2300      	movs	r3, #0
    3bee:	f8ad 300c 	strh.w	r3, [sp, #12]
    3bf2:	e002      	b.n	3bfa <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3bf4:	2301      	movs	r3, #1
    3bf6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    3bfa:	ab02      	add	r3, sp, #8
    3bfc:	4618      	mov	r0, r3
    3bfe:	f7ff ffdc 	bl	3bba <Clock_Ip_ClockSetSimGate>
}
    3c02:	bf00      	nop
    3c04:	b005      	add	sp, #20
    3c06:	f85d fb04 	ldr.w	pc, [sp], #4

00003c0a <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    3c0a:	b500      	push	{lr}
    3c0c:	b083      	sub	sp, #12
    3c0e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3c10:	9b01      	ldr	r3, [sp, #4]
    3c12:	2b00      	cmp	r3, #0
    3c14:	d002      	beq.n	3c1c <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    3c16:	9801      	ldr	r0, [sp, #4]
    3c18:	f000 f8c0 	bl	3d9c <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3c1c:	bf00      	nop
    3c1e:	b003      	add	sp, #12
    3c20:	f85d fb04 	ldr.w	pc, [sp], #4

00003c24 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3c24:	b500      	push	{lr}
    3c26:	b085      	sub	sp, #20
    3c28:	9001      	str	r0, [sp, #4]
    3c2a:	460b      	mov	r3, r1
    3c2c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3c30:	9b01      	ldr	r3, [sp, #4]
    3c32:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3c34:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3c38:	2b00      	cmp	r3, #0
    3c3a:	d003      	beq.n	3c44 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    3c3c:	2300      	movs	r3, #0
    3c3e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3c42:	e002      	b.n	3c4a <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3c44:	2301      	movs	r3, #1
    3c46:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    3c4a:	ab02      	add	r3, sp, #8
    3c4c:	4618      	mov	r0, r3
    3c4e:	f7ff ffdc 	bl	3c0a <Clock_Ip_ClockSetSimTraceEnable>
}
    3c52:	bf00      	nop
    3c54:	b005      	add	sp, #20
    3c56:	f85d fb04 	ldr.w	pc, [sp], #4

00003c5a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3c5a:	b084      	sub	sp, #16
    3c5c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3c5e:	4b09      	ldr	r3, [pc, #36]	; (3c84 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3c60:	691b      	ldr	r3, [r3, #16]
    3c62:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    3c64:	9b03      	ldr	r3, [sp, #12]
    3c66:	f023 0301 	bic.w	r3, r3, #1
    3c6a:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3c6c:	9b01      	ldr	r3, [sp, #4]
    3c6e:	889b      	ldrh	r3, [r3, #4]
    3c70:	461a      	mov	r2, r3
    3c72:	9b03      	ldr	r3, [sp, #12]
    3c74:	4313      	orrs	r3, r2
    3c76:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3c78:	4a02      	ldr	r2, [pc, #8]	; (3c84 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3c7a:	9b03      	ldr	r3, [sp, #12]
    3c7c:	6113      	str	r3, [r2, #16]
}
    3c7e:	bf00      	nop
    3c80:	b004      	add	sp, #16
    3c82:	4770      	bx	lr
    3c84:	40048000 	.word	0x40048000

00003c88 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3c88:	b084      	sub	sp, #16
    3c8a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3c8c:	4b09      	ldr	r3, [pc, #36]	; (3cb4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    3c8e:	691b      	ldr	r3, [r3, #16]
    3c90:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    3c92:	9b03      	ldr	r3, [sp, #12]
    3c94:	f023 0302 	bic.w	r3, r3, #2
    3c98:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3c9a:	9b01      	ldr	r3, [sp, #4]
    3c9c:	889b      	ldrh	r3, [r3, #4]
    3c9e:	005b      	lsls	r3, r3, #1
    3ca0:	9a03      	ldr	r2, [sp, #12]
    3ca2:	4313      	orrs	r3, r2
    3ca4:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3ca6:	4a03      	ldr	r2, [pc, #12]	; (3cb4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    3ca8:	9b03      	ldr	r3, [sp, #12]
    3caa:	6113      	str	r3, [r2, #16]
}
    3cac:	bf00      	nop
    3cae:	b004      	add	sp, #16
    3cb0:	4770      	bx	lr
    3cb2:	bf00      	nop
    3cb4:	40048000 	.word	0x40048000

00003cb8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3cb8:	b084      	sub	sp, #16
    3cba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    3cbc:	4b09      	ldr	r3, [pc, #36]	; (3ce4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3cbe:	685b      	ldr	r3, [r3, #4]
    3cc0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    3cc2:	9b03      	ldr	r3, [sp, #12]
    3cc4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    3cc8:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    3cca:	9b01      	ldr	r3, [sp, #4]
    3ccc:	889b      	ldrh	r3, [r3, #4]
    3cce:	02db      	lsls	r3, r3, #11
    3cd0:	9a03      	ldr	r2, [sp, #12]
    3cd2:	4313      	orrs	r3, r2
    3cd4:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3cd6:	4a03      	ldr	r2, [pc, #12]	; (3ce4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3cd8:	9b03      	ldr	r3, [sp, #12]
    3cda:	6053      	str	r3, [r2, #4]
}
    3cdc:	bf00      	nop
    3cde:	b004      	add	sp, #16
    3ce0:	4770      	bx	lr
    3ce2:	bf00      	nop
    3ce4:	40048000 	.word	0x40048000

00003ce8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3ce8:	b084      	sub	sp, #16
    3cea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    3cec:	4913      	ldr	r1, [pc, #76]	; (3d3c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3cee:	9b01      	ldr	r3, [sp, #4]
    3cf0:	681a      	ldr	r2, [r3, #0]
    3cf2:	4813      	ldr	r0, [pc, #76]	; (3d40 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3cf4:	4613      	mov	r3, r2
    3cf6:	00db      	lsls	r3, r3, #3
    3cf8:	4413      	add	r3, r2
    3cfa:	4403      	add	r3, r0
    3cfc:	3306      	adds	r3, #6
    3cfe:	781b      	ldrb	r3, [r3, #0]
    3d00:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3d04:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    3d06:	9b03      	ldr	r3, [sp, #12]
    3d08:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    3d0c:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    3d0e:	9b01      	ldr	r3, [sp, #4]
    3d10:	889b      	ldrh	r3, [r3, #4]
    3d12:	079b      	lsls	r3, r3, #30
    3d14:	9a03      	ldr	r2, [sp, #12]
    3d16:	4313      	orrs	r3, r2
    3d18:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    3d1a:	4908      	ldr	r1, [pc, #32]	; (3d3c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3d1c:	9b01      	ldr	r3, [sp, #4]
    3d1e:	681a      	ldr	r2, [r3, #0]
    3d20:	4807      	ldr	r0, [pc, #28]	; (3d40 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3d22:	4613      	mov	r3, r2
    3d24:	00db      	lsls	r3, r3, #3
    3d26:	4413      	add	r3, r2
    3d28:	4403      	add	r3, r0
    3d2a:	3306      	adds	r3, #6
    3d2c:	781b      	ldrb	r3, [r3, #0]
    3d2e:	461a      	mov	r2, r3
    3d30:	9b03      	ldr	r3, [sp, #12]
    3d32:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    3d36:	bf00      	nop
    3d38:	b004      	add	sp, #16
    3d3a:	4770      	bx	lr
    3d3c:	40065000 	.word	0x40065000
    3d40:	0000fe24 	.word	0x0000fe24

00003d44 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3d44:	b086      	sub	sp, #24
    3d46:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    3d48:	9b01      	ldr	r3, [sp, #4]
    3d4a:	889b      	ldrh	r3, [r3, #4]
    3d4c:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    3d4e:	9b01      	ldr	r3, [sp, #4]
    3d50:	681a      	ldr	r2, [r3, #0]
    3d52:	4910      	ldr	r1, [pc, #64]	; (3d94 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    3d54:	4613      	mov	r3, r2
    3d56:	00db      	lsls	r3, r3, #3
    3d58:	4413      	add	r3, r2
    3d5a:	440b      	add	r3, r1
    3d5c:	3306      	adds	r3, #6
    3d5e:	781b      	ldrb	r3, [r3, #0]
    3d60:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    3d62:	4b0d      	ldr	r3, [pc, #52]	; (3d98 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3d64:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3d66:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    3d68:	2201      	movs	r2, #1
    3d6a:	9b04      	ldr	r3, [sp, #16]
    3d6c:	fa02 f303 	lsl.w	r3, r2, r3
    3d70:	43db      	mvns	r3, r3
    3d72:	9a03      	ldr	r2, [sp, #12]
    3d74:	4013      	ands	r3, r2
    3d76:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    3d78:	9a05      	ldr	r2, [sp, #20]
    3d7a:	9b04      	ldr	r3, [sp, #16]
    3d7c:	fa02 f303 	lsl.w	r3, r2, r3
    3d80:	9a03      	ldr	r2, [sp, #12]
    3d82:	4313      	orrs	r3, r2
    3d84:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    3d86:	4a04      	ldr	r2, [pc, #16]	; (3d98 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3d88:	9b03      	ldr	r3, [sp, #12]
    3d8a:	6413      	str	r3, [r2, #64]	; 0x40
}
    3d8c:	bf00      	nop
    3d8e:	b006      	add	sp, #24
    3d90:	4770      	bx	lr
    3d92:	bf00      	nop
    3d94:	0000fe24 	.word	0x0000fe24
    3d98:	40048000 	.word	0x40048000

00003d9c <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3d9c:	b084      	sub	sp, #16
    3d9e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    3da0:	4b0a      	ldr	r3, [pc, #40]	; (3dcc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3da2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3da4:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    3da6:	9b01      	ldr	r3, [sp, #4]
    3da8:	889b      	ldrh	r3, [r3, #4]
    3daa:	2b01      	cmp	r3, #1
    3dac:	d104      	bne.n	3db8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    3dae:	9b03      	ldr	r3, [sp, #12]
    3db0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    3db4:	9303      	str	r3, [sp, #12]
    3db6:	e003      	b.n	3dc0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3db8:	9b03      	ldr	r3, [sp, #12]
    3dba:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    3dbe:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    3dc0:	4a02      	ldr	r2, [pc, #8]	; (3dcc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3dc2:	9b03      	ldr	r3, [sp, #12]
    3dc4:	6693      	str	r3, [r2, #104]	; 0x68
}
    3dc6:	bf00      	nop
    3dc8:	b004      	add	sp, #16
    3dca:	4770      	bx	lr
    3dcc:	40048000 	.word	0x40048000

00003dd0 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    3dd0:	b082      	sub	sp, #8
    3dd2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3dd4:	bf00      	nop
    3dd6:	b002      	add	sp, #8
    3dd8:	4770      	bx	lr

00003dda <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    3dda:	b082      	sub	sp, #8
    3ddc:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3dde:	bf00      	nop
    3de0:	b002      	add	sp, #8
    3de2:	4770      	bx	lr

00003de4 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3de4:	b500      	push	{lr}
    3de6:	b083      	sub	sp, #12
    3de8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3dea:	9b01      	ldr	r3, [sp, #4]
    3dec:	2b00      	cmp	r3, #0
    3dee:	d002      	beq.n	3df6 <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    3df0:	9801      	ldr	r0, [sp, #4]
    3df2:	f000 f8d1 	bl	3f98 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3df6:	bf00      	nop
    3df8:	b003      	add	sp, #12
    3dfa:	f85d fb04 	ldr.w	pc, [sp], #4

00003dfe <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3dfe:	b500      	push	{lr}
    3e00:	b083      	sub	sp, #12
    3e02:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e04:	9b01      	ldr	r3, [sp, #4]
    3e06:	2b00      	cmp	r3, #0
    3e08:	d002      	beq.n	3e10 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    3e0a:	9801      	ldr	r0, [sp, #4]
    3e0c:	f000 f950 	bl	40b0 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e10:	bf00      	nop
    3e12:	b003      	add	sp, #12
    3e14:	f85d fb04 	ldr.w	pc, [sp], #4

00003e18 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    3e18:	b500      	push	{lr}
    3e1a:	b083      	sub	sp, #12
    3e1c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    3e1e:	9801      	ldr	r0, [sp, #4]
    3e20:	f000 f98e 	bl	4140 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3e24:	bf00      	nop
    3e26:	b003      	add	sp, #12
    3e28:	f85d fb04 	ldr.w	pc, [sp], #4

00003e2c <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3e2c:	b500      	push	{lr}
    3e2e:	b083      	sub	sp, #12
    3e30:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e32:	9b01      	ldr	r3, [sp, #4]
    3e34:	2b00      	cmp	r3, #0
    3e36:	d002      	beq.n	3e3e <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    3e38:	9801      	ldr	r0, [sp, #4]
    3e3a:	f000 f999 	bl	4170 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e3e:	bf00      	nop
    3e40:	b003      	add	sp, #12
    3e42:	f85d fb04 	ldr.w	pc, [sp], #4

00003e46 <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3e46:	b500      	push	{lr}
    3e48:	b083      	sub	sp, #12
    3e4a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e4c:	9b01      	ldr	r3, [sp, #4]
    3e4e:	2b00      	cmp	r3, #0
    3e50:	d002      	beq.n	3e58 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    3e52:	9801      	ldr	r0, [sp, #4]
    3e54:	f000 f9b0 	bl	41b8 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e58:	bf00      	nop
    3e5a:	b003      	add	sp, #12
    3e5c:	f85d fb04 	ldr.w	pc, [sp], #4

00003e60 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    3e60:	b500      	push	{lr}
    3e62:	b083      	sub	sp, #12
    3e64:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    3e66:	9801      	ldr	r0, [sp, #4]
    3e68:	f000 f9ba 	bl	41e0 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3e6c:	bf00      	nop
    3e6e:	b003      	add	sp, #12
    3e70:	f85d fb04 	ldr.w	pc, [sp], #4

00003e74 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3e74:	b500      	push	{lr}
    3e76:	b083      	sub	sp, #12
    3e78:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e7a:	9b01      	ldr	r3, [sp, #4]
    3e7c:	2b00      	cmp	r3, #0
    3e7e:	d002      	beq.n	3e86 <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    3e80:	9801      	ldr	r0, [sp, #4]
    3e82:	f000 f9bd 	bl	4200 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e86:	bf00      	nop
    3e88:	b003      	add	sp, #12
    3e8a:	f85d fb04 	ldr.w	pc, [sp], #4

00003e8e <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3e8e:	b500      	push	{lr}
    3e90:	b083      	sub	sp, #12
    3e92:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e94:	9b01      	ldr	r3, [sp, #4]
    3e96:	2b00      	cmp	r3, #0
    3e98:	d002      	beq.n	3ea0 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    3e9a:	9801      	ldr	r0, [sp, #4]
    3e9c:	f000 f9d4 	bl	4248 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3ea0:	bf00      	nop
    3ea2:	b003      	add	sp, #12
    3ea4:	f85d fb04 	ldr.w	pc, [sp], #4

00003ea8 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    3ea8:	b500      	push	{lr}
    3eaa:	b083      	sub	sp, #12
    3eac:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    3eae:	9801      	ldr	r0, [sp, #4]
    3eb0:	f000 f9de 	bl	4270 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3eb4:	bf00      	nop
    3eb6:	b003      	add	sp, #12
    3eb8:	f85d fb04 	ldr.w	pc, [sp], #4

00003ebc <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    3ebc:	b500      	push	{lr}
    3ebe:	b089      	sub	sp, #36	; 0x24
    3ec0:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    3ec2:	2300      	movs	r3, #0
    3ec4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    3ec8:	4b20      	ldr	r3, [pc, #128]	; (3f4c <SetInputSouceSytemClock+0x90>)
    3eca:	695b      	ldr	r3, [r3, #20]
    3ecc:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3ece:	9b06      	ldr	r3, [sp, #24]
    3ed0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3ed4:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    3ed6:	9b01      	ldr	r3, [sp, #4]
    3ed8:	061b      	lsls	r3, r3, #24
    3eda:	9a06      	ldr	r2, [sp, #24]
    3edc:	4313      	orrs	r3, r2
    3ede:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    3ee0:	4a1a      	ldr	r2, [pc, #104]	; (3f4c <SetInputSouceSytemClock+0x90>)
    3ee2:	9b06      	ldr	r3, [sp, #24]
    3ee4:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3ee6:	aa02      	add	r2, sp, #8
    3ee8:	a903      	add	r1, sp, #12
    3eea:	a804      	add	r0, sp, #16
    3eec:	f24c 3350 	movw	r3, #50000	; 0xc350
    3ef0:	f7ff f9ac 	bl	324c <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    3ef4:	4b15      	ldr	r3, [pc, #84]	; (3f4c <SetInputSouceSytemClock+0x90>)
    3ef6:	691b      	ldr	r3, [r3, #16]
    3ef8:	0e1b      	lsrs	r3, r3, #24
    3efa:	f003 030f 	and.w	r3, r3, #15
    3efe:	9a01      	ldr	r2, [sp, #4]
    3f00:	429a      	cmp	r2, r3
    3f02:	bf0c      	ite	eq
    3f04:	2301      	moveq	r3, #1
    3f06:	2300      	movne	r3, #0
    3f08:	b2db      	uxtb	r3, r3
    3f0a:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3f0c:	9a02      	ldr	r2, [sp, #8]
    3f0e:	a903      	add	r1, sp, #12
    3f10:	ab04      	add	r3, sp, #16
    3f12:	4618      	mov	r0, r3
    3f14:	f7ff f9b4 	bl	3280 <Clock_Ip_TimeoutExpired>
    3f18:	4603      	mov	r3, r0
    3f1a:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    3f1e:	9b05      	ldr	r3, [sp, #20]
    3f20:	2b00      	cmp	r3, #0
    3f22:	d106      	bne.n	3f32 <SetInputSouceSytemClock+0x76>
    3f24:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f28:	f083 0301 	eor.w	r3, r3, #1
    3f2c:	b2db      	uxtb	r3, r3
    3f2e:	2b00      	cmp	r3, #0
    3f30:	d1e0      	bne.n	3ef4 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    3f32:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f36:	2b00      	cmp	r3, #0
    3f38:	d003      	beq.n	3f42 <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3f3a:	2105      	movs	r1, #5
    3f3c:	2001      	movs	r0, #1
    3f3e:	f7ff f975 	bl	322c <Clock_Ip_ReportClockErrors>
    }
}
    3f42:	bf00      	nop
    3f44:	b009      	add	sp, #36	; 0x24
    3f46:	f85d fb04 	ldr.w	pc, [sp], #4
    3f4a:	bf00      	nop
    3f4c:	40064000 	.word	0x40064000

00003f50 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3f50:	b500      	push	{lr}
    3f52:	b083      	sub	sp, #12
    3f54:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3f56:	9b01      	ldr	r3, [sp, #4]
    3f58:	2b00      	cmp	r3, #0
    3f5a:	d002      	beq.n	3f62 <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    3f5c:	9801      	ldr	r0, [sp, #4]
    3f5e:	f000 f997 	bl	4290 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3f62:	bf00      	nop
    3f64:	b003      	add	sp, #12
    3f66:	f85d fb04 	ldr.w	pc, [sp], #4

00003f6a <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3f6a:	b500      	push	{lr}
    3f6c:	b083      	sub	sp, #12
    3f6e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3f70:	9b01      	ldr	r3, [sp, #4]
    3f72:	2b00      	cmp	r3, #0
    3f74:	d002      	beq.n	3f7c <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    3f76:	9801      	ldr	r0, [sp, #4]
    3f78:	f000 fa7e 	bl	4478 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3f7c:	bf00      	nop
    3f7e:	b003      	add	sp, #12
    3f80:	f85d fb04 	ldr.w	pc, [sp], #4

00003f84 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    3f84:	b500      	push	{lr}
    3f86:	b083      	sub	sp, #12
    3f88:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    3f8a:	9801      	ldr	r0, [sp, #4]
    3f8c:	f000 fab8 	bl	4500 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3f90:	bf00      	nop
    3f92:	b003      	add	sp, #12
    3f94:	f85d fb04 	ldr.w	pc, [sp], #4

00003f98 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3f98:	b500      	push	{lr}
    3f9a:	b08b      	sub	sp, #44	; 0x2c
    3f9c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3f9e:	2300      	movs	r3, #0
    3fa0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    3fa4:	9b01      	ldr	r3, [sp, #4]
    3fa6:	2b00      	cmp	r3, #0
    3fa8:	d10b      	bne.n	3fc2 <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    3faa:	2305      	movs	r3, #5
    3fac:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    3fae:	2301      	movs	r3, #1
    3fb0:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    3fb4:	2301      	movs	r3, #1
    3fb6:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    3fba:	2301      	movs	r3, #1
    3fbc:	f88d 3010 	strb.w	r3, [sp, #16]
    3fc0:	e00e      	b.n	3fe0 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    3fc2:	9b01      	ldr	r3, [sp, #4]
    3fc4:	681b      	ldr	r3, [r3, #0]
    3fc6:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    3fc8:	9b01      	ldr	r3, [sp, #4]
    3fca:	79db      	ldrb	r3, [r3, #7]
    3fcc:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    3fd0:	9b01      	ldr	r3, [sp, #4]
    3fd2:	889b      	ldrh	r3, [r3, #4]
    3fd4:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    3fd8:	9b01      	ldr	r3, [sp, #4]
    3fda:	7a1b      	ldrb	r3, [r3, #8]
    3fdc:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3fe0:	4b32      	ldr	r3, [pc, #200]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3fe2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3fe6:	4a31      	ldr	r2, [pc, #196]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3fe8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3fec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    3ff0:	4b2e      	ldr	r3, [pc, #184]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ff2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ff6:	4a2d      	ldr	r2, [pc, #180]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ff8:	f023 0301 	bic.w	r3, r3, #1
    3ffc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    4000:	4b2a      	ldr	r3, [pc, #168]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    4002:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    4006:	4a29      	ldr	r2, [pc, #164]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    4008:	f023 0304 	bic.w	r3, r3, #4
    400c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    4010:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    4014:	2b01      	cmp	r3, #1
    4016:	d144      	bne.n	40a2 <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    4018:	f89d 300f 	ldrb.w	r3, [sp, #15]
    401c:	4a23      	ldr	r2, [pc, #140]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    401e:	f003 0301 	and.w	r3, r3, #1
    4022:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    4026:	4b21      	ldr	r3, [pc, #132]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    4028:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    402c:	4a1f      	ldr	r2, [pc, #124]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    402e:	f043 0301 	orr.w	r3, r3, #1
    4032:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    4036:	4b1d      	ldr	r3, [pc, #116]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    4038:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    403c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    4040:	009b      	lsls	r3, r3, #2
    4042:	f003 0304 	and.w	r3, r3, #4
    4046:	4919      	ldr	r1, [pc, #100]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    4048:	4313      	orrs	r3, r2
    404a:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    404e:	aa05      	add	r2, sp, #20
    4050:	a906      	add	r1, sp, #24
    4052:	a807      	add	r0, sp, #28
    4054:	f24c 3350 	movw	r3, #50000	; 0xc350
    4058:	f7ff f8f8 	bl	324c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    405c:	4b13      	ldr	r3, [pc, #76]	; (40ac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    405e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    4062:	0e1b      	lsrs	r3, r3, #24
    4064:	f003 0301 	and.w	r3, r3, #1
    4068:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    406a:	9a05      	ldr	r2, [sp, #20]
    406c:	a906      	add	r1, sp, #24
    406e:	ab07      	add	r3, sp, #28
    4070:	4618      	mov	r0, r3
    4072:	f7ff f905 	bl	3280 <Clock_Ip_TimeoutExpired>
    4076:	4603      	mov	r3, r0
    4078:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    407c:	9b08      	ldr	r3, [sp, #32]
    407e:	2b00      	cmp	r3, #0
    4080:	d106      	bne.n	4090 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    4082:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    4086:	f083 0301 	eor.w	r3, r3, #1
    408a:	b2db      	uxtb	r3, r3
    408c:	2b00      	cmp	r3, #0
    408e:	d1e5      	bne.n	405c <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    4090:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    4094:	2b00      	cmp	r3, #0
    4096:	d004      	beq.n	40a2 <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    4098:	9b02      	ldr	r3, [sp, #8]
    409a:	4619      	mov	r1, r3
    409c:	2001      	movs	r0, #1
    409e:	f7ff f8c5 	bl	322c <Clock_Ip_ReportClockErrors>
        }
    }
}
    40a2:	bf00      	nop
    40a4:	b00b      	add	sp, #44	; 0x2c
    40a6:	f85d fb04 	ldr.w	pc, [sp], #4
    40aa:	bf00      	nop
    40ac:	40064000 	.word	0x40064000

000040b0 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    40b0:	b500      	push	{lr}
    40b2:	b089      	sub	sp, #36	; 0x24
    40b4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    40b6:	2300      	movs	r3, #0
    40b8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    40bc:	4b1f      	ldr	r3, [pc, #124]	; (413c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    40be:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40c2:	4a1e      	ldr	r2, [pc, #120]	; (413c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    40c4:	f043 0301 	orr.w	r3, r3, #1
    40c8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    40cc:	4b1b      	ldr	r3, [pc, #108]	; (413c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    40ce:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40d2:	4a1a      	ldr	r2, [pc, #104]	; (413c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    40d4:	f043 0304 	orr.w	r3, r3, #4
    40d8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    40dc:	aa03      	add	r2, sp, #12
    40de:	a904      	add	r1, sp, #16
    40e0:	a805      	add	r0, sp, #20
    40e2:	f24c 3350 	movw	r3, #50000	; 0xc350
    40e6:	f7ff f8b1 	bl	324c <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    40ea:	4b14      	ldr	r3, [pc, #80]	; (413c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    40ec:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40f0:	0e1b      	lsrs	r3, r3, #24
    40f2:	f003 0301 	and.w	r3, r3, #1
    40f6:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    40f8:	9a03      	ldr	r2, [sp, #12]
    40fa:	a904      	add	r1, sp, #16
    40fc:	ab05      	add	r3, sp, #20
    40fe:	4618      	mov	r0, r3
    4100:	f7ff f8be 	bl	3280 <Clock_Ip_TimeoutExpired>
    4104:	4603      	mov	r3, r0
    4106:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    410a:	9b06      	ldr	r3, [sp, #24]
    410c:	2b00      	cmp	r3, #0
    410e:	d106      	bne.n	411e <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    4110:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4114:	f083 0301 	eor.w	r3, r3, #1
    4118:	b2db      	uxtb	r3, r3
    411a:	2b00      	cmp	r3, #0
    411c:	d1e5      	bne.n	40ea <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    411e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4122:	2b00      	cmp	r3, #0
    4124:	d005      	beq.n	4132 <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    4126:	9b01      	ldr	r3, [sp, #4]
    4128:	681b      	ldr	r3, [r3, #0]
    412a:	4619      	mov	r1, r3
    412c:	2001      	movs	r0, #1
    412e:	f7ff f87d 	bl	322c <Clock_Ip_ReportClockErrors>
    }
}
    4132:	bf00      	nop
    4134:	b009      	add	sp, #36	; 0x24
    4136:	f85d fb04 	ldr.w	pc, [sp], #4
    413a:	bf00      	nop
    413c:	40064000 	.word	0x40064000

00004140 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    4140:	b082      	sub	sp, #8
    4142:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    4144:	4b09      	ldr	r3, [pc, #36]	; (416c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    4146:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    414a:	4a08      	ldr	r2, [pc, #32]	; (416c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    414c:	f023 0301 	bic.w	r3, r3, #1
    4150:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    4154:	4b05      	ldr	r3, [pc, #20]	; (416c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    4156:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    415a:	4a04      	ldr	r2, [pc, #16]	; (416c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    415c:	f023 0304 	bic.w	r3, r3, #4
    4160:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    4164:	bf00      	nop
    4166:	b002      	add	sp, #8
    4168:	4770      	bx	lr
    416a:	bf00      	nop
    416c:	40064000 	.word	0x40064000

00004170 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4170:	b082      	sub	sp, #8
    4172:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    4174:	4b0f      	ldr	r3, [pc, #60]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4176:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    417a:	4a0e      	ldr	r2, [pc, #56]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    417c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4180:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    4184:	4b0b      	ldr	r3, [pc, #44]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4186:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    418a:	4a0a      	ldr	r2, [pc, #40]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    418c:	f023 0304 	bic.w	r3, r3, #4
    4190:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    4194:	4b07      	ldr	r3, [pc, #28]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4196:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    419a:	9b01      	ldr	r3, [sp, #4]
    419c:	7a1b      	ldrb	r3, [r3, #8]
    419e:	009b      	lsls	r3, r3, #2
    41a0:	f003 0304 	and.w	r3, r3, #4
    41a4:	4903      	ldr	r1, [pc, #12]	; (41b4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    41a6:	4313      	orrs	r3, r2
    41a8:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    41ac:	bf00      	nop
    41ae:	b002      	add	sp, #8
    41b0:	4770      	bx	lr
    41b2:	bf00      	nop
    41b4:	40064000 	.word	0x40064000

000041b8 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    41b8:	b082      	sub	sp, #8
    41ba:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    41bc:	9b01      	ldr	r3, [sp, #4]
    41be:	889b      	ldrh	r3, [r3, #4]
    41c0:	2b01      	cmp	r3, #1
    41c2:	d107      	bne.n	41d4 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    41c4:	4b05      	ldr	r3, [pc, #20]	; (41dc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    41c6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    41ca:	4a04      	ldr	r2, [pc, #16]	; (41dc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    41cc:	f043 0304 	orr.w	r3, r3, #4
    41d0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    41d4:	bf00      	nop
    41d6:	b002      	add	sp, #8
    41d8:	4770      	bx	lr
    41da:	bf00      	nop
    41dc:	40064000 	.word	0x40064000

000041e0 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    41e0:	b082      	sub	sp, #8
    41e2:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    41e4:	4b05      	ldr	r3, [pc, #20]	; (41fc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    41e6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    41ea:	4a04      	ldr	r2, [pc, #16]	; (41fc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    41ec:	f023 0304 	bic.w	r3, r3, #4
    41f0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    41f4:	bf00      	nop
    41f6:	b002      	add	sp, #8
    41f8:	4770      	bx	lr
    41fa:	bf00      	nop
    41fc:	40064000 	.word	0x40064000

00004200 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4200:	b082      	sub	sp, #8
    4202:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    4204:	4b0f      	ldr	r3, [pc, #60]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4206:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    420a:	4a0e      	ldr	r2, [pc, #56]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    420c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4210:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    4214:	4b0b      	ldr	r3, [pc, #44]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4216:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    421a:	4a0a      	ldr	r2, [pc, #40]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    421c:	f023 0302 	bic.w	r3, r3, #2
    4220:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    4224:	4b07      	ldr	r3, [pc, #28]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4226:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    422a:	9b01      	ldr	r3, [sp, #4]
    422c:	7a5b      	ldrb	r3, [r3, #9]
    422e:	005b      	lsls	r3, r3, #1
    4230:	f003 0302 	and.w	r3, r3, #2
    4234:	4903      	ldr	r1, [pc, #12]	; (4244 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4236:	4313      	orrs	r3, r2
    4238:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    423c:	bf00      	nop
    423e:	b002      	add	sp, #8
    4240:	4770      	bx	lr
    4242:	bf00      	nop
    4244:	40064000 	.word	0x40064000

00004248 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4248:	b082      	sub	sp, #8
    424a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    424c:	9b01      	ldr	r3, [sp, #4]
    424e:	889b      	ldrh	r3, [r3, #4]
    4250:	2b01      	cmp	r3, #1
    4252:	d107      	bne.n	4264 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    4254:	4b05      	ldr	r3, [pc, #20]	; (426c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    4256:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    425a:	4a04      	ldr	r2, [pc, #16]	; (426c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    425c:	f043 0302 	orr.w	r3, r3, #2
    4260:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    4264:	bf00      	nop
    4266:	b002      	add	sp, #8
    4268:	4770      	bx	lr
    426a:	bf00      	nop
    426c:	40064000 	.word	0x40064000

00004270 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    4270:	b082      	sub	sp, #8
    4272:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    4274:	4b05      	ldr	r3, [pc, #20]	; (428c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    4276:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    427a:	4a04      	ldr	r2, [pc, #16]	; (428c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    427c:	f023 0302 	bic.w	r3, r3, #2
    4280:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    4284:	bf00      	nop
    4286:	b002      	add	sp, #8
    4288:	4770      	bx	lr
    428a:	bf00      	nop
    428c:	40064000 	.word	0x40064000

00004290 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4290:	b500      	push	{lr}
    4292:	b08b      	sub	sp, #44	; 0x2c
    4294:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    4296:	9b01      	ldr	r3, [sp, #4]
    4298:	681a      	ldr	r2, [r3, #0]
    429a:	4975      	ldr	r1, [pc, #468]	; (4470 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    429c:	4613      	mov	r3, r2
    429e:	00db      	lsls	r3, r3, #3
    42a0:	4413      	add	r3, r2
    42a2:	440b      	add	r3, r1
    42a4:	781b      	ldrb	r3, [r3, #0]
    42a6:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    42a8:	2300      	movs	r3, #0
    42aa:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    42ae:	2300      	movs	r3, #0
    42b0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    42b4:	4b6f      	ldr	r3, [pc, #444]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42b6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    42ba:	4a6e      	ldr	r2, [pc, #440]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42bc:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    42c0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    42c4:	4b6b      	ldr	r3, [pc, #428]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42c6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    42ca:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    42ce:	2b00      	cmp	r3, #0
    42d0:	d07d      	beq.n	43ce <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    42d2:	9b01      	ldr	r3, [sp, #4]
    42d4:	79db      	ldrb	r3, [r3, #7]
    42d6:	461a      	mov	r2, r3
    42d8:	4b66      	ldr	r3, [pc, #408]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42da:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    42de:	f003 0303 	and.w	r3, r3, #3
    42e2:	429a      	cmp	r2, r3
    42e4:	d10b      	bne.n	42fe <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    42e6:	9b01      	ldr	r3, [sp, #4]
    42e8:	799b      	ldrb	r3, [r3, #6]
    42ea:	461a      	mov	r2, r3
    42ec:	4b61      	ldr	r3, [pc, #388]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42ee:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    42f2:	08db      	lsrs	r3, r3, #3
    42f4:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    42f8:	429a      	cmp	r2, r3
    42fa:	f000 80b4 	beq.w	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    42fe:	4b5d      	ldr	r3, [pc, #372]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4300:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    4304:	f003 0301 	and.w	r3, r3, #1
    4308:	2b00      	cmp	r3, #0
    430a:	d105      	bne.n	4318 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    430c:	2301      	movs	r3, #1
    430e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    4312:	2000      	movs	r0, #0
    4314:	f7ff fd66 	bl	3de4 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    4318:	2002      	movs	r0, #2
    431a:	f7ff fdcf 	bl	3ebc <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    431e:	4b55      	ldr	r3, [pc, #340]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4320:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4324:	4a53      	ldr	r2, [pc, #332]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4326:	f023 0301 	bic.w	r3, r3, #1
    432a:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    432e:	9b01      	ldr	r3, [sp, #4]
    4330:	889b      	ldrh	r3, [r3, #4]
    4332:	2b01      	cmp	r3, #1
    4334:	f040 8097 	bne.w	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    4338:	9b01      	ldr	r3, [sp, #4]
    433a:	79db      	ldrb	r3, [r3, #7]
    433c:	4a4d      	ldr	r2, [pc, #308]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    433e:	f003 0303 	and.w	r3, r3, #3
    4342:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    4346:	4b4b      	ldr	r3, [pc, #300]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4348:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    434c:	9b01      	ldr	r3, [sp, #4]
    434e:	799b      	ldrb	r3, [r3, #6]
    4350:	00db      	lsls	r3, r3, #3
    4352:	f003 0308 	and.w	r3, r3, #8
    4356:	4313      	orrs	r3, r2
    4358:	4a46      	ldr	r2, [pc, #280]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    435a:	f043 0301 	orr.w	r3, r3, #1
    435e:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4362:	aa03      	add	r2, sp, #12
    4364:	a904      	add	r1, sp, #16
    4366:	a805      	add	r0, sp, #20
    4368:	f24c 3350 	movw	r3, #50000	; 0xc350
    436c:	f7fe ff6e 	bl	324c <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4370:	4b40      	ldr	r3, [pc, #256]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4372:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4376:	0e1b      	lsrs	r3, r3, #24
    4378:	f003 0301 	and.w	r3, r3, #1
    437c:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    437e:	9a03      	ldr	r2, [sp, #12]
    4380:	a904      	add	r1, sp, #16
    4382:	ab05      	add	r3, sp, #20
    4384:	4618      	mov	r0, r3
    4386:	f7fe ff7b 	bl	3280 <Clock_Ip_TimeoutExpired>
    438a:	4603      	mov	r3, r0
    438c:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    4390:	9b06      	ldr	r3, [sp, #24]
    4392:	2b00      	cmp	r3, #0
    4394:	d106      	bne.n	43a4 <Clock_Ip_SetFirc_TrustedCall+0x114>
    4396:	f89d 301f 	ldrb.w	r3, [sp, #31]
    439a:	f083 0301 	eor.w	r3, r3, #1
    439e:	b2db      	uxtb	r3, r3
    43a0:	2b00      	cmp	r3, #0
    43a2:	d1e5      	bne.n	4370 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    43a4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    43a8:	2b00      	cmp	r3, #0
    43aa:	d005      	beq.n	43b8 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    43ac:	9b01      	ldr	r3, [sp, #4]
    43ae:	681b      	ldr	r3, [r3, #0]
    43b0:	4619      	mov	r1, r3
    43b2:	2001      	movs	r0, #1
    43b4:	f7fe ff3a 	bl	322c <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    43b8:	2003      	movs	r0, #3
    43ba:	f7ff fd7f 	bl	3ebc <SetInputSouceSytemClock>

                if (SircWasDisabled)
    43be:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    43c2:	2b00      	cmp	r3, #0
    43c4:	d04f      	beq.n	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    43c6:	2002      	movs	r0, #2
    43c8:	f7ff fd26 	bl	3e18 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    43cc:	e04b      	b.n	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    43ce:	4b29      	ldr	r3, [pc, #164]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    43d0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    43d4:	4a27      	ldr	r2, [pc, #156]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    43d6:	f023 0301 	bic.w	r3, r3, #1
    43da:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    43de:	9b01      	ldr	r3, [sp, #4]
    43e0:	889b      	ldrh	r3, [r3, #4]
    43e2:	2b01      	cmp	r3, #1
    43e4:	d13f      	bne.n	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    43e6:	9b01      	ldr	r3, [sp, #4]
    43e8:	79db      	ldrb	r3, [r3, #7]
    43ea:	4a22      	ldr	r2, [pc, #136]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    43ec:	f003 0303 	and.w	r3, r3, #3
    43f0:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    43f4:	4b1f      	ldr	r3, [pc, #124]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    43f6:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    43fa:	9b01      	ldr	r3, [sp, #4]
    43fc:	799b      	ldrb	r3, [r3, #6]
    43fe:	00db      	lsls	r3, r3, #3
    4400:	f003 0308 	and.w	r3, r3, #8
    4404:	4313      	orrs	r3, r2
    4406:	4a1b      	ldr	r2, [pc, #108]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4408:	f043 0301 	orr.w	r3, r3, #1
    440c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4410:	aa03      	add	r2, sp, #12
    4412:	a904      	add	r1, sp, #16
    4414:	a805      	add	r0, sp, #20
    4416:	f24c 3350 	movw	r3, #50000	; 0xc350
    441a:	f7fe ff17 	bl	324c <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    441e:	4b15      	ldr	r3, [pc, #84]	; (4474 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4420:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4424:	0e1b      	lsrs	r3, r3, #24
    4426:	f003 0301 	and.w	r3, r3, #1
    442a:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    442c:	9a03      	ldr	r2, [sp, #12]
    442e:	a904      	add	r1, sp, #16
    4430:	ab05      	add	r3, sp, #20
    4432:	4618      	mov	r0, r3
    4434:	f7fe ff24 	bl	3280 <Clock_Ip_TimeoutExpired>
    4438:	4603      	mov	r3, r0
    443a:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    443e:	9b06      	ldr	r3, [sp, #24]
    4440:	2b00      	cmp	r3, #0
    4442:	d106      	bne.n	4452 <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    4444:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4448:	f083 0301 	eor.w	r3, r3, #1
    444c:	b2db      	uxtb	r3, r3
    444e:	2b00      	cmp	r3, #0
    4450:	d1e5      	bne.n	441e <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    4452:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4456:	2b00      	cmp	r3, #0
    4458:	d005      	beq.n	4466 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    445a:	9b01      	ldr	r3, [sp, #4]
    445c:	681b      	ldr	r3, [r3, #0]
    445e:	4619      	mov	r1, r3
    4460:	2001      	movs	r0, #1
    4462:	f7fe fee3 	bl	322c <Clock_Ip_ReportClockErrors>
}
    4466:	bf00      	nop
    4468:	b00b      	add	sp, #44	; 0x2c
    446a:	f85d fb04 	ldr.w	pc, [sp], #4
    446e:	bf00      	nop
    4470:	0000fe24 	.word	0x0000fe24
    4474:	40064000 	.word	0x40064000

00004478 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4478:	b500      	push	{lr}
    447a:	b089      	sub	sp, #36	; 0x24
    447c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    447e:	2300      	movs	r3, #0
    4480:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    4484:	9b01      	ldr	r3, [sp, #4]
    4486:	889b      	ldrh	r3, [r3, #4]
    4488:	2b01      	cmp	r3, #1
    448a:	d132      	bne.n	44f2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    448c:	4b1b      	ldr	r3, [pc, #108]	; (44fc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    448e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4492:	4a1a      	ldr	r2, [pc, #104]	; (44fc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    4494:	f043 0301 	orr.w	r3, r3, #1
    4498:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    449c:	aa03      	add	r2, sp, #12
    449e:	a904      	add	r1, sp, #16
    44a0:	a805      	add	r0, sp, #20
    44a2:	f24c 3350 	movw	r3, #50000	; 0xc350
    44a6:	f7fe fed1 	bl	324c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    44aa:	4b14      	ldr	r3, [pc, #80]	; (44fc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    44ac:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    44b0:	0e1b      	lsrs	r3, r3, #24
    44b2:	f003 0301 	and.w	r3, r3, #1
    44b6:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    44b8:	9a03      	ldr	r2, [sp, #12]
    44ba:	a904      	add	r1, sp, #16
    44bc:	ab05      	add	r3, sp, #20
    44be:	4618      	mov	r0, r3
    44c0:	f7fe fede 	bl	3280 <Clock_Ip_TimeoutExpired>
    44c4:	4603      	mov	r3, r0
    44c6:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    44ca:	9b06      	ldr	r3, [sp, #24]
    44cc:	2b00      	cmp	r3, #0
    44ce:	d106      	bne.n	44de <Clock_Ip_EnableFirc_TrustedCall+0x66>
    44d0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    44d4:	f083 0301 	eor.w	r3, r3, #1
    44d8:	b2db      	uxtb	r3, r3
    44da:	2b00      	cmp	r3, #0
    44dc:	d1e5      	bne.n	44aa <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    44de:	f89d 301f 	ldrb.w	r3, [sp, #31]
    44e2:	2b00      	cmp	r3, #0
    44e4:	d005      	beq.n	44f2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    44e6:	9b01      	ldr	r3, [sp, #4]
    44e8:	681b      	ldr	r3, [r3, #0]
    44ea:	4619      	mov	r1, r3
    44ec:	2001      	movs	r0, #1
    44ee:	f7fe fe9d 	bl	322c <Clock_Ip_ReportClockErrors>
        }
    }
}
    44f2:	bf00      	nop
    44f4:	b009      	add	sp, #36	; 0x24
    44f6:	f85d fb04 	ldr.w	pc, [sp], #4
    44fa:	bf00      	nop
    44fc:	40064000 	.word	0x40064000

00004500 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    4500:	b082      	sub	sp, #8
    4502:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    4504:	4b05      	ldr	r3, [pc, #20]	; (451c <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    4506:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    450a:	4a04      	ldr	r2, [pc, #16]	; (451c <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    450c:	f023 0301 	bic.w	r3, r3, #1
    4510:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    4514:	bf00      	nop
    4516:	b002      	add	sp, #8
    4518:	4770      	bx	lr
    451a:	bf00      	nop
    451c:	40064000 	.word	0x40064000

00004520 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    4520:	b082      	sub	sp, #8
    4522:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4524:	bf00      	nop
    4526:	b002      	add	sp, #8
    4528:	4770      	bx	lr

0000452a <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    452a:	b082      	sub	sp, #8
    452c:	9001      	str	r0, [sp, #4]
    452e:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    4530:	bf00      	nop
    4532:	b002      	add	sp, #8
    4534:	4770      	bx	lr

00004536 <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    4536:	b082      	sub	sp, #8
    4538:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    453a:	bf00      	nop
    453c:	b002      	add	sp, #8
    453e:	4770      	bx	lr

00004540 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    4540:	b082      	sub	sp, #8
    4542:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4544:	bf00      	nop
    4546:	b002      	add	sp, #8
    4548:	4770      	bx	lr

0000454a <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    454a:	b082      	sub	sp, #8
    454c:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    454e:	2302      	movs	r3, #2
}
    4550:	4618      	mov	r0, r3
    4552:	b002      	add	sp, #8
    4554:	4770      	bx	lr

00004556 <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    4556:	b082      	sub	sp, #8
    4558:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    455a:	bf00      	nop
    455c:	b002      	add	sp, #8
    455e:	4770      	bx	lr

00004560 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    4560:	b500      	push	{lr}
    4562:	b083      	sub	sp, #12
    4564:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4566:	9b01      	ldr	r3, [sp, #4]
    4568:	2b00      	cmp	r3, #0
    456a:	d002      	beq.n	4572 <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    456c:	9801      	ldr	r0, [sp, #4]
    456e:	f000 f870 	bl	4652 <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4572:	bf00      	nop
    4574:	b003      	add	sp, #12
    4576:	f85d fb04 	ldr.w	pc, [sp], #4

0000457a <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    457a:	b500      	push	{lr}
    457c:	b083      	sub	sp, #12
    457e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4580:	9b01      	ldr	r3, [sp, #4]
    4582:	2b00      	cmp	r3, #0
    4584:	d002      	beq.n	458c <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    4586:	9801      	ldr	r0, [sp, #4]
    4588:	f000 f89a 	bl	46c0 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    458c:	bf00      	nop
    458e:	b003      	add	sp, #12
    4590:	f85d fb04 	ldr.w	pc, [sp], #4

00004594 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    4594:	b500      	push	{lr}
    4596:	b089      	sub	sp, #36	; 0x24
    4598:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    459a:	2301      	movs	r3, #1
    459c:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    459e:	2300      	movs	r3, #0
    45a0:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    45a4:	4b1e      	ldr	r3, [pc, #120]	; (4620 <Clock_Ip_CompleteSpll+0x8c>)
    45a6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    45aa:	f003 0301 	and.w	r3, r3, #1
    45ae:	2b00      	cmp	r3, #0
    45b0:	d02f      	beq.n	4612 <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    45b2:	aa02      	add	r2, sp, #8
    45b4:	a903      	add	r1, sp, #12
    45b6:	a804      	add	r0, sp, #16
    45b8:	f24c 3350 	movw	r3, #50000	; 0xc350
    45bc:	f7fe fe46 	bl	324c <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    45c0:	4b17      	ldr	r3, [pc, #92]	; (4620 <Clock_Ip_CompleteSpll+0x8c>)
    45c2:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    45c6:	0e1b      	lsrs	r3, r3, #24
    45c8:	f003 0301 	and.w	r3, r3, #1
    45cc:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    45ce:	9a02      	ldr	r2, [sp, #8]
    45d0:	a903      	add	r1, sp, #12
    45d2:	ab04      	add	r3, sp, #16
    45d4:	4618      	mov	r0, r3
    45d6:	f7fe fe53 	bl	3280 <Clock_Ip_TimeoutExpired>
    45da:	4603      	mov	r3, r0
    45dc:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    45e0:	9b05      	ldr	r3, [sp, #20]
    45e2:	2b00      	cmp	r3, #0
    45e4:	d106      	bne.n	45f4 <Clock_Ip_CompleteSpll+0x60>
    45e6:	f89d 301b 	ldrb.w	r3, [sp, #27]
    45ea:	f083 0301 	eor.w	r3, r3, #1
    45ee:	b2db      	uxtb	r3, r3
    45f0:	2b00      	cmp	r3, #0
    45f2:	d1e5      	bne.n	45c0 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    45f4:	f89d 301b 	ldrb.w	r3, [sp, #27]
    45f8:	f083 0301 	eor.w	r3, r3, #1
    45fc:	b2db      	uxtb	r3, r3
    45fe:	2b00      	cmp	r3, #0
    4600:	d002      	beq.n	4608 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    4602:	2302      	movs	r3, #2
    4604:	9307      	str	r3, [sp, #28]
    4606:	e006      	b.n	4616 <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    4608:	9901      	ldr	r1, [sp, #4]
    460a:	2001      	movs	r0, #1
    460c:	f7fe fe0e 	bl	322c <Clock_Ip_ReportClockErrors>
    4610:	e001      	b.n	4616 <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    4612:	2300      	movs	r3, #0
    4614:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    4616:	9b07      	ldr	r3, [sp, #28]
}
    4618:	4618      	mov	r0, r3
    461a:	b009      	add	sp, #36	; 0x24
    461c:	f85d fb04 	ldr.w	pc, [sp], #4
    4620:	40064000 	.word	0x40064000

00004624 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    4624:	b500      	push	{lr}
    4626:	b083      	sub	sp, #12
    4628:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    462a:	9801      	ldr	r0, [sp, #4]
    462c:	f000 f886 	bl	473c <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    4630:	bf00      	nop
    4632:	b003      	add	sp, #12
    4634:	f85d fb04 	ldr.w	pc, [sp], #4

00004638 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    4638:	b500      	push	{lr}
    463a:	b083      	sub	sp, #12
    463c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    463e:	9b01      	ldr	r3, [sp, #4]
    4640:	2b00      	cmp	r3, #0
    4642:	d002      	beq.n	464a <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    4644:	9801      	ldr	r0, [sp, #4]
    4646:	f000 f891 	bl	476c <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    464a:	bf00      	nop
    464c:	b003      	add	sp, #12
    464e:	f85d fb04 	ldr.w	pc, [sp], #4

00004652 <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4652:	b082      	sub	sp, #8
    4654:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4656:	4b19      	ldr	r3, [pc, #100]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4658:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    465c:	4a17      	ldr	r2, [pc, #92]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    465e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4662:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    4666:	4b15      	ldr	r3, [pc, #84]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4668:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    466c:	4a13      	ldr	r2, [pc, #76]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    466e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    4672:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    4676:	4b11      	ldr	r3, [pc, #68]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4678:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    467c:	4a0f      	ldr	r2, [pc, #60]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    467e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    4682:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4686:	4b0d      	ldr	r3, [pc, #52]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4688:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    468c:	4a0b      	ldr	r2, [pc, #44]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    468e:	f023 0301 	bic.w	r3, r3, #1
    4692:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    4696:	4b09      	ldr	r3, [pc, #36]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4698:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    469c:	4a07      	ldr	r2, [pc, #28]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    469e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    46a2:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    46a6:	4b05      	ldr	r3, [pc, #20]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    46a8:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    46ac:	4a03      	ldr	r2, [pc, #12]	; (46bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    46ae:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    46b2:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    46b6:	bf00      	nop
    46b8:	b002      	add	sp, #8
    46ba:	4770      	bx	lr
    46bc:	40064000 	.word	0x40064000

000046c0 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    46c0:	b082      	sub	sp, #8
    46c2:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    46c4:	9b01      	ldr	r3, [sp, #4]
    46c6:	889b      	ldrh	r3, [r3, #4]
    46c8:	2b01      	cmp	r3, #1
    46ca:	d12f      	bne.n	472c <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    46cc:	4b1a      	ldr	r3, [pc, #104]	; (4738 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    46ce:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    46d2:	9b01      	ldr	r3, [sp, #4]
    46d4:	7b5b      	ldrb	r3, [r3, #13]
    46d6:	3b01      	subs	r3, #1
    46d8:	021b      	lsls	r3, r3, #8
    46da:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    46de:	9b01      	ldr	r3, [sp, #4]
    46e0:	7d1b      	ldrb	r3, [r3, #20]
    46e2:	3b10      	subs	r3, #16
    46e4:	041b      	lsls	r3, r3, #16
    46e6:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    46ea:	430b      	orrs	r3, r1
    46ec:	4912      	ldr	r1, [pc, #72]	; (4738 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    46ee:	4313      	orrs	r3, r2
    46f0:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    46f4:	9b01      	ldr	r3, [sp, #4]
    46f6:	7fdb      	ldrb	r3, [r3, #31]
    46f8:	2b02      	cmp	r3, #2
    46fa:	d011      	beq.n	4720 <Clock_Ip_SetSpll_TrustedCall+0x60>
    46fc:	2b02      	cmp	r3, #2
    46fe:	dc17      	bgt.n	4730 <Clock_Ip_SetSpll_TrustedCall+0x70>
    4700:	2b00      	cmp	r3, #0
    4702:	d002      	beq.n	470a <Clock_Ip_SetSpll_TrustedCall+0x4a>
    4704:	2b01      	cmp	r3, #1
    4706:	d005      	beq.n	4714 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    4708:	e012      	b.n	4730 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    470a:	4b0b      	ldr	r3, [pc, #44]	; (4738 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    470c:	2200      	movs	r2, #0
    470e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4712:	e00e      	b.n	4732 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4714:	4b08      	ldr	r3, [pc, #32]	; (4738 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4716:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    471a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    471e:	e008      	b.n	4732 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4720:	4b05      	ldr	r3, [pc, #20]	; (4738 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4722:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    4726:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    472a:	e002      	b.n	4732 <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    472c:	bf00      	nop
    472e:	e000      	b.n	4732 <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    4730:	bf00      	nop
}
    4732:	bf00      	nop
    4734:	b002      	add	sp, #8
    4736:	4770      	bx	lr
    4738:	40064000 	.word	0x40064000

0000473c <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    473c:	b082      	sub	sp, #8
    473e:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4740:	4b09      	ldr	r3, [pc, #36]	; (4768 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4742:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4746:	4a08      	ldr	r2, [pc, #32]	; (4768 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4748:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    474c:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4750:	4b05      	ldr	r3, [pc, #20]	; (4768 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4752:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4756:	4a04      	ldr	r2, [pc, #16]	; (4768 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4758:	f023 0301 	bic.w	r3, r3, #1
    475c:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    4760:	bf00      	nop
    4762:	b002      	add	sp, #8
    4764:	4770      	bx	lr
    4766:	bf00      	nop
    4768:	40064000 	.word	0x40064000

0000476c <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    476c:	b082      	sub	sp, #8
    476e:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    4770:	9b01      	ldr	r3, [sp, #4]
    4772:	889b      	ldrh	r3, [r3, #4]
    4774:	2b01      	cmp	r3, #1
    4776:	d107      	bne.n	4788 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    4778:	4b05      	ldr	r3, [pc, #20]	; (4790 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    477a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    477e:	4a04      	ldr	r2, [pc, #16]	; (4790 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    4780:	f043 0301 	orr.w	r3, r3, #1
    4784:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    4788:	bf00      	nop
    478a:	b002      	add	sp, #8
    478c:	4770      	bx	lr
    478e:	bf00      	nop
    4790:	40064000 	.word	0x40064000

00004794 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    4794:	b082      	sub	sp, #8
    4796:	9001      	str	r0, [sp, #4]
    4798:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    479a:	bf00      	nop
    479c:	b002      	add	sp, #8
    479e:	4770      	bx	lr

000047a0 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    47a0:	b082      	sub	sp, #8
    47a2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    47a4:	bf00      	nop
    47a6:	b002      	add	sp, #8
    47a8:	4770      	bx	lr

000047aa <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    47aa:	b500      	push	{lr}
    47ac:	b083      	sub	sp, #12
    47ae:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    47b0:	9b01      	ldr	r3, [sp, #4]
    47b2:	2b00      	cmp	r3, #0
    47b4:	d002      	beq.n	47bc <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    47b6:	9801      	ldr	r0, [sp, #4]
    47b8:	f000 f8ee 	bl	4998 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    47bc:	bf00      	nop
    47be:	b003      	add	sp, #12
    47c0:	f85d fb04 	ldr.w	pc, [sp], #4

000047c4 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    47c4:	b500      	push	{lr}
    47c6:	b083      	sub	sp, #12
    47c8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    47ca:	9b01      	ldr	r3, [sp, #4]
    47cc:	2b00      	cmp	r3, #0
    47ce:	d002      	beq.n	47d6 <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    47d0:	9801      	ldr	r0, [sp, #4]
    47d2:	f000 f8ff 	bl	49d4 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    47d6:	bf00      	nop
    47d8:	b003      	add	sp, #12
    47da:	f85d fb04 	ldr.w	pc, [sp], #4

000047de <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    47de:	b500      	push	{lr}
    47e0:	b083      	sub	sp, #12
    47e2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    47e4:	9b01      	ldr	r3, [sp, #4]
    47e6:	2b00      	cmp	r3, #0
    47e8:	d002      	beq.n	47f0 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    47ea:	9801      	ldr	r0, [sp, #4]
    47ec:	f000 f912 	bl	4a14 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    47f0:	bf00      	nop
    47f2:	b003      	add	sp, #12
    47f4:	f85d fb04 	ldr.w	pc, [sp], #4

000047f8 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    47f8:	b500      	push	{lr}
    47fa:	b083      	sub	sp, #12
    47fc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    47fe:	9b01      	ldr	r3, [sp, #4]
    4800:	2b00      	cmp	r3, #0
    4802:	d002      	beq.n	480a <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    4804:	9801      	ldr	r0, [sp, #4]
    4806:	f000 f925 	bl	4a54 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    480a:	bf00      	nop
    480c:	b003      	add	sp, #12
    480e:	f85d fb04 	ldr.w	pc, [sp], #4

00004812 <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4812:	b500      	push	{lr}
    4814:	b083      	sub	sp, #12
    4816:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4818:	9b01      	ldr	r3, [sp, #4]
    481a:	2b00      	cmp	r3, #0
    481c:	d002      	beq.n	4824 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    481e:	9801      	ldr	r0, [sp, #4]
    4820:	f000 f936 	bl	4a90 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4824:	bf00      	nop
    4826:	b003      	add	sp, #12
    4828:	f85d fb04 	ldr.w	pc, [sp], #4

0000482c <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    482c:	b500      	push	{lr}
    482e:	b083      	sub	sp, #12
    4830:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4832:	9b01      	ldr	r3, [sp, #4]
    4834:	2b00      	cmp	r3, #0
    4836:	d002      	beq.n	483e <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    4838:	9801      	ldr	r0, [sp, #4]
    483a:	f000 f949 	bl	4ad0 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    483e:	bf00      	nop
    4840:	b003      	add	sp, #12
    4842:	f85d fb04 	ldr.w	pc, [sp], #4

00004846 <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    4846:	b500      	push	{lr}
    4848:	b083      	sub	sp, #12
    484a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    484c:	9b01      	ldr	r3, [sp, #4]
    484e:	2b00      	cmp	r3, #0
    4850:	d002      	beq.n	4858 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    4852:	9801      	ldr	r0, [sp, #4]
    4854:	f000 f958 	bl	4b08 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4858:	bf00      	nop
    485a:	b003      	add	sp, #12
    485c:	f85d fb04 	ldr.w	pc, [sp], #4

00004860 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    4860:	b500      	push	{lr}
    4862:	b083      	sub	sp, #12
    4864:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4866:	9b01      	ldr	r3, [sp, #4]
    4868:	2b00      	cmp	r3, #0
    486a:	d002      	beq.n	4872 <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    486c:	9801      	ldr	r0, [sp, #4]
    486e:	f000 f969 	bl	4b44 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4872:	bf00      	nop
    4874:	b003      	add	sp, #12
    4876:	f85d fb04 	ldr.w	pc, [sp], #4

0000487a <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    487a:	b500      	push	{lr}
    487c:	b083      	sub	sp, #12
    487e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4880:	9b01      	ldr	r3, [sp, #4]
    4882:	2b00      	cmp	r3, #0
    4884:	d002      	beq.n	488c <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    4886:	9801      	ldr	r0, [sp, #4]
    4888:	f000 f978 	bl	4b7c <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    488c:	bf00      	nop
    488e:	b003      	add	sp, #12
    4890:	f85d fb04 	ldr.w	pc, [sp], #4

00004894 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4894:	b500      	push	{lr}
    4896:	b083      	sub	sp, #12
    4898:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    489a:	9b01      	ldr	r3, [sp, #4]
    489c:	2b00      	cmp	r3, #0
    489e:	d002      	beq.n	48a6 <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    48a0:	9801      	ldr	r0, [sp, #4]
    48a2:	f000 f989 	bl	4bb8 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    48a6:	bf00      	nop
    48a8:	b003      	add	sp, #12
    48aa:	f85d fb04 	ldr.w	pc, [sp], #4

000048ae <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    48ae:	b500      	push	{lr}
    48b0:	b083      	sub	sp, #12
    48b2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    48b4:	9b01      	ldr	r3, [sp, #4]
    48b6:	2b00      	cmp	r3, #0
    48b8:	d002      	beq.n	48c0 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    48ba:	9801      	ldr	r0, [sp, #4]
    48bc:	f000 f998 	bl	4bf0 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    48c0:	bf00      	nop
    48c2:	b003      	add	sp, #12
    48c4:	f85d fb04 	ldr.w	pc, [sp], #4

000048c8 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    48c8:	b500      	push	{lr}
    48ca:	b083      	sub	sp, #12
    48cc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    48ce:	9b01      	ldr	r3, [sp, #4]
    48d0:	2b00      	cmp	r3, #0
    48d2:	d002      	beq.n	48da <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    48d4:	9801      	ldr	r0, [sp, #4]
    48d6:	f000 f9a9 	bl	4c2c <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    48da:	bf00      	nop
    48dc:	b003      	add	sp, #12
    48de:	f85d fb04 	ldr.w	pc, [sp], #4

000048e2 <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    48e2:	b500      	push	{lr}
    48e4:	b083      	sub	sp, #12
    48e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    48e8:	9b01      	ldr	r3, [sp, #4]
    48ea:	2b00      	cmp	r3, #0
    48ec:	d002      	beq.n	48f4 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    48ee:	9801      	ldr	r0, [sp, #4]
    48f0:	f000 f9e6 	bl	4cc0 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    48f4:	bf00      	nop
    48f6:	b003      	add	sp, #12
    48f8:	f85d fb04 	ldr.w	pc, [sp], #4

000048fc <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    48fc:	b500      	push	{lr}
    48fe:	b083      	sub	sp, #12
    4900:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4902:	9b01      	ldr	r3, [sp, #4]
    4904:	2b00      	cmp	r3, #0
    4906:	d002      	beq.n	490e <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    4908:	9801      	ldr	r0, [sp, #4]
    490a:	f000 fa25 	bl	4d58 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    490e:	bf00      	nop
    4910:	b003      	add	sp, #12
    4912:	f85d fb04 	ldr.w	pc, [sp], #4

00004916 <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4916:	b500      	push	{lr}
    4918:	b083      	sub	sp, #12
    491a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    491c:	9b01      	ldr	r3, [sp, #4]
    491e:	2b00      	cmp	r3, #0
    4920:	d002      	beq.n	4928 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    4922:	9801      	ldr	r0, [sp, #4]
    4924:	f000 fa2a 	bl	4d7c <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4928:	bf00      	nop
    492a:	b003      	add	sp, #12
    492c:	f85d fb04 	ldr.w	pc, [sp], #4

00004930 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    4930:	b500      	push	{lr}
    4932:	b083      	sub	sp, #12
    4934:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4936:	9b01      	ldr	r3, [sp, #4]
    4938:	2b00      	cmp	r3, #0
    493a:	d002      	beq.n	4942 <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    493c:	9801      	ldr	r0, [sp, #4]
    493e:	f000 fa3b 	bl	4db8 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4942:	bf00      	nop
    4944:	b003      	add	sp, #12
    4946:	f85d fb04 	ldr.w	pc, [sp], #4

0000494a <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    494a:	b500      	push	{lr}
    494c:	b083      	sub	sp, #12
    494e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4950:	9b01      	ldr	r3, [sp, #4]
    4952:	2b00      	cmp	r3, #0
    4954:	d002      	beq.n	495c <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    4956:	9801      	ldr	r0, [sp, #4]
    4958:	f000 fa56 	bl	4e08 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    495c:	bf00      	nop
    495e:	b003      	add	sp, #12
    4960:	f85d fb04 	ldr.w	pc, [sp], #4

00004964 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    4964:	b500      	push	{lr}
    4966:	b083      	sub	sp, #12
    4968:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    496a:	9b01      	ldr	r3, [sp, #4]
    496c:	2b00      	cmp	r3, #0
    496e:	d002      	beq.n	4976 <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    4970:	9801      	ldr	r0, [sp, #4]
    4972:	f000 fa79 	bl	4e68 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4976:	bf00      	nop
    4978:	b003      	add	sp, #12
    497a:	f85d fb04 	ldr.w	pc, [sp], #4

0000497e <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    497e:	b500      	push	{lr}
    4980:	b083      	sub	sp, #12
    4982:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4984:	9b01      	ldr	r3, [sp, #4]
    4986:	2b00      	cmp	r3, #0
    4988:	d002      	beq.n	4990 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    498a:	9801      	ldr	r0, [sp, #4]
    498c:	f000 fa8a 	bl	4ea4 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4990:	bf00      	nop
    4992:	b003      	add	sp, #12
    4994:	f85d fb04 	ldr.w	pc, [sp], #4

00004998 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4998:	b084      	sub	sp, #16
    499a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    499c:	4b0b      	ldr	r3, [pc, #44]	; (49cc <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    499e:	795b      	ldrb	r3, [r3, #5]
    49a0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    49a2:	4b0b      	ldr	r3, [pc, #44]	; (49d0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    49a4:	695b      	ldr	r3, [r3, #20]
    49a6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    49a8:	9b02      	ldr	r3, [sp, #8]
    49aa:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    49ae:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    49b0:	9b03      	ldr	r3, [sp, #12]
    49b2:	061b      	lsls	r3, r3, #24
    49b4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    49b8:	9a02      	ldr	r2, [sp, #8]
    49ba:	4313      	orrs	r3, r2
    49bc:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    49be:	4a04      	ldr	r2, [pc, #16]	; (49d0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    49c0:	9b02      	ldr	r3, [sp, #8]
    49c2:	6153      	str	r3, [r2, #20]
}
    49c4:	bf00      	nop
    49c6:	b004      	add	sp, #16
    49c8:	4770      	bx	lr
    49ca:	bf00      	nop
    49cc:	0001018c 	.word	0x0001018c
    49d0:	40064000 	.word	0x40064000

000049d4 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    49d4:	b084      	sub	sp, #16
    49d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    49d8:	9b01      	ldr	r3, [sp, #4]
    49da:	685b      	ldr	r3, [r3, #4]
    49dc:	4a0b      	ldr	r2, [pc, #44]	; (4a0c <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    49de:	5cd3      	ldrb	r3, [r2, r3]
    49e0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    49e2:	4b0b      	ldr	r3, [pc, #44]	; (4a10 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    49e4:	695b      	ldr	r3, [r3, #20]
    49e6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    49e8:	9b02      	ldr	r3, [sp, #8]
    49ea:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    49ee:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    49f0:	9b03      	ldr	r3, [sp, #12]
    49f2:	061b      	lsls	r3, r3, #24
    49f4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    49f8:	9a02      	ldr	r2, [sp, #8]
    49fa:	4313      	orrs	r3, r2
    49fc:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    49fe:	4a04      	ldr	r2, [pc, #16]	; (4a10 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    4a00:	9b02      	ldr	r3, [sp, #8]
    4a02:	6153      	str	r3, [r2, #20]
}
    4a04:	bf00      	nop
    4a06:	b004      	add	sp, #16
    4a08:	4770      	bx	lr
    4a0a:	bf00      	nop
    4a0c:	0001018c 	.word	0x0001018c
    4a10:	40064000 	.word	0x40064000

00004a14 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a14:	b084      	sub	sp, #16
    4a16:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4a18:	9b01      	ldr	r3, [sp, #4]
    4a1a:	685b      	ldr	r3, [r3, #4]
    4a1c:	4a0b      	ldr	r2, [pc, #44]	; (4a4c <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    4a1e:	5cd3      	ldrb	r3, [r2, r3]
    4a20:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    4a22:	4b0b      	ldr	r3, [pc, #44]	; (4a50 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    4a24:	699b      	ldr	r3, [r3, #24]
    4a26:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    4a28:	9b02      	ldr	r3, [sp, #8]
    4a2a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4a2e:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    4a30:	9b03      	ldr	r3, [sp, #12]
    4a32:	061b      	lsls	r3, r3, #24
    4a34:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4a38:	9a02      	ldr	r2, [sp, #8]
    4a3a:	4313      	orrs	r3, r2
    4a3c:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    4a3e:	4a04      	ldr	r2, [pc, #16]	; (4a50 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    4a40:	9b02      	ldr	r3, [sp, #8]
    4a42:	6193      	str	r3, [r2, #24]
}
    4a44:	bf00      	nop
    4a46:	b004      	add	sp, #16
    4a48:	4770      	bx	lr
    4a4a:	bf00      	nop
    4a4c:	0001018c 	.word	0x0001018c
    4a50:	40064000 	.word	0x40064000

00004a54 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a54:	b084      	sub	sp, #16
    4a56:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4a58:	4b0b      	ldr	r3, [pc, #44]	; (4a88 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    4a5a:	795b      	ldrb	r3, [r3, #5]
    4a5c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    4a5e:	4b0b      	ldr	r3, [pc, #44]	; (4a8c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    4a60:	69db      	ldr	r3, [r3, #28]
    4a62:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4a64:	9b02      	ldr	r3, [sp, #8]
    4a66:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4a6a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4a6c:	9b03      	ldr	r3, [sp, #12]
    4a6e:	061b      	lsls	r3, r3, #24
    4a70:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4a74:	9a02      	ldr	r2, [sp, #8]
    4a76:	4313      	orrs	r3, r2
    4a78:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    4a7a:	4a04      	ldr	r2, [pc, #16]	; (4a8c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    4a7c:	9b02      	ldr	r3, [sp, #8]
    4a7e:	61d3      	str	r3, [r2, #28]
}
    4a80:	bf00      	nop
    4a82:	b004      	add	sp, #16
    4a84:	4770      	bx	lr
    4a86:	bf00      	nop
    4a88:	0001018c 	.word	0x0001018c
    4a8c:	40064000 	.word	0x40064000

00004a90 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a90:	b084      	sub	sp, #16
    4a92:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4a94:	9b01      	ldr	r3, [sp, #4]
    4a96:	685b      	ldr	r3, [r3, #4]
    4a98:	4a0b      	ldr	r2, [pc, #44]	; (4ac8 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    4a9a:	5cd3      	ldrb	r3, [r2, r3]
    4a9c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    4a9e:	4b0b      	ldr	r3, [pc, #44]	; (4acc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    4aa0:	69db      	ldr	r3, [r3, #28]
    4aa2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4aa4:	9b02      	ldr	r3, [sp, #8]
    4aa6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4aaa:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4aac:	9b03      	ldr	r3, [sp, #12]
    4aae:	061b      	lsls	r3, r3, #24
    4ab0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4ab4:	9a02      	ldr	r2, [sp, #8]
    4ab6:	4313      	orrs	r3, r2
    4ab8:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    4aba:	4a04      	ldr	r2, [pc, #16]	; (4acc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    4abc:	9b02      	ldr	r3, [sp, #8]
    4abe:	61d3      	str	r3, [r2, #28]
}
    4ac0:	bf00      	nop
    4ac2:	b004      	add	sp, #16
    4ac4:	4770      	bx	lr
    4ac6:	bf00      	nop
    4ac8:	0001018c 	.word	0x0001018c
    4acc:	40064000 	.word	0x40064000

00004ad0 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4ad0:	b084      	sub	sp, #16
    4ad2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4ad4:	4b0a      	ldr	r3, [pc, #40]	; (4b00 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    4ad6:	7b9b      	ldrb	r3, [r3, #14]
    4ad8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4ada:	4b0a      	ldr	r3, [pc, #40]	; (4b04 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4adc:	691b      	ldr	r3, [r3, #16]
    4ade:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    4ae0:	9b02      	ldr	r3, [sp, #8]
    4ae2:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4ae6:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4ae8:	9b03      	ldr	r3, [sp, #12]
    4aea:	011b      	lsls	r3, r3, #4
    4aec:	9a02      	ldr	r2, [sp, #8]
    4aee:	4313      	orrs	r3, r2
    4af0:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4af2:	4a04      	ldr	r2, [pc, #16]	; (4b04 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4af4:	9b02      	ldr	r3, [sp, #8]
    4af6:	6113      	str	r3, [r2, #16]
}
    4af8:	bf00      	nop
    4afa:	b004      	add	sp, #16
    4afc:	4770      	bx	lr
    4afe:	bf00      	nop
    4b00:	00010134 	.word	0x00010134
    4b04:	40048000 	.word	0x40048000

00004b08 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4b08:	b084      	sub	sp, #16
    4b0a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4b0c:	9b01      	ldr	r3, [sp, #4]
    4b0e:	685b      	ldr	r3, [r3, #4]
    4b10:	4a0a      	ldr	r2, [pc, #40]	; (4b3c <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    4b12:	5cd3      	ldrb	r3, [r2, r3]
    4b14:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    4b16:	4b0a      	ldr	r3, [pc, #40]	; (4b40 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    4b18:	691b      	ldr	r3, [r3, #16]
    4b1a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    4b1c:	9b02      	ldr	r3, [sp, #8]
    4b1e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4b22:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4b24:	9b03      	ldr	r3, [sp, #12]
    4b26:	011b      	lsls	r3, r3, #4
    4b28:	9a02      	ldr	r2, [sp, #8]
    4b2a:	4313      	orrs	r3, r2
    4b2c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4b2e:	4a04      	ldr	r2, [pc, #16]	; (4b40 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    4b30:	9b02      	ldr	r3, [sp, #8]
    4b32:	6113      	str	r3, [r2, #16]
}
    4b34:	bf00      	nop
    4b36:	b004      	add	sp, #16
    4b38:	4770      	bx	lr
    4b3a:	bf00      	nop
    4b3c:	00010134 	.word	0x00010134
    4b40:	40048000 	.word	0x40048000

00004b44 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4b44:	b084      	sub	sp, #16
    4b46:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4b48:	4b0a      	ldr	r3, [pc, #40]	; (4b74 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    4b4a:	785b      	ldrb	r3, [r3, #1]
    4b4c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4b4e:	4b0a      	ldr	r3, [pc, #40]	; (4b78 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    4b50:	691b      	ldr	r3, [r3, #16]
    4b52:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    4b54:	9b02      	ldr	r3, [sp, #8]
    4b56:	f023 030c 	bic.w	r3, r3, #12
    4b5a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4b5c:	9b03      	ldr	r3, [sp, #12]
    4b5e:	009b      	lsls	r3, r3, #2
    4b60:	9a02      	ldr	r2, [sp, #8]
    4b62:	4313      	orrs	r3, r2
    4b64:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4b66:	4a04      	ldr	r2, [pc, #16]	; (4b78 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    4b68:	9b02      	ldr	r3, [sp, #8]
    4b6a:	6113      	str	r3, [r2, #16]
}
    4b6c:	bf00      	nop
    4b6e:	b004      	add	sp, #16
    4b70:	4770      	bx	lr
    4b72:	bf00      	nop
    4b74:	000101ec 	.word	0x000101ec
    4b78:	40048000 	.word	0x40048000

00004b7c <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4b7c:	b084      	sub	sp, #16
    4b7e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4b80:	9b01      	ldr	r3, [sp, #4]
    4b82:	685b      	ldr	r3, [r3, #4]
    4b84:	4a0a      	ldr	r2, [pc, #40]	; (4bb0 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    4b86:	5cd3      	ldrb	r3, [r2, r3]
    4b88:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4b8a:	4b0a      	ldr	r3, [pc, #40]	; (4bb4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    4b8c:	691b      	ldr	r3, [r3, #16]
    4b8e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    4b90:	9b02      	ldr	r3, [sp, #8]
    4b92:	f023 030c 	bic.w	r3, r3, #12
    4b96:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4b98:	9b03      	ldr	r3, [sp, #12]
    4b9a:	009b      	lsls	r3, r3, #2
    4b9c:	9a02      	ldr	r2, [sp, #8]
    4b9e:	4313      	orrs	r3, r2
    4ba0:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4ba2:	4a04      	ldr	r2, [pc, #16]	; (4bb4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    4ba4:	9b02      	ldr	r3, [sp, #8]
    4ba6:	6113      	str	r3, [r2, #16]
}
    4ba8:	bf00      	nop
    4baa:	b004      	add	sp, #16
    4bac:	4770      	bx	lr
    4bae:	bf00      	nop
    4bb0:	000101ec 	.word	0x000101ec
    4bb4:	40048000 	.word	0x40048000

00004bb8 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4bb8:	b084      	sub	sp, #16
    4bba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4bbc:	4b0a      	ldr	r3, [pc, #40]	; (4be8 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    4bbe:	795b      	ldrb	r3, [r3, #5]
    4bc0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    4bc2:	4b0a      	ldr	r3, [pc, #40]	; (4bec <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    4bc4:	6a1b      	ldr	r3, [r3, #32]
    4bc6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    4bc8:	9b02      	ldr	r3, [sp, #8]
    4bca:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4bce:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    4bd0:	9b03      	ldr	r3, [sp, #12]
    4bd2:	061b      	lsls	r3, r3, #24
    4bd4:	9a02      	ldr	r2, [sp, #8]
    4bd6:	4313      	orrs	r3, r2
    4bd8:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    4bda:	4a04      	ldr	r2, [pc, #16]	; (4bec <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    4bdc:	9b02      	ldr	r3, [sp, #8]
    4bde:	6213      	str	r3, [r2, #32]
}
    4be0:	bf00      	nop
    4be2:	b004      	add	sp, #16
    4be4:	4770      	bx	lr
    4be6:	bf00      	nop
    4be8:	0001018c 	.word	0x0001018c
    4bec:	40064000 	.word	0x40064000

00004bf0 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4bf0:	b084      	sub	sp, #16
    4bf2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4bf4:	9b01      	ldr	r3, [sp, #4]
    4bf6:	685b      	ldr	r3, [r3, #4]
    4bf8:	4a0a      	ldr	r2, [pc, #40]	; (4c24 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    4bfa:	5cd3      	ldrb	r3, [r2, r3]
    4bfc:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    4bfe:	4b0a      	ldr	r3, [pc, #40]	; (4c28 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    4c00:	6a1b      	ldr	r3, [r3, #32]
    4c02:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    4c04:	9b02      	ldr	r3, [sp, #8]
    4c06:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4c0a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    4c0c:	9b03      	ldr	r3, [sp, #12]
    4c0e:	061b      	lsls	r3, r3, #24
    4c10:	9a02      	ldr	r2, [sp, #8]
    4c12:	4313      	orrs	r3, r2
    4c14:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    4c16:	4a04      	ldr	r2, [pc, #16]	; (4c28 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    4c18:	9b02      	ldr	r3, [sp, #8]
    4c1a:	6213      	str	r3, [r2, #32]
}
    4c1c:	bf00      	nop
    4c1e:	b004      	add	sp, #16
    4c20:	4770      	bx	lr
    4c22:	bf00      	nop
    4c24:	0001018c 	.word	0x0001018c
    4c28:	40064000 	.word	0x40064000

00004c2c <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4c2c:	b086      	sub	sp, #24
    4c2e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4c30:	4b20      	ldr	r3, [pc, #128]	; (4cb4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    4c32:	795b      	ldrb	r3, [r3, #5]
    4c34:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    4c36:	9b01      	ldr	r3, [sp, #4]
    4c38:	681a      	ldr	r2, [r3, #0]
    4c3a:	491f      	ldr	r1, [pc, #124]	; (4cb8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    4c3c:	4613      	mov	r3, r2
    4c3e:	00db      	lsls	r3, r3, #3
    4c40:	4413      	add	r3, r2
    4c42:	440b      	add	r3, r1
    4c44:	781b      	ldrb	r3, [r3, #0]
    4c46:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    4c48:	4b1c      	ldr	r3, [pc, #112]	; (4cbc <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    4c4a:	68db      	ldr	r3, [r3, #12]
    4c4c:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    4c4e:	9b03      	ldr	r3, [sp, #12]
    4c50:	2b03      	cmp	r3, #3
    4c52:	d813      	bhi.n	4c7c <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4c54:	9b03      	ldr	r3, [sp, #12]
    4c56:	005b      	lsls	r3, r3, #1
    4c58:	3318      	adds	r3, #24
    4c5a:	2203      	movs	r2, #3
    4c5c:	fa02 f303 	lsl.w	r3, r2, r3
    4c60:	43db      	mvns	r3, r3
    4c62:	9a05      	ldr	r2, [sp, #20]
    4c64:	4013      	ands	r3, r2
    4c66:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4c68:	9b03      	ldr	r3, [sp, #12]
    4c6a:	005b      	lsls	r3, r3, #1
    4c6c:	3318      	adds	r3, #24
    4c6e:	9a04      	ldr	r2, [sp, #16]
    4c70:	fa02 f303 	lsl.w	r3, r2, r3
    4c74:	9a05      	ldr	r2, [sp, #20]
    4c76:	4313      	orrs	r3, r2
    4c78:	9305      	str	r3, [sp, #20]
    4c7a:	e014      	b.n	4ca6 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4c7c:	9b03      	ldr	r3, [sp, #12]
    4c7e:	3b04      	subs	r3, #4
    4c80:	005b      	lsls	r3, r3, #1
    4c82:	3310      	adds	r3, #16
    4c84:	2203      	movs	r2, #3
    4c86:	fa02 f303 	lsl.w	r3, r2, r3
    4c8a:	43db      	mvns	r3, r3
    4c8c:	9a05      	ldr	r2, [sp, #20]
    4c8e:	4013      	ands	r3, r2
    4c90:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    4c92:	9b03      	ldr	r3, [sp, #12]
    4c94:	3b04      	subs	r3, #4
    4c96:	005b      	lsls	r3, r3, #1
    4c98:	3310      	adds	r3, #16
    4c9a:	9a04      	ldr	r2, [sp, #16]
    4c9c:	fa02 f303 	lsl.w	r3, r2, r3
    4ca0:	9a05      	ldr	r2, [sp, #20]
    4ca2:	4313      	orrs	r3, r2
    4ca4:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    4ca6:	4a05      	ldr	r2, [pc, #20]	; (4cbc <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    4ca8:	9b05      	ldr	r3, [sp, #20]
    4caa:	60d3      	str	r3, [r2, #12]
}
    4cac:	bf00      	nop
    4cae:	b006      	add	sp, #24
    4cb0:	4770      	bx	lr
    4cb2:	bf00      	nop
    4cb4:	00010134 	.word	0x00010134
    4cb8:	0000fe24 	.word	0x0000fe24
    4cbc:	40048000 	.word	0x40048000

00004cc0 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4cc0:	b086      	sub	sp, #24
    4cc2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4cc4:	9b01      	ldr	r3, [sp, #4]
    4cc6:	685b      	ldr	r3, [r3, #4]
    4cc8:	4a20      	ldr	r2, [pc, #128]	; (4d4c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    4cca:	5cd3      	ldrb	r3, [r2, r3]
    4ccc:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    4cce:	9b01      	ldr	r3, [sp, #4]
    4cd0:	681a      	ldr	r2, [r3, #0]
    4cd2:	491f      	ldr	r1, [pc, #124]	; (4d50 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    4cd4:	4613      	mov	r3, r2
    4cd6:	00db      	lsls	r3, r3, #3
    4cd8:	4413      	add	r3, r2
    4cda:	440b      	add	r3, r1
    4cdc:	781b      	ldrb	r3, [r3, #0]
    4cde:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    4ce0:	4b1c      	ldr	r3, [pc, #112]	; (4d54 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    4ce2:	68db      	ldr	r3, [r3, #12]
    4ce4:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    4ce6:	9b03      	ldr	r3, [sp, #12]
    4ce8:	2b03      	cmp	r3, #3
    4cea:	d813      	bhi.n	4d14 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4cec:	9b03      	ldr	r3, [sp, #12]
    4cee:	005b      	lsls	r3, r3, #1
    4cf0:	3318      	adds	r3, #24
    4cf2:	2203      	movs	r2, #3
    4cf4:	fa02 f303 	lsl.w	r3, r2, r3
    4cf8:	43db      	mvns	r3, r3
    4cfa:	9a05      	ldr	r2, [sp, #20]
    4cfc:	4013      	ands	r3, r2
    4cfe:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4d00:	9b03      	ldr	r3, [sp, #12]
    4d02:	005b      	lsls	r3, r3, #1
    4d04:	3318      	adds	r3, #24
    4d06:	9a04      	ldr	r2, [sp, #16]
    4d08:	fa02 f303 	lsl.w	r3, r2, r3
    4d0c:	9a05      	ldr	r2, [sp, #20]
    4d0e:	4313      	orrs	r3, r2
    4d10:	9305      	str	r3, [sp, #20]
    4d12:	e014      	b.n	4d3e <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4d14:	9b03      	ldr	r3, [sp, #12]
    4d16:	3b04      	subs	r3, #4
    4d18:	005b      	lsls	r3, r3, #1
    4d1a:	3310      	adds	r3, #16
    4d1c:	2203      	movs	r2, #3
    4d1e:	fa02 f303 	lsl.w	r3, r2, r3
    4d22:	43db      	mvns	r3, r3
    4d24:	9a05      	ldr	r2, [sp, #20]
    4d26:	4013      	ands	r3, r2
    4d28:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    4d2a:	9b03      	ldr	r3, [sp, #12]
    4d2c:	3b04      	subs	r3, #4
    4d2e:	005b      	lsls	r3, r3, #1
    4d30:	3310      	adds	r3, #16
    4d32:	9a04      	ldr	r2, [sp, #16]
    4d34:	fa02 f303 	lsl.w	r3, r2, r3
    4d38:	9a05      	ldr	r2, [sp, #20]
    4d3a:	4313      	orrs	r3, r2
    4d3c:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    4d3e:	4a05      	ldr	r2, [pc, #20]	; (4d54 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    4d40:	9b05      	ldr	r3, [sp, #20]
    4d42:	60d3      	str	r3, [r2, #12]
}
    4d44:	bf00      	nop
    4d46:	b006      	add	sp, #24
    4d48:	4770      	bx	lr
    4d4a:	bf00      	nop
    4d4c:	00010134 	.word	0x00010134
    4d50:	0000fe24 	.word	0x0000fe24
    4d54:	40048000 	.word	0x40048000

00004d58 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4d58:	b084      	sub	sp, #16
    4d5a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    4d5c:	4b06      	ldr	r3, [pc, #24]	; (4d78 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4d5e:	685b      	ldr	r3, [r3, #4]
    4d60:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    4d62:	9b03      	ldr	r3, [sp, #12]
    4d64:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    4d68:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    4d6a:	4a03      	ldr	r2, [pc, #12]	; (4d78 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4d6c:	9b03      	ldr	r3, [sp, #12]
    4d6e:	6053      	str	r3, [r2, #4]
}
    4d70:	bf00      	nop
    4d72:	b004      	add	sp, #16
    4d74:	4770      	bx	lr
    4d76:	bf00      	nop
    4d78:	40048000 	.word	0x40048000

00004d7c <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4d7c:	b084      	sub	sp, #16
    4d7e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4d80:	9b01      	ldr	r3, [sp, #4]
    4d82:	685b      	ldr	r3, [r3, #4]
    4d84:	4a0a      	ldr	r2, [pc, #40]	; (4db0 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    4d86:	5cd3      	ldrb	r3, [r2, r3]
    4d88:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    4d8a:	4b0a      	ldr	r3, [pc, #40]	; (4db4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4d8c:	685b      	ldr	r3, [r3, #4]
    4d8e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    4d90:	9b02      	ldr	r3, [sp, #8]
    4d92:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    4d96:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    4d98:	9b03      	ldr	r3, [sp, #12]
    4d9a:	011b      	lsls	r3, r3, #4
    4d9c:	9a02      	ldr	r2, [sp, #8]
    4d9e:	4313      	orrs	r3, r2
    4da0:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    4da2:	4a04      	ldr	r2, [pc, #16]	; (4db4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4da4:	9b02      	ldr	r3, [sp, #8]
    4da6:	6053      	str	r3, [r2, #4]
}
    4da8:	bf00      	nop
    4daa:	b004      	add	sp, #16
    4dac:	4770      	bx	lr
    4dae:	bf00      	nop
    4db0:	00010134 	.word	0x00010134
    4db4:	40048000 	.word	0x40048000

00004db8 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4db8:	b084      	sub	sp, #16
    4dba:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4dbc:	9b01      	ldr	r3, [sp, #4]
    4dbe:	681a      	ldr	r2, [r3, #0]
    4dc0:	490f      	ldr	r1, [pc, #60]	; (4e00 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    4dc2:	4613      	mov	r3, r2
    4dc4:	00db      	lsls	r3, r3, #3
    4dc6:	4413      	add	r3, r2
    4dc8:	440b      	add	r3, r1
    4dca:	3304      	adds	r3, #4
    4dcc:	781b      	ldrb	r3, [r3, #0]
    4dce:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    4dd0:	4a0c      	ldr	r2, [pc, #48]	; (4e04 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4dd2:	9b03      	ldr	r3, [sp, #12]
    4dd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4dd8:	490a      	ldr	r1, [pc, #40]	; (4e04 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4dda:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    4dde:	9b03      	ldr	r3, [sp, #12]
    4de0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    4de4:	4a07      	ldr	r2, [pc, #28]	; (4e04 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4de6:	9b03      	ldr	r3, [sp, #12]
    4de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4dec:	4905      	ldr	r1, [pc, #20]	; (4e04 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4dee:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    4df2:	9b03      	ldr	r3, [sp, #12]
    4df4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4df8:	bf00      	nop
    4dfa:	b004      	add	sp, #16
    4dfc:	4770      	bx	lr
    4dfe:	bf00      	nop
    4e00:	0000fe24 	.word	0x0000fe24
    4e04:	40065000 	.word	0x40065000

00004e08 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4e08:	b086      	sub	sp, #24
    4e0a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4e0c:	9b01      	ldr	r3, [sp, #4]
    4e0e:	681a      	ldr	r2, [r3, #0]
    4e10:	4912      	ldr	r1, [pc, #72]	; (4e5c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    4e12:	4613      	mov	r3, r2
    4e14:	00db      	lsls	r3, r3, #3
    4e16:	4413      	add	r3, r2
    4e18:	440b      	add	r3, r1
    4e1a:	3304      	adds	r3, #4
    4e1c:	781b      	ldrb	r3, [r3, #0]
    4e1e:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4e20:	9b01      	ldr	r3, [sp, #4]
    4e22:	685b      	ldr	r3, [r3, #4]
    4e24:	4a0e      	ldr	r2, [pc, #56]	; (4e60 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    4e26:	5cd3      	ldrb	r3, [r2, r3]
    4e28:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    4e2a:	4a0e      	ldr	r2, [pc, #56]	; (4e64 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4e2c:	9b05      	ldr	r3, [sp, #20]
    4e2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4e32:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    4e34:	9b03      	ldr	r3, [sp, #12]
    4e36:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    4e3a:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    4e3c:	9b04      	ldr	r3, [sp, #16]
    4e3e:	061b      	lsls	r3, r3, #24
    4e40:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    4e44:	9a03      	ldr	r2, [sp, #12]
    4e46:	4313      	orrs	r3, r2
    4e48:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    4e4a:	4906      	ldr	r1, [pc, #24]	; (4e64 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4e4c:	9b05      	ldr	r3, [sp, #20]
    4e4e:	9a03      	ldr	r2, [sp, #12]
    4e50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4e54:	bf00      	nop
    4e56:	b006      	add	sp, #24
    4e58:	4770      	bx	lr
    4e5a:	bf00      	nop
    4e5c:	0000fe24 	.word	0x0000fe24
    4e60:	000101bc 	.word	0x000101bc
    4e64:	40065000 	.word	0x40065000

00004e68 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4e68:	b084      	sub	sp, #16
    4e6a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4e6c:	4b0b      	ldr	r3, [pc, #44]	; (4e9c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    4e6e:	7f1b      	ldrb	r3, [r3, #28]
    4e70:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    4e72:	4b0b      	ldr	r3, [pc, #44]	; (4ea0 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4e74:	685b      	ldr	r3, [r3, #4]
    4e76:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4e78:	9b02      	ldr	r3, [sp, #8]
    4e7a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4e7e:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4e80:	9b03      	ldr	r3, [sp, #12]
    4e82:	031b      	lsls	r3, r3, #12
    4e84:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4e88:	9a02      	ldr	r2, [sp, #8]
    4e8a:	4313      	orrs	r3, r2
    4e8c:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4e8e:	4a04      	ldr	r2, [pc, #16]	; (4ea0 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4e90:	9b02      	ldr	r3, [sp, #8]
    4e92:	6053      	str	r3, [r2, #4]
}
    4e94:	bf00      	nop
    4e96:	b004      	add	sp, #16
    4e98:	4770      	bx	lr
    4e9a:	bf00      	nop
    4e9c:	00010134 	.word	0x00010134
    4ea0:	40048000 	.word	0x40048000

00004ea4 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4ea4:	b084      	sub	sp, #16
    4ea6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4ea8:	9b01      	ldr	r3, [sp, #4]
    4eaa:	685b      	ldr	r3, [r3, #4]
    4eac:	4a0b      	ldr	r2, [pc, #44]	; (4edc <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    4eae:	5cd3      	ldrb	r3, [r2, r3]
    4eb0:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    4eb2:	4b0b      	ldr	r3, [pc, #44]	; (4ee0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4eb4:	685b      	ldr	r3, [r3, #4]
    4eb6:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4eb8:	9b02      	ldr	r3, [sp, #8]
    4eba:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4ebe:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4ec0:	9b03      	ldr	r3, [sp, #12]
    4ec2:	031b      	lsls	r3, r3, #12
    4ec4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4ec8:	9a02      	ldr	r2, [sp, #8]
    4eca:	4313      	orrs	r3, r2
    4ecc:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4ece:	4a04      	ldr	r2, [pc, #16]	; (4ee0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4ed0:	9b02      	ldr	r3, [sp, #8]
    4ed2:	6053      	str	r3, [r2, #4]
}
    4ed4:	bf00      	nop
    4ed6:	b004      	add	sp, #16
    4ed8:	4770      	bx	lr
    4eda:	bf00      	nop
    4edc:	00010134 	.word	0x00010134
    4ee0:	40048000 	.word	0x40048000

00004ee4 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    4ee4:	b500      	push	{lr}
    4ee6:	b085      	sub	sp, #20
    4ee8:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    4eea:	2300      	movs	r3, #0
    4eec:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    4ef0:	9b01      	ldr	r3, [sp, #4]
    4ef2:	2b00      	cmp	r3, #0
    4ef4:	d037      	beq.n	4f66 <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4ef6:	2300      	movs	r3, #0
    4ef8:	9303      	str	r3, [sp, #12]
    4efa:	e02b      	b.n	4f54 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4efc:	4b29      	ldr	r3, [pc, #164]	; (4fa4 <DisableSafeClock+0xc0>)
    4efe:	6819      	ldr	r1, [r3, #0]
    4f00:	9a03      	ldr	r2, [sp, #12]
    4f02:	4613      	mov	r3, r2
    4f04:	005b      	lsls	r3, r3, #1
    4f06:	4413      	add	r3, r2
    4f08:	009b      	lsls	r3, r3, #2
    4f0a:	440b      	add	r3, r1
    4f0c:	3314      	adds	r3, #20
    4f0e:	681b      	ldr	r3, [r3, #0]
    4f10:	2b05      	cmp	r3, #5
    4f12:	d11c      	bne.n	4f4e <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    4f14:	2301      	movs	r3, #1
    4f16:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    4f1a:	4b22      	ldr	r3, [pc, #136]	; (4fa4 <DisableSafeClock+0xc0>)
    4f1c:	6819      	ldr	r1, [r3, #0]
    4f1e:	9a03      	ldr	r2, [sp, #12]
    4f20:	4613      	mov	r3, r2
    4f22:	005b      	lsls	r3, r3, #1
    4f24:	4413      	add	r3, r2
    4f26:	009b      	lsls	r3, r3, #2
    4f28:	440b      	add	r3, r1
    4f2a:	3318      	adds	r3, #24
    4f2c:	881b      	ldrh	r3, [r3, #0]
    4f2e:	2b00      	cmp	r3, #0
    4f30:	d118      	bne.n	4f64 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4f32:	4b1d      	ldr	r3, [pc, #116]	; (4fa8 <DisableSafeClock+0xc4>)
    4f34:	791b      	ldrb	r3, [r3, #4]
    4f36:	4619      	mov	r1, r3
    4f38:	4a1c      	ldr	r2, [pc, #112]	; (4fac <DisableSafeClock+0xc8>)
    4f3a:	460b      	mov	r3, r1
    4f3c:	005b      	lsls	r3, r3, #1
    4f3e:	440b      	add	r3, r1
    4f40:	009b      	lsls	r3, r3, #2
    4f42:	4413      	add	r3, r2
    4f44:	3308      	adds	r3, #8
    4f46:	681b      	ldr	r3, [r3, #0]
    4f48:	2005      	movs	r0, #5
    4f4a:	4798      	blx	r3
                }
                break;
    4f4c:	e00a      	b.n	4f64 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4f4e:	9b03      	ldr	r3, [sp, #12]
    4f50:	3301      	adds	r3, #1
    4f52:	9303      	str	r3, [sp, #12]
    4f54:	4b13      	ldr	r3, [pc, #76]	; (4fa4 <DisableSafeClock+0xc0>)
    4f56:	681b      	ldr	r3, [r3, #0]
    4f58:	7a1b      	ldrb	r3, [r3, #8]
    4f5a:	461a      	mov	r2, r3
    4f5c:	9b03      	ldr	r3, [sp, #12]
    4f5e:	4293      	cmp	r3, r2
    4f60:	d3cc      	bcc.n	4efc <DisableSafeClock+0x18>
    4f62:	e000      	b.n	4f66 <DisableSafeClock+0x82>
                break;
    4f64:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    4f66:	f89d 300b 	ldrb.w	r3, [sp, #11]
    4f6a:	f083 0301 	eor.w	r3, r3, #1
    4f6e:	b2db      	uxtb	r3, r3
    4f70:	2b00      	cmp	r3, #0
    4f72:	d013      	beq.n	4f9c <DisableSafeClock+0xb8>
    4f74:	4b0e      	ldr	r3, [pc, #56]	; (4fb0 <DisableSafeClock+0xcc>)
    4f76:	781b      	ldrb	r3, [r3, #0]
    4f78:	f083 0301 	eor.w	r3, r3, #1
    4f7c:	b2db      	uxtb	r3, r3
    4f7e:	2b00      	cmp	r3, #0
    4f80:	d00c      	beq.n	4f9c <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4f82:	4b09      	ldr	r3, [pc, #36]	; (4fa8 <DisableSafeClock+0xc4>)
    4f84:	791b      	ldrb	r3, [r3, #4]
    4f86:	4619      	mov	r1, r3
    4f88:	4a08      	ldr	r2, [pc, #32]	; (4fac <DisableSafeClock+0xc8>)
    4f8a:	460b      	mov	r3, r1
    4f8c:	005b      	lsls	r3, r3, #1
    4f8e:	440b      	add	r3, r1
    4f90:	009b      	lsls	r3, r3, #2
    4f92:	4413      	add	r3, r2
    4f94:	3308      	adds	r3, #8
    4f96:	681b      	ldr	r3, [r3, #0]
    4f98:	2005      	movs	r0, #5
    4f9a:	4798      	blx	r3
    }
}
    4f9c:	bf00      	nop
    4f9e:	b005      	add	sp, #20
    4fa0:	f85d fb04 	ldr.w	pc, [sp], #4
    4fa4:	1fff8bb4 	.word	0x1fff8bb4
    4fa8:	0000fdb4 	.word	0x0000fdb4
    4fac:	000103e4 	.word	0x000103e4
    4fb0:	1fff8b18 	.word	0x1fff8b18

00004fb4 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    4fb4:	4b06      	ldr	r3, [pc, #24]	; (4fd0 <SetFircToResetValue_TrustedCall+0x1c>)
    4fb6:	2200      	movs	r2, #0
    4fb8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    4fbc:	4b04      	ldr	r3, [pc, #16]	; (4fd0 <SetFircToResetValue_TrustedCall+0x1c>)
    4fbe:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4fc2:	4a03      	ldr	r2, [pc, #12]	; (4fd0 <SetFircToResetValue_TrustedCall+0x1c>)
    4fc4:	f043 0301 	orr.w	r3, r3, #1
    4fc8:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    4fcc:	bf00      	nop
    4fce:	4770      	bx	lr
    4fd0:	40064000 	.word	0x40064000

00004fd4 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    4fd4:	b084      	sub	sp, #16
    4fd6:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    4fd8:	2303      	movs	r3, #3
    4fda:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4fdc:	2300      	movs	r3, #0
    4fde:	9302      	str	r3, [sp, #8]
    4fe0:	e028      	b.n	5034 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    4fe2:	9b01      	ldr	r3, [sp, #4]
    4fe4:	9a02      	ldr	r2, [sp, #8]
    4fe6:	320d      	adds	r2, #13
    4fe8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4fec:	2b28      	cmp	r3, #40	; 0x28
    4fee:	d10b      	bne.n	5008 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4ff0:	9a01      	ldr	r2, [sp, #4]
    4ff2:	9b02      	ldr	r3, [sp, #8]
    4ff4:	330d      	adds	r3, #13
    4ff6:	00db      	lsls	r3, r3, #3
    4ff8:	4413      	add	r3, r2
    4ffa:	685b      	ldr	r3, [r3, #4]
    4ffc:	4a2b      	ldr	r2, [pc, #172]	; (50ac <SetSimLpoclksRegister_TrustedCall+0xd8>)
    4ffe:	5cd3      	ldrb	r3, [r2, r3]
    5000:	011b      	lsls	r3, r3, #4
    5002:	9a03      	ldr	r2, [sp, #12]
    5004:	4313      	orrs	r3, r2
    5006:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    5008:	9b01      	ldr	r3, [sp, #4]
    500a:	9a02      	ldr	r2, [sp, #8]
    500c:	320d      	adds	r2, #13
    500e:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    5012:	2b29      	cmp	r3, #41	; 0x29
    5014:	d10b      	bne.n	502e <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    5016:	9a01      	ldr	r2, [sp, #4]
    5018:	9b02      	ldr	r3, [sp, #8]
    501a:	330d      	adds	r3, #13
    501c:	00db      	lsls	r3, r3, #3
    501e:	4413      	add	r3, r2
    5020:	685b      	ldr	r3, [r3, #4]
    5022:	4a23      	ldr	r2, [pc, #140]	; (50b0 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    5024:	5cd3      	ldrb	r3, [r2, r3]
    5026:	009b      	lsls	r3, r3, #2
    5028:	9a03      	ldr	r2, [sp, #12]
    502a:	4313      	orrs	r3, r2
    502c:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    502e:	9b02      	ldr	r3, [sp, #8]
    5030:	3301      	adds	r3, #1
    5032:	9302      	str	r3, [sp, #8]
    5034:	9b01      	ldr	r3, [sp, #4]
    5036:	7adb      	ldrb	r3, [r3, #11]
    5038:	461a      	mov	r2, r3
    503a:	9b02      	ldr	r3, [sp, #8]
    503c:	4293      	cmp	r3, r2
    503e:	d3d0      	bcc.n	4fe2 <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    5040:	2300      	movs	r3, #0
    5042:	9302      	str	r3, [sp, #8]
    5044:	e026      	b.n	5094 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    5046:	9a01      	ldr	r2, [sp, #4]
    5048:	9b02      	ldr	r3, [sp, #8]
    504a:	334e      	adds	r3, #78	; 0x4e
    504c:	00db      	lsls	r3, r3, #3
    504e:	4413      	add	r3, r2
    5050:	685b      	ldr	r3, [r3, #4]
    5052:	2b12      	cmp	r3, #18
    5054:	d109      	bne.n	506a <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    5056:	9a01      	ldr	r2, [sp, #4]
    5058:	9b02      	ldr	r3, [sp, #8]
    505a:	334e      	adds	r3, #78	; 0x4e
    505c:	00db      	lsls	r3, r3, #3
    505e:	4413      	add	r3, r2
    5060:	891b      	ldrh	r3, [r3, #8]
    5062:	005b      	lsls	r3, r3, #1
    5064:	9a03      	ldr	r2, [sp, #12]
    5066:	4313      	orrs	r3, r2
    5068:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    506a:	9a01      	ldr	r2, [sp, #4]
    506c:	9b02      	ldr	r3, [sp, #8]
    506e:	334e      	adds	r3, #78	; 0x4e
    5070:	00db      	lsls	r3, r3, #3
    5072:	4413      	add	r3, r2
    5074:	685b      	ldr	r3, [r3, #4]
    5076:	2b13      	cmp	r3, #19
    5078:	d109      	bne.n	508e <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    507a:	9a01      	ldr	r2, [sp, #4]
    507c:	9b02      	ldr	r3, [sp, #8]
    507e:	334e      	adds	r3, #78	; 0x4e
    5080:	00db      	lsls	r3, r3, #3
    5082:	4413      	add	r3, r2
    5084:	891b      	ldrh	r3, [r3, #8]
    5086:	461a      	mov	r2, r3
    5088:	9b03      	ldr	r3, [sp, #12]
    508a:	4313      	orrs	r3, r2
    508c:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    508e:	9b02      	ldr	r3, [sp, #8]
    5090:	3301      	adds	r3, #1
    5092:	9302      	str	r3, [sp, #8]
    5094:	9b01      	ldr	r3, [sp, #4]
    5096:	7c1b      	ldrb	r3, [r3, #16]
    5098:	461a      	mov	r2, r3
    509a:	9b02      	ldr	r3, [sp, #8]
    509c:	4293      	cmp	r3, r2
    509e:	d3d2      	bcc.n	5046 <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    50a0:	4a04      	ldr	r2, [pc, #16]	; (50b4 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    50a2:	9b03      	ldr	r3, [sp, #12]
    50a4:	6113      	str	r3, [r2, #16]
}
    50a6:	bf00      	nop
    50a8:	b004      	add	sp, #16
    50aa:	4770      	bx	lr
    50ac:	00010134 	.word	0x00010134
    50b0:	000101ec 	.word	0x000101ec
    50b4:	40048000 	.word	0x40048000

000050b8 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    50b8:	b500      	push	{lr}
    50ba:	b089      	sub	sp, #36	; 0x24
    50bc:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    50be:	2300      	movs	r3, #0
    50c0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    50c4:	4a21      	ldr	r2, [pc, #132]	; (514c <Clock_Ip_SpecificPlatformInitClock+0x94>)
    50c6:	9b01      	ldr	r3, [sp, #4]
    50c8:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    50ca:	4b21      	ldr	r3, [pc, #132]	; (5150 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    50cc:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    50d0:	f003 0301 	and.w	r3, r3, #1
    50d4:	2b00      	cmp	r3, #0
    50d6:	d12e      	bne.n	5136 <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    50d8:	4b1e      	ldr	r3, [pc, #120]	; (5154 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    50da:	2200      	movs	r2, #0
    50dc:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    50de:	f7ff ff69 	bl	4fb4 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    50e2:	aa03      	add	r2, sp, #12
    50e4:	a904      	add	r1, sp, #16
    50e6:	a805      	add	r0, sp, #20
    50e8:	f24c 3350 	movw	r3, #50000	; 0xc350
    50ec:	f7fe f8ae 	bl	324c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    50f0:	4b17      	ldr	r3, [pc, #92]	; (5150 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    50f2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    50f6:	0e1b      	lsrs	r3, r3, #24
    50f8:	f003 0301 	and.w	r3, r3, #1
    50fc:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    50fe:	9a03      	ldr	r2, [sp, #12]
    5100:	a904      	add	r1, sp, #16
    5102:	ab05      	add	r3, sp, #20
    5104:	4618      	mov	r0, r3
    5106:	f7fe f8bb 	bl	3280 <Clock_Ip_TimeoutExpired>
    510a:	4603      	mov	r3, r0
    510c:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    5110:	9b06      	ldr	r3, [sp, #24]
    5112:	2b00      	cmp	r3, #0
    5114:	d106      	bne.n	5124 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    5116:	f89d 301f 	ldrb.w	r3, [sp, #31]
    511a:	f083 0301 	eor.w	r3, r3, #1
    511e:	b2db      	uxtb	r3, r3
    5120:	2b00      	cmp	r3, #0
    5122:	d1e5      	bne.n	50f0 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    5124:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5128:	2b00      	cmp	r3, #0
    512a:	d007      	beq.n	513c <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    512c:	2105      	movs	r1, #5
    512e:	2001      	movs	r0, #1
    5130:	f7fe f87c 	bl	322c <Clock_Ip_ReportClockErrors>
    5134:	e002      	b.n	513c <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    5136:	4b07      	ldr	r3, [pc, #28]	; (5154 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    5138:	2201      	movs	r2, #1
    513a:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    513c:	9801      	ldr	r0, [sp, #4]
    513e:	f7ff ff49 	bl	4fd4 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    5142:	bf00      	nop
    5144:	b009      	add	sp, #36	; 0x24
    5146:	f85d fb04 	ldr.w	pc, [sp], #4
    514a:	bf00      	nop
    514c:	1fff8bb4 	.word	0x1fff8bb4
    5150:	40064000 	.word	0x40064000
    5154:	1fff8b18 	.word	0x1fff8b18

00005158 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    5158:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    515a:	2300      	movs	r3, #0
    515c:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    515e:	4b29      	ldr	r3, [pc, #164]	; (5204 <getFircConfig+0xac>)
    5160:	681b      	ldr	r3, [r3, #0]
    5162:	2b00      	cmp	r3, #0
    5164:	d024      	beq.n	51b0 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    5166:	2300      	movs	r3, #0
    5168:	9301      	str	r3, [sp, #4]
    516a:	e01a      	b.n	51a2 <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    516c:	4b25      	ldr	r3, [pc, #148]	; (5204 <getFircConfig+0xac>)
    516e:	6819      	ldr	r1, [r3, #0]
    5170:	9a01      	ldr	r2, [sp, #4]
    5172:	4613      	mov	r3, r2
    5174:	005b      	lsls	r3, r3, #1
    5176:	4413      	add	r3, r2
    5178:	009b      	lsls	r3, r3, #2
    517a:	440b      	add	r3, r1
    517c:	3314      	adds	r3, #20
    517e:	681b      	ldr	r3, [r3, #0]
    5180:	2b05      	cmp	r3, #5
    5182:	d10b      	bne.n	519c <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    5184:	4b1f      	ldr	r3, [pc, #124]	; (5204 <getFircConfig+0xac>)
    5186:	6819      	ldr	r1, [r3, #0]
    5188:	9a01      	ldr	r2, [sp, #4]
    518a:	4613      	mov	r3, r2
    518c:	005b      	lsls	r3, r3, #1
    518e:	4413      	add	r3, r2
    5190:	009b      	lsls	r3, r3, #2
    5192:	3310      	adds	r3, #16
    5194:	440b      	add	r3, r1
    5196:	3304      	adds	r3, #4
    5198:	9300      	str	r3, [sp, #0]
                break;
    519a:	e009      	b.n	51b0 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    519c:	9b01      	ldr	r3, [sp, #4]
    519e:	3301      	adds	r3, #1
    51a0:	9301      	str	r3, [sp, #4]
    51a2:	4b18      	ldr	r3, [pc, #96]	; (5204 <getFircConfig+0xac>)
    51a4:	681b      	ldr	r3, [r3, #0]
    51a6:	7a1b      	ldrb	r3, [r3, #8]
    51a8:	461a      	mov	r2, r3
    51aa:	9b01      	ldr	r3, [sp, #4]
    51ac:	4293      	cmp	r3, r2
    51ae:	d3dd      	bcc.n	516c <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    51b0:	9b00      	ldr	r3, [sp, #0]
    51b2:	2b00      	cmp	r3, #0
    51b4:	d121      	bne.n	51fa <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    51b6:	4b14      	ldr	r3, [pc, #80]	; (5208 <getFircConfig+0xb0>)
    51b8:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    51ba:	4b13      	ldr	r3, [pc, #76]	; (5208 <getFircConfig+0xb0>)
    51bc:	2205      	movs	r2, #5
    51be:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    51c0:	4b12      	ldr	r3, [pc, #72]	; (520c <getFircConfig+0xb4>)
    51c2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    51c6:	b29b      	uxth	r3, r3
    51c8:	f003 0301 	and.w	r3, r3, #1
    51cc:	b29a      	uxth	r2, r3
    51ce:	4b0e      	ldr	r3, [pc, #56]	; (5208 <getFircConfig+0xb0>)
    51d0:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    51d2:	4b0e      	ldr	r3, [pc, #56]	; (520c <getFircConfig+0xb4>)
    51d4:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    51d8:	b2db      	uxtb	r3, r3
    51da:	f003 0303 	and.w	r3, r3, #3
    51de:	b2da      	uxtb	r2, r3
    51e0:	4b09      	ldr	r3, [pc, #36]	; (5208 <getFircConfig+0xb0>)
    51e2:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    51e4:	4b09      	ldr	r3, [pc, #36]	; (520c <getFircConfig+0xb4>)
    51e6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    51ea:	b2db      	uxtb	r3, r3
    51ec:	10db      	asrs	r3, r3, #3
    51ee:	b2db      	uxtb	r3, r3
    51f0:	f003 0301 	and.w	r3, r3, #1
    51f4:	b2da      	uxtb	r2, r3
    51f6:	4b04      	ldr	r3, [pc, #16]	; (5208 <getFircConfig+0xb0>)
    51f8:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    51fa:	9b00      	ldr	r3, [sp, #0]
}
    51fc:	4618      	mov	r0, r3
    51fe:	b002      	add	sp, #8
    5200:	4770      	bx	lr
    5202:	bf00      	nop
    5204:	1fff8bb4 	.word	0x1fff8bb4
    5208:	1fff8c20 	.word	0x1fff8c20
    520c:	40064000 	.word	0x40064000

00005210 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    5210:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    5212:	2300      	movs	r3, #0
    5214:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    5216:	4b20      	ldr	r3, [pc, #128]	; (5298 <getSoscConfig+0x88>)
    5218:	681b      	ldr	r3, [r3, #0]
    521a:	2b00      	cmp	r3, #0
    521c:	d024      	beq.n	5268 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    521e:	2300      	movs	r3, #0
    5220:	9301      	str	r3, [sp, #4]
    5222:	e01a      	b.n	525a <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    5224:	4b1c      	ldr	r3, [pc, #112]	; (5298 <getSoscConfig+0x88>)
    5226:	6819      	ldr	r1, [r3, #0]
    5228:	9a01      	ldr	r2, [sp, #4]
    522a:	4613      	mov	r3, r2
    522c:	009b      	lsls	r3, r3, #2
    522e:	4413      	add	r3, r2
    5230:	009b      	lsls	r3, r3, #2
    5232:	440b      	add	r3, r1
    5234:	332c      	adds	r3, #44	; 0x2c
    5236:	681b      	ldr	r3, [r3, #0]
    5238:	2b08      	cmp	r3, #8
    523a:	d10b      	bne.n	5254 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    523c:	4b16      	ldr	r3, [pc, #88]	; (5298 <getSoscConfig+0x88>)
    523e:	6819      	ldr	r1, [r3, #0]
    5240:	9a01      	ldr	r2, [sp, #4]
    5242:	4613      	mov	r3, r2
    5244:	009b      	lsls	r3, r3, #2
    5246:	4413      	add	r3, r2
    5248:	009b      	lsls	r3, r3, #2
    524a:	3328      	adds	r3, #40	; 0x28
    524c:	440b      	add	r3, r1
    524e:	3304      	adds	r3, #4
    5250:	9300      	str	r3, [sp, #0]
                break;
    5252:	e009      	b.n	5268 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    5254:	9b01      	ldr	r3, [sp, #4]
    5256:	3301      	adds	r3, #1
    5258:	9301      	str	r3, [sp, #4]
    525a:	4b0f      	ldr	r3, [pc, #60]	; (5298 <getSoscConfig+0x88>)
    525c:	681b      	ldr	r3, [r3, #0]
    525e:	7a5b      	ldrb	r3, [r3, #9]
    5260:	461a      	mov	r2, r3
    5262:	9b01      	ldr	r3, [sp, #4]
    5264:	4293      	cmp	r3, r2
    5266:	d3dd      	bcc.n	5224 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5268:	9b00      	ldr	r3, [sp, #0]
    526a:	2b00      	cmp	r3, #0
    526c:	d110      	bne.n	5290 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    526e:	4b0b      	ldr	r3, [pc, #44]	; (529c <getSoscConfig+0x8c>)
    5270:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    5272:	4b0a      	ldr	r3, [pc, #40]	; (529c <getSoscConfig+0x8c>)
    5274:	2208      	movs	r2, #8
    5276:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    5278:	4b09      	ldr	r3, [pc, #36]	; (52a0 <getSoscConfig+0x90>)
    527a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    527e:	b29b      	uxth	r3, r3
    5280:	f003 0301 	and.w	r3, r3, #1
    5284:	b29a      	uxth	r2, r3
    5286:	4b05      	ldr	r3, [pc, #20]	; (529c <getSoscConfig+0x8c>)
    5288:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    528a:	4b04      	ldr	r3, [pc, #16]	; (529c <getSoscConfig+0x8c>)
    528c:	4a05      	ldr	r2, [pc, #20]	; (52a4 <getSoscConfig+0x94>)
    528e:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    5290:	9b00      	ldr	r3, [sp, #0]
}
    5292:	4618      	mov	r0, r3
    5294:	b002      	add	sp, #8
    5296:	4770      	bx	lr
    5298:	1fff8bb4 	.word	0x1fff8bb4
    529c:	1fff8c2c 	.word	0x1fff8c2c
    52a0:	40064000 	.word	0x40064000
    52a4:	02625a00 	.word	0x02625a00

000052a8 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    52a8:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    52aa:	2300      	movs	r3, #0
    52ac:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    52ae:	4b28      	ldr	r3, [pc, #160]	; (5350 <getSpllConfig+0xa8>)
    52b0:	681b      	ldr	r3, [r3, #0]
    52b2:	2b00      	cmp	r3, #0
    52b4:	d023      	beq.n	52fe <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    52b6:	2300      	movs	r3, #0
    52b8:	9301      	str	r3, [sp, #4]
    52ba:	e019      	b.n	52f0 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    52bc:	4b24      	ldr	r3, [pc, #144]	; (5350 <getSpllConfig+0xa8>)
    52be:	6819      	ldr	r1, [r3, #0]
    52c0:	9a01      	ldr	r2, [sp, #4]
    52c2:	4613      	mov	r3, r2
    52c4:	009b      	lsls	r3, r3, #2
    52c6:	4413      	add	r3, r2
    52c8:	00db      	lsls	r3, r3, #3
    52ca:	440b      	add	r3, r1
    52cc:	3340      	adds	r3, #64	; 0x40
    52ce:	681b      	ldr	r3, [r3, #0]
    52d0:	2b09      	cmp	r3, #9
    52d2:	d10a      	bne.n	52ea <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    52d4:	4b1e      	ldr	r3, [pc, #120]	; (5350 <getSpllConfig+0xa8>)
    52d6:	6819      	ldr	r1, [r3, #0]
    52d8:	9a01      	ldr	r2, [sp, #4]
    52da:	4613      	mov	r3, r2
    52dc:	009b      	lsls	r3, r3, #2
    52de:	4413      	add	r3, r2
    52e0:	00db      	lsls	r3, r3, #3
    52e2:	3340      	adds	r3, #64	; 0x40
    52e4:	440b      	add	r3, r1
    52e6:	9300      	str	r3, [sp, #0]
                break;
    52e8:	e009      	b.n	52fe <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    52ea:	9b01      	ldr	r3, [sp, #4]
    52ec:	3301      	adds	r3, #1
    52ee:	9301      	str	r3, [sp, #4]
    52f0:	4b17      	ldr	r3, [pc, #92]	; (5350 <getSpllConfig+0xa8>)
    52f2:	681b      	ldr	r3, [r3, #0]
    52f4:	7a9b      	ldrb	r3, [r3, #10]
    52f6:	461a      	mov	r2, r3
    52f8:	9b01      	ldr	r3, [sp, #4]
    52fa:	4293      	cmp	r3, r2
    52fc:	d3de      	bcc.n	52bc <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    52fe:	9b00      	ldr	r3, [sp, #0]
    5300:	2b00      	cmp	r3, #0
    5302:	d121      	bne.n	5348 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    5304:	4b13      	ldr	r3, [pc, #76]	; (5354 <getSpllConfig+0xac>)
    5306:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    5308:	4b12      	ldr	r3, [pc, #72]	; (5354 <getSpllConfig+0xac>)
    530a:	2209      	movs	r2, #9
    530c:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    530e:	4b12      	ldr	r3, [pc, #72]	; (5358 <getSpllConfig+0xb0>)
    5310:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    5314:	b29b      	uxth	r3, r3
    5316:	f003 0301 	and.w	r3, r3, #1
    531a:	b29a      	uxth	r2, r3
    531c:	4b0d      	ldr	r3, [pc, #52]	; (5354 <getSpllConfig+0xac>)
    531e:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    5320:	4b0d      	ldr	r3, [pc, #52]	; (5358 <getSpllConfig+0xb0>)
    5322:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    5326:	0a1b      	lsrs	r3, r3, #8
    5328:	b2db      	uxtb	r3, r3
    532a:	f003 0307 	and.w	r3, r3, #7
    532e:	b2da      	uxtb	r2, r3
    5330:	4b08      	ldr	r3, [pc, #32]	; (5354 <getSpllConfig+0xac>)
    5332:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    5334:	4b08      	ldr	r3, [pc, #32]	; (5358 <getSpllConfig+0xb0>)
    5336:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    533a:	0c1b      	lsrs	r3, r3, #16
    533c:	b2db      	uxtb	r3, r3
    533e:	f003 031f 	and.w	r3, r3, #31
    5342:	b2da      	uxtb	r2, r3
    5344:	4b03      	ldr	r3, [pc, #12]	; (5354 <getSpllConfig+0xac>)
    5346:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    5348:	9b00      	ldr	r3, [sp, #0]
}
    534a:	4618      	mov	r0, r3
    534c:	b002      	add	sp, #8
    534e:	4770      	bx	lr
    5350:	1fff8bb4 	.word	0x1fff8bb4
    5354:	1fff8c40 	.word	0x1fff8c40
    5358:	40064000 	.word	0x40064000

0000535c <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    535c:	b086      	sub	sp, #24
    535e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    5360:	2300      	movs	r3, #0
    5362:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    5364:	9b01      	ldr	r3, [sp, #4]
    5366:	2b1b      	cmp	r3, #27
    5368:	d00f      	beq.n	538a <getSelectorConfig+0x2e>
    536a:	9b01      	ldr	r3, [sp, #4]
    536c:	2b1b      	cmp	r3, #27
    536e:	d80f      	bhi.n	5390 <getSelectorConfig+0x34>
    5370:	9b01      	ldr	r3, [sp, #4]
    5372:	2b19      	cmp	r3, #25
    5374:	d003      	beq.n	537e <getSelectorConfig+0x22>
    5376:	9b01      	ldr	r3, [sp, #4]
    5378:	2b1a      	cmp	r3, #26
    537a:	d003      	beq.n	5384 <getSelectorConfig+0x28>
    537c:	e008      	b.n	5390 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    537e:	2300      	movs	r3, #0
    5380:	9304      	str	r3, [sp, #16]
            break;
    5382:	e008      	b.n	5396 <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    5384:	2301      	movs	r3, #1
    5386:	9304      	str	r3, [sp, #16]
            break;
    5388:	e005      	b.n	5396 <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    538a:	2302      	movs	r3, #2
    538c:	9304      	str	r3, [sp, #16]
            break;
    538e:	e002      	b.n	5396 <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    5390:	2300      	movs	r3, #0
    5392:	9304      	str	r3, [sp, #16]
            break;
    5394:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5396:	4b36      	ldr	r3, [pc, #216]	; (5470 <getSelectorConfig+0x114>)
    5398:	681b      	ldr	r3, [r3, #0]
    539a:	2b00      	cmp	r3, #0
    539c:	d01d      	beq.n	53da <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    539e:	2300      	movs	r3, #0
    53a0:	9303      	str	r3, [sp, #12]
    53a2:	e013      	b.n	53cc <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    53a4:	4b32      	ldr	r3, [pc, #200]	; (5470 <getSelectorConfig+0x114>)
    53a6:	681b      	ldr	r3, [r3, #0]
    53a8:	9a03      	ldr	r2, [sp, #12]
    53aa:	320d      	adds	r2, #13
    53ac:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    53b0:	9a01      	ldr	r2, [sp, #4]
    53b2:	429a      	cmp	r2, r3
    53b4:	d107      	bne.n	53c6 <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    53b6:	4b2e      	ldr	r3, [pc, #184]	; (5470 <getSelectorConfig+0x114>)
    53b8:	681a      	ldr	r2, [r3, #0]
    53ba:	9b03      	ldr	r3, [sp, #12]
    53bc:	330d      	adds	r3, #13
    53be:	00db      	lsls	r3, r3, #3
    53c0:	4413      	add	r3, r2
    53c2:	9305      	str	r3, [sp, #20]
                break;
    53c4:	e009      	b.n	53da <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    53c6:	9b03      	ldr	r3, [sp, #12]
    53c8:	3301      	adds	r3, #1
    53ca:	9303      	str	r3, [sp, #12]
    53cc:	4b28      	ldr	r3, [pc, #160]	; (5470 <getSelectorConfig+0x114>)
    53ce:	681b      	ldr	r3, [r3, #0]
    53d0:	7adb      	ldrb	r3, [r3, #11]
    53d2:	461a      	mov	r2, r3
    53d4:	9b03      	ldr	r3, [sp, #12]
    53d6:	4293      	cmp	r3, r2
    53d8:	d3e4      	bcc.n	53a4 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    53da:	9b05      	ldr	r3, [sp, #20]
    53dc:	2b00      	cmp	r3, #0
    53de:	d140      	bne.n	5462 <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    53e0:	9b04      	ldr	r3, [sp, #16]
    53e2:	00db      	lsls	r3, r3, #3
    53e4:	4a23      	ldr	r2, [pc, #140]	; (5474 <getSelectorConfig+0x118>)
    53e6:	4413      	add	r3, r2
    53e8:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    53ea:	4922      	ldr	r1, [pc, #136]	; (5474 <getSelectorConfig+0x118>)
    53ec:	9b04      	ldr	r3, [sp, #16]
    53ee:	9a01      	ldr	r2, [sp, #4]
    53f0:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    53f4:	9b01      	ldr	r3, [sp, #4]
    53f6:	2b1b      	cmp	r3, #27
    53f8:	d025      	beq.n	5446 <getSelectorConfig+0xea>
    53fa:	9b01      	ldr	r3, [sp, #4]
    53fc:	2b1b      	cmp	r3, #27
    53fe:	d832      	bhi.n	5466 <getSelectorConfig+0x10a>
    5400:	9b01      	ldr	r3, [sp, #4]
    5402:	2b19      	cmp	r3, #25
    5404:	d003      	beq.n	540e <getSelectorConfig+0xb2>
    5406:	9b01      	ldr	r3, [sp, #4]
    5408:	2b1a      	cmp	r3, #26
    540a:	d00e      	beq.n	542a <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    540c:	e02b      	b.n	5466 <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    540e:	4b1a      	ldr	r3, [pc, #104]	; (5478 <getSelectorConfig+0x11c>)
    5410:	695b      	ldr	r3, [r3, #20]
    5412:	0e1b      	lsrs	r3, r3, #24
    5414:	f003 030f 	and.w	r3, r3, #15
    5418:	4a18      	ldr	r2, [pc, #96]	; (547c <getSelectorConfig+0x120>)
    541a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    541e:	4915      	ldr	r1, [pc, #84]	; (5474 <getSelectorConfig+0x118>)
    5420:	9b04      	ldr	r3, [sp, #16]
    5422:	00db      	lsls	r3, r3, #3
    5424:	440b      	add	r3, r1
    5426:	605a      	str	r2, [r3, #4]
                break;
    5428:	e01e      	b.n	5468 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    542a:	4b13      	ldr	r3, [pc, #76]	; (5478 <getSelectorConfig+0x11c>)
    542c:	699b      	ldr	r3, [r3, #24]
    542e:	0e1b      	lsrs	r3, r3, #24
    5430:	f003 030f 	and.w	r3, r3, #15
    5434:	4a11      	ldr	r2, [pc, #68]	; (547c <getSelectorConfig+0x120>)
    5436:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    543a:	490e      	ldr	r1, [pc, #56]	; (5474 <getSelectorConfig+0x118>)
    543c:	9b04      	ldr	r3, [sp, #16]
    543e:	00db      	lsls	r3, r3, #3
    5440:	440b      	add	r3, r1
    5442:	605a      	str	r2, [r3, #4]
                break;
    5444:	e010      	b.n	5468 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    5446:	4b0c      	ldr	r3, [pc, #48]	; (5478 <getSelectorConfig+0x11c>)
    5448:	69db      	ldr	r3, [r3, #28]
    544a:	0e1b      	lsrs	r3, r3, #24
    544c:	f003 030f 	and.w	r3, r3, #15
    5450:	4a0a      	ldr	r2, [pc, #40]	; (547c <getSelectorConfig+0x120>)
    5452:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    5456:	4907      	ldr	r1, [pc, #28]	; (5474 <getSelectorConfig+0x118>)
    5458:	9b04      	ldr	r3, [sp, #16]
    545a:	00db      	lsls	r3, r3, #3
    545c:	440b      	add	r3, r1
    545e:	605a      	str	r2, [r3, #4]
                break;
    5460:	e002      	b.n	5468 <getSelectorConfig+0x10c>
        }
    }
    5462:	bf00      	nop
    5464:	e000      	b.n	5468 <getSelectorConfig+0x10c>
                break;
    5466:	bf00      	nop

    return ReturnValue;
    5468:	9b05      	ldr	r3, [sp, #20]
}
    546a:	4618      	mov	r0, r3
    546c:	b006      	add	sp, #24
    546e:	4770      	bx	lr
    5470:	1fff8bb4 	.word	0x1fff8bb4
    5474:	1fff8c68 	.word	0x1fff8c68
    5478:	40064000 	.word	0x40064000
    547c:	000104b4 	.word	0x000104b4

00005480 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    5480:	b086      	sub	sp, #24
    5482:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    5484:	2300      	movs	r3, #0
    5486:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5488:	2300      	movs	r3, #0
    548a:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    548c:	9b01      	ldr	r3, [sp, #4]
    548e:	2b1f      	cmp	r3, #31
    5490:	d00f      	beq.n	54b2 <getCoreDividerConfig+0x32>
    5492:	9b01      	ldr	r3, [sp, #4]
    5494:	2b1f      	cmp	r3, #31
    5496:	d80f      	bhi.n	54b8 <getCoreDividerConfig+0x38>
    5498:	9b01      	ldr	r3, [sp, #4]
    549a:	2b1d      	cmp	r3, #29
    549c:	d003      	beq.n	54a6 <getCoreDividerConfig+0x26>
    549e:	9b01      	ldr	r3, [sp, #4]
    54a0:	2b1e      	cmp	r3, #30
    54a2:	d003      	beq.n	54ac <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    54a4:	e008      	b.n	54b8 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    54a6:	2300      	movs	r3, #0
    54a8:	9304      	str	r3, [sp, #16]
            break;
    54aa:	e006      	b.n	54ba <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    54ac:	2301      	movs	r3, #1
    54ae:	9304      	str	r3, [sp, #16]
            break;
    54b0:	e003      	b.n	54ba <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    54b2:	2302      	movs	r3, #2
    54b4:	9304      	str	r3, [sp, #16]
            break;
    54b6:	e000      	b.n	54ba <getCoreDividerConfig+0x3a>
                break;
    54b8:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    54ba:	4b41      	ldr	r3, [pc, #260]	; (55c0 <getCoreDividerConfig+0x140>)
    54bc:	681b      	ldr	r3, [r3, #0]
    54be:	2b00      	cmp	r3, #0
    54c0:	d026      	beq.n	5510 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    54c2:	2300      	movs	r3, #0
    54c4:	9303      	str	r3, [sp, #12]
    54c6:	e01c      	b.n	5502 <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    54c8:	4b3d      	ldr	r3, [pc, #244]	; (55c0 <getCoreDividerConfig+0x140>)
    54ca:	6819      	ldr	r1, [r3, #0]
    54cc:	9a03      	ldr	r2, [sp, #12]
    54ce:	4613      	mov	r3, r2
    54d0:	005b      	lsls	r3, r3, #1
    54d2:	4413      	add	r3, r2
    54d4:	009b      	lsls	r3, r3, #2
    54d6:	440b      	add	r3, r1
    54d8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    54dc:	681b      	ldr	r3, [r3, #0]
    54de:	9a01      	ldr	r2, [sp, #4]
    54e0:	429a      	cmp	r2, r3
    54e2:	d10b      	bne.n	54fc <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    54e4:	4b36      	ldr	r3, [pc, #216]	; (55c0 <getCoreDividerConfig+0x140>)
    54e6:	6819      	ldr	r1, [r3, #0]
    54e8:	9a03      	ldr	r2, [sp, #12]
    54ea:	4613      	mov	r3, r2
    54ec:	005b      	lsls	r3, r3, #1
    54ee:	4413      	add	r3, r2
    54f0:	009b      	lsls	r3, r3, #2
    54f2:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    54f6:	440b      	add	r3, r1
    54f8:	9305      	str	r3, [sp, #20]
                break;
    54fa:	e009      	b.n	5510 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    54fc:	9b03      	ldr	r3, [sp, #12]
    54fe:	3301      	adds	r3, #1
    5500:	9303      	str	r3, [sp, #12]
    5502:	4b2f      	ldr	r3, [pc, #188]	; (55c0 <getCoreDividerConfig+0x140>)
    5504:	681b      	ldr	r3, [r3, #0]
    5506:	7b1b      	ldrb	r3, [r3, #12]
    5508:	461a      	mov	r2, r3
    550a:	9b03      	ldr	r3, [sp, #12]
    550c:	4293      	cmp	r3, r2
    550e:	d3db      	bcc.n	54c8 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5510:	9b05      	ldr	r3, [sp, #20]
    5512:	2b00      	cmp	r3, #0
    5514:	d14d      	bne.n	55b2 <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    5516:	9a04      	ldr	r2, [sp, #16]
    5518:	4613      	mov	r3, r2
    551a:	005b      	lsls	r3, r3, #1
    551c:	4413      	add	r3, r2
    551e:	009b      	lsls	r3, r3, #2
    5520:	4a28      	ldr	r2, [pc, #160]	; (55c4 <getCoreDividerConfig+0x144>)
    5522:	4413      	add	r3, r2
    5524:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    5526:	4927      	ldr	r1, [pc, #156]	; (55c4 <getCoreDividerConfig+0x144>)
    5528:	9a04      	ldr	r2, [sp, #16]
    552a:	4613      	mov	r3, r2
    552c:	005b      	lsls	r3, r3, #1
    552e:	4413      	add	r3, r2
    5530:	009b      	lsls	r3, r3, #2
    5532:	440b      	add	r3, r1
    5534:	9a01      	ldr	r2, [sp, #4]
    5536:	601a      	str	r2, [r3, #0]
        switch(Name)
    5538:	9b01      	ldr	r3, [sp, #4]
    553a:	2b1f      	cmp	r3, #31
    553c:	d029      	beq.n	5592 <getCoreDividerConfig+0x112>
    553e:	9b01      	ldr	r3, [sp, #4]
    5540:	2b1f      	cmp	r3, #31
    5542:	d838      	bhi.n	55b6 <getCoreDividerConfig+0x136>
    5544:	9b01      	ldr	r3, [sp, #4]
    5546:	2b1d      	cmp	r3, #29
    5548:	d003      	beq.n	5552 <getCoreDividerConfig+0xd2>
    554a:	9b01      	ldr	r3, [sp, #4]
    554c:	2b1e      	cmp	r3, #30
    554e:	d010      	beq.n	5572 <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    5550:	e031      	b.n	55b6 <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    5552:	4b1d      	ldr	r3, [pc, #116]	; (55c8 <getCoreDividerConfig+0x148>)
    5554:	695b      	ldr	r3, [r3, #20]
    5556:	0c1b      	lsrs	r3, r3, #16
    5558:	f003 030f 	and.w	r3, r3, #15
    555c:	1c59      	adds	r1, r3, #1
    555e:	4819      	ldr	r0, [pc, #100]	; (55c4 <getCoreDividerConfig+0x144>)
    5560:	9a04      	ldr	r2, [sp, #16]
    5562:	4613      	mov	r3, r2
    5564:	005b      	lsls	r3, r3, #1
    5566:	4413      	add	r3, r2
    5568:	009b      	lsls	r3, r3, #2
    556a:	4403      	add	r3, r0
    556c:	3304      	adds	r3, #4
    556e:	6019      	str	r1, [r3, #0]
                break;
    5570:	e022      	b.n	55b8 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    5572:	4b15      	ldr	r3, [pc, #84]	; (55c8 <getCoreDividerConfig+0x148>)
    5574:	699b      	ldr	r3, [r3, #24]
    5576:	0c1b      	lsrs	r3, r3, #16
    5578:	f003 030f 	and.w	r3, r3, #15
    557c:	1c59      	adds	r1, r3, #1
    557e:	4811      	ldr	r0, [pc, #68]	; (55c4 <getCoreDividerConfig+0x144>)
    5580:	9a04      	ldr	r2, [sp, #16]
    5582:	4613      	mov	r3, r2
    5584:	005b      	lsls	r3, r3, #1
    5586:	4413      	add	r3, r2
    5588:	009b      	lsls	r3, r3, #2
    558a:	4403      	add	r3, r0
    558c:	3304      	adds	r3, #4
    558e:	6019      	str	r1, [r3, #0]
                break;
    5590:	e012      	b.n	55b8 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    5592:	4b0d      	ldr	r3, [pc, #52]	; (55c8 <getCoreDividerConfig+0x148>)
    5594:	69db      	ldr	r3, [r3, #28]
    5596:	0c1b      	lsrs	r3, r3, #16
    5598:	f003 030f 	and.w	r3, r3, #15
    559c:	1c59      	adds	r1, r3, #1
    559e:	4809      	ldr	r0, [pc, #36]	; (55c4 <getCoreDividerConfig+0x144>)
    55a0:	9a04      	ldr	r2, [sp, #16]
    55a2:	4613      	mov	r3, r2
    55a4:	005b      	lsls	r3, r3, #1
    55a6:	4413      	add	r3, r2
    55a8:	009b      	lsls	r3, r3, #2
    55aa:	4403      	add	r3, r0
    55ac:	3304      	adds	r3, #4
    55ae:	6019      	str	r1, [r3, #0]
                break;
    55b0:	e002      	b.n	55b8 <getCoreDividerConfig+0x138>
        }
    }
    55b2:	bf00      	nop
    55b4:	e000      	b.n	55b8 <getCoreDividerConfig+0x138>
                break;
    55b6:	bf00      	nop

    return ReturnValue;
    55b8:	9b05      	ldr	r3, [sp, #20]
}
    55ba:	4618      	mov	r0, r3
    55bc:	b006      	add	sp, #24
    55be:	4770      	bx	lr
    55c0:	1fff8bb4 	.word	0x1fff8bb4
    55c4:	1fff8c80 	.word	0x1fff8c80
    55c8:	40064000 	.word	0x40064000

000055cc <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    55cc:	b086      	sub	sp, #24
    55ce:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    55d0:	2300      	movs	r3, #0
    55d2:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    55d4:	2300      	movs	r3, #0
    55d6:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    55d8:	9b01      	ldr	r3, [sp, #4]
    55da:	2b23      	cmp	r3, #35	; 0x23
    55dc:	d00f      	beq.n	55fe <getBusDividerConfig+0x32>
    55de:	9b01      	ldr	r3, [sp, #4]
    55e0:	2b23      	cmp	r3, #35	; 0x23
    55e2:	d80f      	bhi.n	5604 <getBusDividerConfig+0x38>
    55e4:	9b01      	ldr	r3, [sp, #4]
    55e6:	2b21      	cmp	r3, #33	; 0x21
    55e8:	d003      	beq.n	55f2 <getBusDividerConfig+0x26>
    55ea:	9b01      	ldr	r3, [sp, #4]
    55ec:	2b22      	cmp	r3, #34	; 0x22
    55ee:	d003      	beq.n	55f8 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    55f0:	e008      	b.n	5604 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    55f2:	2300      	movs	r3, #0
    55f4:	9304      	str	r3, [sp, #16]
            break;
    55f6:	e006      	b.n	5606 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    55f8:	2301      	movs	r3, #1
    55fa:	9304      	str	r3, [sp, #16]
            break;
    55fc:	e003      	b.n	5606 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    55fe:	2302      	movs	r3, #2
    5600:	9304      	str	r3, [sp, #16]
            break;
    5602:	e000      	b.n	5606 <getBusDividerConfig+0x3a>
                break;
    5604:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5606:	4b41      	ldr	r3, [pc, #260]	; (570c <getBusDividerConfig+0x140>)
    5608:	681b      	ldr	r3, [r3, #0]
    560a:	2b00      	cmp	r3, #0
    560c:	d026      	beq.n	565c <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    560e:	2300      	movs	r3, #0
    5610:	9303      	str	r3, [sp, #12]
    5612:	e01c      	b.n	564e <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5614:	4b3d      	ldr	r3, [pc, #244]	; (570c <getBusDividerConfig+0x140>)
    5616:	6819      	ldr	r1, [r3, #0]
    5618:	9a03      	ldr	r2, [sp, #12]
    561a:	4613      	mov	r3, r2
    561c:	005b      	lsls	r3, r3, #1
    561e:	4413      	add	r3, r2
    5620:	009b      	lsls	r3, r3, #2
    5622:	440b      	add	r3, r1
    5624:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5628:	681b      	ldr	r3, [r3, #0]
    562a:	9a01      	ldr	r2, [sp, #4]
    562c:	429a      	cmp	r2, r3
    562e:	d10b      	bne.n	5648 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5630:	4b36      	ldr	r3, [pc, #216]	; (570c <getBusDividerConfig+0x140>)
    5632:	6819      	ldr	r1, [r3, #0]
    5634:	9a03      	ldr	r2, [sp, #12]
    5636:	4613      	mov	r3, r2
    5638:	005b      	lsls	r3, r3, #1
    563a:	4413      	add	r3, r2
    563c:	009b      	lsls	r3, r3, #2
    563e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5642:	440b      	add	r3, r1
    5644:	9305      	str	r3, [sp, #20]
                break;
    5646:	e009      	b.n	565c <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5648:	9b03      	ldr	r3, [sp, #12]
    564a:	3301      	adds	r3, #1
    564c:	9303      	str	r3, [sp, #12]
    564e:	4b2f      	ldr	r3, [pc, #188]	; (570c <getBusDividerConfig+0x140>)
    5650:	681b      	ldr	r3, [r3, #0]
    5652:	7b1b      	ldrb	r3, [r3, #12]
    5654:	461a      	mov	r2, r3
    5656:	9b03      	ldr	r3, [sp, #12]
    5658:	4293      	cmp	r3, r2
    565a:	d3db      	bcc.n	5614 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    565c:	9b05      	ldr	r3, [sp, #20]
    565e:	2b00      	cmp	r3, #0
    5660:	d14d      	bne.n	56fe <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    5662:	9a04      	ldr	r2, [sp, #16]
    5664:	4613      	mov	r3, r2
    5666:	005b      	lsls	r3, r3, #1
    5668:	4413      	add	r3, r2
    566a:	009b      	lsls	r3, r3, #2
    566c:	4a28      	ldr	r2, [pc, #160]	; (5710 <getBusDividerConfig+0x144>)
    566e:	4413      	add	r3, r2
    5670:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    5672:	4927      	ldr	r1, [pc, #156]	; (5710 <getBusDividerConfig+0x144>)
    5674:	9a04      	ldr	r2, [sp, #16]
    5676:	4613      	mov	r3, r2
    5678:	005b      	lsls	r3, r3, #1
    567a:	4413      	add	r3, r2
    567c:	009b      	lsls	r3, r3, #2
    567e:	440b      	add	r3, r1
    5680:	9a01      	ldr	r2, [sp, #4]
    5682:	601a      	str	r2, [r3, #0]
        switch(Name)
    5684:	9b01      	ldr	r3, [sp, #4]
    5686:	2b23      	cmp	r3, #35	; 0x23
    5688:	d029      	beq.n	56de <getBusDividerConfig+0x112>
    568a:	9b01      	ldr	r3, [sp, #4]
    568c:	2b23      	cmp	r3, #35	; 0x23
    568e:	d838      	bhi.n	5702 <getBusDividerConfig+0x136>
    5690:	9b01      	ldr	r3, [sp, #4]
    5692:	2b21      	cmp	r3, #33	; 0x21
    5694:	d003      	beq.n	569e <getBusDividerConfig+0xd2>
    5696:	9b01      	ldr	r3, [sp, #4]
    5698:	2b22      	cmp	r3, #34	; 0x22
    569a:	d010      	beq.n	56be <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    569c:	e031      	b.n	5702 <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    569e:	4b1d      	ldr	r3, [pc, #116]	; (5714 <getBusDividerConfig+0x148>)
    56a0:	695b      	ldr	r3, [r3, #20]
    56a2:	091b      	lsrs	r3, r3, #4
    56a4:	f003 030f 	and.w	r3, r3, #15
    56a8:	1c59      	adds	r1, r3, #1
    56aa:	4819      	ldr	r0, [pc, #100]	; (5710 <getBusDividerConfig+0x144>)
    56ac:	9a04      	ldr	r2, [sp, #16]
    56ae:	4613      	mov	r3, r2
    56b0:	005b      	lsls	r3, r3, #1
    56b2:	4413      	add	r3, r2
    56b4:	009b      	lsls	r3, r3, #2
    56b6:	4403      	add	r3, r0
    56b8:	3304      	adds	r3, #4
    56ba:	6019      	str	r1, [r3, #0]
                break;
    56bc:	e022      	b.n	5704 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    56be:	4b15      	ldr	r3, [pc, #84]	; (5714 <getBusDividerConfig+0x148>)
    56c0:	699b      	ldr	r3, [r3, #24]
    56c2:	091b      	lsrs	r3, r3, #4
    56c4:	f003 030f 	and.w	r3, r3, #15
    56c8:	1c59      	adds	r1, r3, #1
    56ca:	4811      	ldr	r0, [pc, #68]	; (5710 <getBusDividerConfig+0x144>)
    56cc:	9a04      	ldr	r2, [sp, #16]
    56ce:	4613      	mov	r3, r2
    56d0:	005b      	lsls	r3, r3, #1
    56d2:	4413      	add	r3, r2
    56d4:	009b      	lsls	r3, r3, #2
    56d6:	4403      	add	r3, r0
    56d8:	3304      	adds	r3, #4
    56da:	6019      	str	r1, [r3, #0]
                break;
    56dc:	e012      	b.n	5704 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    56de:	4b0d      	ldr	r3, [pc, #52]	; (5714 <getBusDividerConfig+0x148>)
    56e0:	69db      	ldr	r3, [r3, #28]
    56e2:	091b      	lsrs	r3, r3, #4
    56e4:	f003 030f 	and.w	r3, r3, #15
    56e8:	1c59      	adds	r1, r3, #1
    56ea:	4809      	ldr	r0, [pc, #36]	; (5710 <getBusDividerConfig+0x144>)
    56ec:	9a04      	ldr	r2, [sp, #16]
    56ee:	4613      	mov	r3, r2
    56f0:	005b      	lsls	r3, r3, #1
    56f2:	4413      	add	r3, r2
    56f4:	009b      	lsls	r3, r3, #2
    56f6:	4403      	add	r3, r0
    56f8:	3304      	adds	r3, #4
    56fa:	6019      	str	r1, [r3, #0]
                break;
    56fc:	e002      	b.n	5704 <getBusDividerConfig+0x138>
        }
    }
    56fe:	bf00      	nop
    5700:	e000      	b.n	5704 <getBusDividerConfig+0x138>
                break;
    5702:	bf00      	nop

    return ReturnValue;
    5704:	9b05      	ldr	r3, [sp, #20]
}
    5706:	4618      	mov	r0, r3
    5708:	b006      	add	sp, #24
    570a:	4770      	bx	lr
    570c:	1fff8bb4 	.word	0x1fff8bb4
    5710:	1fff8ca4 	.word	0x1fff8ca4
    5714:	40064000 	.word	0x40064000

00005718 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    5718:	b086      	sub	sp, #24
    571a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    571c:	2300      	movs	r3, #0
    571e:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5720:	2300      	movs	r3, #0
    5722:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5724:	9b01      	ldr	r3, [sp, #4]
    5726:	2b27      	cmp	r3, #39	; 0x27
    5728:	d00f      	beq.n	574a <getSlowDividerConfig+0x32>
    572a:	9b01      	ldr	r3, [sp, #4]
    572c:	2b27      	cmp	r3, #39	; 0x27
    572e:	d80f      	bhi.n	5750 <getSlowDividerConfig+0x38>
    5730:	9b01      	ldr	r3, [sp, #4]
    5732:	2b25      	cmp	r3, #37	; 0x25
    5734:	d003      	beq.n	573e <getSlowDividerConfig+0x26>
    5736:	9b01      	ldr	r3, [sp, #4]
    5738:	2b26      	cmp	r3, #38	; 0x26
    573a:	d003      	beq.n	5744 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    573c:	e008      	b.n	5750 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    573e:	2300      	movs	r3, #0
    5740:	9304      	str	r3, [sp, #16]
            break;
    5742:	e006      	b.n	5752 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5744:	2301      	movs	r3, #1
    5746:	9304      	str	r3, [sp, #16]
            break;
    5748:	e003      	b.n	5752 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    574a:	2302      	movs	r3, #2
    574c:	9304      	str	r3, [sp, #16]
            break;
    574e:	e000      	b.n	5752 <getSlowDividerConfig+0x3a>
                break;
    5750:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5752:	4b40      	ldr	r3, [pc, #256]	; (5854 <getSlowDividerConfig+0x13c>)
    5754:	681b      	ldr	r3, [r3, #0]
    5756:	2b00      	cmp	r3, #0
    5758:	d026      	beq.n	57a8 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    575a:	2300      	movs	r3, #0
    575c:	9303      	str	r3, [sp, #12]
    575e:	e01c      	b.n	579a <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5760:	4b3c      	ldr	r3, [pc, #240]	; (5854 <getSlowDividerConfig+0x13c>)
    5762:	6819      	ldr	r1, [r3, #0]
    5764:	9a03      	ldr	r2, [sp, #12]
    5766:	4613      	mov	r3, r2
    5768:	005b      	lsls	r3, r3, #1
    576a:	4413      	add	r3, r2
    576c:	009b      	lsls	r3, r3, #2
    576e:	440b      	add	r3, r1
    5770:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5774:	681b      	ldr	r3, [r3, #0]
    5776:	9a01      	ldr	r2, [sp, #4]
    5778:	429a      	cmp	r2, r3
    577a:	d10b      	bne.n	5794 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    577c:	4b35      	ldr	r3, [pc, #212]	; (5854 <getSlowDividerConfig+0x13c>)
    577e:	6819      	ldr	r1, [r3, #0]
    5780:	9a03      	ldr	r2, [sp, #12]
    5782:	4613      	mov	r3, r2
    5784:	005b      	lsls	r3, r3, #1
    5786:	4413      	add	r3, r2
    5788:	009b      	lsls	r3, r3, #2
    578a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    578e:	440b      	add	r3, r1
    5790:	9305      	str	r3, [sp, #20]
                break;
    5792:	e009      	b.n	57a8 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5794:	9b03      	ldr	r3, [sp, #12]
    5796:	3301      	adds	r3, #1
    5798:	9303      	str	r3, [sp, #12]
    579a:	4b2e      	ldr	r3, [pc, #184]	; (5854 <getSlowDividerConfig+0x13c>)
    579c:	681b      	ldr	r3, [r3, #0]
    579e:	7b1b      	ldrb	r3, [r3, #12]
    57a0:	461a      	mov	r2, r3
    57a2:	9b03      	ldr	r3, [sp, #12]
    57a4:	4293      	cmp	r3, r2
    57a6:	d3db      	bcc.n	5760 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    57a8:	9b05      	ldr	r3, [sp, #20]
    57aa:	2b00      	cmp	r3, #0
    57ac:	d14a      	bne.n	5844 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    57ae:	9a04      	ldr	r2, [sp, #16]
    57b0:	4613      	mov	r3, r2
    57b2:	005b      	lsls	r3, r3, #1
    57b4:	4413      	add	r3, r2
    57b6:	009b      	lsls	r3, r3, #2
    57b8:	4a27      	ldr	r2, [pc, #156]	; (5858 <getSlowDividerConfig+0x140>)
    57ba:	4413      	add	r3, r2
    57bc:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    57be:	4926      	ldr	r1, [pc, #152]	; (5858 <getSlowDividerConfig+0x140>)
    57c0:	9a04      	ldr	r2, [sp, #16]
    57c2:	4613      	mov	r3, r2
    57c4:	005b      	lsls	r3, r3, #1
    57c6:	4413      	add	r3, r2
    57c8:	009b      	lsls	r3, r3, #2
    57ca:	440b      	add	r3, r1
    57cc:	9a01      	ldr	r2, [sp, #4]
    57ce:	601a      	str	r2, [r3, #0]
        switch(Name)
    57d0:	9b01      	ldr	r3, [sp, #4]
    57d2:	2b27      	cmp	r3, #39	; 0x27
    57d4:	d027      	beq.n	5826 <getSlowDividerConfig+0x10e>
    57d6:	9b01      	ldr	r3, [sp, #4]
    57d8:	2b27      	cmp	r3, #39	; 0x27
    57da:	d835      	bhi.n	5848 <getSlowDividerConfig+0x130>
    57dc:	9b01      	ldr	r3, [sp, #4]
    57de:	2b25      	cmp	r3, #37	; 0x25
    57e0:	d003      	beq.n	57ea <getSlowDividerConfig+0xd2>
    57e2:	9b01      	ldr	r3, [sp, #4]
    57e4:	2b26      	cmp	r3, #38	; 0x26
    57e6:	d00f      	beq.n	5808 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    57e8:	e02e      	b.n	5848 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    57ea:	4b1c      	ldr	r3, [pc, #112]	; (585c <getSlowDividerConfig+0x144>)
    57ec:	695b      	ldr	r3, [r3, #20]
    57ee:	f003 030f 	and.w	r3, r3, #15
    57f2:	1c59      	adds	r1, r3, #1
    57f4:	4818      	ldr	r0, [pc, #96]	; (5858 <getSlowDividerConfig+0x140>)
    57f6:	9a04      	ldr	r2, [sp, #16]
    57f8:	4613      	mov	r3, r2
    57fa:	005b      	lsls	r3, r3, #1
    57fc:	4413      	add	r3, r2
    57fe:	009b      	lsls	r3, r3, #2
    5800:	4403      	add	r3, r0
    5802:	3304      	adds	r3, #4
    5804:	6019      	str	r1, [r3, #0]
                break;
    5806:	e020      	b.n	584a <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    5808:	4b14      	ldr	r3, [pc, #80]	; (585c <getSlowDividerConfig+0x144>)
    580a:	699b      	ldr	r3, [r3, #24]
    580c:	f003 030f 	and.w	r3, r3, #15
    5810:	1c59      	adds	r1, r3, #1
    5812:	4811      	ldr	r0, [pc, #68]	; (5858 <getSlowDividerConfig+0x140>)
    5814:	9a04      	ldr	r2, [sp, #16]
    5816:	4613      	mov	r3, r2
    5818:	005b      	lsls	r3, r3, #1
    581a:	4413      	add	r3, r2
    581c:	009b      	lsls	r3, r3, #2
    581e:	4403      	add	r3, r0
    5820:	3304      	adds	r3, #4
    5822:	6019      	str	r1, [r3, #0]
                break;
    5824:	e011      	b.n	584a <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    5826:	4b0d      	ldr	r3, [pc, #52]	; (585c <getSlowDividerConfig+0x144>)
    5828:	69db      	ldr	r3, [r3, #28]
    582a:	f003 030f 	and.w	r3, r3, #15
    582e:	1c59      	adds	r1, r3, #1
    5830:	4809      	ldr	r0, [pc, #36]	; (5858 <getSlowDividerConfig+0x140>)
    5832:	9a04      	ldr	r2, [sp, #16]
    5834:	4613      	mov	r3, r2
    5836:	005b      	lsls	r3, r3, #1
    5838:	4413      	add	r3, r2
    583a:	009b      	lsls	r3, r3, #2
    583c:	4403      	add	r3, r0
    583e:	3304      	adds	r3, #4
    5840:	6019      	str	r1, [r3, #0]
                break;
    5842:	e002      	b.n	584a <getSlowDividerConfig+0x132>
        }
    }
    5844:	bf00      	nop
    5846:	e000      	b.n	584a <getSlowDividerConfig+0x132>
                break;
    5848:	bf00      	nop

    return ReturnValue;
    584a:	9b05      	ldr	r3, [sp, #20]
}
    584c:	4618      	mov	r0, r3
    584e:	b006      	add	sp, #24
    5850:	4770      	bx	lr
    5852:	bf00      	nop
    5854:	1fff8bb4 	.word	0x1fff8bb4
    5858:	1fff8cc8 	.word	0x1fff8cc8
    585c:	40064000 	.word	0x40064000

00005860 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    5860:	b500      	push	{lr}
    5862:	b083      	sub	sp, #12
    5864:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    5866:	4b64      	ldr	r3, [pc, #400]	; (59f8 <Clock_Ip_ClockInitializeObjects+0x198>)
    5868:	781b      	ldrb	r3, [r3, #0]
    586a:	f083 0301 	eor.w	r3, r3, #1
    586e:	b2db      	uxtb	r3, r3
    5870:	2b00      	cmp	r3, #0
    5872:	d05b      	beq.n	592c <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    5874:	4b60      	ldr	r3, [pc, #384]	; (59f8 <Clock_Ip_ClockInitializeObjects+0x198>)
    5876:	2201      	movs	r2, #1
    5878:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    587a:	4b60      	ldr	r3, [pc, #384]	; (59fc <Clock_Ip_ClockInitializeObjects+0x19c>)
    587c:	785b      	ldrb	r3, [r3, #1]
    587e:	461a      	mov	r2, r3
    5880:	4613      	mov	r3, r2
    5882:	009b      	lsls	r3, r3, #2
    5884:	4413      	add	r3, r2
    5886:	009b      	lsls	r3, r3, #2
    5888:	4a5d      	ldr	r2, [pc, #372]	; (5a00 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    588a:	4413      	add	r3, r2
    588c:	4a5d      	ldr	r2, [pc, #372]	; (5a04 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    588e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    5890:	4b5d      	ldr	r3, [pc, #372]	; (5a08 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    5892:	785b      	ldrb	r3, [r3, #1]
    5894:	461a      	mov	r2, r3
    5896:	4613      	mov	r3, r2
    5898:	009b      	lsls	r3, r3, #2
    589a:	4413      	add	r3, r2
    589c:	009b      	lsls	r3, r3, #2
    589e:	4a5b      	ldr	r2, [pc, #364]	; (5a0c <Clock_Ip_ClockInitializeObjects+0x1ac>)
    58a0:	4413      	add	r3, r2
    58a2:	4a5b      	ldr	r2, [pc, #364]	; (5a10 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    58a4:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    58a6:	4b5b      	ldr	r3, [pc, #364]	; (5a14 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    58a8:	791b      	ldrb	r3, [r3, #4]
    58aa:	461a      	mov	r2, r3
    58ac:	4613      	mov	r3, r2
    58ae:	005b      	lsls	r3, r3, #1
    58b0:	4413      	add	r3, r2
    58b2:	009b      	lsls	r3, r3, #2
    58b4:	4a58      	ldr	r2, [pc, #352]	; (5a18 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    58b6:	4413      	add	r3, r2
    58b8:	4a58      	ldr	r2, [pc, #352]	; (5a1c <Clock_Ip_ClockInitializeObjects+0x1bc>)
    58ba:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    58bc:	4b58      	ldr	r3, [pc, #352]	; (5a20 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    58be:	795b      	ldrb	r3, [r3, #5]
    58c0:	00db      	lsls	r3, r3, #3
    58c2:	4a58      	ldr	r2, [pc, #352]	; (5a24 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    58c4:	4413      	add	r3, r2
    58c6:	4a58      	ldr	r2, [pc, #352]	; (5a28 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    58c8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    58ca:	4b55      	ldr	r3, [pc, #340]	; (5a20 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    58cc:	79db      	ldrb	r3, [r3, #7]
    58ce:	00db      	lsls	r3, r3, #3
    58d0:	4a54      	ldr	r2, [pc, #336]	; (5a24 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    58d2:	4413      	add	r3, r2
    58d4:	4a55      	ldr	r2, [pc, #340]	; (5a2c <Clock_Ip_ClockInitializeObjects+0x1cc>)
    58d6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    58d8:	4b55      	ldr	r3, [pc, #340]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    58da:	799b      	ldrb	r3, [r3, #6]
    58dc:	009b      	lsls	r3, r3, #2
    58de:	4a55      	ldr	r2, [pc, #340]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    58e0:	4413      	add	r3, r2
    58e2:	4a55      	ldr	r2, [pc, #340]	; (5a38 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    58e4:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    58e6:	4b52      	ldr	r3, [pc, #328]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    58e8:	7a1b      	ldrb	r3, [r3, #8]
    58ea:	009b      	lsls	r3, r3, #2
    58ec:	4a51      	ldr	r2, [pc, #324]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    58ee:	4413      	add	r3, r2
    58f0:	4a52      	ldr	r2, [pc, #328]	; (5a3c <Clock_Ip_ClockInitializeObjects+0x1dc>)
    58f2:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    58f4:	4b4e      	ldr	r3, [pc, #312]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    58f6:	7a5b      	ldrb	r3, [r3, #9]
    58f8:	009b      	lsls	r3, r3, #2
    58fa:	4a4e      	ldr	r2, [pc, #312]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    58fc:	4413      	add	r3, r2
    58fe:	4a50      	ldr	r2, [pc, #320]	; (5a40 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    5900:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    5902:	4b4b      	ldr	r3, [pc, #300]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5904:	7adb      	ldrb	r3, [r3, #11]
    5906:	009b      	lsls	r3, r3, #2
    5908:	4a4a      	ldr	r2, [pc, #296]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    590a:	4413      	add	r3, r2
    590c:	4a4d      	ldr	r2, [pc, #308]	; (5a44 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    590e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    5910:	4b47      	ldr	r3, [pc, #284]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5912:	7b1b      	ldrb	r3, [r3, #12]
    5914:	009b      	lsls	r3, r3, #2
    5916:	4a47      	ldr	r2, [pc, #284]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5918:	4413      	add	r3, r2
    591a:	4a4b      	ldr	r2, [pc, #300]	; (5a48 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    591c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    591e:	4b44      	ldr	r3, [pc, #272]	; (5a30 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5920:	7b9b      	ldrb	r3, [r3, #14]
    5922:	009b      	lsls	r3, r3, #2
    5924:	4a43      	ldr	r2, [pc, #268]	; (5a34 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5926:	4413      	add	r3, r2
    5928:	4a48      	ldr	r2, [pc, #288]	; (5a4c <Clock_Ip_ClockInitializeObjects+0x1ec>)
    592a:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    592c:	4b48      	ldr	r3, [pc, #288]	; (5a50 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    592e:	781b      	ldrb	r3, [r3, #0]
    5930:	2b00      	cmp	r3, #0
    5932:	d002      	beq.n	593a <Clock_Ip_ClockInitializeObjects+0xda>
    5934:	9b01      	ldr	r3, [sp, #4]
    5936:	2b00      	cmp	r3, #0
    5938:	d003      	beq.n	5942 <Clock_Ip_ClockInitializeObjects+0xe2>
    593a:	4b46      	ldr	r3, [pc, #280]	; (5a54 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    593c:	781b      	ldrb	r3, [r3, #0]
    593e:	2b00      	cmp	r3, #0
    5940:	d056      	beq.n	59f0 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    5942:	f7ff fc09 	bl	5158 <getFircConfig>
    5946:	4603      	mov	r3, r0
    5948:	4a43      	ldr	r2, [pc, #268]	; (5a58 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    594a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    594c:	f7ff fc60 	bl	5210 <getSoscConfig>
    5950:	4603      	mov	r3, r0
    5952:	4a42      	ldr	r2, [pc, #264]	; (5a5c <Clock_Ip_ClockInitializeObjects+0x1fc>)
    5954:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    5956:	f7ff fca7 	bl	52a8 <getSpllConfig>
    595a:	4603      	mov	r3, r0
    595c:	4a40      	ldr	r2, [pc, #256]	; (5a60 <Clock_Ip_ClockInitializeObjects+0x200>)
    595e:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    5960:	2019      	movs	r0, #25
    5962:	f7ff fcfb 	bl	535c <getSelectorConfig>
    5966:	4603      	mov	r3, r0
    5968:	4a3e      	ldr	r2, [pc, #248]	; (5a64 <Clock_Ip_ClockInitializeObjects+0x204>)
    596a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    596c:	201a      	movs	r0, #26
    596e:	f7ff fcf5 	bl	535c <getSelectorConfig>
    5972:	4603      	mov	r3, r0
    5974:	4a3c      	ldr	r2, [pc, #240]	; (5a68 <Clock_Ip_ClockInitializeObjects+0x208>)
    5976:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    5978:	201b      	movs	r0, #27
    597a:	f7ff fcef 	bl	535c <getSelectorConfig>
    597e:	4603      	mov	r3, r0
    5980:	4a3a      	ldr	r2, [pc, #232]	; (5a6c <Clock_Ip_ClockInitializeObjects+0x20c>)
    5982:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    5984:	201d      	movs	r0, #29
    5986:	f7ff fd7b 	bl	5480 <getCoreDividerConfig>
    598a:	4603      	mov	r3, r0
    598c:	4a38      	ldr	r2, [pc, #224]	; (5a70 <Clock_Ip_ClockInitializeObjects+0x210>)
    598e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    5990:	201e      	movs	r0, #30
    5992:	f7ff fd75 	bl	5480 <getCoreDividerConfig>
    5996:	4603      	mov	r3, r0
    5998:	4a36      	ldr	r2, [pc, #216]	; (5a74 <Clock_Ip_ClockInitializeObjects+0x214>)
    599a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    599c:	201f      	movs	r0, #31
    599e:	f7ff fd6f 	bl	5480 <getCoreDividerConfig>
    59a2:	4603      	mov	r3, r0
    59a4:	4a34      	ldr	r2, [pc, #208]	; (5a78 <Clock_Ip_ClockInitializeObjects+0x218>)
    59a6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    59a8:	2021      	movs	r0, #33	; 0x21
    59aa:	f7ff fe0f 	bl	55cc <getBusDividerConfig>
    59ae:	4603      	mov	r3, r0
    59b0:	4a32      	ldr	r2, [pc, #200]	; (5a7c <Clock_Ip_ClockInitializeObjects+0x21c>)
    59b2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    59b4:	2022      	movs	r0, #34	; 0x22
    59b6:	f7ff fe09 	bl	55cc <getBusDividerConfig>
    59ba:	4603      	mov	r3, r0
    59bc:	4a30      	ldr	r2, [pc, #192]	; (5a80 <Clock_Ip_ClockInitializeObjects+0x220>)
    59be:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    59c0:	2023      	movs	r0, #35	; 0x23
    59c2:	f7ff fe03 	bl	55cc <getBusDividerConfig>
    59c6:	4603      	mov	r3, r0
    59c8:	4a2e      	ldr	r2, [pc, #184]	; (5a84 <Clock_Ip_ClockInitializeObjects+0x224>)
    59ca:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    59cc:	2025      	movs	r0, #37	; 0x25
    59ce:	f7ff fea3 	bl	5718 <getSlowDividerConfig>
    59d2:	4603      	mov	r3, r0
    59d4:	4a2c      	ldr	r2, [pc, #176]	; (5a88 <Clock_Ip_ClockInitializeObjects+0x228>)
    59d6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    59d8:	2026      	movs	r0, #38	; 0x26
    59da:	f7ff fe9d 	bl	5718 <getSlowDividerConfig>
    59de:	4603      	mov	r3, r0
    59e0:	4a2a      	ldr	r2, [pc, #168]	; (5a8c <Clock_Ip_ClockInitializeObjects+0x22c>)
    59e2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    59e4:	2027      	movs	r0, #39	; 0x27
    59e6:	f7ff fe97 	bl	5718 <getSlowDividerConfig>
    59ea:	4603      	mov	r3, r0
    59ec:	4a28      	ldr	r2, [pc, #160]	; (5a90 <Clock_Ip_ClockInitializeObjects+0x230>)
    59ee:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    59f0:	bf00      	nop
    59f2:	b003      	add	sp, #12
    59f4:	f85d fb04 	ldr.w	pc, [sp], #4
    59f8:	1fff8cec 	.word	0x1fff8cec
    59fc:	0000fde4 	.word	0x0000fde4
    5a00:	00010430 	.word	0x00010430
    5a04:	1fff8bb8 	.word	0x1fff8bb8
    5a08:	0000fda4 	.word	0x0000fda4
    5a0c:	00010378 	.word	0x00010378
    5a10:	1fff8bbc 	.word	0x1fff8bbc
    5a14:	0000fdb4 	.word	0x0000fdb4
    5a18:	000103e4 	.word	0x000103e4
    5a1c:	1fff8bc0 	.word	0x1fff8bc0
    5a20:	0000fdf4 	.word	0x0000fdf4
    5a24:	0001045c 	.word	0x0001045c
    5a28:	1fff8bc4 	.word	0x1fff8bc4
    5a2c:	1fff8c00 	.word	0x1fff8c00
    5a30:	0000fd84 	.word	0x0000fd84
    5a34:	00010334 	.word	0x00010334
    5a38:	1fff8bc8 	.word	0x1fff8bc8
    5a3c:	1fff8c04 	.word	0x1fff8c04
    5a40:	1fff8bcc 	.word	0x1fff8bcc
    5a44:	1fff8c08 	.word	0x1fff8c08
    5a48:	1fff8bd0 	.word	0x1fff8bd0
    5a4c:	1fff8c0c 	.word	0x1fff8c0c
    5a50:	1fff8b19 	.word	0x1fff8b19
    5a54:	1fff8b10 	.word	0x1fff8b10
    5a58:	1fff8bd4 	.word	0x1fff8bd4
    5a5c:	1fff8bd8 	.word	0x1fff8bd8
    5a60:	1fff8bdc 	.word	0x1fff8bdc
    5a64:	1fff8be0 	.word	0x1fff8be0
    5a68:	1fff8be4 	.word	0x1fff8be4
    5a6c:	1fff8c10 	.word	0x1fff8c10
    5a70:	1fff8be8 	.word	0x1fff8be8
    5a74:	1fff8bec 	.word	0x1fff8bec
    5a78:	1fff8c14 	.word	0x1fff8c14
    5a7c:	1fff8bf0 	.word	0x1fff8bf0
    5a80:	1fff8bf4 	.word	0x1fff8bf4
    5a84:	1fff8c18 	.word	0x1fff8c18
    5a88:	1fff8bf8 	.word	0x1fff8bf8
    5a8c:	1fff8bfc 	.word	0x1fff8bfc
    5a90:	1fff8c1c 	.word	0x1fff8c1c

00005a94 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    5a94:	b500      	push	{lr}
    5a96:	b083      	sub	sp, #12
    5a98:	9001      	str	r0, [sp, #4]
    5a9a:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    5a9c:	9b01      	ldr	r3, [sp, #4]
    5a9e:	2b03      	cmp	r3, #3
    5aa0:	f000 8090 	beq.w	5bc4 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    5aa4:	9b01      	ldr	r3, [sp, #4]
    5aa6:	2b03      	cmp	r3, #3
    5aa8:	f200 80d3 	bhi.w	5c52 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    5aac:	9b01      	ldr	r3, [sp, #4]
    5aae:	2b00      	cmp	r3, #0
    5ab0:	d040      	beq.n	5b34 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    5ab2:	9b01      	ldr	r3, [sp, #4]
    5ab4:	3b01      	subs	r3, #1
    5ab6:	2b01      	cmp	r3, #1
    5ab8:	f200 80cb 	bhi.w	5c52 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    5abc:	9b00      	ldr	r3, [sp, #0]
    5abe:	2b00      	cmp	r3, #0
    5ac0:	f040 80c9 	bne.w	5c56 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    5ac4:	4b68      	ldr	r3, [pc, #416]	; (5c68 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5ac6:	2200      	movs	r2, #0
    5ac8:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    5aca:	4b68      	ldr	r3, [pc, #416]	; (5c6c <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    5acc:	681b      	ldr	r3, [r3, #0]
    5ace:	685b      	ldr	r3, [r3, #4]
    5ad0:	4a67      	ldr	r2, [pc, #412]	; (5c70 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    5ad2:	6812      	ldr	r2, [r2, #0]
    5ad4:	4610      	mov	r0, r2
    5ad6:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    5ad8:	4b66      	ldr	r3, [pc, #408]	; (5c74 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    5ada:	681b      	ldr	r3, [r3, #0]
    5adc:	681b      	ldr	r3, [r3, #0]
    5ade:	4a66      	ldr	r2, [pc, #408]	; (5c78 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    5ae0:	6812      	ldr	r2, [r2, #0]
    5ae2:	4610      	mov	r0, r2
    5ae4:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    5ae6:	4b65      	ldr	r3, [pc, #404]	; (5c7c <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    5ae8:	681b      	ldr	r3, [r3, #0]
    5aea:	681b      	ldr	r3, [r3, #0]
    5aec:	4a64      	ldr	r2, [pc, #400]	; (5c80 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    5aee:	6812      	ldr	r2, [r2, #0]
    5af0:	4610      	mov	r0, r2
    5af2:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    5af4:	4b63      	ldr	r3, [pc, #396]	; (5c84 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    5af6:	681b      	ldr	r3, [r3, #0]
    5af8:	681b      	ldr	r3, [r3, #0]
    5afa:	4a63      	ldr	r2, [pc, #396]	; (5c88 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    5afc:	6812      	ldr	r2, [r2, #0]
    5afe:	4610      	mov	r0, r2
    5b00:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    5b02:	4b62      	ldr	r3, [pc, #392]	; (5c8c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5b04:	681b      	ldr	r3, [r3, #0]
    5b06:	691b      	ldr	r3, [r3, #16]
    5b08:	4a61      	ldr	r2, [pc, #388]	; (5c90 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5b0a:	6812      	ldr	r2, [r2, #0]
    5b0c:	6812      	ldr	r2, [r2, #0]
    5b0e:	4610      	mov	r0, r2
    5b10:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    5b12:	4b60      	ldr	r3, [pc, #384]	; (5c94 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5b14:	681b      	ldr	r3, [r3, #0]
    5b16:	68db      	ldr	r3, [r3, #12]
    5b18:	4a5f      	ldr	r2, [pc, #380]	; (5c98 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5b1a:	6812      	ldr	r2, [r2, #0]
    5b1c:	6812      	ldr	r2, [r2, #0]
    5b1e:	4610      	mov	r0, r2
    5b20:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    5b22:	4b5e      	ldr	r3, [pc, #376]	; (5c9c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5b24:	681b      	ldr	r3, [r3, #0]
    5b26:	689b      	ldr	r3, [r3, #8]
    5b28:	4a5d      	ldr	r2, [pc, #372]	; (5ca0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5b2a:	6812      	ldr	r2, [r2, #0]
    5b2c:	6812      	ldr	r2, [r2, #0]
    5b2e:	4610      	mov	r0, r2
    5b30:	4798      	blx	r3
            }
        }
        break;
    5b32:	e090      	b.n	5c56 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    5b34:	9b00      	ldr	r3, [sp, #0]
    5b36:	2b02      	cmp	r3, #2
    5b38:	f040 808f 	bne.w	5c5a <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    5b3c:	4b4a      	ldr	r3, [pc, #296]	; (5c68 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5b3e:	2201      	movs	r2, #1
    5b40:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    5b42:	4b56      	ldr	r3, [pc, #344]	; (5c9c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5b44:	681b      	ldr	r3, [r3, #0]
    5b46:	685b      	ldr	r3, [r3, #4]
    5b48:	4a55      	ldr	r2, [pc, #340]	; (5ca0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5b4a:	6812      	ldr	r2, [r2, #0]
    5b4c:	4610      	mov	r0, r2
    5b4e:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    5b50:	4b50      	ldr	r3, [pc, #320]	; (5c94 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5b52:	681b      	ldr	r3, [r3, #0]
    5b54:	691b      	ldr	r3, [r3, #16]
    5b56:	4a50      	ldr	r2, [pc, #320]	; (5c98 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5b58:	6812      	ldr	r2, [r2, #0]
    5b5a:	4610      	mov	r0, r2
    5b5c:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5b5e:	4b4d      	ldr	r3, [pc, #308]	; (5c94 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5b60:	681b      	ldr	r3, [r3, #0]
    5b62:	689b      	ldr	r3, [r3, #8]
    5b64:	4a4c      	ldr	r2, [pc, #304]	; (5c98 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5b66:	6812      	ldr	r2, [r2, #0]
    5b68:	4610      	mov	r0, r2
    5b6a:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5b6c:	4b47      	ldr	r3, [pc, #284]	; (5c8c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5b6e:	681b      	ldr	r3, [r3, #0]
    5b70:	68db      	ldr	r3, [r3, #12]
    5b72:	4a47      	ldr	r2, [pc, #284]	; (5c90 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5b74:	6812      	ldr	r2, [r2, #0]
    5b76:	4610      	mov	r0, r2
    5b78:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    5b7a:	4b44      	ldr	r3, [pc, #272]	; (5c8c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5b7c:	681b      	ldr	r3, [r3, #0]
    5b7e:	689b      	ldr	r3, [r3, #8]
    5b80:	4a43      	ldr	r2, [pc, #268]	; (5c90 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5b82:	6812      	ldr	r2, [r2, #0]
    5b84:	6812      	ldr	r2, [r2, #0]
    5b86:	4610      	mov	r0, r2
    5b88:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    5b8a:	4b38      	ldr	r3, [pc, #224]	; (5c6c <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    5b8c:	681b      	ldr	r3, [r3, #0]
    5b8e:	685b      	ldr	r3, [r3, #4]
    5b90:	4a44      	ldr	r2, [pc, #272]	; (5ca4 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    5b92:	6812      	ldr	r2, [r2, #0]
    5b94:	4610      	mov	r0, r2
    5b96:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    5b98:	4b36      	ldr	r3, [pc, #216]	; (5c74 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    5b9a:	681b      	ldr	r3, [r3, #0]
    5b9c:	681b      	ldr	r3, [r3, #0]
    5b9e:	4a42      	ldr	r2, [pc, #264]	; (5ca8 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    5ba0:	6812      	ldr	r2, [r2, #0]
    5ba2:	4610      	mov	r0, r2
    5ba4:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    5ba6:	4b35      	ldr	r3, [pc, #212]	; (5c7c <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    5ba8:	681b      	ldr	r3, [r3, #0]
    5baa:	681b      	ldr	r3, [r3, #0]
    5bac:	4a3f      	ldr	r2, [pc, #252]	; (5cac <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    5bae:	6812      	ldr	r2, [r2, #0]
    5bb0:	4610      	mov	r0, r2
    5bb2:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    5bb4:	4b33      	ldr	r3, [pc, #204]	; (5c84 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    5bb6:	681b      	ldr	r3, [r3, #0]
    5bb8:	681b      	ldr	r3, [r3, #0]
    5bba:	4a3d      	ldr	r2, [pc, #244]	; (5cb0 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    5bbc:	6812      	ldr	r2, [r2, #0]
    5bbe:	4610      	mov	r0, r2
    5bc0:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    5bc2:	e04a      	b.n	5c5a <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    5bc4:	9b00      	ldr	r3, [sp, #0]
    5bc6:	2b02      	cmp	r3, #2
    5bc8:	d149      	bne.n	5c5e <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    5bca:	4b27      	ldr	r3, [pc, #156]	; (5c68 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5bcc:	2201      	movs	r2, #1
    5bce:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    5bd0:	4b32      	ldr	r3, [pc, #200]	; (5c9c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5bd2:	681b      	ldr	r3, [r3, #0]
    5bd4:	685b      	ldr	r3, [r3, #4]
    5bd6:	4a32      	ldr	r2, [pc, #200]	; (5ca0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5bd8:	6812      	ldr	r2, [r2, #0]
    5bda:	4610      	mov	r0, r2
    5bdc:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    5bde:	4b2d      	ldr	r3, [pc, #180]	; (5c94 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5be0:	681b      	ldr	r3, [r3, #0]
    5be2:	691b      	ldr	r3, [r3, #16]
    5be4:	4a2c      	ldr	r2, [pc, #176]	; (5c98 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5be6:	6812      	ldr	r2, [r2, #0]
    5be8:	4610      	mov	r0, r2
    5bea:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5bec:	4b29      	ldr	r3, [pc, #164]	; (5c94 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5bee:	681b      	ldr	r3, [r3, #0]
    5bf0:	689b      	ldr	r3, [r3, #8]
    5bf2:	4a29      	ldr	r2, [pc, #164]	; (5c98 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5bf4:	6812      	ldr	r2, [r2, #0]
    5bf6:	4610      	mov	r0, r2
    5bf8:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5bfa:	4b24      	ldr	r3, [pc, #144]	; (5c8c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5bfc:	681b      	ldr	r3, [r3, #0]
    5bfe:	68db      	ldr	r3, [r3, #12]
    5c00:	4a23      	ldr	r2, [pc, #140]	; (5c90 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5c02:	6812      	ldr	r2, [r2, #0]
    5c04:	4610      	mov	r0, r2
    5c06:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    5c08:	4b20      	ldr	r3, [pc, #128]	; (5c8c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5c0a:	681b      	ldr	r3, [r3, #0]
    5c0c:	689b      	ldr	r3, [r3, #8]
    5c0e:	4a20      	ldr	r2, [pc, #128]	; (5c90 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5c10:	6812      	ldr	r2, [r2, #0]
    5c12:	6812      	ldr	r2, [r2, #0]
    5c14:	4610      	mov	r0, r2
    5c16:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    5c18:	4b26      	ldr	r3, [pc, #152]	; (5cb4 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    5c1a:	681b      	ldr	r3, [r3, #0]
    5c1c:	685b      	ldr	r3, [r3, #4]
    5c1e:	4a26      	ldr	r2, [pc, #152]	; (5cb8 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    5c20:	6812      	ldr	r2, [r2, #0]
    5c22:	4610      	mov	r0, r2
    5c24:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    5c26:	4b25      	ldr	r3, [pc, #148]	; (5cbc <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    5c28:	681b      	ldr	r3, [r3, #0]
    5c2a:	681b      	ldr	r3, [r3, #0]
    5c2c:	4a24      	ldr	r2, [pc, #144]	; (5cc0 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    5c2e:	6812      	ldr	r2, [r2, #0]
    5c30:	4610      	mov	r0, r2
    5c32:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    5c34:	4b23      	ldr	r3, [pc, #140]	; (5cc4 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    5c36:	681b      	ldr	r3, [r3, #0]
    5c38:	681b      	ldr	r3, [r3, #0]
    5c3a:	4a23      	ldr	r2, [pc, #140]	; (5cc8 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    5c3c:	6812      	ldr	r2, [r2, #0]
    5c3e:	4610      	mov	r0, r2
    5c40:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    5c42:	4b22      	ldr	r3, [pc, #136]	; (5ccc <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    5c44:	681b      	ldr	r3, [r3, #0]
    5c46:	681b      	ldr	r3, [r3, #0]
    5c48:	4a21      	ldr	r2, [pc, #132]	; (5cd0 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    5c4a:	6812      	ldr	r2, [r2, #0]
    5c4c:	4610      	mov	r0, r2
    5c4e:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    5c50:	e005      	b.n	5c5e <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    5c52:	bf00      	nop
    5c54:	e004      	b.n	5c60 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5c56:	bf00      	nop
    5c58:	e002      	b.n	5c60 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5c5a:	bf00      	nop
    5c5c:	e000      	b.n	5c60 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5c5e:	bf00      	nop
    }

}
    5c60:	bf00      	nop
    5c62:	b003      	add	sp, #12
    5c64:	f85d fb04 	ldr.w	pc, [sp], #4
    5c68:	1fff8b19 	.word	0x1fff8b19
    5c6c:	1fff8bc4 	.word	0x1fff8bc4
    5c70:	1fff8be4 	.word	0x1fff8be4
    5c74:	1fff8bc8 	.word	0x1fff8bc8
    5c78:	1fff8bec 	.word	0x1fff8bec
    5c7c:	1fff8bcc 	.word	0x1fff8bcc
    5c80:	1fff8bf4 	.word	0x1fff8bf4
    5c84:	1fff8bd0 	.word	0x1fff8bd0
    5c88:	1fff8bfc 	.word	0x1fff8bfc
    5c8c:	1fff8bb8 	.word	0x1fff8bb8
    5c90:	1fff8bdc 	.word	0x1fff8bdc
    5c94:	1fff8bbc 	.word	0x1fff8bbc
    5c98:	1fff8bd8 	.word	0x1fff8bd8
    5c9c:	1fff8bc0 	.word	0x1fff8bc0
    5ca0:	1fff8bd4 	.word	0x1fff8bd4
    5ca4:	1fff8be0 	.word	0x1fff8be0
    5ca8:	1fff8be8 	.word	0x1fff8be8
    5cac:	1fff8bf0 	.word	0x1fff8bf0
    5cb0:	1fff8bf8 	.word	0x1fff8bf8
    5cb4:	1fff8c00 	.word	0x1fff8c00
    5cb8:	1fff8c10 	.word	0x1fff8c10
    5cbc:	1fff8c04 	.word	0x1fff8c04
    5cc0:	1fff8c14 	.word	0x1fff8c14
    5cc4:	1fff8c08 	.word	0x1fff8c08
    5cc8:	1fff8c18 	.word	0x1fff8c18
    5ccc:	1fff8c0c 	.word	0x1fff8c0c
    5cd0:	1fff8c1c 	.word	0x1fff8c1c

00005cd4 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    5cd4:	b500      	push	{lr}
    5cd6:	b083      	sub	sp, #12
    5cd8:	9001      	str	r0, [sp, #4]
    5cda:	9100      	str	r1, [sp, #0]
    switch(Command)
    5cdc:	9b00      	ldr	r3, [sp, #0]
    5cde:	2b04      	cmp	r3, #4
    5ce0:	d010      	beq.n	5d04 <Clock_Ip_Command+0x30>
    5ce2:	9b00      	ldr	r3, [sp, #0]
    5ce4:	2b04      	cmp	r3, #4
    5ce6:	d811      	bhi.n	5d0c <Clock_Ip_Command+0x38>
    5ce8:	9b00      	ldr	r3, [sp, #0]
    5cea:	2b01      	cmp	r3, #1
    5cec:	d006      	beq.n	5cfc <Clock_Ip_Command+0x28>
    5cee:	9b00      	ldr	r3, [sp, #0]
    5cf0:	2b02      	cmp	r3, #2
    5cf2:	d10b      	bne.n	5d0c <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    5cf4:	9801      	ldr	r0, [sp, #4]
    5cf6:	f7ff fdb3 	bl	5860 <Clock_Ip_ClockInitializeObjects>
            break;
    5cfa:	e008      	b.n	5d0e <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    5cfc:	9801      	ldr	r0, [sp, #4]
    5cfe:	f7ff f9db 	bl	50b8 <Clock_Ip_SpecificPlatformInitClock>
            break;
    5d02:	e004      	b.n	5d0e <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    5d04:	9801      	ldr	r0, [sp, #4]
    5d06:	f7ff f8ed 	bl	4ee4 <DisableSafeClock>
            break;
    5d0a:	e000      	b.n	5d0e <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    5d0c:	bf00      	nop
    }
}
    5d0e:	bf00      	nop
    5d10:	b003      	add	sp, #12
    5d12:	f85d fb04 	ldr.w	pc, [sp], #4
    5d16:	bf00      	nop

00005d18 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    5d18:	b500      	push	{lr}
    5d1a:	b085      	sub	sp, #20
    5d1c:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    5d1e:	4a20      	ldr	r2, [pc, #128]	; (5da0 <Mcu_Init+0x88>)
    5d20:	9b01      	ldr	r3, [sp, #4]
    5d22:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5d24:	2300      	movs	r3, #0
    5d26:	9303      	str	r3, [sp, #12]
    5d28:	e010      	b.n	5d4c <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    5d2a:	4b1d      	ldr	r3, [pc, #116]	; (5da0 <Mcu_Init+0x88>)
    5d2c:	681b      	ldr	r3, [r3, #0]
    5d2e:	6919      	ldr	r1, [r3, #16]
    5d30:	9a03      	ldr	r2, [sp, #12]
    5d32:	4613      	mov	r3, r2
    5d34:	005b      	lsls	r3, r3, #1
    5d36:	4413      	add	r3, r2
    5d38:	009b      	lsls	r3, r3, #2
    5d3a:	440b      	add	r3, r1
    5d3c:	681b      	ldr	r3, [r3, #0]
    5d3e:	9a03      	ldr	r2, [sp, #12]
    5d40:	b2d1      	uxtb	r1, r2
    5d42:	4a18      	ldr	r2, [pc, #96]	; (5da4 <Mcu_Init+0x8c>)
    5d44:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5d46:	9b03      	ldr	r3, [sp, #12]
    5d48:	3301      	adds	r3, #1
    5d4a:	9303      	str	r3, [sp, #12]
    5d4c:	4b14      	ldr	r3, [pc, #80]	; (5da0 <Mcu_Init+0x88>)
    5d4e:	681b      	ldr	r3, [r3, #0]
    5d50:	689b      	ldr	r3, [r3, #8]
    5d52:	9a03      	ldr	r2, [sp, #12]
    5d54:	429a      	cmp	r2, r3
    5d56:	d3e8      	bcc.n	5d2a <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5d58:	2300      	movs	r3, #0
    5d5a:	9303      	str	r3, [sp, #12]
    5d5c:	e010      	b.n	5d80 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    5d5e:	4b10      	ldr	r3, [pc, #64]	; (5da0 <Mcu_Init+0x88>)
    5d60:	681b      	ldr	r3, [r3, #0]
    5d62:	6959      	ldr	r1, [r3, #20]
    5d64:	9a03      	ldr	r2, [sp, #12]
    5d66:	4613      	mov	r3, r2
    5d68:	01db      	lsls	r3, r3, #7
    5d6a:	1a9b      	subs	r3, r3, r2
    5d6c:	00db      	lsls	r3, r3, #3
    5d6e:	440b      	add	r3, r1
    5d70:	681b      	ldr	r3, [r3, #0]
    5d72:	9a03      	ldr	r2, [sp, #12]
    5d74:	b2d1      	uxtb	r1, r2
    5d76:	4a0c      	ldr	r2, [pc, #48]	; (5da8 <Mcu_Init+0x90>)
    5d78:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5d7a:	9b03      	ldr	r3, [sp, #12]
    5d7c:	3301      	adds	r3, #1
    5d7e:	9303      	str	r3, [sp, #12]
    5d80:	4b07      	ldr	r3, [pc, #28]	; (5da0 <Mcu_Init+0x88>)
    5d82:	681b      	ldr	r3, [r3, #0]
    5d84:	68db      	ldr	r3, [r3, #12]
    5d86:	9a03      	ldr	r2, [sp, #12]
    5d88:	429a      	cmp	r2, r3
    5d8a:	d3e8      	bcc.n	5d5e <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    5d8c:	4b04      	ldr	r3, [pc, #16]	; (5da0 <Mcu_Init+0x88>)
    5d8e:	681b      	ldr	r3, [r3, #0]
    5d90:	699b      	ldr	r3, [r3, #24]
    5d92:	4618      	mov	r0, r3
    5d94:	f000 f88a 	bl	5eac <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5d98:	bf00      	nop
    5d9a:	b005      	add	sp, #20
    5d9c:	f85d fb04 	ldr.w	pc, [sp], #4
    5da0:	1fff8cf8 	.word	0x1fff8cf8
    5da4:	1fff8cf4 	.word	0x1fff8cf4
    5da8:	1fff8cf0 	.word	0x1fff8cf0

00005dac <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    5dac:	b084      	sub	sp, #16
    5dae:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    5db0:	2301      	movs	r3, #1
    5db2:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    5db6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5dba:	4618      	mov	r0, r3
    5dbc:	b004      	add	sp, #16
    5dbe:	4770      	bx	lr

00005dc0 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    5dc0:	b500      	push	{lr}
    5dc2:	b085      	sub	sp, #20
    5dc4:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    5dc6:	4a0e      	ldr	r2, [pc, #56]	; (5e00 <Mcu_InitClock+0x40>)
    5dc8:	9b01      	ldr	r3, [sp, #4]
    5dca:	4413      	add	r3, r2
    5dcc:	781b      	ldrb	r3, [r3, #0]
    5dce:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    5dd2:	4b0c      	ldr	r3, [pc, #48]	; (5e04 <Mcu_InitClock+0x44>)
    5dd4:	681b      	ldr	r3, [r3, #0]
    5dd6:	6959      	ldr	r1, [r3, #20]
    5dd8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5ddc:	4613      	mov	r3, r2
    5dde:	01db      	lsls	r3, r3, #7
    5de0:	1a9b      	subs	r3, r3, r2
    5de2:	00db      	lsls	r3, r3, #3
    5de4:	440b      	add	r3, r1
    5de6:	4618      	mov	r0, r3
    5de8:	f000 f86a 	bl	5ec0 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    5dec:	2300      	movs	r3, #0
    5dee:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    5df2:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    5df6:	4618      	mov	r0, r3
    5df8:	b005      	add	sp, #20
    5dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    5dfe:	bf00      	nop
    5e00:	1fff8cf0 	.word	0x1fff8cf0
    5e04:	1fff8cf8 	.word	0x1fff8cf8

00005e08 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    5e08:	b500      	push	{lr}
    5e0a:	b085      	sub	sp, #20
    5e0c:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    5e0e:	4a0d      	ldr	r2, [pc, #52]	; (5e44 <Mcu_SetMode+0x3c>)
    5e10:	9b01      	ldr	r3, [sp, #4]
    5e12:	4413      	add	r3, r2
    5e14:	781b      	ldrb	r3, [r3, #0]
    5e16:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    5e1a:	f008 fa3b 	bl	e294 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    5e1e:	4b0a      	ldr	r3, [pc, #40]	; (5e48 <Mcu_SetMode+0x40>)
    5e20:	681b      	ldr	r3, [r3, #0]
    5e22:	6919      	ldr	r1, [r3, #16]
    5e24:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5e28:	4613      	mov	r3, r2
    5e2a:	005b      	lsls	r3, r3, #1
    5e2c:	4413      	add	r3, r2
    5e2e:	009b      	lsls	r3, r3, #2
    5e30:	440b      	add	r3, r1
    5e32:	4618      	mov	r0, r3
    5e34:	f000 f84e 	bl	5ed4 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    5e38:	f008 fa58 	bl	e2ec <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5e3c:	bf00      	nop
    5e3e:	b005      	add	sp, #20
    5e40:	f85d fb04 	ldr.w	pc, [sp], #4
    5e44:	1fff8cf4 	.word	0x1fff8cf4
    5e48:	1fff8cf8 	.word	0x1fff8cf8

00005e4c <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    5e4c:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    5e4e:	2302      	movs	r3, #2
    5e50:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    5e52:	9b01      	ldr	r3, [sp, #4]
}
    5e54:	4618      	mov	r0, r3
    5e56:	b002      	add	sp, #8
    5e58:	4770      	bx	lr

00005e5a <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    5e5a:	b500      	push	{lr}
    5e5c:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    5e5e:	f000 f843 	bl	5ee8 <Mcu_Ipw_GetResetReason>
    5e62:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    5e64:	9b01      	ldr	r3, [sp, #4]
}
    5e66:	4618      	mov	r0, r3
    5e68:	b003      	add	sp, #12
    5e6a:	f85d fb04 	ldr.w	pc, [sp], #4

00005e6e <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    5e6e:	b500      	push	{lr}
    5e70:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    5e72:	f000 f83f 	bl	5ef4 <Mcu_Ipw_GetResetRawValue>
    5e76:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    5e78:	9b01      	ldr	r3, [sp, #4]
}
    5e7a:	4618      	mov	r0, r3
    5e7c:	b003      	add	sp, #12
    5e7e:	f85d fb04 	ldr.w	pc, [sp], #4

00005e82 <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5e82:	b500      	push	{lr}
    5e84:	b083      	sub	sp, #12
    5e86:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    5e88:	9801      	ldr	r0, [sp, #4]
    5e8a:	f000 f839 	bl	5f00 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    5e8e:	bf00      	nop
    5e90:	b003      	add	sp, #12
    5e92:	f85d fb04 	ldr.w	pc, [sp], #4

00005e96 <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    5e96:	b082      	sub	sp, #8
    5e98:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    5e9a:	4b03      	ldr	r3, [pc, #12]	; (5ea8 <Mcu_ClkSrcFailureNotification+0x12>)
    5e9c:	681b      	ldr	r3, [r3, #0]
    5e9e:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    5ea0:	bf00      	nop
    5ea2:	b002      	add	sp, #8
    5ea4:	4770      	bx	lr
    5ea6:	bf00      	nop
    5ea8:	1fff8cf8 	.word	0x1fff8cf8

00005eac <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    5eac:	b500      	push	{lr}
    5eae:	b083      	sub	sp, #12
    5eb0:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    5eb2:	9801      	ldr	r0, [sp, #4]
    5eb4:	f000 f882 	bl	5fbc <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    5eb8:	bf00      	nop
    5eba:	b003      	add	sp, #12
    5ebc:	f85d fb04 	ldr.w	pc, [sp], #4

00005ec0 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    5ec0:	b500      	push	{lr}
    5ec2:	b083      	sub	sp, #12
    5ec4:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    5ec6:	9801      	ldr	r0, [sp, #4]
    5ec8:	f7fc fc6a 	bl	27a0 <Clock_Ip_InitClock>
}
    5ecc:	bf00      	nop
    5ece:	b003      	add	sp, #12
    5ed0:	f85d fb04 	ldr.w	pc, [sp], #4

00005ed4 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    5ed4:	b500      	push	{lr}
    5ed6:	b083      	sub	sp, #12
    5ed8:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    5eda:	9801      	ldr	r0, [sp, #4]
    5edc:	f000 f820 	bl	5f20 <Power_Ip_SetMode>
}
    5ee0:	bf00      	nop
    5ee2:	b003      	add	sp, #12
    5ee4:	f85d fb04 	ldr.w	pc, [sp], #4

00005ee8 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    5ee8:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    5eea:	f000 f84f 	bl	5f8c <Power_Ip_GetResetReason>
    5eee:	4603      	mov	r3, r0
}
    5ef0:	4618      	mov	r0, r3
    5ef2:	bd08      	pop	{r3, pc}

00005ef4 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    5ef4:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    5ef6:	f000 f857 	bl	5fa8 <Power_Ip_GetResetRawValue>
    5efa:	4603      	mov	r3, r0
}
    5efc:	4618      	mov	r0, r3
    5efe:	bd08      	pop	{r3, pc}

00005f00 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5f00:	b500      	push	{lr}
    5f02:	b083      	sub	sp, #12
    5f04:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    5f06:	9b01      	ldr	r3, [sp, #4]
    5f08:	2b00      	cmp	r3, #0
    5f0a:	d102      	bne.n	5f12 <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    5f0c:	f000 f86c 	bl	5fe8 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    5f10:	e001      	b.n	5f16 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    5f12:	f000 f86e 	bl	5ff2 <Power_Ip_EnableSleepOnExit>
}
    5f16:	bf00      	nop
    5f18:	b003      	add	sp, #12
    5f1a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005f20 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    5f20:	b500      	push	{lr}
    5f22:	b085      	sub	sp, #20
    5f24:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    5f26:	9b01      	ldr	r3, [sp, #4]
    5f28:	685b      	ldr	r3, [r3, #4]
    5f2a:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    5f2c:	9802      	ldr	r0, [sp, #8]
    5f2e:	f000 f9f5 	bl	631c <Power_Ip_SMC_ModeCheckEntry>
    5f32:	4603      	mov	r3, r0
    5f34:	2b00      	cmp	r3, #0
    5f36:	d002      	beq.n	5f3e <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5f38:	2301      	movs	r3, #1
    5f3a:	9303      	str	r3, [sp, #12]
    5f3c:	e003      	b.n	5f46 <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    5f3e:	9801      	ldr	r0, [sp, #4]
    5f40:	f000 fa1e 	bl	6380 <Power_Ip_SMC_ModeConfig>
    5f44:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    5f46:	9b03      	ldr	r3, [sp, #12]
    5f48:	2b01      	cmp	r3, #1
    5f4a:	d103      	bne.n	5f54 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5f4c:	21ff      	movs	r1, #255	; 0xff
    5f4e:	2003      	movs	r0, #3
    5f50:	f000 f8f4 	bl	613c <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    5f54:	bf00      	nop
    5f56:	b005      	add	sp, #20
    5f58:	f85d fb04 	ldr.w	pc, [sp], #4

00005f5c <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    5f5c:	b084      	sub	sp, #16
    5f5e:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    5f60:	230c      	movs	r3, #12
    5f62:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    5f64:	4a08      	ldr	r2, [pc, #32]	; (5f88 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5f66:	9b01      	ldr	r3, [sp, #4]
    5f68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f6c:	2b0e      	cmp	r3, #14
    5f6e:	d805      	bhi.n	5f7c <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    5f70:	4a05      	ldr	r2, [pc, #20]	; (5f88 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5f72:	9b01      	ldr	r3, [sp, #4]
    5f74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f78:	9303      	str	r3, [sp, #12]
    5f7a:	e001      	b.n	5f80 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    5f7c:	230c      	movs	r3, #12
    5f7e:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    5f80:	9b03      	ldr	r3, [sp, #12]
}
    5f82:	4618      	mov	r0, r3
    5f84:	b004      	add	sp, #16
    5f86:	4770      	bx	lr
    5f88:	000104d0 	.word	0x000104d0

00005f8c <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    5f8c:	b500      	push	{lr}
    5f8e:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    5f90:	f000 f940 	bl	6214 <Power_Ip_RCM_GetResetReason>
    5f94:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    5f96:	9801      	ldr	r0, [sp, #4]
    5f98:	f7ff ffe0 	bl	5f5c <Power_Ip_ConvertIntergeToResetType>
    5f9c:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    5f9e:	9b00      	ldr	r3, [sp, #0]
}
    5fa0:	4618      	mov	r0, r3
    5fa2:	b003      	add	sp, #12
    5fa4:	f85d fb04 	ldr.w	pc, [sp], #4

00005fa8 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    5fa8:	b500      	push	{lr}
    5faa:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    5fac:	f000 f98a 	bl	62c4 <Power_Ip_RCM_GetResetRawValue>
    5fb0:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    5fb2:	9b01      	ldr	r3, [sp, #4]
}
    5fb4:	4618      	mov	r0, r3
    5fb6:	b003      	add	sp, #12
    5fb8:	f85d fb04 	ldr.w	pc, [sp], #4

00005fbc <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    5fbc:	b500      	push	{lr}
    5fbe:	b083      	sub	sp, #12
    5fc0:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    5fc2:	9b01      	ldr	r3, [sp, #4]
    5fc4:	681b      	ldr	r3, [r3, #0]
    5fc6:	4618      	mov	r0, r3
    5fc8:	f000 f90e 	bl	61e8 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    5fcc:	9b01      	ldr	r3, [sp, #4]
    5fce:	685b      	ldr	r3, [r3, #4]
    5fd0:	4618      	mov	r0, r3
    5fd2:	f000 f86d 	bl	60b0 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    5fd6:	9b01      	ldr	r3, [sp, #4]
    5fd8:	689b      	ldr	r3, [r3, #8]
    5fda:	4618      	mov	r0, r3
    5fdc:	f000 f990 	bl	6300 <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    5fe0:	bf00      	nop
    5fe2:	b003      	add	sp, #12
    5fe4:	f85d fb04 	ldr.w	pc, [sp], #4

00005fe8 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    5fe8:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    5fea:	f000 f811 	bl	6010 <Power_Ip_CM4_DisableSleepOnExit>
}
    5fee:	bf00      	nop
    5ff0:	bd08      	pop	{r3, pc}

00005ff2 <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    5ff2:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    5ff4:	f000 f820 	bl	6038 <Power_Ip_CM4_EnableSleepOnExit>
}
    5ff8:	bf00      	nop
    5ffa:	bd08      	pop	{r3, pc}

00005ffc <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    5ffc:	b082      	sub	sp, #8
    5ffe:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    6000:	4a02      	ldr	r2, [pc, #8]	; (600c <Power_Ip_InstallNotificationsCallback+0x10>)
    6002:	9b01      	ldr	r3, [sp, #4]
    6004:	6013      	str	r3, [r2, #0]
}
    6006:	bf00      	nop
    6008:	b002      	add	sp, #8
    600a:	4770      	bx	lr
    600c:	1fff8b1c 	.word	0x1fff8b1c

00006010 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    6010:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    6012:	2300      	movs	r3, #0
    6014:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    6016:	4b07      	ldr	r3, [pc, #28]	; (6034 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    6018:	681b      	ldr	r3, [r3, #0]
    601a:	685b      	ldr	r3, [r3, #4]
    601c:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    601e:	9b01      	ldr	r3, [sp, #4]
    6020:	f023 0302 	bic.w	r3, r3, #2
    6024:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    6026:	4b03      	ldr	r3, [pc, #12]	; (6034 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    6028:	681b      	ldr	r3, [r3, #0]
    602a:	9a01      	ldr	r2, [sp, #4]
    602c:	605a      	str	r2, [r3, #4]
}
    602e:	bf00      	nop
    6030:	b002      	add	sp, #8
    6032:	4770      	bx	lr
    6034:	1fff8b20 	.word	0x1fff8b20

00006038 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    6038:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    603a:	2300      	movs	r3, #0
    603c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    603e:	4b07      	ldr	r3, [pc, #28]	; (605c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    6040:	681b      	ldr	r3, [r3, #0]
    6042:	685b      	ldr	r3, [r3, #4]
    6044:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    6046:	9b01      	ldr	r3, [sp, #4]
    6048:	f043 0302 	orr.w	r3, r3, #2
    604c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    604e:	4b03      	ldr	r3, [pc, #12]	; (605c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    6050:	681b      	ldr	r3, [r3, #0]
    6052:	9a01      	ldr	r2, [sp, #4]
    6054:	605a      	str	r2, [r3, #4]
}
    6056:	bf00      	nop
    6058:	b002      	add	sp, #8
    605a:	4770      	bx	lr
    605c:	1fff8b20 	.word	0x1fff8b20

00006060 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    6060:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    6062:	2300      	movs	r3, #0
    6064:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    6066:	4b07      	ldr	r3, [pc, #28]	; (6084 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    6068:	681b      	ldr	r3, [r3, #0]
    606a:	685b      	ldr	r3, [r3, #4]
    606c:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    606e:	9b01      	ldr	r3, [sp, #4]
    6070:	f043 0304 	orr.w	r3, r3, #4
    6074:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    6076:	4b03      	ldr	r3, [pc, #12]	; (6084 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    6078:	681b      	ldr	r3, [r3, #0]
    607a:	9a01      	ldr	r2, [sp, #4]
    607c:	605a      	str	r2, [r3, #4]
}
    607e:	bf00      	nop
    6080:	b002      	add	sp, #8
    6082:	4770      	bx	lr
    6084:	1fff8b20 	.word	0x1fff8b20

00006088 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    6088:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    608a:	2300      	movs	r3, #0
    608c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    608e:	4b07      	ldr	r3, [pc, #28]	; (60ac <Power_Ip_CM4_DisableDeepSleep+0x24>)
    6090:	681b      	ldr	r3, [r3, #0]
    6092:	685b      	ldr	r3, [r3, #4]
    6094:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    6096:	9b01      	ldr	r3, [sp, #4]
    6098:	f023 0304 	bic.w	r3, r3, #4
    609c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    609e:	4b03      	ldr	r3, [pc, #12]	; (60ac <Power_Ip_CM4_DisableDeepSleep+0x24>)
    60a0:	681b      	ldr	r3, [r3, #0]
    60a2:	9a01      	ldr	r2, [sp, #4]
    60a4:	605a      	str	r2, [r3, #4]
}
    60a6:	bf00      	nop
    60a8:	b002      	add	sp, #8
    60aa:	4770      	bx	lr
    60ac:	1fff8b20 	.word	0x1fff8b20

000060b0 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    60b0:	b084      	sub	sp, #16
    60b2:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    60b4:	4b20      	ldr	r3, [pc, #128]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    60b6:	781b      	ldrb	r3, [r3, #0]
    60b8:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    60bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60c0:	f003 030f 	and.w	r3, r3, #15
    60c4:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    60c8:	9b01      	ldr	r3, [sp, #4]
    60ca:	781a      	ldrb	r2, [r3, #0]
    60cc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60d0:	4313      	orrs	r3, r2
    60d2:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    60d6:	4a18      	ldr	r2, [pc, #96]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    60d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60dc:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    60de:	4b16      	ldr	r3, [pc, #88]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    60e0:	785b      	ldrb	r3, [r3, #1]
    60e2:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    60e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60ea:	f003 031f 	and.w	r3, r3, #31
    60ee:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    60f2:	9b01      	ldr	r3, [sp, #4]
    60f4:	785a      	ldrb	r2, [r3, #1]
    60f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60fa:	4313      	orrs	r3, r2
    60fc:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    6100:	4a0d      	ldr	r2, [pc, #52]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    6102:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6106:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    6108:	4b0b      	ldr	r3, [pc, #44]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    610a:	789b      	ldrb	r3, [r3, #2]
    610c:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    6110:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6114:	f003 0338 	and.w	r3, r3, #56	; 0x38
    6118:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    611c:	9b01      	ldr	r3, [sp, #4]
    611e:	789a      	ldrb	r2, [r3, #2]
    6120:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6124:	4313      	orrs	r3, r2
    6126:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    612a:	4a03      	ldr	r2, [pc, #12]	; (6138 <Power_Ip_PMC_PowerInit+0x88>)
    612c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6130:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    6132:	bf00      	nop
    6134:	b004      	add	sp, #16
    6136:	4770      	bx	lr
    6138:	4007d000 	.word	0x4007d000

0000613c <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    613c:	b500      	push	{lr}
    613e:	b083      	sub	sp, #12
    6140:	9001      	str	r0, [sp, #4]
    6142:	460b      	mov	r3, r1
    6144:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    6148:	4b05      	ldr	r3, [pc, #20]	; (6160 <Power_Ip_ReportPowerErrors+0x24>)
    614a:	681b      	ldr	r3, [r3, #0]
    614c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6150:	4611      	mov	r1, r2
    6152:	9801      	ldr	r0, [sp, #4]
    6154:	4798      	blx	r3
}
    6156:	bf00      	nop
    6158:	b003      	add	sp, #12
    615a:	f85d fb04 	ldr.w	pc, [sp], #4
    615e:	bf00      	nop
    6160:	1fff8b1c 	.word	0x1fff8b1c

00006164 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    6164:	b082      	sub	sp, #8
    6166:	9001      	str	r0, [sp, #4]
    6168:	460b      	mov	r3, r1
    616a:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    616e:	bf00      	nop
    6170:	b002      	add	sp, #8
    6172:	4770      	bx	lr

00006174 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    6174:	b500      	push	{lr}
    6176:	b085      	sub	sp, #20
    6178:	9003      	str	r0, [sp, #12]
    617a:	9102      	str	r1, [sp, #8]
    617c:	9201      	str	r2, [sp, #4]
    617e:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    6180:	2000      	movs	r0, #0
    6182:	f7fc f83d 	bl	2200 <OsIf_GetCounter>
    6186:	4602      	mov	r2, r0
    6188:	9b03      	ldr	r3, [sp, #12]
    618a:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    618c:	9b02      	ldr	r3, [sp, #8]
    618e:	2200      	movs	r2, #0
    6190:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    6192:	2100      	movs	r1, #0
    6194:	9800      	ldr	r0, [sp, #0]
    6196:	f7fc f87f 	bl	2298 <OsIf_MicrosToTicks>
    619a:	4602      	mov	r2, r0
    619c:	9b01      	ldr	r3, [sp, #4]
    619e:	601a      	str	r2, [r3, #0]
}
    61a0:	bf00      	nop
    61a2:	b005      	add	sp, #20
    61a4:	f85d fb04 	ldr.w	pc, [sp], #4

000061a8 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    61a8:	b500      	push	{lr}
    61aa:	b087      	sub	sp, #28
    61ac:	9003      	str	r0, [sp, #12]
    61ae:	9102      	str	r1, [sp, #8]
    61b0:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    61b2:	2300      	movs	r3, #0
    61b4:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    61b8:	2100      	movs	r1, #0
    61ba:	9803      	ldr	r0, [sp, #12]
    61bc:	f7fc f839 	bl	2232 <OsIf_GetElapsed>
    61c0:	4602      	mov	r2, r0
    61c2:	9b02      	ldr	r3, [sp, #8]
    61c4:	681b      	ldr	r3, [r3, #0]
    61c6:	441a      	add	r2, r3
    61c8:	9b02      	ldr	r3, [sp, #8]
    61ca:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    61cc:	9b02      	ldr	r3, [sp, #8]
    61ce:	681b      	ldr	r3, [r3, #0]
    61d0:	9a01      	ldr	r2, [sp, #4]
    61d2:	429a      	cmp	r2, r3
    61d4:	d802      	bhi.n	61dc <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    61d6:	2301      	movs	r3, #1
    61d8:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    61dc:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    61e0:	4618      	mov	r0, r3
    61e2:	b007      	add	sp, #28
    61e4:	f85d fb04 	ldr.w	pc, [sp], #4

000061e8 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    61e8:	b082      	sub	sp, #8
    61ea:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    61ec:	9b01      	ldr	r3, [sp, #4]
    61ee:	681a      	ldr	r2, [r3, #0]
    61f0:	4907      	ldr	r1, [pc, #28]	; (6210 <Power_Ip_RCM_ResetInit+0x28>)
    61f2:	f641 7307 	movw	r3, #7943	; 0x1f07
    61f6:	4013      	ands	r3, r2
    61f8:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    61fa:	9b01      	ldr	r3, [sp, #4]
    61fc:	685a      	ldr	r2, [r3, #4]
    61fe:	4904      	ldr	r1, [pc, #16]	; (6210 <Power_Ip_RCM_ResetInit+0x28>)
    6200:	f642 73ff 	movw	r3, #12287	; 0x2fff
    6204:	4013      	ands	r3, r2
    6206:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    6208:	bf00      	nop
    620a:	b002      	add	sp, #8
    620c:	4770      	bx	lr
    620e:	bf00      	nop
    6210:	4007f000 	.word	0x4007f000

00006214 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    6214:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    6216:	230c      	movs	r3, #12
    6218:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    621a:	2300      	movs	r3, #0
    621c:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    621e:	2300      	movs	r3, #0
    6220:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    6222:	2300      	movs	r3, #0
    6224:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    6226:	4b25      	ldr	r3, [pc, #148]	; (62bc <Power_Ip_RCM_GetResetReason+0xa8>)
    6228:	699a      	ldr	r2, [r3, #24]
    622a:	f642 73ee 	movw	r3, #12270	; 0x2fee
    622e:	4013      	ands	r3, r2
    6230:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    6232:	9b03      	ldr	r3, [sp, #12]
    6234:	2b00      	cmp	r3, #0
    6236:	d008      	beq.n	624a <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    6238:	4920      	ldr	r1, [pc, #128]	; (62bc <Power_Ip_RCM_GetResetReason+0xa8>)
    623a:	9a03      	ldr	r2, [sp, #12]
    623c:	f642 73ee 	movw	r3, #12270	; 0x2fee
    6240:	4013      	ands	r3, r2
    6242:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    6244:	4a1e      	ldr	r2, [pc, #120]	; (62c0 <Power_Ip_RCM_GetResetReason+0xac>)
    6246:	9b03      	ldr	r3, [sp, #12]
    6248:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    624a:	4b1d      	ldr	r3, [pc, #116]	; (62c0 <Power_Ip_RCM_GetResetReason+0xac>)
    624c:	681b      	ldr	r3, [r3, #0]
    624e:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    6250:	9a02      	ldr	r2, [sp, #8]
    6252:	f642 73ee 	movw	r3, #12270	; 0x2fee
    6256:	4013      	ands	r3, r2
    6258:	2b82      	cmp	r3, #130	; 0x82
    625a:	d102      	bne.n	6262 <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    625c:	2305      	movs	r3, #5
    625e:	9307      	str	r3, [sp, #28]
    6260:	e027      	b.n	62b2 <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    6262:	2300      	movs	r3, #0
    6264:	9306      	str	r3, [sp, #24]
    6266:	e021      	b.n	62ac <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    6268:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    626c:	9b06      	ldr	r3, [sp, #24]
    626e:	fa22 f303 	lsr.w	r3, r2, r3
    6272:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    6274:	9a01      	ldr	r2, [sp, #4]
    6276:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    627a:	4013      	ands	r3, r2
    627c:	2b00      	cmp	r3, #0
    627e:	d012      	beq.n	62a6 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    6280:	9a01      	ldr	r2, [sp, #4]
    6282:	9b02      	ldr	r3, [sp, #8]
    6284:	4013      	ands	r3, r2
    6286:	2b00      	cmp	r3, #0
    6288:	d00a      	beq.n	62a0 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    628a:	9b05      	ldr	r3, [sp, #20]
    628c:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    628e:	9b04      	ldr	r3, [sp, #16]
    6290:	3301      	adds	r3, #1
    6292:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    6294:	9b04      	ldr	r3, [sp, #16]
    6296:	2b01      	cmp	r3, #1
    6298:	d902      	bls.n	62a0 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    629a:	230d      	movs	r3, #13
    629c:	9307      	str	r3, [sp, #28]
                        break;
    629e:	e008      	b.n	62b2 <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    62a0:	9b05      	ldr	r3, [sp, #20]
    62a2:	3301      	adds	r3, #1
    62a4:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    62a6:	9b06      	ldr	r3, [sp, #24]
    62a8:	3301      	adds	r3, #1
    62aa:	9306      	str	r3, [sp, #24]
    62ac:	9b06      	ldr	r3, [sp, #24]
    62ae:	2b1f      	cmp	r3, #31
    62b0:	d9da      	bls.n	6268 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    62b2:	9b07      	ldr	r3, [sp, #28]
}
    62b4:	4618      	mov	r0, r3
    62b6:	b008      	add	sp, #32
    62b8:	4770      	bx	lr
    62ba:	bf00      	nop
    62bc:	4007f000 	.word	0x4007f000
    62c0:	1fff8cfc 	.word	0x1fff8cfc

000062c4 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    62c4:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    62c6:	4b0c      	ldr	r3, [pc, #48]	; (62f8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    62c8:	699a      	ldr	r2, [r3, #24]
    62ca:	f642 73ee 	movw	r3, #12270	; 0x2fee
    62ce:	4013      	ands	r3, r2
    62d0:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    62d2:	9b01      	ldr	r3, [sp, #4]
    62d4:	2b00      	cmp	r3, #0
    62d6:	d008      	beq.n	62ea <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    62d8:	4907      	ldr	r1, [pc, #28]	; (62f8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    62da:	9a01      	ldr	r2, [sp, #4]
    62dc:	f642 73ee 	movw	r3, #12270	; 0x2fee
    62e0:	4013      	ands	r3, r2
    62e2:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    62e4:	4a05      	ldr	r2, [pc, #20]	; (62fc <Power_Ip_RCM_GetResetRawValue+0x38>)
    62e6:	9b01      	ldr	r3, [sp, #4]
    62e8:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    62ea:	4b04      	ldr	r3, [pc, #16]	; (62fc <Power_Ip_RCM_GetResetRawValue+0x38>)
    62ec:	681b      	ldr	r3, [r3, #0]
    62ee:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    62f0:	9b00      	ldr	r3, [sp, #0]
}
    62f2:	4618      	mov	r0, r3
    62f4:	b002      	add	sp, #8
    62f6:	4770      	bx	lr
    62f8:	4007f000 	.word	0x4007f000
    62fc:	1fff8cfc 	.word	0x1fff8cfc

00006300 <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    6300:	b082      	sub	sp, #8
    6302:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    6304:	9b01      	ldr	r3, [sp, #4]
    6306:	681b      	ldr	r3, [r3, #0]
    6308:	4a03      	ldr	r2, [pc, #12]	; (6318 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    630a:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    630e:	6093      	str	r3, [r2, #8]
}
    6310:	bf00      	nop
    6312:	b002      	add	sp, #8
    6314:	4770      	bx	lr
    6316:	bf00      	nop
    6318:	4007e000 	.word	0x4007e000

0000631c <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    631c:	b084      	sub	sp, #16
    631e:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    6320:	2301      	movs	r3, #1
    6322:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    6324:	4b15      	ldr	r3, [pc, #84]	; (637c <Power_Ip_SMC_ModeCheckEntry+0x60>)
    6326:	695b      	ldr	r3, [r3, #20]
    6328:	b2db      	uxtb	r3, r3
    632a:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    632c:	9b01      	ldr	r3, [sp, #4]
    632e:	2b02      	cmp	r3, #2
    6330:	d012      	beq.n	6358 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    6332:	9b01      	ldr	r3, [sp, #4]
    6334:	2b02      	cmp	r3, #2
    6336:	d818      	bhi.n	636a <Power_Ip_SMC_ModeCheckEntry+0x4e>
    6338:	9b01      	ldr	r3, [sp, #4]
    633a:	2b00      	cmp	r3, #0
    633c:	d003      	beq.n	6346 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    633e:	9b01      	ldr	r3, [sp, #4]
    6340:	2b01      	cmp	r3, #1
    6342:	d003      	beq.n	634c <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    6344:	e011      	b.n	636a <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    6346:	2300      	movs	r3, #0
    6348:	9303      	str	r3, [sp, #12]
            break;
    634a:	e013      	b.n	6374 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    634c:	9b02      	ldr	r3, [sp, #8]
    634e:	2b01      	cmp	r3, #1
    6350:	d10d      	bne.n	636e <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    6352:	2300      	movs	r3, #0
    6354:	9303      	str	r3, [sp, #12]
            break;
    6356:	e00a      	b.n	636e <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    6358:	9b02      	ldr	r3, [sp, #8]
    635a:	2b01      	cmp	r3, #1
    635c:	d002      	beq.n	6364 <Power_Ip_SMC_ModeCheckEntry+0x48>
    635e:	9b02      	ldr	r3, [sp, #8]
    6360:	2b10      	cmp	r3, #16
    6362:	d106      	bne.n	6372 <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    6364:	2300      	movs	r3, #0
    6366:	9303      	str	r3, [sp, #12]
            break;
    6368:	e003      	b.n	6372 <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    636a:	bf00      	nop
    636c:	e002      	b.n	6374 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    636e:	bf00      	nop
    6370:	e000      	b.n	6374 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    6372:	bf00      	nop
        }
    }

    return PowerModeCheck;
    6374:	9b03      	ldr	r3, [sp, #12]
}
    6376:	4618      	mov	r0, r3
    6378:	b004      	add	sp, #16
    637a:	4770      	bx	lr
    637c:	4007e000 	.word	0x4007e000

00006380 <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    6380:	b500      	push	{lr}
    6382:	b08b      	sub	sp, #44	; 0x2c
    6384:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    6386:	2300      	movs	r3, #0
    6388:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    638a:	2300      	movs	r3, #0
    638c:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    638e:	2300      	movs	r3, #0
    6390:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    6394:	9b01      	ldr	r3, [sp, #4]
    6396:	685b      	ldr	r3, [r3, #4]
    6398:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    639a:	9b08      	ldr	r3, [sp, #32]
    639c:	2b02      	cmp	r3, #2
    639e:	d076      	beq.n	648e <Power_Ip_SMC_ModeConfig+0x10e>
    63a0:	9b08      	ldr	r3, [sp, #32]
    63a2:	2b02      	cmp	r3, #2
    63a4:	f200 80ab 	bhi.w	64fe <Power_Ip_SMC_ModeConfig+0x17e>
    63a8:	9b08      	ldr	r3, [sp, #32]
    63aa:	2b00      	cmp	r3, #0
    63ac:	d003      	beq.n	63b6 <Power_Ip_SMC_ModeConfig+0x36>
    63ae:	9b08      	ldr	r3, [sp, #32]
    63b0:	2b01      	cmp	r3, #1
    63b2:	d034      	beq.n	641e <Power_Ip_SMC_ModeConfig+0x9e>
    63b4:	e0a3      	b.n	64fe <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    63b6:	4b58      	ldr	r3, [pc, #352]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    63b8:	68db      	ldr	r3, [r3, #12]
    63ba:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    63bc:	9b06      	ldr	r3, [sp, #24]
    63be:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    63c2:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    63c4:	4a54      	ldr	r2, [pc, #336]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    63c6:	9b06      	ldr	r3, [sp, #24]
    63c8:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    63ca:	aa02      	add	r2, sp, #8
    63cc:	a903      	add	r1, sp, #12
    63ce:	a804      	add	r0, sp, #16
    63d0:	f24c 3350 	movw	r3, #50000	; 0xc350
    63d4:	f7ff fece 	bl	6174 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    63d8:	9a02      	ldr	r2, [sp, #8]
    63da:	a903      	add	r1, sp, #12
    63dc:	ab04      	add	r3, sp, #16
    63de:	4618      	mov	r0, r3
    63e0:	f7ff fee2 	bl	61a8 <Power_Ip_TimeoutExpired>
    63e4:	4603      	mov	r3, r0
    63e6:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    63ea:	4b4b      	ldr	r3, [pc, #300]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    63ec:	695b      	ldr	r3, [r3, #20]
    63ee:	f003 0301 	and.w	r3, r3, #1
    63f2:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    63f4:	9b05      	ldr	r3, [sp, #20]
    63f6:	2b01      	cmp	r3, #1
    63f8:	d006      	beq.n	6408 <Power_Ip_SMC_ModeConfig+0x88>
    63fa:	f89d 301f 	ldrb.w	r3, [sp, #31]
    63fe:	f083 0301 	eor.w	r3, r3, #1
    6402:	b2db      	uxtb	r3, r3
    6404:	2b00      	cmp	r3, #0
    6406:	d1e7      	bne.n	63d8 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    6408:	f89d 301f 	ldrb.w	r3, [sp, #31]
    640c:	2b00      	cmp	r3, #0
    640e:	d079      	beq.n	6504 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    6410:	2301      	movs	r3, #1
    6412:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    6414:	21ff      	movs	r1, #255	; 0xff
    6416:	2000      	movs	r0, #0
    6418:	f7ff fe90 	bl	613c <Power_Ip_ReportPowerErrors>
            }

            break;
    641c:	e072      	b.n	6504 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    641e:	4b3e      	ldr	r3, [pc, #248]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    6420:	68db      	ldr	r3, [r3, #12]
    6422:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6424:	9b06      	ldr	r3, [sp, #24]
    6426:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    642a:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    642c:	9b06      	ldr	r3, [sp, #24]
    642e:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    6432:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    6434:	4a38      	ldr	r2, [pc, #224]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    6436:	9b06      	ldr	r3, [sp, #24]
    6438:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    643a:	aa02      	add	r2, sp, #8
    643c:	a903      	add	r1, sp, #12
    643e:	a804      	add	r0, sp, #16
    6440:	f24c 3350 	movw	r3, #50000	; 0xc350
    6444:	f7ff fe96 	bl	6174 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6448:	9a02      	ldr	r2, [sp, #8]
    644a:	a903      	add	r1, sp, #12
    644c:	ab04      	add	r3, sp, #16
    644e:	4618      	mov	r0, r3
    6450:	f7ff feaa 	bl	61a8 <Power_Ip_TimeoutExpired>
    6454:	4603      	mov	r3, r0
    6456:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    645a:	4b2f      	ldr	r3, [pc, #188]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    645c:	695b      	ldr	r3, [r3, #20]
    645e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    6462:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    6464:	9b05      	ldr	r3, [sp, #20]
    6466:	2b80      	cmp	r3, #128	; 0x80
    6468:	d006      	beq.n	6478 <Power_Ip_SMC_ModeConfig+0xf8>
    646a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    646e:	f083 0301 	eor.w	r3, r3, #1
    6472:	b2db      	uxtb	r3, r3
    6474:	2b00      	cmp	r3, #0
    6476:	d1e7      	bne.n	6448 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    6478:	f89d 301f 	ldrb.w	r3, [sp, #31]
    647c:	2b00      	cmp	r3, #0
    647e:	d043      	beq.n	6508 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    6480:	2301      	movs	r3, #1
    6482:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    6484:	21ff      	movs	r1, #255	; 0xff
    6486:	2000      	movs	r0, #0
    6488:	f7ff fe58 	bl	613c <Power_Ip_ReportPowerErrors>
            }

            break;
    648c:	e03c      	b.n	6508 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    648e:	4b22      	ldr	r3, [pc, #136]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    6490:	68db      	ldr	r3, [r3, #12]
    6492:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6494:	9b06      	ldr	r3, [sp, #24]
    6496:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    649a:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    649c:	9b06      	ldr	r3, [sp, #24]
    649e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    64a2:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    64a4:	4a1c      	ldr	r2, [pc, #112]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    64a6:	9b06      	ldr	r3, [sp, #24]
    64a8:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    64aa:	aa02      	add	r2, sp, #8
    64ac:	a903      	add	r1, sp, #12
    64ae:	a804      	add	r0, sp, #16
    64b0:	f24c 3350 	movw	r3, #50000	; 0xc350
    64b4:	f7ff fe5e 	bl	6174 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    64b8:	9a02      	ldr	r2, [sp, #8]
    64ba:	a903      	add	r1, sp, #12
    64bc:	ab04      	add	r3, sp, #16
    64be:	4618      	mov	r0, r3
    64c0:	f7ff fe72 	bl	61a8 <Power_Ip_TimeoutExpired>
    64c4:	4603      	mov	r3, r0
    64c6:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    64ca:	4b13      	ldr	r3, [pc, #76]	; (6518 <Power_Ip_SMC_ModeConfig+0x198>)
    64cc:	695b      	ldr	r3, [r3, #20]
    64ce:	f003 0304 	and.w	r3, r3, #4
    64d2:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    64d4:	9b05      	ldr	r3, [sp, #20]
    64d6:	2b04      	cmp	r3, #4
    64d8:	d006      	beq.n	64e8 <Power_Ip_SMC_ModeConfig+0x168>
    64da:	f89d 301f 	ldrb.w	r3, [sp, #31]
    64de:	f083 0301 	eor.w	r3, r3, #1
    64e2:	b2db      	uxtb	r3, r3
    64e4:	2b00      	cmp	r3, #0
    64e6:	d1e7      	bne.n	64b8 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    64e8:	f89d 301f 	ldrb.w	r3, [sp, #31]
    64ec:	2b00      	cmp	r3, #0
    64ee:	d00d      	beq.n	650c <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    64f0:	2301      	movs	r3, #1
    64f2:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    64f4:	21ff      	movs	r1, #255	; 0xff
    64f6:	2000      	movs	r0, #0
    64f8:	f7ff fe20 	bl	613c <Power_Ip_ReportPowerErrors>
            }

            break;
    64fc:	e006      	b.n	650c <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    64fe:	2301      	movs	r3, #1
    6500:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    6502:	e004      	b.n	650e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    6504:	bf00      	nop
    6506:	e002      	b.n	650e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    6508:	bf00      	nop
    650a:	e000      	b.n	650e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    650c:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    650e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    6510:	4618      	mov	r0, r3
    6512:	b00b      	add	sp, #44	; 0x2c
    6514:	f85d fb04 	ldr.w	pc, [sp], #4
    6518:	4007e000 	.word	0x4007e000

0000651c <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    651c:	b500      	push	{lr}
    651e:	b085      	sub	sp, #20
    6520:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    6522:	9b01      	ldr	r3, [sp, #4]
    6524:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    6526:	9803      	ldr	r0, [sp, #12]
    6528:	f000 fbc8 	bl	6cbc <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    652c:	4a03      	ldr	r2, [pc, #12]	; (653c <Port_Init+0x20>)
    652e:	9b03      	ldr	r3, [sp, #12]
    6530:	6013      	str	r3, [r2, #0]
        }
    }
}
    6532:	bf00      	nop
    6534:	b005      	add	sp, #20
    6536:	f85d fb04 	ldr.w	pc, [sp], #4
    653a:	bf00      	nop
    653c:	1fff8d00 	.word	0x1fff8d00

00006540 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    6540:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    6542:	4b03      	ldr	r3, [pc, #12]	; (6550 <Port_RefreshPortDirection+0x10>)
    6544:	681b      	ldr	r3, [r3, #0]
    6546:	4618      	mov	r0, r3
    6548:	f000 fc10 	bl	6d6c <Port_Ipw_RefreshPortDirection>
    }
}
    654c:	bf00      	nop
    654e:	bd08      	pop	{r3, pc}
    6550:	1fff8d00 	.word	0x1fff8d00

00006554 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    6554:	b086      	sub	sp, #24
    6556:	9003      	str	r0, [sp, #12]
    6558:	9102      	str	r1, [sp, #8]
    655a:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    655c:	23ff      	movs	r3, #255	; 0xff
    655e:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    6560:	9b03      	ldr	r3, [sp, #12]
    6562:	4a39      	ldr	r2, [pc, #228]	; (6648 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    6564:	4293      	cmp	r3, r2
    6566:	d151      	bne.n	660c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    6568:	9b02      	ldr	r3, [sp, #8]
    656a:	2b10      	cmp	r3, #16
    656c:	d867      	bhi.n	663e <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    656e:	a201      	add	r2, pc, #4	; (adr r2, 6574 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    6570:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6574:	000065b9 	.word	0x000065b9
    6578:	000065c7 	.word	0x000065c7
    657c:	0000663f 	.word	0x0000663f
    6580:	0000663f 	.word	0x0000663f
    6584:	0000663f 	.word	0x0000663f
    6588:	0000663f 	.word	0x0000663f
    658c:	0000663f 	.word	0x0000663f
    6590:	0000663f 	.word	0x0000663f
    6594:	0000663f 	.word	0x0000663f
    6598:	0000663f 	.word	0x0000663f
    659c:	0000663f 	.word	0x0000663f
    65a0:	0000663f 	.word	0x0000663f
    65a4:	0000663f 	.word	0x0000663f
    65a8:	000065d5 	.word	0x000065d5
    65ac:	000065e3 	.word	0x000065e3
    65b0:	000065f1 	.word	0x000065f1
    65b4:	000065ff 	.word	0x000065ff
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    65b8:	2301      	movs	r3, #1
    65ba:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    65bc:	9a05      	ldr	r2, [sp, #20]
    65be:	9b01      	ldr	r3, [sp, #4]
    65c0:	4313      	orrs	r3, r2
    65c2:	9305      	str	r3, [sp, #20]
                break;
    65c4:	e03c      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    65c6:	2302      	movs	r3, #2
    65c8:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    65ca:	9a05      	ldr	r2, [sp, #20]
    65cc:	9b01      	ldr	r3, [sp, #4]
    65ce:	4313      	orrs	r3, r2
    65d0:	9305      	str	r3, [sp, #20]
                break;
    65d2:	e035      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    65d4:	2304      	movs	r3, #4
    65d6:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    65d8:	9a05      	ldr	r2, [sp, #20]
    65da:	9b01      	ldr	r3, [sp, #4]
    65dc:	4313      	orrs	r3, r2
    65de:	9305      	str	r3, [sp, #20]
                break;
    65e0:	e02e      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    65e2:	2308      	movs	r3, #8
    65e4:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    65e6:	9a05      	ldr	r2, [sp, #20]
    65e8:	9b01      	ldr	r3, [sp, #4]
    65ea:	4313      	orrs	r3, r2
    65ec:	9305      	str	r3, [sp, #20]
                break;
    65ee:	e027      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    65f0:	230e      	movs	r3, #14
    65f2:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    65f4:	9a05      	ldr	r2, [sp, #20]
    65f6:	9b01      	ldr	r3, [sp, #4]
    65f8:	4013      	ands	r3, r2
    65fa:	9305      	str	r3, [sp, #20]
                break;
    65fc:	e020      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    65fe:	230d      	movs	r3, #13
    6600:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6602:	9a05      	ldr	r2, [sp, #20]
    6604:	9b01      	ldr	r3, [sp, #4]
    6606:	4013      	ands	r3, r2
    6608:	9305      	str	r3, [sp, #20]
                break;
    660a:	e019      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    660c:	9b03      	ldr	r3, [sp, #12]
    660e:	4a0f      	ldr	r2, [pc, #60]	; (664c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    6610:	4293      	cmp	r3, r2
    6612:	d115      	bne.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    6614:	9b02      	ldr	r3, [sp, #8]
    6616:	2b00      	cmp	r3, #0
    6618:	d003      	beq.n	6622 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    661a:	9b02      	ldr	r3, [sp, #8]
    661c:	2b01      	cmp	r3, #1
    661e:	d007      	beq.n	6630 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    6620:	e00e      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    6622:	230b      	movs	r3, #11
    6624:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6626:	9a05      	ldr	r2, [sp, #20]
    6628:	9b01      	ldr	r3, [sp, #4]
    662a:	4013      	ands	r3, r2
    662c:	9305      	str	r3, [sp, #20]
                break;
    662e:	e007      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    6630:	2307      	movs	r3, #7
    6632:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6634:	9a05      	ldr	r2, [sp, #20]
    6636:	9b01      	ldr	r3, [sp, #4]
    6638:	4013      	ands	r3, r2
    663a:	9305      	str	r3, [sp, #20]
                break;
    663c:	e000      	b.n	6640 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    663e:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    6640:	9b05      	ldr	r3, [sp, #20]
}
    6642:	4618      	mov	r0, r3
    6644:	b006      	add	sp, #24
    6646:	4770      	bx	lr
    6648:	4004a000 	.word	0x4004a000
    664c:	4004b000 	.word	0x4004b000

00006650 <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    6650:	b500      	push	{lr}
    6652:	b089      	sub	sp, #36	; 0x24
    6654:	9003      	str	r0, [sp, #12]
    6656:	9102      	str	r1, [sp, #8]
    6658:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    665a:	9b01      	ldr	r3, [sp, #4]
    665c:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    665e:	9b01      	ldr	r3, [sp, #4]
    6660:	2b08      	cmp	r3, #8
    6662:	d121      	bne.n	66a8 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    6664:	4b13      	ldr	r3, [pc, #76]	; (66b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6666:	685b      	ldr	r3, [r3, #4]
    6668:	f003 030f 	and.w	r3, r3, #15
    666c:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    666e:	9a06      	ldr	r2, [sp, #24]
    6670:	9902      	ldr	r1, [sp, #8]
    6672:	9803      	ldr	r0, [sp, #12]
    6674:	f7ff ff6e 	bl	6554 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    6678:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    667a:	9b05      	ldr	r3, [sp, #20]
    667c:	2bff      	cmp	r3, #255	; 0xff
    667e:	d011      	beq.n	66a4 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    6680:	f008 f898 	bl	e7b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    6684:	4b0b      	ldr	r3, [pc, #44]	; (66b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6686:	685b      	ldr	r3, [r3, #4]
    6688:	4a0a      	ldr	r2, [pc, #40]	; (66b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    668a:	f023 030f 	bic.w	r3, r3, #15
    668e:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    6690:	4b08      	ldr	r3, [pc, #32]	; (66b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6692:	685a      	ldr	r2, [r3, #4]
    6694:	9b05      	ldr	r3, [sp, #20]
    6696:	f003 030f 	and.w	r3, r3, #15
    669a:	4906      	ldr	r1, [pc, #24]	; (66b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    669c:	4313      	orrs	r3, r2
    669e:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    66a0:	f008 f8b4 	bl	e80c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    66a4:	2300      	movs	r3, #0
    66a6:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    66a8:	9b07      	ldr	r3, [sp, #28]
}
    66aa:	4618      	mov	r0, r3
    66ac:	b009      	add	sp, #36	; 0x24
    66ae:	f85d fb04 	ldr.w	pc, [sp], #4
    66b2:	bf00      	nop
    66b4:	40048000 	.word	0x40048000

000066b8 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    66b8:	b500      	push	{lr}
    66ba:	b087      	sub	sp, #28
    66bc:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    66be:	2300      	movs	r3, #0
    66c0:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    66c2:	2300      	movs	r3, #0
    66c4:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    66c6:	2300      	movs	r3, #0
    66c8:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    66ca:	9b01      	ldr	r3, [sp, #4]
    66cc:	68db      	ldr	r3, [r3, #12]
    66ce:	2b02      	cmp	r3, #2
    66d0:	d00a      	beq.n	66e8 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    66d2:	9b05      	ldr	r3, [sp, #20]
    66d4:	f043 0302 	orr.w	r3, r3, #2
    66d8:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    66da:	9b01      	ldr	r3, [sp, #4]
    66dc:	68db      	ldr	r3, [r3, #12]
    66de:	f003 0301 	and.w	r3, r3, #1
    66e2:	9a05      	ldr	r2, [sp, #20]
    66e4:	4313      	orrs	r3, r2
    66e6:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    66e8:	9b01      	ldr	r3, [sp, #4]
    66ea:	699b      	ldr	r3, [r3, #24]
    66ec:	019b      	lsls	r3, r3, #6
    66ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
    66f2:	9a05      	ldr	r2, [sp, #20]
    66f4:	4313      	orrs	r3, r2
    66f6:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    66f8:	9b01      	ldr	r3, [sp, #4]
    66fa:	6a1b      	ldr	r3, [r3, #32]
    66fc:	03db      	lsls	r3, r3, #15
    66fe:	b29b      	uxth	r3, r3
    6700:	9a05      	ldr	r2, [sp, #20]
    6702:	4313      	orrs	r3, r2
    6704:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    6706:	9b01      	ldr	r3, [sp, #4]
    6708:	7f1b      	ldrb	r3, [r3, #28]
    670a:	2b00      	cmp	r3, #0
    670c:	d001      	beq.n	6712 <Port_Ci_Port_Ip_PinInit+0x5a>
    670e:	2310      	movs	r3, #16
    6710:	e000      	b.n	6714 <Port_Ci_Port_Ip_PinInit+0x5c>
    6712:	2300      	movs	r3, #0
    6714:	9a05      	ldr	r2, [sp, #20]
    6716:	4313      	orrs	r3, r2
    6718:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    671a:	9b01      	ldr	r3, [sp, #4]
    671c:	691b      	ldr	r3, [r3, #16]
    671e:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    6720:	9b01      	ldr	r3, [sp, #4]
    6722:	6818      	ldr	r0, [r3, #0]
    6724:	9b01      	ldr	r3, [sp, #4]
    6726:	689b      	ldr	r3, [r3, #8]
    6728:	9a04      	ldr	r2, [sp, #16]
    672a:	4619      	mov	r1, r3
    672c:	f7ff ff90 	bl	6650 <Port_Ci_Port_Ip_ConfigureInterleave>
    6730:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    6732:	9b03      	ldr	r3, [sp, #12]
    6734:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    6736:	9b04      	ldr	r3, [sp, #16]
    6738:	021b      	lsls	r3, r3, #8
    673a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    673e:	9a05      	ldr	r2, [sp, #20]
    6740:	4313      	orrs	r3, r2
    6742:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    6744:	f007 fe9c 	bl	e480 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    6748:	9b01      	ldr	r3, [sp, #4]
    674a:	681b      	ldr	r3, [r3, #0]
    674c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    6750:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    6752:	9b01      	ldr	r3, [sp, #4]
    6754:	689b      	ldr	r3, [r3, #8]
    6756:	2201      	movs	r2, #1
    6758:	fa02 f303 	lsl.w	r3, r2, r3
    675c:	43db      	mvns	r3, r3
    675e:	9a02      	ldr	r2, [sp, #8]
    6760:	4013      	ands	r3, r2
    6762:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    6764:	9b01      	ldr	r3, [sp, #4]
    6766:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    676a:	2b00      	cmp	r3, #0
    676c:	d001      	beq.n	6772 <Port_Ci_Port_Ip_PinInit+0xba>
    676e:	2201      	movs	r2, #1
    6770:	e000      	b.n	6774 <Port_Ci_Port_Ip_PinInit+0xbc>
    6772:	2200      	movs	r2, #0
    6774:	9b01      	ldr	r3, [sp, #4]
    6776:	689b      	ldr	r3, [r3, #8]
    6778:	fa02 f303 	lsl.w	r3, r2, r3
    677c:	9a02      	ldr	r2, [sp, #8]
    677e:	4313      	orrs	r3, r2
    6780:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    6782:	9b01      	ldr	r3, [sp, #4]
    6784:	681b      	ldr	r3, [r3, #0]
    6786:	9a02      	ldr	r2, [sp, #8]
    6788:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    678c:	f007 fea4 	bl	e4d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    6790:	9b04      	ldr	r3, [sp, #16]
    6792:	2b01      	cmp	r3, #1
    6794:	d16d      	bne.n	6872 <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    6796:	9b01      	ldr	r3, [sp, #4]
    6798:	695b      	ldr	r3, [r3, #20]
    679a:	2b02      	cmp	r3, #2
    679c:	d138      	bne.n	6810 <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    679e:	9b01      	ldr	r3, [sp, #4]
    67a0:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    67a4:	2b01      	cmp	r3, #1
    67a6:	d10f      	bne.n	67c8 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    67a8:	f007 febc 	bl	e524 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    67ac:	9b01      	ldr	r3, [sp, #4]
    67ae:	685b      	ldr	r3, [r3, #4]
    67b0:	6859      	ldr	r1, [r3, #4]
    67b2:	9b01      	ldr	r3, [sp, #4]
    67b4:	689b      	ldr	r3, [r3, #8]
    67b6:	2201      	movs	r2, #1
    67b8:	409a      	lsls	r2, r3
    67ba:	9b01      	ldr	r3, [sp, #4]
    67bc:	685b      	ldr	r3, [r3, #4]
    67be:	430a      	orrs	r2, r1
    67c0:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    67c2:	f007 fedb 	bl	e57c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    67c6:	e013      	b.n	67f0 <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    67c8:	9b01      	ldr	r3, [sp, #4]
    67ca:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    67ce:	2b00      	cmp	r3, #0
    67d0:	d10e      	bne.n	67f0 <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    67d2:	f007 fef9 	bl	e5c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    67d6:	9b01      	ldr	r3, [sp, #4]
    67d8:	685b      	ldr	r3, [r3, #4]
    67da:	6899      	ldr	r1, [r3, #8]
    67dc:	9b01      	ldr	r3, [sp, #4]
    67de:	689b      	ldr	r3, [r3, #8]
    67e0:	2201      	movs	r2, #1
    67e2:	409a      	lsls	r2, r3
    67e4:	9b01      	ldr	r3, [sp, #4]
    67e6:	685b      	ldr	r3, [r3, #4]
    67e8:	430a      	orrs	r2, r1
    67ea:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    67ec:	f007 ff18 	bl	e620 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    67f0:	f007 ff3c 	bl	e66c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    67f4:	9b01      	ldr	r3, [sp, #4]
    67f6:	685b      	ldr	r3, [r3, #4]
    67f8:	6959      	ldr	r1, [r3, #20]
    67fa:	9b01      	ldr	r3, [sp, #4]
    67fc:	689b      	ldr	r3, [r3, #8]
    67fe:	2201      	movs	r2, #1
    6800:	409a      	lsls	r2, r3
    6802:	9b01      	ldr	r3, [sp, #4]
    6804:	685b      	ldr	r3, [r3, #4]
    6806:	430a      	orrs	r2, r1
    6808:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    680a:	f007 ff5b 	bl	e6c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    680e:	e030      	b.n	6872 <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    6810:	f007 ff2c 	bl	e66c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    6814:	9b01      	ldr	r3, [sp, #4]
    6816:	685b      	ldr	r3, [r3, #4]
    6818:	6959      	ldr	r1, [r3, #20]
    681a:	9b01      	ldr	r3, [sp, #4]
    681c:	689b      	ldr	r3, [r3, #8]
    681e:	2201      	movs	r2, #1
    6820:	fa02 f303 	lsl.w	r3, r2, r3
    6824:	43da      	mvns	r2, r3
    6826:	9b01      	ldr	r3, [sp, #4]
    6828:	685b      	ldr	r3, [r3, #4]
    682a:	400a      	ands	r2, r1
    682c:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    682e:	f007 ff49 	bl	e6c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    6832:	f007 ff6d 	bl	e710 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    6836:	9b01      	ldr	r3, [sp, #4]
    6838:	685b      	ldr	r3, [r3, #4]
    683a:	6999      	ldr	r1, [r3, #24]
    683c:	9b01      	ldr	r3, [sp, #4]
    683e:	689b      	ldr	r3, [r3, #8]
    6840:	2201      	movs	r2, #1
    6842:	fa02 f303 	lsl.w	r3, r2, r3
    6846:	43da      	mvns	r2, r3
    6848:	9b01      	ldr	r3, [sp, #4]
    684a:	685b      	ldr	r3, [r3, #4]
    684c:	400a      	ands	r2, r1
    684e:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    6850:	9b01      	ldr	r3, [sp, #4]
    6852:	695b      	ldr	r3, [r3, #20]
    6854:	2b03      	cmp	r3, #3
    6856:	d10a      	bne.n	686e <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    6858:	9b01      	ldr	r3, [sp, #4]
    685a:	685b      	ldr	r3, [r3, #4]
    685c:	6999      	ldr	r1, [r3, #24]
    685e:	9b01      	ldr	r3, [sp, #4]
    6860:	689b      	ldr	r3, [r3, #8]
    6862:	2201      	movs	r2, #1
    6864:	409a      	lsls	r2, r3
    6866:	9b01      	ldr	r3, [sp, #4]
    6868:	685b      	ldr	r3, [r3, #4]
    686a:	430a      	orrs	r2, r1
    686c:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    686e:	f007 ff7b 	bl	e768 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    6872:	9b01      	ldr	r3, [sp, #4]
    6874:	681b      	ldr	r3, [r3, #0]
    6876:	9a01      	ldr	r2, [sp, #4]
    6878:	6892      	ldr	r2, [r2, #8]
    687a:	9905      	ldr	r1, [sp, #20]
    687c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6880:	bf00      	nop
    6882:	b007      	add	sp, #28
    6884:	f85d fb04 	ldr.w	pc, [sp], #4

00006888 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    6888:	b500      	push	{lr}
    688a:	b085      	sub	sp, #20
    688c:	9001      	str	r0, [sp, #4]
    688e:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    6890:	2300      	movs	r3, #0
    6892:	9303      	str	r3, [sp, #12]
    6894:	e00d      	b.n	68b2 <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    6896:	9a03      	ldr	r2, [sp, #12]
    6898:	4613      	mov	r3, r2
    689a:	009b      	lsls	r3, r3, #2
    689c:	4413      	add	r3, r2
    689e:	00db      	lsls	r3, r3, #3
    68a0:	461a      	mov	r2, r3
    68a2:	9b00      	ldr	r3, [sp, #0]
    68a4:	4413      	add	r3, r2
    68a6:	4618      	mov	r0, r3
    68a8:	f7ff ff06 	bl	66b8 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    68ac:	9b03      	ldr	r3, [sp, #12]
    68ae:	3301      	adds	r3, #1
    68b0:	9303      	str	r3, [sp, #12]
    68b2:	9a03      	ldr	r2, [sp, #12]
    68b4:	9b01      	ldr	r3, [sp, #4]
    68b6:	429a      	cmp	r2, r3
    68b8:	d3ed      	bcc.n	6896 <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    68ba:	2300      	movs	r3, #0
}
    68bc:	4618      	mov	r0, r3
    68be:	b005      	add	sp, #20
    68c0:	f85d fb04 	ldr.w	pc, [sp], #4

000068c4 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    68c4:	b500      	push	{lr}
    68c6:	b087      	sub	sp, #28
    68c8:	9003      	str	r0, [sp, #12]
    68ca:	9102      	str	r1, [sp, #8]
    68cc:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    68ce:	9a01      	ldr	r2, [sp, #4]
    68d0:	9902      	ldr	r1, [sp, #8]
    68d2:	9803      	ldr	r0, [sp, #12]
    68d4:	f7ff febc 	bl	6650 <Port_Ci_Port_Ip_ConfigureInterleave>
    68d8:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    68da:	f007 ffbd 	bl	e858 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    68de:	9b03      	ldr	r3, [sp, #12]
    68e0:	9a02      	ldr	r2, [sp, #8]
    68e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    68e6:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    68e8:	9b04      	ldr	r3, [sp, #16]
    68ea:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    68ee:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    68f0:	9b05      	ldr	r3, [sp, #20]
    68f2:	021b      	lsls	r3, r3, #8
    68f4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    68f8:	9a04      	ldr	r2, [sp, #16]
    68fa:	4313      	orrs	r3, r2
    68fc:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    68fe:	9b03      	ldr	r3, [sp, #12]
    6900:	9a02      	ldr	r2, [sp, #8]
    6902:	9904      	ldr	r1, [sp, #16]
    6904:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    6908:	f007 ffd2 	bl	e8b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    690c:	bf00      	nop
    690e:	b007      	add	sp, #28
    6910:	f85d fb04 	ldr.w	pc, [sp], #4

00006914 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6914:	b500      	push	{lr}
    6916:	b083      	sub	sp, #12
    6918:	9001      	str	r0, [sp, #4]
    691a:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    691c:	f007 ffee 	bl	e8fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    6920:	9b01      	ldr	r3, [sp, #4]
    6922:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6926:	2101      	movs	r1, #1
    6928:	9b00      	ldr	r3, [sp, #0]
    692a:	fa01 f303 	lsl.w	r3, r1, r3
    692e:	431a      	orrs	r2, r3
    6930:	9b01      	ldr	r3, [sp, #4]
    6932:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    6936:	f008 f80d 	bl	e954 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    693a:	bf00      	nop
    693c:	b003      	add	sp, #12
    693e:	f85d fb04 	ldr.w	pc, [sp], #4

00006942 <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6942:	b500      	push	{lr}
    6944:	b083      	sub	sp, #12
    6946:	9001      	str	r0, [sp, #4]
    6948:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    694a:	f008 f829 	bl	e9a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    694e:	9b01      	ldr	r3, [sp, #4]
    6950:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6954:	2101      	movs	r1, #1
    6956:	9b00      	ldr	r3, [sp, #0]
    6958:	fa01 f303 	lsl.w	r3, r1, r3
    695c:	43db      	mvns	r3, r3
    695e:	401a      	ands	r2, r3
    6960:	9b01      	ldr	r3, [sp, #4]
    6962:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    6966:	f008 f847 	bl	e9f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    696a:	bf00      	nop
    696c:	b003      	add	sp, #12
    696e:	f85d fb04 	ldr.w	pc, [sp], #4

00006972 <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    6972:	b082      	sub	sp, #8
    6974:	9001      	str	r0, [sp, #4]
    6976:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    6978:	9b00      	ldr	r3, [sp, #0]
    697a:	785b      	ldrb	r3, [r3, #1]
    697c:	f003 0201 	and.w	r2, r3, #1
    6980:	9b01      	ldr	r3, [sp, #4]
    6982:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    6986:	9b00      	ldr	r3, [sp, #0]
    6988:	789b      	ldrb	r3, [r3, #2]
    698a:	f003 021f 	and.w	r2, r3, #31
    698e:	9b01      	ldr	r3, [sp, #4]
    6990:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    6994:	bf00      	nop
    6996:	b002      	add	sp, #8
    6998:	4770      	bx	lr

0000699a <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    699a:	b086      	sub	sp, #24
    699c:	9003      	str	r0, [sp, #12]
    699e:	9301      	str	r3, [sp, #4]
    69a0:	460b      	mov	r3, r1
    69a2:	f8ad 300a 	strh.w	r3, [sp, #10]
    69a6:	4613      	mov	r3, r2
    69a8:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    69ac:	2300      	movs	r3, #0
    69ae:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    69b2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69b6:	f043 0301 	orr.w	r3, r3, #1
    69ba:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    69be:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69c2:	f043 0302 	orr.w	r3, r3, #2
    69c6:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    69ca:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69ce:	f043 0310 	orr.w	r3, r3, #16
    69d2:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    69d6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    69de:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    69e2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69e6:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    69ea:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    69ee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69f2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    69f6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    69fa:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    69fe:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6a02:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6a06:	4013      	ands	r3, r2
    6a08:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    6a0c:	9b01      	ldr	r3, [sp, #4]
    6a0e:	2b00      	cmp	r3, #0
    6a10:	d003      	beq.n	6a1a <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    6a12:	9b01      	ldr	r3, [sp, #4]
    6a14:	2b01      	cmp	r3, #1
    6a16:	d00a      	beq.n	6a2e <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    6a18:	e013      	b.n	6a42 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    6a1a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6a1e:	041a      	lsls	r2, r3, #16
    6a20:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a24:	431a      	orrs	r2, r3
    6a26:	9b03      	ldr	r3, [sp, #12]
    6a28:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    6a2c:	e009      	b.n	6a42 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    6a2e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6a32:	041a      	lsls	r2, r3, #16
    6a34:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a38:	431a      	orrs	r2, r3
    6a3a:	9b03      	ldr	r3, [sp, #12]
    6a3c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    6a40:	bf00      	nop
    }
}
    6a42:	bf00      	nop
    6a44:	b006      	add	sp, #24
    6a46:	4770      	bx	lr

00006a48 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    6a48:	b500      	push	{lr}
    6a4a:	b087      	sub	sp, #28
    6a4c:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    6a4e:	9b01      	ldr	r3, [sp, #4]
    6a50:	885b      	ldrh	r3, [r3, #2]
    6a52:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    6a56:	9b01      	ldr	r3, [sp, #4]
    6a58:	689b      	ldr	r3, [r3, #8]
    6a5a:	7a1b      	ldrb	r3, [r3, #8]
    6a5c:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    6a60:	9b01      	ldr	r3, [sp, #4]
    6a62:	689b      	ldr	r3, [r3, #8]
    6a64:	681b      	ldr	r3, [r3, #0]
    6a66:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    6a68:	9b01      	ldr	r3, [sp, #4]
    6a6a:	689b      	ldr	r3, [r3, #8]
    6a6c:	685b      	ldr	r3, [r3, #4]
    6a6e:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6a70:	2300      	movs	r3, #0
    6a72:	f8ad 3016 	strh.w	r3, [sp, #22]
    6a76:	e111      	b.n	6c9c <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    6a78:	9b02      	ldr	r3, [sp, #8]
    6a7a:	2b02      	cmp	r3, #2
    6a7c:	d169      	bne.n	6b52 <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    6a7e:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6a82:	2b01      	cmp	r3, #1
    6a84:	d11a      	bne.n	6abc <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6a86:	9b01      	ldr	r3, [sp, #4]
    6a88:	685a      	ldr	r2, [r3, #4]
    6a8a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a8e:	005b      	lsls	r3, r3, #1
    6a90:	4413      	add	r3, r2
    6a92:	881b      	ldrh	r3, [r3, #0]
    6a94:	f003 021f 	and.w	r2, r3, #31
    6a98:	9b01      	ldr	r3, [sp, #4]
    6a9a:	6859      	ldr	r1, [r3, #4]
    6a9c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6aa0:	005b      	lsls	r3, r3, #1
    6aa2:	440b      	add	r3, r1
    6aa4:	881b      	ldrh	r3, [r3, #0]
    6aa6:	095b      	lsrs	r3, r3, #5
    6aa8:	b29b      	uxth	r3, r3
    6aaa:	4619      	mov	r1, r3
    6aac:	4b81      	ldr	r3, [pc, #516]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6aae:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6ab2:	2101      	movs	r1, #1
    6ab4:	fa01 f202 	lsl.w	r2, r1, r2
    6ab8:	605a      	str	r2, [r3, #4]
    6aba:	e01d      	b.n	6af8 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    6abc:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6ac0:	2b00      	cmp	r3, #0
    6ac2:	d119      	bne.n	6af8 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6ac4:	9b01      	ldr	r3, [sp, #4]
    6ac6:	685a      	ldr	r2, [r3, #4]
    6ac8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6acc:	005b      	lsls	r3, r3, #1
    6ace:	4413      	add	r3, r2
    6ad0:	881b      	ldrh	r3, [r3, #0]
    6ad2:	f003 021f 	and.w	r2, r3, #31
    6ad6:	9b01      	ldr	r3, [sp, #4]
    6ad8:	6859      	ldr	r1, [r3, #4]
    6ada:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6ade:	005b      	lsls	r3, r3, #1
    6ae0:	440b      	add	r3, r1
    6ae2:	881b      	ldrh	r3, [r3, #0]
    6ae4:	095b      	lsrs	r3, r3, #5
    6ae6:	b29b      	uxth	r3, r3
    6ae8:	4619      	mov	r1, r3
    6aea:	4b72      	ldr	r3, [pc, #456]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6aec:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6af0:	2101      	movs	r1, #1
    6af2:	fa01 f202 	lsl.w	r2, r1, r2
    6af6:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6af8:	f007 ffa4 	bl	ea44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6afc:	9b01      	ldr	r3, [sp, #4]
    6afe:	685a      	ldr	r2, [r3, #4]
    6b00:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b04:	005b      	lsls	r3, r3, #1
    6b06:	4413      	add	r3, r2
    6b08:	881b      	ldrh	r3, [r3, #0]
    6b0a:	095b      	lsrs	r3, r3, #5
    6b0c:	b29b      	uxth	r3, r3
    6b0e:	461a      	mov	r2, r3
    6b10:	4b68      	ldr	r3, [pc, #416]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b12:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6b16:	6959      	ldr	r1, [r3, #20]
    6b18:	9b01      	ldr	r3, [sp, #4]
    6b1a:	685a      	ldr	r2, [r3, #4]
    6b1c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b20:	005b      	lsls	r3, r3, #1
    6b22:	4413      	add	r3, r2
    6b24:	881b      	ldrh	r3, [r3, #0]
    6b26:	f003 031f 	and.w	r3, r3, #31
    6b2a:	2201      	movs	r2, #1
    6b2c:	409a      	lsls	r2, r3
    6b2e:	9b01      	ldr	r3, [sp, #4]
    6b30:	6858      	ldr	r0, [r3, #4]
    6b32:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b36:	005b      	lsls	r3, r3, #1
    6b38:	4403      	add	r3, r0
    6b3a:	881b      	ldrh	r3, [r3, #0]
    6b3c:	095b      	lsrs	r3, r3, #5
    6b3e:	b29b      	uxth	r3, r3
    6b40:	4618      	mov	r0, r3
    6b42:	4b5c      	ldr	r3, [pc, #368]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b44:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6b48:	430a      	orrs	r2, r1
    6b4a:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6b4c:	f007 ffa6 	bl	ea9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    6b50:	e086      	b.n	6c60 <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6b52:	f007 ff77 	bl	ea44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    6b56:	9b01      	ldr	r3, [sp, #4]
    6b58:	685a      	ldr	r2, [r3, #4]
    6b5a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b5e:	005b      	lsls	r3, r3, #1
    6b60:	4413      	add	r3, r2
    6b62:	881b      	ldrh	r3, [r3, #0]
    6b64:	095b      	lsrs	r3, r3, #5
    6b66:	b29b      	uxth	r3, r3
    6b68:	461a      	mov	r2, r3
    6b6a:	4b52      	ldr	r3, [pc, #328]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b6c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6b70:	6959      	ldr	r1, [r3, #20]
    6b72:	9b01      	ldr	r3, [sp, #4]
    6b74:	685a      	ldr	r2, [r3, #4]
    6b76:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b7a:	005b      	lsls	r3, r3, #1
    6b7c:	4413      	add	r3, r2
    6b7e:	881b      	ldrh	r3, [r3, #0]
    6b80:	f003 031f 	and.w	r3, r3, #31
    6b84:	2201      	movs	r2, #1
    6b86:	fa02 f303 	lsl.w	r3, r2, r3
    6b8a:	43da      	mvns	r2, r3
    6b8c:	9b01      	ldr	r3, [sp, #4]
    6b8e:	6858      	ldr	r0, [r3, #4]
    6b90:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b94:	005b      	lsls	r3, r3, #1
    6b96:	4403      	add	r3, r0
    6b98:	881b      	ldrh	r3, [r3, #0]
    6b9a:	095b      	lsrs	r3, r3, #5
    6b9c:	b29b      	uxth	r3, r3
    6b9e:	4618      	mov	r0, r3
    6ba0:	4b44      	ldr	r3, [pc, #272]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6ba2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6ba6:	400a      	ands	r2, r1
    6ba8:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6baa:	f007 ff77 	bl	ea9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    6bae:	f007 ff9b 	bl	eae8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6bb2:	9b01      	ldr	r3, [sp, #4]
    6bb4:	685a      	ldr	r2, [r3, #4]
    6bb6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bba:	005b      	lsls	r3, r3, #1
    6bbc:	4413      	add	r3, r2
    6bbe:	881b      	ldrh	r3, [r3, #0]
    6bc0:	095b      	lsrs	r3, r3, #5
    6bc2:	b29b      	uxth	r3, r3
    6bc4:	461a      	mov	r2, r3
    6bc6:	4b3b      	ldr	r3, [pc, #236]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6bc8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6bcc:	6999      	ldr	r1, [r3, #24]
    6bce:	9b01      	ldr	r3, [sp, #4]
    6bd0:	685a      	ldr	r2, [r3, #4]
    6bd2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bd6:	005b      	lsls	r3, r3, #1
    6bd8:	4413      	add	r3, r2
    6bda:	881b      	ldrh	r3, [r3, #0]
    6bdc:	f003 031f 	and.w	r3, r3, #31
    6be0:	2201      	movs	r2, #1
    6be2:	fa02 f303 	lsl.w	r3, r2, r3
    6be6:	43da      	mvns	r2, r3
    6be8:	9b01      	ldr	r3, [sp, #4]
    6bea:	6858      	ldr	r0, [r3, #4]
    6bec:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bf0:	005b      	lsls	r3, r3, #1
    6bf2:	4403      	add	r3, r0
    6bf4:	881b      	ldrh	r3, [r3, #0]
    6bf6:	095b      	lsrs	r3, r3, #5
    6bf8:	b29b      	uxth	r3, r3
    6bfa:	4618      	mov	r0, r3
    6bfc:	4b2d      	ldr	r3, [pc, #180]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6bfe:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6c02:	400a      	ands	r2, r1
    6c04:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    6c06:	9b02      	ldr	r3, [sp, #8]
    6c08:	2b03      	cmp	r3, #3
    6c0a:	d127      	bne.n	6c5c <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6c0c:	9b01      	ldr	r3, [sp, #4]
    6c0e:	685a      	ldr	r2, [r3, #4]
    6c10:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c14:	005b      	lsls	r3, r3, #1
    6c16:	4413      	add	r3, r2
    6c18:	881b      	ldrh	r3, [r3, #0]
    6c1a:	095b      	lsrs	r3, r3, #5
    6c1c:	b29b      	uxth	r3, r3
    6c1e:	461a      	mov	r2, r3
    6c20:	4b24      	ldr	r3, [pc, #144]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6c26:	6999      	ldr	r1, [r3, #24]
    6c28:	9b01      	ldr	r3, [sp, #4]
    6c2a:	685a      	ldr	r2, [r3, #4]
    6c2c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c30:	005b      	lsls	r3, r3, #1
    6c32:	4413      	add	r3, r2
    6c34:	881b      	ldrh	r3, [r3, #0]
    6c36:	f003 031f 	and.w	r3, r3, #31
    6c3a:	2201      	movs	r2, #1
    6c3c:	409a      	lsls	r2, r3
    6c3e:	9b01      	ldr	r3, [sp, #4]
    6c40:	6858      	ldr	r0, [r3, #4]
    6c42:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c46:	005b      	lsls	r3, r3, #1
    6c48:	4403      	add	r3, r0
    6c4a:	881b      	ldrh	r3, [r3, #0]
    6c4c:	095b      	lsrs	r3, r3, #5
    6c4e:	b29b      	uxth	r3, r3
    6c50:	4618      	mov	r0, r3
    6c52:	4b18      	ldr	r3, [pc, #96]	; (6cb4 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c54:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6c58:	430a      	orrs	r2, r1
    6c5a:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    6c5c:	f007 ff70 	bl	eb40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    6c60:	9b01      	ldr	r3, [sp, #4]
    6c62:	685a      	ldr	r2, [r3, #4]
    6c64:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c68:	005b      	lsls	r3, r3, #1
    6c6a:	4413      	add	r3, r2
    6c6c:	881b      	ldrh	r3, [r3, #0]
    6c6e:	095b      	lsrs	r3, r3, #5
    6c70:	b29b      	uxth	r3, r3
    6c72:	461a      	mov	r2, r3
    6c74:	4b10      	ldr	r3, [pc, #64]	; (6cb8 <Port_Ipw_Init_UnusedPins+0x270>)
    6c76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6c7a:	9a01      	ldr	r2, [sp, #4]
    6c7c:	6851      	ldr	r1, [r2, #4]
    6c7e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6c82:	0052      	lsls	r2, r2, #1
    6c84:	440a      	add	r2, r1
    6c86:	8812      	ldrh	r2, [r2, #0]
    6c88:	f002 021f 	and.w	r2, r2, #31
    6c8c:	9903      	ldr	r1, [sp, #12]
    6c8e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6c92:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c96:	3301      	adds	r3, #1
    6c98:	f8ad 3016 	strh.w	r3, [sp, #22]
    6c9c:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6ca0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6ca4:	429a      	cmp	r2, r3
    6ca6:	f4ff aee7 	bcc.w	6a78 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    6caa:	bf00      	nop
    6cac:	bf00      	nop
    6cae:	b007      	add	sp, #28
    6cb0:	f85d fb04 	ldr.w	pc, [sp], #4
    6cb4:	00010520 	.word	0x00010520
    6cb8:	0001050c 	.word	0x0001050c

00006cbc <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    6cbc:	b500      	push	{lr}
    6cbe:	b085      	sub	sp, #20
    6cc0:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    6cc2:	9b01      	ldr	r3, [sp, #4]
    6cc4:	7c1b      	ldrb	r3, [r3, #16]
    6cc6:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6cca:	2300      	movs	r3, #0
    6ccc:	f8ad 300e 	strh.w	r3, [sp, #14]
    6cd0:	e035      	b.n	6d3e <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    6cd2:	9b01      	ldr	r3, [sp, #4]
    6cd4:	695a      	ldr	r2, [r3, #20]
    6cd6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6cda:	00db      	lsls	r3, r3, #3
    6cdc:	4413      	add	r3, r2
    6cde:	781b      	ldrb	r3, [r3, #0]
    6ce0:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    6ce4:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6ce8:	4a1f      	ldr	r2, [pc, #124]	; (6d68 <Port_Ipw_Init+0xac>)
    6cea:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6cee:	9b01      	ldr	r3, [sp, #4]
    6cf0:	695a      	ldr	r2, [r3, #20]
    6cf2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6cf6:	00db      	lsls	r3, r3, #3
    6cf8:	4413      	add	r3, r2
    6cfa:	4619      	mov	r1, r3
    6cfc:	f7ff fe39 	bl	6972 <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    6d00:	f008 f88c 	bl	ee1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    6d04:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6d08:	4a17      	ldr	r2, [pc, #92]	; (6d68 <Port_Ipw_Init+0xac>)
    6d0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d0e:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    6d12:	9b01      	ldr	r3, [sp, #4]
    6d14:	695a      	ldr	r2, [r3, #20]
    6d16:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6d1a:	00db      	lsls	r3, r3, #3
    6d1c:	4413      	add	r3, r2
    6d1e:	685a      	ldr	r2, [r3, #4]
    6d20:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6d24:	4810      	ldr	r0, [pc, #64]	; (6d68 <Port_Ipw_Init+0xac>)
    6d26:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    6d2a:	430a      	orrs	r2, r1
    6d2c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    6d30:	f008 f8a0 	bl	ee74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6d34:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6d38:	3301      	adds	r3, #1
    6d3a:	f8ad 300e 	strh.w	r3, [sp, #14]
    6d3e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    6d42:	b29b      	uxth	r3, r3
    6d44:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6d48:	429a      	cmp	r2, r3
    6d4a:	d3c2      	bcc.n	6cd2 <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    6d4c:	9b01      	ldr	r3, [sp, #4]
    6d4e:	6a1b      	ldr	r3, [r3, #32]
    6d50:	4619      	mov	r1, r3
    6d52:	2010      	movs	r0, #16
    6d54:	f7ff fd98 	bl	6888 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    6d58:	9801      	ldr	r0, [sp, #4]
    6d5a:	f7ff fe75 	bl	6a48 <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    6d5e:	bf00      	nop
    6d60:	b005      	add	sp, #20
    6d62:	f85d fb04 	ldr.w	pc, [sp], #4
    6d66:	bf00      	nop
    6d68:	0001050c 	.word	0x0001050c

00006d6c <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    6d6c:	b500      	push	{lr}
    6d6e:	b085      	sub	sp, #20
    6d70:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    6d72:	9b01      	ldr	r3, [sp, #4]
    6d74:	881b      	ldrh	r3, [r3, #0]
    6d76:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    6d7a:	2300      	movs	r3, #0
    6d7c:	f8ad 300e 	strh.w	r3, [sp, #14]
    6d80:	e0d2      	b.n	6f28 <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    6d82:	9b01      	ldr	r3, [sp, #4]
    6d84:	68d9      	ldr	r1, [r3, #12]
    6d86:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6d8a:	4613      	mov	r3, r2
    6d8c:	009b      	lsls	r3, r3, #2
    6d8e:	4413      	add	r3, r2
    6d90:	009b      	lsls	r3, r3, #2
    6d92:	440b      	add	r3, r1
    6d94:	7c5b      	ldrb	r3, [r3, #17]
    6d96:	f083 0301 	eor.w	r3, r3, #1
    6d9a:	b2db      	uxtb	r3, r3
    6d9c:	2b00      	cmp	r3, #0
    6d9e:	f000 80be 	beq.w	6f1e <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    6da2:	9b01      	ldr	r3, [sp, #4]
    6da4:	68d9      	ldr	r1, [r3, #12]
    6da6:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6daa:	4613      	mov	r3, r2
    6dac:	009b      	lsls	r3, r3, #2
    6dae:	4413      	add	r3, r2
    6db0:	009b      	lsls	r3, r3, #2
    6db2:	440b      	add	r3, r1
    6db4:	7c1b      	ldrb	r3, [r3, #16]
    6db6:	2b00      	cmp	r3, #0
    6db8:	f000 80b1 	beq.w	6f1e <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    6dbc:	9b01      	ldr	r3, [sp, #4]
    6dbe:	68d9      	ldr	r1, [r3, #12]
    6dc0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6dc4:	4613      	mov	r3, r2
    6dc6:	009b      	lsls	r3, r3, #2
    6dc8:	4413      	add	r3, r2
    6dca:	009b      	lsls	r3, r3, #2
    6dcc:	440b      	add	r3, r1
    6dce:	881b      	ldrh	r3, [r3, #0]
    6dd0:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    6dd4:	9b01      	ldr	r3, [sp, #4]
    6dd6:	68d9      	ldr	r1, [r3, #12]
    6dd8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6ddc:	4613      	mov	r3, r2
    6dde:	009b      	lsls	r3, r3, #2
    6de0:	4413      	add	r3, r2
    6de2:	009b      	lsls	r3, r3, #2
    6de4:	440b      	add	r3, r1
    6de6:	68db      	ldr	r3, [r3, #12]
    6de8:	2b02      	cmp	r3, #2
    6dea:	d11d      	bne.n	6e28 <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    6dec:	f008 f95e 	bl	f0ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6df0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6df4:	095b      	lsrs	r3, r3, #5
    6df6:	b29b      	uxth	r3, r3
    6df8:	461a      	mov	r2, r3
    6dfa:	4b51      	ldr	r3, [pc, #324]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6dfc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6e00:	6959      	ldr	r1, [r3, #20]
    6e02:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e06:	f003 031f 	and.w	r3, r3, #31
    6e0a:	2201      	movs	r2, #1
    6e0c:	409a      	lsls	r2, r3
    6e0e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e12:	095b      	lsrs	r3, r3, #5
    6e14:	b29b      	uxth	r3, r3
    6e16:	4618      	mov	r0, r3
    6e18:	4b49      	ldr	r3, [pc, #292]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6e1a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6e1e:	430a      	orrs	r2, r1
    6e20:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    6e22:	f008 f96f 	bl	f104 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    6e26:	e07a      	b.n	6f1e <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    6e28:	9b01      	ldr	r3, [sp, #4]
    6e2a:	68d9      	ldr	r1, [r3, #12]
    6e2c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6e30:	4613      	mov	r3, r2
    6e32:	009b      	lsls	r3, r3, #2
    6e34:	4413      	add	r3, r2
    6e36:	009b      	lsls	r3, r3, #2
    6e38:	440b      	add	r3, r1
    6e3a:	68db      	ldr	r3, [r3, #12]
    6e3c:	2b01      	cmp	r3, #1
    6e3e:	d00b      	beq.n	6e58 <Port_Ipw_RefreshPortDirection+0xec>
    6e40:	9b01      	ldr	r3, [sp, #4]
    6e42:	68d9      	ldr	r1, [r3, #12]
    6e44:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6e48:	4613      	mov	r3, r2
    6e4a:	009b      	lsls	r3, r3, #2
    6e4c:	4413      	add	r3, r2
    6e4e:	009b      	lsls	r3, r3, #2
    6e50:	440b      	add	r3, r1
    6e52:	68db      	ldr	r3, [r3, #12]
    6e54:	2b03      	cmp	r3, #3
    6e56:	d162      	bne.n	6f1e <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    6e58:	f008 f928 	bl	f0ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6e5c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e60:	095b      	lsrs	r3, r3, #5
    6e62:	b29b      	uxth	r3, r3
    6e64:	461a      	mov	r2, r3
    6e66:	4b36      	ldr	r3, [pc, #216]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6e68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6e6c:	6959      	ldr	r1, [r3, #20]
    6e6e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e72:	f003 031f 	and.w	r3, r3, #31
    6e76:	2201      	movs	r2, #1
    6e78:	fa02 f303 	lsl.w	r3, r2, r3
    6e7c:	43da      	mvns	r2, r3
    6e7e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e82:	095b      	lsrs	r3, r3, #5
    6e84:	b29b      	uxth	r3, r3
    6e86:	4618      	mov	r0, r3
    6e88:	4b2d      	ldr	r3, [pc, #180]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6e8a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6e8e:	400a      	ands	r2, r1
    6e90:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    6e92:	f008 f937 	bl	f104 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    6e96:	f008 f95b 	bl	f150 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6e9a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6e9e:	095b      	lsrs	r3, r3, #5
    6ea0:	b29b      	uxth	r3, r3
    6ea2:	461a      	mov	r2, r3
    6ea4:	4b26      	ldr	r3, [pc, #152]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6ea6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6eaa:	6999      	ldr	r1, [r3, #24]
    6eac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6eb0:	f003 031f 	and.w	r3, r3, #31
    6eb4:	2201      	movs	r2, #1
    6eb6:	fa02 f303 	lsl.w	r3, r2, r3
    6eba:	43da      	mvns	r2, r3
    6ebc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6ec0:	095b      	lsrs	r3, r3, #5
    6ec2:	b29b      	uxth	r3, r3
    6ec4:	4618      	mov	r0, r3
    6ec6:	4b1e      	ldr	r3, [pc, #120]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6ec8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6ecc:	400a      	ands	r2, r1
    6ece:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    6ed0:	9b01      	ldr	r3, [sp, #4]
    6ed2:	68d9      	ldr	r1, [r3, #12]
    6ed4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6ed8:	4613      	mov	r3, r2
    6eda:	009b      	lsls	r3, r3, #2
    6edc:	4413      	add	r3, r2
    6ede:	009b      	lsls	r3, r3, #2
    6ee0:	440b      	add	r3, r1
    6ee2:	68db      	ldr	r3, [r3, #12]
    6ee4:	2b03      	cmp	r3, #3
    6ee6:	d118      	bne.n	6f1a <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6ee8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6eec:	095b      	lsrs	r3, r3, #5
    6eee:	b29b      	uxth	r3, r3
    6ef0:	461a      	mov	r2, r3
    6ef2:	4b13      	ldr	r3, [pc, #76]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6ef4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6ef8:	6999      	ldr	r1, [r3, #24]
    6efa:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6efe:	f003 031f 	and.w	r3, r3, #31
    6f02:	2201      	movs	r2, #1
    6f04:	409a      	lsls	r2, r3
    6f06:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6f0a:	095b      	lsrs	r3, r3, #5
    6f0c:	b29b      	uxth	r3, r3
    6f0e:	4618      	mov	r0, r3
    6f10:	4b0b      	ldr	r3, [pc, #44]	; (6f40 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6f12:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6f16:	430a      	orrs	r2, r1
    6f18:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    6f1a:	f008 f945 	bl	f1a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    6f1e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6f22:	3301      	adds	r3, #1
    6f24:	f8ad 300e 	strh.w	r3, [sp, #14]
    6f28:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6f2c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    6f30:	429a      	cmp	r2, r3
    6f32:	f4ff af26 	bcc.w	6d82 <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    6f36:	bf00      	nop
    6f38:	bf00      	nop
    6f3a:	b005      	add	sp, #20
    6f3c:	f85d fb04 	ldr.w	pc, [sp], #4
    6f40:	00010520 	.word	0x00010520

00006f44 <Dio_ReadChannel>:
*/
Dio_LevelType Dio_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    6f44:	b500      	push	{lr}
    6f46:	b085      	sub	sp, #20
    6f48:	4603      	mov	r3, r0
    6f4a:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    6f4e:	2300      	movs	r3, #0
    6f50:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForRead(ChannelId, DIO_READCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_ReadChannel(ChannelId);
    6f54:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    6f58:	4618      	mov	r0, r3
    6f5a:	f000 f871 	bl	7040 <Dio_Ipw_ReadChannel>
    6f5e:	4603      	mov	r3, r0
    6f60:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return ChannelLevel;
    6f64:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6f68:	4618      	mov	r0, r3
    6f6a:	b005      	add	sp, #20
    6f6c:	f85d fb04 	ldr.w	pc, [sp], #4

00006f70 <Dio_WriteChannel>:
void Dio_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    6f70:	b500      	push	{lr}
    6f72:	b083      	sub	sp, #12
    6f74:	4603      	mov	r3, r0
    6f76:	460a      	mov	r2, r1
    6f78:	f8ad 3006 	strh.w	r3, [sp, #6]
    6f7c:	4613      	mov	r3, r2
    6f7e:	f88d 3005 	strb.w	r3, [sp, #5]
    {
        Valid = Dio_ValidateChannelLevel(Level);
        if ((Std_ReturnType) E_OK == Valid)
        {
#endif
            Dio_Ipw_WriteChannel(ChannelId, Level);
    6f82:	f89d 2005 	ldrb.w	r2, [sp, #5]
    6f86:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    6f8a:	4611      	mov	r1, r2
    6f8c:	4618      	mov	r0, r3
    6f8e:	f000 f87d 	bl	708c <Dio_Ipw_WriteChannel>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
        }
    }
#endif

}
    6f92:	bf00      	nop
    6f94:	b003      	add	sp, #12
    6f96:	f85d fb04 	ldr.w	pc, [sp], #4

00006f9a <Dio_FlipChannel>:
*/
Dio_LevelType Dio_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    6f9a:	b500      	push	{lr}
    6f9c:	b085      	sub	sp, #20
    6f9e:	4603      	mov	r3, r0
    6fa0:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    6fa4:	2300      	movs	r3, #0
    6fa6:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForWrite(ChannelId, DIO_FLIPCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_FlipChannel(ChannelId);
    6faa:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    6fae:	4618      	mov	r0, r3
    6fb0:	f000 f892 	bl	70d8 <Dio_Ipw_FlipChannel>
    6fb4:	4603      	mov	r3, r0
    6fb6:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

   return ChannelLevel;
    6fba:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6fbe:	4618      	mov	r0, r3
    6fc0:	b005      	add	sp, #20
    6fc2:	f85d fb04 	ldr.w	pc, [sp], #4

00006fc6 <Dio_ReadPort>:
*/
Dio_PortLevelType Dio_ReadPort
(
    Dio_PortType PortId
)
{
    6fc6:	b500      	push	{lr}
    6fc8:	b085      	sub	sp, #20
    6fca:	4603      	mov	r3, r0
    6fcc:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    6fd0:	2300      	movs	r3, #0
    6fd2:	9303      	str	r3, [sp, #12]
    Std_ReturnType Valid = Dio_ValidatePortForRead(PortId, DIO_READPORT_ID);

    if ((Std_ReturnType) E_OK == Valid)
    {
#endif
        PortLevel = Dio_Ipw_ReadPort(PortId);
    6fd4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6fd8:	4618      	mov	r0, r3
    6fda:	f000 f8b3 	bl	7144 <Dio_Ipw_ReadPort>
    6fde:	9003      	str	r0, [sp, #12]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return PortLevel;
    6fe0:	9b03      	ldr	r3, [sp, #12]
}
    6fe2:	4618      	mov	r0, r3
    6fe4:	b005      	add	sp, #20
    6fe6:	f85d fb04 	ldr.w	pc, [sp], #4

00006fea <Dio_WritePort>:
void Dio_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    6fea:	b500      	push	{lr}
    6fec:	b083      	sub	sp, #12
    6fee:	4603      	mov	r3, r0
    6ff0:	9100      	str	r1, [sp, #0]
    6ff2:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType Valid = Dio_ValidatePortForWrite(PortId, DIO_WRITEPORT_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        Dio_Ipw_WritePort(PortId, Level);
    6ff6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6ffa:	9900      	ldr	r1, [sp, #0]
    6ffc:	4618      	mov	r0, r3
    6ffe:	f000 f8b9 	bl	7174 <Dio_Ipw_WritePort>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif
}
    7002:	bf00      	nop
    7004:	b003      	add	sp, #12
    7006:	f85d fb04 	ldr.w	pc, [sp], #4

0000700a <Dio_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_ReadChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr
)
{
    700a:	b500      	push	{lr}
    700c:	b085      	sub	sp, #20
    700e:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    7010:	2300      	movs	r3, #0
    7012:	9303      	str	r3, [sp, #12]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            PortLevel = Dio_Ipw_ReadChannelGroup(ChannelGroupIdPtr);
    7014:	9801      	ldr	r0, [sp, #4]
    7016:	f000 f8c5 	bl	71a4 <Dio_Ipw_ReadChannelGroup>
    701a:	9003      	str	r0, [sp, #12]
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */

    return PortLevel;
    701c:	9b03      	ldr	r3, [sp, #12]
}
    701e:	4618      	mov	r0, r3
    7020:	b005      	add	sp, #20
    7022:	f85d fb04 	ldr.w	pc, [sp], #4

00007026 <Dio_WriteChannelGroup>:
void Dio_WriteChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr,
    Dio_PortLevelType Level
)
{
    7026:	b500      	push	{lr}
    7028:	b083      	sub	sp, #12
    702a:	9001      	str	r0, [sp, #4]
    702c:	9100      	str	r1, [sp, #0]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            Dio_Ipw_WriteChannelGroup(ChannelGroupIdPtr, Level);
    702e:	9900      	ldr	r1, [sp, #0]
    7030:	9801      	ldr	r0, [sp, #4]
    7032:	f000 f8d7 	bl	71e4 <Dio_Ipw_WriteChannelGroup>
            (void)Det_ReportError((uint16)DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_WRITECHANNELGROUP_ID, DIO_E_PARAM_CONFIG);
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */
}
    7036:	bf00      	nop
    7038:	b003      	add	sp, #12
    703a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007040 <Dio_Ipw_ReadChannel>:
*/
Dio_LevelType Dio_Ipw_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    7040:	b500      	push	{lr}
    7042:	b087      	sub	sp, #28
    7044:	4603      	mov	r3, r0
    7046:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType) STD_LOW;
    704a:	2300      	movs	r3, #0
    704c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    7050:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    7054:	095b      	lsrs	r3, r3, #5
    7056:	b29b      	uxth	r3, r3
    7058:	9304      	str	r3, [sp, #16]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    705a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    705e:	f003 031f 	and.w	r3, r3, #31
    7062:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    7064:	4a08      	ldr	r2, [pc, #32]	; (7088 <Dio_Ipw_ReadChannel+0x48>)
    7066:	9b04      	ldr	r3, [sp, #16]
    7068:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    706c:	9302      	str	r3, [sp, #8]

    ChannelLevel = Gpio_Dio_Ip_ReadPin(GpioBase, u32PinIndex);
    706e:	9903      	ldr	r1, [sp, #12]
    7070:	9802      	ldr	r0, [sp, #8]
    7072:	f000 f940 	bl	72f6 <Gpio_Dio_Ip_ReadPin>
    7076:	4603      	mov	r3, r0
    7078:	f88d 3017 	strb.w	r3, [sp, #23]
    return ChannelLevel;
    707c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    7080:	4618      	mov	r0, r3
    7082:	b007      	add	sp, #28
    7084:	f85d fb04 	ldr.w	pc, [sp], #4
    7088:	1fff8b24 	.word	0x1fff8b24

0000708c <Dio_Ipw_WriteChannel>:
void Dio_Ipw_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    708c:	b500      	push	{lr}
    708e:	b087      	sub	sp, #28
    7090:	4603      	mov	r3, r0
    7092:	460a      	mov	r2, r1
    7094:	f8ad 3006 	strh.w	r3, [sp, #6]
    7098:	4613      	mov	r3, r2
    709a:	f88d 3005 	strb.w	r3, [sp, #5]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    709e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    70a2:	095b      	lsrs	r3, r3, #5
    70a4:	b29b      	uxth	r3, r3
    70a6:	9305      	str	r3, [sp, #20]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    70a8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    70ac:	f003 031f 	and.w	r3, r3, #31
    70b0:	9304      	str	r3, [sp, #16]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    70b2:	4a08      	ldr	r2, [pc, #32]	; (70d4 <Dio_Ipw_WriteChannel+0x48>)
    70b4:	9b05      	ldr	r3, [sp, #20]
    70b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70ba:	9303      	str	r3, [sp, #12]

    Gpio_Dio_Ip_WritePin(GpioBase, u32PinIndex, Level);
    70bc:	f89d 3005 	ldrb.w	r3, [sp, #5]
    70c0:	461a      	mov	r2, r3
    70c2:	9904      	ldr	r1, [sp, #16]
    70c4:	9803      	ldr	r0, [sp, #12]
    70c6:	f000 f8b7 	bl	7238 <Gpio_Dio_Ip_WritePin>
}
    70ca:	bf00      	nop
    70cc:	b007      	add	sp, #28
    70ce:	f85d fb04 	ldr.w	pc, [sp], #4
    70d2:	bf00      	nop
    70d4:	1fff8b24 	.word	0x1fff8b24

000070d8 <Dio_Ipw_FlipChannel>:
*/
Dio_LevelType Dio_Ipw_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    70d8:	b500      	push	{lr}
    70da:	b089      	sub	sp, #36	; 0x24
    70dc:	4603      	mov	r3, r0
    70de:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    70e2:	2300      	movs	r3, #0
    70e4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;
    uint32 u32PortOutPutLevel;
    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    70e8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    70ec:	095b      	lsrs	r3, r3, #5
    70ee:	b29b      	uxth	r3, r3
    70f0:	9306      	str	r3, [sp, #24]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    70f2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    70f6:	f003 031f 	and.w	r3, r3, #31
    70fa:	9305      	str	r3, [sp, #20]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    70fc:	4a10      	ldr	r2, [pc, #64]	; (7140 <Dio_Ipw_FlipChannel+0x68>)
    70fe:	9b06      	ldr	r3, [sp, #24]
    7100:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7104:	9304      	str	r3, [sp, #16]

    Gpio_Dio_Ip_TogglePins(GpioBase, ((uint32)1U << u32PinIndex));
    7106:	2201      	movs	r2, #1
    7108:	9b05      	ldr	r3, [sp, #20]
    710a:	fa02 f303 	lsl.w	r3, r2, r3
    710e:	4619      	mov	r1, r3
    7110:	9804      	ldr	r0, [sp, #16]
    7112:	f000 f8dc 	bl	72ce <Gpio_Dio_Ip_TogglePins>

    u32PortOutPutLevel = Gpio_Dio_Ip_GetPinsOutput(GpioBase);
    7116:	9804      	ldr	r0, [sp, #16]
    7118:	f000 f8bc 	bl	7294 <Gpio_Dio_Ip_GetPinsOutput>
    711c:	9003      	str	r0, [sp, #12]
    ChannelLevel = (Dio_LevelType)((u32PortOutPutLevel & ((uint32)1U << u32PinIndex)) >> u32PinIndex);
    711e:	2201      	movs	r2, #1
    7120:	9b05      	ldr	r3, [sp, #20]
    7122:	409a      	lsls	r2, r3
    7124:	9b03      	ldr	r3, [sp, #12]
    7126:	401a      	ands	r2, r3
    7128:	9b05      	ldr	r3, [sp, #20]
    712a:	fa22 f303 	lsr.w	r3, r2, r3
    712e:	f88d 301f 	strb.w	r3, [sp, #31]

    return ChannelLevel;
    7132:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    7136:	4618      	mov	r0, r3
    7138:	b009      	add	sp, #36	; 0x24
    713a:	f85d fb04 	ldr.w	pc, [sp], #4
    713e:	bf00      	nop
    7140:	1fff8b24 	.word	0x1fff8b24

00007144 <Dio_Ipw_ReadPort>:
*/
Dio_PortLevelType Dio_Ipw_ReadPort
(
    Dio_PortType PortId
)
{
    7144:	b500      	push	{lr}
    7146:	b085      	sub	sp, #20
    7148:	4603      	mov	r3, r0
    714a:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    714e:	2300      	movs	r3, #0
    7150:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    7152:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7156:	4a06      	ldr	r2, [pc, #24]	; (7170 <Dio_Ipw_ReadPort+0x2c>)
    7158:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    715c:	9302      	str	r3, [sp, #8]

    PortLevel = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    715e:	9802      	ldr	r0, [sp, #8]
    7160:	f000 f8be 	bl	72e0 <Gpio_Dio_Ip_ReadPins>
    7164:	9003      	str	r0, [sp, #12]
#endif
#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#endif

    return PortLevel;
    7166:	9b03      	ldr	r3, [sp, #12]
}
    7168:	4618      	mov	r0, r3
    716a:	b005      	add	sp, #20
    716c:	f85d fb04 	ldr.w	pc, [sp], #4
    7170:	1fff8b24 	.word	0x1fff8b24

00007174 <Dio_Ipw_WritePort>:
void Dio_Ipw_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    7174:	b500      	push	{lr}
    7176:	b085      	sub	sp, #20
    7178:	4603      	mov	r3, r0
    717a:	9100      	str	r1, [sp, #0]
    717c:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType CrtLevel = Level;
    7180:	9b00      	ldr	r3, [sp, #0]
    7182:	9303      	str	r3, [sp, #12]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    7184:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7188:	4a05      	ldr	r2, [pc, #20]	; (71a0 <Dio_Ipw_WritePort+0x2c>)
    718a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    718e:	9302      	str	r3, [sp, #8]

#if (STD_ON == DIO_REVERSEPORTBITS)
    CrtLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(CrtLevel));
#endif /* STD_ON == DIO_REVERSEPORTBITS */
    Gpio_Dio_Ip_WritePins(GpioBase, CrtLevel);
    7190:	9903      	ldr	r1, [sp, #12]
    7192:	9802      	ldr	r0, [sp, #8]
    7194:	f000 f875 	bl	7282 <Gpio_Dio_Ip_WritePins>
}
    7198:	bf00      	nop
    719a:	b005      	add	sp, #20
    719c:	f85d fb04 	ldr.w	pc, [sp], #4
    71a0:	1fff8b24 	.word	0x1fff8b24

000071a4 <Dio_Ipw_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_Ipw_ReadChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr
)
{
    71a4:	b500      	push	{lr}
    71a6:	b087      	sub	sp, #28
    71a8:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    71aa:	2300      	movs	r3, #0
    71ac:	9305      	str	r3, [sp, #20]
    Dio_PortLevelType pinsValue;
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    71ae:	9b01      	ldr	r3, [sp, #4]
    71b0:	781b      	ldrb	r3, [r3, #0]
    71b2:	461a      	mov	r2, r3
    71b4:	4b0a      	ldr	r3, [pc, #40]	; (71e0 <Dio_Ipw_ReadChannelGroup+0x3c>)
    71b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    71ba:	9304      	str	r3, [sp, #16]

    pinsValue = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    71bc:	9804      	ldr	r0, [sp, #16]
    71be:	f000 f88f 	bl	72e0 <Gpio_Dio_Ip_ReadPins>
    71c2:	9003      	str	r0, [sp, #12]

#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) << (pChannelGroupIdPtr->u8offset));
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#else
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) >> (pChannelGroupIdPtr->u8offset));
    71c4:	9b01      	ldr	r3, [sp, #4]
    71c6:	685a      	ldr	r2, [r3, #4]
    71c8:	9b03      	ldr	r3, [sp, #12]
    71ca:	4013      	ands	r3, r2
    71cc:	9a01      	ldr	r2, [sp, #4]
    71ce:	7852      	ldrb	r2, [r2, #1]
    71d0:	40d3      	lsrs	r3, r2
    71d2:	9305      	str	r3, [sp, #20]
#endif

    return PortLevel;
    71d4:	9b05      	ldr	r3, [sp, #20]
}
    71d6:	4618      	mov	r0, r3
    71d8:	b007      	add	sp, #28
    71da:	f85d fb04 	ldr.w	pc, [sp], #4
    71de:	bf00      	nop
    71e0:	1fff8b24 	.word	0x1fff8b24

000071e4 <Dio_Ipw_WriteChannelGroup>:
void Dio_Ipw_WriteChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr,
    Dio_PortLevelType                 Level
)
{
    71e4:	b500      	push	{lr}
    71e6:	b087      	sub	sp, #28
    71e8:	9001      	str	r0, [sp, #4]
    71ea:	9100      	str	r1, [sp, #0]
    Dio_PortLevelType ValueSet;
    Dio_PortLevelType ValueClear;

    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    71ec:	9b01      	ldr	r3, [sp, #4]
    71ee:	781b      	ldrb	r3, [r3, #0]
    71f0:	461a      	mov	r2, r3
    71f2:	4b10      	ldr	r3, [pc, #64]	; (7234 <Dio_Ipw_WriteChannelGroup+0x50>)
    71f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    71f8:	9305      	str	r3, [sp, #20]

#if (STD_ON == DIO_REVERSEPORTBITS)
    ValueSet = (((Dio_PortLevelType)(Dio_Ipw_ReverseBits(Level)) >> (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
#else
    ValueSet = (((Dio_PortLevelType)(Level) << (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
    71fa:	9b01      	ldr	r3, [sp, #4]
    71fc:	785b      	ldrb	r3, [r3, #1]
    71fe:	461a      	mov	r2, r3
    7200:	9b00      	ldr	r3, [sp, #0]
    7202:	fa03 f202 	lsl.w	r2, r3, r2
    7206:	9b01      	ldr	r3, [sp, #4]
    7208:	685b      	ldr	r3, [r3, #4]
    720a:	4013      	ands	r3, r2
    720c:	9304      	str	r3, [sp, #16]
#endif

    Gpio_Dio_Ip_SetPins(GpioBase, ValueSet);
    720e:	9904      	ldr	r1, [sp, #16]
    7210:	9805      	ldr	r0, [sp, #20]
    7212:	f000 f84a 	bl	72aa <Gpio_Dio_Ip_SetPins>
    ValueClear = (~ValueSet) & pChannelGroupIdPtr->mask;
    7216:	9b04      	ldr	r3, [sp, #16]
    7218:	43da      	mvns	r2, r3
    721a:	9b01      	ldr	r3, [sp, #4]
    721c:	685b      	ldr	r3, [r3, #4]
    721e:	4013      	ands	r3, r2
    7220:	9303      	str	r3, [sp, #12]
    Gpio_Dio_Ip_ClearPins(GpioBase, ValueClear);
    7222:	9903      	ldr	r1, [sp, #12]
    7224:	9805      	ldr	r0, [sp, #20]
    7226:	f000 f849 	bl	72bc <Gpio_Dio_Ip_ClearPins>

}
    722a:	bf00      	nop
    722c:	b007      	add	sp, #28
    722e:	f85d fb04 	ldr.w	pc, [sp], #4
    7232:	bf00      	nop
    7234:	1fff8b24 	.word	0x1fff8b24

00007238 <Gpio_Dio_Ip_WritePin>:
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pin,
    Gpio_Dio_Ip_PinsLevelType value
)
{
    7238:	b500      	push	{lr}
    723a:	b087      	sub	sp, #28
    723c:	9003      	str	r0, [sp, #12]
    723e:	9102      	str	r1, [sp, #8]
    7240:	4613      	mov	r3, r2
    7242:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Enter critical region */
    SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00();
    7246:	f006 ff81 	bl	e14c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>
    Gpio_Dio_Ip_PinsChannelType pinsValues = (Gpio_Dio_Ip_PinsChannelType)base->PDOR;
    724a:	9b03      	ldr	r3, [sp, #12]
    724c:	681b      	ldr	r3, [r3, #0]
    724e:	9305      	str	r3, [sp, #20]
    pinsValues &= (Gpio_Dio_Ip_PinsChannelType)(~((Gpio_Dio_Ip_PinsChannelType)1U << pin));
    7250:	2201      	movs	r2, #1
    7252:	9b02      	ldr	r3, [sp, #8]
    7254:	fa02 f303 	lsl.w	r3, r2, r3
    7258:	43db      	mvns	r3, r3
    725a:	9a05      	ldr	r2, [sp, #20]
    725c:	4013      	ands	r3, r2
    725e:	9305      	str	r3, [sp, #20]
    pinsValues |= (Gpio_Dio_Ip_PinsChannelType)((Gpio_Dio_Ip_PinsChannelType)value << pin);
    7260:	f89d 2007 	ldrb.w	r2, [sp, #7]
    7264:	9b02      	ldr	r3, [sp, #8]
    7266:	fa02 f303 	lsl.w	r3, r2, r3
    726a:	9a05      	ldr	r2, [sp, #20]
    726c:	4313      	orrs	r3, r2
    726e:	9305      	str	r3, [sp, #20]
    base->PDOR = GPIO_PDOR_PDO(pinsValues);
    7270:	9b03      	ldr	r3, [sp, #12]
    7272:	9a05      	ldr	r2, [sp, #20]
    7274:	601a      	str	r2, [r3, #0]
    /* Exit critical region */
    SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00();
    7276:	f006 ff95 	bl	e1a4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>
}
    727a:	bf00      	nop
    727c:	b007      	add	sp, #28
    727e:	f85d fb04 	ldr.w	pc, [sp], #4

00007282 <Gpio_Dio_Ip_WritePins>:
void Gpio_Dio_Ip_WritePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    7282:	b082      	sub	sp, #8
    7284:	9001      	str	r0, [sp, #4]
    7286:	9100      	str	r1, [sp, #0]
    base->PDOR = GPIO_PDOR_PDO(pins);
    7288:	9b01      	ldr	r3, [sp, #4]
    728a:	9a00      	ldr	r2, [sp, #0]
    728c:	601a      	str	r2, [r3, #0]
}
    728e:	bf00      	nop
    7290:	b002      	add	sp, #8
    7292:	4770      	bx	lr

00007294 <Gpio_Dio_Ip_GetPinsOutput>:
 * that are configured as output will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_GetPinsOutput_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_GetPinsOutput(const GPIO_Type * const base)
{
    7294:	b084      	sub	sp, #16
    7296:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    7298:	2300      	movs	r3, #0
    729a:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDOR);
    729c:	9b01      	ldr	r3, [sp, #4]
    729e:	681b      	ldr	r3, [r3, #0]
    72a0:	9303      	str	r3, [sp, #12]
    return returnValue;
    72a2:	9b03      	ldr	r3, [sp, #12]
}
    72a4:	4618      	mov	r0, r3
    72a6:	b004      	add	sp, #16
    72a8:	4770      	bx	lr

000072aa <Gpio_Dio_Ip_SetPins>:
void Gpio_Dio_Ip_SetPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    72aa:	b082      	sub	sp, #8
    72ac:	9001      	str	r0, [sp, #4]
    72ae:	9100      	str	r1, [sp, #0]
    base->PSOR = GPIO_PSOR_PTSO(pins);
    72b0:	9b01      	ldr	r3, [sp, #4]
    72b2:	9a00      	ldr	r2, [sp, #0]
    72b4:	605a      	str	r2, [r3, #4]
}
    72b6:	bf00      	nop
    72b8:	b002      	add	sp, #8
    72ba:	4770      	bx	lr

000072bc <Gpio_Dio_Ip_ClearPins>:
void Gpio_Dio_Ip_ClearPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    72bc:	b082      	sub	sp, #8
    72be:	9001      	str	r0, [sp, #4]
    72c0:	9100      	str	r1, [sp, #0]
    base->PCOR = GPIO_PCOR_PTCO(pins);
    72c2:	9b01      	ldr	r3, [sp, #4]
    72c4:	9a00      	ldr	r2, [sp, #0]
    72c6:	609a      	str	r2, [r3, #8]
}
    72c8:	bf00      	nop
    72ca:	b002      	add	sp, #8
    72cc:	4770      	bx	lr

000072ce <Gpio_Dio_Ip_TogglePins>:
void Gpio_Dio_Ip_TogglePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    72ce:	b082      	sub	sp, #8
    72d0:	9001      	str	r0, [sp, #4]
    72d2:	9100      	str	r1, [sp, #0]
    base->PTOR = GPIO_PTOR_PTTO(pins);
    72d4:	9b01      	ldr	r3, [sp, #4]
    72d6:	9a00      	ldr	r2, [sp, #0]
    72d8:	60da      	str	r2, [r3, #12]
}
    72da:	bf00      	nop
    72dc:	b002      	add	sp, #8
    72de:	4770      	bx	lr

000072e0 <Gpio_Dio_Ip_ReadPins>:
 * configured as input will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_ReadPins_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_ReadPins(const GPIO_Type * const base)
{
    72e0:	b084      	sub	sp, #16
    72e2:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    72e4:	2300      	movs	r3, #0
    72e6:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDIR);
    72e8:	9b01      	ldr	r3, [sp, #4]
    72ea:	691b      	ldr	r3, [r3, #16]
    72ec:	9303      	str	r3, [sp, #12]
    return returnValue;
    72ee:	9b03      	ldr	r3, [sp, #12]
}
    72f0:	4618      	mov	r0, r3
    72f2:	b004      	add	sp, #16
    72f4:	4770      	bx	lr

000072f6 <Gpio_Dio_Ip_ReadPin>:
 * configured as input will have meaningful value.
 *
 * @implements    Gpio_Dio_Ip_ReadPin_Activity
 */
Gpio_Dio_Ip_PinsLevelType Gpio_Dio_Ip_ReadPin(const GPIO_Type * const base, Gpio_Dio_Ip_PinsChannelType pin)
{
    72f6:	b084      	sub	sp, #16
    72f8:	9001      	str	r0, [sp, #4]
    72fa:	9100      	str	r1, [sp, #0]
    Gpio_Dio_Ip_PinsLevelType returnValue = 0U;
    72fc:	2300      	movs	r3, #0
    72fe:	f88d 300f 	strb.w	r3, [sp, #15]
    returnValue  = (Gpio_Dio_Ip_PinsLevelType)(((base->PDIR)&((uint32)1<<pin))>>(pin));
    7302:	9b01      	ldr	r3, [sp, #4]
    7304:	691a      	ldr	r2, [r3, #16]
    7306:	2101      	movs	r1, #1
    7308:	9b00      	ldr	r3, [sp, #0]
    730a:	fa01 f303 	lsl.w	r3, r1, r3
    730e:	401a      	ands	r2, r3
    7310:	9b00      	ldr	r3, [sp, #0]
    7312:	fa22 f303 	lsr.w	r3, r2, r3
    7316:	f88d 300f 	strb.w	r3, [sp, #15]

    return returnValue;
    731a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    731e:	4618      	mov	r0, r3
    7320:	b004      	add	sp, #16
    7322:	4770      	bx	lr

00007324 <Can_IsControllersBusy>:
        }
    }
#endif /* CAN_43_FLEXCAN_MAINFUNCTION_MULTIPLE_READ == STD_ON */

static boolean Can_IsControllersBusy(uint32 u32CoreId)
{
    7324:	b084      	sub	sp, #16
    7326:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    7328:	2300      	movs	r3, #0
    732a:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    732e:	2300      	movs	r3, #0
    7330:	f88d 300e 	strb.w	r3, [sp, #14]

    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    7334:	2300      	movs	r3, #0
    7336:	f88d 300e 	strb.w	r3, [sp, #14]
    733a:	e01b      	b.n	7374 <Can_IsControllersBusy+0x50>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    733c:	4a12      	ldr	r2, [pc, #72]	; (7388 <Can_IsControllersBusy+0x64>)
    733e:	9b01      	ldr	r3, [sp, #4]
    7340:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7344:	695a      	ldr	r2, [r3, #20]
    7346:	f89d 300e 	ldrb.w	r3, [sp, #14]
    734a:	009b      	lsls	r3, r3, #2
    734c:	4413      	add	r3, r2
    734e:	681b      	ldr	r3, [r3, #0]
    7350:	2b00      	cmp	r3, #0
    7352:	d00a      	beq.n	736a <Can_IsControllersBusy+0x46>
        {
            if (CAN_CS_UNINIT != Can_eControllerState[u8ControllerID])
    7354:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7358:	4a0c      	ldr	r2, [pc, #48]	; (738c <Can_IsControllersBusy+0x68>)
    735a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    735e:	2b00      	cmp	r3, #0
    7360:	d003      	beq.n	736a <Can_IsControllersBusy+0x46>
                *   The function Can_Init shall raise the error CAN_E_TRANSITION if the CAN
                *   controllers are not in state UNINIT.
                */
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_TRANSITION);
            #endif
                bCtrlBusy = TRUE;
    7362:	2301      	movs	r3, #1
    7364:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    7368:	e008      	b.n	737c <Can_IsControllersBusy+0x58>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    736a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    736e:	3301      	adds	r3, #1
    7370:	f88d 300e 	strb.w	r3, [sp, #14]
    7374:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7378:	2b00      	cmp	r3, #0
    737a:	d0df      	beq.n	733c <Can_IsControllersBusy+0x18>
            }
        }
    }

    return bCtrlBusy;
    737c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    7380:	4618      	mov	r0, r3
    7382:	b004      	add	sp, #16
    7384:	4770      	bx	lr
    7386:	bf00      	nop
    7388:	1fff8d0c 	.word	0x1fff8d0c
    738c:	1fff8d08 	.word	0x1fff8d08

00007390 <Can_InitControllers>:

static void Can_InitControllers(uint32 u32CoreId)
{
    7390:	b500      	push	{lr}
    7392:	b085      	sub	sp, #20
    7394:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    7396:	2300      	movs	r3, #0
    7398:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    739c:	2300      	movs	r3, #0
    739e:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    73a2:	2300      	movs	r3, #0
    73a4:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    73a6:	2300      	movs	r3, #0
    73a8:	f88d 300e 	strb.w	r3, [sp, #14]
    73ac:	e035      	b.n	741a <Can_InitControllers+0x8a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    73ae:	4a30      	ldr	r2, [pc, #192]	; (7470 <Can_InitControllers+0xe0>)
    73b0:	9b01      	ldr	r3, [sp, #4]
    73b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73b6:	695a      	ldr	r2, [r3, #20]
    73b8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    73bc:	009b      	lsls	r3, r3, #2
    73be:	4413      	add	r3, r2
    73c0:	681b      	ldr	r3, [r3, #0]
    73c2:	2b00      	cmp	r3, #0
    73c4:	d024      	beq.n	7410 <Can_InitControllers+0x80>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    73c6:	4a2a      	ldr	r2, [pc, #168]	; (7470 <Can_InitControllers+0xe0>)
    73c8:	9b01      	ldr	r3, [sp, #4]
    73ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73ce:	695a      	ldr	r2, [r3, #20]
    73d0:	f89d 300e 	ldrb.w	r3, [sp, #14]
    73d4:	009b      	lsls	r3, r3, #2
    73d6:	4413      	add	r3, r2
    73d8:	681b      	ldr	r3, [r3, #0]
    73da:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    73dc:	9b02      	ldr	r3, [sp, #8]
    73de:	7a1b      	ldrb	r3, [r3, #8]
    73e0:	2b00      	cmp	r3, #0
    73e2:	d015      	beq.n	7410 <Can_InitControllers+0x80>
                */
            #if ((CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) || (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON))
                Can_au16BaudrateIDConfig[u8ControllerID] = Can_pController->Can_u16DefaultBaudrateID;
            #endif
                /* Reset interrupt level to default value after re-init */
                Can_au8DisableInterruptLevel[u8ControllerID] = 0U;
    73e4:	f89d 300e 	ldrb.w	r3, [sp, #14]
    73e8:	4a22      	ldr	r2, [pc, #136]	; (7474 <Can_InitControllers+0xe4>)
    73ea:	2100      	movs	r1, #0
    73ec:	54d1      	strb	r1, [r2, r3]
            #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
                Can_apxCtrlConfigIcomIndex[u8ControllerID] = NULL_PTR;
            #endif
                /* Init the controller */
                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_Init(Can_pController))
    73ee:	9802      	ldr	r0, [sp, #8]
    73f0:	f001 f830 	bl	8454 <Can_43_FLEXCAN_Ipw_Init>
    73f4:	4603      	mov	r3, r0
    73f6:	2b00      	cmp	r3, #0
    73f8:	d106      	bne.n	7408 <Can_InitControllers+0x78>
                {
                    Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    73fa:	f89d 300e 	ldrb.w	r3, [sp, #14]
    73fe:	4a1e      	ldr	r2, [pc, #120]	; (7478 <Can_InitControllers+0xe8>)
    7400:	2102      	movs	r1, #2
    7402:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    7406:	e003      	b.n	7410 <Can_InitControllers+0x80>
                else
                {
                    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_INIT_FAILED);
                    #endif
                    bCtrlBusy = TRUE;
    7408:	2301      	movs	r3, #1
    740a:	f88d 300f 	strb.w	r3, [sp, #15]
                    break;
    740e:	e008      	b.n	7422 <Can_InitControllers+0x92>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    7410:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7414:	3301      	adds	r3, #1
    7416:	f88d 300e 	strb.w	r3, [sp, #14]
    741a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    741e:	2b00      	cmp	r3, #0
    7420:	d0c5      	beq.n	73ae <Can_InitControllers+0x1e>
    }
    /*
    *  [SWS_Can_00246] After initializing all controllers inside the HW Unit, the function Can_Init
    *   shall change the module state to CAN_READY.
    */
    if (TRUE == bCtrlBusy)
    7422:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7426:	2b00      	cmp	r3, #0
    7428:	d01e      	beq.n	7468 <Can_InitControllers+0xd8>
    {
        /* Init failed due to one or more controllers failed, reset status of all  core's current controllers */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    742a:	2300      	movs	r3, #0
    742c:	f88d 300e 	strb.w	r3, [sp, #14]
    7430:	e016      	b.n	7460 <Can_InitControllers+0xd0>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    7432:	4a0f      	ldr	r2, [pc, #60]	; (7470 <Can_InitControllers+0xe0>)
    7434:	9b01      	ldr	r3, [sp, #4]
    7436:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    743a:	695a      	ldr	r2, [r3, #20]
    743c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7440:	009b      	lsls	r3, r3, #2
    7442:	4413      	add	r3, r2
    7444:	681b      	ldr	r3, [r3, #0]
    7446:	2b00      	cmp	r3, #0
    7448:	d005      	beq.n	7456 <Can_InitControllers+0xc6>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    744a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    744e:	4a0a      	ldr	r2, [pc, #40]	; (7478 <Can_InitControllers+0xe8>)
    7450:	2100      	movs	r1, #0
    7452:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    7456:	f89d 300e 	ldrb.w	r3, [sp, #14]
    745a:	3301      	adds	r3, #1
    745c:	f88d 300e 	strb.w	r3, [sp, #14]
    7460:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7464:	2b00      	cmp	r3, #0
    7466:	d0e4      	beq.n	7432 <Can_InitControllers+0xa2>
    else
    {
        Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_READY;
    }
#endif
}
    7468:	bf00      	nop
    746a:	b005      	add	sp, #20
    746c:	f85d fb04 	ldr.w	pc, [sp], #4
    7470:	1fff8d0c 	.word	0x1fff8d0c
    7474:	1fff8d04 	.word	0x1fff8d04
    7478:	1fff8d08 	.word	0x1fff8d08

0000747c <Can_DeInitControllers>:
    return bResult;
}
#endif

static void Can_DeInitControllers(uint32 u32CoreId)
{
    747c:	b500      	push	{lr}
    747e:	b085      	sub	sp, #20
    7480:	9001      	str	r0, [sp, #4]
    uint8 u8ControllerID = 0U;
    7482:	2300      	movs	r3, #0
    7484:	f88d 300f 	strb.w	r3, [sp, #15]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7488:	2300      	movs	r3, #0
    748a:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    748c:	2300      	movs	r3, #0
    748e:	f88d 300f 	strb.w	r3, [sp, #15]
    7492:	e028      	b.n	74e6 <Can_DeInitControllers+0x6a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    7494:	4a18      	ldr	r2, [pc, #96]	; (74f8 <Can_DeInitControllers+0x7c>)
    7496:	9b01      	ldr	r3, [sp, #4]
    7498:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    749c:	695a      	ldr	r2, [r3, #20]
    749e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74a2:	009b      	lsls	r3, r3, #2
    74a4:	4413      	add	r3, r2
    74a6:	681b      	ldr	r3, [r3, #0]
    74a8:	2b00      	cmp	r3, #0
    74aa:	d017      	beq.n	74dc <Can_DeInitControllers+0x60>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    74ac:	4a12      	ldr	r2, [pc, #72]	; (74f8 <Can_DeInitControllers+0x7c>)
    74ae:	9b01      	ldr	r3, [sp, #4]
    74b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74b4:	695a      	ldr	r2, [r3, #20]
    74b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74ba:	009b      	lsls	r3, r3, #2
    74bc:	4413      	add	r3, r2
    74be:	681b      	ldr	r3, [r3, #0]
    74c0:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    74c2:	9b02      	ldr	r3, [sp, #8]
    74c4:	7a1b      	ldrb	r3, [r3, #8]
    74c6:	2b00      	cmp	r3, #0
    74c8:	d008      	beq.n	74dc <Can_DeInitControllers+0x60>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    74ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74ce:	4a0b      	ldr	r2, [pc, #44]	; (74fc <Can_DeInitControllers+0x80>)
    74d0:	2100      	movs	r1, #0
    74d2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                Can_43_FLEXCAN_Ipw_DeInit(Can_pController);
    74d6:	9802      	ldr	r0, [sp, #8]
    74d8:	f001 f8cc 	bl	8674 <Can_43_FLEXCAN_Ipw_DeInit>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    74dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74e0:	3301      	adds	r3, #1
    74e2:	f88d 300f 	strb.w	r3, [sp, #15]
    74e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74ea:	2b00      	cmp	r3, #0
    74ec:	d0d2      	beq.n	7494 <Can_DeInitControllers+0x18>
            }
        }
    }
}
    74ee:	bf00      	nop
    74f0:	bf00      	nop
    74f2:	b005      	add	sp, #20
    74f4:	f85d fb04 	ldr.w	pc, [sp], #4
    74f8:	1fff8d0c 	.word	0x1fff8d0c
    74fc:	1fff8d08 	.word	0x1fff8d08

00007500 <Can_43_FLEXCAN_Init>:
* @api
*/

/* implements     Can_Init_Activity */
void Can_43_FLEXCAN_Init(const Can_43_FLEXCAN_ConfigType * Config)
{
    7500:	b500      	push	{lr}
    7502:	b085      	sub	sp, #20
    7504:	9001      	str	r0, [sp, #4]
    uint32 u32CoreId = 0U;
    7506:	2300      	movs	r3, #0
    7508:	9303      	str	r3, [sp, #12]
    boolean bCtrlBusy = FALSE;
    750a:	2300      	movs	r3, #0
    750c:	f88d 300b 	strb.w	r3, [sp, #11]
#if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
    boolean bValidCoreID = FALSE;
#endif

    u32CoreId = Can_GetCoreID();
    7510:	2300      	movs	r3, #0
    7512:	9303      	str	r3, [sp, #12]
        #if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
            if (u32CoreId == Config->Can_u32CoreID)
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Copy pointer to current Can Driver configuration. */
                Can_apxConfig[u32CoreId] = Config;
    7514:	490c      	ldr	r1, [pc, #48]	; (7548 <Can_43_FLEXCAN_Init+0x48>)
    7516:	9b03      	ldr	r3, [sp, #12]
    7518:	9a01      	ldr	r2, [sp, #4]
    751a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            if (TRUE == bValidCoreID)
            {
#endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Fault Injection point to allow to test SWS_Can_00408 */
                MCAL_FAULT_INJECTION_POINT(CAN_FIP_1_CHANGE_DRIVER_TO_UNINITIALIZED);
                bCtrlBusy = Can_IsControllersBusy(u32CoreId);
    751e:	9803      	ldr	r0, [sp, #12]
    7520:	f7ff ff00 	bl	7324 <Can_IsControllersBusy>
    7524:	4603      	mov	r3, r0
    7526:	f88d 300b 	strb.w	r3, [sp, #11]
                if (FALSE == bCtrlBusy)
    752a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    752e:	f083 0301 	eor.w	r3, r3, #1
    7532:	b2db      	uxtb	r3, r3
    7534:	2b00      	cmp	r3, #0
    7536:	d002      	beq.n	753e <Can_43_FLEXCAN_Init+0x3e>
                {
                    Can_InitControllers(u32CoreId);
    7538:	9803      	ldr	r0, [sp, #12]
    753a:	f7ff ff29 	bl	7390 <Can_InitControllers>

#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif /* (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) */
}
    753e:	bf00      	nop
    7540:	b005      	add	sp, #20
    7542:	f85d fb04 	ldr.w	pc, [sp], #4
    7546:	bf00      	nop
    7548:	1fff8d0c 	.word	0x1fff8d0c

0000754c <Can_43_FLEXCAN_DeInit>:
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
*/
/* implements     Can_DeInit_Activity */
void Can_43_FLEXCAN_DeInit(void)
{
    754c:	b500      	push	{lr}
    754e:	b083      	sub	sp, #12
    /* Variable for indexing the controllers. */
    uint8 u8ControllerID = 0U;
    7550:	2300      	movs	r3, #0
    7552:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean bCtrlBusy = FALSE;
    7556:	2300      	movs	r3, #0
    7558:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 u32CoreId = 0U;
    755c:	2300      	movs	r3, #0
    755e:	9300      	str	r3, [sp, #0]

    u32CoreId = Can_GetCoreID();
    7560:	2300      	movs	r3, #0
    7562:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    7564:	2300      	movs	r3, #0
    7566:	f88d 3007 	strb.w	r3, [sp, #7]
    756a:	e01b      	b.n	75a4 <Can_43_FLEXCAN_DeInit+0x58>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    756c:	4a19      	ldr	r2, [pc, #100]	; (75d4 <Can_43_FLEXCAN_DeInit+0x88>)
    756e:	9b00      	ldr	r3, [sp, #0]
    7570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7574:	695a      	ldr	r2, [r3, #20]
    7576:	f89d 3007 	ldrb.w	r3, [sp, #7]
    757a:	009b      	lsls	r3, r3, #2
    757c:	4413      	add	r3, r2
    757e:	681b      	ldr	r3, [r3, #0]
    7580:	2b00      	cmp	r3, #0
    7582:	d00a      	beq.n	759a <Can_43_FLEXCAN_DeInit+0x4e>
            {
                if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    7584:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7588:	4a13      	ldr	r2, [pc, #76]	; (75d8 <Can_43_FLEXCAN_DeInit+0x8c>)
    758a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    758e:	2b01      	cmp	r3, #1
    7590:	d103      	bne.n	759a <Can_43_FLEXCAN_DeInit+0x4e>
                    *   if any of the CAN controllers is in state STARTED.
                    */
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_DEINIT, (uint8)CAN_43_FLEXCAN_E_TRANSITION);
                #endif
                    /* Controller is busy */
                    bCtrlBusy =  TRUE;
    7592:	2301      	movs	r3, #1
    7594:	f88d 3006 	strb.w	r3, [sp, #6]
                    /* Skipping the loop if any of Can Controller is in state STARTED */
                    break;
    7598:	e008      	b.n	75ac <Can_43_FLEXCAN_DeInit+0x60>
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    759a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    759e:	3301      	adds	r3, #1
    75a0:	f88d 3007 	strb.w	r3, [sp, #7]
    75a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    75a8:	2b00      	cmp	r3, #0
    75aa:	d0df      	beq.n	756c <Can_43_FLEXCAN_DeInit+0x20>
                }
            }
        }
        /* All Controllers are not busy */
        if (FALSE == bCtrlBusy)
    75ac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    75b0:	f083 0301 	eor.w	r3, r3, #1
    75b4:	b2db      	uxtb	r3, r3
    75b6:	2b00      	cmp	r3, #0
    75b8:	d007      	beq.n	75ca <Can_43_FLEXCAN_DeInit+0x7e>
            *   [SWS_Can_91010] The function Can_DeInit shall change the module state to
            *   CAN_UNINIT before de-initializing all controllers inside the HW unit
            */
            Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_UNINIT;
        #endif
            Can_DeInitControllers(u32CoreId);
    75ba:	9800      	ldr	r0, [sp, #0]
    75bc:	f7ff ff5e 	bl	747c <Can_DeInitControllers>
            Can_apxConfig[u32CoreId] = NULL_PTR;
    75c0:	4a04      	ldr	r2, [pc, #16]	; (75d4 <Can_43_FLEXCAN_DeInit+0x88>)
    75c2:	9b00      	ldr	r3, [sp, #0]
    75c4:	2100      	movs	r1, #0
    75c6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
}
    75ca:	bf00      	nop
    75cc:	b003      	add	sp, #12
    75ce:	f85d fb04 	ldr.w	pc, [sp], #4
    75d2:	bf00      	nop
    75d4:	1fff8d0c 	.word	0x1fff8d0c
    75d8:	1fff8d08 	.word	0x1fff8d08

000075dc <Can_43_FLEXCAN_SetBaudrate>:
    Std_ReturnType Can_43_FLEXCAN_SetBaudrate
    (
        uint8 Controller,
        uint16 BaudRateConfigID
    )
    {
    75dc:	b500      	push	{lr}
    75de:	b087      	sub	sp, #28
    75e0:	4603      	mov	r3, r0
    75e2:	460a      	mov	r2, r1
    75e4:	f88d 3007 	strb.w	r3, [sp, #7]
    75e8:	4613      	mov	r3, r2
    75ea:	f8ad 3004 	strh.w	r3, [sp, #4]
        /* Returns the result of CAN set baudrate */
        Std_ReturnType eRetVal = (Std_ReturnType)E_NOT_OK;
    75ee:	2301      	movs	r3, #1
    75f0:	f88d 3017 	strb.w	r3, [sp, #23]
        uint32 u32CoreId = 0U;
    75f4:	2300      	movs	r3, #0
    75f6:	9304      	str	r3, [sp, #16]
        const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    75f8:	2300      	movs	r3, #0
    75fa:	9303      	str	r3, [sp, #12]

        u32CoreId = Can_GetCoreID();
    75fc:	2300      	movs	r3, #0
    75fe:	9304      	str	r3, [sp, #16]
    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
        if (TRUE == Can_ValidateController(u32CoreId, Controller, CAN_43_FLEXCAN_SID_SET_BAUDRATE))
        {
    #endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    7600:	4a10      	ldr	r2, [pc, #64]	; (7644 <Can_43_FLEXCAN_SetBaudrate+0x68>)
    7602:	9b04      	ldr	r3, [sp, #16]
    7604:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7608:	695a      	ldr	r2, [r3, #20]
    760a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    760e:	009b      	lsls	r3, r3, #2
    7610:	4413      	add	r3, r2
    7612:	681b      	ldr	r3, [r3, #0]
    7614:	9303      	str	r3, [sp, #12]
                        (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_SET_BAUDRATE, CAN_43_FLEXCAN_E_PARAM_BAUDRATE);
                    }
                    else
                    {
                #endif
                        if (CAN_CS_STOPPED == Can_eControllerState[Controller])
    7616:	f89d 3007 	ldrb.w	r3, [sp, #7]
    761a:	4a0b      	ldr	r2, [pc, #44]	; (7648 <Can_43_FLEXCAN_SetBaudrate+0x6c>)
    761c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7620:	2b02      	cmp	r3, #2
    7622:	d108      	bne.n	7636 <Can_43_FLEXCAN_SetBaudrate+0x5a>
                        {
                            eRetVal = Can_43_FLEXCAN_Ipw_SetBaudrate(Can_pController, BaudRateConfigID);
    7624:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    7628:	4619      	mov	r1, r3
    762a:	9803      	ldr	r0, [sp, #12]
    762c:	f001 f82e 	bl	868c <Can_43_FLEXCAN_Ipw_SetBaudrate>
    7630:	4603      	mov	r3, r0
    7632:	f88d 3017 	strb.w	r3, [sp, #23]
                        }
    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    }
        }
    #endif
        return eRetVal;
    7636:	f89d 3017 	ldrb.w	r3, [sp, #23]
    }
    763a:	4618      	mov	r0, r3
    763c:	b007      	add	sp, #28
    763e:	f85d fb04 	ldr.w	pc, [sp], #4
    7642:	bf00      	nop
    7644:	1fff8d0c 	.word	0x1fff8d0c
    7648:	1fff8d08 	.word	0x1fff8d08

0000764c <Can_43_FLEXCAN_SetControllerMode>:
*
* @api
*/
/* implements     Can_SetControllerMode_Activity */
Std_ReturnType Can_43_FLEXCAN_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    764c:	b500      	push	{lr}
    764e:	b087      	sub	sp, #28
    7650:	4603      	mov	r3, r0
    7652:	9100      	str	r1, [sp, #0]
    7654:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    7658:	2301      	movs	r3, #1
    765a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    765e:	2300      	movs	r3, #0
    7660:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7662:	2300      	movs	r3, #0
    7664:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    7666:	2300      	movs	r3, #0
    7668:	9304      	str	r3, [sp, #16]
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    if (TRUE == Can_ValidateController(u32CoreId, Controller, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE))
    {
#endif
                Can_pController = (const Can_43_FLEXCAN_ControllerConfigType *)(Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    766a:	4a47      	ldr	r2, [pc, #284]	; (7788 <Can_43_FLEXCAN_SetControllerMode+0x13c>)
    766c:	9b04      	ldr	r3, [sp, #16]
    766e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7672:	695a      	ldr	r2, [r3, #20]
    7674:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7678:	009b      	lsls	r3, r3, #2
    767a:	4413      	add	r3, r2
    767c:	681b      	ldr	r3, [r3, #0]
    767e:	9303      	str	r3, [sp, #12]
                /*
                *   [SWS_Can_00017] The function Can_SetControllerMode shall perform software
                *   triggered state transitions of the CAN controller State machine.
                */
                switch (Transition)
    7680:	9b00      	ldr	r3, [sp, #0]
    7682:	2b03      	cmp	r3, #3
    7684:	d05d      	beq.n	7742 <Can_43_FLEXCAN_SetControllerMode+0xf6>
    7686:	9b00      	ldr	r3, [sp, #0]
    7688:	2b03      	cmp	r3, #3
    768a:	d874      	bhi.n	7776 <Can_43_FLEXCAN_SetControllerMode+0x12a>
    768c:	9b00      	ldr	r3, [sp, #0]
    768e:	2b01      	cmp	r3, #1
    7690:	d003      	beq.n	769a <Can_43_FLEXCAN_SetControllerMode+0x4e>
    7692:	9b00      	ldr	r3, [sp, #0]
    7694:	2b02      	cmp	r3, #2
    7696:	d01d      	beq.n	76d4 <Can_43_FLEXCAN_SetControllerMode+0x88>
                        *   has been requested, the function Can_SetControllerMode shall raise the error CAN_E_TRANSITION and
                        *   return E_NOT_OK
                        */
                        (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_TRANSITION);
                    #endif
                        break;
    7698:	e06d      	b.n	7776 <Can_43_FLEXCAN_SetControllerMode+0x12a>
                        if (CAN_CS_STOPPED == Can_eControllerState[Controller])
    769a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    769e:	4a3b      	ldr	r2, [pc, #236]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    76a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76a4:	2b02      	cmp	r3, #2
    76a6:	d168      	bne.n	777a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStartMode(Can_pController))
    76a8:	9803      	ldr	r0, [sp, #12]
    76aa:	f001 f8f5 	bl	8898 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>
    76ae:	4603      	mov	r3, r0
    76b0:	2b00      	cmp	r3, #0
    76b2:	d162      	bne.n	777a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                                Can_eControllerState[Controller] = CAN_CS_STARTED;
    76b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    76b8:	4a34      	ldr	r2, [pc, #208]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    76ba:	2101      	movs	r1, #1
    76bc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STARTED);
    76c0:	9b03      	ldr	r3, [sp, #12]
    76c2:	781b      	ldrb	r3, [r3, #0]
    76c4:	2101      	movs	r1, #1
    76c6:	4618      	mov	r0, r3
    76c8:	f008 f9a6 	bl	fa18 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    76cc:	2300      	movs	r3, #0
    76ce:	f88d 3017 	strb.w	r3, [sp, #23]
                        break;
    76d2:	e052      	b.n	777a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                        switch (Can_eControllerState[Controller])
    76d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    76d8:	4a2c      	ldr	r2, [pc, #176]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    76da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76de:	2b01      	cmp	r3, #1
    76e0:	d005      	beq.n	76ee <Can_43_FLEXCAN_SetControllerMode+0xa2>
    76e2:	2b00      	cmp	r3, #0
    76e4:	d029      	beq.n	773a <Can_43_FLEXCAN_SetControllerMode+0xee>
    76e6:	3b02      	subs	r3, #2
    76e8:	2b01      	cmp	r3, #1
    76ea:	d826      	bhi.n	773a <Can_43_FLEXCAN_SetControllerMode+0xee>
    76ec:	e015      	b.n	771a <Can_43_FLEXCAN_SetControllerMode+0xce>
                                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    76ee:	9803      	ldr	r0, [sp, #12]
    76f0:	f001 f940 	bl	8974 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    76f4:	4603      	mov	r3, r0
    76f6:	2b00      	cmp	r3, #0
    76f8:	d121      	bne.n	773e <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                    Can_eControllerState[Controller] = CAN_CS_STOPPED;
    76fa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    76fe:	4a23      	ldr	r2, [pc, #140]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    7700:	2102      	movs	r1, #2
    7702:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                    CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    7706:	9b03      	ldr	r3, [sp, #12]
    7708:	781b      	ldrb	r3, [r3, #0]
    770a:	2102      	movs	r1, #2
    770c:	4618      	mov	r0, r3
    770e:	f008 f983 	bl	fa18 <CanIf_ControllerModeIndication>
                                    eRetVal = E_OK;
    7712:	2300      	movs	r3, #0
    7714:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    7718:	e011      	b.n	773e <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                Can_eControllerState[Controller] = CAN_CS_STOPPED;
    771a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    771e:	4a1b      	ldr	r2, [pc, #108]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    7720:	2102      	movs	r1, #2
    7722:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    7726:	9b03      	ldr	r3, [sp, #12]
    7728:	781b      	ldrb	r3, [r3, #0]
    772a:	2102      	movs	r1, #2
    772c:	4618      	mov	r0, r3
    772e:	f008 f973 	bl	fa18 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    7732:	2300      	movs	r3, #0
    7734:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    7738:	e002      	b.n	7740 <Can_43_FLEXCAN_SetControllerMode+0xf4>
                                break;
    773a:	bf00      	nop
    773c:	e01e      	b.n	777c <Can_43_FLEXCAN_SetControllerMode+0x130>
                                break;
    773e:	bf00      	nop
                        break;
    7740:	e01c      	b.n	777c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        switch (Can_eControllerState[Controller])
    7742:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7746:	4a11      	ldr	r2, [pc, #68]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    7748:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    774c:	3b02      	subs	r3, #2
    774e:	2b01      	cmp	r3, #1
    7750:	d80f      	bhi.n	7772 <Can_43_FLEXCAN_SetControllerMode+0x126>
                                Can_eControllerState[Controller] = CAN_CS_SLEEP;
    7752:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7756:	4a0d      	ldr	r2, [pc, #52]	; (778c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    7758:	2103      	movs	r1, #3
    775a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_SLEEP);
    775e:	9b03      	ldr	r3, [sp, #12]
    7760:	781b      	ldrb	r3, [r3, #0]
    7762:	2103      	movs	r1, #3
    7764:	4618      	mov	r0, r3
    7766:	f008 f957 	bl	fa18 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    776a:	2300      	movs	r3, #0
    776c:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    7770:	e000      	b.n	7774 <Can_43_FLEXCAN_SetControllerMode+0x128>
                                break;
    7772:	bf00      	nop
                        break;
    7774:	e002      	b.n	777c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    7776:	bf00      	nop
    7778:	e000      	b.n	777c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    777a:	bf00      	nop
                    }
                }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eRetVal;
    777c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    7780:	4618      	mov	r0, r3
    7782:	b007      	add	sp, #28
    7784:	f85d fb04 	ldr.w	pc, [sp], #4
    7788:	1fff8d0c 	.word	0x1fff8d0c
    778c:	1fff8d08 	.word	0x1fff8d08

00007790 <Can_43_FLEXCAN_DisableControllerInterrupts>:
*
* @api
*/
/* implements     Can_DisableControllerInterrupts_Activity */
void Can_43_FLEXCAN_DisableControllerInterrupts(uint8 Controller)
{
    7790:	b500      	push	{lr}
    7792:	b085      	sub	sp, #20
    7794:	4603      	mov	r3, r0
    7796:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    779a:	2300      	movs	r3, #0
    779c:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    779e:	2300      	movs	r3, #0
    77a0:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    77a2:	2300      	movs	r3, #0
    77a4:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    77a6:	4a10      	ldr	r2, [pc, #64]	; (77e8 <Can_43_FLEXCAN_DisableControllerInterrupts+0x58>)
    77a8:	9b03      	ldr	r3, [sp, #12]
    77aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77ae:	695a      	ldr	r2, [r3, #20]
    77b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77b4:	009b      	lsls	r3, r3, #2
    77b6:	4413      	add	r3, r2
    77b8:	681b      	ldr	r3, [r3, #0]
    77ba:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    77bc:	f005 fe0c 	bl	d3d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_au8DisableInterruptLevel[Controller] += 1U;
    77c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77c4:	4a09      	ldr	r2, [pc, #36]	; (77ec <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    77c6:	5cd2      	ldrb	r2, [r2, r3]
    77c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77cc:	3201      	adds	r2, #1
    77ce:	b2d1      	uxtb	r1, r2
    77d0:	4a06      	ldr	r2, [pc, #24]	; (77ec <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    77d2:	54d1      	strb	r1, [r2, r3]
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    77d4:	f005 fe2c 	bl	d430 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(Can_pController);
    77d8:	9802      	ldr	r0, [sp, #8]
    77da:	f001 f949 	bl	8a70 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    77de:	bf00      	nop
    77e0:	b005      	add	sp, #20
    77e2:	f85d fb04 	ldr.w	pc, [sp], #4
    77e6:	bf00      	nop
    77e8:	1fff8d0c 	.word	0x1fff8d0c
    77ec:	1fff8d04 	.word	0x1fff8d04

000077f0 <Can_43_FLEXCAN_EnableControllerInterrupts>:
*
* @api
*/
/* implements     Can_EnableControllerInterrupts_Activity */
void Can_43_FLEXCAN_EnableControllerInterrupts(uint8 Controller)
{
    77f0:	b500      	push	{lr}
    77f2:	b085      	sub	sp, #20
    77f4:	4603      	mov	r3, r0
    77f6:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    77fa:	2300      	movs	r3, #0
    77fc:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    77fe:	2300      	movs	r3, #0
    7800:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    7802:	2300      	movs	r3, #0
    7804:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    7806:	4a16      	ldr	r2, [pc, #88]	; (7860 <Can_43_FLEXCAN_EnableControllerInterrupts+0x70>)
    7808:	9b03      	ldr	r3, [sp, #12]
    780a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    780e:	695a      	ldr	r2, [r3, #20]
    7810:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7814:	009b      	lsls	r3, r3, #2
    7816:	4413      	add	r3, r2
    7818:	681b      	ldr	r3, [r3, #0]
    781a:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    781c:	f005 fe2e 	bl	d47c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>
                if (Can_au8DisableInterruptLevel[Controller] > 0U)
    7820:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7824:	4a0f      	ldr	r2, [pc, #60]	; (7864 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    7826:	5cd3      	ldrb	r3, [r2, r3]
    7828:	2b00      	cmp	r3, #0
    782a:	d009      	beq.n	7840 <Can_43_FLEXCAN_EnableControllerInterrupts+0x50>
                {
                    Can_au8DisableInterruptLevel[Controller] -= 1U;
    782c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7830:	4a0c      	ldr	r2, [pc, #48]	; (7864 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    7832:	5cd2      	ldrb	r2, [r2, r3]
    7834:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7838:	3a01      	subs	r2, #1
    783a:	b2d1      	uxtb	r1, r2
    783c:	4a09      	ldr	r2, [pc, #36]	; (7864 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    783e:	54d1      	strb	r1, [r2, r3]
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    7840:	f005 fe48 	bl	d4d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>

                if (0U == Can_au8DisableInterruptLevel[Controller])
    7844:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7848:	4a06      	ldr	r2, [pc, #24]	; (7864 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    784a:	5cd3      	ldrb	r3, [r2, r3]
    784c:	2b00      	cmp	r3, #0
    784e:	d102      	bne.n	7856 <Can_43_FLEXCAN_EnableControllerInterrupts+0x66>
                {
                    Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(Can_pController);
    7850:	9802      	ldr	r0, [sp, #8]
    7852:	f001 f937 	bl	8ac4 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    7856:	bf00      	nop
    7858:	b005      	add	sp, #20
    785a:	f85d fb04 	ldr.w	pc, [sp], #4
    785e:	bf00      	nop
    7860:	1fff8d0c 	.word	0x1fff8d0c
    7864:	1fff8d04 	.word	0x1fff8d04

00007868 <Can_43_FLEXCAN_GetControllerErrorState>:
Std_ReturnType Can_43_FLEXCAN_GetControllerErrorState
(
    uint8 ControllerId,
    Can_ErrorStateType * ErrorStatePtr
)
{
    7868:	b500      	push	{lr}
    786a:	b087      	sub	sp, #28
    786c:	4603      	mov	r3, r0
    786e:	9100      	str	r1, [sp, #0]
    7870:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    7874:	2301      	movs	r3, #1
    7876:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 errorState = 0U;
    787a:	2300      	movs	r3, #0
    787c:	f88d 300b 	strb.w	r3, [sp, #11]
    uint32 u32CoreId = 0U;
    7880:	2300      	movs	r3, #0
    7882:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7884:	2300      	movs	r3, #0
    7886:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    7888:	2300      	movs	r3, #0
    788a:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_ERROR_STATE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    788c:	4a18      	ldr	r2, [pc, #96]	; (78f0 <Can_43_FLEXCAN_GetControllerErrorState+0x88>)
    788e:	9b04      	ldr	r3, [sp, #16]
    7890:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7894:	695a      	ldr	r2, [r3, #20]
    7896:	f89d 3007 	ldrb.w	r3, [sp, #7]
    789a:	009b      	lsls	r3, r3, #2
    789c:	4413      	add	r3, r2
    789e:	681b      	ldr	r3, [r3, #0]
    78a0:	9303      	str	r3, [sp, #12]
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerErrorState(Can_pController, &errorState);
    78a2:	f10d 030b 	add.w	r3, sp, #11
    78a6:	4619      	mov	r1, r3
    78a8:	9803      	ldr	r0, [sp, #12]
    78aa:	f001 f937 	bl	8b1c <Can_43_FLEXCAN_Ipw_GetControllerErrorState>
    78ae:	4603      	mov	r3, r0
    78b0:	f88d 3017 	strb.w	r3, [sp, #23]
                    if(eRetVal == (Std_ReturnType)E_OK)
    78b4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    78b8:	2b00      	cmp	r3, #0
    78ba:	d112      	bne.n	78e2 <Can_43_FLEXCAN_GetControllerErrorState+0x7a>
                    {
                        switch (errorState)
    78bc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    78c0:	2b00      	cmp	r3, #0
    78c2:	d002      	beq.n	78ca <Can_43_FLEXCAN_GetControllerErrorState+0x62>
    78c4:	2b01      	cmp	r3, #1
    78c6:	d004      	beq.n	78d2 <Can_43_FLEXCAN_GetControllerErrorState+0x6a>
    78c8:	e007      	b.n	78da <Can_43_FLEXCAN_GetControllerErrorState+0x72>
                        {
                            case 0x00U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
    78ca:	9b00      	ldr	r3, [sp, #0]
    78cc:	2200      	movs	r2, #0
    78ce:	601a      	str	r2, [r3, #0]
                                break;
    78d0:	e008      	b.n	78e4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            case 0x01U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
    78d2:	9b00      	ldr	r3, [sp, #0]
    78d4:	2201      	movs	r2, #1
    78d6:	601a      	str	r2, [r3, #0]
                                break;
    78d8:	e004      	b.n	78e4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            default:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
    78da:	9b00      	ldr	r3, [sp, #0]
    78dc:	2202      	movs	r2, #2
    78de:	601a      	str	r2, [r3, #0]
                                break;
    78e0:	e000      	b.n	78e4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                        }
                    }
    78e2:	bf00      	nop
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                }
    }
#endif
    return eRetVal;
    78e4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    78e8:	4618      	mov	r0, r3
    78ea:	b007      	add	sp, #28
    78ec:	f85d fb04 	ldr.w	pc, [sp], #4
    78f0:	1fff8d0c 	.word	0x1fff8d0c

000078f4 <Can_43_FLEXCAN_GetControllerMode>:
Std_ReturnType Can_43_FLEXCAN_GetControllerMode
(
    uint8 Controller,
    Can_ControllerStateType * ControllerModePtr
)
{
    78f4:	b084      	sub	sp, #16
    78f6:	4603      	mov	r3, r0
    78f8:	9100      	str	r1, [sp, #0]
    78fa:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    78fe:	2301      	movs	r3, #1
    7900:	f88d 300f 	strb.w	r3, [sp, #15]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    *ControllerModePtr = Can_eControllerState[Controller];
    7904:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7908:	4a06      	ldr	r2, [pc, #24]	; (7924 <Can_43_FLEXCAN_GetControllerMode+0x30>)
    790a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    790e:	9b00      	ldr	r3, [sp, #0]
    7910:	601a      	str	r2, [r3, #0]
                    eRetVal = E_OK;
    7912:	2300      	movs	r3, #0
    7914:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    7918:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    791c:	4618      	mov	r0, r3
    791e:	b004      	add	sp, #16
    7920:	4770      	bx	lr
    7922:	bf00      	nop
    7924:	1fff8d08 	.word	0x1fff8d08

00007928 <Can_43_FLEXCAN_GetControllerRxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerRxErrorCounter
(
    uint8 ControllerId,
    uint8 * RxErrorCounterPtr
)
{
    7928:	b500      	push	{lr}
    792a:	b087      	sub	sp, #28
    792c:	4603      	mov	r3, r0
    792e:	9100      	str	r1, [sp, #0]
    7930:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    7934:	2301      	movs	r3, #1
    7936:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    793a:	2300      	movs	r3, #0
    793c:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    793e:	2300      	movs	r3, #0
    7940:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    7942:	2300      	movs	r3, #0
    7944:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_RX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    7946:	4a0c      	ldr	r2, [pc, #48]	; (7978 <Can_43_FLEXCAN_GetControllerRxErrorCounter+0x50>)
    7948:	9b04      	ldr	r3, [sp, #16]
    794a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    794e:	695a      	ldr	r2, [r3, #20]
    7950:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7954:	009b      	lsls	r3, r3, #2
    7956:	4413      	add	r3, r2
    7958:	681b      	ldr	r3, [r3, #0]
    795a:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Rx error counter
                    *   register of Can Controller and shall return the Rx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(Can_pController, RxErrorCounterPtr);
    795c:	9900      	ldr	r1, [sp, #0]
    795e:	9803      	ldr	r0, [sp, #12]
    7960:	f001 f907 	bl	8b72 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>
    7964:	4603      	mov	r3, r0
    7966:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    796a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    796e:	4618      	mov	r0, r3
    7970:	b007      	add	sp, #28
    7972:	f85d fb04 	ldr.w	pc, [sp], #4
    7976:	bf00      	nop
    7978:	1fff8d0c 	.word	0x1fff8d0c

0000797c <Can_43_FLEXCAN_GetControllerTxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerTxErrorCounter
(
    uint8 ControllerId,
    uint8 * TxErrorCounterPtr
)
{
    797c:	b500      	push	{lr}
    797e:	b087      	sub	sp, #28
    7980:	4603      	mov	r3, r0
    7982:	9100      	str	r1, [sp, #0]
    7984:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    7988:	2301      	movs	r3, #1
    798a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    798e:	2300      	movs	r3, #0
    7990:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7992:	2300      	movs	r3, #0
    7994:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    7996:	2300      	movs	r3, #0
    7998:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_TX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    799a:	4a0c      	ldr	r2, [pc, #48]	; (79cc <Can_43_FLEXCAN_GetControllerTxErrorCounter+0x50>)
    799c:	9b04      	ldr	r3, [sp, #16]
    799e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79a2:	695a      	ldr	r2, [r3, #20]
    79a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    79a8:	009b      	lsls	r3, r3, #2
    79aa:	4413      	add	r3, r2
    79ac:	681b      	ldr	r3, [r3, #0]
    79ae:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Tx error counter
                    *   register of Can Controller and shall return the Tx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(Can_pController, TxErrorCounterPtr);
    79b0:	9900      	ldr	r1, [sp, #0]
    79b2:	9803      	ldr	r0, [sp, #12]
    79b4:	f001 f8cb 	bl	8b4e <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>
    79b8:	4603      	mov	r3, r0
    79ba:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    79be:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    79c2:	4618      	mov	r0, r3
    79c4:	b007      	add	sp, #28
    79c6:	f85d fb04 	ldr.w	pc, [sp], #4
    79ca:	bf00      	nop
    79cc:	1fff8d0c 	.word	0x1fff8d0c

000079d0 <Can_43_FLEXCAN_Write>:
Std_ReturnType Can_43_FLEXCAN_Write
(
    Can_HwHandleType Hth,
    const Can_PduType * PduInfo
)
{
    79d0:	b500      	push	{lr}
    79d2:	b089      	sub	sp, #36	; 0x24
    79d4:	4603      	mov	r3, r0
    79d6:	9100      	str	r1, [sp, #0]
    79d8:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType eRetVal = E_NOT_OK;
    79dc:	2301      	movs	r3, #1
    79de:	f88d 301f 	strb.w	r3, [sp, #31]
    uint8 u8ControllerID = 0U;
    79e2:	2300      	movs	r3, #0
    79e4:	f88d 301e 	strb.w	r3, [sp, #30]
    uint32 u32CoreId = 0U;
    79e8:	2300      	movs	r3, #0
    79ea:	9306      	str	r3, [sp, #24]
    Can_HwHandleType HwObjectID = 0U;
    79ec:	2300      	movs	r3, #0
    79ee:	f8ad 3016 	strh.w	r3, [sp, #22]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    79f2:	2300      	movs	r3, #0
    79f4:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    79f6:	2300      	movs	r3, #0
    79f8:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    79fa:	2300      	movs	r3, #0
    79fc:	9306      	str	r3, [sp, #24]
    HwObjectID = Hth;
    79fe:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    7a02:	f8ad 3016 	strh.w	r3, [sp, #22]
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_WRITE, CAN_43_FLEXCAN_E_PARAM_POINTER);
            }
            else
            {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    7a06:	4a1d      	ldr	r2, [pc, #116]	; (7a7c <Can_43_FLEXCAN_Write+0xac>)
    7a08:	9b06      	ldr	r3, [sp, #24]
    7a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a0e:	68da      	ldr	r2, [r3, #12]
    7a10:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7a14:	4413      	add	r3, r2
    7a16:	781b      	ldrb	r3, [r3, #0]
    7a18:	f88d 301e 	strb.w	r3, [sp, #30]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    7a1c:	4a17      	ldr	r2, [pc, #92]	; (7a7c <Can_43_FLEXCAN_Write+0xac>)
    7a1e:	9b06      	ldr	r3, [sp, #24]
    7a20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a24:	695a      	ldr	r2, [r3, #20]
    7a26:	f89d 301e 	ldrb.w	r3, [sp, #30]
    7a2a:	009b      	lsls	r3, r3, #2
    7a2c:	4413      	add	r3, r2
    7a2e:	681b      	ldr	r3, [r3, #0]
    7a30:	9304      	str	r3, [sp, #16]
                if (NULL_PTR != Can_pController)
    7a32:	9b04      	ldr	r3, [sp, #16]
    7a34:	2b00      	cmp	r3, #0
    7a36:	d01b      	beq.n	7a70 <Can_43_FLEXCAN_Write+0xa0>
                {
                    Can_pHwObject = &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]);
    7a38:	4a10      	ldr	r2, [pc, #64]	; (7a7c <Can_43_FLEXCAN_Write+0xac>)
    7a3a:	9b06      	ldr	r3, [sp, #24]
    7a3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a40:	6919      	ldr	r1, [r3, #16]
    7a42:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    7a46:	4613      	mov	r3, r2
    7a48:	00db      	lsls	r3, r3, #3
    7a4a:	4413      	add	r3, r2
    7a4c:	009b      	lsls	r3, r3, #2
    7a4e:	440b      	add	r3, r1
    7a50:	9303      	str	r3, [sp, #12]
                #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    if ((TRUE == Can_ValidatePdu(Can_pController, Can_pHwObject, PduInfo)) && (CAN_CS_STARTED == Can_eControllerState[u8ControllerID]))
                #else
                    /* avoid unexpected behaviour when accessing to RAM */
                    if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    7a52:	f89d 301e 	ldrb.w	r3, [sp, #30]
    7a56:	4a0a      	ldr	r2, [pc, #40]	; (7a80 <Can_43_FLEXCAN_Write+0xb0>)
    7a58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a5c:	2b01      	cmp	r3, #1
    7a5e:	d107      	bne.n	7a70 <Can_43_FLEXCAN_Write+0xa0>
                            eRetVal = CAN_BUSY;
                        }
                        else
                        {
                    #endif
                            eRetVal = Can_43_FLEXCAN_Ipw_Write(Can_pController, Can_pHwObject, PduInfo);
    7a60:	9a00      	ldr	r2, [sp, #0]
    7a62:	9903      	ldr	r1, [sp, #12]
    7a64:	9804      	ldr	r0, [sp, #16]
    7a66:	f001 f896 	bl	8b96 <Can_43_FLEXCAN_Ipw_Write>
    7a6a:	4603      	mov	r3, r0
    7a6c:	f88d 301f 	strb.w	r3, [sp, #31]
                }
            #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
            }
    }
#endif
    return eRetVal;
    7a70:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    7a74:	4618      	mov	r0, r3
    7a76:	b009      	add	sp, #36	; 0x24
    7a78:	f85d fb04 	ldr.w	pc, [sp], #4
    7a7c:	1fff8d0c 	.word	0x1fff8d0c
    7a80:	1fff8d08 	.word	0x1fff8d08

00007a84 <Can_43_FLEXCAN_MainFunction_Write>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON */
    }
    7a84:	bf00      	nop
    7a86:	4770      	bx	lr

00007a88 <Can_43_FLEXCAN_MainFunction_Read>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON */
    }
    7a88:	bf00      	nop
    7a8a:	4770      	bx	lr

00007a8c <Can_43_FLEXCAN_MainFunction_BusOff>:
            }
            u8ControllerID++;
        }
    }
#endif /* CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON */
}
    7a8c:	bf00      	nop
    7a8e:	4770      	bx	lr

00007a90 <Can_43_FLEXCAN_MainFunction_Mode>:
*
* @api
*/
/* implements     Can_MainFunction_Mode_Activity */
void Can_43_FLEXCAN_MainFunction_Mode(void)
{
    7a90:	b500      	push	{lr}
    7a92:	b085      	sub	sp, #20
    uint8 u8ControllerID = 0U;
    7a94:	2300      	movs	r3, #0
    7a96:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32CoreId = 0U;
    7a9a:	2300      	movs	r3, #0
    7a9c:	9302      	str	r3, [sp, #8]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7a9e:	2300      	movs	r3, #0
    7aa0:	9301      	str	r3, [sp, #4]

    u32CoreId = Can_GetCoreID();
    7aa2:	2300      	movs	r3, #0
    7aa4:	9302      	str	r3, [sp, #8]
    if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    7aa6:	4a17      	ldr	r2, [pc, #92]	; (7b04 <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    7aa8:	9b02      	ldr	r3, [sp, #8]
    7aaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7aae:	2b00      	cmp	r3, #0
    7ab0:	d024      	beq.n	7afc <Can_43_FLEXCAN_MainFunction_Mode+0x6c>
    {
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    7ab2:	e01f      	b.n	7af4 <Can_43_FLEXCAN_MainFunction_Mode+0x64>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    7ab4:	4a13      	ldr	r2, [pc, #76]	; (7b04 <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    7ab6:	9b02      	ldr	r3, [sp, #8]
    7ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7abc:	695a      	ldr	r2, [r3, #20]
    7abe:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7ac2:	009b      	lsls	r3, r3, #2
    7ac4:	4413      	add	r3, r2
    7ac6:	681b      	ldr	r3, [r3, #0]
    7ac8:	9301      	str	r3, [sp, #4]
            if (NULL_PTR != Can_pController)
    7aca:	9b01      	ldr	r3, [sp, #4]
    7acc:	2b00      	cmp	r3, #0
    7ace:	d00c      	beq.n	7aea <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
            {
                if (TRUE == Can_pController->Can_bActivation)
    7ad0:	9b01      	ldr	r3, [sp, #4]
    7ad2:	7a1b      	ldrb	r3, [r3, #8]
    7ad4:	2b00      	cmp	r3, #0
    7ad6:	d008      	beq.n	7aea <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
                {
                    Can_43_FLEXCAN_Ipw_MainFunction_Mode(Can_pController, &Can_eControllerState[u8ControllerID]);
    7ad8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7adc:	009b      	lsls	r3, r3, #2
    7ade:	4a0a      	ldr	r2, [pc, #40]	; (7b08 <Can_43_FLEXCAN_MainFunction_Mode+0x78>)
    7ae0:	4413      	add	r3, r2
    7ae2:	4619      	mov	r1, r3
    7ae4:	9801      	ldr	r0, [sp, #4]
    7ae6:	f001 f95c 	bl	8da2 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>
                }
            }
            u8ControllerID++;
    7aea:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7aee:	3301      	adds	r3, #1
    7af0:	f88d 300f 	strb.w	r3, [sp, #15]
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    7af4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7af8:	2b00      	cmp	r3, #0
    7afa:	d0db      	beq.n	7ab4 <Can_43_FLEXCAN_MainFunction_Mode+0x24>
        }
    }
}
    7afc:	bf00      	nop
    7afe:	b005      	add	sp, #20
    7b00:	f85d fb04 	ldr.w	pc, [sp], #4
    7b04:	1fff8d0c 	.word	0x1fff8d0c
    7b08:	1fff8d08 	.word	0x1fff8d08

00007b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>:
(
    uint8 u8CtrlOffset,
    uint8 u8MbIdx,
    Can_43_FLEXCAN_MbType mbType
)
{
    7b0c:	b500      	push	{lr}
    7b0e:	b087      	sub	sp, #28
    7b10:	4603      	mov	r3, r0
    7b12:	9200      	str	r2, [sp, #0]
    7b14:	f88d 3007 	strb.w	r3, [sp, #7]
    7b18:	460b      	mov	r3, r1
    7b1a:	f88d 3006 	strb.w	r3, [sp, #6]
    uint8 u8ControllerID = 0U;
    7b1e:	2300      	movs	r3, #0
    7b20:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    7b24:	2300      	movs	r3, #0
    7b26:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7b28:	2300      	movs	r3, #0
    7b2a:	9303      	str	r3, [sp, #12]

    MCAL_FAULT_INJECTION_POINT(CAN_FIP_2_CHANGE_DRIVER_TO_UNINITIALIZED);
    u32CoreId = Can_GetCoreID();
    7b2c:	2300      	movs	r3, #0
    7b2e:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    7b30:	4a16      	ldr	r2, [pc, #88]	; (7b8c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    7b32:	9b04      	ldr	r3, [sp, #16]
    7b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b38:	2b00      	cmp	r3, #0
    7b3a:	d022      	beq.n	7b82 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    7b3c:	4a13      	ldr	r2, [pc, #76]	; (7b8c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    7b3e:	9b04      	ldr	r3, [sp, #16]
    7b40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b44:	689a      	ldr	r2, [r3, #8]
    7b46:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7b4a:	4413      	add	r3, r2
    7b4c:	781b      	ldrb	r3, [r3, #0]
    7b4e:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    7b52:	4a0e      	ldr	r2, [pc, #56]	; (7b8c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    7b54:	9b04      	ldr	r3, [sp, #16]
    7b56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b5a:	695a      	ldr	r2, [r3, #20]
    7b5c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7b60:	009b      	lsls	r3, r3, #2
    7b62:	4413      	add	r3, r2
    7b64:	681b      	ldr	r3, [r3, #0]
    7b66:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    7b68:	9b03      	ldr	r3, [sp, #12]
    7b6a:	2b00      	cmp	r3, #0
    7b6c:	d009      	beq.n	7b82 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
        {
            Can_43_FLEXCAN_Ipw_ProcessHwObject(Can_pController, (Can_apxConfig[u32CoreId]), u8MbIdx, mbType);
    7b6e:	4a07      	ldr	r2, [pc, #28]	; (7b8c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    7b70:	9b04      	ldr	r3, [sp, #16]
    7b72:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    7b76:	f89d 2006 	ldrb.w	r2, [sp, #6]
    7b7a:	9b00      	ldr	r3, [sp, #0]
    7b7c:	9803      	ldr	r0, [sp, #12]
    7b7e:	f001 f946 	bl	8e0e <Can_43_FLEXCAN_Ipw_ProcessHwObject>
        }

    }
}
    7b82:	bf00      	nop
    7b84:	b007      	add	sp, #28
    7b86:	f85d fb04 	ldr.w	pc, [sp], #4
    7b8a:	bf00      	nop
    7b8c:	1fff8d0c 	.word	0x1fff8d0c

00007b90 <Can_43_FLEXCAN_ProcessBusOffInterrupt>:
*/
void Can_43_FLEXCAN_ProcessBusOffInterrupt
(
    uint8 u8CtrlOffset
)
{
    7b90:	b500      	push	{lr}
    7b92:	b087      	sub	sp, #28
    7b94:	4603      	mov	r3, r0
    7b96:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 u8ControllerID = 0U;
    7b9a:	2300      	movs	r3, #0
    7b9c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    7ba0:	2300      	movs	r3, #0
    7ba2:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    7ba4:	2300      	movs	r3, #0
    7ba6:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    7ba8:	2300      	movs	r3, #0
    7baa:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    7bac:	4a19      	ldr	r2, [pc, #100]	; (7c14 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    7bae:	9b04      	ldr	r3, [sp, #16]
    7bb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bb4:	2b00      	cmp	r3, #0
    7bb6:	d029      	beq.n	7c0c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    7bb8:	4a16      	ldr	r2, [pc, #88]	; (7c14 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    7bba:	9b04      	ldr	r3, [sp, #16]
    7bbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bc0:	689a      	ldr	r2, [r3, #8]
    7bc2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7bc6:	4413      	add	r3, r2
    7bc8:	781b      	ldrb	r3, [r3, #0]
    7bca:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    7bce:	4a11      	ldr	r2, [pc, #68]	; (7c14 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    7bd0:	9b04      	ldr	r3, [sp, #16]
    7bd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bd6:	695a      	ldr	r2, [r3, #20]
    7bd8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7bdc:	009b      	lsls	r3, r3, #2
    7bde:	4413      	add	r3, r2
    7be0:	681b      	ldr	r3, [r3, #0]
    7be2:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    7be4:	9b03      	ldr	r3, [sp, #12]
    7be6:	2b00      	cmp	r3, #0
    7be8:	d010      	beq.n	7c0c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
        {
            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    7bea:	9803      	ldr	r0, [sp, #12]
    7bec:	f000 fec2 	bl	8974 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    7bf0:	4603      	mov	r3, r0
    7bf2:	2b00      	cmp	r3, #0
    7bf4:	d10a      	bne.n	7c0c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    7bf6:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7bfa:	4a07      	ldr	r2, [pc, #28]	; (7c18 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x88>)
    7bfc:	2102      	movs	r1, #2
    7bfe:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                CanIf_ControllerBusOff(Can_pController->Can_u8AbstControllerID);
    7c02:	9b03      	ldr	r3, [sp, #12]
    7c04:	781b      	ldrb	r3, [r3, #0]
    7c06:	4618      	mov	r0, r3
    7c08:	f007 ff0e 	bl	fa28 <CanIf_ControllerBusOff>
            }
        }
    }
}
    7c0c:	bf00      	nop
    7c0e:	b007      	add	sp, #28
    7c10:	f85d fb04 	ldr.w	pc, [sp], #4
    7c14:	1fff8d0c 	.word	0x1fff8d0c
    7c18:	1fff8d08 	.word	0x1fff8d08

00007c1c <Can_Ipw_ParseData>:
    PduInfoType * CanIf_PduInfo,
    Flexcan_Ip_MsgBuffType * pReceivedDataBuffer,
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
)
{
    7c1c:	b500      	push	{lr}
    7c1e:	b085      	sub	sp, #20
    7c20:	9003      	str	r0, [sp, #12]
    7c22:	9102      	str	r1, [sp, #8]
    7c24:	9201      	str	r2, [sp, #4]
    7c26:	9300      	str	r3, [sp, #0]
    CanIf_Mailbox->CanId = pReceivedDataBuffer->msgId;
    7c28:	9b01      	ldr	r3, [sp, #4]
    7c2a:	685a      	ldr	r2, [r3, #4]
    7c2c:	9b03      	ldr	r3, [sp, #12]
    7c2e:	601a      	str	r2, [r3, #0]
    * convert the ID to a standardized format since the Upper layer (CANIF) does not know
    * whether the received CAN frame is a Standard CAN frame or Extended CAN frame.
    * In case of an Extended CAN frame, MSB of a received CAN frame ID needs to be
    * made as 1 to mark the received CAN frame as Extended.
    */
    if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_IDE_MASK) != 0U)
    7c30:	9b01      	ldr	r3, [sp, #4]
    7c32:	681b      	ldr	r3, [r3, #0]
    7c34:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    7c38:	2b00      	cmp	r3, #0
    7c3a:	d005      	beq.n	7c48 <Can_Ipw_ParseData+0x2c>
    {
        CanIf_Mailbox->CanId |= (uint32)0x80000000U;
    7c3c:	9b03      	ldr	r3, [sp, #12]
    7c3e:	681b      	ldr	r3, [r3, #0]
    7c40:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    7c44:	9b03      	ldr	r3, [sp, #12]
    7c46:	601a      	str	r2, [r3, #0]
    }

    if (CAN_RX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    7c48:	9b06      	ldr	r3, [sp, #24]
    7c4a:	699b      	ldr	r3, [r3, #24]
    7c4c:	2b00      	cmp	r3, #0
    7c4e:	d10c      	bne.n	7c6a <Can_Ipw_ParseData+0x4e>
    {
        /* Check if Mb Overrun */
        if ((uint32)(0x06000000U) == (pReceivedDataBuffer->cs & CAN_IPW_CS_CODE_MASK))
    7c50:	9b01      	ldr	r3, [sp, #4]
    7c52:	681b      	ldr	r3, [r3, #0]
    7c54:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    7c58:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
    7c5c:	d105      	bne.n	7c6a <Can_Ipw_ParseData+0x4e>
        {
            (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    7c5e:	2301      	movs	r3, #1
    7c60:	2208      	movs	r2, #8
    7c62:	2100      	movs	r1, #0
    7c64:	2050      	movs	r0, #80	; 0x50
    7c66:	f007 fd3f 	bl	f6e8 <Det_ReportRuntimeError>
        }
    }

    /* when legacy fifo enabled, FD must be disabled */
    if (CAN_RX_LEGACY_FIFO != Can_pHwObjectConfig->Can_eReceiveType)
    7c6a:	9b06      	ldr	r3, [sp, #24]
    7c6c:	699b      	ldr	r3, [r3, #24]
    7c6e:	2b01      	cmp	r3, #1
    7c70:	d009      	beq.n	7c86 <Can_Ipw_ParseData+0x6a>
    {
        /*
        * [SWS_Can_00501]  CanDrv shall indicate whether the received message is a
        * conventional CAN frame or a CAN FD frame as described in Can_IdType.
        */
        if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_EDL_MASK) != 0U)
    7c72:	9b01      	ldr	r3, [sp, #4]
    7c74:	681b      	ldr	r3, [r3, #0]
    7c76:	2b00      	cmp	r3, #0
    7c78:	da05      	bge.n	7c86 <Can_Ipw_ParseData+0x6a>
        {
            CanIf_Mailbox->CanId |= (uint32)0x40000000U;
    7c7a:	9b03      	ldr	r3, [sp, #12]
    7c7c:	681b      	ldr	r3, [r3, #0]
    7c7e:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    7c82:	9b03      	ldr	r3, [sp, #12]
    7c84:	601a      	str	r2, [r3, #0]
        }
    }

    if (Can_pHwObjectConfig->Can_u8PayloadLength <= pReceivedDataBuffer->dataLen)
    7c86:	9b06      	ldr	r3, [sp, #24]
    7c88:	7c1a      	ldrb	r2, [r3, #16]
    7c8a:	9b01      	ldr	r3, [sp, #4]
    7c8c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    7c90:	429a      	cmp	r2, r3
    7c92:	d805      	bhi.n	7ca0 <Can_Ipw_ParseData+0x84>
    {
        CanIf_PduInfo->SduLength = Can_pHwObjectConfig->Can_u8PayloadLength;
    7c94:	9b06      	ldr	r3, [sp, #24]
    7c96:	7c1b      	ldrb	r3, [r3, #16]
    7c98:	461a      	mov	r2, r3
    7c9a:	9b02      	ldr	r3, [sp, #8]
    7c9c:	609a      	str	r2, [r3, #8]
    7c9e:	e005      	b.n	7cac <Can_Ipw_ParseData+0x90>
    }
    else
    {
        CanIf_PduInfo->SduLength = pReceivedDataBuffer->dataLen;
    7ca0:	9b01      	ldr	r3, [sp, #4]
    7ca2:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    7ca6:	461a      	mov	r2, r3
    7ca8:	9b02      	ldr	r3, [sp, #8]
    7caa:	609a      	str	r2, [r3, #8]
                                                      CanIf_PduInfo->SduLength, \
                                                      &pReceivedDataBuffer->data[0]) \
                                                     )
    {
#endif
    CanIf_Mailbox->Hoh = Can_pHwObjectConfig->Can_HwObjectID;
    7cac:	9b06      	ldr	r3, [sp, #24]
    7cae:	881a      	ldrh	r2, [r3, #0]
    7cb0:	9b03      	ldr	r3, [sp, #12]
    7cb2:	809a      	strh	r2, [r3, #4]
    CanIf_Mailbox->ControllerId = Can_pControllerConfig->Can_u8AbstControllerID;
    7cb4:	9b00      	ldr	r3, [sp, #0]
    7cb6:	781a      	ldrb	r2, [r3, #0]
    7cb8:	9b03      	ldr	r3, [sp, #12]
    7cba:	719a      	strb	r2, [r3, #6]
    CanIf_PduInfo->SduDataPtr = &pReceivedDataBuffer->data[0];
    7cbc:	9b01      	ldr	r3, [sp, #4]
    7cbe:	f103 0208 	add.w	r2, r3, #8
    7cc2:	9b02      	ldr	r3, [sp, #8]
    7cc4:	601a      	str	r2, [r3, #0]
    CanIf_RxIndication(CanIf_Mailbox, CanIf_PduInfo);
    7cc6:	9902      	ldr	r1, [sp, #8]
    7cc8:	9803      	ldr	r0, [sp, #12]
    7cca:	f007 fe3b 	bl	f944 <CanIf_RxIndication>
#if (CAN_43_FLEXCAN_LPDU_CALLOUT_SUPPORT == STD_ON)
    }
#endif
}
    7cce:	bf00      	nop
    7cd0:	b005      	add	sp, #20
    7cd2:	f85d fb04 	ldr.w	pc, [sp], #4

00007cd6 <Can_Ipw_InitLegacyFifoFilter>:

static void Can_Ipw_InitLegacyFifoFilter(const Can_43_FLEXCAN_ControllerConfigType * Can_pController, const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject)
{
    7cd6:	b500      	push	{lr}
    7cd8:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
    7cdc:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ce0:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    7ce4:	6018      	str	r0, [r3, #0]
    7ce6:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7cea:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7cee:	6019      	str	r1, [r3, #0]
    uint8 u8FilterIdx=0U;
    7cf0:	2300      	movs	r3, #0
    7cf2:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    uint8 u8HwFilterCount = 0U;
    7cf6:	2300      	movs	r3, #0
    7cf8:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
    uint32 u32HwFilterMask = (uint32)0x00000000U;
    7cfc:	2300      	movs	r3, #0
    7cfe:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    /* The max FIFO id filter affected by Rx individual masks*/
    uint8 u8FiFoFilterIndvCount = 0U;
    7d02:	2300      	movs	r3, #0
    7d04:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    Flexcan_Ip_RxFifoIdElementFormatType eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    7d08:	2300      	movs	r3, #0
    7d0a:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
    /* Need to alocate a filter array with elemnets no as defined in HwObject */
    Flexcan_Ip_IdTableType RxFifoFilters[128];

    if (((Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U) <= 32U)
    7d0e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d12:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7d16:	681b      	ldr	r3, [r3, #0]
    7d18:	7c9b      	ldrb	r3, [r3, #18]
    7d1a:	089b      	lsrs	r3, r3, #2
    7d1c:	b2db      	uxtb	r3, r3
    7d1e:	3306      	adds	r3, #6
    7d20:	2b20      	cmp	r3, #32
    7d22:	d80b      	bhi.n	7d3c <Can_Ipw_InitLegacyFifoFilter+0x66>
    {
        u8FiFoFilterIndvCount = (Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U;
    7d24:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d28:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7d2c:	681b      	ldr	r3, [r3, #0]
    7d2e:	7c9b      	ldrb	r3, [r3, #18]
    7d30:	089b      	lsrs	r3, r3, #2
    7d32:	b2db      	uxtb	r3, r3
    7d34:	3306      	adds	r3, #6
    7d36:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    7d3a:	e002      	b.n	7d42 <Can_Ipw_InitLegacyFifoFilter+0x6c>
    }
    else
    {
        u8FiFoFilterIndvCount = 32U;
    7d3c:	2320      	movs	r3, #32
    7d3e:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    }
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    7d42:	2300      	movs	r3, #0
    7d44:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    7d48:	e169      	b.n	801e <Can_Ipw_InitLegacyFifoFilter+0x348>
    {
            if (CAN_LEGACY_FIFO_FORMAT_A == Can_pController->Can_eLegacyAcceptanceMode)
    7d4a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d4e:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    7d52:	681b      	ldr	r3, [r3, #0]
    7d54:	691b      	ldr	r3, [r3, #16]
    7d56:	2b00      	cmp	r3, #0
    7d58:	d13a      	bne.n	7dd0 <Can_Ipw_InitLegacyFifoFilter+0xfa>
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount;
    7d5a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d5e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7d62:	681b      	ldr	r3, [r3, #0]
    7d64:	7c9b      	ldrb	r3, [r3, #18]
    7d66:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC0000000U;
    7d6a:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    7d6e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    7d72:	2300      	movs	r3, #0
    7d74:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    7d78:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d7c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7d80:	681b      	ldr	r3, [r3, #0]
    7d82:	689b      	ldr	r3, [r3, #8]
    7d84:	2b00      	cmp	r3, #0
    7d86:	d011      	beq.n	7dac <Can_Ipw_InitLegacyFifoFilter+0xd6>
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_EXT_SHIFT;
    7d88:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7d8c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7d90:	681b      	ldr	r3, [r3, #0]
    7d92:	695a      	ldr	r2, [r3, #20]
    7d94:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7d98:	00db      	lsls	r3, r3, #3
    7d9a:	4413      	add	r3, r2
    7d9c:	685b      	ldr	r3, [r3, #4]
    7d9e:	005b      	lsls	r3, r3, #1
    7da0:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7da4:	4313      	orrs	r3, r2
    7da6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    7daa:	e126      	b.n	7ffa <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_STD_SHIFT;
    7dac:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7db0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7db4:	681b      	ldr	r3, [r3, #0]
    7db6:	695a      	ldr	r2, [r3, #20]
    7db8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7dbc:	00db      	lsls	r3, r3, #3
    7dbe:	4413      	add	r3, r2
    7dc0:	685b      	ldr	r3, [r3, #4]
    7dc2:	04db      	lsls	r3, r3, #19
    7dc4:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7dc8:	4313      	orrs	r3, r2
    7dca:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    7dce:	e114      	b.n	7ffa <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else if (CAN_LEGACY_FIFO_FORMAT_B == Can_pController->Can_eLegacyAcceptanceMode)
    7dd0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7dd4:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    7dd8:	681b      	ldr	r3, [r3, #0]
    7dda:	691b      	ldr	r3, [r3, #16]
    7ddc:	2b01      	cmp	r3, #1
    7dde:	d160      	bne.n	7ea2 <Can_Ipw_InitLegacyFifoFilter+0x1cc>
            {
                u8HwFilterCount = Can_pHwObject->Can_u8HwFilterCount * 2U ;
    7de0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7de4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7de8:	681b      	ldr	r3, [r3, #0]
    7dea:	7c9b      	ldrb	r3, [r3, #18]
    7dec:	005b      	lsls	r3, r3, #1
    7dee:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC000C000U;
    7df2:	f04f 23c0 	mov.w	r3, #3221274624	; 0xc000c000
    7df6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_B;
    7dfa:	2301      	movs	r3, #1
    7dfc:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    7e00:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7e04:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7e08:	681b      	ldr	r3, [r3, #0]
    7e0a:	689b      	ldr	r3, [r3, #8]
    7e0c:	2b00      	cmp	r3, #0
    7e0e:	d024      	beq.n	7e5a <Can_Ipw_InitLegacyFifoFilter+0x184>
                {
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT1;
    7e10:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7e14:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7e18:	681b      	ldr	r3, [r3, #0]
    7e1a:	695a      	ldr	r2, [r3, #20]
    7e1c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7e20:	011b      	lsls	r3, r3, #4
    7e22:	4413      	add	r3, r2
    7e24:	685b      	ldr	r3, [r3, #4]
    7e26:	0bdb      	lsrs	r3, r3, #15
    7e28:	041b      	lsls	r3, r3, #16
    7e2a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7e2e:	4313      	orrs	r3, r2
    7e30:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT2;
    7e34:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7e38:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7e3c:	681b      	ldr	r3, [r3, #0]
    7e3e:	695a      	ldr	r2, [r3, #20]
    7e40:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7e44:	011b      	lsls	r3, r3, #4
    7e46:	3308      	adds	r3, #8
    7e48:	4413      	add	r3, r2
    7e4a:	685b      	ldr	r3, [r3, #4]
    7e4c:	0bdb      	lsrs	r3, r3, #15
    7e4e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7e52:	4313      	orrs	r3, r2
    7e54:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    7e58:	e0cf      	b.n	7ffa <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT1;
    7e5a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7e5e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7e62:	681b      	ldr	r3, [r3, #0]
    7e64:	695a      	ldr	r2, [r3, #20]
    7e66:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7e6a:	011b      	lsls	r3, r3, #4
    7e6c:	4413      	add	r3, r2
    7e6e:	685b      	ldr	r3, [r3, #4]
    7e70:	04db      	lsls	r3, r3, #19
    7e72:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7e76:	4313      	orrs	r3, r2
    7e78:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT2;
    7e7c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7e80:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7e84:	681b      	ldr	r3, [r3, #0]
    7e86:	695a      	ldr	r2, [r3, #20]
    7e88:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7e8c:	011b      	lsls	r3, r3, #4
    7e8e:	3308      	adds	r3, #8
    7e90:	4413      	add	r3, r2
    7e92:	685b      	ldr	r3, [r3, #4]
    7e94:	00db      	lsls	r3, r3, #3
    7e96:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7e9a:	4313      	orrs	r3, r2
    7e9c:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    7ea0:	e0ab      	b.n	7ffa <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else /*CAN_LEGACY_FIFO_FORMAT_C == Can_pController->Can_eLegacyAcceptanceMode */
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount * 4U ;
    7ea2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ea6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7eaa:	681b      	ldr	r3, [r3, #0]
    7eac:	7c9b      	ldrb	r3, [r3, #18]
    7eae:	009b      	lsls	r3, r3, #2
    7eb0:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0x00000000U;
    7eb4:	2300      	movs	r3, #0
    7eb6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_C;
    7eba:	2302      	movs	r3, #2
    7ebc:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    7ec0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ec4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7ec8:	681b      	ldr	r3, [r3, #0]
    7eca:	689b      	ldr	r3, [r3, #8]
    7ecc:	2b00      	cmp	r3, #0
    7ece:	d04a      	beq.n	7f66 <Can_Ipw_InitLegacyFifoFilter+0x290>
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    7ed0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ed4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7ed8:	681b      	ldr	r3, [r3, #0]
    7eda:	695a      	ldr	r2, [r3, #20]
    7edc:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7ee0:	015b      	lsls	r3, r3, #5
    7ee2:	4413      	add	r3, r2
    7ee4:	685b      	ldr	r3, [r3, #4]
    7ee6:	0d5b      	lsrs	r3, r3, #21
    7ee8:	061b      	lsls	r3, r3, #24
    7eea:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7eee:	4313      	orrs	r3, r2
    7ef0:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    7ef4:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ef8:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7efc:	681b      	ldr	r3, [r3, #0]
    7efe:	695a      	ldr	r2, [r3, #20]
    7f00:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7f04:	015b      	lsls	r3, r3, #5
    7f06:	3308      	adds	r3, #8
    7f08:	4413      	add	r3, r2
    7f0a:	685b      	ldr	r3, [r3, #4]
    7f0c:	0d5b      	lsrs	r3, r3, #21
    7f0e:	041b      	lsls	r3, r3, #16
    7f10:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7f14:	4313      	orrs	r3, r2
    7f16:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    7f1a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7f1e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7f22:	681b      	ldr	r3, [r3, #0]
    7f24:	695a      	ldr	r2, [r3, #20]
    7f26:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7f2a:	015b      	lsls	r3, r3, #5
    7f2c:	3310      	adds	r3, #16
    7f2e:	4413      	add	r3, r2
    7f30:	685b      	ldr	r3, [r3, #4]
    7f32:	0d5b      	lsrs	r3, r3, #21
    7f34:	021b      	lsls	r3, r3, #8
    7f36:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7f3a:	4313      	orrs	r3, r2
    7f3c:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    7f40:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7f44:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7f48:	681b      	ldr	r3, [r3, #0]
    7f4a:	695a      	ldr	r2, [r3, #20]
    7f4c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7f50:	015b      	lsls	r3, r3, #5
    7f52:	3318      	adds	r3, #24
    7f54:	4413      	add	r3, r2
    7f56:	685b      	ldr	r3, [r3, #4]
    7f58:	0d5b      	lsrs	r3, r3, #21
    7f5a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7f5e:	4313      	orrs	r3, r2
    7f60:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    7f64:	e049      	b.n	7ffa <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    7f66:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7f6a:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7f6e:	681b      	ldr	r3, [r3, #0]
    7f70:	695a      	ldr	r2, [r3, #20]
    7f72:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7f76:	015b      	lsls	r3, r3, #5
    7f78:	4413      	add	r3, r2
    7f7a:	685b      	ldr	r3, [r3, #4]
    7f7c:	08db      	lsrs	r3, r3, #3
    7f7e:	061b      	lsls	r3, r3, #24
    7f80:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7f84:	4313      	orrs	r3, r2
    7f86:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    7f8a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7f8e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7f92:	681b      	ldr	r3, [r3, #0]
    7f94:	695a      	ldr	r2, [r3, #20]
    7f96:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7f9a:	015b      	lsls	r3, r3, #5
    7f9c:	3308      	adds	r3, #8
    7f9e:	4413      	add	r3, r2
    7fa0:	685b      	ldr	r3, [r3, #4]
    7fa2:	08db      	lsrs	r3, r3, #3
    7fa4:	041b      	lsls	r3, r3, #16
    7fa6:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7faa:	4313      	orrs	r3, r2
    7fac:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    7fb0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7fb4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7fb8:	681b      	ldr	r3, [r3, #0]
    7fba:	695a      	ldr	r2, [r3, #20]
    7fbc:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7fc0:	015b      	lsls	r3, r3, #5
    7fc2:	3310      	adds	r3, #16
    7fc4:	4413      	add	r3, r2
    7fc6:	685b      	ldr	r3, [r3, #4]
    7fc8:	08db      	lsrs	r3, r3, #3
    7fca:	021b      	lsls	r3, r3, #8
    7fcc:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7fd0:	4313      	orrs	r3, r2
    7fd2:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    7fd6:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7fda:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    7fde:	681b      	ldr	r3, [r3, #0]
    7fe0:	695a      	ldr	r2, [r3, #20]
    7fe2:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    7fe6:	015b      	lsls	r3, r3, #5
    7fe8:	3318      	adds	r3, #24
    7fea:	4413      	add	r3, r2
    7fec:	685b      	ldr	r3, [r3, #4]
    7fee:	08db      	lsrs	r3, r3, #3
    7ff0:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    7ff4:	4313      	orrs	r3, r2
    7ff6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                }
            }
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, u8FilterIdx, u32HwFilterMask);
    7ffa:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    7ffe:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8002:	681b      	ldr	r3, [r3, #0]
    8004:	789b      	ldrb	r3, [r3, #2]
    8006:	f89d 1417 	ldrb.w	r1, [sp, #1047]	; 0x417
    800a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    800e:	4618      	mov	r0, r3
    8010:	f002 fe76 	bl	ad00 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    8014:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8018:	3301      	adds	r3, #1
    801a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    801e:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    8022:	f89d 340f 	ldrb.w	r3, [sp, #1039]	; 0x40f
    8026:	429a      	cmp	r2, r3
    8028:	d20a      	bcs.n	8040 <Can_Ipw_InitLegacyFifoFilter+0x36a>
    802a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    802e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8032:	681b      	ldr	r3, [r3, #0]
    8034:	7c9b      	ldrb	r3, [r3, #18]
    8036:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    803a:	429a      	cmp	r2, r3
    803c:	f4ff ae85 	bcc.w	7d4a <Can_Ipw_InitLegacyFifoFilter+0x74>
    }

    (void)FlexCAN_Ip_SetRxFifoGlobalMask(Can_pController->Can_u8ControllerOffset, Can_pController->Can_u32LegacyGlobalMask);
    8040:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8044:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8048:	681b      	ldr	r3, [r3, #0]
    804a:	789a      	ldrb	r2, [r3, #2]
    804c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8050:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8054:	681b      	ldr	r3, [r3, #0]
    8056:	68db      	ldr	r3, [r3, #12]
    8058:	4619      	mov	r1, r3
    805a:	4610      	mov	r0, r2
    805c:	f002 fe9e 	bl	ad9c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>
    
    if (u8HwFilterCount != 0U)
    8060:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    8064:	2b00      	cmp	r3, #0
    8066:	d054      	beq.n	8112 <Can_Ipw_InitLegacyFifoFilter+0x43c>
    {
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    8068:	2300      	movs	r3, #0
    806a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    806e:	e03e      	b.n	80ee <Can_Ipw_InitLegacyFifoFilter+0x418>
        {
            RxFifoFilters[u8FilterIdx].id = Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterCode;
    8070:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8074:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8078:	681b      	ldr	r3, [r3, #0]
    807a:	695a      	ldr	r2, [r3, #20]
    807c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8080:	00db      	lsls	r3, r3, #3
    8082:	441a      	add	r2, r3
    8084:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8088:	6812      	ldr	r2, [r2, #0]
    808a:	f50d 6183 	add.w	r1, sp, #1048	; 0x418
    808e:	f5a1 6182 	sub.w	r1, r1, #1040	; 0x410
    8092:	00db      	lsls	r3, r3, #3
    8094:	440b      	add	r3, r1
    8096:	605a      	str	r2, [r3, #4]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    8098:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    809c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    80a0:	681b      	ldr	r3, [r3, #0]
    80a2:	689b      	ldr	r3, [r3, #8]
    80a4:	2b00      	cmp	r3, #0
    80a6:	d00a      	beq.n	80be <Can_Ipw_InitLegacyFifoFilter+0x3e8>
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = TRUE;
    80a8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    80ac:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    80b0:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    80b4:	00db      	lsls	r3, r3, #3
    80b6:	4413      	add	r3, r2
    80b8:	2201      	movs	r2, #1
    80ba:	705a      	strb	r2, [r3, #1]
    80bc:	e009      	b.n	80d2 <Can_Ipw_InitLegacyFifoFilter+0x3fc>
            }
            else
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = FALSE;
    80be:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    80c2:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    80c6:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    80ca:	00db      	lsls	r3, r3, #3
    80cc:	4413      	add	r3, r2
    80ce:	2200      	movs	r2, #0
    80d0:	705a      	strb	r2, [r3, #1]
            }
            RxFifoFilters[u8FilterIdx].isRemoteFrame = FALSE;
    80d2:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    80d6:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    80da:	f5a3 6382 	sub.w	r3, r3, #1040	; 0x410
    80de:	2100      	movs	r1, #0
    80e0:	f803 1032 	strb.w	r1, [r3, r2, lsl #3]
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    80e4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    80e8:	3301      	adds	r3, #1
    80ea:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    80ee:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    80f2:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    80f6:	429a      	cmp	r2, r3
    80f8:	d3ba      	bcc.n	8070 <Can_Ipw_InitLegacyFifoFilter+0x39a>
        }

        (void)FlexCAN_Ip_ConfigRxFifo(Can_pController->Can_u8ControllerOffset, eElementFormat, RxFifoFilters);
    80fa:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    80fe:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8102:	681b      	ldr	r3, [r3, #0]
    8104:	789b      	ldrb	r3, [r3, #2]
    8106:	aa02      	add	r2, sp, #8
    8108:	f8dd 1408 	ldr.w	r1, [sp, #1032]	; 0x408
    810c:	4618      	mov	r0, r3
    810e:	f002 f9da 	bl	a4c6 <FlexCAN_Ip_ConfigRxFifo_Privileged>
    }
    
}
    8112:	bf00      	nop
    8114:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
    8118:	f85d fb04 	ldr.w	pc, [sp], #4

0000811c <Can_Ipw_InitBaudrate>:

#endif /* (CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON) */

/* Init baudrate for controller */
static void Can_Ipw_InitBaudrate(const Can_43_FLEXCAN_ControllerConfigType * ControllerConfig)
{
    811c:	b510      	push	{r4, lr}
    811e:	b088      	sub	sp, #32
    8120:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
    uint16 BaudRateConfigID = Can_au16ControllerBaudRateSel[ControllerConfig->Can_u8ControllerID];
    8122:	9b01      	ldr	r3, [sp, #4]
    8124:	785b      	ldrb	r3, [r3, #1]
    8126:	461a      	mov	r2, r3
    8128:	4b58      	ldr	r3, [pc, #352]	; (828c <Can_Ipw_InitBaudrate+0x170>)
    812a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    812e:	f8ad 301e 	strh.w	r3, [sp, #30]
#if ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON))
    #if (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON)
        if (CAN_43_FLEXCAN_CLOCKMODE_NORMAL == Can_Ipw_eClockMode[ControllerConfig->Can_u8ControllerID])
        {
    #endif
            FlexCANTimeSeg.preDivider = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u16Prescaler;
    8132:	9b01      	ldr	r3, [sp, #4]
    8134:	6a1a      	ldr	r2, [r3, #32]
    8136:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    813a:	2116      	movs	r1, #22
    813c:	fb01 f303 	mul.w	r3, r1, r3
    8140:	4413      	add	r3, r2
    8142:	88db      	ldrh	r3, [r3, #6]
    8144:	9305      	str	r3, [sp, #20]
        {
            FlexCANTimeSeg.preDivider = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u16PrescalerAlternate;
        }
    #endif

        FlexCANTimeSeg.propSeg    = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PropSeg;
    8146:	9b01      	ldr	r3, [sp, #4]
    8148:	6a1a      	ldr	r2, [r3, #32]
    814a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    814e:	2116      	movs	r1, #22
    8150:	fb01 f303 	mul.w	r3, r1, r3
    8154:	4413      	add	r3, r2
    8156:	789b      	ldrb	r3, [r3, #2]
    8158:	9302      	str	r3, [sp, #8]
        FlexCANTimeSeg.phaseSeg1  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg1;
    815a:	9b01      	ldr	r3, [sp, #4]
    815c:	6a1a      	ldr	r2, [r3, #32]
    815e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    8162:	2116      	movs	r1, #22
    8164:	fb01 f303 	mul.w	r3, r1, r3
    8168:	4413      	add	r3, r2
    816a:	78db      	ldrb	r3, [r3, #3]
    816c:	9303      	str	r3, [sp, #12]
        FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg2;
    816e:	9b01      	ldr	r3, [sp, #4]
    8170:	6a1a      	ldr	r2, [r3, #32]
    8172:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    8176:	2116      	movs	r1, #22
    8178:	fb01 f303 	mul.w	r3, r1, r3
    817c:	4413      	add	r3, r2
    817e:	791b      	ldrb	r3, [r3, #4]
    8180:	9304      	str	r3, [sp, #16]
        FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8ResyncJumpWidth;
    8182:	9b01      	ldr	r3, [sp, #4]
    8184:	6a1a      	ldr	r2, [r3, #32]
    8186:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    818a:	2116      	movs	r1, #22
    818c:	fb01 f303 	mul.w	r3, r1, r3
    8190:	4413      	add	r3, r2
    8192:	7a1b      	ldrb	r3, [r3, #8]
    8194:	9306      	str	r3, [sp, #24]
        (void)FlexCAN_Ip_SetBitrate(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, FALSE);
    8196:	9b01      	ldr	r3, [sp, #4]
    8198:	789b      	ldrb	r3, [r3, #2]
    819a:	a902      	add	r1, sp, #8
    819c:	2200      	movs	r2, #0
    819e:	4618      	mov	r0, r3
    81a0:	f003 f842 	bl	b228 <FlexCAN_Ip_SetBitrate_Privileged>
#endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
        if (TRUE == ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bFDFrame)
    81a4:	9b01      	ldr	r3, [sp, #4]
    81a6:	6a1a      	ldr	r2, [r3, #32]
    81a8:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    81ac:	2116      	movs	r1, #22
    81ae:	fb01 f303 	mul.w	r3, r1, r3
    81b2:	4413      	add	r3, r2
    81b4:	785b      	ldrb	r3, [r3, #1]
    81b6:	2b00      	cmp	r3, #0
    81b8:	d057      	beq.n	826a <Can_Ipw_InitBaudrate+0x14e>
    #if ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON))
        #if (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON)
            if (CAN_43_FLEXCAN_CLOCKMODE_NORMAL == Can_Ipw_eClockMode[ControllerConfig->Can_u8ControllerID])
            {
        #endif
                FlexCANTimeSeg.preDivider = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u16Prescaler;
    81ba:	9b01      	ldr	r3, [sp, #4]
    81bc:	6a1a      	ldr	r2, [r3, #32]
    81be:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    81c2:	2116      	movs	r1, #22
    81c4:	fb01 f303 	mul.w	r3, r1, r3
    81c8:	4413      	add	r3, r2
    81ca:	89db      	ldrh	r3, [r3, #14]
    81cc:	9305      	str	r3, [sp, #20]
            else
            {
                FlexCANTimeSeg.preDivider = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u16PrescalerAlternate;
            }
        #endif
            FlexCANTimeSeg.propSeg    = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PropSeg;
    81ce:	9b01      	ldr	r3, [sp, #4]
    81d0:	6a1a      	ldr	r2, [r3, #32]
    81d2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    81d6:	2116      	movs	r1, #22
    81d8:	fb01 f303 	mul.w	r3, r1, r3
    81dc:	4413      	add	r3, r2
    81de:	7a9b      	ldrb	r3, [r3, #10]
    81e0:	9302      	str	r3, [sp, #8]
            FlexCANTimeSeg.phaseSeg1  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg1;
    81e2:	9b01      	ldr	r3, [sp, #4]
    81e4:	6a1a      	ldr	r2, [r3, #32]
    81e6:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    81ea:	2116      	movs	r1, #22
    81ec:	fb01 f303 	mul.w	r3, r1, r3
    81f0:	4413      	add	r3, r2
    81f2:	7adb      	ldrb	r3, [r3, #11]
    81f4:	9303      	str	r3, [sp, #12]
            FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg2;
    81f6:	9b01      	ldr	r3, [sp, #4]
    81f8:	6a1a      	ldr	r2, [r3, #32]
    81fa:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    81fe:	2116      	movs	r1, #22
    8200:	fb01 f303 	mul.w	r3, r1, r3
    8204:	4413      	add	r3, r2
    8206:	7b1b      	ldrb	r3, [r3, #12]
    8208:	9304      	str	r3, [sp, #16]
            FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8ResyncJumpWidth;
    820a:	9b01      	ldr	r3, [sp, #4]
    820c:	6a1a      	ldr	r2, [r3, #32]
    820e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    8212:	2116      	movs	r1, #22
    8214:	fb01 f303 	mul.w	r3, r1, r3
    8218:	4413      	add	r3, r2
    821a:	7c1b      	ldrb	r3, [r3, #16]
    821c:	9306      	str	r3, [sp, #24]

            (void)FlexCAN_Ip_SetBitrateCbt(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bBitRateSwitch);
    821e:	9b01      	ldr	r3, [sp, #4]
    8220:	7898      	ldrb	r0, [r3, #2]
    8222:	9b01      	ldr	r3, [sp, #4]
    8224:	6a1a      	ldr	r2, [r3, #32]
    8226:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    822a:	2116      	movs	r1, #22
    822c:	fb01 f303 	mul.w	r3, r1, r3
    8230:	4413      	add	r3, r2
    8232:	781a      	ldrb	r2, [r3, #0]
    8234:	ab02      	add	r3, sp, #8
    8236:	4619      	mov	r1, r3
    8238:	f003 f8c0 	bl	b3bc <FlexCAN_Ip_SetBitrateCbt_Privileged>
    #endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
            (void)FlexCAN_Ip_SetTDCOffset(ControllerConfig->Can_u8ControllerOffset, \
    823c:	9b01      	ldr	r3, [sp, #4]
    823e:	7898      	ldrb	r0, [r3, #2]
    8240:	9b01      	ldr	r3, [sp, #4]
    8242:	6a1a      	ldr	r2, [r3, #32]
    8244:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    8248:	2116      	movs	r1, #22
    824a:	fb01 f303 	mul.w	r3, r1, r3
    824e:	4413      	add	r3, r2
    8250:	7cd9      	ldrb	r1, [r3, #19]
    8252:	9b01      	ldr	r3, [sp, #4]
    8254:	6a1a      	ldr	r2, [r3, #32]
    8256:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    825a:	2416      	movs	r4, #22
    825c:	fb04 f303 	mul.w	r3, r4, r3
    8260:	4413      	add	r3, r2
    8262:	7d1b      	ldrb	r3, [r3, #20]
    8264:	461a      	mov	r2, r3
    8266:	f003 f913 	bl	b490 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bTrcvDelayEnable, \
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(ControllerConfig->Can_u8ControllerOffset, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TxArbitrationStartDelay);
    826a:	9b01      	ldr	r3, [sp, #4]
    826c:	7898      	ldrb	r0, [r3, #2]
    826e:	9b01      	ldr	r3, [sp, #4]
    8270:	6a1a      	ldr	r2, [r3, #32]
    8272:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    8276:	2116      	movs	r1, #22
    8278:	fb01 f303 	mul.w	r3, r1, r3
    827c:	4413      	add	r3, r2
    827e:	7c9b      	ldrb	r3, [r3, #18]
    8280:	4619      	mov	r1, r3
    8282:	f003 f959 	bl	b538 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
}
    8286:	bf00      	nop
    8288:	b008      	add	sp, #32
    828a:	bd10      	pop	{r4, pc}
    828c:	1fff8fb0 	.word	0x1fff8fb0

00008290 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    8290:	b500      	push	{lr}
    8292:	b087      	sub	sp, #28
    8294:	9003      	str	r0, [sp, #12]
    8296:	9102      	str	r1, [sp, #8]
    8298:	4613      	mov	r3, r2
    829a:	f88d 3007 	strb.w	r3, [sp, #7]
        Can_HwHandleType u8HwObjectID = 0U;
    829e:	2300      	movs	r3, #0
    82a0:	f8ad 3016 	strh.w	r3, [sp, #22]

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    82a4:	9b03      	ldr	r3, [sp, #12]
    82a6:	785b      	ldrb	r3, [r3, #1]
    82a8:	461a      	mov	r2, r3
    82aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    82ae:	491c      	ldr	r1, [pc, #112]	; (8320 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x90>)
    82b0:	0152      	lsls	r2, r2, #5
    82b2:	4413      	add	r3, r2
    82b4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    82b8:	f8ad 3016 	strh.w	r3, [sp, #22]
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    82bc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    82c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    82c4:	4293      	cmp	r3, r2
    82c6:	d027      	beq.n	8318 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
    82c8:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    82cc:	4613      	mov	r3, r2
    82ce:	00db      	lsls	r3, r3, #3
    82d0:	4413      	add	r3, r2
    82d2:	009b      	lsls	r3, r3, #2
    82d4:	461a      	mov	r2, r3
    82d6:	9b02      	ldr	r3, [sp, #8]
    82d8:	4413      	add	r3, r2
    82da:	7b1b      	ldrb	r3, [r3, #12]
    82dc:	f083 0301 	eor.w	r3, r3, #1
    82e0:	b2db      	uxtb	r3, r3
    82e2:	2b00      	cmp	r3, #0
    82e4:	d018      	beq.n	8318 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
        {
            if (CAN_TX_NORMAL == Can_pHwObjectConfig[u8HwObjectID].Can_eReceiveType)
    82e6:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    82ea:	4613      	mov	r3, r2
    82ec:	00db      	lsls	r3, r3, #3
    82ee:	4413      	add	r3, r2
    82f0:	009b      	lsls	r3, r3, #2
    82f2:	461a      	mov	r2, r3
    82f4:	9b02      	ldr	r3, [sp, #8]
    82f6:	4413      	add	r3, r2
    82f8:	699b      	ldr	r3, [r3, #24]
    82fa:	2b03      	cmp	r3, #3
    82fc:	d10c      	bne.n	8318 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
            {
                CanIf_TxConfirmation(Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx]);
    82fe:	9b03      	ldr	r3, [sp, #12]
    8300:	785b      	ldrb	r3, [r3, #1]
    8302:	461a      	mov	r2, r3
    8304:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8308:	4906      	ldr	r1, [pc, #24]	; (8324 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x94>)
    830a:	0152      	lsls	r2, r2, #5
    830c:	4413      	add	r3, r2
    830e:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    8312:	4618      	mov	r0, r3
    8314:	f007 fae2 	bl	f8dc <CanIf_TxConfirmation>
            }
        }
    }
    8318:	bf00      	nop
    831a:	b007      	add	sp, #28
    831c:	f85d fb04 	ldr.w	pc, [sp], #4
    8320:	1fff8f70 	.word	0x1fff8f70
    8324:	1fff8f30 	.word	0x1fff8f30

00008328 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    8328:	b500      	push	{lr}
    832a:	b08f      	sub	sp, #60	; 0x3c
    832c:	9005      	str	r0, [sp, #20]
    832e:	9104      	str	r1, [sp, #16]
    8330:	4613      	mov	r3, r2
    8332:	f88d 300f 	strb.w	r3, [sp, #15]
        Can_HwHandleType u8HwObjectID = 0U;
    8336:	2300      	movs	r3, #0
    8338:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        Can_HwType CanIf_Mailbox;
        PduInfoType CanIf_PduInfo;
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    833c:	2300      	movs	r3, #0
    833e:	930c      	str	r3, [sp, #48]	; 0x30
        Flexcan_Ip_MsgBuffType * pReceivedDataBuffer = NULL_PTR;
    8340:	2300      	movs	r3, #0
    8342:	930b      	str	r3, [sp, #44]	; 0x2c

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    8344:	9b05      	ldr	r3, [sp, #20]
    8346:	785b      	ldrb	r3, [r3, #1]
    8348:	461a      	mov	r2, r3
    834a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    834e:	493f      	ldr	r1, [pc, #252]	; (844c <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x124>)
    8350:	0152      	lsls	r2, r2, #5
    8352:	4413      	add	r3, r2
    8354:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    8358:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    835c:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
    8360:	f64f 72ff 	movw	r2, #65535	; 0xffff
    8364:	4293      	cmp	r3, r2
    8366:	d06c      	beq.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
    8368:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    836c:	4613      	mov	r3, r2
    836e:	00db      	lsls	r3, r3, #3
    8370:	4413      	add	r3, r2
    8372:	009b      	lsls	r3, r3, #2
    8374:	461a      	mov	r2, r3
    8376:	9b04      	ldr	r3, [sp, #16]
    8378:	4413      	add	r3, r2
    837a:	7b1b      	ldrb	r3, [r3, #12]
    837c:	f083 0301 	eor.w	r3, r3, #1
    8380:	b2db      	uxtb	r3, r3
    8382:	2b00      	cmp	r3, #0
    8384:	d05d      	beq.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
        {
            Can_pHwObject = &Can_pHwObjectConfig[u8HwObjectID];
    8386:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    838a:	4613      	mov	r3, r2
    838c:	00db      	lsls	r3, r3, #3
    838e:	4413      	add	r3, r2
    8390:	009b      	lsls	r3, r3, #2
    8392:	461a      	mov	r2, r3
    8394:	9b04      	ldr	r3, [sp, #16]
    8396:	4413      	add	r3, r2
    8398:	930c      	str	r3, [sp, #48]	; 0x30

            if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    839a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    839c:	699b      	ldr	r3, [r3, #24]
    839e:	2b00      	cmp	r3, #0
    83a0:	d118      	bne.n	83d4 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xac>
            {
                pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    83a2:	4a2b      	ldr	r2, [pc, #172]	; (8450 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x128>)
    83a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83a6:	7f1b      	ldrb	r3, [r3, #28]
    83a8:	011b      	lsls	r3, r3, #4
    83aa:	4413      	add	r3, r2
    83ac:	681b      	ldr	r3, [r3, #0]
    83ae:	930b      	str	r3, [sp, #44]	; 0x2c
                Can_Ipw_ParseData(&CanIf_Mailbox, \
    83b0:	a906      	add	r1, sp, #24
    83b2:	a809      	add	r0, sp, #36	; 0x24
    83b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83b6:	9300      	str	r3, [sp, #0]
    83b8:	9b05      	ldr	r3, [sp, #20]
    83ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    83bc:	f7ff fc2e 	bl	7c1c <Can_Ipw_ParseData>
                                  pReceivedDataBuffer, \
                                  Can_pControllerConfig, \
                                  Can_pHwObject \
                                 );
                /* ready to receive in next time */
                (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    83c0:	9b05      	ldr	r3, [sp, #20]
    83c2:	7898      	ldrb	r0, [r3, #2]
    83c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83c6:	7f19      	ldrb	r1, [r3, #28]
    83c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83ca:	7b1b      	ldrb	r3, [r3, #12]
    83cc:	2200      	movs	r2, #0
    83ce:	f001 ff49 	bl	a264 <FlexCAN_Ip_Receive>
            else
            {
                /* prevent misra */
            }
        }
    }
    83d2:	e036      	b.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
            else if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    83d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83d6:	699b      	ldr	r3, [r3, #24]
    83d8:	2b01      	cmp	r3, #1
    83da:	d132      	bne.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                if ((uint8)7U == u8MbIdx)
    83dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    83e0:	2b07      	cmp	r3, #7
    83e2:	d10d      	bne.n	8400 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xd8>
                    (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    83e4:	2301      	movs	r3, #1
    83e6:	2208      	movs	r2, #8
    83e8:	2100      	movs	r1, #0
    83ea:	2050      	movs	r0, #80	; 0x50
    83ec:	f007 f97c 	bl	f6e8 <Det_ReportRuntimeError>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoOvfNotif)
    83f0:	9b05      	ldr	r3, [sp, #20]
    83f2:	699b      	ldr	r3, [r3, #24]
    83f4:	2b00      	cmp	r3, #0
    83f6:	d024      	beq.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                        Can_pControllerConfig->Can_pLegacyFiFoOvfNotif();
    83f8:	9b05      	ldr	r3, [sp, #20]
    83fa:	699b      	ldr	r3, [r3, #24]
    83fc:	4798      	blx	r3
    }
    83fe:	e020      	b.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                else if ((uint8)6U == u8MbIdx)
    8400:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8404:	2b06      	cmp	r3, #6
    8406:	d107      	bne.n	8418 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xf0>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoWarnNotif)
    8408:	9b05      	ldr	r3, [sp, #20]
    840a:	695b      	ldr	r3, [r3, #20]
    840c:	2b00      	cmp	r3, #0
    840e:	d018      	beq.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                        Can_pControllerConfig->Can_pLegacyFiFoWarnNotif();
    8410:	9b05      	ldr	r3, [sp, #20]
    8412:	695b      	ldr	r3, [r3, #20]
    8414:	4798      	blx	r3
    }
    8416:	e014      	b.n	8442 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                    pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    8418:	4a0d      	ldr	r2, [pc, #52]	; (8450 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x128>)
    841a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    841c:	7f1b      	ldrb	r3, [r3, #28]
    841e:	011b      	lsls	r3, r3, #4
    8420:	4413      	add	r3, r2
    8422:	681b      	ldr	r3, [r3, #0]
    8424:	930b      	str	r3, [sp, #44]	; 0x2c
                    Can_Ipw_ParseData(&CanIf_Mailbox, \
    8426:	a906      	add	r1, sp, #24
    8428:	a809      	add	r0, sp, #36	; 0x24
    842a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    842c:	9300      	str	r3, [sp, #0]
    842e:	9b05      	ldr	r3, [sp, #20]
    8430:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8432:	f7ff fbf3 	bl	7c1c <Can_Ipw_ParseData>
                    (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    8436:	9b05      	ldr	r3, [sp, #20]
    8438:	789b      	ldrb	r3, [r3, #2]
    843a:	2100      	movs	r1, #0
    843c:	4618      	mov	r0, r3
    843e:	f002 f80f 	bl	a460 <FlexCAN_Ip_RxFifo>
    }
    8442:	bf00      	nop
    8444:	b00f      	add	sp, #60	; 0x3c
    8446:	f85d fb04 	ldr.w	pc, [sp], #4
    844a:	bf00      	nop
    844c:	1fff8f70 	.word	0x1fff8f70
    8450:	1fff8d10 	.word	0x1fff8d10

00008454 <Can_43_FLEXCAN_Ipw_Init>:
#endif /* (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON) */
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Std_ReturnType Can_43_FLEXCAN_Ipw_Init(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8454:	b510      	push	{r4, lr}
    8456:	b084      	sub	sp, #16
    8458:	9001      	str	r0, [sp, #4]
    Std_ReturnType eRetVal = (Std_ReturnType)FLEXCAN_STATUS_ERROR;
    845a:	2301      	movs	r3, #1
    845c:	f88d 300c 	strb.w	r3, [sp, #12]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    /* The Index of Hoh in a group that refer to a controller */
    uint8 u8HwObjRefIdx = 0U;
    8460:	2300      	movs	r3, #0
    8462:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ObjIdx = 0U;
    8466:	2300      	movs	r3, #0
    8468:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    846c:	2300      	movs	r3, #0
    846e:	9302      	str	r3, [sp, #8]
    uint8 u8HwBufferCount = 0U;
    8470:	2300      	movs	r3, #0
    8472:	f88d 300d 	strb.w	r3, [sp, #13]
#endif

#if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
    Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID] = Can_pControllerConfig->Can_u16DefaultBaudrateID;
    8476:	9b01      	ldr	r3, [sp, #4]
    8478:	785b      	ldrb	r3, [r3, #1]
    847a:	461a      	mov	r2, r3
    847c:	9b01      	ldr	r3, [sp, #4]
    847e:	8b99      	ldrh	r1, [r3, #28]
    8480:	4b78      	ldr	r3, [pc, #480]	; (8664 <Can_43_FLEXCAN_Ipw_Init+0x210>)
    8482:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    {
        Can_Ipw_u32Seconds = 0U;
    }
#endif
    /* @violates @ref Can_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    eRetVal = (Std_ReturnType)Call_Can_FlexCan_Init(Can_pControllerConfig->Can_u8ControllerOffset, Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);
    8486:	9b01      	ldr	r3, [sp, #4]
    8488:	7898      	ldrb	r0, [r3, #2]
    848a:	4977      	ldr	r1, [pc, #476]	; (8668 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    848c:	9b01      	ldr	r3, [sp, #4]
    848e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8490:	681b      	ldr	r3, [r3, #0]
    8492:	461a      	mov	r2, r3
    8494:	f001 fdda 	bl	a04c <FlexCAN_Ip_Init_Privileged>
    8498:	4603      	mov	r3, r0
    849a:	f88d 300c 	strb.w	r3, [sp, #12]
    
    /* by defaut, enable interrupt when setcontroller to start */
    Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    849e:	9b01      	ldr	r3, [sp, #4]
    84a0:	785b      	ldrb	r3, [r3, #1]
    84a2:	461a      	mov	r2, r3
    84a4:	4b71      	ldr	r3, [pc, #452]	; (866c <Can_43_FLEXCAN_Ipw_Init+0x218>)
    84a6:	2101      	movs	r1, #1
    84a8:	5499      	strb	r1, [r3, r2]
    if ((Std_ReturnType)FLEXCAN_STATUS_SUCCESS == eRetVal)
    84aa:	f89d 300c 	ldrb.w	r3, [sp, #12]
    84ae:	2b00      	cmp	r3, #0
    84b0:	d13b      	bne.n	852a <Can_43_FLEXCAN_Ipw_Init+0xd6>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    84b2:	9b01      	ldr	r3, [sp, #4]
    84b4:	789b      	ldrb	r3, [r3, #2]
    84b6:	4618      	mov	r0, r3
    84b8:	f003 f8fc 	bl	b6b4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* If the FlexCAN_Init retuns SUCCESS then the module is already in freezemode, and FlexCAN_Ip_SetTDCOffset and FlexCAN_Ip_SetTxArbitrationStartDelay will always retun success */
        if (Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bFDFrame)
    84bc:	9b01      	ldr	r3, [sp, #4]
    84be:	6a1a      	ldr	r2, [r3, #32]
    84c0:	9b01      	ldr	r3, [sp, #4]
    84c2:	8b9b      	ldrh	r3, [r3, #28]
    84c4:	4619      	mov	r1, r3
    84c6:	2316      	movs	r3, #22
    84c8:	fb01 f303 	mul.w	r3, r1, r3
    84cc:	4413      	add	r3, r2
    84ce:	785b      	ldrb	r3, [r3, #1]
    84d0:	2b00      	cmp	r3, #0
    84d2:	d018      	beq.n	8506 <Can_43_FLEXCAN_Ipw_Init+0xb2>
        {
            (void)FlexCAN_Ip_SetTDCOffset(Can_pControllerConfig->Can_u8ControllerOffset, \
    84d4:	9b01      	ldr	r3, [sp, #4]
    84d6:	7898      	ldrb	r0, [r3, #2]
    84d8:	9b01      	ldr	r3, [sp, #4]
    84da:	6a1a      	ldr	r2, [r3, #32]
    84dc:	9b01      	ldr	r3, [sp, #4]
    84de:	8b9b      	ldrh	r3, [r3, #28]
    84e0:	4619      	mov	r1, r3
    84e2:	2316      	movs	r3, #22
    84e4:	fb01 f303 	mul.w	r3, r1, r3
    84e8:	4413      	add	r3, r2
    84ea:	7cd9      	ldrb	r1, [r3, #19]
    84ec:	9b01      	ldr	r3, [sp, #4]
    84ee:	6a1a      	ldr	r2, [r3, #32]
    84f0:	9b01      	ldr	r3, [sp, #4]
    84f2:	8b9b      	ldrh	r3, [r3, #28]
    84f4:	461c      	mov	r4, r3
    84f6:	2316      	movs	r3, #22
    84f8:	fb04 f303 	mul.w	r3, r4, r3
    84fc:	4413      	add	r3, r2
    84fe:	7d1b      	ldrb	r3, [r3, #20]
    8500:	461a      	mov	r2, r3
    8502:	f002 ffc5 	bl	b490 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bTrcvDelayEnable, \
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(Can_pControllerConfig->Can_u8ControllerOffset, \
    8506:	9b01      	ldr	r3, [sp, #4]
    8508:	7898      	ldrb	r0, [r3, #2]
    850a:	9b01      	ldr	r3, [sp, #4]
    850c:	6a1a      	ldr	r2, [r3, #32]
    850e:	9b01      	ldr	r3, [sp, #4]
    8510:	8b9b      	ldrh	r3, [r3, #28]
    8512:	4619      	mov	r1, r3
    8514:	2316      	movs	r3, #22
    8516:	fb01 f303 	mul.w	r3, r1, r3
    851a:	4413      	add	r3, r2
    851c:	7c9b      	ldrb	r3, [r3, #18]
    851e:	4619      	mov	r1, r3
    8520:	f003 f80a 	bl	b538 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
                                                    Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TxArbitrationStartDelay);
        
        /* Init all Rx objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    8524:	9801      	ldr	r0, [sp, #4]
    8526:	f000 fbe5 	bl	8cf4 <Can_Ipw_InitRx>
    }

#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    852a:	2300      	movs	r3, #0
    852c:	f88d 300d 	strb.w	r3, [sp, #13]
    8530:	e010      	b.n	8554 <Can_43_FLEXCAN_Ipw_Init+0x100>
    {
        Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8HwBufferCount] = CAN_43_FLEXCAN_HWOBJ_UNMAPPED;
    8532:	9b01      	ldr	r3, [sp, #4]
    8534:	785b      	ldrb	r3, [r3, #1]
    8536:	461a      	mov	r2, r3
    8538:	f89d 300d 	ldrb.w	r3, [sp, #13]
    853c:	494c      	ldr	r1, [pc, #304]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    853e:	0152      	lsls	r2, r2, #5
    8540:	4413      	add	r3, r2
    8542:	f64f 72ff 	movw	r2, #65535	; 0xffff
    8546:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    854a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    854e:	3301      	adds	r3, #1
    8550:	f88d 300d 	strb.w	r3, [sp, #13]
    8554:	f89d 300d 	ldrb.w	r3, [sp, #13]
    8558:	2b1f      	cmp	r3, #31
    855a:	d9ea      	bls.n	8532 <Can_43_FLEXCAN_Ipw_Init+0xde>
    }
    /* Map MB index to hardware object ID */
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    855c:	2300      	movs	r3, #0
    855e:	f88d 300f 	strb.w	r3, [sp, #15]
    8562:	e06b      	b.n	863c <Can_43_FLEXCAN_Ipw_Init+0x1e8>
    {
        Can_pHwObject = Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    8564:	9b01      	ldr	r3, [sp, #4]
    8566:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    8568:	f89d 300f 	ldrb.w	r3, [sp, #15]
    856c:	009b      	lsls	r3, r3, #2
    856e:	4413      	add	r3, r2
    8570:	681b      	ldr	r3, [r3, #0]
    8572:	9302      	str	r3, [sp, #8]
        switch (Can_pHwObject->Can_eReceiveType)
    8574:	9b02      	ldr	r3, [sp, #8]
    8576:	699b      	ldr	r3, [r3, #24]
    8578:	2b03      	cmp	r3, #3
    857a:	d006      	beq.n	858a <Can_43_FLEXCAN_Ipw_Init+0x136>
    857c:	2b03      	cmp	r3, #3
    857e:	d857      	bhi.n	8630 <Can_43_FLEXCAN_Ipw_Init+0x1dc>
    8580:	2b00      	cmp	r3, #0
    8582:	d023      	beq.n	85cc <Can_43_FLEXCAN_Ipw_Init+0x178>
    8584:	2b01      	cmp	r3, #1
    8586:	d02f      	beq.n	85e8 <Can_43_FLEXCAN_Ipw_Init+0x194>
                break;
            }
            default:
            {
                /* don't map for enhance fifo object because of out of message buffer memory */
                break;
    8588:	e052      	b.n	8630 <Can_43_FLEXCAN_Ipw_Init+0x1dc>
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    858a:	2300      	movs	r3, #0
    858c:	f88d 300e 	strb.w	r3, [sp, #14]
    8590:	e015      	b.n	85be <Can_43_FLEXCAN_Ipw_Init+0x16a>
                    Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex + u8ObjIdx] = Can_pHwObject->Can_HwObjectID;
    8592:	9b01      	ldr	r3, [sp, #4]
    8594:	785b      	ldrb	r3, [r3, #1]
    8596:	461c      	mov	r4, r3
    8598:	9b02      	ldr	r3, [sp, #8]
    859a:	7f1b      	ldrb	r3, [r3, #28]
    859c:	461a      	mov	r2, r3
    859e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    85a2:	4413      	add	r3, r2
    85a4:	9a02      	ldr	r2, [sp, #8]
    85a6:	8810      	ldrh	r0, [r2, #0]
    85a8:	4931      	ldr	r1, [pc, #196]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    85aa:	0162      	lsls	r2, r4, #5
    85ac:	4413      	add	r3, r2
    85ae:	4602      	mov	r2, r0
    85b0:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    85b4:	f89d 300e 	ldrb.w	r3, [sp, #14]
    85b8:	3301      	adds	r3, #1
    85ba:	f88d 300e 	strb.w	r3, [sp, #14]
    85be:	9b02      	ldr	r3, [sp, #8]
    85c0:	7b9b      	ldrb	r3, [r3, #14]
    85c2:	f89d 200e 	ldrb.w	r2, [sp, #14]
    85c6:	429a      	cmp	r2, r3
    85c8:	d3e3      	bcc.n	8592 <Can_43_FLEXCAN_Ipw_Init+0x13e>
                break;
    85ca:	e032      	b.n	8632 <Can_43_FLEXCAN_Ipw_Init+0x1de>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    85cc:	9b01      	ldr	r3, [sp, #4]
    85ce:	785b      	ldrb	r3, [r3, #1]
    85d0:	461c      	mov	r4, r3
    85d2:	9b02      	ldr	r3, [sp, #8]
    85d4:	7f1b      	ldrb	r3, [r3, #28]
    85d6:	4618      	mov	r0, r3
    85d8:	9b02      	ldr	r3, [sp, #8]
    85da:	8819      	ldrh	r1, [r3, #0]
    85dc:	4a24      	ldr	r2, [pc, #144]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    85de:	0163      	lsls	r3, r4, #5
    85e0:	4403      	add	r3, r0
    85e2:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                break;
    85e6:	e024      	b.n	8632 <Can_43_FLEXCAN_Ipw_Init+0x1de>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    85e8:	9b01      	ldr	r3, [sp, #4]
    85ea:	785b      	ldrb	r3, [r3, #1]
    85ec:	461c      	mov	r4, r3
    85ee:	9b02      	ldr	r3, [sp, #8]
    85f0:	7f1b      	ldrb	r3, [r3, #28]
    85f2:	4618      	mov	r0, r3
    85f4:	9b02      	ldr	r3, [sp, #8]
    85f6:	8819      	ldrh	r1, [r3, #0]
    85f8:	4a1d      	ldr	r2, [pc, #116]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    85fa:	0163      	lsls	r3, r4, #5
    85fc:	4403      	add	r3, r0
    85fe:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][6U] = Can_pHwObject->Can_HwObjectID;
    8602:	9b01      	ldr	r3, [sp, #4]
    8604:	785b      	ldrb	r3, [r3, #1]
    8606:	4618      	mov	r0, r3
    8608:	9b02      	ldr	r3, [sp, #8]
    860a:	8819      	ldrh	r1, [r3, #0]
    860c:	4a18      	ldr	r2, [pc, #96]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    860e:	0183      	lsls	r3, r0, #6
    8610:	4413      	add	r3, r2
    8612:	330c      	adds	r3, #12
    8614:	460a      	mov	r2, r1
    8616:	801a      	strh	r2, [r3, #0]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][7U] = Can_pHwObject->Can_HwObjectID;
    8618:	9b01      	ldr	r3, [sp, #4]
    861a:	785b      	ldrb	r3, [r3, #1]
    861c:	4618      	mov	r0, r3
    861e:	9b02      	ldr	r3, [sp, #8]
    8620:	8819      	ldrh	r1, [r3, #0]
    8622:	4a13      	ldr	r2, [pc, #76]	; (8670 <Can_43_FLEXCAN_Ipw_Init+0x21c>)
    8624:	0183      	lsls	r3, r0, #6
    8626:	4413      	add	r3, r2
    8628:	330e      	adds	r3, #14
    862a:	460a      	mov	r2, r1
    862c:	801a      	strh	r2, [r3, #0]
                break;
    862e:	e000      	b.n	8632 <Can_43_FLEXCAN_Ipw_Init+0x1de>
                break;
    8630:	bf00      	nop
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    8632:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8636:	3301      	adds	r3, #1
    8638:	f88d 300f 	strb.w	r3, [sp, #15]
    863c:	9b01      	ldr	r3, [sp, #4]
    863e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    8642:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8646:	429a      	cmp	r2, r3
    8648:	d38c      	bcc.n	8564 <Can_43_FLEXCAN_Ipw_Init+0x110>
            }
        }
    }
#endif /* MB_INTERRUPT_SUPPORT */
    eRetVal = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    864a:	9b01      	ldr	r3, [sp, #4]
    864c:	789b      	ldrb	r3, [r3, #2]
    864e:	4618      	mov	r0, r3
    8650:	f002 fd80 	bl	b154 <FlexCAN_Ip_SetStopMode_Privileged>
    8654:	4603      	mov	r3, r0
    8656:	f88d 300c 	strb.w	r3, [sp, #12]

    return (Std_ReturnType)eRetVal;
    865a:	f89d 300c 	ldrb.w	r3, [sp, #12]
}
    865e:	4618      	mov	r0, r3
    8660:	b004      	add	sp, #16
    8662:	bd10      	pop	{r4, pc}
    8664:	1fff8fb0 	.word	0x1fff8fb0
    8668:	1fff8d10 	.word	0x1fff8d10
    866c:	1fff8fb4 	.word	0x1fff8fb4
    8670:	1fff8f70 	.word	0x1fff8f70

00008674 <Can_43_FLEXCAN_Ipw_DeInit>:

/**
*   @brief      De-Initialize Controller
*/
void Can_43_FLEXCAN_Ipw_DeInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8674:	b500      	push	{lr}
    8676:	b083      	sub	sp, #12
    8678:	9001      	str	r0, [sp, #4]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    (void)FlexCAN_Ip_Deinit(Can_pControllerConfig->Can_u8ControllerOffset);
    867a:	9b01      	ldr	r3, [sp, #4]
    867c:	789b      	ldrb	r3, [r3, #2]
    867e:	4618      	mov	r0, r3
    8680:	f002 fbd4 	bl	ae2c <FlexCAN_Ip_Deinit_Privileged>
}
    8684:	bf00      	nop
    8686:	b003      	add	sp, #12
    8688:	f85d fb04 	ldr.w	pc, [sp], #4

0000868c <Can_43_FLEXCAN_Ipw_SetBaudrate>:
    Std_ReturnType Can_43_FLEXCAN_Ipw_SetBaudrate
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        uint16 BaudRateConfigID
    )
    {
    868c:	b510      	push	{r4, lr}
    868e:	b088      	sub	sp, #32
    8690:	9001      	str	r0, [sp, #4]
    8692:	460b      	mov	r3, r1
    8694:	f8ad 3002 	strh.w	r3, [sp, #2]
        Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    8698:	2301      	movs	r3, #1
    869a:	9307      	str	r3, [sp, #28]
        Flexcan_Ip_TimeSegmentType FlexCANTimeSeg;

        eRetVal = FlexCAN_Ip_EnterFreezeMode(Can_pControllerConfig->Can_u8ControllerOffset);
    869c:	9b01      	ldr	r3, [sp, #4]
    869e:	789b      	ldrb	r3, [r3, #2]
    86a0:	4618      	mov	r0, r3
    86a2:	f002 fb01 	bl	aca8 <FlexCAN_Ip_EnterFreezeMode_Privileged>
    86a6:	9007      	str	r0, [sp, #28]
        if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    86a8:	9b07      	ldr	r3, [sp, #28]
    86aa:	2b00      	cmp	r3, #0
    86ac:	f040 80bb 	bne.w	8826 <Can_43_FLEXCAN_Ipw_SetBaudrate+0x19a>
        {
        #if (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON)
            if (CAN_43_FLEXCAN_CLOCKMODE_NORMAL == Can_Ipw_eClockMode[Can_pControllerConfig->Can_u8ControllerID])
            {
        #endif
                FlexCANTimeSeg.preDivider = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u16Prescaler;
    86b0:	9b01      	ldr	r3, [sp, #4]
    86b2:	6a1a      	ldr	r2, [r3, #32]
    86b4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    86b8:	2116      	movs	r1, #22
    86ba:	fb01 f303 	mul.w	r3, r1, r3
    86be:	4413      	add	r3, r2
    86c0:	88db      	ldrh	r3, [r3, #6]
    86c2:	9305      	str	r3, [sp, #20]
            {
                FlexCANTimeSeg.preDivider = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u16PrescalerAlternate;
            }
        #endif

            FlexCANTimeSeg.propSeg    = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PropSeg;
    86c4:	9b01      	ldr	r3, [sp, #4]
    86c6:	6a1a      	ldr	r2, [r3, #32]
    86c8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    86cc:	2116      	movs	r1, #22
    86ce:	fb01 f303 	mul.w	r3, r1, r3
    86d2:	4413      	add	r3, r2
    86d4:	789b      	ldrb	r3, [r3, #2]
    86d6:	9302      	str	r3, [sp, #8]
            FlexCANTimeSeg.phaseSeg1  = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg1;
    86d8:	9b01      	ldr	r3, [sp, #4]
    86da:	6a1a      	ldr	r2, [r3, #32]
    86dc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    86e0:	2116      	movs	r1, #22
    86e2:	fb01 f303 	mul.w	r3, r1, r3
    86e6:	4413      	add	r3, r2
    86e8:	78db      	ldrb	r3, [r3, #3]
    86ea:	9303      	str	r3, [sp, #12]
            FlexCANTimeSeg.phaseSeg2  = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg2;
    86ec:	9b01      	ldr	r3, [sp, #4]
    86ee:	6a1a      	ldr	r2, [r3, #32]
    86f0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    86f4:	2116      	movs	r1, #22
    86f6:	fb01 f303 	mul.w	r3, r1, r3
    86fa:	4413      	add	r3, r2
    86fc:	791b      	ldrb	r3, [r3, #4]
    86fe:	9304      	str	r3, [sp, #16]
            FlexCANTimeSeg.rJumpwidth = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8ResyncJumpWidth;
    8700:	9b01      	ldr	r3, [sp, #4]
    8702:	6a1a      	ldr	r2, [r3, #32]
    8704:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8708:	2116      	movs	r1, #22
    870a:	fb01 f303 	mul.w	r3, r1, r3
    870e:	4413      	add	r3, r2
    8710:	7a1b      	ldrb	r3, [r3, #8]
    8712:	9306      	str	r3, [sp, #24]

            
            (void)FlexCAN_Ip_SetBitrate(Can_pControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, FALSE);
    8714:	9b01      	ldr	r3, [sp, #4]
    8716:	789b      	ldrb	r3, [r3, #2]
    8718:	a902      	add	r1, sp, #8
    871a:	2200      	movs	r2, #0
    871c:	4618      	mov	r0, r3
    871e:	f002 fd83 	bl	b228 <FlexCAN_Ip_SetBitrate_Privileged>
        #if (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON)
            if (CAN_43_FLEXCAN_CLOCKMODE_NORMAL == Can_Ipw_eClockMode[Can_pControllerConfig->Can_u8ControllerID])
            {
        #endif
                FlexCANTimeSeg.preDivider = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u16Prescaler;
    8722:	9b01      	ldr	r3, [sp, #4]
    8724:	6a1a      	ldr	r2, [r3, #32]
    8726:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    872a:	2116      	movs	r1, #22
    872c:	fb01 f303 	mul.w	r3, r1, r3
    8730:	4413      	add	r3, r2
    8732:	89db      	ldrh	r3, [r3, #14]
    8734:	9305      	str	r3, [sp, #20]
            {
                FlexCANTimeSeg.preDivider = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u16PrescalerAlternate;
            }
        #endif

            if (TRUE == Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bFDFrame)
    8736:	9b01      	ldr	r3, [sp, #4]
    8738:	6a1a      	ldr	r2, [r3, #32]
    873a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    873e:	2116      	movs	r1, #22
    8740:	fb01 f303 	mul.w	r3, r1, r3
    8744:	4413      	add	r3, r2
    8746:	785b      	ldrb	r3, [r3, #1]
    8748:	2b00      	cmp	r3, #0
    874a:	d04d      	beq.n	87e8 <Can_43_FLEXCAN_Ipw_SetBaudrate+0x15c>
            {
                FlexCANTimeSeg.propSeg    = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PropSeg;
    874c:	9b01      	ldr	r3, [sp, #4]
    874e:	6a1a      	ldr	r2, [r3, #32]
    8750:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8754:	2116      	movs	r1, #22
    8756:	fb01 f303 	mul.w	r3, r1, r3
    875a:	4413      	add	r3, r2
    875c:	7a9b      	ldrb	r3, [r3, #10]
    875e:	9302      	str	r3, [sp, #8]
                FlexCANTimeSeg.phaseSeg1  = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg1;
    8760:	9b01      	ldr	r3, [sp, #4]
    8762:	6a1a      	ldr	r2, [r3, #32]
    8764:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8768:	2116      	movs	r1, #22
    876a:	fb01 f303 	mul.w	r3, r1, r3
    876e:	4413      	add	r3, r2
    8770:	7adb      	ldrb	r3, [r3, #11]
    8772:	9303      	str	r3, [sp, #12]
                FlexCANTimeSeg.phaseSeg2  = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg2;
    8774:	9b01      	ldr	r3, [sp, #4]
    8776:	6a1a      	ldr	r2, [r3, #32]
    8778:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    877c:	2116      	movs	r1, #22
    877e:	fb01 f303 	mul.w	r3, r1, r3
    8782:	4413      	add	r3, r2
    8784:	7b1b      	ldrb	r3, [r3, #12]
    8786:	9304      	str	r3, [sp, #16]
                FlexCANTimeSeg.rJumpwidth = Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8ResyncJumpWidth;
    8788:	9b01      	ldr	r3, [sp, #4]
    878a:	6a1a      	ldr	r2, [r3, #32]
    878c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8790:	2116      	movs	r1, #22
    8792:	fb01 f303 	mul.w	r3, r1, r3
    8796:	4413      	add	r3, r2
    8798:	7c1b      	ldrb	r3, [r3, #16]
    879a:	9306      	str	r3, [sp, #24]

                (void)FlexCAN_Ip_SetBitrateCbt(Can_pControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bBitRateSwitch);
    879c:	9b01      	ldr	r3, [sp, #4]
    879e:	7898      	ldrb	r0, [r3, #2]
    87a0:	9b01      	ldr	r3, [sp, #4]
    87a2:	6a1a      	ldr	r2, [r3, #32]
    87a4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    87a8:	2116      	movs	r1, #22
    87aa:	fb01 f303 	mul.w	r3, r1, r3
    87ae:	4413      	add	r3, r2
    87b0:	781a      	ldrb	r2, [r3, #0]
    87b2:	ab02      	add	r3, sp, #8
    87b4:	4619      	mov	r1, r3
    87b6:	f002 fe01 	bl	b3bc <FlexCAN_Ip_SetBitrateCbt_Privileged>

                (void)FlexCAN_Ip_SetTDCOffset(Can_pControllerConfig->Can_u8ControllerOffset, \
    87ba:	9b01      	ldr	r3, [sp, #4]
    87bc:	7898      	ldrb	r0, [r3, #2]
    87be:	9b01      	ldr	r3, [sp, #4]
    87c0:	6a1a      	ldr	r2, [r3, #32]
    87c2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    87c6:	2116      	movs	r1, #22
    87c8:	fb01 f303 	mul.w	r3, r1, r3
    87cc:	4413      	add	r3, r2
    87ce:	7cd9      	ldrb	r1, [r3, #19]
    87d0:	9b01      	ldr	r3, [sp, #4]
    87d2:	6a1a      	ldr	r2, [r3, #32]
    87d4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    87d8:	2416      	movs	r4, #22
    87da:	fb04 f303 	mul.w	r3, r4, r3
    87de:	4413      	add	r3, r2
    87e0:	7d1b      	ldrb	r3, [r3, #20]
    87e2:	461a      	mov	r2, r3
    87e4:	f002 fe54 	bl	b490 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                            Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bTrcvDelayEnable, \
                                            Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TrcvDelayCompOffset \
                                            );
            }

            (void)FlexCAN_Ip_SetTxArbitrationStartDelay(Can_pControllerConfig->Can_u8ControllerOffset, Can_pControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TxArbitrationStartDelay);
    87e8:	9b01      	ldr	r3, [sp, #4]
    87ea:	7898      	ldrb	r0, [r3, #2]
    87ec:	9b01      	ldr	r3, [sp, #4]
    87ee:	6a1a      	ldr	r2, [r3, #32]
    87f0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    87f4:	2116      	movs	r1, #22
    87f6:	fb01 f303 	mul.w	r3, r1, r3
    87fa:	4413      	add	r3, r2
    87fc:	7c9b      	ldrb	r3, [r3, #18]
    87fe:	4619      	mov	r1, r3
    8800:	f002 fe9a 	bl	b538 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>

            eRetVal = FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    8804:	9b01      	ldr	r3, [sp, #4]
    8806:	789b      	ldrb	r3, [r3, #2]
    8808:	4618      	mov	r0, r3
    880a:	f002 fca3 	bl	b154 <FlexCAN_Ip_SetStopMode_Privileged>
    880e:	9007      	str	r0, [sp, #28]
            if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    8810:	9b07      	ldr	r3, [sp, #28]
    8812:	2b00      	cmp	r3, #0
    8814:	d107      	bne.n	8826 <Can_43_FLEXCAN_Ipw_SetBaudrate+0x19a>
            {
                Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID] = BaudRateConfigID;
    8816:	9b01      	ldr	r3, [sp, #4]
    8818:	785b      	ldrb	r3, [r3, #1]
    881a:	4619      	mov	r1, r3
    881c:	4a06      	ldr	r2, [pc, #24]	; (8838 <Can_43_FLEXCAN_Ipw_SetBaudrate+0x1ac>)
    881e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    8822:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
            }
        }
        return ((FLEXCAN_STATUS_SUCCESS == eRetVal) ? ((Std_ReturnType)E_OK) : ((Std_ReturnType)E_NOT_OK));
    8826:	9b07      	ldr	r3, [sp, #28]
    8828:	2b00      	cmp	r3, #0
    882a:	bf14      	ite	ne
    882c:	2301      	movne	r3, #1
    882e:	2300      	moveq	r3, #0
    8830:	b2db      	uxtb	r3, r3
    }
    8832:	4618      	mov	r0, r3
    8834:	b008      	add	sp, #32
    8836:	bd10      	pop	{r4, pc}
    8838:	1fff8fb0 	.word	0x1fff8fb0

0000883c <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>:

/**
*   @brief      Set Error Initialization and set Controller to start Mode.
*/
static Std_ReturnType Can_43_FLEXCAN_Ipw_SetControlerErrorInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    883c:	b500      	push	{lr}
    883e:	b085      	sub	sp, #20
    8840:	9001      	str	r0, [sp, #4]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_SUCCESS;
    8842:	2300      	movs	r3, #0
    8844:	9303      	str	r3, [sp, #12]

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    8846:	9b01      	ldr	r3, [sp, #4]
    8848:	785b      	ldrb	r3, [r3, #1]
    884a:	461a      	mov	r2, r3
    884c:	4b11      	ldr	r3, [pc, #68]	; (8894 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x58>)
    884e:	5c9b      	ldrb	r3, [r3, r2]
    8850:	2b00      	cmp	r3, #0
    8852:	d012      	beq.n	887a <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x3e>
    {
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    8854:	9b01      	ldr	r3, [sp, #4]
    8856:	7a5b      	ldrb	r3, [r3, #9]
    8858:	f083 0301 	eor.w	r3, r3, #1
    885c:	b2db      	uxtb	r3, r3
    885e:	2b00      	cmp	r3, #0
    8860:	d006      	beq.n	8870 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x34>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    8862:	9b01      	ldr	r3, [sp, #4]
    8864:	789b      	ldrb	r3, [r3, #2]
    8866:	2201      	movs	r2, #1
    8868:	2104      	movs	r1, #4
    886a:	4618      	mov	r0, r3
    886c:	f002 ff4e 	bl	b70c <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    8870:	9b01      	ldr	r3, [sp, #4]
    8872:	789b      	ldrb	r3, [r3, #2]
    8874:	4618      	mov	r0, r3
    8876:	f002 feef 	bl	b658 <FlexCAN_Ip_EnableInterrupts_Privileged>
    }
    eRetVal = FlexCAN_Ip_SetStartMode(Can_pControllerConfig->Can_u8ControllerOffset);
    887a:	9b01      	ldr	r3, [sp, #4]
    887c:	789b      	ldrb	r3, [r3, #2]
    887e:	4618      	mov	r0, r3
    8880:	f002 fc48 	bl	b114 <FlexCAN_Ip_SetStartMode_Privileged>
    8884:	9003      	str	r0, [sp, #12]

    return (Std_ReturnType)eRetVal;
    8886:	9b03      	ldr	r3, [sp, #12]
    8888:	b2db      	uxtb	r3, r3
}
    888a:	4618      	mov	r0, r3
    888c:	b005      	add	sp, #20
    888e:	f85d fb04 	ldr.w	pc, [sp], #4
    8892:	bf00      	nop
    8894:	1fff8fb4 	.word	0x1fff8fb4

00008898 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>:

/**
*   @brief      Set Controller to participate the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStartMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8898:	b500      	push	{lr}
    889a:	b087      	sub	sp, #28
    889c:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    uint8 u8HwObjRefIdx = 0U;
    889e:	2300      	movs	r3, #0
    88a0:	f88d 3017 	strb.w	r3, [sp, #23]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    88a4:	2300      	movs	r3, #0
    88a6:	9303      	str	r3, [sp, #12]
        {
            Can_Ipw_u32CurrentCompareVal = Stm_Ip_GetCompareValue(CAN_43_FLEXCAN_TS_STM_INSTANCE, CAN_43_FLEXCAN_TS_STM_CHANNEL);
        }
    }
#endif
    eRetVal = FlexCAN_Ip_Init(Can_pControllerConfig->Can_u8ControllerOffset, \
    88a8:	9b01      	ldr	r3, [sp, #4]
    88aa:	7898      	ldrb	r0, [r3, #2]
    88ac:	4930      	ldr	r1, [pc, #192]	; (8970 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xd8>)
    88ae:	9b01      	ldr	r3, [sp, #4]
    88b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    88b2:	681b      	ldr	r3, [r3, #0]
    88b4:	461a      	mov	r2, r3
    88b6:	f001 fbc9 	bl	a04c <FlexCAN_Ip_Init_Privileged>
    88ba:	9004      	str	r0, [sp, #16]
                                                    Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], \
                                                    Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);

    if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    88bc:	9b04      	ldr	r3, [sp, #16]
    88be:	2b00      	cmp	r3, #0
    88c0:	d14f      	bne.n	8962 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xca>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    88c2:	9b01      	ldr	r3, [sp, #4]
    88c4:	789b      	ldrb	r3, [r3, #2]
    88c6:	4618      	mov	r0, r3
    88c8:	f002 fef4 	bl	b6b4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* Re-Init baudrate */
        Can_Ipw_InitBaudrate(Can_pControllerConfig);
    88cc:	9801      	ldr	r0, [sp, #4]
    88ce:	f7ff fc25 	bl	811c <Can_Ipw_InitBaudrate>

        /* Re-Init all Rx Objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    88d2:	9801      	ldr	r0, [sp, #4]
    88d4:	f000 fa0e 	bl	8cf4 <Can_Ipw_InitRx>
            Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][MbIdx] = FALSE;
        }
    #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */

    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    88d8:	2300      	movs	r3, #0
    88da:	f88d 3017 	strb.w	r3, [sp, #23]
    88de:	e02f      	b.n	8940 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa8>
        {
            Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    88e0:	9b01      	ldr	r3, [sp, #4]
    88e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    88e4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    88e8:	009b      	lsls	r3, r3, #2
    88ea:	4413      	add	r3, r2
    88ec:	681b      	ldr	r3, [r3, #0]
    88ee:	9303      	str	r3, [sp, #12]

            if (FALSE == Can_pHwObject->Can_bHwObjectUsesPolling)
    88f0:	9b03      	ldr	r3, [sp, #12]
    88f2:	7b1b      	ldrb	r3, [r3, #12]
    88f4:	f083 0301 	eor.w	r3, r3, #1
    88f8:	b2db      	uxtb	r3, r3
    88fa:	2b00      	cmp	r3, #0
    88fc:	d018      	beq.n	8930 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x98>
            {
                switch (Can_pHwObject->Can_eReceiveType)
    88fe:	9b03      	ldr	r3, [sp, #12]
    8900:	699b      	ldr	r3, [r3, #24]
    8902:	2b00      	cmp	r3, #0
    8904:	d003      	beq.n	890e <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x76>
    8906:	3b01      	subs	r3, #1
    8908:	2b01      	cmp	r3, #1
    890a:	d813      	bhi.n	8934 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9c>
    890c:	e009      	b.n	8922 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x8a>
                {
                    case CAN_RX_NORMAL:
                    {
                        (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    890e:	9b01      	ldr	r3, [sp, #4]
    8910:	7898      	ldrb	r0, [r3, #2]
    8912:	9b03      	ldr	r3, [sp, #12]
    8914:	7f19      	ldrb	r1, [r3, #28]
    8916:	9b03      	ldr	r3, [sp, #12]
    8918:	7b1b      	ldrb	r3, [r3, #12]
    891a:	2200      	movs	r2, #0
    891c:	f001 fca2 	bl	a264 <FlexCAN_Ip_Receive>
                                                 Can_pHwObject->Can_u8HwBufferIndex, \
                                                 NULL_PTR, \
                                                 Can_pHwObject->Can_bHwObjectUsesPolling \
                                                );
                        break;
    8920:	e009      	b.n	8936 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, Can_pControllerConfig->pDmaDstAddr);
                        }
                        else
                    #endif
                        {
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    8922:	9b01      	ldr	r3, [sp, #4]
    8924:	789b      	ldrb	r3, [r3, #2]
    8926:	2100      	movs	r1, #0
    8928:	4618      	mov	r0, r3
    892a:	f001 fd99 	bl	a460 <FlexCAN_Ip_RxFifo>
                        }
                        break;
    892e:	e002      	b.n	8936 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                    {
                        /* nothing to do(TX object) */
                        break;
                    }
                }
            }
    8930:	bf00      	nop
    8932:	e000      	b.n	8936 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                        break;
    8934:	bf00      	nop
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    8936:	f89d 3017 	ldrb.w	r3, [sp, #23]
    893a:	3301      	adds	r3, #1
    893c:	f88d 3017 	strb.w	r3, [sp, #23]
    8940:	9b01      	ldr	r3, [sp, #4]
    8942:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    8946:	f89d 2017 	ldrb.w	r2, [sp, #23]
    894a:	429a      	cmp	r2, r3
    894c:	d3c8      	bcc.n	88e0 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x48>
        }
    #endif /* CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON */
        eRetVal = ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControlerErrorInit(Can_pControllerConfig)) ? (FLEXCAN_STATUS_SUCCESS) : (FLEXCAN_STATUS_ERROR);
    894e:	9801      	ldr	r0, [sp, #4]
    8950:	f7ff ff74 	bl	883c <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>
    8954:	4603      	mov	r3, r0
    8956:	2b00      	cmp	r3, #0
    8958:	bf14      	ite	ne
    895a:	2301      	movne	r3, #1
    895c:	2300      	moveq	r3, #0
    895e:	b2db      	uxtb	r3, r3
    8960:	9304      	str	r3, [sp, #16]
    }
    return (Std_ReturnType)eRetVal;
    8962:	9b04      	ldr	r3, [sp, #16]
    8964:	b2db      	uxtb	r3, r3
}
    8966:	4618      	mov	r0, r3
    8968:	b007      	add	sp, #28
    896a:	f85d fb04 	ldr.w	pc, [sp], #4
    896e:	bf00      	nop
    8970:	1fff8d10 	.word	0x1fff8d10

00008974 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>:

/**
*   @brief      Set Controller to stop participating the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStopMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8974:	b500      	push	{lr}
    8976:	b085      	sub	sp, #20
    8978:	9001      	str	r0, [sp, #4]
    * that are not allowed in the new state. 
    * [SWS_Can_00426]  Disabling of CAN interrupts shall not be executed, when CAN
    * interrupts have been disabled by function Can_DisableControllerInterrupts.
    */
    Std_ReturnType eReturnValue;
    uint8 u8HwObjRefIdx = 0U;
    897a:	2300      	movs	r3, #0
    897c:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    uint8 u8Idx = 0U;
    8980:	2300      	movs	r3, #0
    8982:	f88d 300d 	strb.w	r3, [sp, #13]

    if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_EnterFreezeMode(Can_pControllerConfig->Can_u8ControllerOffset))
    8986:	9b01      	ldr	r3, [sp, #4]
    8988:	789b      	ldrb	r3, [r3, #2]
    898a:	4618      	mov	r0, r3
    898c:	f002 f98c 	bl	aca8 <FlexCAN_Ip_EnterFreezeMode_Privileged>
    8990:	4603      	mov	r3, r0
    8992:	2b00      	cmp	r3, #0
    8994:	d160      	bne.n	8a58 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xe4>
    {
    #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_ConfigPN(Can_pControllerConfig->Can_u8ControllerOffset, FALSE, NULL_PTR);
    #endif

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    8996:	9b01      	ldr	r3, [sp, #4]
    8998:	785b      	ldrb	r3, [r3, #1]
    899a:	461a      	mov	r2, r3
    899c:	4b33      	ldr	r3, [pc, #204]	; (8a6c <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xf8>)
    899e:	5c9b      	ldrb	r3, [r3, r2]
    89a0:	2b00      	cmp	r3, #0
    89a2:	d012      	beq.n	89ca <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
    {
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    89a4:	9b01      	ldr	r3, [sp, #4]
    89a6:	789b      	ldrb	r3, [r3, #2]
    89a8:	4618      	mov	r0, r3
    89aa:	f002 fe83 	bl	b6b4 <FlexCAN_Ip_DisableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    89ae:	9b01      	ldr	r3, [sp, #4]
    89b0:	7a5b      	ldrb	r3, [r3, #9]
    89b2:	f083 0301 	eor.w	r3, r3, #1
    89b6:	b2db      	uxtb	r3, r3
    89b8:	2b00      	cmp	r3, #0
    89ba:	d006      	beq.n	89ca <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    89bc:	9b01      	ldr	r3, [sp, #4]
    89be:	789b      	ldrb	r3, [r3, #2]
    89c0:	2200      	movs	r2, #0
    89c2:	2104      	movs	r1, #4
    89c4:	4618      	mov	r0, r3
    89c6:	f002 fea1 	bl	b70c <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    89ca:	2300      	movs	r3, #0
    89cc:	f88d 300e 	strb.w	r3, [sp, #14]
    89d0:	e032      	b.n	8a38 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xc4>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    89d2:	9b01      	ldr	r3, [sp, #4]
    89d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    89d6:	f89d 300e 	ldrb.w	r3, [sp, #14]
    89da:	009b      	lsls	r3, r3, #2
    89dc:	4413      	add	r3, r2
    89de:	681b      	ldr	r3, [r3, #0]
    89e0:	9302      	str	r3, [sp, #8]

        if (CAN_TX_NORMAL == Can_pHwObject->Can_eReceiveType)
    89e2:	9b02      	ldr	r3, [sp, #8]
    89e4:	699b      	ldr	r3, [r3, #24]
    89e6:	2b03      	cmp	r3, #3
    89e8:	d119      	bne.n	8a1e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xaa>
        {
            u8Idx = 0U;
    89ea:	2300      	movs	r3, #0
    89ec:	f88d 300d 	strb.w	r3, [sp, #13]
            do
            {
                (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex + u8Idx);
    89f0:	9b01      	ldr	r3, [sp, #4]
    89f2:	7898      	ldrb	r0, [r3, #2]
    89f4:	9b02      	ldr	r3, [sp, #8]
    89f6:	7f1a      	ldrb	r2, [r3, #28]
    89f8:	f89d 300d 	ldrb.w	r3, [sp, #13]
    89fc:	4413      	add	r3, r2
    89fe:	b2db      	uxtb	r3, r3
    8a00:	4619      	mov	r1, r3
    8a02:	f002 ff09 	bl	b818 <FlexCAN_Ip_AbortTransfer>
                u8Idx++;
    8a06:	f89d 300d 	ldrb.w	r3, [sp, #13]
    8a0a:	3301      	adds	r3, #1
    8a0c:	f88d 300d 	strb.w	r3, [sp, #13]
            }while (u8Idx < Can_pHwObject->Can_u8ObjectCount);
    8a10:	9b02      	ldr	r3, [sp, #8]
    8a12:	7b9b      	ldrb	r3, [r3, #14]
    8a14:	f89d 200d 	ldrb.w	r2, [sp, #13]
    8a18:	429a      	cmp	r2, r3
    8a1a:	d3e9      	bcc.n	89f0 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x7c>
    8a1c:	e007      	b.n	8a2e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xba>
        }
        else
        {
            (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex);
    8a1e:	9b01      	ldr	r3, [sp, #4]
    8a20:	789a      	ldrb	r2, [r3, #2]
    8a22:	9b02      	ldr	r3, [sp, #8]
    8a24:	7f1b      	ldrb	r3, [r3, #28]
    8a26:	4619      	mov	r1, r3
    8a28:	4610      	mov	r0, r2
    8a2a:	f002 fef5 	bl	b818 <FlexCAN_Ip_AbortTransfer>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    8a2e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8a32:	3301      	adds	r3, #1
    8a34:	f88d 300e 	strb.w	r3, [sp, #14]
    8a38:	9b01      	ldr	r3, [sp, #4]
    8a3a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    8a3e:	f89d 200e 	ldrb.w	r2, [sp, #14]
    8a42:	429a      	cmp	r2, r3
    8a44:	d3c5      	bcc.n	89d2 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x5e>
        }
    }
    eReturnValue = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    8a46:	9b01      	ldr	r3, [sp, #4]
    8a48:	789b      	ldrb	r3, [r3, #2]
    8a4a:	4618      	mov	r0, r3
    8a4c:	f002 fb82 	bl	b154 <FlexCAN_Ip_SetStopMode_Privileged>
    8a50:	4603      	mov	r3, r0
    8a52:	f88d 300f 	strb.w	r3, [sp, #15]
    8a56:	e002      	b.n	8a5e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xea>
    }
    else
    {
        eReturnValue = E_NOT_OK;
    8a58:	2301      	movs	r3, #1
    8a5a:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return eReturnValue;
    8a5e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    8a62:	4618      	mov	r0, r3
    8a64:	b005      	add	sp, #20
    8a66:	f85d fb04 	ldr.w	pc, [sp], #4
    8a6a:	bf00      	nop
    8a6c:	1fff8fb4 	.word	0x1fff8fb4

00008a70 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>:
/**
*   @brief      Disable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8a70:	b500      	push	{lr}
    8a72:	b083      	sub	sp, #12
    8a74:	9001      	str	r0, [sp, #4]
    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    8a76:	9b01      	ldr	r3, [sp, #4]
    8a78:	785b      	ldrb	r3, [r3, #1]
    8a7a:	461a      	mov	r2, r3
    8a7c:	4b10      	ldr	r3, [pc, #64]	; (8ac0 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    8a7e:	5c9b      	ldrb	r3, [r3, r2]
    8a80:	2b00      	cmp	r3, #0
    8a82:	d018      	beq.n	8ab6 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    8a84:	9b01      	ldr	r3, [sp, #4]
    8a86:	789b      	ldrb	r3, [r3, #2]
    8a88:	4618      	mov	r0, r3
    8a8a:	f002 fe13 	bl	b6b4 <FlexCAN_Ip_DisableInterrupts_Privileged>
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = FALSE;
    8a8e:	9b01      	ldr	r3, [sp, #4]
    8a90:	785b      	ldrb	r3, [r3, #1]
    8a92:	461a      	mov	r2, r3
    8a94:	4b0a      	ldr	r3, [pc, #40]	; (8ac0 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    8a96:	2100      	movs	r1, #0
    8a98:	5499      	strb	r1, [r3, r2]
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    8a9a:	9b01      	ldr	r3, [sp, #4]
    8a9c:	7a5b      	ldrb	r3, [r3, #9]
    8a9e:	f083 0301 	eor.w	r3, r3, #1
    8aa2:	b2db      	uxtb	r3, r3
    8aa4:	2b00      	cmp	r3, #0
    8aa6:	d006      	beq.n	8ab6 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    8aa8:	9b01      	ldr	r3, [sp, #4]
    8aaa:	789b      	ldrb	r3, [r3, #2]
    8aac:	2200      	movs	r2, #0
    8aae:	2104      	movs	r1, #4
    8ab0:	4618      	mov	r0, r3
    8ab2:	f002 fe2b 	bl	b70c <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
}
    8ab6:	bf00      	nop
    8ab8:	b003      	add	sp, #12
    8aba:	f85d fb04 	ldr.w	pc, [sp], #4
    8abe:	bf00      	nop
    8ac0:	1fff8fb4 	.word	0x1fff8fb4

00008ac4 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>:

/**
*   @brief      Enable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    8ac4:	b500      	push	{lr}
    8ac6:	b083      	sub	sp, #12
    8ac8:	9001      	str	r0, [sp, #4]
    /*
    * [SWS_Can_00208]  The function Can_EnableControllerInterrupts shall perform no
    * action when Can_DisableControllerInterrupts has not been called before.
    */
    if (FALSE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    8aca:	9b01      	ldr	r3, [sp, #4]
    8acc:	785b      	ldrb	r3, [r3, #1]
    8ace:	461a      	mov	r2, r3
    8ad0:	4b11      	ldr	r3, [pc, #68]	; (8b18 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    8ad2:	5c9b      	ldrb	r3, [r3, r2]
    8ad4:	f083 0301 	eor.w	r3, r3, #1
    8ad8:	b2db      	uxtb	r3, r3
    8ada:	2b00      	cmp	r3, #0
    8adc:	d018      	beq.n	8b10 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x4c>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    8ade:	9b01      	ldr	r3, [sp, #4]
    8ae0:	789b      	ldrb	r3, [r3, #2]
    8ae2:	4618      	mov	r0, r3
    8ae4:	f002 fdb8 	bl	b658 <FlexCAN_Ip_EnableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    8ae8:	9b01      	ldr	r3, [sp, #4]
    8aea:	7a5b      	ldrb	r3, [r3, #9]
    8aec:	f083 0301 	eor.w	r3, r3, #1
    8af0:	b2db      	uxtb	r3, r3
    8af2:	2b00      	cmp	r3, #0
    8af4:	d006      	beq.n	8b04 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x40>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    8af6:	9b01      	ldr	r3, [sp, #4]
    8af8:	789b      	ldrb	r3, [r3, #2]
    8afa:	2201      	movs	r2, #1
    8afc:	2104      	movs	r1, #4
    8afe:	4618      	mov	r0, r3
    8b00:	f002 fe04 	bl	b70c <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        /* update status */
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    8b04:	9b01      	ldr	r3, [sp, #4]
    8b06:	785b      	ldrb	r3, [r3, #1]
    8b08:	461a      	mov	r2, r3
    8b0a:	4b03      	ldr	r3, [pc, #12]	; (8b18 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    8b0c:	2101      	movs	r1, #1
    8b0e:	5499      	strb	r1, [r3, r2]
    }
}
    8b10:	bf00      	nop
    8b12:	b003      	add	sp, #12
    8b14:	f85d fb04 	ldr.w	pc, [sp], #4
    8b18:	1fff8fb4 	.word	0x1fff8fb4

00008b1c <Can_43_FLEXCAN_Ipw_GetControllerErrorState>:

/**
*   @brief      Get Controller Error State
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerErrorState(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    8b1c:	b500      	push	{lr}
    8b1e:	b085      	sub	sp, #20
    8b20:	9001      	str	r0, [sp, #4]
    8b22:	9100      	str	r1, [sp, #0]
    uint32 Error = 0U;
    8b24:	2300      	movs	r3, #0
    8b26:	9303      	str	r3, [sp, #12]

    Error = FlexCAN_Ip_GetErrorStatus(Can_pControllerConfig->Can_u8ControllerOffset);
    8b28:	9b01      	ldr	r3, [sp, #4]
    8b2a:	789b      	ldrb	r3, [r3, #2]
    8b2c:	4618      	mov	r0, r3
    8b2e:	f001 fe87 	bl	a840 <FlexCAN_Ip_GetErrorStatus>
    8b32:	9003      	str	r0, [sp, #12]

    *pValue = (uint8)((Error & FLEXCAN_ESR1_FLTCONF_MASK)>>FLEXCAN_ESR1_FLTCONF_SHIFT);
    8b34:	9b03      	ldr	r3, [sp, #12]
    8b36:	091b      	lsrs	r3, r3, #4
    8b38:	b2db      	uxtb	r3, r3
    8b3a:	f003 0303 	and.w	r3, r3, #3
    8b3e:	b2da      	uxtb	r2, r3
    8b40:	9b00      	ldr	r3, [sp, #0]
    8b42:	701a      	strb	r2, [r3, #0]
    return E_OK;
    8b44:	2300      	movs	r3, #0
}
    8b46:	4618      	mov	r0, r3
    8b48:	b005      	add	sp, #20
    8b4a:	f85d fb04 	ldr.w	pc, [sp], #4

00008b4e <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>:

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    8b4e:	b500      	push	{lr}
    8b50:	b083      	sub	sp, #12
    8b52:	9001      	str	r0, [sp, #4]
    8b54:	9100      	str	r1, [sp, #0]
     *pValue = FlexCAN_Ip_GetControllerTxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    8b56:	9b01      	ldr	r3, [sp, #4]
    8b58:	789b      	ldrb	r3, [r3, #2]
    8b5a:	4618      	mov	r0, r3
    8b5c:	f001 fe82 	bl	a864 <FlexCAN_Ip_GetControllerTxErrorCounter>
    8b60:	4603      	mov	r3, r0
    8b62:	461a      	mov	r2, r3
    8b64:	9b00      	ldr	r3, [sp, #0]
    8b66:	701a      	strb	r2, [r3, #0]
     return E_OK;
    8b68:	2300      	movs	r3, #0
}
    8b6a:	4618      	mov	r0, r3
    8b6c:	b003      	add	sp, #12
    8b6e:	f85d fb04 	ldr.w	pc, [sp], #4

00008b72 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>:

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    8b72:	b500      	push	{lr}
    8b74:	b083      	sub	sp, #12
    8b76:	9001      	str	r0, [sp, #4]
    8b78:	9100      	str	r1, [sp, #0]

    *pValue = FlexCAN_Ip_GetControllerRxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    8b7a:	9b01      	ldr	r3, [sp, #4]
    8b7c:	789b      	ldrb	r3, [r3, #2]
    8b7e:	4618      	mov	r0, r3
    8b80:	f001 fe82 	bl	a888 <FlexCAN_Ip_GetControllerRxErrorCounter>
    8b84:	4603      	mov	r3, r0
    8b86:	461a      	mov	r2, r3
    8b88:	9b00      	ldr	r3, [sp, #0]
    8b8a:	701a      	strb	r2, [r3, #0]
    return E_OK;
    8b8c:	2300      	movs	r3, #0
}
    8b8e:	4618      	mov	r0, r3
    8b90:	b003      	add	sp, #12
    8b92:	f85d fb04 	ldr.w	pc, [sp], #4

00008b96 <Can_43_FLEXCAN_Ipw_Write>:
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
    const Can_PduType * PduInfo
)
{
    8b96:	b510      	push	{r4, lr}
    8b98:	b08c      	sub	sp, #48	; 0x30
    8b9a:	9005      	str	r0, [sp, #20]
    8b9c:	9104      	str	r1, [sp, #16]
    8b9e:	9203      	str	r2, [sp, #12]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    8ba0:	2301      	movs	r3, #1
    8ba2:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_DataInfoType DataInfo;
    uint8 u8ObjIdx = 0U;
    8ba4:	2300      	movs	r3, #0
    8ba6:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
#if (CAN_43_FLEXCAN_TRIGGER_TRANSMIT_USED == STD_ON)
    PduInfoType CanIf_PduInfo;
    uint8 Data[64U];
#endif

    DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    8baa:	2300      	movs	r3, #0
    8bac:	9306      	str	r3, [sp, #24]
    DataInfo.data_length = 0U;
    8bae:	2300      	movs	r3, #0
    8bb0:	9307      	str	r3, [sp, #28]
    DataInfo.fd_padding = 0U;
    8bb2:	2300      	movs	r3, #0
    8bb4:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    DataInfo.fd_enable = FALSE;
    8bb8:	2300      	movs	r3, #0
    8bba:	f88d 3020 	strb.w	r3, [sp, #32]
    DataInfo.enable_brs = FALSE;
    8bbe:	2300      	movs	r3, #0
    8bc0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    DataInfo.is_remote = FALSE;
    8bc4:	2300      	movs	r3, #0
    8bc6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    DataInfo.is_polling = FALSE;
    8bca:	2300      	movs	r3, #0
    8bcc:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    if (CAN_TX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    8bd0:	9b04      	ldr	r3, [sp, #16]
    8bd2:	699b      	ldr	r3, [r3, #24]
    8bd4:	2b03      	cmp	r3, #3
    8bd6:	d177      	bne.n	8cc8 <Can_43_FLEXCAN_Ipw_Write+0x132>
    {
        DataInfo.msg_id_type = ((PduInfo->id & CAN_43_FLEXCAN_EXTENDED_ID_U32) != 0U) ? FLEXCAN_MSG_ID_EXT : FLEXCAN_MSG_ID_STD;
    8bd8:	9b03      	ldr	r3, [sp, #12]
    8bda:	681b      	ldr	r3, [r3, #0]
    8bdc:	0fdb      	lsrs	r3, r3, #31
    8bde:	9306      	str	r3, [sp, #24]
        if (Can_pHwObjectConfig->Can_u8PayloadLength <=  PduInfo->length)
    8be0:	9b04      	ldr	r3, [sp, #16]
    8be2:	7c1a      	ldrb	r2, [r3, #16]
    8be4:	9b03      	ldr	r3, [sp, #12]
    8be6:	799b      	ldrb	r3, [r3, #6]
    8be8:	429a      	cmp	r2, r3
    8bea:	d803      	bhi.n	8bf4 <Can_43_FLEXCAN_Ipw_Write+0x5e>
        {
            DataInfo.data_length = Can_pHwObjectConfig->Can_u8PayloadLength;
    8bec:	9b04      	ldr	r3, [sp, #16]
    8bee:	7c1b      	ldrb	r3, [r3, #16]
    8bf0:	9307      	str	r3, [sp, #28]
    8bf2:	e002      	b.n	8bfa <Can_43_FLEXCAN_Ipw_Write+0x64>
        }
        else
        {
            DataInfo.data_length = PduInfo->length;
    8bf4:	9b03      	ldr	r3, [sp, #12]
    8bf6:	799b      	ldrb	r3, [r3, #6]
    8bf8:	9307      	str	r3, [sp, #28]
        }
#if (CAN_43_FLEXCAN_FEATURE_HAS_FD == STD_ON)
        DataInfo.fd_padding = Can_pHwObjectConfig->Can_u8PaddingValue;
    8bfa:	9b04      	ldr	r3, [sp, #16]
    8bfc:	7c5b      	ldrb	r3, [r3, #17]
    8bfe:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        DataInfo.fd_enable = ((PduInfo->id & CAN_43_FLEXCAN_FD_FRAME_U32) != 0U) ? TRUE : FALSE;
    8c02:	9b03      	ldr	r3, [sp, #12]
    8c04:	681b      	ldr	r3, [r3, #0]
    8c06:	0f9b      	lsrs	r3, r3, #30
    8c08:	f003 0301 	and.w	r3, r3, #1
    8c0c:	2b00      	cmp	r3, #0
    8c0e:	bf14      	ite	ne
    8c10:	2301      	movne	r3, #1
    8c12:	2300      	moveq	r3, #0
    8c14:	b2db      	uxtb	r3, r3
    8c16:	f88d 3020 	strb.w	r3, [sp, #32]
    #if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
            DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID]].Can_bBitRateSwitch;
    8c1a:	9b05      	ldr	r3, [sp, #20]
    8c1c:	6a1a      	ldr	r2, [r3, #32]
    8c1e:	9b05      	ldr	r3, [sp, #20]
    8c20:	785b      	ldrb	r3, [r3, #1]
    8c22:	4619      	mov	r1, r3
    8c24:	4b31      	ldr	r3, [pc, #196]	; (8cec <Can_43_FLEXCAN_Ipw_Write+0x156>)
    8c26:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    8c2a:	4619      	mov	r1, r3
    8c2c:	2316      	movs	r3, #22
    8c2e:	fb01 f303 	mul.w	r3, r1, r3
    8c32:	4413      	add	r3, r2
    8c34:	781b      	ldrb	r3, [r3, #0]
    8c36:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    #else
        DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bBitRateSwitch;
    #endif
#endif
        DataInfo.is_remote = FALSE;
    8c3a:	2300      	movs	r3, #0
    8c3c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        DataInfo.is_polling = Can_pHwObjectConfig->Can_bHwObjectUsesPolling;
    8c40:	9b04      	ldr	r3, [sp, #16]
    8c42:	7b1b      	ldrb	r3, [r3, #12]
    8c44:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        do
        {
            eRetVal = FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx);
    8c48:	9b05      	ldr	r3, [sp, #20]
    8c4a:	7898      	ldrb	r0, [r3, #2]
    8c4c:	9b04      	ldr	r3, [sp, #16]
    8c4e:	7f1a      	ldrb	r2, [r3, #28]
    8c50:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    8c54:	4413      	add	r3, r2
    8c56:	b2db      	uxtb	r3, r3
    8c58:	4619      	mov	r1, r3
    8c5a:	f001 fcdf 	bl	a61c <FlexCAN_Ip_GetTransferStatus>
    8c5e:	900b      	str	r0, [sp, #44]	; 0x2c
            if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    8c60:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8c62:	2b00      	cmp	r3, #0
    8c64:	d122      	bne.n	8cac <Can_43_FLEXCAN_Ipw_Write+0x116>
            {
                #if ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))
                Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = PduInfo->swPduHandle;
    8c66:	9b05      	ldr	r3, [sp, #20]
    8c68:	785b      	ldrb	r3, [r3, #1]
    8c6a:	461c      	mov	r4, r3
    8c6c:	9b04      	ldr	r3, [sp, #16]
    8c6e:	7f1b      	ldrb	r3, [r3, #28]
    8c70:	461a      	mov	r2, r3
    8c72:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    8c76:	4413      	add	r3, r2
    8c78:	9a03      	ldr	r2, [sp, #12]
    8c7a:	8890      	ldrh	r0, [r2, #4]
    8c7c:	491c      	ldr	r1, [pc, #112]	; (8cf0 <Can_43_FLEXCAN_Ipw_Write+0x15a>)
    8c7e:	0162      	lsls	r2, r4, #5
    8c80:	4413      	add	r3, r2
    8c82:	4602      	mov	r2, r0
    8c84:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                    }
                }
                else
                {
            #endif
                    eRetVal = FlexCAN_Ip_Send(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx, &DataInfo, PduInfo->id, PduInfo->sdu);
    8c88:	9b05      	ldr	r3, [sp, #20]
    8c8a:	7898      	ldrb	r0, [r3, #2]
    8c8c:	9b04      	ldr	r3, [sp, #16]
    8c8e:	7f1a      	ldrb	r2, [r3, #28]
    8c90:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    8c94:	4413      	add	r3, r2
    8c96:	b2d9      	uxtb	r1, r3
    8c98:	9b03      	ldr	r3, [sp, #12]
    8c9a:	681c      	ldr	r4, [r3, #0]
    8c9c:	9b03      	ldr	r3, [sp, #12]
    8c9e:	689b      	ldr	r3, [r3, #8]
    8ca0:	aa06      	add	r2, sp, #24
    8ca2:	9300      	str	r3, [sp, #0]
    8ca4:	4623      	mov	r3, r4
    8ca6:	f001 fa4d 	bl	a144 <FlexCAN_Ip_Send>
    8caa:	900b      	str	r0, [sp, #44]	; 0x2c
                /* Revert to FALSE due to the MB was not transmitted successfully */
                Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = FALSE;
            }
            #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */
            }
            u8ObjIdx++;
    8cac:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    8cb0:	3301      	adds	r3, #1
    8cb2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        } while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (FLEXCAN_STATUS_BUSY == eRetVal));
    8cb6:	9b04      	ldr	r3, [sp, #16]
    8cb8:	7b9b      	ldrb	r3, [r3, #14]
    8cba:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    8cbe:	429a      	cmp	r2, r3
    8cc0:	d202      	bcs.n	8cc8 <Can_43_FLEXCAN_Ipw_Write+0x132>
    8cc2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8cc4:	2b02      	cmp	r3, #2
    8cc6:	d0bf      	beq.n	8c48 <Can_43_FLEXCAN_Ipw_Write+0xb2>
    }

    if ((FLEXCAN_STATUS_SUCCESS != eRetVal) && (FLEXCAN_STATUS_BUSY != eRetVal))
    8cc8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8cca:	2b00      	cmp	r3, #0
    8ccc:	d004      	beq.n	8cd8 <Can_43_FLEXCAN_Ipw_Write+0x142>
    8cce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8cd0:	2b02      	cmp	r3, #2
    8cd2:	d001      	beq.n	8cd8 <Can_43_FLEXCAN_Ipw_Write+0x142>
    {
        eRetVal = FLEXCAN_STATUS_ERROR;
    8cd4:	2301      	movs	r3, #1
    8cd6:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    return ((FLEXCAN_STATUS_BUSY == eRetVal) ? ((Std_ReturnType)CAN_BUSY) : ((Std_ReturnType)eRetVal));
    8cd8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8cda:	2b02      	cmp	r3, #2
    8cdc:	d002      	beq.n	8ce4 <Can_43_FLEXCAN_Ipw_Write+0x14e>
    8cde:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8ce0:	b2db      	uxtb	r3, r3
    8ce2:	e000      	b.n	8ce6 <Can_43_FLEXCAN_Ipw_Write+0x150>
    8ce4:	2302      	movs	r3, #2
}
    8ce6:	4618      	mov	r0, r3
    8ce8:	b00c      	add	sp, #48	; 0x30
    8cea:	bd10      	pop	{r4, pc}
    8cec:	1fff8fb0 	.word	0x1fff8fb0
    8cf0:	1fff8f30 	.word	0x1fff8f30

00008cf4 <Can_Ipw_InitRx>:

static void Can_Ipw_InitRx(const Can_43_FLEXCAN_ControllerConfigType * Can_pController)
{
    8cf4:	b500      	push	{lr}
    8cf6:	b089      	sub	sp, #36	; 0x24
    8cf8:	9001      	str	r0, [sp, #4]
    uint8 u8HwObjRefIdx = 0U;
    8cfa:	2300      	movs	r3, #0
    8cfc:	f88d 301f 	strb.w	r3, [sp, #31]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    Flexcan_Ip_DataInfoType DataInfo;

    /* This function just is called only if controller is in freeze mode */
    /* Always enable individual mask , Already in freeze mode */
    (void)FlexCAN_Ip_SetRxMaskType(Can_pController->Can_u8ControllerOffset, FLEXCAN_RX_MASK_INDIVIDUAL);
    8d00:	9b01      	ldr	r3, [sp, #4]
    8d02:	789b      	ldrb	r3, [r3, #2]
    8d04:	2101      	movs	r1, #1
    8d06:	4618      	mov	r0, r3
    8d08:	f002 fa42 	bl	b190 <FlexCAN_Ip_SetRxMaskType_Privileged>

    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    8d0c:	2300      	movs	r3, #0
    8d0e:	f88d 301f 	strb.w	r3, [sp, #31]
    8d12:	e03a      	b.n	8d8a <Can_Ipw_InitRx+0x96>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pController->Can_ppHwObject[u8HwObjRefIdx];
    8d14:	9b01      	ldr	r3, [sp, #4]
    8d16:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    8d18:	f89d 301f 	ldrb.w	r3, [sp, #31]
    8d1c:	009b      	lsls	r3, r3, #2
    8d1e:	4413      	add	r3, r2
    8d20:	681b      	ldr	r3, [r3, #0]
    8d22:	9306      	str	r3, [sp, #24]

        if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    8d24:	9b06      	ldr	r3, [sp, #24]
    8d26:	699b      	ldr	r3, [r3, #24]
    8d28:	2b00      	cmp	r3, #0
    8d2a:	d121      	bne.n	8d70 <Can_Ipw_InitRx+0x7c>
        {
            DataInfo.fd_enable = FALSE;
    8d2c:	2300      	movs	r3, #0
    8d2e:	f88d 3010 	strb.w	r3, [sp, #16]
            DataInfo.data_length = 0U;
    8d32:	2300      	movs	r3, #0
    8d34:	9303      	str	r3, [sp, #12]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    8d36:	9b06      	ldr	r3, [sp, #24]
    8d38:	689b      	ldr	r3, [r3, #8]
    8d3a:	2b00      	cmp	r3, #0
    8d3c:	d002      	beq.n	8d44 <Can_Ipw_InitRx+0x50>
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_EXT;
    8d3e:	2301      	movs	r3, #1
    8d40:	9302      	str	r3, [sp, #8]
    8d42:	e001      	b.n	8d48 <Can_Ipw_InitRx+0x54>
            }
            else
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    8d44:	2300      	movs	r3, #0
    8d46:	9302      	str	r3, [sp, #8]
            }
            (void)FlexCAN_Ip_ConfigRxMb(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, &DataInfo, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterCode);
    8d48:	9b01      	ldr	r3, [sp, #4]
    8d4a:	7898      	ldrb	r0, [r3, #2]
    8d4c:	9b06      	ldr	r3, [sp, #24]
    8d4e:	7f19      	ldrb	r1, [r3, #28]
    8d50:	9b06      	ldr	r3, [sp, #24]
    8d52:	695b      	ldr	r3, [r3, #20]
    8d54:	681b      	ldr	r3, [r3, #0]
    8d56:	aa02      	add	r2, sp, #8
    8d58:	f001 fa40 	bl	a1dc <FlexCAN_Ip_ConfigRxMb>
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterMask);
    8d5c:	9b01      	ldr	r3, [sp, #4]
    8d5e:	7898      	ldrb	r0, [r3, #2]
    8d60:	9b06      	ldr	r3, [sp, #24]
    8d62:	7f19      	ldrb	r1, [r3, #28]
    8d64:	9b06      	ldr	r3, [sp, #24]
    8d66:	695b      	ldr	r3, [r3, #20]
    8d68:	685b      	ldr	r3, [r3, #4]
    8d6a:	461a      	mov	r2, r3
    8d6c:	f001 ffc8 	bl	ad00 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
        }

        if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    8d70:	9b06      	ldr	r3, [sp, #24]
    8d72:	699b      	ldr	r3, [r3, #24]
    8d74:	2b01      	cmp	r3, #1
    8d76:	d103      	bne.n	8d80 <Can_Ipw_InitRx+0x8c>
        {
            Can_Ipw_InitLegacyFifoFilter(Can_pController, Can_pHwObject);
    8d78:	9906      	ldr	r1, [sp, #24]
    8d7a:	9801      	ldr	r0, [sp, #4]
    8d7c:	f7fe ffab 	bl	7cd6 <Can_Ipw_InitLegacyFifoFilter>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    8d80:	f89d 301f 	ldrb.w	r3, [sp, #31]
    8d84:	3301      	adds	r3, #1
    8d86:	f88d 301f 	strb.w	r3, [sp, #31]
    8d8a:	9b01      	ldr	r3, [sp, #4]
    8d8c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    8d90:	f89d 201f 	ldrb.w	r2, [sp, #31]
    8d94:	429a      	cmp	r2, r3
    8d96:	d3bd      	bcc.n	8d14 <Can_Ipw_InitRx+0x20>
        }
    }
}
    8d98:	bf00      	nop
    8d9a:	bf00      	nop
    8d9c:	b009      	add	sp, #36	; 0x24
    8d9e:	f85d fb04 	ldr.w	pc, [sp], #4

00008da2 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>:
void Can_43_FLEXCAN_Ipw_MainFunction_Mode
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    Can_ControllerStateType * Can_pControllerState
)
{
    8da2:	b500      	push	{lr}
    8da4:	b083      	sub	sp, #12
    8da6:	9001      	str	r0, [sp, #4]
    8da8:	9100      	str	r1, [sp, #0]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    if (CAN_CS_STARTED == *Can_pControllerState)
    8daa:	9b00      	ldr	r3, [sp, #0]
    8dac:	681b      	ldr	r3, [r3, #0]
    8dae:	2b01      	cmp	r3, #1
    8db0:	d114      	bne.n	8ddc <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x3a>
    {
        if (FALSE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    8db2:	9b01      	ldr	r3, [sp, #4]
    8db4:	789b      	ldrb	r3, [r3, #2]
    8db6:	4618      	mov	r0, r3
    8db8:	f002 f994 	bl	b0e4 <FlexCAN_Ip_GetStartMode_Privileged>
    8dbc:	4603      	mov	r3, r0
    8dbe:	f083 0301 	eor.w	r3, r3, #1
    8dc2:	b2db      	uxtb	r3, r3
    8dc4:	2b00      	cmp	r3, #0
    8dc6:	d01e      	beq.n	8e06 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        {
            *Can_pControllerState = CAN_CS_STOPPED;
    8dc8:	9b00      	ldr	r3, [sp, #0]
    8dca:	2202      	movs	r2, #2
    8dcc:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STOPPED);
    8dce:	9b01      	ldr	r3, [sp, #4]
    8dd0:	781b      	ldrb	r3, [r3, #0]
    8dd2:	2102      	movs	r1, #2
    8dd4:	4618      	mov	r0, r3
    8dd6:	f006 fe1f 	bl	fa18 <CanIf_ControllerModeIndication>
    }
    else
    {
        /* nothing to do */
    }
}
    8dda:	e014      	b.n	8e06 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
    else if (CAN_CS_STOPPED == *Can_pControllerState)
    8ddc:	9b00      	ldr	r3, [sp, #0]
    8dde:	681b      	ldr	r3, [r3, #0]
    8de0:	2b02      	cmp	r3, #2
    8de2:	d110      	bne.n	8e06 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        if (TRUE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    8de4:	9b01      	ldr	r3, [sp, #4]
    8de6:	789b      	ldrb	r3, [r3, #2]
    8de8:	4618      	mov	r0, r3
    8dea:	f002 f97b 	bl	b0e4 <FlexCAN_Ip_GetStartMode_Privileged>
    8dee:	4603      	mov	r3, r0
    8df0:	2b00      	cmp	r3, #0
    8df2:	d008      	beq.n	8e06 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
            *Can_pControllerState = CAN_CS_STARTED;
    8df4:	9b00      	ldr	r3, [sp, #0]
    8df6:	2201      	movs	r2, #1
    8df8:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STARTED);
    8dfa:	9b01      	ldr	r3, [sp, #4]
    8dfc:	781b      	ldrb	r3, [r3, #0]
    8dfe:	2101      	movs	r1, #1
    8e00:	4618      	mov	r0, r3
    8e02:	f006 fe09 	bl	fa18 <CanIf_ControllerModeIndication>
}
    8e06:	bf00      	nop
    8e08:	b003      	add	sp, #12
    8e0a:	f85d fb04 	ldr.w	pc, [sp], #4

00008e0e <Can_43_FLEXCAN_Ipw_ProcessHwObject>:
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_ConfigType * Can_pConfig,
        uint8 u8MbIdx,
        Can_43_FLEXCAN_MbType mbType
    )
    {
    8e0e:	b500      	push	{lr}
    8e10:	b085      	sub	sp, #20
    8e12:	9003      	str	r0, [sp, #12]
    8e14:	9102      	str	r1, [sp, #8]
    8e16:	9300      	str	r3, [sp, #0]
    8e18:	4613      	mov	r3, r2
    8e1a:	f88d 3007 	strb.w	r3, [sp, #7]
        switch (mbType)
    8e1e:	9b00      	ldr	r3, [sp, #0]
    8e20:	2b03      	cmp	r3, #3
    8e22:	d009      	beq.n	8e38 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x2a>
    8e24:	9b00      	ldr	r3, [sp, #0]
    8e26:	2b03      	cmp	r3, #3
    8e28:	d821      	bhi.n	8e6e <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
    8e2a:	9b00      	ldr	r3, [sp, #0]
    8e2c:	2b00      	cmp	r3, #0
    8e2e:	d00c      	beq.n	8e4a <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x3c>
    8e30:	9b00      	ldr	r3, [sp, #0]
    8e32:	2b01      	cmp	r3, #1
    8e34:	d012      	beq.n	8e5c <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x4e>
                break;
            }
            default:
            {
                /* prevent misra */
                break;
    8e36:	e01a      	b.n	8e6e <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
                Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    8e38:	9b02      	ldr	r3, [sp, #8]
    8e3a:	691b      	ldr	r3, [r3, #16]
    8e3c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    8e40:	4619      	mov	r1, r3
    8e42:	9803      	ldr	r0, [sp, #12]
    8e44:	f7ff fa24 	bl	8290 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>
                break;
    8e48:	e012      	b.n	8e70 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    8e4a:	9b02      	ldr	r3, [sp, #8]
    8e4c:	691b      	ldr	r3, [r3, #16]
    8e4e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    8e52:	4619      	mov	r1, r3
    8e54:	9803      	ldr	r0, [sp, #12]
    8e56:	f7ff fa67 	bl	8328 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    8e5a:	e009      	b.n	8e70 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                    Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    8e5c:	9b02      	ldr	r3, [sp, #8]
    8e5e:	691b      	ldr	r3, [r3, #16]
    8e60:	f89d 2007 	ldrb.w	r2, [sp, #7]
    8e64:	4619      	mov	r1, r3
    8e66:	9803      	ldr	r0, [sp, #12]
    8e68:	f7ff fa5e 	bl	8328 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    8e6c:	e000      	b.n	8e70 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                break;
    8e6e:	bf00      	nop
            }
        }
    }
    8e70:	bf00      	nop
    8e72:	b005      	add	sp, #20
    8e74:	f85d fb04 	ldr.w	pc, [sp], #4

00008e78 <Can_43_FLEXCAN_CommonIrqCallback>:
void Can_43_FLEXCAN_CommonIrqCallback(uint8 u8Instance,
                           Flexcan_Ip_EventType event,
                           uint32 u32buffIdx,
                           const Flexcan_Ip_StateType *driverState
                          )
{
    8e78:	b500      	push	{lr}
    8e7a:	b085      	sub	sp, #20
    8e7c:	9102      	str	r1, [sp, #8]
    8e7e:	9201      	str	r2, [sp, #4]
    8e80:	9300      	str	r3, [sp, #0]
    8e82:	4603      	mov	r3, r0
    8e84:	f88d 300f 	strb.w	r3, [sp, #15]
    else
    {
#endif /* CAN_43_FLEXCAN_FEATURE_HAS_ENHANCED_RX_FIFO */
    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        /* This callback is just used for interrupt buffter */
        if (FALSE == (driverState->mbs[u32buffIdx].isPolling))
    8e88:	9a00      	ldr	r2, [sp, #0]
    8e8a:	9b01      	ldr	r3, [sp, #4]
    8e8c:	011b      	lsls	r3, r3, #4
    8e8e:	4413      	add	r3, r2
    8e90:	3308      	adds	r3, #8
    8e92:	781b      	ldrb	r3, [r3, #0]
    8e94:	f083 0301 	eor.w	r3, r3, #1
    8e98:	b2db      	uxtb	r3, r3
    8e9a:	2b00      	cmp	r3, #0
    8e9c:	d03b      	beq.n	8f16 <Can_43_FLEXCAN_CommonIrqCallback+0x9e>
    8e9e:	9b02      	ldr	r3, [sp, #8]
    8ea0:	2b04      	cmp	r3, #4
    8ea2:	d83a      	bhi.n	8f1a <Can_43_FLEXCAN_CommonIrqCallback+0xa2>
    8ea4:	a201      	add	r2, pc, #4	; (adr r2, 8eac <Can_43_FLEXCAN_CommonIrqCallback+0x34>)
    8ea6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8eaa:	bf00      	nop
    8eac:	00008ed3 	.word	0x00008ed3
    8eb0:	00008ee5 	.word	0x00008ee5
    8eb4:	00008ef7 	.word	0x00008ef7
    8eb8:	00008f07 	.word	0x00008f07
    8ebc:	00008ec1 	.word	0x00008ec1
        {
            switch (event)
            {
                case FLEXCAN_EVENT_TX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_TX_NORMAL);
    8ec0:	9b01      	ldr	r3, [sp, #4]
    8ec2:	b2d9      	uxtb	r1, r3
    8ec4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8ec8:	2203      	movs	r2, #3
    8eca:	4618      	mov	r0, r3
    8ecc:	f7fe fe1e 	bl	7b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    8ed0:	e024      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_NORMAL);
    8ed2:	9b01      	ldr	r3, [sp, #4]
    8ed4:	b2d9      	uxtb	r1, r3
    8ed6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8eda:	2200      	movs	r2, #0
    8edc:	4618      	mov	r0, r3
    8ede:	f7fe fe15 	bl	7b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    8ee2:	e01b      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_LEGACY_FIFO);
    8ee4:	9b01      	ldr	r3, [sp, #4]
    8ee6:	b2d9      	uxtb	r1, r3
    8ee8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8eec:	2201      	movs	r2, #1
    8eee:	4618      	mov	r0, r3
    8ef0:	f7fe fe0c 	bl	7b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    8ef4:	e012      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_WARNING:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 6U, CAN_RX_LEGACY_FIFO);
    8ef6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8efa:	2201      	movs	r2, #1
    8efc:	2106      	movs	r1, #6
    8efe:	4618      	mov	r0, r3
    8f00:	f7fe fe04 	bl	7b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    8f04:	e00a      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_OVERFLOW:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 7U, CAN_RX_LEGACY_FIFO);
    8f06:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8f0a:	2201      	movs	r2, #1
    8f0c:	2107      	movs	r1, #7
    8f0e:	4618      	mov	r0, r3
    8f10:	f7fe fdfc 	bl	7b0c <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    8f14:	e002      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                {
                    /* nothing to do */
                    break;
                }
            }
        }
    8f16:	bf00      	nop
    8f18:	e000      	b.n	8f1c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                    break;
    8f1a:	bf00      	nop
        Can_43_FLEXCAN_ProcessPNInterrupt(u8Instance);
    }
#endif /* (CAN_43_FLEXCAN_FEATURE_HAS_PRETENDED_NETWORKING == STD_ON) */
    (void)u32buffIdx;
    (void)driverState;
}
    8f1c:	bf00      	nop
    8f1e:	b005      	add	sp, #20
    8f20:	f85d fb04 	ldr.w	pc, [sp], #4

00008f24 <Can_43_FLEXCAN_ErrorIrqCallback>:
void Can_43_FLEXCAN_ErrorIrqCallback(uint8 u8Instance,
                          Flexcan_Ip_EventType event,
                          uint32 u32ErrStatus,
                          const Flexcan_Ip_StateType *driverState
                         )
{
    8f24:	b500      	push	{lr}
    8f26:	b085      	sub	sp, #20
    8f28:	9102      	str	r1, [sp, #8]
    8f2a:	9201      	str	r2, [sp, #4]
    8f2c:	9300      	str	r3, [sp, #0]
    8f2e:	4603      	mov	r3, r0
    8f30:	f88d 300f 	strb.w	r3, [sp, #15]
    (void) driverState; /* not used yet */
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON)
    (void) u32ErrStatus; /* prevent compiler warning */
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON) */

    switch (event)
    8f34:	9b02      	ldr	r3, [sp, #8]
    8f36:	2b07      	cmp	r3, #7
    8f38:	d105      	bne.n	8f46 <Can_43_FLEXCAN_ErrorIrqCallback+0x22>
        }
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON) */
        /* this function is called for both interrupt & polling */
        case FLEXCAN_EVENT_BUSOFF:
        {
            Can_43_FLEXCAN_ProcessBusOffInterrupt(u8Instance);
    8f3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8f3e:	4618      	mov	r0, r3
    8f40:	f7fe fe26 	bl	7b90 <Can_43_FLEXCAN_ProcessBusOffInterrupt>
            break;
    8f44:	e000      	b.n	8f48 <Can_43_FLEXCAN_ErrorIrqCallback+0x24>
        }
        default:
        {
            /* nothing to do */
            break;
    8f46:	bf00      	nop
        }
    }
}
    8f48:	bf00      	nop
    8f4a:	b005      	add	sp, #20
    8f4c:	f85d fb04 	ldr.w	pc, [sp], #4

00008f50 <FlexCAN_SetRxFifoGlobalMask>:
 *
 * @param[in]   base  The FlexCAN base address
 * @param[in]   Mask     Sets mask
 */
static inline void FlexCAN_SetRxFifoGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    8f50:	b082      	sub	sp, #8
    8f52:	9001      	str	r0, [sp, #4]
    8f54:	9100      	str	r1, [sp, #0]
    (base->RXFGMASK) = Mask;
    8f56:	9b01      	ldr	r3, [sp, #4]
    8f58:	9a00      	ldr	r2, [sp, #0]
    8f5a:	649a      	str	r2, [r3, #72]	; 0x48
}
    8f5c:	bf00      	nop
    8f5e:	b002      	add	sp, #8
    8f60:	4770      	bx	lr

00008f62 <FlexCAN_SetTDCOffset>:
 */
static inline void FlexCAN_SetTDCOffset(FLEXCAN_Type * base,
                                        boolean enable,
                                        uint8 offset
                                       )
{
    8f62:	b084      	sub	sp, #16
    8f64:	9001      	str	r0, [sp, #4]
    8f66:	460b      	mov	r3, r1
    8f68:	f88d 3003 	strb.w	r3, [sp, #3]
    8f6c:	4613      	mov	r3, r2
    8f6e:	f88d 3002 	strb.w	r3, [sp, #2]
    uint32 tmp;

    tmp = base->FDCTRL;
    8f72:	9b01      	ldr	r3, [sp, #4]
    8f74:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    8f78:	9303      	str	r3, [sp, #12]
    tmp &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    8f7a:	9b03      	ldr	r3, [sp, #12]
    8f7c:	f423 431f 	bic.w	r3, r3, #40704	; 0x9f00
    8f80:	9303      	str	r3, [sp, #12]

    if (enable)
    8f82:	f89d 3003 	ldrb.w	r3, [sp, #3]
    8f86:	2b00      	cmp	r3, #0
    8f88:	d00b      	beq.n	8fa2 <FlexCAN_SetTDCOffset+0x40>
    {
        tmp = tmp | FLEXCAN_FDCTRL_TDCEN_MASK;
    8f8a:	9b03      	ldr	r3, [sp, #12]
    8f8c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    8f90:	9303      	str	r3, [sp, #12]
        tmp = tmp | FLEXCAN_FDCTRL_TDCOFF(offset);
    8f92:	f89d 3002 	ldrb.w	r3, [sp, #2]
    8f96:	021b      	lsls	r3, r3, #8
    8f98:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    8f9c:	9a03      	ldr	r2, [sp, #12]
    8f9e:	4313      	orrs	r3, r2
    8fa0:	9303      	str	r3, [sp, #12]
    }

    base->FDCTRL = tmp;
    8fa2:	9b01      	ldr	r3, [sp, #4]
    8fa4:	9a03      	ldr	r2, [sp, #12]
    8fa6:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    8faa:	bf00      	nop
    8fac:	b004      	add	sp, #16
    8fae:	4770      	bx	lr

00008fb0 <FlexCAN_IsEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsEnabled(const FLEXCAN_Type * pBase)
{
    8fb0:	b082      	sub	sp, #8
    8fb2:	9001      	str	r0, [sp, #4]
    return (((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U) ? FALSE : TRUE;
    8fb4:	9b01      	ldr	r3, [sp, #4]
    8fb6:	681b      	ldr	r3, [r3, #0]
    8fb8:	43db      	mvns	r3, r3
    8fba:	0fdb      	lsrs	r3, r3, #31
    8fbc:	b2db      	uxtb	r3, r3
}
    8fbe:	4618      	mov	r0, r3
    8fc0:	b002      	add	sp, #8
    8fc2:	4770      	bx	lr

00008fc4 <FlexCAN_SetFDEnabled>:
 */
static inline void FlexCAN_SetFDEnabled(FLEXCAN_Type * base,
                                        boolean enableFD,
                                        boolean enableBRS
                                       )
{
    8fc4:	b082      	sub	sp, #8
    8fc6:	9001      	str	r0, [sp, #4]
    8fc8:	460b      	mov	r3, r1
    8fca:	f88d 3003 	strb.w	r3, [sp, #3]
    8fce:	4613      	mov	r3, r2
    8fd0:	f88d 3002 	strb.w	r3, [sp, #2]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FDEN_MASK) | FLEXCAN_MCR_FDEN(enableFD ? 1UL : 0UL);
    8fd4:	9b01      	ldr	r3, [sp, #4]
    8fd6:	681b      	ldr	r3, [r3, #0]
    8fd8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    8fdc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8fe0:	2a00      	cmp	r2, #0
    8fe2:	d002      	beq.n	8fea <FlexCAN_SetFDEnabled+0x26>
    8fe4:	f44f 6200 	mov.w	r2, #2048	; 0x800
    8fe8:	e000      	b.n	8fec <FlexCAN_SetFDEnabled+0x28>
    8fea:	2200      	movs	r2, #0
    8fec:	431a      	orrs	r2, r3
    8fee:	9b01      	ldr	r3, [sp, #4]
    8ff0:	601a      	str	r2, [r3, #0]

    /* Enable BitRate Switch support from BRS_TX_MB field or ignore it */
    base->FDCTRL = (base->FDCTRL & ~FLEXCAN_FDCTRL_FDRATE_MASK) | FLEXCAN_FDCTRL_FDRATE(enableBRS ? 1UL : 0UL);
    8ff2:	9b01      	ldr	r3, [sp, #4]
    8ff4:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    8ff8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    8ffc:	f89d 2002 	ldrb.w	r2, [sp, #2]
    9000:	2a00      	cmp	r2, #0
    9002:	d002      	beq.n	900a <FlexCAN_SetFDEnabled+0x46>
    9004:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    9008:	e000      	b.n	900c <FlexCAN_SetFDEnabled+0x48>
    900a:	2200      	movs	r2, #0
    900c:	431a      	orrs	r2, r3
    900e:	9b01      	ldr	r3, [sp, #4]
    9010:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00

    /* Disable Transmission Delay Compensation by default */
    base->FDCTRL &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    9014:	9b01      	ldr	r3, [sp, #4]
    9016:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    901a:	f423 421f 	bic.w	r2, r3, #40704	; 0x9f00
    901e:	9b01      	ldr	r3, [sp, #4]
    9020:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    9024:	bf00      	nop
    9026:	b002      	add	sp, #8
    9028:	4770      	bx	lr

0000902a <FlexCAN_SetListenOnlyMode>:
 *
 * @param   base    The FlexCAN base address
 * @param   enable  TRUE to enable; FALSE to disable
 */
static inline void FlexCAN_SetListenOnlyMode(FLEXCAN_Type * base, boolean enableListenOnly)
{
    902a:	b082      	sub	sp, #8
    902c:	9001      	str	r0, [sp, #4]
    902e:	460b      	mov	r3, r1
    9030:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(enableListenOnly ? 1UL : 0UL);
    9034:	9b01      	ldr	r3, [sp, #4]
    9036:	685b      	ldr	r3, [r3, #4]
    9038:	f023 0308 	bic.w	r3, r3, #8
    903c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9040:	2a00      	cmp	r2, #0
    9042:	d001      	beq.n	9048 <FlexCAN_SetListenOnlyMode+0x1e>
    9044:	2208      	movs	r2, #8
    9046:	e000      	b.n	904a <FlexCAN_SetListenOnlyMode+0x20>
    9048:	2200      	movs	r2, #0
    904a:	431a      	orrs	r2, r3
    904c:	9b01      	ldr	r3, [sp, #4]
    904e:	605a      	str	r2, [r3, #4]
}
    9050:	bf00      	nop
    9052:	b002      	add	sp, #8
    9054:	4770      	bx	lr

00009056 <FlexCAN_UnlockRxMsgBuff>:
 * @brief Unlocks the FlexCAN Rx message buffer.
 *
 * @param   base     The FlexCAN base address
 */
static inline void FlexCAN_UnlockRxMsgBuff(const FLEXCAN_Type * base)
{
    9056:	b082      	sub	sp, #8
    9058:	9001      	str	r0, [sp, #4]
    /* Unlock the mailbox by reading the free running timer */
    (void)base->TIMER;
    905a:	9b01      	ldr	r3, [sp, #4]
    905c:	689b      	ldr	r3, [r3, #8]
}
    905e:	bf00      	nop
    9060:	b002      	add	sp, #8
    9062:	4770      	bx	lr

00009064 <FlexCAN_ClearMsgBuffIntStatusFlag>:
 *
 * @param   base        The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 */
static inline void FlexCAN_ClearMsgBuffIntStatusFlag(FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    9064:	b084      	sub	sp, #16
    9066:	9001      	str	r0, [sp, #4]
    9068:	9100      	str	r1, [sp, #0]
    uint32 flag = ((uint32)1U << (msgBuffIdx % 32U));
    906a:	9b00      	ldr	r3, [sp, #0]
    906c:	f003 031f 	and.w	r3, r3, #31
    9070:	2201      	movs	r2, #1
    9072:	fa02 f303 	lsl.w	r3, r2, r3
    9076:	9303      	str	r3, [sp, #12]

    /* Clear the corresponding message buffer interrupt flag*/
    if (msgBuffIdx < 32U)
    9078:	9b00      	ldr	r3, [sp, #0]
    907a:	2b1f      	cmp	r3, #31
    907c:	d802      	bhi.n	9084 <FlexCAN_ClearMsgBuffIntStatusFlag+0x20>
    {
        (base->IFLAG1) = (flag);
    907e:	9b01      	ldr	r3, [sp, #4]
    9080:	9a03      	ldr	r2, [sp, #12]
    9082:	631a      	str	r2, [r3, #48]	; 0x30
    else
    {
        (base->IFLAG4) = (flag);
    }
#endif
}
    9084:	bf00      	nop
    9086:	b004      	add	sp, #16
    9088:	4770      	bx	lr

0000908a <FlexCAN_GetBuffStatusFlag>:
 * @param   base                The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 * @return  flag        The value of interrupt flag of the message buffer.
 */
static inline uint8 FlexCAN_GetBuffStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    908a:	b084      	sub	sp, #16
    908c:	9001      	str	r0, [sp, #4]
    908e:	9100      	str	r1, [sp, #0]
    uint32 flag = 0U;
    9090:	2300      	movs	r3, #0
    9092:	9303      	str	r3, [sp, #12]

    if (msgBuffIdx < 32U)
    9094:	9b00      	ldr	r3, [sp, #0]
    9096:	2b1f      	cmp	r3, #31
    9098:	d80e      	bhi.n	90b8 <FlexCAN_GetBuffStatusFlag+0x2e>
    {
        flag = ((base->IFLAG1 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    909a:	9b01      	ldr	r3, [sp, #4]
    909c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    909e:	9b00      	ldr	r3, [sp, #0]
    90a0:	f003 031f 	and.w	r3, r3, #31
    90a4:	2101      	movs	r1, #1
    90a6:	fa01 f303 	lsl.w	r3, r1, r3
    90aa:	401a      	ands	r2, r3
    90ac:	9b00      	ldr	r3, [sp, #0]
    90ae:	f003 031f 	and.w	r3, r3, #31
    90b2:	fa22 f303 	lsr.w	r3, r2, r3
    90b6:	9303      	str	r3, [sp, #12]
    {
        flag = ((base->IFLAG4 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    }
#endif

    return (uint8)flag;
    90b8:	9b03      	ldr	r3, [sp, #12]
    90ba:	b2db      	uxtb	r3, r3
}
    90bc:	4618      	mov	r0, r3
    90be:	b004      	add	sp, #16
    90c0:	4770      	bx	lr

000090c2 <FlexCAN_SetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetFDTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    90c2:	b082      	sub	sp, #8
    90c4:	9001      	str	r0, [sp, #4]
    90c6:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* Set FlexCAN time segments*/
    (base->FDCBT) = ((base->FDCBT) & ~((FLEXCAN_FDCBT_FPROPSEG_MASK | FLEXCAN_FDCBT_FPSEG2_MASK |
    90c8:	9b01      	ldr	r3, [sp, #4]
    90ca:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    90ce:	4b15      	ldr	r3, [pc, #84]	; (9124 <FlexCAN_SetFDTimeSegments+0x62>)
    90d0:	4013      	ands	r3, r2
    90d2:	9a01      	ldr	r2, [sp, #4]
    90d4:	f8c2 3c04 	str.w	r3, [r2, #3076]	; 0xc04
                                        FLEXCAN_FDCBT_FPSEG1_MASK | FLEXCAN_FDCBT_FPRESDIV_MASK
                                       ) | FLEXCAN_FDCBT_FRJW_MASK
                                      )
                    );

    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    90d8:	9b01      	ldr	r3, [sp, #4]
    90da:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    90de:	9b00      	ldr	r3, [sp, #0]
    90e0:	681b      	ldr	r3, [r3, #0]
    90e2:	029b      	lsls	r3, r3, #10
    90e4:	f403 41f8 	and.w	r1, r3, #31744	; 0x7c00
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    90e8:	9b00      	ldr	r3, [sp, #0]
    90ea:	689b      	ldr	r3, [r3, #8]
    90ec:	f003 0307 	and.w	r3, r3, #7
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    90f0:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    90f2:	9b00      	ldr	r3, [sp, #0]
    90f4:	685b      	ldr	r3, [r3, #4]
    90f6:	015b      	lsls	r3, r3, #5
    90f8:	b2db      	uxtb	r3, r3
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    90fa:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    90fc:	9b00      	ldr	r3, [sp, #0]
    90fe:	68db      	ldr	r3, [r3, #12]
    9100:	0518      	lsls	r0, r3, #20
    9102:	4b09      	ldr	r3, [pc, #36]	; (9128 <FlexCAN_SetFDTimeSegments+0x66>)
    9104:	4003      	ands	r3, r0
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    9106:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FRJW(timeSeg->rJumpwidth)
    9108:	9b00      	ldr	r3, [sp, #0]
    910a:	691b      	ldr	r3, [r3, #16]
    910c:	041b      	lsls	r3, r3, #16
    910e:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    9112:	430b      	orrs	r3, r1
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    9114:	431a      	orrs	r2, r3
    9116:	9b01      	ldr	r3, [sp, #4]
    9118:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
                                     )
                    );
}
    911c:	bf00      	nop
    911e:	b002      	add	sp, #8
    9120:	4770      	bx	lr
    9122:	bf00      	nop
    9124:	c0088318 	.word	0xc0088318
    9128:	3ff00000 	.word	0x3ff00000

0000912c <FlexCAN_SetTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    912c:	b082      	sub	sp, #8
    912e:	9001      	str	r0, [sp, #4]
    9130:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    (base->CTRL1) = ((base->CTRL1) & ~((FLEXCAN_CTRL1_PROPSEG_MASK | FLEXCAN_CTRL1_PSEG2_MASK |
    9132:	9b01      	ldr	r3, [sp, #4]
    9134:	685a      	ldr	r2, [r3, #4]
    9136:	f64f 73f8 	movw	r3, #65528	; 0xfff8
    913a:	4013      	ands	r3, r2
    913c:	9a01      	ldr	r2, [sp, #4]
    913e:	6053      	str	r3, [r2, #4]
                                        FLEXCAN_CTRL1_PSEG1_MASK | FLEXCAN_CTRL1_PRESDIV_MASK
                                       ) | FLEXCAN_CTRL1_RJW_MASK
                                      )
                    );

    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9140:	9b01      	ldr	r3, [sp, #4]
    9142:	685a      	ldr	r2, [r3, #4]
    9144:	9b00      	ldr	r3, [sp, #0]
    9146:	681b      	ldr	r3, [r3, #0]
    9148:	f003 0107 	and.w	r1, r3, #7
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    914c:	9b00      	ldr	r3, [sp, #0]
    914e:	689b      	ldr	r3, [r3, #8]
    9150:	041b      	lsls	r3, r3, #16
    9152:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9156:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    9158:	9b00      	ldr	r3, [sp, #0]
    915a:	685b      	ldr	r3, [r3, #4]
    915c:	04db      	lsls	r3, r3, #19
    915e:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    9162:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    9164:	9b00      	ldr	r3, [sp, #0]
    9166:	68db      	ldr	r3, [r3, #12]
    9168:	061b      	lsls	r3, r3, #24
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    916a:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_RJW(timeSeg->rJumpwidth)
    916c:	9b00      	ldr	r3, [sp, #0]
    916e:	691b      	ldr	r3, [r3, #16]
    9170:	059b      	lsls	r3, r3, #22
    9172:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    9176:	430b      	orrs	r3, r1
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9178:	431a      	orrs	r2, r3
    917a:	9b01      	ldr	r3, [sp, #4]
    917c:	605a      	str	r2, [r3, #4]
                                     )
                    );
}
    917e:	bf00      	nop
    9180:	b002      	add	sp, #8
    9182:	4770      	bx	lr

00009184 <FlexCAN_SetExtendedTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetExtendedTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9184:	b082      	sub	sp, #8
    9186:	9001      	str	r0, [sp, #4]
    9188:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* If extended bit time definitions are enabled, use CBT register */
    (base->CBT) = ((base->CBT) & ~((FLEXCAN_CBT_EPROPSEG_MASK | FLEXCAN_CBT_EPSEG2_MASK |
    918a:	9b01      	ldr	r3, [sp, #4]
    918c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    918e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
    9192:	9b01      	ldr	r3, [sp, #4]
    9194:	651a      	str	r2, [r3, #80]	; 0x50
                                    FLEXCAN_CBT_EPSEG1_MASK | FLEXCAN_CBT_EPRESDIV_MASK
                                   ) | FLEXCAN_CBT_ERJW_MASK
                                  )
                  );

    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    9196:	9b01      	ldr	r3, [sp, #4]
    9198:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    919a:	9b00      	ldr	r3, [sp, #0]
    919c:	681b      	ldr	r3, [r3, #0]
    919e:	029b      	lsls	r3, r3, #10
    91a0:	b299      	uxth	r1, r3
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    91a2:	9b00      	ldr	r3, [sp, #0]
    91a4:	689b      	ldr	r3, [r3, #8]
    91a6:	f003 031f 	and.w	r3, r3, #31
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    91aa:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    91ac:	9b00      	ldr	r3, [sp, #0]
    91ae:	685b      	ldr	r3, [r3, #4]
    91b0:	015b      	lsls	r3, r3, #5
    91b2:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    91b6:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    91b8:	9b00      	ldr	r3, [sp, #0]
    91ba:	68db      	ldr	r3, [r3, #12]
    91bc:	0558      	lsls	r0, r3, #21
    91be:	4b07      	ldr	r3, [pc, #28]	; (91dc <FlexCAN_SetExtendedTimeSegments+0x58>)
    91c0:	4003      	ands	r3, r0
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    91c2:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_ERJW(timeSeg->rJumpwidth)
    91c4:	9b00      	ldr	r3, [sp, #0]
    91c6:	691b      	ldr	r3, [r3, #16]
    91c8:	041b      	lsls	r3, r3, #16
    91ca:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    91ce:	430b      	orrs	r3, r1
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    91d0:	431a      	orrs	r2, r3
    91d2:	9b01      	ldr	r3, [sp, #4]
    91d4:	651a      	str	r2, [r3, #80]	; 0x50
                                 )
                  );
}
    91d6:	bf00      	nop
    91d8:	b002      	add	sp, #8
    91da:	4770      	bx	lr
    91dc:	7fe00000 	.word	0x7fe00000

000091e0 <FlexCAN_GetExtendedTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetExtendedTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    91e0:	b082      	sub	sp, #8
    91e2:	9001      	str	r0, [sp, #4]
    91e4:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CBT) & FLEXCAN_CBT_EPRESDIV_MASK) >> FLEXCAN_CBT_EPRESDIV_SHIFT;
    91e6:	9b01      	ldr	r3, [sp, #4]
    91e8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    91ea:	0d5b      	lsrs	r3, r3, #21
    91ec:	f3c3 0209 	ubfx	r2, r3, #0, #10
    91f0:	9b00      	ldr	r3, [sp, #0]
    91f2:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CBT) & FLEXCAN_CBT_EPROPSEG_MASK) >> FLEXCAN_CBT_EPROPSEG_SHIFT;
    91f4:	9b01      	ldr	r3, [sp, #4]
    91f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    91f8:	0a9b      	lsrs	r3, r3, #10
    91fa:	f003 023f 	and.w	r2, r3, #63	; 0x3f
    91fe:	9b00      	ldr	r3, [sp, #0]
    9200:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CBT) & FLEXCAN_CBT_EPSEG1_MASK) >> FLEXCAN_CBT_EPSEG1_SHIFT;
    9202:	9b01      	ldr	r3, [sp, #4]
    9204:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9206:	095b      	lsrs	r3, r3, #5
    9208:	f003 021f 	and.w	r2, r3, #31
    920c:	9b00      	ldr	r3, [sp, #0]
    920e:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CBT) & FLEXCAN_CBT_EPSEG2_MASK) >> FLEXCAN_CBT_EPSEG2_SHIFT;
    9210:	9b01      	ldr	r3, [sp, #4]
    9212:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9214:	f003 021f 	and.w	r2, r3, #31
    9218:	9b00      	ldr	r3, [sp, #0]
    921a:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CBT) & FLEXCAN_CBT_ERJW_MASK) >> FLEXCAN_CBT_ERJW_SHIFT;
    921c:	9b01      	ldr	r3, [sp, #4]
    921e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9220:	0c1b      	lsrs	r3, r3, #16
    9222:	f003 021f 	and.w	r2, r3, #31
    9226:	9b00      	ldr	r3, [sp, #0]
    9228:	611a      	str	r2, [r3, #16]
}
    922a:	bf00      	nop
    922c:	b002      	add	sp, #8
    922e:	4770      	bx	lr

00009230 <FlexCAN_GetTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9230:	b082      	sub	sp, #8
    9232:	9001      	str	r0, [sp, #4]
    9234:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CTRL1) & FLEXCAN_CTRL1_PRESDIV_MASK) >> FLEXCAN_CTRL1_PRESDIV_SHIFT;
    9236:	9b01      	ldr	r3, [sp, #4]
    9238:	685b      	ldr	r3, [r3, #4]
    923a:	0e1b      	lsrs	r3, r3, #24
    923c:	b2da      	uxtb	r2, r3
    923e:	9b00      	ldr	r3, [sp, #0]
    9240:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CTRL1) & FLEXCAN_CTRL1_PROPSEG_MASK) >> FLEXCAN_CTRL1_PROPSEG_SHIFT;
    9242:	9b01      	ldr	r3, [sp, #4]
    9244:	685b      	ldr	r3, [r3, #4]
    9246:	f003 0207 	and.w	r2, r3, #7
    924a:	9b00      	ldr	r3, [sp, #0]
    924c:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG1_MASK) >> FLEXCAN_CTRL1_PSEG1_SHIFT;
    924e:	9b01      	ldr	r3, [sp, #4]
    9250:	685b      	ldr	r3, [r3, #4]
    9252:	0cdb      	lsrs	r3, r3, #19
    9254:	f003 0207 	and.w	r2, r3, #7
    9258:	9b00      	ldr	r3, [sp, #0]
    925a:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG2_MASK) >> FLEXCAN_CTRL1_PSEG2_SHIFT;
    925c:	9b01      	ldr	r3, [sp, #4]
    925e:	685b      	ldr	r3, [r3, #4]
    9260:	0c1b      	lsrs	r3, r3, #16
    9262:	f003 0207 	and.w	r2, r3, #7
    9266:	9b00      	ldr	r3, [sp, #0]
    9268:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CTRL1) & FLEXCAN_CTRL1_RJW_MASK) >> FLEXCAN_CTRL1_RJW_SHIFT;
    926a:	9b01      	ldr	r3, [sp, #4]
    926c:	685b      	ldr	r3, [r3, #4]
    926e:	0d9b      	lsrs	r3, r3, #22
    9270:	f003 0203 	and.w	r2, r3, #3
    9274:	9b00      	ldr	r3, [sp, #0]
    9276:	611a      	str	r2, [r3, #16]
}
    9278:	bf00      	nop
    927a:	b002      	add	sp, #8
    927c:	4770      	bx	lr

0000927e <FlexCAN_GetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetFDTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    927e:	b082      	sub	sp, #8
    9280:	9001      	str	r0, [sp, #4]
    9282:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->FDCBT) & FLEXCAN_FDCBT_FPRESDIV_MASK) >> FLEXCAN_FDCBT_FPRESDIV_SHIFT;
    9284:	9b01      	ldr	r3, [sp, #4]
    9286:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    928a:	0d1b      	lsrs	r3, r3, #20
    928c:	f3c3 0209 	ubfx	r2, r3, #0, #10
    9290:	9b00      	ldr	r3, [sp, #0]
    9292:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->FDCBT) & FLEXCAN_FDCBT_FPROPSEG_MASK) >> FLEXCAN_FDCBT_FPROPSEG_SHIFT;
    9294:	9b01      	ldr	r3, [sp, #4]
    9296:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    929a:	0a9b      	lsrs	r3, r3, #10
    929c:	f003 021f 	and.w	r2, r3, #31
    92a0:	9b00      	ldr	r3, [sp, #0]
    92a2:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG1_MASK) >> FLEXCAN_FDCBT_FPSEG1_SHIFT;
    92a4:	9b01      	ldr	r3, [sp, #4]
    92a6:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    92aa:	095b      	lsrs	r3, r3, #5
    92ac:	f003 0207 	and.w	r2, r3, #7
    92b0:	9b00      	ldr	r3, [sp, #0]
    92b2:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG2_MASK) >> FLEXCAN_FDCBT_FPSEG2_SHIFT;
    92b4:	9b01      	ldr	r3, [sp, #4]
    92b6:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    92ba:	f003 0207 	and.w	r2, r3, #7
    92be:	9b00      	ldr	r3, [sp, #0]
    92c0:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->FDCBT) & FLEXCAN_FDCBT_FRJW_MASK) >> FLEXCAN_FDCBT_FRJW_SHIFT;
    92c2:	9b01      	ldr	r3, [sp, #4]
    92c4:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    92c8:	0c1b      	lsrs	r3, r3, #16
    92ca:	f003 0207 	and.w	r2, r3, #7
    92ce:	9b00      	ldr	r3, [sp, #0]
    92d0:	611a      	str	r2, [r3, #16]
}
    92d2:	bf00      	nop
    92d4:	b002      	add	sp, #8
    92d6:	4770      	bx	lr

000092d8 <FlexCAN_IsExCbtEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsExCbtEnabled(const FLEXCAN_Type * pBase)
{
    92d8:	b082      	sub	sp, #8
    92da:	9001      	str	r0, [sp, #4]
    return (0U == ((pBase->CBT & FLEXCAN_CBT_BTF_MASK) >> FLEXCAN_CBT_BTF_SHIFT)) ? FALSE : TRUE;
    92dc:	9b01      	ldr	r3, [sp, #4]
    92de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    92e0:	0fdb      	lsrs	r3, r3, #31
    92e2:	b2db      	uxtb	r3, r3
}
    92e4:	4618      	mov	r0, r3
    92e6:	b002      	add	sp, #8
    92e8:	4770      	bx	lr

000092ea <FlexCAN_EnableExtCbt>:
 *
 * @param   base    The FlexCAN base address
 * @param   enableCBT Enable/Disable use of Extent Time Segments
 */
static inline void FlexCAN_EnableExtCbt(FLEXCAN_Type * base, boolean enableCBT)
{   /* Enable the use of extended bit time definitions */
    92ea:	b082      	sub	sp, #8
    92ec:	9001      	str	r0, [sp, #4]
    92ee:	460b      	mov	r3, r1
    92f0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CBT = (base->CBT & ~FLEXCAN_CBT_BTF_MASK) | FLEXCAN_CBT_BTF(enableCBT ? 1UL : 0UL);
    92f4:	9b01      	ldr	r3, [sp, #4]
    92f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    92f8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    92fc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9300:	2a00      	cmp	r2, #0
    9302:	d002      	beq.n	930a <FlexCAN_EnableExtCbt+0x20>
    9304:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    9308:	e000      	b.n	930c <FlexCAN_EnableExtCbt+0x22>
    930a:	2200      	movs	r2, #0
    930c:	431a      	orrs	r2, r3
    930e:	9b01      	ldr	r3, [sp, #4]
    9310:	651a      	str	r2, [r3, #80]	; 0x50
}
    9312:	bf00      	nop
    9314:	b002      	add	sp, #8
    9316:	4770      	bx	lr

00009318 <FlexCAN_SetSelfReception>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Enable/Disable Self Reception
 */
static inline void FlexCAN_SetSelfReception(FLEXCAN_Type * base, boolean enable)
{
    9318:	b082      	sub	sp, #8
    931a:	9001      	str	r0, [sp, #4]
    931c:	460b      	mov	r3, r1
    931e:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    9322:	9b01      	ldr	r3, [sp, #4]
    9324:	681b      	ldr	r3, [r3, #0]
    9326:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    932a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    932e:	2a00      	cmp	r2, #0
    9330:	d001      	beq.n	9336 <FlexCAN_SetSelfReception+0x1e>
    9332:	2200      	movs	r2, #0
    9334:	e001      	b.n	933a <FlexCAN_SetSelfReception+0x22>
    9336:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    933a:	431a      	orrs	r2, r3
    933c:	9b01      	ldr	r3, [sp, #4]
    933e:	601a      	str	r2, [r3, #0]
}
    9340:	bf00      	nop
    9342:	b002      	add	sp, #8
    9344:	4770      	bx	lr

00009346 <FlexCAN_IsFDEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsFDEnabled(const FLEXCAN_Type * base)
{
    9346:	b082      	sub	sp, #8
    9348:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    934a:	9b01      	ldr	r3, [sp, #4]
    934c:	681b      	ldr	r3, [r3, #0]
    934e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    9352:	2b00      	cmp	r3, #0
    9354:	bf14      	ite	ne
    9356:	2301      	movne	r3, #1
    9358:	2300      	moveq	r3, #0
    935a:	b2db      	uxtb	r3, r3
}
    935c:	4618      	mov	r0, r3
    935e:	b002      	add	sp, #8
    9360:	4770      	bx	lr

00009362 <FlexCAN_IsListenOnlyModeEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsListenOnlyModeEnabled(const FLEXCAN_Type * base)
{
    9362:	b082      	sub	sp, #8
    9364:	9001      	str	r0, [sp, #4]
    return (((base->CTRL1 & (FLEXCAN_CTRL1_LOM_MASK)) != 0U) ? TRUE : FALSE);
    9366:	9b01      	ldr	r3, [sp, #4]
    9368:	685b      	ldr	r3, [r3, #4]
    936a:	f003 0308 	and.w	r3, r3, #8
    936e:	2b00      	cmp	r3, #0
    9370:	bf14      	ite	ne
    9372:	2301      	movne	r3, #1
    9374:	2300      	moveq	r3, #0
    9376:	b2db      	uxtb	r3, r3
}
    9378:	4618      	mov	r0, r3
    937a:	b002      	add	sp, #8
    937c:	4770      	bx	lr

0000937e <RxFifoOcuppiedLastMsgBuff>:
 *
 * @param   x    Number of Configured RxFIFO Filters
 * @return  number of last MB occupied by RxFIFO
 */
static inline uint32 RxFifoOcuppiedLastMsgBuff(uint8 x)
{
    937e:	b082      	sub	sp, #8
    9380:	4603      	mov	r3, r0
    9382:	f88d 3007 	strb.w	r3, [sp, #7]
    return 5U + (((((uint32)x) + 1U) * 8U) / 4U);
    9386:	f89d 3007 	ldrb.w	r3, [sp, #7]
    938a:	3301      	adds	r3, #1
    938c:	00db      	lsls	r3, r3, #3
    938e:	089b      	lsrs	r3, r3, #2
    9390:	3305      	adds	r3, #5
}
    9392:	4618      	mov	r0, r3
    9394:	b002      	add	sp, #8
    9396:	4770      	bx	lr

00009398 <FlexCAN_SetClkSrc>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Specifies if The CAN engine clock source is the oscillator clock(FALSE) or peripheral clock(TRUE).
 */
static inline void FlexCAN_SetClkSrc(FLEXCAN_Type * base, boolean enable)
{
    9398:	b082      	sub	sp, #8
    939a:	9001      	str	r0, [sp, #4]
    939c:	460b      	mov	r3, r1
    939e:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_CLKSRC_MASK) | FLEXCAN_CTRL1_CLKSRC(enable ? 1UL : 0UL);
    93a2:	9b01      	ldr	r3, [sp, #4]
    93a4:	685b      	ldr	r3, [r3, #4]
    93a6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    93aa:	f89d 2003 	ldrb.w	r2, [sp, #3]
    93ae:	2a00      	cmp	r2, #0
    93b0:	d002      	beq.n	93b8 <FlexCAN_SetClkSrc+0x20>
    93b2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    93b6:	e000      	b.n	93ba <FlexCAN_SetClkSrc+0x22>
    93b8:	2200      	movs	r2, #0
    93ba:	431a      	orrs	r2, r3
    93bc:	9b01      	ldr	r3, [sp, #4]
    93be:	605a      	str	r2, [r3, #4]
}
    93c0:	bf00      	nop
    93c2:	b002      	add	sp, #8
    93c4:	4770      	bx	lr

000093c6 <FlexCAN_GetMsgBuffIntStatusFlag>:
 * @param   base  The FlexCAN base address
 * @param   msgBuffIdx       Index of the message buffer
 * @return  the individual Message Buffer interrupt flag (0 and 1 are the flag value)
 */
static inline uint8 FlexCAN_GetMsgBuffIntStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    93c6:	b084      	sub	sp, #16
    93c8:	9001      	str	r0, [sp, #4]
    93ca:	9100      	str	r1, [sp, #0]
    /* TODO: This need to be protected multithread access*/
    uint8 flag = 0;
    93cc:	2300      	movs	r3, #0
    93ce:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 mask;

    if (msgBuffIdx < 32U)
    93d2:	9b00      	ldr	r3, [sp, #0]
    93d4:	2b1f      	cmp	r3, #31
    93d6:	d810      	bhi.n	93fa <FlexCAN_GetMsgBuffIntStatusFlag+0x34>
    {
        mask = base->IMASK1 & FLEXCAN_IMASK1_BUF31TO0M_MASK;
    93d8:	9b01      	ldr	r3, [sp, #4]
    93da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    93dc:	9302      	str	r3, [sp, #8]
        flag = (uint8)(((base->IFLAG1 & mask) >> (msgBuffIdx % 32U)) & 1U);
    93de:	9b01      	ldr	r3, [sp, #4]
    93e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    93e2:	9b02      	ldr	r3, [sp, #8]
    93e4:	401a      	ands	r2, r3
    93e6:	9b00      	ldr	r3, [sp, #0]
    93e8:	f003 031f 	and.w	r3, r3, #31
    93ec:	fa22 f303 	lsr.w	r3, r2, r3
    93f0:	b2db      	uxtb	r3, r3
    93f2:	f003 0301 	and.w	r3, r3, #1
    93f6:	f88d 300f 	strb.w	r3, [sp, #15]
        mask = base->IMASK4 & FLEXCAN_IMASK4_BUF127TO96M_MASK;
        flag = (uint8)(((base->IFLAG4 & mask) >> (msgBuffIdx % 32U)) & 1U);
    }
#endif

    return flag;
    93fa:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    93fe:	4618      	mov	r0, r3
    9400:	b004      	add	sp, #16
    9402:	4770      	bx	lr

00009404 <FlexCAN_SetRxMsgBuffGlobalMask>:
 *
 * @param   base  The FlexCAN base address
 * @param   Mask  Mask Value
 */
static inline void FlexCAN_SetRxMsgBuffGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    9404:	b082      	sub	sp, #8
    9406:	9001      	str	r0, [sp, #4]
    9408:	9100      	str	r1, [sp, #0]
    (base->RXMGMASK) = Mask;
    940a:	9b01      	ldr	r3, [sp, #4]
    940c:	9a00      	ldr	r2, [sp, #0]
    940e:	611a      	str	r2, [r3, #16]
}
    9410:	bf00      	nop
    9412:	b002      	add	sp, #8
    9414:	4770      	bx	lr

00009416 <FlexCAN_SetRxIndividualMask>:
 */
static inline void FlexCAN_SetRxIndividualMask(FLEXCAN_Type * base,
                                               uint32 msgBuffIdx,
                                               uint32 mask
                                              )
{
    9416:	b084      	sub	sp, #16
    9418:	9003      	str	r0, [sp, #12]
    941a:	9102      	str	r1, [sp, #8]
    941c:	9201      	str	r2, [sp, #4]
    base->RXIMR[msgBuffIdx] = mask;
    941e:	9b03      	ldr	r3, [sp, #12]
    9420:	9a02      	ldr	r2, [sp, #8]
    9422:	f502 7208 	add.w	r2, r2, #544	; 0x220
    9426:	9901      	ldr	r1, [sp, #4]
    9428:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    942c:	bf00      	nop
    942e:	b004      	add	sp, #16
    9430:	4770      	bx	lr

00009432 <FlexCAN_SetTxArbitrationStartDelay>:
 *
 * @param   base  The FlexCAN base address
 * @param   tasd  The Tx arbitration start delay value
 */
static inline void FlexCAN_SetTxArbitrationStartDelay(FLEXCAN_Type * base, uint8 tasd)
{
    9432:	b082      	sub	sp, #8
    9434:	9001      	str	r0, [sp, #4]
    9436:	460b      	mov	r3, r1
    9438:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_TASD_MASK) | FLEXCAN_CTRL2_TASD(tasd);
    943c:	9b01      	ldr	r3, [sp, #4]
    943e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9440:	f423 0278 	bic.w	r2, r3, #16252928	; 0xf80000
    9444:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9448:	04db      	lsls	r3, r3, #19
    944a:	f403 0378 	and.w	r3, r3, #16252928	; 0xf80000
    944e:	431a      	orrs	r2, r3
    9450:	9b01      	ldr	r3, [sp, #4]
    9452:	635a      	str	r2, [r3, #52]	; 0x34
}
    9454:	bf00      	nop
    9456:	b002      	add	sp, #8
    9458:	4770      	bx	lr

0000945a <FlexCAN_SetRxMaskType>:
 *
 * @param   base  The FlexCAN base address
 * @param   type         The FlexCAN Rx mask type
 */
static inline void FlexCAN_SetRxMaskType(FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
    945a:	b082      	sub	sp, #8
    945c:	9001      	str	r0, [sp, #4]
    945e:	9100      	str	r1, [sp, #0]
    /* Set RX masking type (RX global mask or RX individual mask)*/
    if (FLEXCAN_RX_MASK_GLOBAL == type)
    9460:	9b00      	ldr	r3, [sp, #0]
    9462:	2b00      	cmp	r3, #0
    9464:	d106      	bne.n	9474 <FlexCAN_SetRxMaskType+0x1a>
    {
        /* Enable Global RX masking */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(0U);
    9466:	9b01      	ldr	r3, [sp, #4]
    9468:	681b      	ldr	r3, [r3, #0]
    946a:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
    946e:	9b01      	ldr	r3, [sp, #4]
    9470:	601a      	str	r2, [r3, #0]
    else
    {
        /* Enable Individual Rx Masking and Queue */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    }
}
    9472:	e005      	b.n	9480 <FlexCAN_SetRxMaskType+0x26>
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    9474:	9b01      	ldr	r3, [sp, #4]
    9476:	681b      	ldr	r3, [r3, #0]
    9478:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
    947c:	9b01      	ldr	r3, [sp, #4]
    947e:	601a      	str	r2, [r3, #0]
}
    9480:	bf00      	nop
    9482:	b002      	add	sp, #8
    9484:	4770      	bx	lr

00009486 <FlexCAN_SetRegDefaultVal>:
 * @brief Will set Flexcan Peripheral Register to default val.
 *
 * @param   base    The FlexCAN base address
 */
static inline void FlexCAN_SetRegDefaultVal(FLEXCAN_Type * base)
{
    9486:	b500      	push	{lr}
    9488:	b083      	sub	sp, #12
    948a:	9001      	str	r0, [sp, #4]
        base->ERFCR = FLEXCAN_IP_ERFCR_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    948c:	9801      	ldr	r0, [sp, #4]
    948e:	f002 ff85 	bl	c39c <FlexCAN_IsFDAvailable>
    9492:	4603      	mov	r3, r0
    9494:	2b00      	cmp	r3, #0
    9496:	d007      	beq.n	94a8 <FlexCAN_SetRegDefaultVal+0x22>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    9498:	9b01      	ldr	r3, [sp, #4]
    949a:	2200      	movs	r2, #0
    949c:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    94a0:	9b01      	ldr	r3, [sp, #4]
    94a2:	4a12      	ldr	r2, [pc, #72]	; (94ec <FlexCAN_SetRegDefaultVal+0x66>)
    94a4:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    {
        base->IFLAG2 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
        base->IMASK2 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */
    base->IFLAG1 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
    94a8:	9b01      	ldr	r3, [sp, #4]
    94aa:	f04f 32ff 	mov.w	r2, #4294967295
    94ae:	631a      	str	r2, [r3, #48]	; 0x30
    base->IMASK1 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    94b0:	9b01      	ldr	r3, [sp, #4]
    94b2:	2200      	movs	r2, #0
    94b4:	629a      	str	r2, [r3, #40]	; 0x28
    base->CBT = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    94b6:	9b01      	ldr	r3, [sp, #4]
    94b8:	2200      	movs	r2, #0
    94ba:	651a      	str	r2, [r3, #80]	; 0x50
    base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    94bc:	9b01      	ldr	r3, [sp, #4]
    94be:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    94c2:	635a      	str	r2, [r3, #52]	; 0x34
    base->ESR1 = FLEXCAN_IP_ESR1_DEFAULT_VALUE_U32;
    94c4:	9b01      	ldr	r3, [sp, #4]
    94c6:	4a0a      	ldr	r2, [pc, #40]	; (94f0 <FlexCAN_SetRegDefaultVal+0x6a>)
    94c8:	621a      	str	r2, [r3, #32]
    base->ECR = FLEXCAN_IP_ECR_DEFAULT_VALUE_U32;
    94ca:	9b01      	ldr	r3, [sp, #4]
    94cc:	2200      	movs	r2, #0
    94ce:	61da      	str	r2, [r3, #28]
    base->TIMER = FLEXCAN_IP_TIMER_DEFAULT_VALUE_U32;
    94d0:	9b01      	ldr	r3, [sp, #4]
    94d2:	2200      	movs	r2, #0
    94d4:	609a      	str	r2, [r3, #8]
    base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    94d6:	9b01      	ldr	r3, [sp, #4]
    94d8:	2200      	movs	r2, #0
    94da:	605a      	str	r2, [r3, #4]
    base->EPRS  = FLEXCAN_IP_EPRS_DEFAULT_VALUE_U32;
    base->ENCBT = FLEXCAN_IP_ENCBT_DEFAULT_VALUE_U32;
    base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
    base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
    base->MCR = FLEXCAN_IP_MCR_DEFAULT_VALUE_U32;
    94dc:	9b01      	ldr	r3, [sp, #4]
    94de:	4a05      	ldr	r2, [pc, #20]	; (94f4 <FlexCAN_SetRegDefaultVal+0x6e>)
    94e0:	601a      	str	r2, [r3, #0]
}
    94e2:	bf00      	nop
    94e4:	b003      	add	sp, #12
    94e6:	f85d fb04 	ldr.w	pc, [sp], #4
    94ea:	bf00      	nop
    94ec:	80004100 	.word	0x80004100
    94f0:	0003b006 	.word	0x0003b006
    94f4:	d890000f 	.word	0xd890000f

000094f8 <FlexCAN_InitRxFifo>:
 * Description   : Initialize fifo and dma if requested.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitRxFifo(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    94f8:	b500      	push	{lr}
    94fa:	b085      	sub	sp, #20
    94fc:	9001      	str	r0, [sp, #4]
    94fe:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    9500:	2300      	movs	r3, #0
    9502:	9303      	str	r3, [sp, #12]

    /* Enable RxFIFO feature, if requested. This might fail if the FD mode is enabled. */
    if (Flexcan_Ip_pData->is_rx_fifo_needed)
    9504:	9b00      	ldr	r3, [sp, #0]
    9506:	7a1b      	ldrb	r3, [r3, #8]
    9508:	2b00      	cmp	r3, #0
    950a:	d006      	beq.n	951a <FlexCAN_InitRxFifo+0x22>
    {
        eResult = FlexCAN_EnableRxFifo(pBase, (uint32)Flexcan_Ip_pData->num_id_filters);
    950c:	9b00      	ldr	r3, [sp, #0]
    950e:	685b      	ldr	r3, [r3, #4]
    9510:	4619      	mov	r1, r3
    9512:	9801      	ldr	r0, [sp, #4]
    9514:	f002 fefe 	bl	c314 <FlexCAN_EnableRxFifo>
    9518:	9003      	str	r0, [sp, #12]
        FlexCAN_SetRxFifoDMA(pBase, FALSE);
    }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    return eResult;
    951a:	9b03      	ldr	r3, [sp, #12]
}
    951c:	4618      	mov	r0, r3
    951e:	b005      	add	sp, #20
    9520:	f85d fb04 	ldr.w	pc, [sp], #4

00009524 <FlexCAN_InitCtroll>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitCtroll(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    9524:	b500      	push	{lr}
    9526:	b085      	sub	sp, #20
    9528:	9001      	str	r0, [sp, #4]
    952a:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    952c:	2300      	movs	r3, #0
    952e:	9303      	str	r3, [sp, #12]
    /* Disable the self reception feature if FlexCAN is not in loopback mode. */
    if (Flexcan_Ip_pData->flexcanMode != FLEXCAN_LOOPBACK_MODE)
    9530:	9b00      	ldr	r3, [sp, #0]
    9532:	68db      	ldr	r3, [r3, #12]
    9534:	2b02      	cmp	r3, #2
    9536:	d003      	beq.n	9540 <FlexCAN_InitCtroll+0x1c>
    {
        FlexCAN_SetSelfReception(pBase, FALSE);
    9538:	2100      	movs	r1, #0
    953a:	9801      	ldr	r0, [sp, #4]
    953c:	f7ff feec 	bl	9318 <FlexCAN_SetSelfReception>
    }

    /* Init legacy fifo, enhanced fifo if requested. */
    eResult = FlexCAN_InitRxFifo(pBase, Flexcan_Ip_pData);
    9540:	9900      	ldr	r1, [sp, #0]
    9542:	9801      	ldr	r0, [sp, #4]
    9544:	f7ff ffd8 	bl	94f8 <FlexCAN_InitRxFifo>
    9548:	9003      	str	r0, [sp, #12]
    if (eResult != FLEXCAN_STATUS_SUCCESS)
    954a:	9b03      	ldr	r3, [sp, #12]
    954c:	2b00      	cmp	r3, #0
    954e:	d006      	beq.n	955e <FlexCAN_InitCtroll+0x3a>
    {
        /* To enter Disable Mode requires FreezMode first */
        (void)FlexCAN_EnterFreezeMode(pBase);
    9550:	9801      	ldr	r0, [sp, #4]
    9552:	f002 fd03 	bl	bf5c <FlexCAN_EnterFreezeMode>
        (void)FlexCAN_Disable(pBase);
    9556:	9801      	ldr	r0, [sp, #4]
    9558:	f002 fdca 	bl	c0f0 <FlexCAN_Disable>
    955c:	e00b      	b.n	9576 <FlexCAN_InitCtroll+0x52>
    }
    else
    {
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set payload size. */
        FlexCAN_SetPayloadSize(pBase, &Flexcan_Ip_pData->payload);
    955e:	9b00      	ldr	r3, [sp, #0]
    9560:	3314      	adds	r3, #20
    9562:	4619      	mov	r1, r3
    9564:	9801      	ldr	r0, [sp, #4]
    9566:	f002 ff3b 	bl	c3e0 <FlexCAN_SetPayloadSize>
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
            (void)FlexCAN_Disable(pBase);
        }
    #else
        (void)FlexCAN_SetMaxMsgBuffNum(pBase, Flexcan_Ip_pData->max_num_mb);
    956a:	9b00      	ldr	r3, [sp, #0]
    956c:	681b      	ldr	r3, [r3, #0]
    956e:	4619      	mov	r1, r3
    9570:	9801      	ldr	r0, [sp, #4]
    9572:	f003 fab7 	bl	cae4 <FlexCAN_SetMaxMsgBuffNum>
    #endif /* FLEXCAN_IP_DEV_ERROR_DETECT */
    }
    return eResult;
    9576:	9b03      	ldr	r3, [sp, #12]
}
    9578:	4618      	mov	r0, r3
    957a:	b005      	add	sp, #20
    957c:	f85d fb04 	ldr.w	pc, [sp], #4

00009580 <FlexCAN_InitController>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitController(uint8 Instance, FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    9580:	b500      	push	{lr}
    9582:	b087      	sub	sp, #28
    9584:	4603      	mov	r3, r0
    9586:	9102      	str	r1, [sp, #8]
    9588:	9201      	str	r2, [sp, #4]
    958a:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    958e:	2300      	movs	r3, #0
    9590:	9305      	str	r3, [sp, #20]

    if (FlexCAN_IsEnabled(pBase))
    9592:	9802      	ldr	r0, [sp, #8]
    9594:	f7ff fd0c 	bl	8fb0 <FlexCAN_IsEnabled>
    9598:	4603      	mov	r3, r0
    959a:	2b00      	cmp	r3, #0
    959c:	d00a      	beq.n	95b4 <FlexCAN_InitController+0x34>
    {
        /* To enter Disable Mode requires FreezMode first */
        eResult = FlexCAN_EnterFreezeMode(pBase);
    959e:	9802      	ldr	r0, [sp, #8]
    95a0:	f002 fcdc 	bl	bf5c <FlexCAN_EnterFreezeMode>
    95a4:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == eResult)
    95a6:	9b05      	ldr	r3, [sp, #20]
    95a8:	2b00      	cmp	r3, #0
    95aa:	d103      	bne.n	95b4 <FlexCAN_InitController+0x34>
        {
            eResult = FlexCAN_Disable(pBase);
    95ac:	9802      	ldr	r0, [sp, #8]
    95ae:	f002 fd9f 	bl	c0f0 <FlexCAN_Disable>
    95b2:	9005      	str	r0, [sp, #20]
        }
    }

    if (FLEXCAN_STATUS_SUCCESS == eResult)
    95b4:	9b05      	ldr	r3, [sp, #20]
    95b6:	2b00      	cmp	r3, #0
    95b8:	d137      	bne.n	962a <FlexCAN_InitController+0xaa>
    {
    #if (FLEXCAN_IP_FEATURE_HAS_PE_CLKSRC_SELECT == STD_ON)
        /* Select a source clock for the FlexCAN engine */
        FlexCAN_SetClkSrc(pBase, Flexcan_Ip_pData->is_pe_clock);
    95ba:	9b01      	ldr	r3, [sp, #4]
    95bc:	7e5b      	ldrb	r3, [r3, #25]
    95be:	4619      	mov	r1, r3
    95c0:	9802      	ldr	r0, [sp, #8]
    95c2:	f7ff fee9 	bl	9398 <FlexCAN_SetClkSrc>
    #endif
        /* Enable FlexCAN Module need to perform SoftReset & ClearRam */
        pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    95c6:	9b02      	ldr	r3, [sp, #8]
    95c8:	681b      	ldr	r3, [r3, #0]
    95ca:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    95ce:	9b02      	ldr	r3, [sp, #8]
    95d0:	601a      	str	r2, [r3, #0]
        /* Initialize FLEXCAN device */
        eResult = FlexCAN_Init(pBase);
    95d2:	9802      	ldr	r0, [sp, #8]
    95d4:	f002 fe28 	bl	c228 <FlexCAN_Init>
    95d8:	9005      	str	r0, [sp, #20]
        if (eResult != FLEXCAN_STATUS_SUCCESS)
    95da:	9b05      	ldr	r3, [sp, #20]
    95dc:	2b00      	cmp	r3, #0
    95de:	d006      	beq.n	95ee <FlexCAN_InitController+0x6e>
        {
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
    95e0:	9802      	ldr	r0, [sp, #8]
    95e2:	f002 fcbb 	bl	bf5c <FlexCAN_EnterFreezeMode>
            (void)FlexCAN_Disable(pBase);
    95e6:	9802      	ldr	r0, [sp, #8]
    95e8:	f002 fd82 	bl	c0f0 <FlexCAN_Disable>
    95ec:	e01d      	b.n	962a <FlexCAN_InitController+0xaa>
            /* Disable the Protection again because is enabled by soft reset */
            FlexCAN_DisableMemErrorDetection(pBase);
        #endif

        #if defined(CAN_FEATURE_S32K1XX)
            if (TRUE == FlexCAN_IsFDAvailable(pBase))
    95ee:	9802      	ldr	r0, [sp, #8]
    95f0:	f002 fed4 	bl	c39c <FlexCAN_IsFDAvailable>
    95f4:	4603      	mov	r3, r0
    95f6:	2b00      	cmp	r3, #0
    95f8:	d007      	beq.n	960a <FlexCAN_InitController+0x8a>
            {
        #endif /* defined(CAN_FEATURE_S32K1XX) */
                /* Enable/Disable FD and check FD was set as expected. Setting FD as enabled
                 * might fail if the current CAN instance does not support FD. */
                FlexCAN_SetFDEnabled(pBase, Flexcan_Ip_pData->fd_enable, Flexcan_Ip_pData->bitRateSwitch);
    95fa:	9b01      	ldr	r3, [sp, #4]
    95fc:	7e19      	ldrb	r1, [r3, #24]
    95fe:	9b01      	ldr	r3, [sp, #4]
    9600:	7edb      	ldrb	r3, [r3, #27]
    9602:	461a      	mov	r2, r3
    9604:	9802      	ldr	r0, [sp, #8]
    9606:	f7ff fcdd 	bl	8fc4 <FlexCAN_SetFDEnabled>
                }*/
        #if defined(CAN_FEATURE_S32K1XX)
            }
        #endif /* defined(CAN_FEATURE_S32K1XX) */
            /* configure depends on controller options. */
            FlexCAN_ConfigCtrlOptions(pBase, Flexcan_Ip_pData->ctrlOptions);
    960a:	9b01      	ldr	r3, [sp, #4]
    960c:	691b      	ldr	r3, [r3, #16]
    960e:	4619      	mov	r1, r3
    9610:	9802      	ldr	r0, [sp, #8]
    9612:	f003 fdeb 	bl	d1ec <FlexCAN_ConfigCtrlOptions>
            /* reset Imask buffers */
            FlexCAN_ResetImaskBuff(Instance);
    9616:	f89d 300f 	ldrb.w	r3, [sp, #15]
    961a:	4618      	mov	r0, r3
    961c:	f003 fe56 	bl	d2cc <FlexCAN_ResetImaskBuff>
            eResult = FlexCAN_InitCtroll(pBase, Flexcan_Ip_pData);
    9620:	9901      	ldr	r1, [sp, #4]
    9622:	9802      	ldr	r0, [sp, #8]
    9624:	f7ff ff7e 	bl	9524 <FlexCAN_InitCtroll>
    9628:	9005      	str	r0, [sp, #20]
        }
    }
    return eResult;
    962a:	9b05      	ldr	r3, [sp, #20]
}
    962c:	4618      	mov	r0, r3
    962e:	b007      	add	sp, #28
    9630:	f85d fb04 	ldr.w	pc, [sp], #4

00009634 <FlexCAN_InitBaudrate>:
 * Description   : Init baudrate for given controller.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_InitBaudrate(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    9634:	b500      	push	{lr}
    9636:	b083      	sub	sp, #12
    9638:	9001      	str	r0, [sp, #4]
    963a:	9100      	str	r1, [sp, #0]
    /* Enable the use of extended bit time definitions */
    FlexCAN_EnableExtCbt(pBase, Flexcan_Ip_pData->fd_enable);
    963c:	9b00      	ldr	r3, [sp, #0]
    963e:	7e1b      	ldrb	r3, [r3, #24]
    9640:	4619      	mov	r1, r3
    9642:	9801      	ldr	r0, [sp, #4]
    9644:	f7ff fe51 	bl	92ea <FlexCAN_EnableExtCbt>
        /* Disable Enhanced CBT time segments */
        pBase->CTRL2 &= ~FLEXCAN_CTRL2_BTE_MASK;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set bit rate. */
        if (Flexcan_Ip_pData->fd_enable)
    9648:	9b00      	ldr	r3, [sp, #0]
    964a:	7e1b      	ldrb	r3, [r3, #24]
    964c:	2b00      	cmp	r3, #0
    964e:	d00c      	beq.n	966a <FlexCAN_InitBaudrate+0x36>
        {
            /* Write Normal bit time configuration to CBT register */
            FlexCAN_SetExtendedTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    9650:	9b00      	ldr	r3, [sp, #0]
    9652:	331c      	adds	r3, #28
    9654:	4619      	mov	r1, r3
    9656:	9801      	ldr	r0, [sp, #4]
    9658:	f7ff fd94 	bl	9184 <FlexCAN_SetExtendedTimeSegments>
            /* Write Data bit time configuration to FDCBT register */
            FlexCAN_SetFDTimeSegments(pBase, &Flexcan_Ip_pData->bitrate_cbt);
    965c:	9b00      	ldr	r3, [sp, #0]
    965e:	3330      	adds	r3, #48	; 0x30
    9660:	4619      	mov	r1, r3
    9662:	9801      	ldr	r0, [sp, #4]
    9664:	f7ff fd2d 	bl	90c2 <FlexCAN_SetFDTimeSegments>
            /* Write Normal bit time configuration to CTRL1 register */
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
        }
#endif
    }
}
    9668:	e005      	b.n	9676 <FlexCAN_InitBaudrate+0x42>
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    966a:	9b00      	ldr	r3, [sp, #0]
    966c:	331c      	adds	r3, #28
    966e:	4619      	mov	r1, r3
    9670:	9801      	ldr	r0, [sp, #4]
    9672:	f7ff fd5b 	bl	912c <FlexCAN_SetTimeSegments>
}
    9676:	bf00      	nop
    9678:	b003      	add	sp, #12
    967a:	f85d fb04 	ldr.w	pc, [sp], #4

0000967e <FlexCAN_ProccessLegacyRxFIFO>:
 * Description   : This function will process the enhanced RxFIFO in blocking mode.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_ProccessLegacyRxFIFO(uint8 u8Instance, uint32 u32TimeoutMs)
{
    967e:	b500      	push	{lr}
    9680:	b08d      	sub	sp, #52	; 0x34
    9682:	4603      	mov	r3, r0
    9684:	9102      	str	r1, [sp, #8]
    9686:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    968a:	2300      	movs	r3, #0
    968c:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    968e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9692:	4a46      	ldr	r2, [pc, #280]	; (97ac <FlexCAN_ProccessLegacyRxFIFO+0x12e>)
    9694:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9698:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    969a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    969e:	4a44      	ldr	r2, [pc, #272]	; (97b0 <FlexCAN_ProccessLegacyRxFIFO+0x132>)
    96a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96a4:	9307      	str	r3, [sp, #28]
    uint32 timeStart = 0U;
    96a6:	2300      	movs	r3, #0
    96a8:	9305      	str	r3, [sp, #20]
    uint32 timeElapsed = 0U;
    96aa:	2300      	movs	r3, #0
    96ac:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    96ae:	9b02      	ldr	r3, [sp, #8]
    96b0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    96b4:	fb02 f303 	mul.w	r3, r2, r3
    96b8:	2100      	movs	r1, #0
    96ba:	4618      	mov	r0, r3
    96bc:	f7f8 fdec 	bl	2298 <OsIf_MicrosToTicks>
    96c0:	9006      	str	r0, [sp, #24]
    uint32 u32intType = 0U;
    96c2:	2300      	movs	r3, #0
    96c4:	9309      	str	r3, [sp, #36]	; 0x24

        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    96c6:	2000      	movs	r0, #0
    96c8:	f7f8 fd9a 	bl	2200 <OsIf_GetCounter>
    96cc:	4603      	mov	r3, r0
    96ce:	9305      	str	r3, [sp, #20]

        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    96d0:	e02a      	b.n	9728 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
        {
            if (FLEXCAN_RXFIFO_USING_POLLING == pState->transferType)
    96d2:	9b08      	ldr	r3, [sp, #32]
    96d4:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    96d8:	2b01      	cmp	r3, #1
    96da:	d115      	bne.n	9708 <FlexCAN_ProccessLegacyRxFIFO+0x8a>
            {
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    96dc:	2307      	movs	r3, #7
    96de:	9309      	str	r3, [sp, #36]	; 0x24
    96e0:	e00f      	b.n	9702 <FlexCAN_ProccessLegacyRxFIFO+0x84>
                     u32intType >= FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE; \
                     u32intType--)
                {
                    if (FlexCAN_GetBuffStatusFlag(pBase, u32intType) != 0U)
    96e2:	9909      	ldr	r1, [sp, #36]	; 0x24
    96e4:	9807      	ldr	r0, [sp, #28]
    96e6:	f7ff fcd0 	bl	908a <FlexCAN_GetBuffStatusFlag>
    96ea:	4603      	mov	r3, r0
    96ec:	2b00      	cmp	r3, #0
    96ee:	d005      	beq.n	96fc <FlexCAN_ProccessLegacyRxFIFO+0x7e>
                    {
                        FlexCAN_IRQHandlerRxFIFO(u8Instance, u32intType);
    96f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    96f4:	9909      	ldr	r1, [sp, #36]	; 0x24
    96f6:	4618      	mov	r0, r3
    96f8:	f000 fb06 	bl	9d08 <FlexCAN_IRQHandlerRxFIFO>
                     u32intType--)
    96fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    96fe:	3b01      	subs	r3, #1
    9700:	9309      	str	r3, [sp, #36]	; 0x24
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    9702:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9704:	2b04      	cmp	r3, #4
    9706:	d8ec      	bhi.n	96e2 <FlexCAN_ProccessLegacyRxFIFO+0x64>
                    }
                }
            }

            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9708:	ab05      	add	r3, sp, #20
    970a:	2100      	movs	r1, #0
    970c:	4618      	mov	r0, r3
    970e:	f7f8 fd90 	bl	2232 <OsIf_GetElapsed>
    9712:	4602      	mov	r2, r0
    9714:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9716:	4413      	add	r3, r2
    9718:	930a      	str	r3, [sp, #40]	; 0x28
            if (timeElapsed >= mS2Ticks)
    971a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    971c:	9b06      	ldr	r3, [sp, #24]
    971e:	429a      	cmp	r2, r3
    9720:	d302      	bcc.n	9728 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
            {
                eResult = FLEXCAN_STATUS_TIMEOUT;
    9722:	2303      	movs	r3, #3
    9724:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    9726:	e003      	b.n	9730 <FlexCAN_ProccessLegacyRxFIFO+0xb2>
        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    9728:	9b08      	ldr	r3, [sp, #32]
    972a:	685b      	ldr	r3, [r3, #4]
    972c:	2b01      	cmp	r3, #1
    972e:	d0d0      	beq.n	96d2 <FlexCAN_ProccessLegacyRxFIFO+0x54>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == eResult) && (FLEXCAN_RXFIFO_USING_POLLING != pState->transferType))
    9730:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9732:	2b03      	cmp	r3, #3
    9734:	d125      	bne.n	9782 <FlexCAN_ProccessLegacyRxFIFO+0x104>
    9736:	9b08      	ldr	r3, [sp, #32]
    9738:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    973c:	2b01      	cmp	r3, #1
    973e:	d020      	beq.n	9782 <FlexCAN_ProccessLegacyRxFIFO+0x104>
        {
            /* Disable RX FIFO interrupts*/
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, pState->isIntActive);
    9740:	9b08      	ldr	r3, [sp, #32]
    9742:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9746:	f89d 100f 	ldrb.w	r1, [sp, #15]
    974a:	9300      	str	r3, [sp, #0]
    974c:	2300      	movs	r3, #0
    974e:	2205      	movs	r2, #5
    9750:	9807      	ldr	r0, [sp, #28]
    9752:	f002 feef 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, pState->isIntActive);
    9756:	9b08      	ldr	r3, [sp, #32]
    9758:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    975c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9760:	9300      	str	r3, [sp, #0]
    9762:	2300      	movs	r3, #0
    9764:	2206      	movs	r2, #6
    9766:	9807      	ldr	r0, [sp, #28]
    9768:	f002 fee4 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, pState->isIntActive);
    976c:	9b08      	ldr	r3, [sp, #32]
    976e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9772:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9776:	9300      	str	r3, [sp, #0]
    9778:	2300      	movs	r3, #0
    977a:	2207      	movs	r2, #7
    977c:	9807      	ldr	r0, [sp, #28]
    977e:	f002 fed9 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
                (void)Dma_Ip_SetLogicChannelCommand(pState->rxFifoDMAChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            }
#endif
        }

        switch (pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    9782:	9b08      	ldr	r3, [sp, #32]
    9784:	685b      	ldr	r3, [r3, #4]
    9786:	2b00      	cmp	r3, #0
    9788:	d005      	beq.n	9796 <FlexCAN_ProccessLegacyRxFIFO+0x118>
    978a:	2b01      	cmp	r3, #1
    978c:	d106      	bne.n	979c <FlexCAN_ProccessLegacyRxFIFO+0x11e>
        {
            case FLEXCAN_MB_RX_BUSY:
                pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    978e:	9b08      	ldr	r3, [sp, #32]
    9790:	2200      	movs	r2, #0
    9792:	605a      	str	r2, [r3, #4]
                break;
    9794:	e005      	b.n	97a2 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_IDLE:
                eResult = FLEXCAN_STATUS_SUCCESS;
    9796:	2300      	movs	r3, #0
    9798:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    979a:	e002      	b.n	97a2 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_DMA_ERROR:
                eResult = FLEXCAN_STATUS_ERROR;
                break;
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
            default:
                eResult = FLEXCAN_STATUS_ERROR;
    979c:	2301      	movs	r3, #1
    979e:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    97a0:	bf00      	nop
        }

    return eResult;
    97a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    97a4:	4618      	mov	r0, r3
    97a6:	b00d      	add	sp, #52	; 0x34
    97a8:	f85d fb04 	ldr.w	pc, [sp], #4
    97ac:	1fff8fb8 	.word	0x1fff8fb8
    97b0:	00010534 	.word	0x00010534

000097b4 <FlexCAN_StartRxMessageBufferData>:
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageBufferData(uint8 instance,
                                                              uint8 mb_idx,
                                                              Flexcan_Ip_MsgBuffType * data,
                                                              boolean isPolling
                                                             )
{
    97b4:	b084      	sub	sp, #16
    97b6:	9200      	str	r2, [sp, #0]
    97b8:	461a      	mov	r2, r3
    97ba:	4603      	mov	r3, r0
    97bc:	f88d 3007 	strb.w	r3, [sp, #7]
    97c0:	460b      	mov	r3, r1
    97c2:	f88d 3006 	strb.w	r3, [sp, #6]
    97c6:	4613      	mov	r3, r2
    97c8:	f88d 3005 	strb.w	r3, [sp, #5]

    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    97cc:	2300      	movs	r3, #0
    97ce:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    97d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    97d4:	4a15      	ldr	r2, [pc, #84]	; (982c <FlexCAN_StartRxMessageBufferData+0x78>)
    97d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97da:	9302      	str	r3, [sp, #8]
    }
    else
    {
#endif
        /* Start receiving mailbox */
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    97dc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    97e0:	9a02      	ldr	r2, [sp, #8]
    97e2:	011b      	lsls	r3, r3, #4
    97e4:	4413      	add	r3, r2
    97e6:	3304      	adds	r3, #4
    97e8:	681b      	ldr	r3, [r3, #0]
    97ea:	2b00      	cmp	r3, #0
    97ec:	d002      	beq.n	97f4 <FlexCAN_StartRxMessageBufferData+0x40>
        {
            result = FLEXCAN_STATUS_BUSY;
    97ee:	2302      	movs	r3, #2
    97f0:	9303      	str	r3, [sp, #12]
    97f2:	e017      	b.n	9824 <FlexCAN_StartRxMessageBufferData+0x70>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_RX_BUSY;
    97f4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    97f8:	9a02      	ldr	r2, [sp, #8]
    97fa:	011b      	lsls	r3, r3, #4
    97fc:	4413      	add	r3, r2
    97fe:	3304      	adds	r3, #4
    9800:	2201      	movs	r2, #1
    9802:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].pMBmessage = data;
    9804:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9808:	9a02      	ldr	r2, [sp, #8]
    980a:	011b      	lsls	r3, r3, #4
    980c:	4413      	add	r3, r2
    980e:	9a00      	ldr	r2, [sp, #0]
    9810:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = isPolling;
    9812:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9816:	9a02      	ldr	r2, [sp, #8]
    9818:	011b      	lsls	r3, r3, #4
    981a:	4413      	add	r3, r2
    981c:	3308      	adds	r3, #8
    981e:	f89d 2005 	ldrb.w	r2, [sp, #5]
    9822:	701a      	strb	r2, [r3, #0]
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    9824:	9b03      	ldr	r3, [sp, #12]
}
    9826:	4618      	mov	r0, r3
    9828:	b004      	add	sp, #16
    982a:	4770      	bx	lr
    982c:	1fff8fb8 	.word	0x1fff8fb8

00009830 <FlexCAN_StartSendData>:
                                                   uint8 mb_idx,
                                                   const Flexcan_Ip_DataInfoType * tx_info,
                                                   uint32 msg_id,
                                                   const uint8 * mb_data
                                                  )
{
    9830:	b500      	push	{lr}
    9832:	b08f      	sub	sp, #60	; 0x3c
    9834:	9204      	str	r2, [sp, #16]
    9836:	9303      	str	r3, [sp, #12]
    9838:	4603      	mov	r3, r0
    983a:	f88d 3017 	strb.w	r3, [sp, #23]
    983e:	460b      	mov	r3, r1
    9840:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    9844:	2300      	movs	r3, #0
    9846:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[Flexcan_Ip_u8Instance];
    9848:	f89d 3017 	ldrb.w	r3, [sp, #23]
    984c:	4a38      	ldr	r2, [pc, #224]	; (9930 <FlexCAN_StartSendData+0x100>)
    984e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9852:	930c      	str	r3, [sp, #48]	; 0x30
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    9854:	f89d 3017 	ldrb.w	r3, [sp, #23]
    9858:	4a36      	ldr	r2, [pc, #216]	; (9934 <FlexCAN_StartSendData+0x104>)
    985a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    985e:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    9860:	2300      	movs	r3, #0
    9862:	930a      	str	r3, [sp, #40]	; 0x28
        eResult = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
    else
    {
#endif
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    9864:	f89d 3016 	ldrb.w	r3, [sp, #22]
    9868:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    986a:	011b      	lsls	r3, r3, #4
    986c:	4413      	add	r3, r2
    986e:	3304      	adds	r3, #4
    9870:	681b      	ldr	r3, [r3, #0]
    9872:	2b00      	cmp	r3, #0
    9874:	d002      	beq.n	987c <FlexCAN_StartSendData+0x4c>
        {
            eResult = FLEXCAN_STATUS_BUSY;
    9876:	2302      	movs	r3, #2
    9878:	930d      	str	r3, [sp, #52]	; 0x34
    987a:	e053      	b.n	9924 <FlexCAN_StartSendData+0xf4>
        }
        else
        {
            /* Clear message buffer flag */
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    987c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    9880:	4619      	mov	r1, r3
    9882:	980b      	ldr	r0, [sp, #44]	; 0x2c
    9884:	f7ff fbee 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>

            state->mbs[mb_idx].state = FLEXCAN_MB_TX_BUSY;
    9888:	f89d 3016 	ldrb.w	r3, [sp, #22]
    988c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    988e:	011b      	lsls	r3, r3, #4
    9890:	4413      	add	r3, r2
    9892:	3304      	adds	r3, #4
    9894:	2202      	movs	r2, #2
    9896:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].time_stamp = 0U;
    9898:	f89d 3016 	ldrb.w	r3, [sp, #22]
    989c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    989e:	011b      	lsls	r3, r3, #4
    98a0:	4413      	add	r3, r2
    98a2:	330c      	adds	r3, #12
    98a4:	2200      	movs	r2, #0
    98a6:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = tx_info->is_polling;
    98a8:	f89d 3016 	ldrb.w	r3, [sp, #22]
    98ac:	9a04      	ldr	r2, [sp, #16]
    98ae:	7b11      	ldrb	r1, [r2, #12]
    98b0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    98b2:	011b      	lsls	r3, r3, #4
    98b4:	4413      	add	r3, r2
    98b6:	3308      	adds	r3, #8
    98b8:	460a      	mov	r2, r1
    98ba:	701a      	strb	r2, [r3, #0]
            state->mbs[mb_idx].isRemote = tx_info->is_remote;
    98bc:	f89d 3016 	ldrb.w	r3, [sp, #22]
    98c0:	9a04      	ldr	r2, [sp, #16]
    98c2:	7ad1      	ldrb	r1, [r2, #11]
    98c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    98c6:	011b      	lsls	r3, r3, #4
    98c8:	4413      	add	r3, r2
    98ca:	3309      	adds	r3, #9
    98cc:	460a      	mov	r2, r1
    98ce:	701a      	strb	r2, [r3, #0]

            cs.dataLen = tx_info->data_length;
    98d0:	9b04      	ldr	r3, [sp, #16]
    98d2:	685b      	ldr	r3, [r3, #4]
    98d4:	9308      	str	r3, [sp, #32]

            cs.msgIdType = tx_info->msg_id_type;
    98d6:	9b04      	ldr	r3, [sp, #16]
    98d8:	681b      	ldr	r3, [r3, #0]
    98da:	9307      	str	r3, [sp, #28]

        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            cs.fd_enable = tx_info->fd_enable;
    98dc:	9b04      	ldr	r3, [sp, #16]
    98de:	7a1b      	ldrb	r3, [r3, #8]
    98e0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
            cs.fd_padding = tx_info->fd_padding;
    98e4:	9b04      	ldr	r3, [sp, #16]
    98e6:	7a5b      	ldrb	r3, [r3, #9]
    98e8:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
            cs.enable_brs = tx_info->enable_brs;
    98ec:	9b04      	ldr	r3, [sp, #16]
    98ee:	7a9b      	ldrb	r3, [r3, #10]
    98f0:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        #endif

            if (tx_info->is_remote)
    98f4:	9b04      	ldr	r3, [sp, #16]
    98f6:	7adb      	ldrb	r3, [r3, #11]
    98f8:	2b00      	cmp	r3, #0
    98fa:	d002      	beq.n	9902 <FlexCAN_StartSendData+0xd2>
            {
                cs.code = (uint32)FLEXCAN_TX_REMOTE;
    98fc:	231c      	movs	r3, #28
    98fe:	9306      	str	r3, [sp, #24]
    9900:	e001      	b.n	9906 <FlexCAN_StartSendData+0xd6>
            }
            else
            {
                cs.code = (uint32)FLEXCAN_TX_DATA;
    9902:	230c      	movs	r3, #12
    9904:	9306      	str	r3, [sp, #24]
            }
            pMbAddr = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    9906:	f89d 3016 	ldrb.w	r3, [sp, #22]
    990a:	4619      	mov	r1, r3
    990c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    990e:	f002 fa89 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    9912:	900a      	str	r0, [sp, #40]	; 0x28
            FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, FALSE);
    9914:	a906      	add	r1, sp, #24
    9916:	2300      	movs	r3, #0
    9918:	9300      	str	r3, [sp, #0]
    991a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    991c:	9a03      	ldr	r2, [sp, #12]
    991e:	980a      	ldr	r0, [sp, #40]	; 0x28
    9920:	f002 ffd2 	bl	c8c8 <FlexCAN_SetTxMsgBuff>
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    9924:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    9926:	4618      	mov	r0, r3
    9928:	b00f      	add	sp, #60	; 0x3c
    992a:	f85d fb04 	ldr.w	pc, [sp], #4
    992e:	bf00      	nop
    9930:	1fff8fb8 	.word	0x1fff8fb8
    9934:	00010534 	.word	0x00010534

00009938 <FlexCAN_StartRxMessageFifoData>:
 * receiving data and enabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageFifoData(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    9938:	b500      	push	{lr}
    993a:	b089      	sub	sp, #36	; 0x24
    993c:	4603      	mov	r3, r0
    993e:	9102      	str	r1, [sp, #8]
    9940:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = NULL_PTR;
    9944:	2300      	movs	r3, #0
    9946:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StateType * state = NULL_PTR;
    9948:	2300      	movs	r3, #0
    994a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    994c:	2300      	movs	r3, #0
    994e:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base = Flexcan_Ip_apxBase[instance];
    9950:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9954:	4a26      	ldr	r2, [pc, #152]	; (99f0 <FlexCAN_StartRxMessageFifoData+0xb8>)
    9956:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    995a:	9306      	str	r3, [sp, #24]
    state = Flexcan_Ip_apxState[instance];
    995c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9960:	4a24      	ldr	r2, [pc, #144]	; (99f4 <FlexCAN_StartRxMessageFifoData+0xbc>)
    9962:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9966:	9305      	str	r3, [sp, #20]
    #endif
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    /* Start receiving fifo */
    if (state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY)
    9968:	9b05      	ldr	r3, [sp, #20]
    996a:	685b      	ldr	r3, [r3, #4]
    996c:	2b01      	cmp	r3, #1
    996e:	d102      	bne.n	9976 <FlexCAN_StartRxMessageFifoData+0x3e>
    {
        eResult = FLEXCAN_STATUS_BUSY;
    9970:	2302      	movs	r3, #2
    9972:	9307      	str	r3, [sp, #28]
    9974:	e036      	b.n	99e4 <FlexCAN_StartRxMessageFifoData+0xac>
    }
    else
    {
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_RX_BUSY;
    9976:	9b05      	ldr	r3, [sp, #20]
    9978:	2201      	movs	r2, #1
    997a:	605a      	str	r2, [r3, #4]
    if (FLEXCAN_RXFIFO_USING_POLLING == state->transferType)
    997c:	9b05      	ldr	r3, [sp, #20]
    997e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    9982:	2b01      	cmp	r3, #1
    9984:	d102      	bne.n	998c <FlexCAN_StartRxMessageFifoData+0x54>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    9986:	9b05      	ldr	r3, [sp, #20]
    9988:	2201      	movs	r2, #1
    998a:	721a      	strb	r2, [r3, #8]
    }

    /* This will get filled by the interrupt handler */
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = data;
    998c:	9b05      	ldr	r3, [sp, #20]
    998e:	9a02      	ldr	r2, [sp, #8]
    9990:	601a      	str	r2, [r3, #0]

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    9992:	9b05      	ldr	r3, [sp, #20]
    9994:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    9998:	2b00      	cmp	r3, #0
    999a:	d123      	bne.n	99e4 <FlexCAN_StartRxMessageFifoData+0xac>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = FALSE;
    999c:	9b05      	ldr	r3, [sp, #20]
    999e:	2200      	movs	r2, #0
    99a0:	721a      	strb	r2, [r3, #8]
        /* Enable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, TRUE, state->isIntActive);
    99a2:	9b05      	ldr	r3, [sp, #20]
    99a4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    99a8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    99ac:	9300      	str	r3, [sp, #0]
    99ae:	2301      	movs	r3, #1
    99b0:	2206      	movs	r2, #6
    99b2:	9806      	ldr	r0, [sp, #24]
    99b4:	f002 fdbe 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, TRUE, state->isIntActive);
    99b8:	9b05      	ldr	r3, [sp, #20]
    99ba:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    99be:	f89d 100f 	ldrb.w	r1, [sp, #15]
    99c2:	9300      	str	r3, [sp, #0]
    99c4:	2301      	movs	r3, #1
    99c6:	2207      	movs	r2, #7
    99c8:	9806      	ldr	r0, [sp, #24]
    99ca:	f002 fdb3 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, TRUE, state->isIntActive);
    99ce:	9b05      	ldr	r3, [sp, #20]
    99d0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    99d4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    99d8:	9300      	str	r3, [sp, #0]
    99da:	2301      	movs	r3, #1
    99dc:	2205      	movs	r2, #5
    99de:	9806      	ldr	r0, [sp, #24]
    99e0:	f002 fda8 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    99e4:	9b07      	ldr	r3, [sp, #28]
}
    99e6:	4618      	mov	r0, r3
    99e8:	b009      	add	sp, #36	; 0x24
    99ea:	f85d fb04 	ldr.w	pc, [sp], #4
    99ee:	bf00      	nop
    99f0:	00010534 	.word	0x00010534
    99f4:	1fff8fb8 	.word	0x1fff8fb8

000099f8 <FlexCAN_IRQHandlerRxMB>:
 *
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerRxMB(uint8 instance, uint32 mb_idx)
{
    99f8:	b510      	push	{r4, lr}
    99fa:	b09e      	sub	sp, #120	; 0x78
    99fc:	4603      	mov	r3, r0
    99fe:	9102      	str	r1, [sp, #8]
    9a00:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    9a04:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9a08:	4a70      	ldr	r2, [pc, #448]	; (9bcc <FlexCAN_IRQHandlerRxMB+0x1d4>)
    9a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a0e:	931c      	str	r3, [sp, #112]	; 0x70
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    9a10:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9a14:	4a6e      	ldr	r2, [pc, #440]	; (9bd0 <FlexCAN_IRQHandlerRxMB+0x1d8>)
    9a16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1a:	931b      	str	r3, [sp, #108]	; 0x6c
    Flexcan_Ip_MsgBuffType data;
    boolean bCurrentIntStat = FALSE;
    9a1c:	2300      	movs	r3, #0
    9a1e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[mb_idx].pMBmessage  */
    if (NULL_PTR == state->mbs[mb_idx].pMBmessage)
    9a22:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9a24:	9b02      	ldr	r3, [sp, #8]
    9a26:	011b      	lsls	r3, r3, #4
    9a28:	4413      	add	r3, r2
    9a2a:	681b      	ldr	r3, [r3, #0]
    9a2c:	2b00      	cmp	r3, #0
    9a2e:	d105      	bne.n	9a3c <FlexCAN_IRQHandlerRxMB+0x44>
    {
        state->mbs[mb_idx].pMBmessage = &data;
    9a30:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9a32:	9b02      	ldr	r3, [sp, #8]
    9a34:	011b      	lsls	r3, r3, #4
    9a36:	4413      	add	r3, r2
    9a38:	aa05      	add	r2, sp, #20
    9a3a:	601a      	str	r2, [r3, #0]
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    boolean bIsCriticalSectionNeeded = FALSE;
    9a3c:	2300      	movs	r3, #0
    9a3e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77

    /* Expectation: the sequence will not be interrupted when it already in interupt context */
    if (TRUE == state->mbs[mb_idx].isPolling)
    9a42:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9a44:	9b02      	ldr	r3, [sp, #8]
    9a46:	011b      	lsls	r3, r3, #4
    9a48:	4413      	add	r3, r2
    9a4a:	3308      	adds	r3, #8
    9a4c:	781b      	ldrb	r3, [r3, #0]
    9a4e:	2b00      	cmp	r3, #0
    9a50:	d008      	beq.n	9a64 <FlexCAN_IRQHandlerRxMB+0x6c>
        if ((state->bIsLegacyFifoEn ||  state->bIsEnhancedFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #else
        if ((state->bIsLegacyFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    #elif defined (ERR_IPV_FLEXCAN_E050246)
        if (state->bIsLegacyFifoEn)
    9a52:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9a54:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    9a58:	2b00      	cmp	r3, #0
    9a5a:	d003      	beq.n	9a64 <FlexCAN_IRQHandlerRxMB+0x6c>
    #endif
        {
            bIsCriticalSectionNeeded = TRUE;
    9a5c:	2301      	movs	r3, #1
    9a5e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
            /* Disable all IRQs */
            OsIf_SuspendAllInterrupts();
    9a62:	b672      	cpsid	i
        }
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    /* Lock RX message buffer and RX FIFO*/
    FlexCAN_LockRxMsgBuff(base, mb_idx);
    9a64:	9902      	ldr	r1, [sp, #8]
    9a66:	981c      	ldr	r0, [sp, #112]	; 0x70
    9a68:	f002 fd55 	bl	c516 <FlexCAN_LockRxMsgBuff>

    /* Get RX MB field values*/
    FlexCAN_GetMsgBuff(base, mb_idx, state->mbs[mb_idx].pMBmessage);
    9a6c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9a6e:	9b02      	ldr	r3, [sp, #8]
    9a70:	011b      	lsls	r3, r3, #4
    9a72:	4413      	add	r3, r2
    9a74:	681b      	ldr	r3, [r3, #0]
    9a76:	461a      	mov	r2, r3
    9a78:	9902      	ldr	r1, [sp, #8]
    9a7a:	981c      	ldr	r0, [sp, #112]	; 0x70
    9a7c:	f002 fe7a 	bl	c774 <FlexCAN_GetMsgBuff>

    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    9a80:	9902      	ldr	r1, [sp, #8]
    9a82:	981c      	ldr	r0, [sp, #112]	; 0x70
    9a84:	f7ff faee 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>

#if defined (ERR_IPV_FLEXCAN_E050246)
    /* the CODE field is updated with an incorrect value when MBx is locked by software for more than 20 CAN bit times and FIFO enable.
    When the CODE field is corrupted, it's probably updated with any value that is invalid. Except EMPTY, FULL and OVERRUN other values can not make MB unlocked and move-in process. */
    if ((state->bIsLegacyFifoEn) && \
    9a88:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9a8a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    9a8e:	2b00      	cmp	r3, #0
    9a90:	d032      	beq.n	9af8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    9a92:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9a94:	9b02      	ldr	r3, [sp, #8]
    9a96:	011b      	lsls	r3, r3, #4
    9a98:	4413      	add	r3, r2
    9a9a:	681b      	ldr	r3, [r3, #0]
    9a9c:	681b      	ldr	r3, [r3, #0]
    9a9e:	0e1b      	lsrs	r3, r3, #24
    9aa0:	f003 030f 	and.w	r3, r3, #15
    if ((state->bIsLegacyFifoEn) && \
    9aa4:	2b02      	cmp	r3, #2
    9aa6:	d027      	beq.n	9af8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    9aa8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9aaa:	9b02      	ldr	r3, [sp, #8]
    9aac:	011b      	lsls	r3, r3, #4
    9aae:	4413      	add	r3, r2
    9ab0:	681b      	ldr	r3, [r3, #0]
    9ab2:	681b      	ldr	r3, [r3, #0]
    9ab4:	0e1b      	lsrs	r3, r3, #24
    9ab6:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    9aba:	2b04      	cmp	r3, #4
    9abc:	d01c      	beq.n	9af8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_OVERRUN != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)))
    9abe:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9ac0:	9b02      	ldr	r3, [sp, #8]
    9ac2:	011b      	lsls	r3, r3, #4
    9ac4:	4413      	add	r3, r2
    9ac6:	681b      	ldr	r3, [r3, #0]
    9ac8:	681b      	ldr	r3, [r3, #0]
    9aca:	0e1b      	lsrs	r3, r3, #24
    9acc:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    9ad0:	2b06      	cmp	r3, #6
    9ad2:	d011      	beq.n	9af8 <FlexCAN_IRQHandlerRxMB+0x100>
    {
        /* Update the cs code for next sequence move in MB.
        A CPU write into the C/S word also unlocks the MB */
        volatile uint32 *flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    9ad4:	9902      	ldr	r1, [sp, #8]
    9ad6:	981c      	ldr	r0, [sp, #112]	; 0x70
    9ad8:	f002 f9a4 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    9adc:	9019      	str	r0, [sp, #100]	; 0x64
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    9ade:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9ae0:	681b      	ldr	r3, [r3, #0]
    9ae2:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    9ae6:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9ae8:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (((uint32)FLEXCAN_RX_EMPTY) << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    9aea:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9aec:	681b      	ldr	r3, [r3, #0]
    9aee:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    9af2:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9af4:	601a      	str	r2, [r3, #0]
    {
    9af6:	e002      	b.n	9afe <FlexCAN_IRQHandlerRxMB+0x106>
    }
    else
#endif
    {
    /* Unlock RX message buffer and RX FIFO*/
    FlexCAN_UnlockRxMsgBuff(base);
    9af8:	981c      	ldr	r0, [sp, #112]	; 0x70
    9afa:	f7ff faac 	bl	9056 <FlexCAN_UnlockRxMsgBuff>
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    /* To ensure that interrupts are resumed when they are suspended */
    if (TRUE == bIsCriticalSectionNeeded)
    9afe:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
    9b02:	2b00      	cmp	r3, #0
    9b04:	d000      	beq.n	9b08 <FlexCAN_IRQHandlerRxMB+0x110>
    {
        /* Enable all IRQs */
        OsIf_ResumeAllInterrupts();
    9b06:	b662      	cpsie	i
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    9b08:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9b0a:	9b02      	ldr	r3, [sp, #8]
    9b0c:	011b      	lsls	r3, r3, #4
    9b0e:	4413      	add	r3, r2
    9b10:	3304      	adds	r3, #4
    9b12:	2200      	movs	r2, #0
    9b14:	601a      	str	r2, [r3, #0]

    bCurrentIntStat = state->mbs[mb_idx].isPolling;
    9b16:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9b18:	9b02      	ldr	r3, [sp, #8]
    9b1a:	011b      	lsls	r3, r3, #4
    9b1c:	4413      	add	r3, r2
    9b1e:	3308      	adds	r3, #8
    9b20:	781b      	ldrb	r3, [r3, #0]
    9b22:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* Invoke callback */
    if (state->callback != NULL_PTR)
    9b26:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9b28:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    9b2c:	2b00      	cmp	r3, #0
    9b2e:	d008      	beq.n	9b42 <FlexCAN_IRQHandlerRxMB+0x14a>
    {
        state->callback(instance, FLEXCAN_EVENT_RX_COMPLETE, mb_idx, state);
    9b30:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9b32:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    9b36:	f89d 000f 	ldrb.w	r0, [sp, #15]
    9b3a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9b3c:	9a02      	ldr	r2, [sp, #8]
    9b3e:	2100      	movs	r1, #0
    9b40:	47a0      	blx	r4
    }

    if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state) && (FALSE == state->mbs[mb_idx].isPolling))
    9b42:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9b44:	9b02      	ldr	r3, [sp, #8]
    9b46:	011b      	lsls	r3, r3, #4
    9b48:	4413      	add	r3, r2
    9b4a:	3304      	adds	r3, #4
    9b4c:	681b      	ldr	r3, [r3, #0]
    9b4e:	2b00      	cmp	r3, #0
    9b50:	d11e      	bne.n	9b90 <FlexCAN_IRQHandlerRxMB+0x198>
    9b52:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9b54:	9b02      	ldr	r3, [sp, #8]
    9b56:	011b      	lsls	r3, r3, #4
    9b58:	4413      	add	r3, r2
    9b5a:	3308      	adds	r3, #8
    9b5c:	781b      	ldrb	r3, [r3, #0]
    9b5e:	f083 0301 	eor.w	r3, r3, #1
    9b62:	b2db      	uxtb	r3, r3
    9b64:	2b00      	cmp	r3, #0
    9b66:	d013      	beq.n	9b90 <FlexCAN_IRQHandlerRxMB+0x198>
    {
        /* callback is not called, need to reset to default value */
        state->mbs[mb_idx].isPolling = TRUE;
    9b68:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9b6a:	9b02      	ldr	r3, [sp, #8]
    9b6c:	011b      	lsls	r3, r3, #4
    9b6e:	4413      	add	r3, r2
    9b70:	3308      	adds	r3, #8
    9b72:	2201      	movs	r2, #1
    9b74:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    9b76:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9b78:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9b7c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9b80:	9300      	str	r3, [sp, #0]
    9b82:	2300      	movs	r3, #0
    9b84:	9a02      	ldr	r2, [sp, #8]
    9b86:	981c      	ldr	r0, [sp, #112]	; 0x70
    9b88:	f002 fcd4 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    9b8c:	bf00      	nop
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    9b8e:	e019      	b.n	9bc4 <FlexCAN_IRQHandlerRxMB+0x1cc>
    else if ((FALSE == bCurrentIntStat) && (TRUE == state->mbs[mb_idx].isPolling))
    9b90:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
    9b94:	f083 0301 	eor.w	r3, r3, #1
    9b98:	b2db      	uxtb	r3, r3
    9b9a:	2b00      	cmp	r3, #0
    9b9c:	d012      	beq.n	9bc4 <FlexCAN_IRQHandlerRxMB+0x1cc>
    9b9e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    9ba0:	9b02      	ldr	r3, [sp, #8]
    9ba2:	011b      	lsls	r3, r3, #4
    9ba4:	4413      	add	r3, r2
    9ba6:	3308      	adds	r3, #8
    9ba8:	781b      	ldrb	r3, [r3, #0]
    9baa:	2b00      	cmp	r3, #0
    9bac:	d00a      	beq.n	9bc4 <FlexCAN_IRQHandlerRxMB+0x1cc>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    9bae:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9bb0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9bb4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9bb8:	9300      	str	r3, [sp, #0]
    9bba:	2300      	movs	r3, #0
    9bbc:	9a02      	ldr	r2, [sp, #8]
    9bbe:	981c      	ldr	r0, [sp, #112]	; 0x70
    9bc0:	f002 fcb8 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
}
    9bc4:	bf00      	nop
    9bc6:	b01e      	add	sp, #120	; 0x78
    9bc8:	bd10      	pop	{r4, pc}
    9bca:	bf00      	nop
    9bcc:	00010534 	.word	0x00010534
    9bd0:	1fff8fb8 	.word	0x1fff8fb8

00009bd4 <FlexCAN_IRQHandlerTxMB>:
 * note: just using in interrupt mode
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerTxMB(uint8 u8Instance, uint32 u32MbIdx)
{
    9bd4:	b510      	push	{r4, lr}
    9bd6:	b09a      	sub	sp, #104	; 0x68
    9bd8:	4603      	mov	r3, r0
    9bda:	9102      	str	r1, [sp, #8]
    9bdc:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    9be0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9be4:	4a46      	ldr	r2, [pc, #280]	; (9d00 <FlexCAN_IRQHandlerTxMB+0x12c>)
    9be6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bea:	9319      	str	r3, [sp, #100]	; 0x64
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    9bec:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9bf0:	4a44      	ldr	r2, [pc, #272]	; (9d04 <FlexCAN_IRQHandlerTxMB+0x130>)
    9bf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bf6:	9318      	str	r3, [sp, #96]	; 0x60
    Flexcan_Ip_MsgBuffType mb;
    mb.cs = 0U;
    9bf8:	2300      	movs	r3, #0
    9bfa:	9304      	str	r3, [sp, #16]
    mb.time_stamp = 0U;
    9bfc:	2300      	movs	r3, #0
    9bfe:	9317      	str	r3, [sp, #92]	; 0x5c
    if (pState->mbs[u32MbIdx].isRemote)
    9c00:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9c02:	9b02      	ldr	r3, [sp, #8]
    9c04:	011b      	lsls	r3, r3, #4
    9c06:	4413      	add	r3, r2
    9c08:	3309      	adds	r3, #9
    9c0a:	781b      	ldrb	r3, [r3, #0]
    9c0c:	2b00      	cmp	r3, #0
    9c0e:	d01e      	beq.n	9c4e <FlexCAN_IRQHandlerTxMB+0x7a>
    {
        FlexCAN_LockRxMsgBuff(pBase, u32MbIdx);
    9c10:	9902      	ldr	r1, [sp, #8]
    9c12:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c14:	f002 fc7f 	bl	c516 <FlexCAN_LockRxMsgBuff>
        FlexCAN_GetMsgBuff(pBase, u32MbIdx, &mb);
    9c18:	ab04      	add	r3, sp, #16
    9c1a:	461a      	mov	r2, r3
    9c1c:	9902      	ldr	r1, [sp, #8]
    9c1e:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c20:	f002 fda8 	bl	c774 <FlexCAN_GetMsgBuff>
        FlexCAN_UnlockRxMsgBuff(pBase);
    9c24:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c26:	f7ff fa16 	bl	9056 <FlexCAN_UnlockRxMsgBuff>
        pState->mbs[u32MbIdx].time_stamp = mb.time_stamp;
    9c2a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    9c2c:	9918      	ldr	r1, [sp, #96]	; 0x60
    9c2e:	9b02      	ldr	r3, [sp, #8]
    9c30:	011b      	lsls	r3, r3, #4
    9c32:	440b      	add	r3, r1
    9c34:	330c      	adds	r3, #12
    9c36:	601a      	str	r2, [r3, #0]
        /* If the frame was a remote frame, clear the flag only if the response was
        * not received yet. If the response was received, leave the flag set in order
        * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
        if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    9c38:	9b04      	ldr	r3, [sp, #16]
    9c3a:	0e1b      	lsrs	r3, r3, #24
    9c3c:	f003 030f 	and.w	r3, r3, #15
    9c40:	2b04      	cmp	r3, #4
    9c42:	d116      	bne.n	9c72 <FlexCAN_IRQHandlerTxMB+0x9e>
        {
            FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    9c44:	9902      	ldr	r1, [sp, #8]
    9c46:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c48:	f7ff fa0c 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
    9c4c:	e011      	b.n	9c72 <FlexCAN_IRQHandlerTxMB+0x9e>
        }
    }
    else
    {
        pState->mbs[u32MbIdx].time_stamp = FlexCAN_GetMsgBuffTimestamp(pBase, u32MbIdx);
    9c4e:	9902      	ldr	r1, [sp, #8]
    9c50:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c52:	f002 fd7b 	bl	c74c <FlexCAN_GetMsgBuffTimestamp>
    9c56:	4601      	mov	r1, r0
    9c58:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9c5a:	9b02      	ldr	r3, [sp, #8]
    9c5c:	011b      	lsls	r3, r3, #4
    9c5e:	4413      	add	r3, r2
    9c60:	330c      	adds	r3, #12
    9c62:	6019      	str	r1, [r3, #0]
        FlexCAN_UnlockRxMsgBuff(pBase);
    9c64:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c66:	f7ff f9f6 	bl	9056 <FlexCAN_UnlockRxMsgBuff>
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    9c6a:	9902      	ldr	r1, [sp, #8]
    9c6c:	9819      	ldr	r0, [sp, #100]	; 0x64
    9c6e:	f7ff f9f9 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }

    pState->mbs[u32MbIdx].state = FLEXCAN_MB_IDLE;
    9c72:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9c74:	9b02      	ldr	r3, [sp, #8]
    9c76:	011b      	lsls	r3, r3, #4
    9c78:	4413      	add	r3, r2
    9c7a:	3304      	adds	r3, #4
    9c7c:	2200      	movs	r2, #0
    9c7e:	601a      	str	r2, [r3, #0]

    /* Invoke callback */
    if (pState->callback != NULL_PTR)
    9c80:	9b18      	ldr	r3, [sp, #96]	; 0x60
    9c82:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    9c86:	2b00      	cmp	r3, #0
    9c88:	d008      	beq.n	9c9c <FlexCAN_IRQHandlerTxMB+0xc8>
    {
        pState->callback(u8Instance, FLEXCAN_EVENT_TX_COMPLETE, u32MbIdx, pState);
    9c8a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    9c8c:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    9c90:	f89d 000f 	ldrb.w	r0, [sp, #15]
    9c94:	9b18      	ldr	r3, [sp, #96]	; 0x60
    9c96:	9a02      	ldr	r2, [sp, #8]
    9c98:	2104      	movs	r1, #4
    9c9a:	47a0      	blx	r4
    }

    if (FLEXCAN_MB_IDLE == pState->mbs[u32MbIdx].state)
    9c9c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9c9e:	9b02      	ldr	r3, [sp, #8]
    9ca0:	011b      	lsls	r3, r3, #4
    9ca2:	4413      	add	r3, r2
    9ca4:	3304      	adds	r3, #4
    9ca6:	681b      	ldr	r3, [r3, #0]
    9ca8:	2b00      	cmp	r3, #0
    9caa:	d112      	bne.n	9cd2 <FlexCAN_IRQHandlerTxMB+0xfe>
    {
        /* callback is not called, need to reset to default value */
        pState->mbs[u32MbIdx].isPolling = TRUE;
    9cac:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9cae:	9b02      	ldr	r3, [sp, #8]
    9cb0:	011b      	lsls	r3, r3, #4
    9cb2:	4413      	add	r3, r2
    9cb4:	3308      	adds	r3, #8
    9cb6:	2201      	movs	r2, #1
    9cb8:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    9cba:	9b18      	ldr	r3, [sp, #96]	; 0x60
    9cbc:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9cc0:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9cc4:	9300      	str	r3, [sp, #0]
    9cc6:	2300      	movs	r3, #0
    9cc8:	9a02      	ldr	r2, [sp, #8]
    9cca:	9819      	ldr	r0, [sp, #100]	; 0x64
    9ccc:	f002 fc32 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    9cd0:	e012      	b.n	9cf8 <FlexCAN_IRQHandlerTxMB+0x124>
    else if (TRUE == pState->mbs[u32MbIdx].isPolling)
    9cd2:	9a18      	ldr	r2, [sp, #96]	; 0x60
    9cd4:	9b02      	ldr	r3, [sp, #8]
    9cd6:	011b      	lsls	r3, r3, #4
    9cd8:	4413      	add	r3, r2
    9cda:	3308      	adds	r3, #8
    9cdc:	781b      	ldrb	r3, [r3, #0]
    9cde:	2b00      	cmp	r3, #0
    9ce0:	d00a      	beq.n	9cf8 <FlexCAN_IRQHandlerTxMB+0x124>
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    9ce2:	9b18      	ldr	r3, [sp, #96]	; 0x60
    9ce4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9ce8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    9cec:	9300      	str	r3, [sp, #0]
    9cee:	2300      	movs	r3, #0
    9cf0:	9a02      	ldr	r2, [sp, #8]
    9cf2:	9819      	ldr	r0, [sp, #100]	; 0x64
    9cf4:	f002 fc1e 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
}
    9cf8:	bf00      	nop
    9cfa:	b01a      	add	sp, #104	; 0x68
    9cfc:	bd10      	pop	{r4, pc}
    9cfe:	bf00      	nop
    9d00:	00010534 	.word	0x00010534
    9d04:	1fff8fb8 	.word	0x1fff8fb8

00009d08 <FlexCAN_IRQHandlerRxFIFO>:
 * Function Name : FlexCAN_IRQHandlerRxFIFO
 * Description   : Process IRQHandler in case of RxFIFO mode selection for CAN interface.
 *
 *END**************************************************************************/
static inline void FlexCAN_IRQHandlerRxFIFO(uint8 instance, uint32 mb_idx)
{
    9d08:	b510      	push	{r4, lr}
    9d0a:	b098      	sub	sp, #96	; 0x60
    9d0c:	4603      	mov	r3, r0
    9d0e:	9100      	str	r1, [sp, #0]
    9d10:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    9d14:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9d18:	4a3c      	ldr	r2, [pc, #240]	; (9e0c <FlexCAN_IRQHandlerRxFIFO+0x104>)
    9d1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d1e:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    9d20:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9d24:	4a3a      	ldr	r2, [pc, #232]	; (9e10 <FlexCAN_IRQHandlerRxFIFO+0x108>)
    9d26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d2a:	9316      	str	r3, [sp, #88]	; 0x58
    Flexcan_Ip_MsgBuffType data;

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage  */
    if (NULL_PTR == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage)
    9d2c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d2e:	681b      	ldr	r3, [r3, #0]
    9d30:	2b00      	cmp	r3, #0
    9d32:	d102      	bne.n	9d3a <FlexCAN_IRQHandlerRxFIFO+0x32>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = &data;
    9d34:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d36:	aa02      	add	r2, sp, #8
    9d38:	601a      	str	r2, [r3, #0]
    }
    switch (mb_idx)
    9d3a:	9b00      	ldr	r3, [sp, #0]
    9d3c:	2b07      	cmp	r3, #7
    9d3e:	d048      	beq.n	9dd2 <FlexCAN_IRQHandlerRxFIFO+0xca>
    9d40:	9b00      	ldr	r3, [sp, #0]
    9d42:	2b07      	cmp	r3, #7
    9d44:	d858      	bhi.n	9df8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
    9d46:	9b00      	ldr	r3, [sp, #0]
    9d48:	2b05      	cmp	r3, #5
    9d4a:	d003      	beq.n	9d54 <FlexCAN_IRQHandlerRxFIFO+0x4c>
    9d4c:	9b00      	ldr	r3, [sp, #0]
    9d4e:	2b06      	cmp	r3, #6
    9d50:	d02c      	beq.n	9dac <FlexCAN_IRQHandlerRxFIFO+0xa4>
            }

            break;
        default:
            /* Do Nothing */
            break;
    9d52:	e051      	b.n	9df8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
            if (FLEXCAN_MB_RX_BUSY == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    9d54:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d56:	685b      	ldr	r3, [r3, #4]
    9d58:	2b01      	cmp	r3, #1
    9d5a:	d14f      	bne.n	9dfc <FlexCAN_IRQHandlerRxFIFO+0xf4>
                FlexCAN_ReadRxFifo(base, state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage);
    9d5c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d5e:	681b      	ldr	r3, [r3, #0]
    9d60:	4619      	mov	r1, r3
    9d62:	9817      	ldr	r0, [sp, #92]	; 0x5c
    9d64:	f003 f98d 	bl	d082 <FlexCAN_ReadRxFifo>
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    9d68:	9900      	ldr	r1, [sp, #0]
    9d6a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    9d6c:	f7ff f97a 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
                state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    9d70:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d72:	2200      	movs	r2, #0
    9d74:	605a      	str	r2, [r3, #4]
                if (state->callback != NULL_PTR)
    9d76:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d78:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    9d7c:	2b00      	cmp	r3, #0
    9d7e:	d008      	beq.n	9d92 <FlexCAN_IRQHandlerRxFIFO+0x8a>
                    state->callback(instance, FLEXCAN_EVENT_RXFIFO_COMPLETE, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    9d80:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d82:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    9d86:	f89d 0007 	ldrb.w	r0, [sp, #7]
    9d8a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d8c:	2200      	movs	r2, #0
    9d8e:	2101      	movs	r1, #1
    9d90:	47a0      	blx	r4
                if (FLEXCAN_MB_IDLE == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    9d92:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d94:	685b      	ldr	r3, [r3, #4]
    9d96:	2b00      	cmp	r3, #0
    9d98:	d130      	bne.n	9dfc <FlexCAN_IRQHandlerRxFIFO+0xf4>
                    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    9d9a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9d9c:	2201      	movs	r2, #1
    9d9e:	721a      	strb	r2, [r3, #8]
                    FlexCAN_CompleteRxMessageFifoData(instance);
    9da0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9da4:	4618      	mov	r0, r3
    9da6:	f000 fc61 	bl	a66c <FlexCAN_CompleteRxMessageFifoData>
            break;
    9daa:	e027      	b.n	9dfc <FlexCAN_IRQHandlerRxFIFO+0xf4>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    9dac:	9900      	ldr	r1, [sp, #0]
    9dae:	9817      	ldr	r0, [sp, #92]	; 0x5c
    9db0:	f7ff f958 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    9db4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9db6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    9dba:	2b00      	cmp	r3, #0
    9dbc:	d020      	beq.n	9e00 <FlexCAN_IRQHandlerRxFIFO+0xf8>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_WARNING, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    9dbe:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9dc0:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    9dc4:	f89d 0007 	ldrb.w	r0, [sp, #7]
    9dc8:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9dca:	2200      	movs	r2, #0
    9dcc:	2102      	movs	r1, #2
    9dce:	47a0      	blx	r4
            break;
    9dd0:	e016      	b.n	9e00 <FlexCAN_IRQHandlerRxFIFO+0xf8>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    9dd2:	9900      	ldr	r1, [sp, #0]
    9dd4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    9dd6:	f7ff f945 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    9dda:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9ddc:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    9de0:	2b00      	cmp	r3, #0
    9de2:	d00f      	beq.n	9e04 <FlexCAN_IRQHandlerRxFIFO+0xfc>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_OVERFLOW, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    9de4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9de6:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    9dea:	f89d 0007 	ldrb.w	r0, [sp, #7]
    9dee:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9df0:	2200      	movs	r2, #0
    9df2:	2103      	movs	r1, #3
    9df4:	47a0      	blx	r4
            break;
    9df6:	e005      	b.n	9e04 <FlexCAN_IRQHandlerRxFIFO+0xfc>
            break;
    9df8:	bf00      	nop
    9dfa:	e004      	b.n	9e06 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    9dfc:	bf00      	nop
    9dfe:	e002      	b.n	9e06 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    9e00:	bf00      	nop
    9e02:	e000      	b.n	9e06 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    9e04:	bf00      	nop
    }
}
    9e06:	bf00      	nop
    9e08:	b018      	add	sp, #96	; 0x60
    9e0a:	bd10      	pop	{r4, pc}
    9e0c:	00010534 	.word	0x00010534
    9e10:	1fff8fb8 	.word	0x1fff8fb8

00009e14 <FlexCAN_AbortTxTransfer>:
 * Description   : Abort transfer for Tx buffer.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_AbortTxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    9e14:	b500      	push	{lr}
    9e16:	b08b      	sub	sp, #44	; 0x2c
    9e18:	4603      	mov	r3, r0
    9e1a:	460a      	mov	r2, r1
    9e1c:	f88d 3007 	strb.w	r3, [sp, #7]
    9e20:	4613      	mov	r3, r2
    9e22:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    9e26:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9e2a:	4a3c      	ldr	r2, [pc, #240]	; (9f1c <FlexCAN_AbortTxTransfer+0x108>)
    9e2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e30:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    9e32:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9e36:	4a3a      	ldr	r2, [pc, #232]	; (9f20 <FlexCAN_AbortTxTransfer+0x10c>)
    9e38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e3c:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    9e3e:	2300      	movs	r3, #0
    9e40:	9309      	str	r3, [sp, #36]	; 0x24

    uint32 timeStart = 0U;
    9e42:	2300      	movs	r3, #0
    9e44:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9e46:	2300      	movs	r3, #0
    9e48:	9308      	str	r3, [sp, #32]
    uint32 flexcan_mb_config = 0;
    9e4a:	2300      	movs	r3, #0
    9e4c:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = 0U;
    9e4e:	2300      	movs	r3, #0
    9e50:	9304      	str	r3, [sp, #16]
    volatile uint32 * flexcan_mb = NULL_PTR;
    9e52:	2300      	movs	r3, #0
    9e54:	9303      	str	r3, [sp, #12]

    flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    9e56:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9e5a:	4619      	mov	r1, r3
    9e5c:	9807      	ldr	r0, [sp, #28]
    9e5e:	f001 ffe1 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    9e62:	9003      	str	r0, [sp, #12]
    flexcan_mb_config = * flexcan_mb;
    9e64:	9b03      	ldr	r3, [sp, #12]
    9e66:	681b      	ldr	r3, [r3, #0]
    9e68:	9305      	str	r3, [sp, #20]
    /* Reset the code */
    flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    9e6a:	9b05      	ldr	r3, [sp, #20]
    9e6c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    9e70:	9305      	str	r3, [sp, #20]
    flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    9e72:	9b05      	ldr	r3, [sp, #20]
    9e74:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    9e78:	9305      	str	r3, [sp, #20]
    *flexcan_mb = flexcan_mb_config;
    9e7a:	9b03      	ldr	r3, [sp, #12]
    9e7c:	9a05      	ldr	r2, [sp, #20]
    9e7e:	601a      	str	r2, [r3, #0]

    /* Wait to finish abort operation */
    uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9e80:	2100      	movs	r1, #0
    9e82:	4828      	ldr	r0, [pc, #160]	; (9f24 <FlexCAN_AbortTxTransfer+0x110>)
    9e84:	f7f8 fa08 	bl	2298 <OsIf_MicrosToTicks>
    9e88:	9004      	str	r0, [sp, #16]
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9e8a:	2000      	movs	r0, #0
    9e8c:	f7f8 f9b8 	bl	2200 <OsIf_GetCounter>
    9e90:	4603      	mov	r3, r0
    9e92:	9302      	str	r3, [sp, #8]
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    9e94:	e00f      	b.n	9eb6 <FlexCAN_AbortTxTransfer+0xa2>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9e96:	ab02      	add	r3, sp, #8
    9e98:	2100      	movs	r1, #0
    9e9a:	4618      	mov	r0, r3
    9e9c:	f7f8 f9c9 	bl	2232 <OsIf_GetElapsed>
    9ea0:	4602      	mov	r2, r0
    9ea2:	9b08      	ldr	r3, [sp, #32]
    9ea4:	4413      	add	r3, r2
    9ea6:	9308      	str	r3, [sp, #32]
        if (timeElapsed >= uS2Ticks)
    9ea8:	9a08      	ldr	r2, [sp, #32]
    9eaa:	9b04      	ldr	r3, [sp, #16]
    9eac:	429a      	cmp	r2, r3
    9eae:	d302      	bcc.n	9eb6 <FlexCAN_AbortTxTransfer+0xa2>
        {
            result = FLEXCAN_STATUS_TIMEOUT;
    9eb0:	2303      	movs	r3, #3
    9eb2:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    9eb4:	e008      	b.n	9ec8 <FlexCAN_AbortTxTransfer+0xb4>
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    9eb6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9eba:	4619      	mov	r1, r3
    9ebc:	9807      	ldr	r0, [sp, #28]
    9ebe:	f7ff f8e4 	bl	908a <FlexCAN_GetBuffStatusFlag>
    9ec2:	4603      	mov	r3, r0
    9ec4:	2b00      	cmp	r3, #0
    9ec6:	d0e6      	beq.n	9e96 <FlexCAN_AbortTxTransfer+0x82>
        }
    }
    if (result != FLEXCAN_STATUS_TIMEOUT)
    9ec8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9eca:	2b03      	cmp	r3, #3
    9ecc:	d012      	beq.n	9ef4 <FlexCAN_AbortTxTransfer+0xe0>
    {
        flexcan_mb_config = *flexcan_mb;
    9ece:	9b03      	ldr	r3, [sp, #12]
    9ed0:	681b      	ldr	r3, [r3, #0]
    9ed2:	9305      	str	r3, [sp, #20]
        /* Check if the MBs have been safely Inactivated */
        if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    9ed4:	9b05      	ldr	r3, [sp, #20]
    9ed6:	0e1b      	lsrs	r3, r3, #24
    9ed8:	f003 030f 	and.w	r3, r3, #15
    9edc:	2b08      	cmp	r3, #8
    9ede:	d101      	bne.n	9ee4 <FlexCAN_AbortTxTransfer+0xd0>
        {
            /* Transmission have occurred */
            result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    9ee0:	2305      	movs	r3, #5
    9ee2:	9309      	str	r3, [sp, #36]	; 0x24
        }

        if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    9ee4:	9b05      	ldr	r3, [sp, #20]
    9ee6:	0e1b      	lsrs	r3, r3, #24
    9ee8:	f003 030f 	and.w	r3, r3, #15
    9eec:	2b09      	cmp	r3, #9
    9eee:	d101      	bne.n	9ef4 <FlexCAN_AbortTxTransfer+0xe0>
        {
            /* Transmission have been aborted */
            result = FLEXCAN_STATUS_SUCCESS;
    9ef0:	2300      	movs	r3, #0
    9ef2:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    9ef4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9ef8:	4619      	mov	r1, r3
    9efa:	9807      	ldr	r0, [sp, #28]
    9efc:	f7ff f8b2 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    9f00:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9f04:	9a06      	ldr	r2, [sp, #24]
    9f06:	011b      	lsls	r3, r3, #4
    9f08:	4413      	add	r3, r2
    9f0a:	3304      	adds	r3, #4
    9f0c:	2200      	movs	r2, #0
    9f0e:	601a      	str	r2, [r3, #0]

    return result;
    9f10:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    9f12:	4618      	mov	r0, r3
    9f14:	b00b      	add	sp, #44	; 0x2c
    9f16:	f85d fb04 	ldr.w	pc, [sp], #4
    9f1a:	bf00      	nop
    9f1c:	00010534 	.word	0x00010534
    9f20:	1fff8fb8 	.word	0x1fff8fb8
    9f24:	000f4240 	.word	0x000f4240

00009f28 <FlexCAN_AbortRxTransfer>:
 * Description   : Abort transfer for Rx normal or legacy fifo if enabled.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static void FlexCAN_AbortRxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    9f28:	b500      	push	{lr}
    9f2a:	b089      	sub	sp, #36	; 0x24
    9f2c:	4603      	mov	r3, r0
    9f2e:	460a      	mov	r2, r1
    9f30:	f88d 3007 	strb.w	r3, [sp, #7]
    9f34:	4613      	mov	r3, r2
    9f36:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    9f3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9f3e:	4a41      	ldr	r2, [pc, #260]	; (a044 <FlexCAN_AbortRxTransfer+0x11c>)
    9f40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f44:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    9f46:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9f4a:	4a3f      	ldr	r2, [pc, #252]	; (a048 <FlexCAN_AbortRxTransfer+0x120>)
    9f4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f50:	9306      	str	r3, [sp, #24]
    uint8 val1 = 0U;
    9f52:	2300      	movs	r3, #0
    9f54:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 val2 = 0U;
    9f58:	2300      	movs	r3, #0
    9f5a:	9304      	str	r3, [sp, #16]
    uint32 flexcan_mb_config = 0;
    9f5c:	2300      	movs	r3, #0
    9f5e:	9303      	str	r3, [sp, #12]
    volatile uint32 * flexcan_mb = NULL_PTR;
    9f60:	2300      	movs	r3, #0
    9f62:	9302      	str	r3, [sp, #8]

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    9f64:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9f68:	9a06      	ldr	r2, [sp, #24]
    9f6a:	011b      	lsls	r3, r3, #4
    9f6c:	4413      	add	r3, r2
    9f6e:	3304      	adds	r3, #4
    9f70:	2200      	movs	r2, #0
    9f72:	601a      	str	r2, [r3, #0]
    /* Check if fifo enabled */
    if (TRUE == state->bIsLegacyFifoEn)
    9f74:	9b06      	ldr	r3, [sp, #24]
    9f76:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    9f7a:	2b00      	cmp	r3, #0
    9f7c:	d03c      	beq.n	9ff8 <FlexCAN_AbortRxTransfer+0xd0>
    {
        /* Get the number of RX FIFO Filters*/
        val1 = (uint8)(((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    9f7e:	9b07      	ldr	r3, [sp, #28]
    9f80:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9f82:	0e1b      	lsrs	r3, r3, #24
    9f84:	b2db      	uxtb	r3, r3
    9f86:	f003 030f 	and.w	r3, r3, #15
    9f8a:	f88d 3017 	strb.w	r3, [sp, #23]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        val2 = RxFifoOcuppiedLastMsgBuff(val1);
    9f8e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    9f92:	4618      	mov	r0, r3
    9f94:	f7ff f9f3 	bl	937e <RxFifoOcuppiedLastMsgBuff>
    9f98:	9004      	str	r0, [sp, #16]
        if (mb_idx > val2)
    9f9a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9f9e:	9a04      	ldr	r2, [sp, #16]
    9fa0:	429a      	cmp	r2, r3
    9fa2:	d21b      	bcs.n	9fdc <FlexCAN_AbortRxTransfer+0xb4>
        {
            /* This operation is not allowed for MB that are part of RxFIFO */
            flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    9fa4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9fa8:	4619      	mov	r1, r3
    9faa:	9807      	ldr	r0, [sp, #28]
    9fac:	f001 ff3a 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    9fb0:	9002      	str	r0, [sp, #8]
            flexcan_mb_config = * flexcan_mb;
    9fb2:	9b02      	ldr	r3, [sp, #8]
    9fb4:	681b      	ldr	r3, [r3, #0]
    9fb6:	9303      	str	r3, [sp, #12]
            /* Reset the code and unlock the MB */
            flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    9fb8:	9b03      	ldr	r3, [sp, #12]
    9fba:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    9fbe:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
            *flexcan_mb = flexcan_mb_config;
    9fc0:	9b02      	ldr	r3, [sp, #8]
    9fc2:	9a03      	ldr	r2, [sp, #12]
    9fc4:	601a      	str	r2, [r3, #0]
            /* Reconfigure The MB as left by RxMBconfig */
            flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    9fc6:	9b03      	ldr	r3, [sp, #12]
    9fc8:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    9fcc:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    9fce:	9b03      	ldr	r3, [sp, #12]
    9fd0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    9fd4:	9303      	str	r3, [sp, #12]
            *flexcan_mb = flexcan_mb_config;
    9fd6:	9b02      	ldr	r3, [sp, #8]
    9fd8:	9a03      	ldr	r2, [sp, #12]
    9fda:	601a      	str	r2, [r3, #0]
        }
        if (FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    9fdc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9fe0:	2b00      	cmp	r3, #0
    9fe2:	d125      	bne.n	a030 <FlexCAN_AbortRxTransfer+0x108>
        {
            FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, state->isIntActive);
    9fe4:	9b06      	ldr	r3, [sp, #24]
    9fe6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9fea:	f89d 1007 	ldrb.w	r1, [sp, #7]
    9fee:	2205      	movs	r2, #5
    9ff0:	9807      	ldr	r0, [sp, #28]
    9ff2:	f002 faf5 	bl	c5e0 <FLEXCAN_ClearMsgBuffIntCmd>
    9ff6:	e01b      	b.n	a030 <FlexCAN_AbortRxTransfer+0x108>
        }
    }
    else
    {
        /* This operation is not allowed for MB that are part of RxFIFO */
        flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    9ff8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9ffc:	4619      	mov	r1, r3
    9ffe:	9807      	ldr	r0, [sp, #28]
    a000:	f001 ff10 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    a004:	9002      	str	r0, [sp, #8]
        flexcan_mb_config = * flexcan_mb;
    a006:	9b02      	ldr	r3, [sp, #8]
    a008:	681b      	ldr	r3, [r3, #0]
    a00a:	9303      	str	r3, [sp, #12]
        /* Reset the code and unlock the MB */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    a00c:	9b03      	ldr	r3, [sp, #12]
    a00e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    a012:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
        *flexcan_mb = flexcan_mb_config;
    a014:	9b02      	ldr	r3, [sp, #8]
    a016:	9a03      	ldr	r2, [sp, #12]
    a018:	601a      	str	r2, [r3, #0]
        /* Reconfigure The MB as left by RxMBconfig */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    a01a:	9b03      	ldr	r3, [sp, #12]
    a01c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    a020:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    a022:	9b03      	ldr	r3, [sp, #12]
    a024:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    a028:	9303      	str	r3, [sp, #12]
        *flexcan_mb = flexcan_mb_config;
    a02a:	9b02      	ldr	r3, [sp, #8]
    a02c:	9a03      	ldr	r2, [sp, #12]
    a02e:	601a      	str	r2, [r3, #0]
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    a030:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a034:	4619      	mov	r1, r3
    a036:	9807      	ldr	r0, [sp, #28]
    a038:	f7ff f814 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
}
    a03c:	bf00      	nop
    a03e:	b009      	add	sp, #36	; 0x24
    a040:	f85d fb04 	ldr.w	pc, [sp], #4
    a044:	00010534 	.word	0x00010534
    a048:	1fff8fb8 	.word	0x1fff8fb8

0000a04c <FlexCAN_Ip_Init_Privileged>:
/* implements FlexCAN_Ip_Init_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Init_Privileged(uint8 Flexcan_Ip_u8Instance,
                                                 Flexcan_Ip_StateType * Flexcan_Ip_pState,
                                                 const Flexcan_Ip_ConfigType * Flexcan_Ip_pData
                                                )
{
    a04c:	b500      	push	{lr}
    a04e:	b089      	sub	sp, #36	; 0x24
    a050:	4603      	mov	r3, r0
    a052:	9102      	str	r1, [sp, #8]
    a054:	9201      	str	r2, [sp, #4]
    a056:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a05a:	2300      	movs	r3, #0
    a05c:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    a05e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a062:	4a36      	ldr	r2, [pc, #216]	; (a13c <FlexCAN_Ip_Init_Privileged+0xf0>)
    a064:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a068:	9305      	str	r3, [sp, #20]
    {
        OsIf_Trusted_Call1param(FlexCAN_SetUserAccessAllowed, pBase);
    }
#endif

    eResult = FlexCAN_InitController(Flexcan_Ip_u8Instance, pBase, Flexcan_Ip_pData);
    a06a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a06e:	9a01      	ldr	r2, [sp, #4]
    a070:	9905      	ldr	r1, [sp, #20]
    a072:	4618      	mov	r0, r3
    a074:	f7ff fa84 	bl	9580 <FlexCAN_InitController>
    a078:	9006      	str	r0, [sp, #24]
    if (FLEXCAN_STATUS_SUCCESS == eResult)
    a07a:	9b06      	ldr	r3, [sp, #24]
    a07c:	2b00      	cmp	r3, #0
    a07e:	d158      	bne.n	a132 <FlexCAN_Ip_Init_Privileged+0xe6>
    {
        /* Init Baudrate */
        FlexCAN_InitBaudrate(pBase, Flexcan_Ip_pData);
    a080:	9901      	ldr	r1, [sp, #4]
    a082:	9805      	ldr	r0, [sp, #20]
    a084:	f7ff fad6 	bl	9634 <FlexCAN_InitBaudrate>
        /* Select mode */
        FlexCAN_SetOperationMode(pBase, Flexcan_Ip_pData->flexcanMode);
    a088:	9b01      	ldr	r3, [sp, #4]
    a08a:	68db      	ldr	r3, [r3, #12]
    a08c:	4619      	mov	r1, r3
    a08e:	9805      	ldr	r0, [sp, #20]
    a090:	f002 fdb8 	bl	cc04 <FlexCAN_SetOperationMode>

#if (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON)
        FlexCAN_ConfigTimestamp(Flexcan_Ip_u8Instance, pBase, (const Flexcan_Ip_TimeStampConfigType *)(&Flexcan_Ip_pData->time_stamp));
#endif   /* (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON) */

        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    a094:	2300      	movs	r3, #0
    a096:	9307      	str	r3, [sp, #28]
    a098:	e01d      	b.n	a0d6 <FlexCAN_Ip_Init_Privileged+0x8a>
        {
            /* Check if blocking need to be any more present in sync\async discussions */
            /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
            Flexcan_Ip_pState->mbs[i].isPolling = TRUE;
    a09a:	9a02      	ldr	r2, [sp, #8]
    a09c:	9b07      	ldr	r3, [sp, #28]
    a09e:	011b      	lsls	r3, r3, #4
    a0a0:	4413      	add	r3, r2
    a0a2:	3308      	adds	r3, #8
    a0a4:	2201      	movs	r2, #1
    a0a6:	701a      	strb	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].pMBmessage = NULL_PTR;
    a0a8:	9a02      	ldr	r2, [sp, #8]
    a0aa:	9b07      	ldr	r3, [sp, #28]
    a0ac:	011b      	lsls	r3, r3, #4
    a0ae:	4413      	add	r3, r2
    a0b0:	2200      	movs	r2, #0
    a0b2:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].state = FLEXCAN_MB_IDLE;
    a0b4:	9a02      	ldr	r2, [sp, #8]
    a0b6:	9b07      	ldr	r3, [sp, #28]
    a0b8:	011b      	lsls	r3, r3, #4
    a0ba:	4413      	add	r3, r2
    a0bc:	3304      	adds	r3, #4
    a0be:	2200      	movs	r2, #0
    a0c0:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].time_stamp = 0U;
    a0c2:	9a02      	ldr	r2, [sp, #8]
    a0c4:	9b07      	ldr	r3, [sp, #28]
    a0c6:	011b      	lsls	r3, r3, #4
    a0c8:	4413      	add	r3, r2
    a0ca:	330c      	adds	r3, #12
    a0cc:	2200      	movs	r2, #0
    a0ce:	601a      	str	r2, [r3, #0]
        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    a0d0:	9b07      	ldr	r3, [sp, #28]
    a0d2:	3301      	adds	r3, #1
    a0d4:	9307      	str	r3, [sp, #28]
    a0d6:	9b07      	ldr	r3, [sp, #28]
    a0d8:	2b1f      	cmp	r3, #31
    a0da:	d9de      	bls.n	a09a <FlexCAN_Ip_Init_Privileged+0x4e>
        /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
        Flexcan_Ip_pState->enhancedFifoOutput.isPolling = TRUE;
        Flexcan_Ip_pState->enhancedFifoOutput.state = FLEXCAN_MB_IDLE;
#endif

        Flexcan_Ip_pState->transferType = Flexcan_Ip_pData->transfer_type;
    a0dc:	9b01      	ldr	r3, [sp, #4]
    a0de:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    a0e0:	9b02      	ldr	r3, [sp, #8]
    a0e2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        Flexcan_Ip_pState->u32NumOfMbTransferByDMA = Flexcan_Ip_pData->num_enhanced_watermark;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

        /* Clear Callbacks in case of autovariables garbage */
        Flexcan_Ip_pState->callback = Flexcan_Ip_pData->Callback;
    a0e6:	9b01      	ldr	r3, [sp, #4]
    a0e8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a0ea:	9b02      	ldr	r3, [sp, #8]
    a0ec:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        Flexcan_Ip_pState->callbackParam = NULL_PTR;
    a0f0:	9b02      	ldr	r3, [sp, #8]
    a0f2:	2200      	movs	r2, #0
    a0f4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
        Flexcan_Ip_pState->error_callback = Flexcan_Ip_pData->ErrorCallback;
    a0f8:	9b01      	ldr	r3, [sp, #4]
    a0fa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    a0fc:	9b02      	ldr	r3, [sp, #8]
    a0fe:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
        Flexcan_Ip_pState->errorCallbackParam = NULL_PTR;
    a102:	9b02      	ldr	r3, [sp, #8]
    a104:	2200      	movs	r2, #0
    a106:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
        Flexcan_Ip_pState->bIsLegacyFifoEn = Flexcan_Ip_pData->is_rx_fifo_needed;
    a10a:	9b01      	ldr	r3, [sp, #4]
    a10c:	7a1a      	ldrb	r2, [r3, #8]
    a10e:	9b02      	ldr	r3, [sp, #8]
    a110:	f883 2214 	strb.w	r2, [r3, #532]	; 0x214
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
        Flexcan_Ip_pState->bIsEnhancedFifoEn = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
        Flexcan_Ip_pState->u32MaxMbNum = Flexcan_Ip_pData->max_num_mb;
    a114:	9b01      	ldr	r3, [sp, #4]
    a116:	681a      	ldr	r2, [r3, #0]
    a118:	9b02      	ldr	r3, [sp, #8]
    a11a:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
        Flexcan_Ip_pState->isIntActive = TRUE;
    a11e:	9b02      	ldr	r3, [sp, #8]
    a120:	2201      	movs	r2, #1
    a122:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        /* Save runtime structure pointers so irq handler can point to the correct state structure */
        Flexcan_Ip_apxState[Flexcan_Ip_u8Instance] = Flexcan_Ip_pState;
    a126:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a12a:	4905      	ldr	r1, [pc, #20]	; (a140 <FlexCAN_Ip_Init_Privileged+0xf4>)
    a12c:	9a02      	ldr	r2, [sp, #8]
    a12e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return eResult;
    a132:	9b06      	ldr	r3, [sp, #24]
}
    a134:	4618      	mov	r0, r3
    a136:	b009      	add	sp, #36	; 0x24
    a138:	f85d fb04 	ldr.w	pc, [sp], #4
    a13c:	00010534 	.word	0x00010534
    a140:	1fff8fb8 	.word	0x1fff8fb8

0000a144 <FlexCAN_Ip_Send>:
                                      uint8 mb_idx,
                                      const Flexcan_Ip_DataInfoType * tx_info,
                                      uint32 msg_id,
                                      const uint8 * mb_data
                                     )
{
    a144:	b500      	push	{lr}
    a146:	b08b      	sub	sp, #44	; 0x2c
    a148:	9204      	str	r2, [sp, #16]
    a14a:	9303      	str	r3, [sp, #12]
    a14c:	4603      	mov	r3, r0
    a14e:	f88d 3017 	strb.w	r3, [sp, #23]
    a152:	460b      	mov	r3, r1
    a154:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    a158:	2301      	movs	r3, #1
    a15a:	9309      	str	r3, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a15c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a160:	4a1c      	ldr	r2, [pc, #112]	; (a1d4 <FlexCAN_Ip_Send+0x90>)
    a162:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a166:	9308      	str	r3, [sp, #32]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a168:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a16c:	4a1a      	ldr	r2, [pc, #104]	; (a1d8 <FlexCAN_Ip_Send+0x94>)
    a16e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a172:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif
    if (!FlexCAN_IsListenOnlyModeEnabled(base))
    a174:	9808      	ldr	r0, [sp, #32]
    a176:	f7ff f8f4 	bl	9362 <FlexCAN_IsListenOnlyModeEnabled>
    a17a:	4603      	mov	r3, r0
    a17c:	f083 0301 	eor.w	r3, r3, #1
    a180:	b2db      	uxtb	r3, r3
    a182:	2b00      	cmp	r3, #0
    a184:	d021      	beq.n	a1ca <FlexCAN_Ip_Send+0x86>
    {
        result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    a186:	f89d 1016 	ldrb.w	r1, [sp, #22]
    a18a:	f89d 0017 	ldrb.w	r0, [sp, #23]
    a18e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a190:	9300      	str	r3, [sp, #0]
    a192:	9b03      	ldr	r3, [sp, #12]
    a194:	9a04      	ldr	r2, [sp, #16]
    a196:	f7ff fb4b 	bl	9830 <FlexCAN_StartSendData>
    a19a:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        if ((FLEXCAN_STATUS_SUCCESS ==  result) && (FALSE == tx_info->is_polling))
    a19c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a19e:	2b00      	cmp	r3, #0
    a1a0:	d113      	bne.n	a1ca <FlexCAN_Ip_Send+0x86>
    a1a2:	9b04      	ldr	r3, [sp, #16]
    a1a4:	7b1b      	ldrb	r3, [r3, #12]
    a1a6:	f083 0301 	eor.w	r3, r3, #1
    a1aa:	b2db      	uxtb	r3, r3
    a1ac:	2b00      	cmp	r3, #0
    a1ae:	d00c      	beq.n	a1ca <FlexCAN_Ip_Send+0x86>
        {
            /* Enable message buffer interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    a1b0:	f89d 2016 	ldrb.w	r2, [sp, #22]
    a1b4:	9b07      	ldr	r3, [sp, #28]
    a1b6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a1ba:	f89d 1017 	ldrb.w	r1, [sp, #23]
    a1be:	9300      	str	r3, [sp, #0]
    a1c0:	2301      	movs	r3, #1
    a1c2:	9808      	ldr	r0, [sp, #32]
    a1c4:	f002 f9b6 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    a1c8:	9009      	str	r0, [sp, #36]	; 0x24
        }
#endif
    }
    return result;
    a1ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    a1cc:	4618      	mov	r0, r3
    a1ce:	b00b      	add	sp, #44	; 0x2c
    a1d0:	f85d fb04 	ldr.w	pc, [sp], #4
    a1d4:	00010534 	.word	0x00010534
    a1d8:	1fff8fb8 	.word	0x1fff8fb8

0000a1dc <FlexCAN_Ip_ConfigRxMb>:
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxMb(uint8 instance,
                                            uint8 mb_idx,
                                            const Flexcan_Ip_DataInfoType * rx_info,
                                            uint32 msg_id
                                           )
{
    a1dc:	b500      	push	{lr}
    a1de:	b08b      	sub	sp, #44	; 0x2c
    a1e0:	9202      	str	r2, [sp, #8]
    a1e2:	9301      	str	r3, [sp, #4]
    a1e4:	4603      	mov	r3, r0
    a1e6:	f88d 300f 	strb.w	r3, [sp, #15]
    a1ea:	460b      	mov	r3, r1
    a1ec:	f88d 300e 	strb.w	r3, [sp, #14]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a1f0:	2300      	movs	r3, #0
    a1f2:	9309      	str	r3, [sp, #36]	; 0x24
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a1f4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a1f8:	4a19      	ldr	r2, [pc, #100]	; (a260 <FlexCAN_Ip_ConfigRxMb+0x84>)
    a1fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1fe:	9308      	str	r3, [sp, #32]
    }
    else
    {
#endif
        /* Clear the message buffer flag if previous remained triggered */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    a200:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a204:	4619      	mov	r1, r3
    a206:	9808      	ldr	r0, [sp, #32]
    a208:	f7fe ff2c 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>

        cs.dataLen = rx_info->data_length;
    a20c:	9b02      	ldr	r3, [sp, #8]
    a20e:	685b      	ldr	r3, [r3, #4]
    a210:	9306      	str	r3, [sp, #24]
        cs.msgIdType = rx_info->msg_id_type;
    a212:	9b02      	ldr	r3, [sp, #8]
    a214:	681b      	ldr	r3, [r3, #0]
    a216:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = rx_info->fd_enable;
    a218:	9b02      	ldr	r3, [sp, #8]
    a21a:	7a1b      	ldrb	r3, [r3, #8]
    a21c:	f88d 301c 	strb.w	r3, [sp, #28]
    #endif

        /* Initialize rx mb*/
        cs.code = (uint32)FLEXCAN_RX_NOT_USED;
    a220:	230f      	movs	r3, #15
    a222:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    a224:	f89d 100e 	ldrb.w	r1, [sp, #14]
    a228:	aa04      	add	r2, sp, #16
    a22a:	9b01      	ldr	r3, [sp, #4]
    a22c:	9808      	ldr	r0, [sp, #32]
    a22e:	f002 fa25 	bl	c67c <FlexCAN_SetRxMsgBuff>

        /* Initialize receive MB*/
        cs.code = (uint32)FLEXCAN_RX_INACTIVE;
    a232:	2300      	movs	r3, #0
    a234:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    a236:	f89d 100e 	ldrb.w	r1, [sp, #14]
    a23a:	aa04      	add	r2, sp, #16
    a23c:	9b01      	ldr	r3, [sp, #4]
    a23e:	9808      	ldr	r0, [sp, #32]
    a240:	f002 fa1c 	bl	c67c <FlexCAN_SetRxMsgBuff>

        /* Set up FlexCAN message buffer fields for receiving data*/
        cs.code = (uint32)FLEXCAN_RX_EMPTY;
    a244:	2304      	movs	r3, #4
    a246:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    a248:	f89d 100e 	ldrb.w	r1, [sp, #14]
    a24c:	aa04      	add	r2, sp, #16
    a24e:	9b01      	ldr	r3, [sp, #4]
    a250:	9808      	ldr	r0, [sp, #32]
    a252:	f002 fa13 	bl	c67c <FlexCAN_SetRxMsgBuff>
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    a256:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    a258:	4618      	mov	r0, r3
    a25a:	b00b      	add	sp, #44	; 0x2c
    a25c:	f85d fb04 	ldr.w	pc, [sp], #4
    a260:	00010534 	.word	0x00010534

0000a264 <FlexCAN_Ip_Receive>:
Flexcan_Ip_StatusType FlexCAN_Ip_Receive(uint8 instance,
                                         uint8 mb_idx,
                                         Flexcan_Ip_MsgBuffType * data,
                                         boolean isPolling
                                        )
{
    a264:	b500      	push	{lr}
    a266:	b089      	sub	sp, #36	; 0x24
    a268:	9202      	str	r2, [sp, #8]
    a26a:	461a      	mov	r2, r3
    a26c:	4603      	mov	r3, r0
    a26e:	f88d 300f 	strb.w	r3, [sp, #15]
    a272:	460b      	mov	r3, r1
    a274:	f88d 300e 	strb.w	r3, [sp, #14]
    a278:	4613      	mov	r3, r2
    a27a:	f88d 300d 	strb.w	r3, [sp, #13]

    Flexcan_Ip_StatusType result;
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a27e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a282:	4a18      	ldr	r2, [pc, #96]	; (a2e4 <FlexCAN_Ip_Receive+0x80>)
    a284:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a288:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a28a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a28e:	4a16      	ldr	r2, [pc, #88]	; (a2e8 <FlexCAN_Ip_Receive+0x84>)
    a290:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a294:	9305      	str	r3, [sp, #20]
#endif
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    #endif

    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    a296:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a29a:	f89d 100e 	ldrb.w	r1, [sp, #14]
    a29e:	f89d 000f 	ldrb.w	r0, [sp, #15]
    a2a2:	9a02      	ldr	r2, [sp, #8]
    a2a4:	f7ff fa86 	bl	97b4 <FlexCAN_StartRxMessageBufferData>
    a2a8:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    a2aa:	9b07      	ldr	r3, [sp, #28]
    a2ac:	2b00      	cmp	r3, #0
    a2ae:	d113      	bne.n	a2d8 <FlexCAN_Ip_Receive+0x74>
    a2b0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a2b4:	f083 0301 	eor.w	r3, r3, #1
    a2b8:	b2db      	uxtb	r3, r3
    a2ba:	2b00      	cmp	r3, #0
    a2bc:	d00c      	beq.n	a2d8 <FlexCAN_Ip_Receive+0x74>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    a2be:	f89d 200e 	ldrb.w	r2, [sp, #14]
    a2c2:	9b05      	ldr	r3, [sp, #20]
    a2c4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a2c8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a2cc:	9300      	str	r3, [sp, #0]
    a2ce:	2301      	movs	r3, #1
    a2d0:	9806      	ldr	r0, [sp, #24]
    a2d2:	f002 f92f 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    a2d6:	9007      	str	r0, [sp, #28]
    }
#endif
    return result;
    a2d8:	9b07      	ldr	r3, [sp, #28]
}
    a2da:	4618      	mov	r0, r3
    a2dc:	b009      	add	sp, #36	; 0x24
    a2de:	f85d fb04 	ldr.w	pc, [sp], #4
    a2e2:	bf00      	nop
    a2e4:	00010534 	.word	0x00010534
    a2e8:	1fff8fb8 	.word	0x1fff8fb8

0000a2ec <FlexCAN_Ip_ReceiveBlocking>:
                                                 uint8 mb_idx,
                                                 Flexcan_Ip_MsgBuffType * data,
                                                 boolean isPolling,
                                                 uint32 u32TimeoutMs
                                                )
{
    a2ec:	b500      	push	{lr}
    a2ee:	b08b      	sub	sp, #44	; 0x2c
    a2f0:	9202      	str	r2, [sp, #8]
    a2f2:	461a      	mov	r2, r3
    a2f4:	4603      	mov	r3, r0
    a2f6:	f88d 300f 	strb.w	r3, [sp, #15]
    a2fa:	460b      	mov	r3, r1
    a2fc:	f88d 300e 	strb.w	r3, [sp, #14]
    a300:	4613      	mov	r3, r2
    a302:	f88d 300d 	strb.w	r3, [sp, #13]
    Flexcan_Ip_StatusType result;
    uint32 timeStart = 0U;
    a306:	2300      	movs	r3, #0
    a308:	9304      	str	r3, [sp, #16]
    uint32 timeElapsed = 0U;
    a30a:	2300      	movs	r3, #0
    a30c:	9308      	str	r3, [sp, #32]
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a30e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a310:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    a314:	fb02 f303 	mul.w	r3, r2, r3
    a318:	2100      	movs	r1, #0
    a31a:	4618      	mov	r0, r3
    a31c:	f7f7 ffbc 	bl	2298 <OsIf_MicrosToTicks>
    a320:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a322:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a326:	4a4c      	ldr	r2, [pc, #304]	; (a458 <FlexCAN_Ip_ReceiveBlocking+0x16c>)
    a328:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a32c:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a32e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a332:	4a4a      	ldr	r2, [pc, #296]	; (a45c <FlexCAN_Ip_ReceiveBlocking+0x170>)
    a334:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a338:	9305      	str	r3, [sp, #20]
#else
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    a33a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a33e:	f89d 100e 	ldrb.w	r1, [sp, #14]
    a342:	f89d 000f 	ldrb.w	r0, [sp, #15]
    a346:	9a02      	ldr	r2, [sp, #8]
    a348:	f7ff fa34 	bl	97b4 <FlexCAN_StartRxMessageBufferData>
    a34c:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    a34e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a350:	2b00      	cmp	r3, #0
    a352:	d113      	bne.n	a37c <FlexCAN_Ip_ReceiveBlocking+0x90>
    a354:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a358:	f083 0301 	eor.w	r3, r3, #1
    a35c:	b2db      	uxtb	r3, r3
    a35e:	2b00      	cmp	r3, #0
    a360:	d00c      	beq.n	a37c <FlexCAN_Ip_ReceiveBlocking+0x90>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    a362:	f89d 200e 	ldrb.w	r2, [sp, #14]
    a366:	9b06      	ldr	r3, [sp, #24]
    a368:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a36c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a370:	9300      	str	r3, [sp, #0]
    a372:	2301      	movs	r3, #1
    a374:	9805      	ldr	r0, [sp, #20]
    a376:	f002 f8dd 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    a37a:	9009      	str	r0, [sp, #36]	; 0x24
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    a37c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a37e:	2b00      	cmp	r3, #0
    a380:	d133      	bne.n	a3ea <FlexCAN_Ip_ReceiveBlocking+0xfe>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a382:	2000      	movs	r0, #0
    a384:	f7f7 ff3c 	bl	2200 <OsIf_GetCounter>
    a388:	4603      	mov	r3, r0
    a38a:	9304      	str	r3, [sp, #16]
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    a38c:	e024      	b.n	a3d8 <FlexCAN_Ip_ReceiveBlocking+0xec>
        {
            if (TRUE == isPolling)
    a38e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a392:	2b00      	cmp	r3, #0
    a394:	d010      	beq.n	a3b8 <FlexCAN_Ip_ReceiveBlocking+0xcc>
            {
                if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    a396:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a39a:	4619      	mov	r1, r3
    a39c:	9805      	ldr	r0, [sp, #20]
    a39e:	f7fe fe74 	bl	908a <FlexCAN_GetBuffStatusFlag>
    a3a2:	4603      	mov	r3, r0
    a3a4:	2b00      	cmp	r3, #0
    a3a6:	d007      	beq.n	a3b8 <FlexCAN_Ip_ReceiveBlocking+0xcc>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    a3a8:	f89d 200e 	ldrb.w	r2, [sp, #14]
    a3ac:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a3b0:	4611      	mov	r1, r2
    a3b2:	4618      	mov	r0, r3
    a3b4:	f7ff fb20 	bl	99f8 <FlexCAN_IRQHandlerRxMB>
                }
            }
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a3b8:	ab04      	add	r3, sp, #16
    a3ba:	2100      	movs	r1, #0
    a3bc:	4618      	mov	r0, r3
    a3be:	f7f7 ff38 	bl	2232 <OsIf_GetElapsed>
    a3c2:	4602      	mov	r2, r0
    a3c4:	9b08      	ldr	r3, [sp, #32]
    a3c6:	4413      	add	r3, r2
    a3c8:	9308      	str	r3, [sp, #32]
            if (timeElapsed >= mS2Ticks)
    a3ca:	9a08      	ldr	r2, [sp, #32]
    a3cc:	9b07      	ldr	r3, [sp, #28]
    a3ce:	429a      	cmp	r2, r3
    a3d0:	d302      	bcc.n	a3d8 <FlexCAN_Ip_ReceiveBlocking+0xec>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    a3d2:	2303      	movs	r3, #3
    a3d4:	9309      	str	r3, [sp, #36]	; 0x24
                break;
    a3d6:	e008      	b.n	a3ea <FlexCAN_Ip_ReceiveBlocking+0xfe>
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    a3d8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a3dc:	9a06      	ldr	r2, [sp, #24]
    a3de:	011b      	lsls	r3, r3, #4
    a3e0:	4413      	add	r3, r2
    a3e2:	3304      	adds	r3, #4
    a3e4:	681b      	ldr	r3, [r3, #0]
    a3e6:	2b01      	cmp	r3, #1
    a3e8:	d0d1      	beq.n	a38e <FlexCAN_Ip_ReceiveBlocking+0xa2>
            }
        }
    }

    if ((FLEXCAN_STATUS_TIMEOUT == result) && (FALSE == isPolling))
    a3ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3ec:	2b03      	cmp	r3, #3
    a3ee:	d112      	bne.n	a416 <FlexCAN_Ip_ReceiveBlocking+0x12a>
    a3f0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    a3f4:	f083 0301 	eor.w	r3, r3, #1
    a3f8:	b2db      	uxtb	r3, r3
    a3fa:	2b00      	cmp	r3, #0
    a3fc:	d00b      	beq.n	a416 <FlexCAN_Ip_ReceiveBlocking+0x12a>
    {
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        /* Disable Mb interrupt*/
       (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    a3fe:	f89d 200e 	ldrb.w	r2, [sp, #14]
    a402:	9b06      	ldr	r3, [sp, #24]
    a404:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a408:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a40c:	9300      	str	r3, [sp, #0]
    a40e:	2300      	movs	r3, #0
    a410:	9805      	ldr	r0, [sp, #20]
    a412:	f002 f88f 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
#endif
    }

    if ((FLEXCAN_STATUS_BUFF_OUT_OF_RANGE != result) && (FLEXCAN_STATUS_BUSY != result))
    a416:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a418:	2b04      	cmp	r3, #4
    a41a:	d018      	beq.n	a44e <FlexCAN_Ip_ReceiveBlocking+0x162>
    a41c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a41e:	2b02      	cmp	r3, #2
    a420:	d015      	beq.n	a44e <FlexCAN_Ip_ReceiveBlocking+0x162>
    {
        if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state))
    a422:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a426:	9a06      	ldr	r2, [sp, #24]
    a428:	011b      	lsls	r3, r3, #4
    a42a:	4413      	add	r3, r2
    a42c:	3304      	adds	r3, #4
    a42e:	681b      	ldr	r3, [r3, #0]
    a430:	2b00      	cmp	r3, #0
    a432:	d102      	bne.n	a43a <FlexCAN_Ip_ReceiveBlocking+0x14e>
        {
            result = FLEXCAN_STATUS_SUCCESS;
    a434:	2300      	movs	r3, #0
    a436:	9309      	str	r3, [sp, #36]	; 0x24
    a438:	e009      	b.n	a44e <FlexCAN_Ip_ReceiveBlocking+0x162>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    a43a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a43e:	9a06      	ldr	r2, [sp, #24]
    a440:	011b      	lsls	r3, r3, #4
    a442:	4413      	add	r3, r2
    a444:	3304      	adds	r3, #4
    a446:	2200      	movs	r2, #0
    a448:	601a      	str	r2, [r3, #0]
            result = FLEXCAN_STATUS_TIMEOUT;
    a44a:	2303      	movs	r3, #3
    a44c:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    return result;
    a44e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    a450:	4618      	mov	r0, r3
    a452:	b00b      	add	sp, #44	; 0x2c
    a454:	f85d fb04 	ldr.w	pc, [sp], #4
    a458:	1fff8fb8 	.word	0x1fff8fb8
    a45c:	00010534 	.word	0x00010534

0000a460 <FlexCAN_Ip_RxFifo>:
 * after the frame was received and read into the specified buffer.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_RxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifo(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    a460:	b500      	push	{lr}
    a462:	b085      	sub	sp, #20
    a464:	4603      	mov	r3, r0
    a466:	9100      	str	r1, [sp, #0]
    a468:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    a46c:	2300      	movs	r3, #0
    a46e:	9303      	str	r3, [sp, #12]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    a470:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a474:	9900      	ldr	r1, [sp, #0]
    a476:	4618      	mov	r0, r3
    a478:	f7ff fa5e 	bl	9938 <FlexCAN_StartRxMessageFifoData>
    a47c:	9003      	str	r0, [sp, #12]
    }
    return result;
    a47e:	9b03      	ldr	r3, [sp, #12]
}
    a480:	4618      	mov	r0, r3
    a482:	b005      	add	sp, #20
    a484:	f85d fb04 	ldr.w	pc, [sp], #4

0000a488 <FlexCAN_Ip_RxFifoBlocking>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_RxFifoBlocking_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifoBlocking(uint8 instance, Flexcan_Ip_MsgBuffType *data, uint32 timeout)
{
    a488:	b500      	push	{lr}
    a48a:	b087      	sub	sp, #28
    a48c:	4603      	mov	r3, r0
    a48e:	9102      	str	r1, [sp, #8]
    a490:	9201      	str	r2, [sp, #4]
    a492:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    a496:	2300      	movs	r3, #0
    a498:	9305      	str	r3, [sp, #20]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    a49a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a49e:	9902      	ldr	r1, [sp, #8]
    a4a0:	4618      	mov	r0, r3
    a4a2:	f7ff fa49 	bl	9938 <FlexCAN_StartRxMessageFifoData>
    a4a6:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == result)
    a4a8:	9b05      	ldr	r3, [sp, #20]
    a4aa:	2b00      	cmp	r3, #0
    a4ac:	d106      	bne.n	a4bc <FlexCAN_Ip_RxFifoBlocking+0x34>
        {
            result = FlexCAN_ProccessLegacyRxFIFO(instance, timeout);
    a4ae:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a4b2:	9901      	ldr	r1, [sp, #4]
    a4b4:	4618      	mov	r0, r3
    a4b6:	f7ff f8e2 	bl	967e <FlexCAN_ProccessLegacyRxFIFO>
    a4ba:	9005      	str	r0, [sp, #20]
        }
    }
    return result;
    a4bc:	9b05      	ldr	r3, [sp, #20]
}
    a4be:	4618      	mov	r0, r3
    a4c0:	b007      	add	sp, #28
    a4c2:	f85d fb04 	ldr.w	pc, [sp], #4

0000a4c6 <FlexCAN_Ip_ConfigRxFifo_Privileged>:
/* implements FlexCAN_Ip_ConfigRxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxFifo_Privileged(uint8 instance,
                                                         Flexcan_Ip_RxFifoIdElementFormatType id_format,
                                                         const Flexcan_Ip_IdTableType * id_filter_table
                                                        )
{
    a4c6:	b500      	push	{lr}
    a4c8:	b089      	sub	sp, #36	; 0x24
    a4ca:	4603      	mov	r3, r0
    a4cc:	9102      	str	r1, [sp, #8]
    a4ce:	9201      	str	r2, [sp, #4]
    a4d0:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    a4d4:	2300      	movs	r3, #0
    a4d6:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    a4d8:	2300      	movs	r3, #0
    a4da:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    a4dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a4e0:	4a1c      	ldr	r2, [pc, #112]	; (a554 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x8e>)
    a4e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4e6:	9305      	str	r3, [sp, #20]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    a4e8:	9805      	ldr	r0, [sp, #20]
    a4ea:	f7fe fd61 	bl	8fb0 <FlexCAN_IsEnabled>
    a4ee:	4603      	mov	r3, r0
    a4f0:	2b00      	cmp	r3, #0
    a4f2:	bf14      	ite	ne
    a4f4:	2301      	movne	r3, #1
    a4f6:	2300      	moveq	r3, #0
    a4f8:	b2db      	uxtb	r3, r3
    a4fa:	f083 0301 	eor.w	r3, r3, #1
    a4fe:	b2db      	uxtb	r3, r3
    a500:	f88d 3013 	strb.w	r3, [sp, #19]
    a504:	f89d 3013 	ldrb.w	r3, [sp, #19]
    a508:	f003 0301 	and.w	r3, r3, #1
    a50c:	f88d 3013 	strb.w	r3, [sp, #19]

    if (TRUE == disabled)
    a510:	f89d 3013 	ldrb.w	r3, [sp, #19]
    a514:	2b00      	cmp	r3, #0
    a516:	d003      	beq.n	a520 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x5a>
    {
        result = FlexCAN_Enable(pBase);
    a518:	9805      	ldr	r0, [sp, #20]
    a51a:	f001 fd6b 	bl	bff4 <FlexCAN_Enable>
    a51e:	9007      	str	r0, [sp, #28]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    a520:	9b07      	ldr	r3, [sp, #28]
    a522:	2b00      	cmp	r3, #0
    a524:	d104      	bne.n	a530 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x6a>
    {
        /* Initialize rx fifo*/
        FlexCAN_SetRxFifoFilter(pBase, id_format, id_filter_table);
    a526:	9a01      	ldr	r2, [sp, #4]
    a528:	9902      	ldr	r1, [sp, #8]
    a52a:	9805      	ldr	r0, [sp, #20]
    a52c:	f002 fba5 	bl	cc7a <FlexCAN_SetRxFifoFilter>
    }

    if (TRUE == disabled)
    a530:	f89d 3013 	ldrb.w	r3, [sp, #19]
    a534:	2b00      	cmp	r3, #0
    a536:	d008      	beq.n	a54a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
    {
        status = FlexCAN_Disable(pBase);
    a538:	9805      	ldr	r0, [sp, #20]
    a53a:	f001 fdd9 	bl	c0f0 <FlexCAN_Disable>
    a53e:	9006      	str	r0, [sp, #24]
        if (FLEXCAN_STATUS_SUCCESS != status)
    a540:	9b06      	ldr	r3, [sp, #24]
    a542:	2b00      	cmp	r3, #0
    a544:	d001      	beq.n	a54a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
        {
            result = status;
    a546:	9b06      	ldr	r3, [sp, #24]
    a548:	9307      	str	r3, [sp, #28]
        }
    }

    return result;
    a54a:	9b07      	ldr	r3, [sp, #28]
}
    a54c:	4618      	mov	r0, r3
    a54e:	b009      	add	sp, #36	; 0x24
    a550:	f85d fb04 	ldr.w	pc, [sp], #4
    a554:	00010534 	.word	0x00010534

0000a558 <FlexCAN_Ip_ConfigRemoteResponseMb>:
                                                        uint8 mb_idx,
                                                        const Flexcan_Ip_DataInfoType *tx_info,
                                                        uint32 msg_id,
                                                        const uint8 *mb_data
                                                       )
{
    a558:	b500      	push	{lr}
    a55a:	b08f      	sub	sp, #60	; 0x3c
    a55c:	9204      	str	r2, [sp, #16]
    a55e:	9303      	str	r3, [sp, #12]
    a560:	4603      	mov	r3, r0
    a562:	f88d 3017 	strb.w	r3, [sp, #23]
    a566:	460b      	mov	r3, r1
    a568:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    a56c:	2300      	movs	r3, #0
    a56e:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    a570:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a574:	4a27      	ldr	r2, [pc, #156]	; (a614 <FlexCAN_Ip_ConfigRemoteResponseMb+0xbc>)
    a576:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a57a:	930c      	str	r3, [sp, #48]	; 0x30
    const Flexcan_Ip_StateType * const state = Flexcan_Ip_apxState[instance];
    a57c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a580:	4a25      	ldr	r2, [pc, #148]	; (a618 <FlexCAN_Ip_ConfigRemoteResponseMb+0xc0>)
    a582:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a586:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    a588:	2300      	movs	r3, #0
    a58a:	930a      	str	r3, [sp, #40]	; 0x28
    if (TRUE == FlexCAN_IsMbOutOfRange(pBase, mb_idx, state->bIsLegacyFifoEn, state->u32MaxMbNum))
    {
        result = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    a58c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a58e:	2b00      	cmp	r3, #0
    a590:	d13a      	bne.n	a608 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
    {
        /* Initialize transmit mb*/
        cs.dataLen = tx_info->data_length;
    a592:	9b04      	ldr	r3, [sp, #16]
    a594:	685b      	ldr	r3, [r3, #4]
    a596:	9308      	str	r3, [sp, #32]
        cs.msgIdType = tx_info->msg_id_type;
    a598:	9b04      	ldr	r3, [sp, #16]
    a59a:	681b      	ldr	r3, [r3, #0]
    a59c:	9307      	str	r3, [sp, #28]
        cs.code = (uint32)FLEXCAN_RX_RANSWER;
    a59e:	230a      	movs	r3, #10
    a5a0:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = FALSE;
    a5a2:	2300      	movs	r3, #0
    a5a4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        cs.enable_brs = FALSE;
    a5a8:	2300      	movs	r3, #0
    a5aa:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        cs.fd_padding = 0x00U;
    a5ae:	2300      	movs	r3, #0
    a5b0:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
#endif
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    a5b4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a5b8:	4619      	mov	r1, r3
    a5ba:	980c      	ldr	r0, [sp, #48]	; 0x30
    a5bc:	f7fe fd52 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
        pMbAddr = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    a5c0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a5c4:	4619      	mov	r1, r3
    a5c6:	980c      	ldr	r0, [sp, #48]	; 0x30
    a5c8:	f001 fc2c 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    a5cc:	900a      	str	r0, [sp, #40]	; 0x28
        FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, tx_info->is_remote);
    a5ce:	9b04      	ldr	r3, [sp, #16]
    a5d0:	7adb      	ldrb	r3, [r3, #11]
    a5d2:	a906      	add	r1, sp, #24
    a5d4:	9300      	str	r3, [sp, #0]
    a5d6:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a5d8:	9a03      	ldr	r2, [sp, #12]
    a5da:	980a      	ldr	r0, [sp, #40]	; 0x28
    a5dc:	f002 f974 	bl	c8c8 <FlexCAN_SetTxMsgBuff>
        if (FALSE == tx_info->is_polling)
    a5e0:	9b04      	ldr	r3, [sp, #16]
    a5e2:	7b1b      	ldrb	r3, [r3, #12]
    a5e4:	f083 0301 	eor.w	r3, r3, #1
    a5e8:	b2db      	uxtb	r3, r3
    a5ea:	2b00      	cmp	r3, #0
    a5ec:	d00c      	beq.n	a608 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
        {
            /* Enable MB interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(pBase, instance, mb_idx, TRUE, state->isIntActive);
    a5ee:	f89d 2016 	ldrb.w	r2, [sp, #22]
    a5f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a5f4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a5f8:	f89d 1017 	ldrb.w	r1, [sp, #23]
    a5fc:	9300      	str	r3, [sp, #0]
    a5fe:	2301      	movs	r3, #1
    a600:	980c      	ldr	r0, [sp, #48]	; 0x30
    a602:	f001 ff97 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    a606:	900d      	str	r0, [sp, #52]	; 0x34
        }
    }
    return result;
    a608:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    a60a:	4618      	mov	r0, r3
    a60c:	b00f      	add	sp, #60	; 0x3c
    a60e:	f85d fb04 	ldr.w	pc, [sp], #4
    a612:	bf00      	nop
    a614:	00010534 	.word	0x00010534
    a618:	1fff8fb8 	.word	0x1fff8fb8

0000a61c <FlexCAN_Ip_GetTransferStatus>:
 * or complete (success). In case Enhanced Rx Fifo, mb_idx will be 255.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetTransferStatus_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_GetTransferStatus(uint8 instance, uint8 mb_idx)
{
    a61c:	b084      	sub	sp, #16
    a61e:	4603      	mov	r3, r0
    a620:	460a      	mov	r2, r1
    a622:	f88d 3007 	strb.w	r3, [sp, #7]
    a626:	4613      	mov	r3, r2
    a628:	f88d 3006 	strb.w	r3, [sp, #6]

    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a62c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a630:	4a0d      	ldr	r2, [pc, #52]	; (a668 <FlexCAN_Ip_GetTransferStatus+0x4c>)
    a632:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a636:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_ERROR;
    a638:	2301      	movs	r3, #1
    a63a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
#endif

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    a63c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a640:	2b1f      	cmp	r3, #31
    a642:	d80d      	bhi.n	a660 <FlexCAN_Ip_GetTransferStatus+0x44>
    {
        if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    a644:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a648:	9a02      	ldr	r2, [sp, #8]
    a64a:	011b      	lsls	r3, r3, #4
    a64c:	4413      	add	r3, r2
    a64e:	3304      	adds	r3, #4
    a650:	681b      	ldr	r3, [r3, #0]
    a652:	2b00      	cmp	r3, #0
    a654:	d102      	bne.n	a65c <FlexCAN_Ip_GetTransferStatus+0x40>
        {
            status = FLEXCAN_STATUS_SUCCESS;
    a656:	2300      	movs	r3, #0
    a658:	9303      	str	r3, [sp, #12]
    a65a:	e001      	b.n	a660 <FlexCAN_Ip_GetTransferStatus+0x44>
            status = FLEXCAN_STATUS_ERROR;
        }
#endif
        else
        {
            status = FLEXCAN_STATUS_BUSY;
    a65c:	2302      	movs	r3, #2
    a65e:	9303      	str	r3, [sp, #12]
            status = FLEXCAN_STATUS_BUSY;
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return status;
    a660:	9b03      	ldr	r3, [sp, #12]
}
    a662:	4618      	mov	r0, r3
    a664:	b004      	add	sp, #16
    a666:	4770      	bx	lr
    a668:	1fff8fb8 	.word	0x1fff8fb8

0000a66c <FlexCAN_CompleteRxMessageFifoData>:
 * data and disabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_CompleteRxMessageFifoData(uint8 instance)
{
    a66c:	b500      	push	{lr}
    a66e:	b087      	sub	sp, #28
    a670:	4603      	mov	r3, r0
    a672:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a676:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a67a:	4a1d      	ldr	r2, [pc, #116]	; (a6f0 <FlexCAN_CompleteRxMessageFifoData+0x84>)
    a67c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a680:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a682:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a686:	4a1b      	ldr	r2, [pc, #108]	; (a6f4 <FlexCAN_CompleteRxMessageFifoData+0x88>)
    a688:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a68c:	9304      	str	r3, [sp, #16]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    a68e:	9b04      	ldr	r3, [sp, #16]
    a690:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    a694:	2b00      	cmp	r3, #0
    a696:	d120      	bne.n	a6da <FlexCAN_CompleteRxMessageFifoData+0x6e>
    {
        /* Disable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, state->isIntActive);
    a698:	9b04      	ldr	r3, [sp, #16]
    a69a:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a69e:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a6a2:	9300      	str	r3, [sp, #0]
    a6a4:	2300      	movs	r3, #0
    a6a6:	2205      	movs	r2, #5
    a6a8:	9805      	ldr	r0, [sp, #20]
    a6aa:	f001 ff43 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, state->isIntActive);
    a6ae:	9b04      	ldr	r3, [sp, #16]
    a6b0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a6b4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a6b8:	9300      	str	r3, [sp, #0]
    a6ba:	2300      	movs	r3, #0
    a6bc:	2206      	movs	r2, #6
    a6be:	9805      	ldr	r0, [sp, #20]
    a6c0:	f001 ff38 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, state->isIntActive);
    a6c4:	9b04      	ldr	r3, [sp, #16]
    a6c6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a6ca:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a6ce:	9300      	str	r3, [sp, #0]
    a6d0:	2300      	movs	r3, #0
    a6d2:	2207      	movs	r2, #7
    a6d4:	9805      	ldr	r0, [sp, #20]
    a6d6:	f001 ff2d 	bl	c534 <FlexCAN_SetMsgBuffIntCmd>
    {
        /* do nothing when transferType is POLLING */
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    /* Clear fifo message*/
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = NULL_PTR;
    a6da:	9b04      	ldr	r3, [sp, #16]
    a6dc:	2200      	movs	r2, #0
    a6de:	601a      	str	r2, [r3, #0]
            state->callback(instance, FLEXCAN_EVENT_DMA_ERROR, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
        }
    }

#else
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    a6e0:	9b04      	ldr	r3, [sp, #16]
    a6e2:	2200      	movs	r2, #0
    a6e4:	605a      	str	r2, [r3, #4]
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
}
    a6e6:	bf00      	nop
    a6e8:	b007      	add	sp, #28
    a6ea:	f85d fb04 	ldr.w	pc, [sp], #4
    a6ee:	bf00      	nop
    a6f0:	00010534 	.word	0x00010534
    a6f4:	1fff8fb8 	.word	0x1fff8fb8

0000a6f8 <FlexCAN_IRQHandler>:
    uint32 endMbIdx
    #if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    ,boolean bEnhancedFifoExisted
    #endif
)
{
    a6f8:	b500      	push	{lr}
    a6fa:	b08b      	sub	sp, #44	; 0x2c
    a6fc:	4603      	mov	r3, r0
    a6fe:	9102      	str	r1, [sp, #8]
    a700:	9201      	str	r2, [sp, #4]
    a702:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32MbHandle = 0U;
    a706:	2300      	movs	r3, #0
    a708:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 flag_reg = 0;
    a70a:	2300      	movs	r3, #0
    a70c:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a70e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a712:	4a3f      	ldr	r2, [pc, #252]	; (a810 <FlexCAN_IRQHandler+0x118>)
    a714:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a718:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a71a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a71e:	4a3d      	ldr	r2, [pc, #244]	; (a814 <FlexCAN_IRQHandler+0x11c>)
    a720:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a724:	9305      	str	r3, [sp, #20]

    /* Get the interrupts that are enabled and ready */
    uint32 mb_idx = endMbIdx;
    a726:	9b01      	ldr	r3, [sp, #4]
    a728:	9307      	str	r3, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(endMbIdx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM);
#endif
    /* Check if instance initialized */
    if (NULL_PTR != state)
    a72a:	9b05      	ldr	r3, [sp, #20]
    a72c:	2b00      	cmp	r3, #0
    a72e:	d05c      	beq.n	a7ea <FlexCAN_IRQHandler+0xf2>
    {
        flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    a730:	9907      	ldr	r1, [sp, #28]
    a732:	9806      	ldr	r0, [sp, #24]
    a734:	f7fe fe47 	bl	93c6 <FlexCAN_GetMsgBuffIntStatusFlag>
    a738:	4603      	mov	r3, r0
    a73a:	9308      	str	r3, [sp, #32]

        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    a73c:	e008      	b.n	a750 <FlexCAN_IRQHandler+0x58>
        {
            mb_idx--;
    a73e:	9b07      	ldr	r3, [sp, #28]
    a740:	3b01      	subs	r3, #1
    a742:	9307      	str	r3, [sp, #28]
            flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    a744:	9907      	ldr	r1, [sp, #28]
    a746:	9806      	ldr	r0, [sp, #24]
    a748:	f7fe fe3d 	bl	93c6 <FlexCAN_GetMsgBuffIntStatusFlag>
    a74c:	4603      	mov	r3, r0
    a74e:	9308      	str	r3, [sp, #32]
        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    a750:	9b08      	ldr	r3, [sp, #32]
    a752:	2b00      	cmp	r3, #0
    a754:	d103      	bne.n	a75e <FlexCAN_IRQHandler+0x66>
    a756:	9a07      	ldr	r2, [sp, #28]
    a758:	9b02      	ldr	r3, [sp, #8]
    a75a:	429a      	cmp	r2, r3
    a75c:	d8ef      	bhi.n	a73e <FlexCAN_IRQHandler+0x46>
        }

        /* Check Tx/Rx interrupt flag and clear the interrupt */
        if (flag_reg != 0U)
    a75e:	9b08      	ldr	r3, [sp, #32]
    a760:	2b00      	cmp	r3, #0
    a762:	d050      	beq.n	a806 <FlexCAN_IRQHandler+0x10e>
        {
            /* For legacy fifo, mb handler is FLEXCAN_IP_MB_HANDLE_RXFIFO(0) */
            u32MbHandle = mb_idx;
    a764:	9b07      	ldr	r3, [sp, #28]
    a766:	9309      	str	r3, [sp, #36]	; 0x24

            if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    a768:	9b05      	ldr	r3, [sp, #20]
    a76a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    a76e:	2b00      	cmp	r3, #0
    a770:	d00b      	beq.n	a78a <FlexCAN_IRQHandler+0x92>
    a772:	9b07      	ldr	r3, [sp, #28]
    a774:	2b07      	cmp	r3, #7
    a776:	d808      	bhi.n	a78a <FlexCAN_IRQHandler+0x92>
            {
                FlexCAN_IRQHandlerRxFIFO(instance, mb_idx);
    a778:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a77c:	9907      	ldr	r1, [sp, #28]
    a77e:	4618      	mov	r0, r3
    a780:	f7ff fac2 	bl	9d08 <FlexCAN_IRQHandlerRxFIFO>
                u32MbHandle = (uint32)FLEXCAN_IP_MB_HANDLE_RXFIFO;
    a784:	2300      	movs	r3, #0
    a786:	9309      	str	r3, [sp, #36]	; 0x24
    a788:	e00d      	b.n	a7a6 <FlexCAN_IRQHandler+0xae>
            }
            else
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[u32MbHandle].state)
    a78a:	9a05      	ldr	r2, [sp, #20]
    a78c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a78e:	011b      	lsls	r3, r3, #4
    a790:	4413      	add	r3, r2
    a792:	3304      	adds	r3, #4
    a794:	681b      	ldr	r3, [r3, #0]
    a796:	2b01      	cmp	r3, #1
    a798:	d105      	bne.n	a7a6 <FlexCAN_IRQHandler+0xae>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    a79a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a79e:	9907      	ldr	r1, [sp, #28]
    a7a0:	4618      	mov	r0, r3
    a7a2:	f7ff f929 	bl	99f8 <FlexCAN_IRQHandlerRxMB>
                }
            }

            /* Check mailbox completed transmission */
            if (FLEXCAN_MB_TX_BUSY == state->mbs[u32MbHandle].state)
    a7a6:	9a05      	ldr	r2, [sp, #20]
    a7a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a7aa:	011b      	lsls	r3, r3, #4
    a7ac:	4413      	add	r3, r2
    a7ae:	3304      	adds	r3, #4
    a7b0:	681b      	ldr	r3, [r3, #0]
    a7b2:	2b02      	cmp	r3, #2
    a7b4:	d105      	bne.n	a7c2 <FlexCAN_IRQHandler+0xca>
            {
                FlexCAN_IRQHandlerTxMB(instance, mb_idx);
    a7b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a7ba:	9907      	ldr	r1, [sp, #28]
    a7bc:	4618      	mov	r0, r3
    a7be:	f7ff fa09 	bl	9bd4 <FlexCAN_IRQHandlerTxMB>
            }

            /* Check for spurious interrupt */
            if (FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx) != 0U)
    a7c2:	9907      	ldr	r1, [sp, #28]
    a7c4:	9806      	ldr	r0, [sp, #24]
    a7c6:	f7fe fdfe 	bl	93c6 <FlexCAN_GetMsgBuffIntStatusFlag>
    a7ca:	4603      	mov	r3, r0
    a7cc:	2b00      	cmp	r3, #0
    a7ce:	d01a      	beq.n	a806 <FlexCAN_IRQHandler+0x10e>
            {
                if (state->mbs[u32MbHandle].state == FLEXCAN_MB_IDLE)
    a7d0:	9a05      	ldr	r2, [sp, #20]
    a7d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a7d4:	011b      	lsls	r3, r3, #4
    a7d6:	4413      	add	r3, r2
    a7d8:	3304      	adds	r3, #4
    a7da:	681b      	ldr	r3, [r3, #0]
    a7dc:	2b00      	cmp	r3, #0
    a7de:	d112      	bne.n	a806 <FlexCAN_IRQHandler+0x10e>
                {
                    /* In case of desynchronized status of the MB to avoid trapping in ISR
                    * clear the MB flag */
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    a7e0:	9907      	ldr	r1, [sp, #28]
    a7e2:	9806      	ldr	r0, [sp, #24]
    a7e4:	f7fe fc3e 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_UNDERFLOW);
        }
    #endif /* End of (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    }
}
    a7e8:	e00d      	b.n	a806 <FlexCAN_IRQHandler+0x10e>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    a7ea:	9b02      	ldr	r3, [sp, #8]
    a7ec:	9307      	str	r3, [sp, #28]
    a7ee:	e006      	b.n	a7fe <FlexCAN_IRQHandler+0x106>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    a7f0:	9907      	ldr	r1, [sp, #28]
    a7f2:	9806      	ldr	r0, [sp, #24]
    a7f4:	f7fe fc36 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    a7f8:	9b07      	ldr	r3, [sp, #28]
    a7fa:	3301      	adds	r3, #1
    a7fc:	9307      	str	r3, [sp, #28]
    a7fe:	9a07      	ldr	r2, [sp, #28]
    a800:	9b01      	ldr	r3, [sp, #4]
    a802:	429a      	cmp	r2, r3
    a804:	d9f4      	bls.n	a7f0 <FlexCAN_IRQHandler+0xf8>
}
    a806:	bf00      	nop
    a808:	b00b      	add	sp, #44	; 0x2c
    a80a:	f85d fb04 	ldr.w	pc, [sp], #4
    a80e:	bf00      	nop
    a810:	00010534 	.word	0x00010534
    a814:	1fff8fb8 	.word	0x1fff8fb8

0000a818 <FlexCAN_Ip_ClearErrorStatus>:
 *                 transmission of a CAN frame.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearErrorStatus_Activity */
void FlexCAN_Ip_ClearErrorStatus(uint8 instance, uint32 error)
{
    a818:	b084      	sub	sp, #16
    a81a:	4603      	mov	r3, r0
    a81c:	9100      	str	r1, [sp, #0]
    a81e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a822:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a826:	4a05      	ldr	r2, [pc, #20]	; (a83c <FlexCAN_Ip_ClearErrorStatus+0x24>)
    a828:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a82c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base->ESR1 = error;
    a82e:	9b03      	ldr	r3, [sp, #12]
    a830:	9a00      	ldr	r2, [sp, #0]
    a832:	621a      	str	r2, [r3, #32]
}
    a834:	bf00      	nop
    a836:	b004      	add	sp, #16
    a838:	4770      	bx	lr
    a83a:	bf00      	nop
    a83c:	00010534 	.word	0x00010534

0000a840 <FlexCAN_Ip_GetErrorStatus>:
 *                 transmission of a CAN frame and some general status of the device.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetErrorStatus_Activity */
uint32 FlexCAN_Ip_GetErrorStatus(uint8 instance)
{
    a840:	b084      	sub	sp, #16
    a842:	4603      	mov	r3, r0
    a844:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a848:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a84c:	4a04      	ldr	r2, [pc, #16]	; (a860 <FlexCAN_Ip_GetErrorStatus+0x20>)
    a84e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a852:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint32)(base->ESR1);
    a854:	9b03      	ldr	r3, [sp, #12]
    a856:	6a1b      	ldr	r3, [r3, #32]
}
    a858:	4618      	mov	r0, r3
    a85a:	b004      	add	sp, #16
    a85c:	4770      	bx	lr
    a85e:	bf00      	nop
    a860:	00010534 	.word	0x00010534

0000a864 <FlexCAN_Ip_GetControllerTxErrorCounter>:
 *                 transmitted messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerTxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerTxErrorCounter(uint8 instance)
{
    a864:	b084      	sub	sp, #16
    a866:	4603      	mov	r3, r0
    a868:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a86c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a870:	4a04      	ldr	r2, [pc, #16]	; (a884 <FlexCAN_Ip_GetControllerTxErrorCounter+0x20>)
    a872:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a876:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_TXERRCNT_MASK) >> FLEXCAN_ECR_TXERRCNT_SHIFT);
    a878:	9b03      	ldr	r3, [sp, #12]
    a87a:	69db      	ldr	r3, [r3, #28]
    a87c:	b2db      	uxtb	r3, r3
}
    a87e:	4618      	mov	r0, r3
    a880:	b004      	add	sp, #16
    a882:	4770      	bx	lr
    a884:	00010534 	.word	0x00010534

0000a888 <FlexCAN_Ip_GetControllerRxErrorCounter>:
 *                 received messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerRxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerRxErrorCounter(uint8 instance)
{
    a888:	b084      	sub	sp, #16
    a88a:	4603      	mov	r3, r0
    a88c:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a890:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a894:	4a05      	ldr	r2, [pc, #20]	; (a8ac <FlexCAN_Ip_GetControllerRxErrorCounter+0x24>)
    a896:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a89a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_RXERRCNT_MASK) >> FLEXCAN_ECR_RXERRCNT_SHIFT);
    a89c:	9b03      	ldr	r3, [sp, #12]
    a89e:	69db      	ldr	r3, [r3, #28]
    a8a0:	0a1b      	lsrs	r3, r3, #8
    a8a2:	b2db      	uxtb	r3, r3
}
    a8a4:	4618      	mov	r0, r3
    a8a6:	b004      	add	sp, #16
    a8a8:	4770      	bx	lr
    a8aa:	bf00      	nop
    a8ac:	00010534 	.word	0x00010534

0000a8b0 <FlexCAN_Error_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements  CAN_X_ERROR_ISR_Activity */
void FlexCAN_Error_IRQHandler(uint8 instance)
{
    a8b0:	b510      	push	{r4, lr}
    a8b2:	b086      	sub	sp, #24
    a8b4:	4603      	mov	r3, r0
    a8b6:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    a8ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a8be:	4a29      	ldr	r2, [pc, #164]	; (a964 <FlexCAN_Error_IRQHandler+0xb4>)
    a8c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8c4:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a8c6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a8ca:	4a27      	ldr	r2, [pc, #156]	; (a968 <FlexCAN_Error_IRQHandler+0xb8>)
    a8cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8d0:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    a8d2:	2300      	movs	r3, #0
    a8d4:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check if the instance initialized */
    if (NULL_PTR != state)
    a8d6:	9b03      	ldr	r3, [sp, #12]
    a8d8:	2b00      	cmp	r3, #0
    a8da:	d03d      	beq.n	a958 <FlexCAN_Error_IRQHandler+0xa8>
    {
        /* Get error status to get value updated */
        u32ErrStatus = pBase->ESR1;
    a8dc:	9b04      	ldr	r3, [sp, #16]
    a8de:	6a1b      	ldr	r3, [r3, #32]
    a8e0:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_MASK))) && ((uint32)0U != (pBase->CTRL1 & ((uint32)FLEXCAN_CTRL1_ERRMSK_MASK))))
    a8e2:	9b05      	ldr	r3, [sp, #20]
    a8e4:	f003 0302 	and.w	r3, r3, #2
    a8e8:	2b00      	cmp	r3, #0
    a8ea:	d019      	beq.n	a920 <FlexCAN_Error_IRQHandler+0x70>
    a8ec:	9b04      	ldr	r3, [sp, #16]
    a8ee:	685b      	ldr	r3, [r3, #4]
    a8f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    a8f4:	2b00      	cmp	r3, #0
    a8f6:	d013      	beq.n	a920 <FlexCAN_Error_IRQHandler+0x70>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_MASK;
    a8f8:	9b04      	ldr	r3, [sp, #16]
    a8fa:	2202      	movs	r2, #2
    a8fc:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    a8fe:	9b03      	ldr	r3, [sp, #12]
    a900:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    a904:	2b00      	cmp	r3, #0
    a906:	d00b      	beq.n	a920 <FlexCAN_Error_IRQHandler+0x70>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR, u32ErrStatus, state);
    a908:	9b03      	ldr	r3, [sp, #12]
    a90a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    a90e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    a912:	9b03      	ldr	r3, [sp, #12]
    a914:	9a05      	ldr	r2, [sp, #20]
    a916:	2105      	movs	r1, #5
    a918:	47a0      	blx	r4
            #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = pBase->ESR1;
    a91a:	9b04      	ldr	r3, [sp, #16]
    a91c:	6a1b      	ldr	r3, [r3, #32]
    a91e:	9305      	str	r3, [sp, #20]
            }
        }

    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Check if this is spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_FAST_MASK))) && ((uint32)0U != (pBase->CTRL2 & ((uint32)FLEXCAN_CTRL2_ERRMSK_FAST_MASK))))
    a920:	9b05      	ldr	r3, [sp, #20]
    a922:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    a926:	2b00      	cmp	r3, #0
    a928:	d019      	beq.n	a95e <FlexCAN_Error_IRQHandler+0xae>
    a92a:	9b04      	ldr	r3, [sp, #16]
    a92c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a92e:	2b00      	cmp	r3, #0
    a930:	da15      	bge.n	a95e <FlexCAN_Error_IRQHandler+0xae>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_FAST_MASK;
    a932:	9b04      	ldr	r3, [sp, #16]
    a934:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    a938:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    a93a:	9b03      	ldr	r3, [sp, #12]
    a93c:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    a940:	2b00      	cmp	r3, #0
    a942:	d00c      	beq.n	a95e <FlexCAN_Error_IRQHandler+0xae>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR_FAST, u32ErrStatus, state);
    a944:	9b03      	ldr	r3, [sp, #12]
    a946:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    a94a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    a94e:	9b03      	ldr	r3, [sp, #12]
    a950:	9a05      	ldr	r2, [sp, #20]
    a952:	2106      	movs	r1, #6
    a954:	47a0      	blx	r4
    }
    else
    {
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    }
}
    a956:	e002      	b.n	a95e <FlexCAN_Error_IRQHandler+0xae>
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    a958:	9b04      	ldr	r3, [sp, #16]
    a95a:	4a04      	ldr	r2, [pc, #16]	; (a96c <FlexCAN_Error_IRQHandler+0xbc>)
    a95c:	621a      	str	r2, [r3, #32]
}
    a95e:	bf00      	nop
    a960:	b006      	add	sp, #24
    a962:	bd10      	pop	{r4, pc}
    a964:	00010534 	.word	0x00010534
    a968:	1fff8fb8 	.word	0x1fff8fb8
    a96c:	00300002 	.word	0x00300002

0000a970 <FlexCAN_BusOff_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements CAN_X_BUSOFF_ISR_Activity */
void FlexCAN_BusOff_IRQHandler(uint8 instance)
{
    a970:	b510      	push	{r4, lr}
    a972:	b086      	sub	sp, #24
    a974:	4603      	mov	r3, r0
    a976:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a97a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a97e:	4a3a      	ldr	r2, [pc, #232]	; (aa68 <FlexCAN_BusOff_IRQHandler+0xf8>)
    a980:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a984:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a986:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a98a:	4a38      	ldr	r2, [pc, #224]	; (aa6c <FlexCAN_BusOff_IRQHandler+0xfc>)
    a98c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a990:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    a992:	2300      	movs	r3, #0
    a994:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check If Driver initialized */
    if (NULL_PTR != state)
    a996:	9b03      	ldr	r3, [sp, #12]
    a998:	2b00      	cmp	r3, #0
    a99a:	d05f      	beq.n	aa5c <FlexCAN_BusOff_IRQHandler+0xec>
    {
        /* Get error status to get value updated */
        u32ErrStatus = base->ESR1;
    a99c:	9b04      	ldr	r3, [sp, #16]
    a99e:	6a1b      	ldr	r3, [r3, #32]
    a9a0:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_TWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_TWRNMSK_MASK))))
    a9a2:	9b05      	ldr	r3, [sp, #20]
    a9a4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    a9a8:	2b00      	cmp	r3, #0
    a9aa:	d01a      	beq.n	a9e2 <FlexCAN_BusOff_IRQHandler+0x72>
    a9ac:	9b04      	ldr	r3, [sp, #16]
    a9ae:	685b      	ldr	r3, [r3, #4]
    a9b0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    a9b4:	2b00      	cmp	r3, #0
    a9b6:	d014      	beq.n	a9e2 <FlexCAN_BusOff_IRQHandler+0x72>
        {
            base->ESR1 = FLEXCAN_ESR1_TWRNINT_MASK;
    a9b8:	9b04      	ldr	r3, [sp, #16]
    a9ba:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    a9be:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    a9c0:	9b03      	ldr	r3, [sp, #12]
    a9c2:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    a9c6:	2b00      	cmp	r3, #0
    a9c8:	d00b      	beq.n	a9e2 <FlexCAN_BusOff_IRQHandler+0x72>
            {
                state->error_callback(instance, FLEXCAN_EVENT_TX_WARNING, u32ErrStatus, state);
    a9ca:	9b03      	ldr	r3, [sp, #12]
    a9cc:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    a9d0:	f89d 0007 	ldrb.w	r0, [sp, #7]
    a9d4:	9b03      	ldr	r3, [sp, #12]
    a9d6:	9a05      	ldr	r2, [sp, #20]
    a9d8:	2109      	movs	r1, #9
    a9da:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    a9dc:	9b04      	ldr	r3, [sp, #16]
    a9de:	6a1b      	ldr	r3, [r3, #32]
    a9e0:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_RWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_RWRNMSK_MASK))))
    a9e2:	9b05      	ldr	r3, [sp, #20]
    a9e4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    a9e8:	2b00      	cmp	r3, #0
    a9ea:	d01a      	beq.n	aa22 <FlexCAN_BusOff_IRQHandler+0xb2>
    a9ec:	9b04      	ldr	r3, [sp, #16]
    a9ee:	685b      	ldr	r3, [r3, #4]
    a9f0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    a9f4:	2b00      	cmp	r3, #0
    a9f6:	d014      	beq.n	aa22 <FlexCAN_BusOff_IRQHandler+0xb2>
        {
            base->ESR1 = FLEXCAN_ESR1_RWRNINT_MASK;
    a9f8:	9b04      	ldr	r3, [sp, #16]
    a9fa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    a9fe:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    aa00:	9b03      	ldr	r3, [sp, #12]
    aa02:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    aa06:	2b00      	cmp	r3, #0
    aa08:	d00b      	beq.n	aa22 <FlexCAN_BusOff_IRQHandler+0xb2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_RX_WARNING, u32ErrStatus, state);
    aa0a:	9b03      	ldr	r3, [sp, #12]
    aa0c:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    aa10:	f89d 0007 	ldrb.w	r0, [sp, #7]
    aa14:	9b03      	ldr	r3, [sp, #12]
    aa16:	9a05      	ldr	r2, [sp, #20]
    aa18:	2108      	movs	r1, #8
    aa1a:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    aa1c:	9b04      	ldr	r3, [sp, #16]
    aa1e:	6a1b      	ldr	r3, [r3, #32]
    aa20:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_BOFFINT_MASK))) && ((uint32)0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_BOFFMSK_MASK))))
    aa22:	9b05      	ldr	r3, [sp, #20]
    aa24:	f003 0304 	and.w	r3, r3, #4
    aa28:	2b00      	cmp	r3, #0
    aa2a:	d01a      	beq.n	aa62 <FlexCAN_BusOff_IRQHandler+0xf2>
    aa2c:	9b04      	ldr	r3, [sp, #16]
    aa2e:	685b      	ldr	r3, [r3, #4]
    aa30:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    aa34:	2b00      	cmp	r3, #0
    aa36:	d014      	beq.n	aa62 <FlexCAN_BusOff_IRQHandler+0xf2>
        {
            base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    aa38:	9b04      	ldr	r3, [sp, #16]
    aa3a:	2204      	movs	r2, #4
    aa3c:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    aa3e:	9b03      	ldr	r3, [sp, #12]
    aa40:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    aa44:	2b00      	cmp	r3, #0
    aa46:	d00c      	beq.n	aa62 <FlexCAN_BusOff_IRQHandler+0xf2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    aa48:	9b03      	ldr	r3, [sp, #12]
    aa4a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    aa4e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    aa52:	9b03      	ldr	r3, [sp, #12]
    aa54:	9a05      	ldr	r2, [sp, #20]
    aa56:	2107      	movs	r1, #7
    aa58:	47a0      	blx	r4
    }
    else
    {
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    }
}
    aa5a:	e002      	b.n	aa62 <FlexCAN_BusOff_IRQHandler+0xf2>
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    aa5c:	9b04      	ldr	r3, [sp, #16]
    aa5e:	4a04      	ldr	r2, [pc, #16]	; (aa70 <FlexCAN_BusOff_IRQHandler+0x100>)
    aa60:	621a      	str	r2, [r3, #32]
}
    aa62:	bf00      	nop
    aa64:	b006      	add	sp, #24
    aa66:	bd10      	pop	{r4, pc}
    aa68:	00010534 	.word	0x00010534
    aa6c:	1fff8fb8 	.word	0x1fff8fb8
    aa70:	000b0004 	.word	0x000b0004

0000aa74 <FlexCAN_Ip_SendBlocking>:
                                              const Flexcan_Ip_DataInfoType * tx_info,
                                              uint32 msg_id,
                                              const uint8 * mb_data,
                                              uint32 timeout_ms
                                             )
{
    aa74:	b500      	push	{lr}
    aa76:	b091      	sub	sp, #68	; 0x44
    aa78:	9204      	str	r2, [sp, #16]
    aa7a:	9303      	str	r3, [sp, #12]
    aa7c:	4603      	mov	r3, r0
    aa7e:	f88d 3017 	strb.w	r3, [sp, #23]
    aa82:	460b      	mov	r3, r1
    aa84:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    aa88:	f89d 3017 	ldrb.w	r3, [sp, #23]
    aa8c:	4a5f      	ldr	r2, [pc, #380]	; (ac0c <FlexCAN_Ip_SendBlocking+0x198>)
    aa8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa92:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    aa94:	f89d 3017 	ldrb.w	r3, [sp, #23]
    aa98:	4a5d      	ldr	r2, [pc, #372]	; (ac10 <FlexCAN_Ip_SendBlocking+0x19c>)
    aa9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa9e:	930c      	str	r3, [sp, #48]	; 0x30

    uint32 timeStart = 0U;
    aaa0:	2300      	movs	r3, #0
    aaa2:	9307      	str	r3, [sp, #28]
    uint32 timeElapsed = 0U;
    aaa4:	2300      	movs	r3, #0
    aaa6:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 mS2Ticks = OsIf_MicrosToTicks((timeout_ms * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    aaa8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    aaaa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    aaae:	fb02 f303 	mul.w	r3, r2, r3
    aab2:	2100      	movs	r1, #0
    aab4:	4618      	mov	r0, r3
    aab6:	f7f7 fbef 	bl	2298 <OsIf_MicrosToTicks>
    aaba:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32 uS2Ticks = 0U;
    aabc:	2300      	movs	r3, #0
    aabe:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 flexcan_mb_config = 0;
    aac0:	2300      	movs	r3, #0
    aac2:	9309      	str	r3, [sp, #36]	; 0x24

    volatile uint32 * flexcan_mb = NULL_PTR;
    aac4:	2300      	movs	r3, #0
    aac6:	9308      	str	r3, [sp, #32]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif

    result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    aac8:	f89d 1016 	ldrb.w	r1, [sp, #22]
    aacc:	f89d 0017 	ldrb.w	r0, [sp, #23]
    aad0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    aad2:	9300      	str	r3, [sp, #0]
    aad4:	9b03      	ldr	r3, [sp, #12]
    aad6:	9a04      	ldr	r2, [sp, #16]
    aad8:	f7fe feaa 	bl	9830 <FlexCAN_StartSendData>
    aadc:	900f      	str	r0, [sp, #60]	; 0x3c

    if (FLEXCAN_STATUS_SUCCESS == result)
    aade:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    aae0:	2b00      	cmp	r3, #0
    aae2:	f040 808d 	bne.w	ac00 <FlexCAN_Ip_SendBlocking+0x18c>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    aae6:	2000      	movs	r0, #0
    aae8:	f7f7 fb8a 	bl	2200 <OsIf_GetCounter>
    aaec:	4603      	mov	r3, r0
    aaee:	9307      	str	r3, [sp, #28]
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    aaf0:	e00f      	b.n	ab12 <FlexCAN_Ip_SendBlocking+0x9e>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    aaf2:	ab07      	add	r3, sp, #28
    aaf4:	2100      	movs	r1, #0
    aaf6:	4618      	mov	r0, r3
    aaf8:	f7f7 fb9b 	bl	2232 <OsIf_GetElapsed>
    aafc:	4602      	mov	r2, r0
    aafe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ab00:	4413      	add	r3, r2
    ab02:	930e      	str	r3, [sp, #56]	; 0x38
            if (timeElapsed >= mS2Ticks)
    ab04:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    ab06:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab08:	429a      	cmp	r2, r3
    ab0a:	d302      	bcc.n	ab12 <FlexCAN_Ip_SendBlocking+0x9e>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    ab0c:	2303      	movs	r3, #3
    ab0e:	930f      	str	r3, [sp, #60]	; 0x3c
                break;
    ab10:	e008      	b.n	ab24 <FlexCAN_Ip_SendBlocking+0xb0>
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    ab12:	f89d 3016 	ldrb.w	r3, [sp, #22]
    ab16:	4619      	mov	r1, r3
    ab18:	980d      	ldr	r0, [sp, #52]	; 0x34
    ab1a:	f7fe fab6 	bl	908a <FlexCAN_GetBuffStatusFlag>
    ab1e:	4603      	mov	r3, r0
    ab20:	2b01      	cmp	r3, #1
    ab22:	d1e6      	bne.n	aaf2 <FlexCAN_Ip_SendBlocking+0x7e>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == result) && (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE))
    ab24:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    ab26:	2b03      	cmp	r3, #3
    ab28:	d15c      	bne.n	abe4 <FlexCAN_Ip_SendBlocking+0x170>
    ab2a:	f89d 3016 	ldrb.w	r3, [sp, #22]
    ab2e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ab30:	011b      	lsls	r3, r3, #4
    ab32:	4413      	add	r3, r2
    ab34:	3304      	adds	r3, #4
    ab36:	681b      	ldr	r3, [r3, #0]
    ab38:	2b00      	cmp	r3, #0
    ab3a:	d053      	beq.n	abe4 <FlexCAN_Ip_SendBlocking+0x170>
        {
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    ab3c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    ab40:	4619      	mov	r1, r3
    ab42:	980d      	ldr	r0, [sp, #52]	; 0x34
    ab44:	f7fe fa8e 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
                flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    ab48:	f89d 3016 	ldrb.w	r3, [sp, #22]
    ab4c:	4619      	mov	r1, r3
    ab4e:	980d      	ldr	r0, [sp, #52]	; 0x34
    ab50:	f001 f968 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    ab54:	9008      	str	r0, [sp, #32]
                flexcan_mb_config = * flexcan_mb;
    ab56:	9b08      	ldr	r3, [sp, #32]
    ab58:	681b      	ldr	r3, [r3, #0]
    ab5a:	9309      	str	r3, [sp, #36]	; 0x24
                /* Reset the code */
                flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    ab5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ab5e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    ab62:	9309      	str	r3, [sp, #36]	; 0x24
                flexcan_mb_config |= ((uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    ab64:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ab66:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    ab6a:	9309      	str	r3, [sp, #36]	; 0x24
                *flexcan_mb = flexcan_mb_config;
    ab6c:	9b08      	ldr	r3, [sp, #32]
    ab6e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ab70:	601a      	str	r2, [r3, #0]

                /* Wait to finish abort operation */
                uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab72:	2100      	movs	r1, #0
    ab74:	4827      	ldr	r0, [pc, #156]	; (ac14 <FlexCAN_Ip_SendBlocking+0x1a0>)
    ab76:	f7f7 fb8f 	bl	2298 <OsIf_MicrosToTicks>
    ab7a:	900a      	str	r0, [sp, #40]	; 0x28
                timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab7c:	2000      	movs	r0, #0
    ab7e:	f7f7 fb3f 	bl	2200 <OsIf_GetCounter>
    ab82:	4603      	mov	r3, r0
    ab84:	9307      	str	r3, [sp, #28]
                 timeElapsed = 0U;
    ab86:	2300      	movs	r3, #0
    ab88:	930e      	str	r3, [sp, #56]	; 0x38
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    ab8a:	e00f      	b.n	abac <FlexCAN_Ip_SendBlocking+0x138>
                {
                    timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab8c:	ab07      	add	r3, sp, #28
    ab8e:	2100      	movs	r1, #0
    ab90:	4618      	mov	r0, r3
    ab92:	f7f7 fb4e 	bl	2232 <OsIf_GetElapsed>
    ab96:	4602      	mov	r2, r0
    ab98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ab9a:	4413      	add	r3, r2
    ab9c:	930e      	str	r3, [sp, #56]	; 0x38
                    if (timeElapsed >= uS2Ticks)
    ab9e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    aba0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aba2:	429a      	cmp	r2, r3
    aba4:	d302      	bcc.n	abac <FlexCAN_Ip_SendBlocking+0x138>
                    {
                        result = FLEXCAN_STATUS_TIMEOUT;
    aba6:	2303      	movs	r3, #3
    aba8:	930f      	str	r3, [sp, #60]	; 0x3c
                        break;
    abaa:	e008      	b.n	abbe <FlexCAN_Ip_SendBlocking+0x14a>
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    abac:	f89d 3016 	ldrb.w	r3, [sp, #22]
    abb0:	4619      	mov	r1, r3
    abb2:	980d      	ldr	r0, [sp, #52]	; 0x34
    abb4:	f7fe fa69 	bl	908a <FlexCAN_GetBuffStatusFlag>
    abb8:	4603      	mov	r3, r0
    abba:	2b00      	cmp	r3, #0
    abbc:	d0e6      	beq.n	ab8c <FlexCAN_Ip_SendBlocking+0x118>
                    }
                }

                flexcan_mb_config = *flexcan_mb;
    abbe:	9b08      	ldr	r3, [sp, #32]
    abc0:	681b      	ldr	r3, [r3, #0]
    abc2:	9309      	str	r3, [sp, #36]	; 0x24
                /* Check if the MBs have been safely Inactivated */
                if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    abc4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    abc6:	0e1b      	lsrs	r3, r3, #24
    abc8:	f003 030f 	and.w	r3, r3, #15
    abcc:	2b08      	cmp	r3, #8
    abce:	d101      	bne.n	abd4 <FlexCAN_Ip_SendBlocking+0x160>
                {
                    /* Transmission have occurred */
                    result = FLEXCAN_STATUS_SUCCESS;
    abd0:	2300      	movs	r3, #0
    abd2:	930f      	str	r3, [sp, #60]	; 0x3c
                }

                if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    abd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    abd6:	0e1b      	lsrs	r3, r3, #24
    abd8:	f003 030f 	and.w	r3, r3, #15
    abdc:	2b09      	cmp	r3, #9
    abde:	d101      	bne.n	abe4 <FlexCAN_Ip_SendBlocking+0x170>
                {
                    /* Transmission have been aborted */
                    result = FLEXCAN_STATUS_TIMEOUT;
    abe0:	2303      	movs	r3, #3
    abe2:	930f      	str	r3, [sp, #60]	; 0x3c
                }
        }

        /* Clear message buffer flag */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    abe4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    abe8:	4619      	mov	r1, r3
    abea:	980d      	ldr	r0, [sp, #52]	; 0x34
    abec:	f7fe fa3a 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>

        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    abf0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    abf4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    abf6:	011b      	lsls	r3, r3, #4
    abf8:	4413      	add	r3, r2
    abfa:	3304      	adds	r3, #4
    abfc:	2200      	movs	r2, #0
    abfe:	601a      	str	r2, [r3, #0]
    }
    return result;
    ac00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
    ac02:	4618      	mov	r0, r3
    ac04:	b011      	add	sp, #68	; 0x44
    ac06:	f85d fb04 	ldr.w	pc, [sp], #4
    ac0a:	bf00      	nop
    ac0c:	00010534 	.word	0x00010534
    ac10:	1fff8fb8 	.word	0x1fff8fb8
    ac14:	000f4240 	.word	0x000f4240

0000ac18 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_SetRxMbGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMbGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    ac18:	b500      	push	{lr}
    ac1a:	b087      	sub	sp, #28
    ac1c:	4603      	mov	r3, r0
    ac1e:	9100      	str	r1, [sp, #0]
    ac20:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    ac24:	2300      	movs	r3, #0
    ac26:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    ac28:	2300      	movs	r3, #0
    ac2a:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    ac2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ac30:	4a1c      	ldr	r2, [pc, #112]	; (aca4 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x8c>)
    ac32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac36:	9303      	str	r3, [sp, #12]
#endif

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    ac38:	9803      	ldr	r0, [sp, #12]
    ac3a:	f7fe f9b9 	bl	8fb0 <FlexCAN_IsEnabled>
    ac3e:	4603      	mov	r3, r0
    ac40:	2b00      	cmp	r3, #0
    ac42:	bf14      	ite	ne
    ac44:	2301      	movne	r3, #1
    ac46:	2300      	moveq	r3, #0
    ac48:	b2db      	uxtb	r3, r3
    ac4a:	f083 0301 	eor.w	r3, r3, #1
    ac4e:	b2db      	uxtb	r3, r3
    ac50:	f88d 300b 	strb.w	r3, [sp, #11]
    ac54:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ac58:	f003 0301 	and.w	r3, r3, #1
    ac5c:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    ac60:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ac64:	2b00      	cmp	r3, #0
    ac66:	d003      	beq.n	ac70 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    ac68:	9803      	ldr	r0, [sp, #12]
    ac6a:	f001 f9c3 	bl	bff4 <FlexCAN_Enable>
    ac6e:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    ac70:	9b05      	ldr	r3, [sp, #20]
    ac72:	2b00      	cmp	r3, #0
    ac74:	d103      	bne.n	ac7e <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxMsgBuffGlobalMask(pBase, mask);
    ac76:	9900      	ldr	r1, [sp, #0]
    ac78:	9803      	ldr	r0, [sp, #12]
    ac7a:	f7fe fbc3 	bl	9404 <FlexCAN_SetRxMsgBuffGlobalMask>
    }

    if (TRUE == disabled)
    ac7e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ac82:	2b00      	cmp	r3, #0
    ac84:	d008      	beq.n	ac98 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    ac86:	9803      	ldr	r0, [sp, #12]
    ac88:	f001 fa32 	bl	c0f0 <FlexCAN_Disable>
    ac8c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    ac8e:	9b04      	ldr	r3, [sp, #16]
    ac90:	2b00      	cmp	r3, #0
    ac92:	d001      	beq.n	ac98 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
        {
            result = status;
    ac94:	9b04      	ldr	r3, [sp, #16]
    ac96:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    ac98:	9b05      	ldr	r3, [sp, #20]
}
    ac9a:	4618      	mov	r0, r3
    ac9c:	b007      	add	sp, #28
    ac9e:	f85d fb04 	ldr.w	pc, [sp], #4
    aca2:	bf00      	nop
    aca4:	00010534 	.word	0x00010534

0000aca8 <FlexCAN_Ip_EnterFreezeMode_Privileged>:
 * Description   : Enter Driver In freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnterFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnterFreezeMode_Privileged(uint8 instance)
{
    aca8:	b500      	push	{lr}
    acaa:	b085      	sub	sp, #20
    acac:	4603      	mov	r3, r0
    acae:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    acb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    acb6:	4a06      	ldr	r2, [pc, #24]	; (acd0 <FlexCAN_Ip_EnterFreezeMode_Privileged+0x28>)
    acb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    acbc:	9303      	str	r3, [sp, #12]
        return FlexCAN_EnterFreezeMode(base);
    acbe:	9803      	ldr	r0, [sp, #12]
    acc0:	f001 f94c 	bl	bf5c <FlexCAN_EnterFreezeMode>
    acc4:	4603      	mov	r3, r0
}
    acc6:	4618      	mov	r0, r3
    acc8:	b005      	add	sp, #20
    acca:	f85d fb04 	ldr.w	pc, [sp], #4
    acce:	bf00      	nop
    acd0:	00010534 	.word	0x00010534

0000acd4 <FlexCAN_Ip_ExitFreezeMode_Privileged>:
 * Description   : Exit Driver from freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ExitFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ExitFreezeMode_Privileged(uint8 instance)
{
    acd4:	b500      	push	{lr}
    acd6:	b085      	sub	sp, #20
    acd8:	4603      	mov	r3, r0
    acda:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    acde:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ace2:	4a06      	ldr	r2, [pc, #24]	; (acfc <FlexCAN_Ip_ExitFreezeMode_Privileged+0x28>)
    ace4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ace8:	9303      	str	r3, [sp, #12]
        return FlexCAN_ExitFreezeMode(base);
    acea:	9803      	ldr	r0, [sp, #12]
    acec:	f001 f9be 	bl	c06c <FlexCAN_ExitFreezeMode>
    acf0:	4603      	mov	r3, r0
}
    acf2:	4618      	mov	r0, r3
    acf4:	b005      	add	sp, #20
    acf6:	f85d fb04 	ldr.w	pc, [sp], #4
    acfa:	bf00      	nop
    acfc:	00010534 	.word	0x00010534

0000ad00 <FlexCAN_Ip_SetRxIndividualMask_Privileged>:
 * Description   : Set Rx individual mask as absolute value provided by mask parameter
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxIndividualMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxIndividualMask_Privileged(uint8 instance, uint8 mb_idx, uint32 mask)
{
    ad00:	b500      	push	{lr}
    ad02:	b087      	sub	sp, #28
    ad04:	4603      	mov	r3, r0
    ad06:	9200      	str	r2, [sp, #0]
    ad08:	f88d 3007 	strb.w	r3, [sp, #7]
    ad0c:	460b      	mov	r3, r1
    ad0e:	f88d 3006 	strb.w	r3, [sp, #6]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    ad12:	2300      	movs	r3, #0
    ad14:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    ad16:	2300      	movs	r3, #0
    ad18:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    ad1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ad1e:	4a1e      	ldr	r2, [pc, #120]	; (ad98 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x98>)
    ad20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad24:	9303      	str	r3, [sp, #12]
    }
    else
    {
#endif

    boolean disabled = !FlexCAN_IsEnabled(pBase);
    ad26:	9803      	ldr	r0, [sp, #12]
    ad28:	f7fe f942 	bl	8fb0 <FlexCAN_IsEnabled>
    ad2c:	4603      	mov	r3, r0
    ad2e:	2b00      	cmp	r3, #0
    ad30:	bf14      	ite	ne
    ad32:	2301      	movne	r3, #1
    ad34:	2300      	moveq	r3, #0
    ad36:	b2db      	uxtb	r3, r3
    ad38:	f083 0301 	eor.w	r3, r3, #1
    ad3c:	b2db      	uxtb	r3, r3
    ad3e:	f88d 300b 	strb.w	r3, [sp, #11]
    ad42:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ad46:	f003 0301 	and.w	r3, r3, #1
    ad4a:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    ad4e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ad52:	2b00      	cmp	r3, #0
    ad54:	d003      	beq.n	ad5e <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    ad56:	9803      	ldr	r0, [sp, #12]
    ad58:	f001 f94c 	bl	bff4 <FlexCAN_Enable>
    ad5c:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    ad5e:	9b05      	ldr	r3, [sp, #20]
    ad60:	2b00      	cmp	r3, #0
    ad62:	d106      	bne.n	ad72 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x72>
    {
        FlexCAN_SetRxIndividualMask(pBase, mb_idx, mask);
    ad64:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ad68:	9a00      	ldr	r2, [sp, #0]
    ad6a:	4619      	mov	r1, r3
    ad6c:	9803      	ldr	r0, [sp, #12]
    ad6e:	f7fe fb52 	bl	9416 <FlexCAN_SetRxIndividualMask>
    }

    if (TRUE == disabled)
    ad72:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ad76:	2b00      	cmp	r3, #0
    ad78:	d008      	beq.n	ad8c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    ad7a:	9803      	ldr	r0, [sp, #12]
    ad7c:	f001 f9b8 	bl	c0f0 <FlexCAN_Disable>
    ad80:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    ad82:	9b04      	ldr	r3, [sp, #16]
    ad84:	2b00      	cmp	r3, #0
    ad86:	d001      	beq.n	ad8c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
        {
            result = status;
    ad88:	9b04      	ldr	r3, [sp, #16]
    ad8a:	9305      	str	r3, [sp, #20]
        }
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    ad8c:	9b05      	ldr	r3, [sp, #20]
}
    ad8e:	4618      	mov	r0, r3
    ad90:	b007      	add	sp, #28
    ad92:	f85d fb04 	ldr.w	pc, [sp], #4
    ad96:	bf00      	nop
    ad98:	00010534 	.word	0x00010534

0000ad9c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>:
 * Description   : Set RxFifo Global Mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxFifoGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxFifoGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    ad9c:	b500      	push	{lr}
    ad9e:	b087      	sub	sp, #28
    ada0:	4603      	mov	r3, r0
    ada2:	9100      	str	r1, [sp, #0]
    ada4:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    ada8:	2300      	movs	r3, #0
    adaa:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    adac:	2300      	movs	r3, #0
    adae:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    adb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    adb4:	4a1c      	ldr	r2, [pc, #112]	; (ae28 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x8c>)
    adb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    adba:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    adbc:	9803      	ldr	r0, [sp, #12]
    adbe:	f7fe f8f7 	bl	8fb0 <FlexCAN_IsEnabled>
    adc2:	4603      	mov	r3, r0
    adc4:	2b00      	cmp	r3, #0
    adc6:	bf14      	ite	ne
    adc8:	2301      	movne	r3, #1
    adca:	2300      	moveq	r3, #0
    adcc:	b2db      	uxtb	r3, r3
    adce:	f083 0301 	eor.w	r3, r3, #1
    add2:	b2db      	uxtb	r3, r3
    add4:	f88d 300b 	strb.w	r3, [sp, #11]
    add8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    addc:	f003 0301 	and.w	r3, r3, #1
    ade0:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    ade4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ade8:	2b00      	cmp	r3, #0
    adea:	d003      	beq.n	adf4 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    adec:	9803      	ldr	r0, [sp, #12]
    adee:	f001 f901 	bl	bff4 <FlexCAN_Enable>
    adf2:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    adf4:	9b05      	ldr	r3, [sp, #20]
    adf6:	2b00      	cmp	r3, #0
    adf8:	d103      	bne.n	ae02 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxFifoGlobalMask(pBase, mask);
    adfa:	9900      	ldr	r1, [sp, #0]
    adfc:	9803      	ldr	r0, [sp, #12]
    adfe:	f7fe f8a7 	bl	8f50 <FlexCAN_SetRxFifoGlobalMask>
    }

    if (TRUE == disabled)
    ae02:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ae06:	2b00      	cmp	r3, #0
    ae08:	d008      	beq.n	ae1c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    ae0a:	9803      	ldr	r0, [sp, #12]
    ae0c:	f001 f970 	bl	c0f0 <FlexCAN_Disable>
    ae10:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    ae12:	9b04      	ldr	r3, [sp, #16]
    ae14:	2b00      	cmp	r3, #0
    ae16:	d001      	beq.n	ae1c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
        {
            result = status;
    ae18:	9b04      	ldr	r3, [sp, #16]
    ae1a:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    ae1c:	9b05      	ldr	r3, [sp, #20]
}
    ae1e:	4618      	mov	r0, r3
    ae20:	b007      	add	sp, #28
    ae22:	f85d fb04 	ldr.w	pc, [sp], #4
    ae26:	bf00      	nop
    ae28:	00010534 	.word	0x00010534

0000ae2c <FlexCAN_Ip_Deinit_Privileged>:
 * This function will disable all FlexCAN interrupts, and disable the FlexCAN.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_Deinit_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Deinit_Privileged(uint8 instance)
{
    ae2c:	b500      	push	{lr}
    ae2e:	b085      	sub	sp, #20
    ae30:	4603      	mov	r3, r0
    ae32:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ae36:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ae3a:	4a0e      	ldr	r2, [pc, #56]	; (ae74 <FlexCAN_Ip_Deinit_Privileged+0x48>)
    ae3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae40:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Enter Freeze Mode Required before to enter Disabled Mode */
    result = FlexCAN_EnterFreezeMode(base);
    ae42:	9803      	ldr	r0, [sp, #12]
    ae44:	f001 f88a 	bl	bf5c <FlexCAN_EnterFreezeMode>
    ae48:	9002      	str	r0, [sp, #8]
    if (FLEXCAN_STATUS_SUCCESS == result)
    ae4a:	9b02      	ldr	r3, [sp, #8]
    ae4c:	2b00      	cmp	r3, #0
    ae4e:	d10b      	bne.n	ae68 <FlexCAN_Ip_Deinit_Privileged+0x3c>
    {
        /* Reset registers */
        FlexCAN_SetRegDefaultVal(base);
    ae50:	9803      	ldr	r0, [sp, #12]
    ae52:	f7fe fb18 	bl	9486 <FlexCAN_SetRegDefaultVal>
        /* wait for disable */
        (void)FlexCAN_Disable(base);
    ae56:	9803      	ldr	r0, [sp, #12]
    ae58:	f001 f94a 	bl	c0f0 <FlexCAN_Disable>
        /* Clear state pointer that is checked by FLEXCAN_DRV_Init */
        Flexcan_Ip_apxState[instance] = NULL_PTR;
    ae5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ae60:	4a05      	ldr	r2, [pc, #20]	; (ae78 <FlexCAN_Ip_Deinit_Privileged+0x4c>)
    ae62:	2100      	movs	r1, #0
    ae64:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            OsIf_Trusted_Call1param(FlexCAN_ClrUserAccessAllowed, base);
        }
    #endif
    }

    return result;
    ae68:	9b02      	ldr	r3, [sp, #8]
}
    ae6a:	4618      	mov	r0, r3
    ae6c:	b005      	add	sp, #20
    ae6e:	f85d fb04 	ldr.w	pc, [sp], #4
    ae72:	bf00      	nop
    ae74:	00010534 	.word	0x00010534
    ae78:	1fff8fb8 	.word	0x1fff8fb8

0000ae7c <FlexCAN_Ip_MainFunctionRead>:
 * This function read the messages received as pulling or if the Interrupts are disabled.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionRead_Activity */
void FlexCAN_Ip_MainFunctionRead(uint8 instance, uint8 mb_idx)
{
    ae7c:	b500      	push	{lr}
    ae7e:	b085      	sub	sp, #20
    ae80:	4603      	mov	r3, r0
    ae82:	460a      	mov	r2, r1
    ae84:	f88d 3007 	strb.w	r3, [sp, #7]
    ae88:	4613      	mov	r3, r2
    ae8a:	f88d 3006 	strb.w	r3, [sp, #6]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ae8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ae92:	4a22      	ldr	r2, [pc, #136]	; (af1c <FlexCAN_Ip_MainFunctionRead+0xa0>)
    ae94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae98:	9303      	str	r3, [sp, #12]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    ae9a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ae9e:	4a20      	ldr	r2, [pc, #128]	; (af20 <FlexCAN_Ip_MainFunctionRead+0xa4>)
    aea0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aea4:	9302      	str	r3, [sp, #8]
        }
    }
    else
    {
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
        if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    aea6:	9b02      	ldr	r3, [sp, #8]
    aea8:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    aeac:	2b00      	cmp	r3, #0
    aeae:	d015      	beq.n	aedc <FlexCAN_Ip_MainFunctionRead+0x60>
    aeb0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aeb4:	2b07      	cmp	r3, #7
    aeb6:	d811      	bhi.n	aedc <FlexCAN_Ip_MainFunctionRead+0x60>
        {
            /* just process available legacy fifo event only */
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    aeb8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aebc:	2b00      	cmp	r3, #0
    aebe:	d128      	bne.n	af12 <FlexCAN_Ip_MainFunctionRead+0x96>
            {
                if (FlexCAN_GetBuffStatusFlag(base, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE) != 0U)
    aec0:	2105      	movs	r1, #5
    aec2:	9803      	ldr	r0, [sp, #12]
    aec4:	f7fe f8e1 	bl	908a <FlexCAN_GetBuffStatusFlag>
    aec8:	4603      	mov	r3, r0
    aeca:	2b00      	cmp	r3, #0
    aecc:	d021      	beq.n	af12 <FlexCAN_Ip_MainFunctionRead+0x96>
                {
                    FlexCAN_IRQHandlerRxFIFO(instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE);
    aece:	f89d 3007 	ldrb.w	r3, [sp, #7]
    aed2:	2105      	movs	r1, #5
    aed4:	4618      	mov	r0, r3
    aed6:	f7fe ff17 	bl	9d08 <FlexCAN_IRQHandlerRxFIFO>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    aeda:	e01a      	b.n	af12 <FlexCAN_Ip_MainFunctionRead+0x96>
                }
            }
        }
        else
        {
            if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    aedc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aee0:	4619      	mov	r1, r3
    aee2:	9803      	ldr	r0, [sp, #12]
    aee4:	f7fe f8d1 	bl	908a <FlexCAN_GetBuffStatusFlag>
    aee8:	4603      	mov	r3, r0
    aeea:	2b00      	cmp	r3, #0
    aeec:	d012      	beq.n	af14 <FlexCAN_Ip_MainFunctionRead+0x98>
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    aeee:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aef2:	9a02      	ldr	r2, [sp, #8]
    aef4:	011b      	lsls	r3, r3, #4
    aef6:	4413      	add	r3, r2
    aef8:	3304      	adds	r3, #4
    aefa:	681b      	ldr	r3, [r3, #0]
    aefc:	2b01      	cmp	r3, #1
    aefe:	d109      	bne.n	af14 <FlexCAN_Ip_MainFunctionRead+0x98>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    af00:	f89d 2006 	ldrb.w	r2, [sp, #6]
    af04:	f89d 3007 	ldrb.w	r3, [sp, #7]
    af08:	4611      	mov	r1, r2
    af0a:	4618      	mov	r0, r3
    af0c:	f7fe fd74 	bl	99f8 <FlexCAN_IRQHandlerRxMB>
            }
        }
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
}
    af10:	e000      	b.n	af14 <FlexCAN_Ip_MainFunctionRead+0x98>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    af12:	bf00      	nop
}
    af14:	bf00      	nop
    af16:	b005      	add	sp, #20
    af18:	f85d fb04 	ldr.w	pc, [sp], #4
    af1c:	00010534 	.word	0x00010534
    af20:	1fff8fb8 	.word	0x1fff8fb8

0000af24 <FlexCAN_Ip_MainFunctionBusOff_Privileged>:
 * This function check the bus off event.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionBusOff_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_MainFunctionBusOff_Privileged(uint8 instance)
{
    af24:	b510      	push	{r4, lr}
    af26:	b086      	sub	sp, #24
    af28:	4603      	mov	r3, r0
    af2a:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    af2e:	2301      	movs	r3, #1
    af30:	9305      	str	r3, [sp, #20]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    af32:	f89d 3007 	ldrb.w	r3, [sp, #7]
    af36:	4a15      	ldr	r2, [pc, #84]	; (af8c <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x68>)
    af38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af3c:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    af3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    af42:	4a13      	ldr	r2, [pc, #76]	; (af90 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x6c>)
    af44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af48:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    af4a:	2300      	movs	r3, #0
    af4c:	9302      	str	r3, [sp, #8]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Get error status */
    u32ErrStatus = base->ESR1;
    af4e:	9b04      	ldr	r3, [sp, #16]
    af50:	6a1b      	ldr	r3, [r3, #32]
    af52:	9302      	str	r3, [sp, #8]

    if (0U != (u32ErrStatus & FLEXCAN_ESR1_BOFFINT_MASK))
    af54:	9b02      	ldr	r3, [sp, #8]
    af56:	f003 0304 	and.w	r3, r3, #4
    af5a:	2b00      	cmp	r3, #0
    af5c:	d012      	beq.n	af84 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x60>
    {
        /* Invoke callback */
        if (state->error_callback != NULL_PTR)
    af5e:	9b03      	ldr	r3, [sp, #12]
    af60:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    af64:	2b00      	cmp	r3, #0
    af66:	d008      	beq.n	af7a <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x56>
        {
            state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    af68:	9b03      	ldr	r3, [sp, #12]
    af6a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    af6e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    af72:	9b03      	ldr	r3, [sp, #12]
    af74:	9a02      	ldr	r2, [sp, #8]
    af76:	2107      	movs	r1, #7
    af78:	47a0      	blx	r4
        }
        /* Clear BusOff Status Flag */
        base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    af7a:	9b04      	ldr	r3, [sp, #16]
    af7c:	2204      	movs	r2, #4
    af7e:	621a      	str	r2, [r3, #32]
        eRetVal = FLEXCAN_STATUS_SUCCESS;
    af80:	2300      	movs	r3, #0
    af82:	9305      	str	r3, [sp, #20]
    }
    return eRetVal;
    af84:	9b05      	ldr	r3, [sp, #20]
}
    af86:	4618      	mov	r0, r3
    af88:	b006      	add	sp, #24
    af8a:	bd10      	pop	{r4, pc}
    af8c:	00010534 	.word	0x00010534
    af90:	1fff8fb8 	.word	0x1fff8fb8

0000af94 <FlexCAN_Ip_MainFunctionWrite>:
 * This function check the message if have been sent.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionWrite_Activity */
void FlexCAN_Ip_MainFunctionWrite(uint8 instance, uint8 mb_idx)
{
    af94:	b510      	push	{r4, lr}
    af96:	b098      	sub	sp, #96	; 0x60
    af98:	4603      	mov	r3, r0
    af9a:	460a      	mov	r2, r1
    af9c:	f88d 3007 	strb.w	r3, [sp, #7]
    afa0:	4613      	mov	r3, r2
    afa2:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    afa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    afaa:	4a3f      	ldr	r2, [pc, #252]	; (b0a8 <FlexCAN_Ip_MainFunctionWrite+0x114>)
    afac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afb0:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    afb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    afb6:	4a3d      	ldr	r2, [pc, #244]	; (b0ac <FlexCAN_Ip_MainFunctionWrite+0x118>)
    afb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afbc:	9316      	str	r3, [sp, #88]	; 0x58

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    afbe:	f89d 3006 	ldrb.w	r3, [sp, #6]
    afc2:	4619      	mov	r1, r3
    afc4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    afc6:	f7fe f860 	bl	908a <FlexCAN_GetBuffStatusFlag>
    afca:	4603      	mov	r3, r0
    afcc:	2b00      	cmp	r3, #0
    afce:	d068      	beq.n	b0a2 <FlexCAN_Ip_MainFunctionWrite+0x10e>
    {
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    afd0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    afd4:	9a16      	ldr	r2, [sp, #88]	; 0x58
    afd6:	011b      	lsls	r3, r3, #4
    afd8:	4413      	add	r3, r2
    afda:	3304      	adds	r3, #4
    afdc:	681b      	ldr	r3, [r3, #0]
    afde:	2b02      	cmp	r3, #2
    afe0:	d15f      	bne.n	b0a2 <FlexCAN_Ip_MainFunctionWrite+0x10e>
        {
            if (state->mbs[mb_idx].isRemote)
    afe2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    afe6:	9a16      	ldr	r2, [sp, #88]	; 0x58
    afe8:	011b      	lsls	r3, r3, #4
    afea:	4413      	add	r3, r2
    afec:	3309      	adds	r3, #9
    afee:	781b      	ldrb	r3, [r3, #0]
    aff0:	2b00      	cmp	r3, #0
    aff2:	d028      	beq.n	b046 <FlexCAN_Ip_MainFunctionWrite+0xb2>
            {
                Flexcan_Ip_MsgBuffType mb;
                mb.cs = 0U;
    aff4:	2300      	movs	r3, #0
    aff6:	9302      	str	r3, [sp, #8]
                mb.time_stamp = 0U;
    aff8:	2300      	movs	r3, #0
    affa:	9315      	str	r3, [sp, #84]	; 0x54
                FlexCAN_LockRxMsgBuff(base, mb_idx);
    affc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b000:	4619      	mov	r1, r3
    b002:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b004:	f001 fa87 	bl	c516 <FlexCAN_LockRxMsgBuff>
                FlexCAN_GetMsgBuff(base, mb_idx, &mb);
    b008:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b00c:	aa02      	add	r2, sp, #8
    b00e:	4619      	mov	r1, r3
    b010:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b012:	f001 fbaf 	bl	c774 <FlexCAN_GetMsgBuff>
                FlexCAN_UnlockRxMsgBuff(base);
    b016:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b018:	f7fe f81d 	bl	9056 <FlexCAN_UnlockRxMsgBuff>
                state->mbs[mb_idx].time_stamp = mb.time_stamp;
    b01c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b020:	9a15      	ldr	r2, [sp, #84]	; 0x54
    b022:	9916      	ldr	r1, [sp, #88]	; 0x58
    b024:	011b      	lsls	r3, r3, #4
    b026:	440b      	add	r3, r1
    b028:	330c      	adds	r3, #12
    b02a:	601a      	str	r2, [r3, #0]
                /* If the frame was a remote frame, clear the flag only if the response was
                * not received yet. If the response was received, leave the flag set in order
                * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
                if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    b02c:	9b02      	ldr	r3, [sp, #8]
    b02e:	0e1b      	lsrs	r3, r3, #24
    b030:	f003 030f 	and.w	r3, r3, #15
    b034:	2b04      	cmp	r3, #4
    b036:	d11d      	bne.n	b074 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                {
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b038:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b03c:	4619      	mov	r1, r3
    b03e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b040:	f7fe f810 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
    b044:	e016      	b.n	b074 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                }
            }
            else
            {
                state->mbs[mb_idx].time_stamp = FlexCAN_GetMsgBuffTimestamp(base, mb_idx);
    b046:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b04a:	f89d 4006 	ldrb.w	r4, [sp, #6]
    b04e:	4619      	mov	r1, r3
    b050:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b052:	f001 fb7b 	bl	c74c <FlexCAN_GetMsgBuffTimestamp>
    b056:	4601      	mov	r1, r0
    b058:	9a16      	ldr	r2, [sp, #88]	; 0x58
    b05a:	0123      	lsls	r3, r4, #4
    b05c:	4413      	add	r3, r2
    b05e:	330c      	adds	r3, #12
    b060:	6019      	str	r1, [r3, #0]
                FlexCAN_UnlockRxMsgBuff(base);
    b062:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b064:	f7fd fff7 	bl	9056 <FlexCAN_UnlockRxMsgBuff>
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b068:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b06c:	4619      	mov	r1, r3
    b06e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b070:	f7fd fff8 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
            }

            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    b074:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b078:	9a16      	ldr	r2, [sp, #88]	; 0x58
    b07a:	011b      	lsls	r3, r3, #4
    b07c:	4413      	add	r3, r2
    b07e:	3304      	adds	r3, #4
    b080:	2200      	movs	r2, #0
    b082:	601a      	str	r2, [r3, #0]

            /* Invoke callback */
            if (state->callback != NULL_PTR)
    b084:	9b16      	ldr	r3, [sp, #88]	; 0x58
    b086:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    b08a:	2b00      	cmp	r3, #0
    b08c:	d009      	beq.n	b0a2 <FlexCAN_Ip_MainFunctionWrite+0x10e>
            {
                state->callback(instance, FLEXCAN_EVENT_TX_COMPLETE, mb_idx, state);
    b08e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    b090:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    b094:	f89d 2006 	ldrb.w	r2, [sp, #6]
    b098:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b09c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    b09e:	2104      	movs	r1, #4
    b0a0:	47a0      	blx	r4
            }
        }
    }
}
    b0a2:	bf00      	nop
    b0a4:	b018      	add	sp, #96	; 0x60
    b0a6:	bd10      	pop	{r4, pc}
    b0a8:	00010534 	.word	0x00010534
    b0ac:	1fff8fb8 	.word	0x1fff8fb8

0000b0b0 <FlexCAN_Ip_GetStopMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STOPPED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStopMode_Activity */
boolean FlexCAN_Ip_GetStopMode_Privileged(uint8 instance)
{
    b0b0:	b084      	sub	sp, #16
    b0b2:	4603      	mov	r3, r0
    b0b4:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b0b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b0bc:	4a08      	ldr	r2, [pc, #32]	; (b0e0 <FlexCAN_Ip_GetStopMode_Privileged+0x30>)
    b0be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b0c2:	9303      	str	r3, [sp, #12]
    return ((FLEXCAN_MCR_LPMACK_MASK == (base->MCR & FLEXCAN_MCR_LPMACK_MASK)) ? TRUE : FALSE);
    b0c4:	9b03      	ldr	r3, [sp, #12]
    b0c6:	681b      	ldr	r3, [r3, #0]
    b0c8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    b0cc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    b0d0:	bf0c      	ite	eq
    b0d2:	2301      	moveq	r3, #1
    b0d4:	2300      	movne	r3, #0
    b0d6:	b2db      	uxtb	r3, r3
}
    b0d8:	4618      	mov	r0, r3
    b0da:	b004      	add	sp, #16
    b0dc:	4770      	bx	lr
    b0de:	bf00      	nop
    b0e0:	00010534 	.word	0x00010534

0000b0e4 <FlexCAN_Ip_GetStartMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STARTED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStartMode_Activity */
boolean FlexCAN_Ip_GetStartMode_Privileged(uint8 instance)
{
    b0e4:	b084      	sub	sp, #16
    b0e6:	4603      	mov	r3, r0
    b0e8:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b0ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b0f0:	4a07      	ldr	r2, [pc, #28]	; (b110 <FlexCAN_Ip_GetStartMode_Privileged+0x2c>)
    b0f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b0f6:	9303      	str	r3, [sp, #12]
    return ((0U == (base->MCR & (FLEXCAN_MCR_LPMACK_MASK | FLEXCAN_MCR_FRZACK_MASK))) ? TRUE : FALSE);
    b0f8:	9b03      	ldr	r3, [sp, #12]
    b0fa:	681b      	ldr	r3, [r3, #0]
    b0fc:	f003 7388 	and.w	r3, r3, #17825792	; 0x1100000
    b100:	2b00      	cmp	r3, #0
    b102:	bf0c      	ite	eq
    b104:	2301      	moveq	r3, #1
    b106:	2300      	movne	r3, #0
    b108:	b2db      	uxtb	r3, r3
}
    b10a:	4618      	mov	r0, r3
    b10c:	b004      	add	sp, #16
    b10e:	4770      	bx	lr
    b110:	00010534 	.word	0x00010534

0000b114 <FlexCAN_Ip_SetStartMode_Privileged>:
 * Description   : Set the FlexCAN instance in START mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStartMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStartMode_Privileged(uint8 instance)
{
    b114:	b500      	push	{lr}
    b116:	b085      	sub	sp, #20
    b118:	4603      	mov	r3, r0
    b11a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b11e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b122:	4a0b      	ldr	r2, [pc, #44]	; (b150 <FlexCAN_Ip_SetStartMode_Privileged+0x3c>)
    b124:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b128:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    b12a:	f002 fb93 	bl	d854 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>
    /* Enable Flexcan Module */
    pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    b12e:	9b03      	ldr	r3, [sp, #12]
    b130:	681b      	ldr	r3, [r3, #0]
    b132:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    b136:	9b03      	ldr	r3, [sp, #12]
    b138:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    b13a:	f002 fbb7 	bl	d8ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>

    return (FlexCAN_ExitFreezeMode(pBase));
    b13e:	9803      	ldr	r0, [sp, #12]
    b140:	f000 ff94 	bl	c06c <FlexCAN_ExitFreezeMode>
    b144:	4603      	mov	r3, r0
}
    b146:	4618      	mov	r0, r3
    b148:	b005      	add	sp, #20
    b14a:	f85d fb04 	ldr.w	pc, [sp], #4
    b14e:	bf00      	nop
    b150:	00010534 	.word	0x00010534

0000b154 <FlexCAN_Ip_SetStopMode_Privileged>:
 * Description   : Set the FlexCAN instance in STOP mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStopMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStopMode_Privileged(uint8 instance)
{
    b154:	b500      	push	{lr}
    b156:	b085      	sub	sp, #20
    b158:	4603      	mov	r3, r0
    b15a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b15e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b162:	4a0a      	ldr	r2, [pc, #40]	; (b18c <FlexCAN_Ip_SetStopMode_Privileged+0x38>)
    b164:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b168:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status;
    status = FlexCAN_EnterFreezeMode(pBase);
    b16a:	9802      	ldr	r0, [sp, #8]
    b16c:	f000 fef6 	bl	bf5c <FlexCAN_EnterFreezeMode>
    b170:	9003      	str	r0, [sp, #12]
    if (FLEXCAN_STATUS_SUCCESS == status)
    b172:	9b03      	ldr	r3, [sp, #12]
    b174:	2b00      	cmp	r3, #0
    b176:	d103      	bne.n	b180 <FlexCAN_Ip_SetStopMode_Privileged+0x2c>

        /* TODO: reset MB status */

        /* TODO: disable all interrupt */

        status = FlexCAN_Disable(pBase);
    b178:	9802      	ldr	r0, [sp, #8]
    b17a:	f000 ffb9 	bl	c0f0 <FlexCAN_Disable>
    b17e:	9003      	str	r0, [sp, #12]
    }
    return status;
    b180:	9b03      	ldr	r3, [sp, #12]
}
    b182:	4618      	mov	r0, r3
    b184:	b005      	add	sp, #20
    b186:	f85d fb04 	ldr.w	pc, [sp], #4
    b18a:	bf00      	nop
    b18c:	00010534 	.word	0x00010534

0000b190 <FlexCAN_Ip_SetRxMaskType_Privileged>:
 * mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxMaskType_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMaskType_Privileged(uint8 instance, Flexcan_Ip_RxMaskType type)
{
    b190:	b500      	push	{lr}
    b192:	b087      	sub	sp, #28
    b194:	4603      	mov	r3, r0
    b196:	9100      	str	r1, [sp, #0]
    b198:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b19c:	2300      	movs	r3, #0
    b19e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b1a0:	2300      	movs	r3, #0
    b1a2:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b1a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b1a8:	4a1e      	ldr	r2, [pc, #120]	; (b224 <FlexCAN_Ip_SetRxMaskType_Privileged+0x94>)
    b1aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b1ae:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b1b0:	9803      	ldr	r0, [sp, #12]
    b1b2:	f7fd fefd 	bl	8fb0 <FlexCAN_IsEnabled>
    b1b6:	4603      	mov	r3, r0
    b1b8:	2b00      	cmp	r3, #0
    b1ba:	bf14      	ite	ne
    b1bc:	2301      	movne	r3, #1
    b1be:	2300      	moveq	r3, #0
    b1c0:	b2db      	uxtb	r3, r3
    b1c2:	f083 0301 	eor.w	r3, r3, #1
    b1c6:	b2db      	uxtb	r3, r3
    b1c8:	f88d 300b 	strb.w	r3, [sp, #11]
    b1cc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b1d0:	f003 0301 	and.w	r3, r3, #1
    b1d4:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b1d8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b1dc:	2b00      	cmp	r3, #0
    b1de:	d003      	beq.n	b1e8 <FlexCAN_Ip_SetRxMaskType_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    b1e0:	9803      	ldr	r0, [sp, #12]
    b1e2:	f000 ff07 	bl	bff4 <FlexCAN_Enable>
    b1e6:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b1e8:	9b05      	ldr	r3, [sp, #20]
    b1ea:	2b00      	cmp	r3, #0
    b1ec:	d107      	bne.n	b1fe <FlexCAN_Ip_SetRxMaskType_Privileged+0x6e>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    b1ee:	f002 fb83 	bl	d8f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
        FlexCAN_SetRxMaskType(pBase, type);
    b1f2:	9900      	ldr	r1, [sp, #0]
    b1f4:	9803      	ldr	r0, [sp, #12]
    b1f6:	f7fe f930 	bl	945a <FlexCAN_SetRxMaskType>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    b1fa:	f002 fba9 	bl	d950 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
    }

    if (TRUE == disabled)
    b1fe:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b202:	2b00      	cmp	r3, #0
    b204:	d008      	beq.n	b218 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
    {
        status = FlexCAN_Disable(pBase);
    b206:	9803      	ldr	r0, [sp, #12]
    b208:	f000 ff72 	bl	c0f0 <FlexCAN_Disable>
    b20c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b20e:	9b04      	ldr	r3, [sp, #16]
    b210:	2b00      	cmp	r3, #0
    b212:	d001      	beq.n	b218 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
        {
            result = status;
    b214:	9b04      	ldr	r3, [sp, #16]
    b216:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b218:	9b05      	ldr	r3, [sp, #20]
}
    b21a:	4618      	mov	r0, r3
    b21c:	b007      	add	sp, #28
    b21e:	f85d fb04 	ldr.w	pc, [sp], #4
    b222:	bf00      	nop
    b224:	00010534 	.word	0x00010534

0000b228 <FlexCAN_Ip_SetBitrate_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrate_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrate_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
    b228:	b500      	push	{lr}
    b22a:	b087      	sub	sp, #28
    b22c:	4603      	mov	r3, r0
    b22e:	9100      	str	r1, [sp, #0]
    b230:	f88d 3007 	strb.w	r3, [sp, #7]
    b234:	4613      	mov	r3, r2
    b236:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b23a:	2300      	movs	r3, #0
    b23c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b23e:	2300      	movs	r3, #0
    b240:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b242:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b246:	4a1c      	ldr	r2, [pc, #112]	; (b2b8 <FlexCAN_Ip_SetBitrate_Privileged+0x90>)
    b248:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b24c:	9303      	str	r3, [sp, #12]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    b24e:	9b03      	ldr	r3, [sp, #12]
    b250:	681b      	ldr	r3, [r3, #0]
    b252:	0fdb      	lsrs	r3, r3, #31
    b254:	f88d 300b 	strb.w	r3, [sp, #11]
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_OFF)
    (void)enhExt;
#endif
    if (TRUE == disabled)
    b258:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b25c:	2b00      	cmp	r3, #0
    b25e:	d003      	beq.n	b268 <FlexCAN_Ip_SetBitrate_Privileged+0x40>
    {
        result = FlexCAN_Enable(pBase);
    b260:	9803      	ldr	r0, [sp, #12]
    b262:	f000 fec7 	bl	bff4 <FlexCAN_Enable>
    b266:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b268:	9b05      	ldr	r3, [sp, #20]
    b26a:	2b00      	cmp	r3, #0
    b26c:	d112      	bne.n	b294 <FlexCAN_Ip_SetBitrate_Privileged+0x6c>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    b26e:	f002 fd2f 	bl	dcd0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
            FlexCAN_SetEnhancedNominalTimeSegments(pBase, bitrate);
        }
        else
#endif
        {
            if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    b272:	9803      	ldr	r0, [sp, #12]
    b274:	f7fe f830 	bl	92d8 <FlexCAN_IsExCbtEnabled>
    b278:	4603      	mov	r3, r0
    b27a:	2b00      	cmp	r3, #0
    b27c:	d004      	beq.n	b288 <FlexCAN_Ip_SetBitrate_Privileged+0x60>
            {
                FlexCAN_SetExtendedTimeSegments(pBase, bitrate);
    b27e:	9900      	ldr	r1, [sp, #0]
    b280:	9803      	ldr	r0, [sp, #12]
    b282:	f7fd ff7f 	bl	9184 <FlexCAN_SetExtendedTimeSegments>
    b286:	e003      	b.n	b290 <FlexCAN_Ip_SetBitrate_Privileged+0x68>
            }
            else
            {
                FlexCAN_SetTimeSegments(pBase, bitrate);
    b288:	9900      	ldr	r1, [sp, #0]
    b28a:	9803      	ldr	r0, [sp, #12]
    b28c:	f7fd ff4e 	bl	912c <FlexCAN_SetTimeSegments>
            }
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    b290:	f002 fd4a 	bl	dd28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
    }

    if (TRUE == disabled)
    b294:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b298:	2b00      	cmp	r3, #0
    b29a:	d008      	beq.n	b2ae <FlexCAN_Ip_SetBitrate_Privileged+0x86>
    {
        status = FlexCAN_Disable(pBase);
    b29c:	9803      	ldr	r0, [sp, #12]
    b29e:	f000 ff27 	bl	c0f0 <FlexCAN_Disable>
    b2a2:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b2a4:	9b04      	ldr	r3, [sp, #16]
    b2a6:	2b00      	cmp	r3, #0
    b2a8:	d001      	beq.n	b2ae <FlexCAN_Ip_SetBitrate_Privileged+0x86>
        {
            result = status;
    b2aa:	9b04      	ldr	r3, [sp, #16]
    b2ac:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b2ae:	9b05      	ldr	r3, [sp, #20]
}
    b2b0:	4618      	mov	r0, r3
    b2b2:	b007      	add	sp, #28
    b2b4:	f85d fb04 	ldr.w	pc, [sp], #4
    b2b8:	00010534 	.word	0x00010534

0000b2bc <FlexCAN_Ip_GetBitrate>:
 * or the arbitration phase of FD frames.
 *
 *END**************************************************************************/
 /* implements   FlexCAN_Ip_GetBitrate_Activity */
boolean FlexCAN_Ip_GetBitrate(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    b2bc:	b500      	push	{lr}
    b2be:	b085      	sub	sp, #20
    b2c0:	4603      	mov	r3, r0
    b2c2:	9100      	str	r1, [sp, #0]
    b2c4:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b2c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b2cc:	4a0d      	ldr	r2, [pc, #52]	; (b304 <FlexCAN_Ip_GetBitrate+0x48>)
    b2ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b2d2:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    b2d4:	2300      	movs	r3, #0
    b2d6:	f88d 300b 	strb.w	r3, [sp, #11]
        FlexCAN_GetEnhancedNominalTimeSegments(pBase, bitrate);
    }
    else
#endif
    {
        if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    b2da:	9803      	ldr	r0, [sp, #12]
    b2dc:	f7fd fffc 	bl	92d8 <FlexCAN_IsExCbtEnabled>
    b2e0:	4603      	mov	r3, r0
    b2e2:	2b00      	cmp	r3, #0
    b2e4:	d004      	beq.n	b2f0 <FlexCAN_Ip_GetBitrate+0x34>
        {
            /* Get the Extended time segments*/
            FlexCAN_GetExtendedTimeSegments(pBase, bitrate);
    b2e6:	9900      	ldr	r1, [sp, #0]
    b2e8:	9803      	ldr	r0, [sp, #12]
    b2ea:	f7fd ff79 	bl	91e0 <FlexCAN_GetExtendedTimeSegments>
    b2ee:	e003      	b.n	b2f8 <FlexCAN_Ip_GetBitrate+0x3c>
        }
        else
        {
            /* Get the time segments*/
            FlexCAN_GetTimeSegments(pBase, bitrate);
    b2f0:	9900      	ldr	r1, [sp, #0]
    b2f2:	9803      	ldr	r0, [sp, #12]
    b2f4:	f7fd ff9c 	bl	9230 <FlexCAN_GetTimeSegments>
        }
    }
    return enhCbt;
    b2f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    b2fc:	4618      	mov	r0, r3
    b2fe:	b005      	add	sp, #20
    b300:	f85d fb04 	ldr.w	pc, [sp], #4
    b304:	00010534 	.word	0x00010534

0000b308 <FlexCAN_Ip_ClearTDCFail>:
 * Description   : This function clear the TDC Fail flag.
 *
 *END**************************************************************************/
/* implements   FlexCAN_Ip_ClearTDCFail_Activity */
void FlexCAN_Ip_ClearTDCFail(uint8 u8Instance)
{
    b308:	b500      	push	{lr}
    b30a:	b085      	sub	sp, #20
    b30c:	4603      	mov	r3, r0
    b30e:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b312:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b316:	4a0a      	ldr	r2, [pc, #40]	; (b340 <FlexCAN_Ip_ClearTDCFail+0x38>)
    b318:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b31c:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    b31e:	f002 fb3d 	bl	d99c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
        pBase->ETDC |=  FLEXCAN_ETDC_ETDCFAIL_MASK;
    }
    else
#endif
    {
        pBase->FDCTRL |= FLEXCAN_FDCTRL_TDCFAIL_MASK;
    b322:	9b03      	ldr	r3, [sp, #12]
    b324:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    b328:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    b32c:	9b03      	ldr	r3, [sp, #12]
    b32e:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    b332:	f002 fb5f 	bl	d9f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
}
    b336:	bf00      	nop
    b338:	b005      	add	sp, #20
    b33a:	f85d fb04 	ldr.w	pc, [sp], #4
    b33e:	bf00      	nop
    b340:	00010534 	.word	0x00010534

0000b344 <FlexCAN_Ip_GetTDCFail>:
 *
 *END**************************************************************************/

/* implements    FlexCAN_Ip_GetTDCFail_Activity */
boolean FlexCAN_Ip_GetTDCFail(uint8 u8Instance)
{
    b344:	b084      	sub	sp, #16
    b346:	4603      	mov	r3, r0
    b348:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean value=FALSE;
    b34c:	2300      	movs	r3, #0
    b34e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b352:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b356:	4a0a      	ldr	r2, [pc, #40]	; (b380 <FlexCAN_Ip_GetTDCFail+0x3c>)
    b358:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b35c:	9302      	str	r3, [sp, #8]
        value = ((pBase->ETDC & FLEXCAN_ETDC_ETDCFAIL_MASK) == FLEXCAN_ETDC_ETDCFAIL_MASK) ? TRUE : FALSE;
    }
    else
#endif
    {
        value = ((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCFAIL_MASK) == FLEXCAN_FDCTRL_TDCFAIL_MASK) ? TRUE : FALSE;
    b35e:	9b02      	ldr	r3, [sp, #8]
    b360:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    b364:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    b368:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    b36c:	bf0c      	ite	eq
    b36e:	2301      	moveq	r3, #1
    b370:	2300      	movne	r3, #0
    b372:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    b376:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    b37a:	4618      	mov	r0, r3
    b37c:	b004      	add	sp, #16
    b37e:	4770      	bx	lr
    b380:	00010534 	.word	0x00010534

0000b384 <FlexCAN_Ip_GetTDCValue>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_GetTDCValue_Activity */
uint8 FlexCAN_Ip_GetTDCValue(uint8 u8Instance)
{
    b384:	b084      	sub	sp, #16
    b386:	4603      	mov	r3, r0
    b388:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 value = 0;
    b38c:	2300      	movs	r3, #0
    b38e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b392:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b396:	4a08      	ldr	r2, [pc, #32]	; (b3b8 <FlexCAN_Ip_GetTDCValue+0x34>)
    b398:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b39c:	9302      	str	r3, [sp, #8]
        value = (uint8)((pBase->ETDC& FLEXCAN_ETDC_ETDCVAL_MASK) >> FLEXCAN_ETDC_ETDCVAL_SHIFT);
    }
    else
#endif
    {
        value = (uint8)((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCVAL_MASK) >> FLEXCAN_FDCTRL_TDCVAL_SHIFT);
    b39e:	9b02      	ldr	r3, [sp, #8]
    b3a0:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    b3a4:	b2db      	uxtb	r3, r3
    b3a6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    b3aa:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    b3ae:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    b3b2:	4618      	mov	r0, r3
    b3b4:	b004      	add	sp, #16
    b3b6:	4770      	bx	lr
    b3b8:	00010534 	.word	0x00010534

0000b3bc <FlexCAN_Ip_SetBitrateCbt_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrateCbt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrateCbt_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
    b3bc:	b500      	push	{lr}
    b3be:	b087      	sub	sp, #28
    b3c0:	4603      	mov	r3, r0
    b3c2:	9100      	str	r1, [sp, #0]
    b3c4:	f88d 3007 	strb.w	r3, [sp, #7]
    b3c8:	4613      	mov	r3, r2
    b3ca:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b3ce:	2300      	movs	r3, #0
    b3d0:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b3d2:	2300      	movs	r3, #0
    b3d4:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b3d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b3da:	4a1e      	ldr	r2, [pc, #120]	; (b454 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x98>)
    b3dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3e0:	9303      	str	r3, [sp, #12]
    boolean fd_enable = FlexCAN_IsFDEnabled(pBase);
    b3e2:	9803      	ldr	r0, [sp, #12]
    b3e4:	f7fd ffaf 	bl	9346 <FlexCAN_IsFDEnabled>
    b3e8:	4603      	mov	r3, r0
    b3ea:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    b3ee:	9b03      	ldr	r3, [sp, #12]
    b3f0:	681b      	ldr	r3, [r3, #0]
    b3f2:	0fdb      	lsrs	r3, r3, #31
    b3f4:	f88d 300a 	strb.w	r3, [sp, #10]

    if (TRUE == disabled)
    b3f8:	f89d 300a 	ldrb.w	r3, [sp, #10]
    b3fc:	2b00      	cmp	r3, #0
    b3fe:	d003      	beq.n	b408 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x4c>
    {
        result = FlexCAN_Enable(pBase);
    b400:	9803      	ldr	r0, [sp, #12]
    b402:	f000 fdf7 	bl	bff4 <FlexCAN_Enable>
    b406:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b408:	9b05      	ldr	r3, [sp, #20]
    b40a:	2b00      	cmp	r3, #0
    b40c:	d10f      	bne.n	b42e <FlexCAN_Ip_SetBitrateCbt_Privileged+0x72>
    {
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_ON)
        boolean enhCbt = FlexCAN_IsEnhCbtEnabled(pBase);
#endif
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    b40e:	f002 fcb1 	bl	dd74 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
        FlexCAN_SetFDEnabled(pBase, fd_enable, bitRateSwitch);
    b412:	f89d 2006 	ldrb.w	r2, [sp, #6]
    b416:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b41a:	4619      	mov	r1, r3
    b41c:	9803      	ldr	r0, [sp, #12]
    b41e:	f7fd fdd1 	bl	8fc4 <FlexCAN_SetFDEnabled>
        }
        else
#endif
        {
            /* Set time segments*/
            FlexCAN_SetFDTimeSegments(pBase, bitrate);
    b422:	9900      	ldr	r1, [sp, #0]
    b424:	9803      	ldr	r0, [sp, #12]
    b426:	f7fd fe4c 	bl	90c2 <FlexCAN_SetFDTimeSegments>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    b42a:	f002 fccf 	bl	ddcc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
    }

    if (TRUE == disabled)
    b42e:	f89d 300a 	ldrb.w	r3, [sp, #10]
    b432:	2b00      	cmp	r3, #0
    b434:	d008      	beq.n	b448 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    b436:	9803      	ldr	r0, [sp, #12]
    b438:	f000 fe5a 	bl	c0f0 <FlexCAN_Disable>
    b43c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b43e:	9b04      	ldr	r3, [sp, #16]
    b440:	2b00      	cmp	r3, #0
    b442:	d001      	beq.n	b448 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
        {
            result = status;
    b444:	9b04      	ldr	r3, [sp, #16]
    b446:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b448:	9b05      	ldr	r3, [sp, #20]
}
    b44a:	4618      	mov	r0, r3
    b44c:	b007      	add	sp, #28
    b44e:	f85d fb04 	ldr.w	pc, [sp], #4
    b452:	bf00      	nop
    b454:	00010534 	.word	0x00010534

0000b458 <FlexCAN_Ip_GetBitrateFD>:
 * of FD frames.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBitrateFD_Activity */
boolean FlexCAN_Ip_GetBitrateFD(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    b458:	b500      	push	{lr}
    b45a:	b085      	sub	sp, #20
    b45c:	4603      	mov	r3, r0
    b45e:	9100      	str	r1, [sp, #0]
    b460:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b464:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b468:	4a08      	ldr	r2, [pc, #32]	; (b48c <FlexCAN_Ip_GetBitrateFD+0x34>)
    b46a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b46e:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    b470:	2300      	movs	r3, #0
    b472:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    else
#endif
    {
        /* Get the time segments*/
        FlexCAN_GetFDTimeSegments(pBase, bitrate);
    b476:	9900      	ldr	r1, [sp, #0]
    b478:	9803      	ldr	r0, [sp, #12]
    b47a:	f7fd ff00 	bl	927e <FlexCAN_GetFDTimeSegments>
    }
    return enhCbt;
    b47e:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    b482:	4618      	mov	r0, r3
    b484:	b005      	add	sp, #20
    b486:	f85d fb04 	ldr.w	pc, [sp], #4
    b48a:	bf00      	nop
    b48c:	00010534 	.word	0x00010534

0000b490 <FlexCAN_Ip_SetTDCOffset_Privileged>:
 * the Transceiver Delay Compensation Offset.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTDCOffset_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTDCOffset_Privileged(uint8 instance, boolean enable, uint8 offset)
{
    b490:	b500      	push	{lr}
    b492:	b087      	sub	sp, #28
    b494:	4603      	mov	r3, r0
    b496:	f88d 3007 	strb.w	r3, [sp, #7]
    b49a:	460b      	mov	r3, r1
    b49c:	f88d 3006 	strb.w	r3, [sp, #6]
    b4a0:	4613      	mov	r3, r2
    b4a2:	f88d 3005 	strb.w	r3, [sp, #5]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b4a6:	2300      	movs	r3, #0
    b4a8:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b4aa:	2300      	movs	r3, #0
    b4ac:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b4ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b4b2:	4a20      	ldr	r2, [pc, #128]	; (b534 <FlexCAN_Ip_SetTDCOffset_Privileged+0xa4>)
    b4b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4b8:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b4ba:	9803      	ldr	r0, [sp, #12]
    b4bc:	f7fd fd78 	bl	8fb0 <FlexCAN_IsEnabled>
    b4c0:	4603      	mov	r3, r0
    b4c2:	2b00      	cmp	r3, #0
    b4c4:	bf14      	ite	ne
    b4c6:	2301      	movne	r3, #1
    b4c8:	2300      	moveq	r3, #0
    b4ca:	b2db      	uxtb	r3, r3
    b4cc:	f083 0301 	eor.w	r3, r3, #1
    b4d0:	b2db      	uxtb	r3, r3
    b4d2:	f88d 300b 	strb.w	r3, [sp, #11]
    b4d6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b4da:	f003 0301 	and.w	r3, r3, #1
    b4de:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b4e2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b4e6:	2b00      	cmp	r3, #0
    b4e8:	d003      	beq.n	b4f2 <FlexCAN_Ip_SetTDCOffset_Privileged+0x62>
    {
        result = FlexCAN_Enable(pBase);
    b4ea:	9803      	ldr	r0, [sp, #12]
    b4ec:	f000 fd82 	bl	bff4 <FlexCAN_Enable>
    b4f0:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b4f2:	9b05      	ldr	r3, [sp, #20]
    b4f4:	2b00      	cmp	r3, #0
    b4f6:	d10b      	bne.n	b510 <FlexCAN_Ip_SetTDCOffset_Privileged+0x80>
    {
        /* Check if enhaced CBT is Enabled */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    b4f8:	f002 fc8e 	bl	de18 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        }
        else
#endif
        {
            /* Enable/Disable TDC and set the TDC Offset */
            FlexCAN_SetTDCOffset(pBase, enable, offset);
    b4fc:	f89d 2005 	ldrb.w	r2, [sp, #5]
    b500:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b504:	4619      	mov	r1, r3
    b506:	9803      	ldr	r0, [sp, #12]
    b508:	f7fd fd2b 	bl	8f62 <FlexCAN_SetTDCOffset>
        }
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    b50c:	f002 fcb0 	bl	de70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        /* Check if enhaced CBT is Enabled */
    }

    if (TRUE == disabled)
    b510:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b514:	2b00      	cmp	r3, #0
    b516:	d008      	beq.n	b52a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
    {
        status = FlexCAN_Disable(pBase);
    b518:	9803      	ldr	r0, [sp, #12]
    b51a:	f000 fde9 	bl	c0f0 <FlexCAN_Disable>
    b51e:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b520:	9b04      	ldr	r3, [sp, #16]
    b522:	2b00      	cmp	r3, #0
    b524:	d001      	beq.n	b52a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
        {
            result = status;
    b526:	9b04      	ldr	r3, [sp, #16]
    b528:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    b52a:	9b05      	ldr	r3, [sp, #20]
}
    b52c:	4618      	mov	r0, r3
    b52e:	b007      	add	sp, #28
    b530:	f85d fb04 	ldr.w	pc, [sp], #4
    b534:	00010534 	.word	0x00010534

0000b538 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>:
 * be delayed from the first bit of CRC field on CAN bus.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTxArbitrationStartDelay_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged(uint8 instance,  uint8 value)
{
    b538:	b500      	push	{lr}
    b53a:	b087      	sub	sp, #28
    b53c:	4603      	mov	r3, r0
    b53e:	460a      	mov	r2, r1
    b540:	f88d 3007 	strb.w	r3, [sp, #7]
    b544:	4613      	mov	r3, r2
    b546:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b54a:	2300      	movs	r3, #0
    b54c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b54e:	2300      	movs	r3, #0
    b550:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b552:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b556:	4a1f      	ldr	r2, [pc, #124]	; (b5d4 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x9c>)
    b558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b55c:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b55e:	9803      	ldr	r0, [sp, #12]
    b560:	f7fd fd26 	bl	8fb0 <FlexCAN_IsEnabled>
    b564:	4603      	mov	r3, r0
    b566:	2b00      	cmp	r3, #0
    b568:	bf14      	ite	ne
    b56a:	2301      	movne	r3, #1
    b56c:	2300      	moveq	r3, #0
    b56e:	b2db      	uxtb	r3, r3
    b570:	f083 0301 	eor.w	r3, r3, #1
    b574:	b2db      	uxtb	r3, r3
    b576:	f88d 300b 	strb.w	r3, [sp, #11]
    b57a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b57e:	f003 0301 	and.w	r3, r3, #1
    b582:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b586:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b58a:	2b00      	cmp	r3, #0
    b58c:	d003      	beq.n	b596 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    b58e:	9803      	ldr	r0, [sp, #12]
    b590:	f000 fd30 	bl	bff4 <FlexCAN_Enable>
    b594:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b596:	9b05      	ldr	r3, [sp, #20]
    b598:	2b00      	cmp	r3, #0
    b59a:	d109      	bne.n	b5b0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    b59c:	f002 fc8e 	bl	debc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
        FlexCAN_SetTxArbitrationStartDelay(pBase, value);
    b5a0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b5a4:	4619      	mov	r1, r3
    b5a6:	9803      	ldr	r0, [sp, #12]
    b5a8:	f7fd ff43 	bl	9432 <FlexCAN_SetTxArbitrationStartDelay>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    b5ac:	f002 fcb2 	bl	df14 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
    }

    if (TRUE == disabled)
    b5b0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b5b4:	2b00      	cmp	r3, #0
    b5b6:	d008      	beq.n	b5ca <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    b5b8:	9803      	ldr	r0, [sp, #12]
    b5ba:	f000 fd99 	bl	c0f0 <FlexCAN_Disable>
    b5be:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b5c0:	9b04      	ldr	r3, [sp, #16]
    b5c2:	2b00      	cmp	r3, #0
    b5c4:	d001      	beq.n	b5ca <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
        {
            result = status;
    b5c6:	9b04      	ldr	r3, [sp, #16]
    b5c8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b5ca:	9b05      	ldr	r3, [sp, #20]
}
    b5cc:	4618      	mov	r0, r3
    b5ce:	b007      	add	sp, #28
    b5d0:	f85d fb04 	ldr.w	pc, [sp], #4
    b5d4:	00010534 	.word	0x00010534

0000b5d8 <FlexCAN_Ip_GetBuffStatusFlag>:
 * In case of a complete operation this flag is set.
 * In case msgBuff is 255 will return Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBuffStatusFlag_Activity */
boolean FlexCAN_Ip_GetBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    b5d8:	b500      	push	{lr}
    b5da:	b085      	sub	sp, #20
    b5dc:	4603      	mov	r3, r0
    b5de:	460a      	mov	r2, r1
    b5e0:	f88d 3007 	strb.w	r3, [sp, #7]
    b5e4:	4613      	mov	r3, r2
    b5e6:	f88d 3006 	strb.w	r3, [sp, #6]
    boolean returnResult;
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b5ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b5ee:	4a0b      	ldr	r2, [pc, #44]	; (b61c <FlexCAN_Ip_GetBuffStatusFlag+0x44>)
    b5f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b5f4:	9303      	str	r3, [sp, #12]
        returnResult = ((1U == FlexCAN_GetEnhancedRxFIFOStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW)) ? TRUE : FALSE);
    }
    else
#endif
    {
        returnResult = ((1U == FlexCAN_GetBuffStatusFlag(pBase, msgBuffIdx)) ? TRUE : FALSE);
    b5f6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b5fa:	4619      	mov	r1, r3
    b5fc:	9803      	ldr	r0, [sp, #12]
    b5fe:	f7fd fd44 	bl	908a <FlexCAN_GetBuffStatusFlag>
    b602:	4603      	mov	r3, r0
    b604:	2b01      	cmp	r3, #1
    b606:	bf0c      	ite	eq
    b608:	2301      	moveq	r3, #1
    b60a:	2300      	movne	r3, #0
    b60c:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    return returnResult;
    b610:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    b614:	4618      	mov	r0, r3
    b616:	b005      	add	sp, #20
    b618:	f85d fb04 	ldr.w	pc, [sp], #4
    b61c:	00010534 	.word	0x00010534

0000b620 <FlexCAN_Ip_ClearBuffStatusFlag>:
 * Description   : Clear FlexCAN Message Buffer Status Flag.
 * In case msgBuff is 255 will clear Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearBuffStatusFlag_Activity */
void FlexCAN_Ip_ClearBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    b620:	b500      	push	{lr}
    b622:	b085      	sub	sp, #20
    b624:	4603      	mov	r3, r0
    b626:	460a      	mov	r2, r1
    b628:	f88d 3007 	strb.w	r3, [sp, #7]
    b62c:	4613      	mov	r3, r2
    b62e:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b632:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b636:	4a07      	ldr	r2, [pc, #28]	; (b654 <FlexCAN_Ip_ClearBuffStatusFlag+0x34>)
    b638:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b63c:	9303      	str	r3, [sp, #12]
        FlexCAN_ClearEnhancedRxFifoIntStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
    }
    else
#endif
    {
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, msgBuffIdx);
    b63e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b642:	4619      	mov	r1, r3
    b644:	9803      	ldr	r0, [sp, #12]
    b646:	f7fd fd0d 	bl	9064 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }
}
    b64a:	bf00      	nop
    b64c:	b005      	add	sp, #20
    b64e:	f85d fb04 	ldr.w	pc, [sp], #4
    b652:	bf00      	nop
    b654:	00010534 	.word	0x00010534

0000b658 <FlexCAN_Ip_EnableInterrupts_Privileged>:
 * Description   : Enable all mb interrupts configured.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnableInterrupts_Privileged(uint8 u8Instance)
{
    b658:	b500      	push	{lr}
    b65a:	b087      	sub	sp, #28
    b65c:	4603      	mov	r3, r0
    b65e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b662:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b666:	4a11      	ldr	r2, [pc, #68]	; (b6ac <FlexCAN_Ip_EnableInterrupts_Privileged+0x54>)
    b668:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b66c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    b66e:	2301      	movs	r3, #1
    b670:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    b672:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b676:	4a0e      	ldr	r2, [pc, #56]	; (b6b0 <FlexCAN_Ip_EnableInterrupts_Privileged+0x58>)
    b678:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b67c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    b67e:	9804      	ldr	r0, [sp, #16]
    b680:	f7fd fc96 	bl	8fb0 <FlexCAN_IsEnabled>
    b684:	4603      	mov	r3, r0
    b686:	2b00      	cmp	r3, #0
    b688:	d00b      	beq.n	b6a2 <FlexCAN_Ip_EnableInterrupts_Privileged+0x4a>
    {
        FlexCAN_EnableInterrupts(pBase, u8Instance);
    b68a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b68e:	4619      	mov	r1, r3
    b690:	9804      	ldr	r0, [sp, #16]
    b692:	f000 ffe1 	bl	c658 <FlexCAN_EnableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, TRUE);
            }
        }
    #endif
        state->isIntActive = TRUE;
    b696:	9b03      	ldr	r3, [sp, #12]
    b698:	2201      	movs	r2, #1
    b69a:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    b69e:	2300      	movs	r3, #0
    b6a0:	9305      	str	r3, [sp, #20]
    }

    return result;
    b6a2:	9b05      	ldr	r3, [sp, #20]
}
    b6a4:	4618      	mov	r0, r3
    b6a6:	b007      	add	sp, #28
    b6a8:	f85d fb04 	ldr.w	pc, [sp], #4
    b6ac:	00010534 	.word	0x00010534
    b6b0:	1fff8fb8 	.word	0x1fff8fb8

0000b6b4 <FlexCAN_Ip_DisableInterrupts_Privileged>:
 * Description   : Enable all interrupts configured.
 *
 *END**************************************************************************/
 /* implements FlexCAN_Ip_DisableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_DisableInterrupts_Privileged(uint8 u8Instance)
{
    b6b4:	b500      	push	{lr}
    b6b6:	b087      	sub	sp, #28
    b6b8:	4603      	mov	r3, r0
    b6ba:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b6be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b6c2:	4a10      	ldr	r2, [pc, #64]	; (b704 <FlexCAN_Ip_DisableInterrupts_Privileged+0x50>)
    b6c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b6c8:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    b6ca:	2301      	movs	r3, #1
    b6cc:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    b6ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b6d2:	4a0d      	ldr	r2, [pc, #52]	; (b708 <FlexCAN_Ip_DisableInterrupts_Privileged+0x54>)
    b6d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b6d8:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    b6da:	9804      	ldr	r0, [sp, #16]
    b6dc:	f7fd fc68 	bl	8fb0 <FlexCAN_IsEnabled>
    b6e0:	4603      	mov	r3, r0
    b6e2:	2b00      	cmp	r3, #0
    b6e4:	d008      	beq.n	b6f8 <FlexCAN_Ip_DisableInterrupts_Privileged+0x44>
    {
        FlexCAN_DisableInterrupts(pBase);
    b6e6:	9804      	ldr	r0, [sp, #16]
    b6e8:	f000 ffae 	bl	c648 <FlexCAN_DisableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, FALSE);
            }
        }
#endif
        state->isIntActive = FALSE;
    b6ec:	9b03      	ldr	r3, [sp, #12]
    b6ee:	2200      	movs	r2, #0
    b6f0:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    b6f4:	2300      	movs	r3, #0
    b6f6:	9305      	str	r3, [sp, #20]
    }

    return result;
    b6f8:	9b05      	ldr	r3, [sp, #20]
}
    b6fa:	4618      	mov	r0, r3
    b6fc:	b007      	add	sp, #28
    b6fe:	f85d fb04 	ldr.w	pc, [sp], #4
    b702:	bf00      	nop
    b704:	00010534 	.word	0x00010534
    b708:	1fff8fb8 	.word	0x1fff8fb8

0000b70c <FlexCAN_Ip_SetErrorInt_Privileged>:
 * Description   : Enable\Disable Error or BusOff Interrupt
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetErrorInt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetErrorInt_Privileged(uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
    b70c:	b500      	push	{lr}
    b70e:	b087      	sub	sp, #28
    b710:	4603      	mov	r3, r0
    b712:	9100      	str	r1, [sp, #0]
    b714:	f88d 3007 	strb.w	r3, [sp, #7]
    b718:	4613      	mov	r3, r2
    b71a:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b71e:	2300      	movs	r3, #0
    b720:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b722:	2300      	movs	r3, #0
    b724:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b726:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b72a:	4a3a      	ldr	r2, [pc, #232]	; (b814 <FlexCAN_Ip_SetErrorInt_Privileged+0x108>)
    b72c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b730:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b732:	9803      	ldr	r0, [sp, #12]
    b734:	f7fd fc3c 	bl	8fb0 <FlexCAN_IsEnabled>
    b738:	4603      	mov	r3, r0
    b73a:	2b00      	cmp	r3, #0
    b73c:	bf14      	ite	ne
    b73e:	2301      	movne	r3, #1
    b740:	2300      	moveq	r3, #0
    b742:	b2db      	uxtb	r3, r3
    b744:	f083 0301 	eor.w	r3, r3, #1
    b748:	b2db      	uxtb	r3, r3
    b74a:	f88d 300b 	strb.w	r3, [sp, #11]
    b74e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b752:	f003 0301 	and.w	r3, r3, #1
    b756:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b75a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b75e:	2b00      	cmp	r3, #0
    b760:	d003      	beq.n	b76a <FlexCAN_Ip_SetErrorInt_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    b762:	9803      	ldr	r0, [sp, #12]
    b764:	f000 fc46 	bl	bff4 <FlexCAN_Enable>
    b768:	9005      	str	r0, [sp, #20]
    }

    if (FLEXCAN_STATUS_SUCCESS == result)
    b76a:	9b05      	ldr	r3, [sp, #20]
    b76c:	2b00      	cmp	r3, #0
    b76e:	d13c      	bne.n	b7ea <FlexCAN_Ip_SetErrorInt_Privileged+0xde>
    b770:	9b00      	ldr	r3, [sp, #0]
    b772:	2b04      	cmp	r3, #4
    b774:	d83b      	bhi.n	b7ee <FlexCAN_Ip_SetErrorInt_Privileged+0xe2>
    b776:	a201      	add	r2, pc, #4	; (adr r2, b77c <FlexCAN_Ip_SetErrorInt_Privileged+0x70>)
    b778:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b77c:	0000b7c7 	.word	0x0000b7c7
    b780:	0000b7d9 	.word	0x0000b7d9
    b784:	0000b7a3 	.word	0x0000b7a3
    b788:	0000b7b5 	.word	0x0000b7b5
    b78c:	0000b791 	.word	0x0000b791
    {
        switch (type)
        {
            case FLEXCAN_IP_INT_BUSOFF:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_BUSOFF, enable);
    b790:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b794:	461a      	mov	r2, r3
    b796:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    b79a:	9803      	ldr	r0, [sp, #12]
    b79c:	f000 fce8 	bl	c170 <FlexCAN_SetErrIntCmd>
                break;
    b7a0:	e026      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR, enable);
    b7a2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b7a6:	461a      	mov	r2, r3
    b7a8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    b7ac:	9803      	ldr	r0, [sp, #12]
    b7ae:	f000 fcdf 	bl	c170 <FlexCAN_SetErrIntCmd>
                break;
    b7b2:	e01d      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR_FAST :
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR_FAST, enable);
    b7b4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b7b8:	461a      	mov	r2, r3
    b7ba:	f244 0101 	movw	r1, #16385	; 0x4001
    b7be:	9803      	ldr	r0, [sp, #12]
    b7c0:	f000 fcd6 	bl	c170 <FlexCAN_SetErrIntCmd>
                break;
    b7c4:	e014      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_RX_WARNING, enable);
    b7c6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b7ca:	461a      	mov	r2, r3
    b7cc:	f44f 6180 	mov.w	r1, #1024	; 0x400
    b7d0:	9803      	ldr	r0, [sp, #12]
    b7d2:	f000 fccd 	bl	c170 <FlexCAN_SetErrIntCmd>
                }
                break;
    b7d6:	e00b      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_TX_WARNING, enable);
    b7d8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b7dc:	461a      	mov	r2, r3
    b7de:	f44f 6100 	mov.w	r1, #2048	; 0x800
    b7e2:	9803      	ldr	r0, [sp, #12]
    b7e4:	f000 fcc4 	bl	c170 <FlexCAN_SetErrIntCmd>
                }
                break;
    b7e8:	e002      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    /* Should not get here */
                #endif
                break;
            }
        }
    }
    b7ea:	bf00      	nop
    b7ec:	e000      	b.n	b7f0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                break;
    b7ee:	bf00      	nop

    if (TRUE == disabled)
    b7f0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b7f4:	2b00      	cmp	r3, #0
    b7f6:	d008      	beq.n	b80a <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
    {
        status = FlexCAN_Disable(pBase);
    b7f8:	9803      	ldr	r0, [sp, #12]
    b7fa:	f000 fc79 	bl	c0f0 <FlexCAN_Disable>
    b7fe:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b800:	9b04      	ldr	r3, [sp, #16]
    b802:	2b00      	cmp	r3, #0
    b804:	d001      	beq.n	b80a <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
        {
            result = status;
    b806:	9b04      	ldr	r3, [sp, #16]
    b808:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b80a:	9b05      	ldr	r3, [sp, #20]
}
    b80c:	4618      	mov	r0, r3
    b80e:	b007      	add	sp, #28
    b810:	f85d fb04 	ldr.w	pc, [sp], #4
    b814:	00010534 	.word	0x00010534

0000b818 <FlexCAN_Ip_AbortTransfer>:
 * receiver.
 *
 *END**************************************************************************/
/* implements    FlexCAN_Ip_AbortTransfer_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_AbortTransfer(uint8 u8Instance, uint8 mb_idx)
{
    b818:	b500      	push	{lr}
    b81a:	b087      	sub	sp, #28
    b81c:	4603      	mov	r3, r0
    b81e:	460a      	mov	r2, r1
    b820:	f88d 3007 	strb.w	r3, [sp, #7]
    b824:	4613      	mov	r3, r2
    b826:	f88d 3006 	strb.w	r3, [sp, #6]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
        DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
    #endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    b82a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b82e:	4a27      	ldr	r2, [pc, #156]	; (b8cc <FlexCAN_Ip_AbortTransfer+0xb4>)
    b830:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b834:	9304      	str	r3, [sp, #16]
#if ((FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON))
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
#else
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    b836:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b83a:	4a25      	ldr	r2, [pc, #148]	; (b8d0 <FlexCAN_Ip_AbortTransfer+0xb8>)
    b83c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b840:	9303      	str	r3, [sp, #12]
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON) */
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b842:	2300      	movs	r3, #0
    b844:	9305      	str	r3, [sp, #20]

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    b846:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b84a:	2b1f      	cmp	r3, #31
    b84c:	d838      	bhi.n	b8c0 <FlexCAN_Ip_AbortTransfer+0xa8>
    {

    if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    b84e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b852:	9a03      	ldr	r2, [sp, #12]
    b854:	011b      	lsls	r3, r3, #4
    b856:	4413      	add	r3, r2
    b858:	3304      	adds	r3, #4
    b85a:	681b      	ldr	r3, [r3, #0]
    b85c:	2b00      	cmp	r3, #0
    b85e:	d102      	bne.n	b866 <FlexCAN_Ip_AbortTransfer+0x4e>
    {
        result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    b860:	2305      	movs	r3, #5
    b862:	9305      	str	r3, [sp, #20]
    b864:	e02c      	b.n	b8c0 <FlexCAN_Ip_AbortTransfer+0xa8>
    }
    else
    {
        FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, mb_idx, state->isIntActive);
    b866:	f89d 2006 	ldrb.w	r2, [sp, #6]
    b86a:	9b03      	ldr	r3, [sp, #12]
    b86c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b870:	f89d 1007 	ldrb.w	r1, [sp, #7]
    b874:	9804      	ldr	r0, [sp, #16]
    b876:	f000 feb3 	bl	c5e0 <FLEXCAN_ClearMsgBuffIntCmd>
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    b87a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b87e:	9a03      	ldr	r2, [sp, #12]
    b880:	011b      	lsls	r3, r3, #4
    b882:	4413      	add	r3, r2
    b884:	3304      	adds	r3, #4
    b886:	681b      	ldr	r3, [r3, #0]
    b888:	2b02      	cmp	r3, #2
    b88a:	d108      	bne.n	b89e <FlexCAN_Ip_AbortTransfer+0x86>
        {
            result = FlexCAN_AbortTxTransfer(u8Instance, mb_idx);
    b88c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    b890:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b894:	4611      	mov	r1, r2
    b896:	4618      	mov	r0, r3
    b898:	f7fe fabc 	bl	9e14 <FlexCAN_AbortTxTransfer>
    b89c:	9005      	str	r0, [sp, #20]
        }

        if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    b89e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b8a2:	9a03      	ldr	r2, [sp, #12]
    b8a4:	011b      	lsls	r3, r3, #4
    b8a6:	4413      	add	r3, r2
    b8a8:	3304      	adds	r3, #4
    b8aa:	681b      	ldr	r3, [r3, #0]
    b8ac:	2b01      	cmp	r3, #1
    b8ae:	d107      	bne.n	b8c0 <FlexCAN_Ip_AbortTransfer+0xa8>
        {
            FlexCAN_AbortRxTransfer(u8Instance, mb_idx);
    b8b0:	f89d 2006 	ldrb.w	r2, [sp, #6]
    b8b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b8b8:	4611      	mov	r1, r2
    b8ba:	4618      	mov	r0, r3
    b8bc:	f7fe fb34 	bl	9f28 <FlexCAN_AbortRxTransfer>
        }
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
#endif /* if FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return result;
    b8c0:	9b05      	ldr	r3, [sp, #20]
}
    b8c2:	4618      	mov	r0, r3
    b8c4:	b007      	add	sp, #28
    b8c6:	f85d fb04 	ldr.w	pc, [sp], #4
    b8ca:	bf00      	nop
    b8cc:	00010534 	.word	0x00010534
    b8d0:	1fff8fb8 	.word	0x1fff8fb8

0000b8d4 <FlexCAN_Ip_SetRxMb14Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb14Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb14Mask_Privileged(uint8 instance, uint32 mask)
{
    b8d4:	b500      	push	{lr}
    b8d6:	b087      	sub	sp, #28
    b8d8:	4603      	mov	r3, r0
    b8da:	9100      	str	r1, [sp, #0]
    b8dc:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b8e0:	2300      	movs	r3, #0
    b8e2:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b8e4:	2300      	movs	r3, #0
    b8e6:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b8e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b8ec:	4a1b      	ldr	r2, [pc, #108]	; (b95c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x88>)
    b8ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8f2:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b8f4:	9803      	ldr	r0, [sp, #12]
    b8f6:	f7fd fb5b 	bl	8fb0 <FlexCAN_IsEnabled>
    b8fa:	4603      	mov	r3, r0
    b8fc:	2b00      	cmp	r3, #0
    b8fe:	bf14      	ite	ne
    b900:	2301      	movne	r3, #1
    b902:	2300      	moveq	r3, #0
    b904:	b2db      	uxtb	r3, r3
    b906:	f083 0301 	eor.w	r3, r3, #1
    b90a:	b2db      	uxtb	r3, r3
    b90c:	f88d 300b 	strb.w	r3, [sp, #11]
    b910:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b914:	f003 0301 	and.w	r3, r3, #1
    b918:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b91c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b920:	2b00      	cmp	r3, #0
    b922:	d003      	beq.n	b92c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    b924:	9803      	ldr	r0, [sp, #12]
    b926:	f000 fb65 	bl	bff4 <FlexCAN_Enable>
    b92a:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    b92c:	9b05      	ldr	r3, [sp, #20]
    b92e:	2b00      	cmp	r3, #0
    b930:	d102      	bne.n	b938 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x64>
    {
        pBase->RX14MASK = mask;
    b932:	9b03      	ldr	r3, [sp, #12]
    b934:	9a00      	ldr	r2, [sp, #0]
    b936:	615a      	str	r2, [r3, #20]
    }
    if (TRUE == disabled)
    b938:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b93c:	2b00      	cmp	r3, #0
    b93e:	d008      	beq.n	b952 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    b940:	9803      	ldr	r0, [sp, #12]
    b942:	f000 fbd5 	bl	c0f0 <FlexCAN_Disable>
    b946:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b948:	9b04      	ldr	r3, [sp, #16]
    b94a:	2b00      	cmp	r3, #0
    b94c:	d001      	beq.n	b952 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
        {
            result = status;
    b94e:	9b04      	ldr	r3, [sp, #16]
    b950:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b952:	9b05      	ldr	r3, [sp, #20]
}
    b954:	4618      	mov	r0, r3
    b956:	b007      	add	sp, #28
    b958:	f85d fb04 	ldr.w	pc, [sp], #4
    b95c:	00010534 	.word	0x00010534

0000b960 <FlexCAN_Ip_SetRxMb15Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb15Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb15Mask_Privileged(uint8 instance, uint32 mask)
{
    b960:	b500      	push	{lr}
    b962:	b087      	sub	sp, #28
    b964:	4603      	mov	r3, r0
    b966:	9100      	str	r1, [sp, #0]
    b968:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b96c:	2300      	movs	r3, #0
    b96e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b970:	2300      	movs	r3, #0
    b972:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b974:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b978:	4a1b      	ldr	r2, [pc, #108]	; (b9e8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x88>)
    b97a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b97e:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b980:	9803      	ldr	r0, [sp, #12]
    b982:	f7fd fb15 	bl	8fb0 <FlexCAN_IsEnabled>
    b986:	4603      	mov	r3, r0
    b988:	2b00      	cmp	r3, #0
    b98a:	bf14      	ite	ne
    b98c:	2301      	movne	r3, #1
    b98e:	2300      	moveq	r3, #0
    b990:	b2db      	uxtb	r3, r3
    b992:	f083 0301 	eor.w	r3, r3, #1
    b996:	b2db      	uxtb	r3, r3
    b998:	f88d 300b 	strb.w	r3, [sp, #11]
    b99c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b9a0:	f003 0301 	and.w	r3, r3, #1
    b9a4:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b9a8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b9ac:	2b00      	cmp	r3, #0
    b9ae:	d003      	beq.n	b9b8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    b9b0:	9803      	ldr	r0, [sp, #12]
    b9b2:	f000 fb1f 	bl	bff4 <FlexCAN_Enable>
    b9b6:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    b9b8:	9b05      	ldr	r3, [sp, #20]
    b9ba:	2b00      	cmp	r3, #0
    b9bc:	d102      	bne.n	b9c4 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x64>
    {
        pBase->RX15MASK = mask;
    b9be:	9b03      	ldr	r3, [sp, #12]
    b9c0:	9a00      	ldr	r2, [sp, #0]
    b9c2:	619a      	str	r2, [r3, #24]
    }

    if (TRUE == disabled)
    b9c4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b9c8:	2b00      	cmp	r3, #0
    b9ca:	d008      	beq.n	b9de <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    b9cc:	9803      	ldr	r0, [sp, #12]
    b9ce:	f000 fb8f 	bl	c0f0 <FlexCAN_Disable>
    b9d2:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b9d4:	9b04      	ldr	r3, [sp, #16]
    b9d6:	2b00      	cmp	r3, #0
    b9d8:	d001      	beq.n	b9de <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
        {
            result = status;
    b9da:	9b04      	ldr	r3, [sp, #16]
    b9dc:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    b9de:	9b05      	ldr	r3, [sp, #20]
}
    b9e0:	4618      	mov	r0, r3
    b9e2:	b007      	add	sp, #28
    b9e4:	f85d fb04 	ldr.w	pc, [sp], #4
    b9e8:	00010534 	.word	0x00010534

0000b9ec <FlexCAN_Ip_SetListenOnlyMode_Privileged>:
 * This function will enable or disable Listen Only mode.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_SetListenOnlyMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetListenOnlyMode_Privileged(uint8 instance, const boolean enable)
{
    b9ec:	b500      	push	{lr}
    b9ee:	b087      	sub	sp, #28
    b9f0:	4603      	mov	r3, r0
    b9f2:	460a      	mov	r2, r1
    b9f4:	f88d 3007 	strb.w	r3, [sp, #7]
    b9f8:	4613      	mov	r3, r2
    b9fa:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b9fe:	2300      	movs	r3, #0
    ba00:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    ba02:	2300      	movs	r3, #0
    ba04:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    ba06:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ba0a:	4a1f      	ldr	r2, [pc, #124]	; (ba88 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x9c>)
    ba0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba10:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    ba12:	9803      	ldr	r0, [sp, #12]
    ba14:	f7fd facc 	bl	8fb0 <FlexCAN_IsEnabled>
    ba18:	4603      	mov	r3, r0
    ba1a:	2b00      	cmp	r3, #0
    ba1c:	bf14      	ite	ne
    ba1e:	2301      	movne	r3, #1
    ba20:	2300      	moveq	r3, #0
    ba22:	b2db      	uxtb	r3, r3
    ba24:	f083 0301 	eor.w	r3, r3, #1
    ba28:	b2db      	uxtb	r3, r3
    ba2a:	f88d 300b 	strb.w	r3, [sp, #11]
    ba2e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba32:	f003 0301 	and.w	r3, r3, #1
    ba36:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    ba3a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba3e:	2b00      	cmp	r3, #0
    ba40:	d003      	beq.n	ba4a <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    ba42:	9803      	ldr	r0, [sp, #12]
    ba44:	f000 fad6 	bl	bff4 <FlexCAN_Enable>
    ba48:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    ba4a:	9b05      	ldr	r3, [sp, #20]
    ba4c:	2b00      	cmp	r3, #0
    ba4e:	d109      	bne.n	ba64 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    ba50:	f001 fff6 	bl	da40 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
        FlexCAN_SetListenOnlyMode(pBase, enable);
    ba54:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ba58:	4619      	mov	r1, r3
    ba5a:	9803      	ldr	r0, [sp, #12]
    ba5c:	f7fd fae5 	bl	902a <FlexCAN_SetListenOnlyMode>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    ba60:	f002 f81a 	bl	da98 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
    }

    if (TRUE == disabled)
    ba64:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba68:	2b00      	cmp	r3, #0
    ba6a:	d008      	beq.n	ba7e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    ba6c:	9803      	ldr	r0, [sp, #12]
    ba6e:	f000 fb3f 	bl	c0f0 <FlexCAN_Disable>
    ba72:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    ba74:	9b04      	ldr	r3, [sp, #16]
    ba76:	2b00      	cmp	r3, #0
    ba78:	d001      	beq.n	ba7e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
        {
            result = status;
    ba7a:	9b04      	ldr	r3, [sp, #16]
    ba7c:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    ba7e:	9b05      	ldr	r3, [sp, #20]
}
    ba80:	4618      	mov	r0, r3
    ba82:	b007      	add	sp, #28
    ba84:	f85d fb04 	ldr.w	pc, [sp], #4
    ba88:	00010534 	.word	0x00010534

0000ba8c <FlexCAN_Ip_GetListenOnlyMode>:
 * Description   : Check if Listen Only mode is ENABLE.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_GetListenOnlyMode_Activity */
boolean FlexCAN_Ip_GetListenOnlyMode(uint8 instance)
{
    ba8c:	b500      	push	{lr}
    ba8e:	b085      	sub	sp, #20
    ba90:	4603      	mov	r3, r0
    ba92:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ba96:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ba9a:	4a06      	ldr	r2, [pc, #24]	; (bab4 <FlexCAN_Ip_GetListenOnlyMode+0x28>)
    ba9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    baa0:	9303      	str	r3, [sp, #12]
    return FlexCAN_IsListenOnlyModeEnabled(base);
    baa2:	9803      	ldr	r0, [sp, #12]
    baa4:	f7fd fc5d 	bl	9362 <FlexCAN_IsListenOnlyModeEnabled>
    baa8:	4603      	mov	r3, r0
}
    baaa:	4618      	mov	r0, r3
    baac:	b005      	add	sp, #20
    baae:	f85d fb04 	ldr.w	pc, [sp], #4
    bab2:	bf00      	nop
    bab4:	00010534 	.word	0x00010534

0000bab8 <FlexCAN_Ip_ManualBusOffRecovery>:
 * Description   : Recover manually from bus-off if possible.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_ManualBusOffRecovery_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ManualBusOffRecovery(uint8 Instance)
{
    bab8:	b500      	push	{lr}
    baba:	b089      	sub	sp, #36	; 0x24
    babc:	4603      	mov	r3, r0
    babe:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * Base = Flexcan_Ip_apxBase[Instance];
    bac2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bac6:	4a27      	ldr	r2, [pc, #156]	; (bb64 <FlexCAN_Ip_ManualBusOffRecovery+0xac>)
    bac8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bacc:	9305      	str	r3, [sp, #20]
    uint32 timeStart = 0U;
    bace:	2300      	movs	r3, #0
    bad0:	9303      	str	r3, [sp, #12]
    uint32 timeElapsed = 0U;
    bad2:	2300      	movs	r3, #0
    bad4:	9307      	str	r3, [sp, #28]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bad6:	2100      	movs	r1, #0
    bad8:	4823      	ldr	r0, [pc, #140]	; (bb68 <FlexCAN_Ip_ManualBusOffRecovery+0xb0>)
    bada:	f7f6 fbdd 	bl	2298 <OsIf_MicrosToTicks>
    bade:	9004      	str	r0, [sp, #16]
    Flexcan_Ip_StatusType RetVal = FLEXCAN_STATUS_ERROR;
    bae0:	2301      	movs	r3, #1
    bae2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Recover from bus-off when Automatic recovering from Bus Off state disabled. */
    if ((Base->CTRL1 & FLEXCAN_CTRL1_BOFFREC_MASK) != 0U)
    bae4:	9b05      	ldr	r3, [sp, #20]
    bae6:	685b      	ldr	r3, [r3, #4]
    bae8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    baec:	2b00      	cmp	r3, #0
    baee:	d033      	beq.n	bb58 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
    {
        RetVal = FLEXCAN_STATUS_SUCCESS;
    baf0:	2300      	movs	r3, #0
    baf2:	9306      	str	r3, [sp, #24]
        /* return success if the controller is not in bus-off */
        if ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    baf4:	9b05      	ldr	r3, [sp, #20]
    baf6:	6a1b      	ldr	r3, [r3, #32]
    baf8:	f003 0320 	and.w	r3, r3, #32
    bafc:	2b00      	cmp	r3, #0
    bafe:	d02b      	beq.n	bb58 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
        {
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    bb00:	f002 fad2 	bl	e0a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* negate to recover from bus-off */
            Base->CTRL1 &= ~FLEXCAN_CTRL1_BOFFREC_MASK;
    bb04:	9b05      	ldr	r3, [sp, #20]
    bb06:	685b      	ldr	r3, [r3, #4]
    bb08:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    bb0c:	9b05      	ldr	r3, [sp, #20]
    bb0e:	605a      	str	r2, [r3, #4]
            /* re-assert to disable bus-off auto reocvery */
            Base->CTRL1 |= FLEXCAN_CTRL1_BOFFREC_MASK;
    bb10:	9b05      	ldr	r3, [sp, #20]
    bb12:	685b      	ldr	r3, [r3, #4]
    bb14:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    bb18:	9b05      	ldr	r3, [sp, #20]
    bb1a:	605a      	str	r2, [r3, #4]
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    bb1c:	f002 faf0 	bl	e100 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* Wait till exit bus-off */
            timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bb20:	2000      	movs	r0, #0
    bb22:	f7f6 fb6d 	bl	2200 <OsIf_GetCounter>
    bb26:	4603      	mov	r3, r0
    bb28:	9303      	str	r3, [sp, #12]

            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    bb2a:	e00f      	b.n	bb4c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
            {
                timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bb2c:	ab03      	add	r3, sp, #12
    bb2e:	2100      	movs	r1, #0
    bb30:	4618      	mov	r0, r3
    bb32:	f7f6 fb7e 	bl	2232 <OsIf_GetElapsed>
    bb36:	4602      	mov	r2, r0
    bb38:	9b07      	ldr	r3, [sp, #28]
    bb3a:	4413      	add	r3, r2
    bb3c:	9307      	str	r3, [sp, #28]
                if (timeElapsed >= uS2Ticks)
    bb3e:	9a07      	ldr	r2, [sp, #28]
    bb40:	9b04      	ldr	r3, [sp, #16]
    bb42:	429a      	cmp	r2, r3
    bb44:	d302      	bcc.n	bb4c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
                {
                    RetVal = FLEXCAN_STATUS_TIMEOUT;
    bb46:	2303      	movs	r3, #3
    bb48:	9306      	str	r3, [sp, #24]
                    break;
    bb4a:	e005      	b.n	bb58 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    bb4c:	9b05      	ldr	r3, [sp, #20]
    bb4e:	6a1b      	ldr	r3, [r3, #32]
    bb50:	f003 0320 	and.w	r3, r3, #32
    bb54:	2b00      	cmp	r3, #0
    bb56:	d1e9      	bne.n	bb2c <FlexCAN_Ip_ManualBusOffRecovery+0x74>
                }
            }
        }
    }

    return RetVal;
    bb58:	9b06      	ldr	r3, [sp, #24]
}
    bb5a:	4618      	mov	r0, r3
    bb5c:	b009      	add	sp, #36	; 0x24
    bb5e:	f85d fb04 	ldr.w	pc, [sp], #4
    bb62:	bf00      	nop
    bb64:	00010534 	.word	0x00010534
    bb68:	000f4240 	.word	0x000f4240

0000bb6c <FlexCAN_SetSelfReception>:
{
    bb6c:	b082      	sub	sp, #8
    bb6e:	9001      	str	r0, [sp, #4]
    bb70:	460b      	mov	r3, r1
    bb72:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    bb76:	9b01      	ldr	r3, [sp, #4]
    bb78:	681b      	ldr	r3, [r3, #0]
    bb7a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    bb7e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bb82:	2a00      	cmp	r2, #0
    bb84:	d001      	beq.n	bb8a <FlexCAN_SetSelfReception+0x1e>
    bb86:	2200      	movs	r2, #0
    bb88:	e001      	b.n	bb8e <FlexCAN_SetSelfReception+0x22>
    bb8a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    bb8e:	431a      	orrs	r2, r3
    bb90:	9b01      	ldr	r3, [sp, #4]
    bb92:	601a      	str	r2, [r3, #0]
}
    bb94:	bf00      	nop
    bb96:	b002      	add	sp, #8
    bb98:	4770      	bx	lr

0000bb9a <FlexCAN_IsFDEnabled>:
{
    bb9a:	b082      	sub	sp, #8
    bb9c:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    bb9e:	9b01      	ldr	r3, [sp, #4]
    bba0:	681b      	ldr	r3, [r3, #0]
    bba2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    bba6:	2b00      	cmp	r3, #0
    bba8:	bf14      	ite	ne
    bbaa:	2301      	movne	r3, #1
    bbac:	2300      	moveq	r3, #0
    bbae:	b2db      	uxtb	r3, r3
}
    bbb0:	4618      	mov	r0, r3
    bbb2:	b002      	add	sp, #8
    bbb4:	4770      	bx	lr

0000bbb6 <FlexCAN_SetIsoCan>:
{
    bbb6:	b082      	sub	sp, #8
    bbb8:	9001      	str	r0, [sp, #4]
    bbba:	460b      	mov	r3, r1
    bbbc:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ISOCANFDEN_MASK) | FLEXCAN_CTRL2_ISOCANFDEN(enable ? 1UL : 0UL);
    bbc0:	9b01      	ldr	r3, [sp, #4]
    bbc2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bbc4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    bbc8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bbcc:	2a00      	cmp	r2, #0
    bbce:	d002      	beq.n	bbd6 <FlexCAN_SetIsoCan+0x20>
    bbd0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    bbd4:	e000      	b.n	bbd8 <FlexCAN_SetIsoCan+0x22>
    bbd6:	2200      	movs	r2, #0
    bbd8:	431a      	orrs	r2, r3
    bbda:	9b01      	ldr	r3, [sp, #4]
    bbdc:	635a      	str	r2, [r3, #52]	; 0x34
}
    bbde:	bf00      	nop
    bbe0:	b002      	add	sp, #8
    bbe2:	4770      	bx	lr

0000bbe4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>:
{
    bbe4:	b082      	sub	sp, #8
    bbe6:	9001      	str	r0, [sp, #4]
    bbe8:	460b      	mov	r3, r1
    bbea:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EACEN_MASK) | FLEXCAN_CTRL2_EACEN(enable ? 1UL : 0UL);
    bbee:	9b01      	ldr	r3, [sp, #4]
    bbf0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bbf2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    bbf6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bbfa:	2a00      	cmp	r2, #0
    bbfc:	d002      	beq.n	bc04 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x20>
    bbfe:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    bc02:	e000      	b.n	bc06 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x22>
    bc04:	2200      	movs	r2, #0
    bc06:	431a      	orrs	r2, r3
    bc08:	9b01      	ldr	r3, [sp, #4]
    bc0a:	635a      	str	r2, [r3, #52]	; 0x34
}
    bc0c:	bf00      	nop
    bc0e:	b002      	add	sp, #8
    bc10:	4770      	bx	lr

0000bc12 <FlexCAN_SetProtocolException>:
{
    bc12:	b082      	sub	sp, #8
    bc14:	9001      	str	r0, [sp, #4]
    bc16:	460b      	mov	r3, r1
    bc18:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_PREXCEN_MASK) | FLEXCAN_CTRL2_PREXCEN(enable ? 1UL : 0UL);
    bc1c:	9b01      	ldr	r3, [sp, #4]
    bc1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bc20:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    bc24:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bc28:	2a00      	cmp	r2, #0
    bc2a:	d002      	beq.n	bc32 <FlexCAN_SetProtocolException+0x20>
    bc2c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    bc30:	e000      	b.n	bc34 <FlexCAN_SetProtocolException+0x22>
    bc32:	2200      	movs	r2, #0
    bc34:	431a      	orrs	r2, r3
    bc36:	9b01      	ldr	r3, [sp, #4]
    bc38:	635a      	str	r2, [r3, #52]	; 0x34
}
    bc3a:	bf00      	nop
    bc3c:	b002      	add	sp, #8
    bc3e:	4770      	bx	lr

0000bc40 <FlexCAN_SetRemoteReqStore>:
{
    bc40:	b082      	sub	sp, #8
    bc42:	9001      	str	r0, [sp, #4]
    bc44:	460b      	mov	r3, r1
    bc46:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RRS_MASK) | FLEXCAN_CTRL2_RRS(enable ? 1UL : 0UL);
    bc4a:	9b01      	ldr	r3, [sp, #4]
    bc4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bc4e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    bc52:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bc56:	2a00      	cmp	r2, #0
    bc58:	d002      	beq.n	bc60 <FlexCAN_SetRemoteReqStore+0x20>
    bc5a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    bc5e:	e000      	b.n	bc62 <FlexCAN_SetRemoteReqStore+0x22>
    bc60:	2200      	movs	r2, #0
    bc62:	431a      	orrs	r2, r3
    bc64:	9b01      	ldr	r3, [sp, #4]
    bc66:	635a      	str	r2, [r3, #52]	; 0x34
}
    bc68:	bf00      	nop
    bc6a:	b002      	add	sp, #8
    bc6c:	4770      	bx	lr

0000bc6e <FlexCAN_SetBusOffAutorecovery>:
{
    bc6e:	b082      	sub	sp, #8
    bc70:	9001      	str	r0, [sp, #4]
    bc72:	460b      	mov	r3, r1
    bc74:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_BOFFREC_MASK) | FLEXCAN_CTRL1_BOFFREC(enable ? 0UL : 1UL);
    bc78:	9b01      	ldr	r3, [sp, #4]
    bc7a:	685b      	ldr	r3, [r3, #4]
    bc7c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    bc80:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bc84:	2a00      	cmp	r2, #0
    bc86:	d001      	beq.n	bc8c <FlexCAN_SetBusOffAutorecovery+0x1e>
    bc88:	2200      	movs	r2, #0
    bc8a:	e000      	b.n	bc8e <FlexCAN_SetBusOffAutorecovery+0x20>
    bc8c:	2240      	movs	r2, #64	; 0x40
    bc8e:	431a      	orrs	r2, r3
    bc90:	9b01      	ldr	r3, [sp, #4]
    bc92:	605a      	str	r2, [r3, #4]
}
    bc94:	bf00      	nop
    bc96:	b002      	add	sp, #8
    bc98:	4770      	bx	lr

0000bc9a <FlexCAN_SetEdgeFilter>:
{
    bc9a:	b082      	sub	sp, #8
    bc9c:	9001      	str	r0, [sp, #4]
    bc9e:	460b      	mov	r3, r1
    bca0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EDFLTDIS_MASK) | FLEXCAN_CTRL2_EDFLTDIS(enable ? 0UL : 1UL);
    bca4:	9b01      	ldr	r3, [sp, #4]
    bca6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bca8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    bcac:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bcb0:	2a00      	cmp	r2, #0
    bcb2:	d001      	beq.n	bcb8 <FlexCAN_SetEdgeFilter+0x1e>
    bcb4:	2200      	movs	r2, #0
    bcb6:	e001      	b.n	bcbc <FlexCAN_SetEdgeFilter+0x22>
    bcb8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    bcbc:	431a      	orrs	r2, r3
    bcbe:	9b01      	ldr	r3, [sp, #4]
    bcc0:	635a      	str	r2, [r3, #52]	; 0x34
}
    bcc2:	bf00      	nop
    bcc4:	b002      	add	sp, #8
    bcc6:	4770      	bx	lr

0000bcc8 <FlexCAN_CanBitSampling>:
{
    bcc8:	b082      	sub	sp, #8
    bcca:	9001      	str	r0, [sp, #4]
    bccc:	460b      	mov	r3, r1
    bcce:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_SMP_MASK) | FLEXCAN_CTRL1_SMP(enable ? 1UL : 0UL);
    bcd2:	9b01      	ldr	r3, [sp, #4]
    bcd4:	685b      	ldr	r3, [r3, #4]
    bcd6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    bcda:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bcde:	2a00      	cmp	r2, #0
    bce0:	d001      	beq.n	bce6 <FlexCAN_CanBitSampling+0x1e>
    bce2:	2280      	movs	r2, #128	; 0x80
    bce4:	e000      	b.n	bce8 <FlexCAN_CanBitSampling+0x20>
    bce6:	2200      	movs	r2, #0
    bce8:	431a      	orrs	r2, r3
    bcea:	9b01      	ldr	r3, [sp, #4]
    bcec:	605a      	str	r2, [r3, #4]
}
    bcee:	bf00      	nop
    bcf0:	b002      	add	sp, #8
    bcf2:	4770      	bx	lr

0000bcf4 <FlexCAN_ComputeDLCValue>:
 * Function Name: FLEXCAN_ComputeDLCValue
 * Description  : Computes the DLC field value, given a payload size (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_ComputeDLCValue(uint8 payloadSize)
{
    bcf4:	b084      	sub	sp, #16
    bcf6:	4603      	mov	r3, r0
    bcf8:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 ret = 0xFFU;                   /* 0,  1,  2,  3,  4,  5,  6,  7,  8, */
    bcfc:	23ff      	movs	r3, #255	; 0xff
    bcfe:	9303      	str	r3, [sp, #12]
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES
                                          };

    if (payloadSize <= 64U)
    bd00:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bd04:	2b40      	cmp	r3, #64	; 0x40
    bd06:	d804      	bhi.n	bd12 <FlexCAN_ComputeDLCValue+0x1e>
    {
        ret = payload_code[payloadSize];
    bd08:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bd0c:	4a03      	ldr	r2, [pc, #12]	; (bd1c <FlexCAN_ComputeDLCValue+0x28>)
    bd0e:	5cd3      	ldrb	r3, [r2, r3]
    bd10:	9303      	str	r3, [sp, #12]
    else
    {
        /* The argument is not a valid payload size will return 0xFF*/
    }

    return (uint8)ret;
    bd12:	9b03      	ldr	r3, [sp, #12]
    bd14:	b2db      	uxtb	r3, r3
}
    bd16:	4618      	mov	r0, r3
    bd18:	b004      	add	sp, #16
    bd1a:	4770      	bx	lr
    bd1c:	00010540 	.word	0x00010540

0000bd20 <FlexCAN_ClearRAM>:
 * Function Name : FLEXCAN_ClearRAM
 * Description   : Clears FlexCAN memory positions that require initialization.
 *
 *END**************************************************************************/
static void FlexCAN_ClearRAM(FLEXCAN_Type * base)
{
    bd20:	b500      	push	{lr}
    bd22:	b087      	sub	sp, #28
    bd24:	9001      	str	r0, [sp, #4]
    uint32 databyte;
    uint32 RAM_size   = FlexCAN_GetMaxMbNum(base) * 4U;
    bd26:	9801      	ldr	r0, [sp, #4]
    bd28:	f000 f8f6 	bl	bf18 <FlexCAN_GetMaxMbNum>
    bd2c:	4603      	mov	r3, r0
    bd2e:	009b      	lsls	r3, r3, #2
    bd30:	9304      	str	r3, [sp, #16]
    uint32 RXIMR_size = FlexCAN_GetMaxMbNum(base);
    bd32:	9801      	ldr	r0, [sp, #4]
    bd34:	f000 f8f0 	bl	bf18 <FlexCAN_GetMaxMbNum>
    bd38:	9003      	str	r0, [sp, #12]
    /* Address of base + ram offset to point to MB start address */
    volatile uint32 * RAM = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    bd3a:	9b01      	ldr	r3, [sp, #4]
    bd3c:	3380      	adds	r3, #128	; 0x80
    bd3e:	9302      	str	r3, [sp, #8]
    /* Clear MB region */
    for (databyte = 0U; databyte < RAM_size; databyte++)
    bd40:	2300      	movs	r3, #0
    bd42:	9305      	str	r3, [sp, #20]
    bd44:	e008      	b.n	bd58 <FlexCAN_ClearRAM+0x38>
    {
        RAM[databyte] = 0x0U;
    bd46:	9b05      	ldr	r3, [sp, #20]
    bd48:	009b      	lsls	r3, r3, #2
    bd4a:	9a02      	ldr	r2, [sp, #8]
    bd4c:	4413      	add	r3, r2
    bd4e:	2200      	movs	r2, #0
    bd50:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RAM_size; databyte++)
    bd52:	9b05      	ldr	r3, [sp, #20]
    bd54:	3301      	adds	r3, #1
    bd56:	9305      	str	r3, [sp, #20]
    bd58:	9a05      	ldr	r2, [sp, #20]
    bd5a:	9b04      	ldr	r3, [sp, #16]
    bd5c:	429a      	cmp	r2, r3
    bd5e:	d3f2      	bcc.n	bd46 <FlexCAN_ClearRAM+0x26>
    }
    RAM = (volatile uint32 *)base->RXIMR;
    bd60:	9b01      	ldr	r3, [sp, #4]
    bd62:	f503 6308 	add.w	r3, r3, #2176	; 0x880
    bd66:	9302      	str	r3, [sp, #8]
    /* Clear RXIMR region */
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    bd68:	2300      	movs	r3, #0
    bd6a:	9305      	str	r3, [sp, #20]
    bd6c:	e008      	b.n	bd80 <FlexCAN_ClearRAM+0x60>
    {
        RAM[databyte] = 0x0U;
    bd6e:	9b05      	ldr	r3, [sp, #20]
    bd70:	009b      	lsls	r3, r3, #2
    bd72:	9a02      	ldr	r2, [sp, #8]
    bd74:	4413      	add	r3, r2
    bd76:	2200      	movs	r2, #0
    bd78:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    bd7a:	9b05      	ldr	r3, [sp, #20]
    bd7c:	3301      	adds	r3, #1
    bd7e:	9305      	str	r3, [sp, #20]
    bd80:	9a05      	ldr	r2, [sp, #20]
    bd82:	9b03      	ldr	r3, [sp, #12]
    bd84:	429a      	cmp	r2, r3
    bd86:	d3f2      	bcc.n	bd6e <FlexCAN_ClearRAM+0x4e>
    }
#endif
    /* Clear WRMFRZ bit in CTRL2 Register to restrict write access to memory */
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_WRMFRZ_MASK) | FLEXCAN_CTRL2_WRMFRZ(0U);
#endif /* if FLEXCAN_IP_FEATURE_HAS_MEM_ERR_DET */
}
    bd88:	bf00      	nop
    bd8a:	bf00      	nop
    bd8c:	b007      	add	sp, #28
    bd8e:	f85d fb04 	ldr.w	pc, [sp], #4

0000bd92 <FlexCAN_ComputePayloadSize>:
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#else
static uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
{
    bd92:	b084      	sub	sp, #16
    bd94:	4603      	mov	r3, r0
    bd96:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ret = 8U;
    bd9a:	2308      	movs	r3, #8
    bd9c:	f88d 300f 	strb.w	r3, [sp, #15]

    if (dlcValue <= 8U)
    bda0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bda4:	2b08      	cmp	r3, #8
    bda6:	d804      	bhi.n	bdb2 <FlexCAN_ComputePayloadSize+0x20>
    {
        ret = dlcValue;
    bda8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bdac:	f88d 300f 	strb.w	r3, [sp, #15]
    bdb0:	e033      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
    }
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    else
    {
        switch (dlcValue)
    bdb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bdb6:	3b09      	subs	r3, #9
    bdb8:	2b06      	cmp	r3, #6
    bdba:	d82d      	bhi.n	be18 <FlexCAN_ComputePayloadSize+0x86>
    bdbc:	a201      	add	r2, pc, #4	; (adr r2, bdc4 <FlexCAN_ComputePayloadSize+0x32>)
    bdbe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    bdc2:	bf00      	nop
    bdc4:	0000bde1 	.word	0x0000bde1
    bdc8:	0000bde9 	.word	0x0000bde9
    bdcc:	0000bdf1 	.word	0x0000bdf1
    bdd0:	0000bdf9 	.word	0x0000bdf9
    bdd4:	0000be01 	.word	0x0000be01
    bdd8:	0000be09 	.word	0x0000be09
    bddc:	0000be11 	.word	0x0000be11
        {
            case FLEXCAN_IP_DLC_VALUE_12_BYTES:
                ret = 12U;
    bde0:	230c      	movs	r3, #12
    bde2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    bde6:	e018      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_16_BYTES:
                ret = 16U;
    bde8:	2310      	movs	r3, #16
    bdea:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    bdee:	e014      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_20_BYTES:
                ret = 20U;
    bdf0:	2314      	movs	r3, #20
    bdf2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    bdf6:	e010      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_24_BYTES:
                ret = 24U;
    bdf8:	2318      	movs	r3, #24
    bdfa:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    bdfe:	e00c      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_32_BYTES:
                ret = 32U;
    be00:	2320      	movs	r3, #32
    be02:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    be06:	e008      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_48_BYTES:
                ret = 48U;
    be08:	2330      	movs	r3, #48	; 0x30
    be0a:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    be0e:	e004      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_64_BYTES:
                ret = 64U;
    be10:	2340      	movs	r3, #64	; 0x40
    be12:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    be16:	e000      	b.n	be1a <FlexCAN_ComputePayloadSize+0x88>
            default:
                /* The argument is not a valid DLC size */
                break;
    be18:	bf00      	nop
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    return ret;
    be1a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    be1e:	4618      	mov	r0, r3
    be20:	b004      	add	sp, #16
    be22:	4770      	bx	lr

0000be24 <FlexCAN_GetMsgBuffRegion>:
 * Function Name : FLEXCAN_GetMsgBuffRegion
 * Description   : Returns the start of a MB area, based on its index.
 *
 *END**************************************************************************/
volatile uint32 * FlexCAN_GetMsgBuffRegion(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    be24:	b500      	push	{lr}
    be26:	b08b      	sub	sp, #44	; 0x2c
    be28:	9001      	str	r0, [sp, #4]
    be2a:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    be2c:	2308      	movs	r3, #8
    be2e:	f88d 3020 	strb.w	r3, [sp, #32]
    uint8 mb_size = 0U;
    be32:	2300      	movs	r3, #0
    be34:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ramBlockSize = 512U;
    be38:	f44f 7300 	mov.w	r3, #512	; 0x200
    be3c:	9307      	str	r3, [sp, #28]
    uint16 ramBlockOffset = 0;
    be3e:	2300      	movs	r3, #0
    be40:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    uint8 msgBuffIdxBackup = (uint8)msgBuffIdx;
    be44:	9b00      	ldr	r3, [sp, #0]
    be46:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint8 i=0U;
    be4a:	2300      	movs	r3, #0
    be4c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    uint8 maxMbNum=0U;
    be50:	2300      	movs	r3, #0
    be52:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    uint32 mb_index=0U;
    be56:	2300      	movs	r3, #0
    be58:	9306      	str	r3, [sp, #24]
    uint8 payload_size=0U;
    be5a:	2300      	movs	r3, #0
    be5c:	f88d 3017 	strb.w	r3, [sp, #23]
    volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    be60:	9b01      	ldr	r3, [sp, #4]
    be62:	3380      	adds	r3, #128	; 0x80
    be64:	9304      	str	r3, [sp, #16]
    volatile uint32 * pAddressRet = NULL_PTR;
    be66:	2300      	movs	r3, #0
    be68:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY == STD_ON)
    volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    be6a:	2300      	movs	r3, #0
    be6c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    be70:	e02d      	b.n	bece <FlexCAN_GetMsgBuffRegion+0xaa>
    {
        payload_size = FlexCAN_GetPayloadSize(base, i);
    be72:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    be76:	4619      	mov	r1, r3
    be78:	9801      	ldr	r0, [sp, #4]
    be7a:	f000 fad1 	bl	c420 <FlexCAN_GetPayloadSize>
    be7e:	4603      	mov	r3, r0
    be80:	f88d 3017 	strb.w	r3, [sp, #23]
        mb_size = (uint8)(payload_size + arbitration_field_size);
    be84:	f89d 2017 	ldrb.w	r2, [sp, #23]
    be88:	f89d 3020 	ldrb.w	r3, [sp, #32]
    be8c:	4413      	add	r3, r2
    be8e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        maxMbNum = (uint8)(ramBlockSize / mb_size);
    be92:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    be96:	9a07      	ldr	r2, [sp, #28]
    be98:	fbb2 f3f3 	udiv	r3, r2, r3
    be9c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        if (maxMbNum > msgBuffIdxBackup)
    bea0:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    bea4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    bea8:	429a      	cmp	r2, r3
    beaa:	d815      	bhi.n	bed8 <FlexCAN_GetMsgBuffRegion+0xb4>
        {
            break;
        }
        ramBlockOffset += 128U;
    beac:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    beb0:	3380      	adds	r3, #128	; 0x80
    beb2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        msgBuffIdxBackup -= maxMbNum;
    beb6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    beba:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    bebe:	1ad3      	subs	r3, r2, r3
    bec0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    bec4:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    bec8:	3301      	adds	r3, #1
    beca:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    bece:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    bed2:	2b00      	cmp	r3, #0
    bed4:	d0cd      	beq.n	be72 <FlexCAN_GetMsgBuffRegion+0x4e>
    bed6:	e000      	b.n	beda <FlexCAN_GetMsgBuffRegion+0xb6>
            break;
    bed8:	bf00      	nop
    }
    else
#endif
    {
        /* Multiply the MB index by the MB size (in words) */
        mb_index = (uint32)ramBlockOffset + (((uint32)msgBuffIdxBackup % (uint32)maxMbNum) * ((uint32)mb_size >> 2U));
    beda:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
    bede:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    bee2:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    bee6:	fbb3 f0f2 	udiv	r0, r3, r2
    beea:	fb00 f202 	mul.w	r2, r0, r2
    beee:	1a9b      	subs	r3, r3, r2
    bef0:	b2db      	uxtb	r3, r3
    bef2:	461a      	mov	r2, r3
    bef4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    bef8:	089b      	lsrs	r3, r3, #2
    befa:	b2db      	uxtb	r3, r3
    befc:	fb02 f303 	mul.w	r3, r2, r3
    bf00:	440b      	add	r3, r1
    bf02:	9306      	str	r3, [sp, #24]
        pAddressRet = &(RAM[mb_index]);
    bf04:	9b06      	ldr	r3, [sp, #24]
    bf06:	009b      	lsls	r3, r3, #2
    bf08:	9a04      	ldr	r2, [sp, #16]
    bf0a:	4413      	add	r3, r2
    bf0c:	9303      	str	r3, [sp, #12]
    }

    return pAddressRet;
    bf0e:	9b03      	ldr	r3, [sp, #12]
}
    bf10:	4618      	mov	r0, r3
    bf12:	b00b      	add	sp, #44	; 0x2c
    bf14:	f85d fb04 	ldr.w	pc, [sp], #4

0000bf18 <FlexCAN_GetMaxMbNum>:
 * Function Name : FlexCAN_GetMaxMbNum
 * Description   : Computes the maximum RAM size occupied by MBs.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMaxMbNum(const FLEXCAN_Type * base)
{
    bf18:	b084      	sub	sp, #16
    bf1a:	9001      	str	r0, [sp, #4]
    uint32 i, ret = 0u;
    bf1c:	2300      	movs	r3, #0
    bf1e:	9302      	str	r3, [sp, #8]
    static FLEXCAN_Type * const flexcanBase[] = IP_FLEXCAN_BASE_PTRS;
    static const uint32 maxMbNum[] = FLEXCAN_IP_FEATURE_MAX_MB_NUM_ARRAY;

    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    bf20:	2300      	movs	r3, #0
    bf22:	9303      	str	r3, [sp, #12]
    bf24:	e00e      	b.n	bf44 <FlexCAN_GetMaxMbNum+0x2c>
    {
        if (base == flexcanBase[i])
    bf26:	4a0b      	ldr	r2, [pc, #44]	; (bf54 <FlexCAN_GetMaxMbNum+0x3c>)
    bf28:	9b03      	ldr	r3, [sp, #12]
    bf2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bf2e:	9a01      	ldr	r2, [sp, #4]
    bf30:	429a      	cmp	r2, r3
    bf32:	d104      	bne.n	bf3e <FlexCAN_GetMaxMbNum+0x26>
        {
            ret = maxMbNum[i];
    bf34:	4a08      	ldr	r2, [pc, #32]	; (bf58 <FlexCAN_GetMaxMbNum+0x40>)
    bf36:	9b03      	ldr	r3, [sp, #12]
    bf38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bf3c:	9302      	str	r3, [sp, #8]
    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    bf3e:	9b03      	ldr	r3, [sp, #12]
    bf40:	3301      	adds	r3, #1
    bf42:	9303      	str	r3, [sp, #12]
    bf44:	9b03      	ldr	r3, [sp, #12]
    bf46:	2b02      	cmp	r3, #2
    bf48:	d9ed      	bls.n	bf26 <FlexCAN_GetMaxMbNum+0xe>
        }
    }
    return ret;
    bf4a:	9b02      	ldr	r3, [sp, #8]
}
    bf4c:	4618      	mov	r0, r3
    bf4e:	b004      	add	sp, #16
    bf50:	4770      	bx	lr
    bf52:	bf00      	nop
    bf54:	00010584 	.word	0x00010584
    bf58:	00010590 	.word	0x00010590

0000bf5c <FlexCAN_EnterFreezeMode>:
 * Function Name : FLEXCAN_EnterFreezeMode
 * Description   : Enter the freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnterFreezeMode(FLEXCAN_Type * base)
{
    bf5c:	b500      	push	{lr}
    bf5e:	b087      	sub	sp, #28
    bf60:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    bf62:	2300      	movs	r3, #0
    bf64:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    bf66:	2300      	movs	r3, #0
    bf68:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bf6a:	2100      	movs	r1, #0
    bf6c:	4820      	ldr	r0, [pc, #128]	; (bff0 <FlexCAN_EnterFreezeMode+0x94>)
    bf6e:	f7f6 f993 	bl	2298 <OsIf_MicrosToTicks>
    bf72:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    bf74:	2300      	movs	r3, #0
    bf76:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    bf78:	f001 fad2 	bl	d520 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(1U);
    bf7c:	9b01      	ldr	r3, [sp, #4]
    bf7e:	681b      	ldr	r3, [r3, #0]
    bf80:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    bf84:	9b01      	ldr	r3, [sp, #4]
    bf86:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(1U);
    bf88:	9b01      	ldr	r3, [sp, #4]
    bf8a:	681b      	ldr	r3, [r3, #0]
    bf8c:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
    bf90:	9b01      	ldr	r3, [sp, #4]
    bf92:	601a      	str	r2, [r3, #0]
    if (((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U)
    bf94:	9b01      	ldr	r3, [sp, #4]
    bf96:	681b      	ldr	r3, [r3, #0]
    bf98:	2b00      	cmp	r3, #0
    bf9a:	da05      	bge.n	bfa8 <FlexCAN_EnterFreezeMode+0x4c>
    {
        base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    bf9c:	9b01      	ldr	r3, [sp, #4]
    bf9e:	681b      	ldr	r3, [r3, #0]
    bfa0:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    bfa4:	9b01      	ldr	r3, [sp, #4]
    bfa6:	601a      	str	r2, [r3, #0]
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    bfa8:	f001 fae6 	bl	d578 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bfac:	2000      	movs	r0, #0
    bfae:	f7f6 f927 	bl	2200 <OsIf_GetCounter>
    bfb2:	4603      	mov	r3, r0
    bfb4:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    bfb6:	e00f      	b.n	bfd8 <FlexCAN_EnterFreezeMode+0x7c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    bfb8:	ab02      	add	r3, sp, #8
    bfba:	2100      	movs	r1, #0
    bfbc:	4618      	mov	r0, r3
    bfbe:	f7f6 f938 	bl	2232 <OsIf_GetElapsed>
    bfc2:	4602      	mov	r2, r0
    bfc4:	9b05      	ldr	r3, [sp, #20]
    bfc6:	4413      	add	r3, r2
    bfc8:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    bfca:	9a05      	ldr	r2, [sp, #20]
    bfcc:	9b03      	ldr	r3, [sp, #12]
    bfce:	429a      	cmp	r2, r3
    bfd0:	d302      	bcc.n	bfd8 <FlexCAN_EnterFreezeMode+0x7c>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    bfd2:	2303      	movs	r3, #3
    bfd4:	9304      	str	r3, [sp, #16]
            break;
    bfd6:	e005      	b.n	bfe4 <FlexCAN_EnterFreezeMode+0x88>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    bfd8:	9b01      	ldr	r3, [sp, #4]
    bfda:	681b      	ldr	r3, [r3, #0]
    bfdc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    bfe0:	2b00      	cmp	r3, #0
    bfe2:	d0e9      	beq.n	bfb8 <FlexCAN_EnterFreezeMode+0x5c>
        }
    }

    return returnResult;
    bfe4:	9b04      	ldr	r3, [sp, #16]
}
    bfe6:	4618      	mov	r0, r3
    bfe8:	b007      	add	sp, #28
    bfea:	f85d fb04 	ldr.w	pc, [sp], #4
    bfee:	bf00      	nop
    bff0:	000f4240 	.word	0x000f4240

0000bff4 <FlexCAN_Enable>:
 * Function Name : FlexCAN_Enable
 * Description   : Enable the clock for FlexCAN Module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Enable(FLEXCAN_Type * base)
{
    bff4:	b500      	push	{lr}
    bff6:	b087      	sub	sp, #28
    bff8:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    bffa:	2300      	movs	r3, #0
    bffc:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    bffe:	2300      	movs	r3, #0
    c000:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c002:	2100      	movs	r1, #0
    c004:	4818      	ldr	r0, [pc, #96]	; (c068 <FlexCAN_Enable+0x74>)
    c006:	f7f6 f947 	bl	2298 <OsIf_MicrosToTicks>
    c00a:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    c00c:	2300      	movs	r3, #0
    c00e:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    c010:	f001 fad8 	bl	d5c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>

    /* Enable Module */
    base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    c014:	9b01      	ldr	r3, [sp, #4]
    c016:	681b      	ldr	r3, [r3, #0]
    c018:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    c01c:	9b01      	ldr	r3, [sp, #4]
    c01e:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    c020:	f001 fafc 	bl	d61c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c024:	2000      	movs	r0, #0
    c026:	f7f6 f8eb 	bl	2200 <OsIf_GetCounter>
    c02a:	4603      	mov	r3, r0
    c02c:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    c02e:	e00f      	b.n	c050 <FlexCAN_Enable+0x5c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c030:	ab02      	add	r3, sp, #8
    c032:	2100      	movs	r1, #0
    c034:	4618      	mov	r0, r3
    c036:	f7f6 f8fc 	bl	2232 <OsIf_GetElapsed>
    c03a:	4602      	mov	r2, r0
    c03c:	9b05      	ldr	r3, [sp, #20]
    c03e:	4413      	add	r3, r2
    c040:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    c042:	9a05      	ldr	r2, [sp, #20]
    c044:	9b03      	ldr	r3, [sp, #12]
    c046:	429a      	cmp	r2, r3
    c048:	d302      	bcc.n	c050 <FlexCAN_Enable+0x5c>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    c04a:	2303      	movs	r3, #3
    c04c:	9304      	str	r3, [sp, #16]
            break;
    c04e:	e005      	b.n	c05c <FlexCAN_Enable+0x68>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    c050:	9b01      	ldr	r3, [sp, #4]
    c052:	681b      	ldr	r3, [r3, #0]
    c054:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    c058:	2b00      	cmp	r3, #0
    c05a:	d0e9      	beq.n	c030 <FlexCAN_Enable+0x3c>
        }
    }
    return returnValue;
    c05c:	9b04      	ldr	r3, [sp, #16]
}
    c05e:	4618      	mov	r0, r3
    c060:	b007      	add	sp, #28
    c062:	f85d fb04 	ldr.w	pc, [sp], #4
    c066:	bf00      	nop
    c068:	000f4240 	.word	0x000f4240

0000c06c <FlexCAN_ExitFreezeMode>:
 * Function Name : FLEXCAN_ExitFreezeMode
 * Description   : Exit of freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_ExitFreezeMode(FLEXCAN_Type * base)
{
    c06c:	b500      	push	{lr}
    c06e:	b087      	sub	sp, #28
    c070:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    c072:	2300      	movs	r3, #0
    c074:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    c076:	2300      	movs	r3, #0
    c078:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c07a:	2100      	movs	r1, #0
    c07c:	481b      	ldr	r0, [pc, #108]	; (c0ec <FlexCAN_ExitFreezeMode+0x80>)
    c07e:	f7f6 f90b 	bl	2298 <OsIf_MicrosToTicks>
    c082:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    c084:	2300      	movs	r3, #0
    c086:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    c088:	f001 faee 	bl	d668 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(0U);
    c08c:	9b01      	ldr	r3, [sp, #4]
    c08e:	681b      	ldr	r3, [r3, #0]
    c090:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
    c094:	9b01      	ldr	r3, [sp, #4]
    c096:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(0U);
    c098:	9b01      	ldr	r3, [sp, #4]
    c09a:	681b      	ldr	r3, [r3, #0]
    c09c:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    c0a0:	9b01      	ldr	r3, [sp, #4]
    c0a2:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    c0a4:	f001 fb0c 	bl	d6c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    /* Wait till exit freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c0a8:	2000      	movs	r0, #0
    c0aa:	f7f6 f8a9 	bl	2200 <OsIf_GetCounter>
    c0ae:	4603      	mov	r3, r0
    c0b0:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    c0b2:	e00f      	b.n	c0d4 <FlexCAN_ExitFreezeMode+0x68>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c0b4:	ab02      	add	r3, sp, #8
    c0b6:	2100      	movs	r1, #0
    c0b8:	4618      	mov	r0, r3
    c0ba:	f7f6 f8ba 	bl	2232 <OsIf_GetElapsed>
    c0be:	4602      	mov	r2, r0
    c0c0:	9b05      	ldr	r3, [sp, #20]
    c0c2:	4413      	add	r3, r2
    c0c4:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    c0c6:	9a05      	ldr	r2, [sp, #20]
    c0c8:	9b03      	ldr	r3, [sp, #12]
    c0ca:	429a      	cmp	r2, r3
    c0cc:	d302      	bcc.n	c0d4 <FlexCAN_ExitFreezeMode+0x68>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    c0ce:	2303      	movs	r3, #3
    c0d0:	9304      	str	r3, [sp, #16]
            break;
    c0d2:	e005      	b.n	c0e0 <FlexCAN_ExitFreezeMode+0x74>
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    c0d4:	9b01      	ldr	r3, [sp, #4]
    c0d6:	681b      	ldr	r3, [r3, #0]
    c0d8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    c0dc:	2b00      	cmp	r3, #0
    c0de:	d1e9      	bne.n	c0b4 <FlexCAN_ExitFreezeMode+0x48>
        }
    }
    return returnValue;
    c0e0:	9b04      	ldr	r3, [sp, #16]
}
    c0e2:	4618      	mov	r0, r3
    c0e4:	b007      	add	sp, #28
    c0e6:	f85d fb04 	ldr.w	pc, [sp], #4
    c0ea:	bf00      	nop
    c0ec:	000f4240 	.word	0x000f4240

0000c0f0 <FlexCAN_Disable>:
 * Description   : Disable FlexCAN module.
 * This function will disable FlexCAN module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Disable(FLEXCAN_Type * base)
{
    c0f0:	b500      	push	{lr}
    c0f2:	b087      	sub	sp, #28
    c0f4:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    c0f6:	2300      	movs	r3, #0
    c0f8:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    c0fa:	2300      	movs	r3, #0
    c0fc:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c0fe:	2100      	movs	r1, #0
    c100:	481a      	ldr	r0, [pc, #104]	; (c16c <FlexCAN_Disable+0x7c>)
    c102:	f7f6 f8c9 	bl	2298 <OsIf_MicrosToTicks>
    c106:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    c108:	2300      	movs	r3, #0
    c10a:	9304      	str	r3, [sp, #16]

    /* To access the memory mapped registers */
    /* Enter disable mode (hard reset). */
    if (0U == ((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT))
    c10c:	9b01      	ldr	r3, [sp, #4]
    c10e:	681b      	ldr	r3, [r3, #0]
    c110:	2b00      	cmp	r3, #0
    c112:	db25      	blt.n	c160 <FlexCAN_Disable+0x70>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    c114:	f001 fafa 	bl	d70c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Clock disable (module) */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MDIS_MASK) | FLEXCAN_MCR_MDIS(1U);
    c118:	9b01      	ldr	r3, [sp, #4]
    c11a:	681b      	ldr	r3, [r3, #0]
    c11c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    c120:	9b01      	ldr	r3, [sp, #4]
    c122:	601a      	str	r2, [r3, #0]
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    c124:	f001 fb1e 	bl	d764 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Wait until disable mode acknowledged */
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c128:	2000      	movs	r0, #0
    c12a:	f7f6 f869 	bl	2200 <OsIf_GetCounter>
    c12e:	4603      	mov	r3, r0
    c130:	9302      	str	r3, [sp, #8]
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    c132:	e00f      	b.n	c154 <FlexCAN_Disable+0x64>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c134:	ab02      	add	r3, sp, #8
    c136:	2100      	movs	r1, #0
    c138:	4618      	mov	r0, r3
    c13a:	f7f6 f87a 	bl	2232 <OsIf_GetElapsed>
    c13e:	4602      	mov	r2, r0
    c140:	9b05      	ldr	r3, [sp, #20]
    c142:	4413      	add	r3, r2
    c144:	9305      	str	r3, [sp, #20]
            if (timeElapsed >= uS2Ticks)
    c146:	9a05      	ldr	r2, [sp, #20]
    c148:	9b03      	ldr	r3, [sp, #12]
    c14a:	429a      	cmp	r2, r3
    c14c:	d302      	bcc.n	c154 <FlexCAN_Disable+0x64>
            {
                returnResult = FLEXCAN_STATUS_TIMEOUT;
    c14e:	2303      	movs	r3, #3
    c150:	9304      	str	r3, [sp, #16]
                break;
    c152:	e005      	b.n	c160 <FlexCAN_Disable+0x70>
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    c154:	9b01      	ldr	r3, [sp, #4]
    c156:	681b      	ldr	r3, [r3, #0]
    c158:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    c15c:	2b00      	cmp	r3, #0
    c15e:	d0e9      	beq.n	c134 <FlexCAN_Disable+0x44>
            }
        }
    }
    return returnResult;
    c160:	9b04      	ldr	r3, [sp, #16]
}
    c162:	4618      	mov	r0, r3
    c164:	b007      	add	sp, #28
    c166:	f85d fb04 	ldr.w	pc, [sp], #4
    c16a:	bf00      	nop
    c16c:	000f4240 	.word	0x000f4240

0000c170 <FlexCAN_SetErrIntCmd>:
 * Description   : Enable the error interrupts.
 * This function will enable Error interrupt.
 *
 *END**************************************************************************/
void FlexCAN_SetErrIntCmd(FLEXCAN_Type * base, flexcan_int_type_t errType, boolean enable)
{
    c170:	b500      	push	{lr}
    c172:	b087      	sub	sp, #28
    c174:	9003      	str	r0, [sp, #12]
    c176:	9102      	str	r1, [sp, #8]
    c178:	4613      	mov	r3, r2
    c17a:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 temp = (uint32)errType;
    c17e:	9b02      	ldr	r3, [sp, #8]
    c180:	9305      	str	r3, [sp, #20]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    c182:	f001 fb15 	bl	d7b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
    if (enable)
    c186:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c18a:	2b00      	cmp	r3, #0
    c18c:	d020      	beq.n	c1d0 <FlexCAN_SetErrIntCmd+0x60>
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    c18e:	9b02      	ldr	r3, [sp, #8]
    c190:	f244 0201 	movw	r2, #16385	; 0x4001
    c194:	4293      	cmp	r3, r2
    c196:	d106      	bne.n	c1a6 <FlexCAN_SetErrIntCmd+0x36>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(1U);
    c198:	9b03      	ldr	r3, [sp, #12]
    c19a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c19c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    c1a0:	9b03      	ldr	r3, [sp, #12]
    c1a2:	635a      	str	r2, [r3, #52]	; 0x34
    c1a4:	e03a      	b.n	c21c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            if ((FLEXCAN_INT_RX_WARNING == errType) || (FLEXCAN_INT_TX_WARNING == errType))
    c1a6:	9b02      	ldr	r3, [sp, #8]
    c1a8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    c1ac:	d003      	beq.n	c1b6 <FlexCAN_SetErrIntCmd+0x46>
    c1ae:	9b02      	ldr	r3, [sp, #8]
    c1b0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    c1b4:	d105      	bne.n	c1c2 <FlexCAN_SetErrIntCmd+0x52>
            {
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(1U);
    c1b6:	9b03      	ldr	r3, [sp, #12]
    c1b8:	681b      	ldr	r3, [r3, #0]
    c1ba:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    c1be:	9b03      	ldr	r3, [sp, #12]
    c1c0:	601a      	str	r2, [r3, #0]
            }
            (base->CTRL1) = ((base->CTRL1) | (temp));
    c1c2:	9b03      	ldr	r3, [sp, #12]
    c1c4:	685a      	ldr	r2, [r3, #4]
    c1c6:	9b05      	ldr	r3, [sp, #20]
    c1c8:	431a      	orrs	r2, r3
    c1ca:	9b03      	ldr	r3, [sp, #12]
    c1cc:	605a      	str	r2, [r3, #4]
    c1ce:	e025      	b.n	c21c <FlexCAN_SetErrIntCmd+0xac>
        }
    }
    else
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    c1d0:	9b02      	ldr	r3, [sp, #8]
    c1d2:	f244 0201 	movw	r2, #16385	; 0x4001
    c1d6:	4293      	cmp	r3, r2
    c1d8:	d106      	bne.n	c1e8 <FlexCAN_SetErrIntCmd+0x78>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(0U);
    c1da:	9b03      	ldr	r3, [sp, #12]
    c1dc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c1de:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    c1e2:	9b03      	ldr	r3, [sp, #12]
    c1e4:	635a      	str	r2, [r3, #52]	; 0x34
    c1e6:	e019      	b.n	c21c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            (base->CTRL1) = ((base->CTRL1) & ~(temp));
    c1e8:	9b03      	ldr	r3, [sp, #12]
    c1ea:	685a      	ldr	r2, [r3, #4]
    c1ec:	9b05      	ldr	r3, [sp, #20]
    c1ee:	43db      	mvns	r3, r3
    c1f0:	401a      	ands	r2, r3
    c1f2:	9b03      	ldr	r3, [sp, #12]
    c1f4:	605a      	str	r2, [r3, #4]
            temp = base->CTRL1;
    c1f6:	9b03      	ldr	r3, [sp, #12]
    c1f8:	685b      	ldr	r3, [r3, #4]
    c1fa:	9305      	str	r3, [sp, #20]
            if ((0U == (temp & (uint32)FLEXCAN_INT_RX_WARNING)) && (0U == (temp & (uint32)FLEXCAN_INT_TX_WARNING)))
    c1fc:	9b05      	ldr	r3, [sp, #20]
    c1fe:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    c202:	2b00      	cmp	r3, #0
    c204:	d10a      	bne.n	c21c <FlexCAN_SetErrIntCmd+0xac>
    c206:	9b05      	ldr	r3, [sp, #20]
    c208:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    c20c:	2b00      	cmp	r3, #0
    c20e:	d105      	bne.n	c21c <FlexCAN_SetErrIntCmd+0xac>
            {
                /* If WRNEN disabled then both FLEXCAN_INT_RX_WARNING and FLEXCAN_INT_TX_WARNING will be disabled */
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(0U);
    c210:	9b03      	ldr	r3, [sp, #12]
    c212:	681b      	ldr	r3, [r3, #0]
    c214:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
    c218:	9b03      	ldr	r3, [sp, #12]
    c21a:	601a      	str	r2, [r3, #0]
            }
        }
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    c21c:	f001 faf4 	bl	d808 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
}
    c220:	bf00      	nop
    c222:	b007      	add	sp, #28
    c224:	f85d fb04 	ldr.w	pc, [sp], #4

0000c228 <FlexCAN_Init>:
 * buffers, initialize all message buffers as inactive, enable RX FIFO
 * if needed, mask all mask bits, and disable all MB interrupts.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Init(FLEXCAN_Type * base)
{
    c228:	b500      	push	{lr}
    c22a:	b087      	sub	sp, #28
    c22c:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    c22e:	2300      	movs	r3, #0
    c230:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    c232:	2300      	movs	r3, #0
    c234:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c236:	2100      	movs	r1, #0
    c238:	4833      	ldr	r0, [pc, #204]	; (c308 <FlexCAN_Init+0xe0>)
    c23a:	f7f6 f82d 	bl	2298 <OsIf_MicrosToTicks>
    c23e:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    c240:	2300      	movs	r3, #0
    c242:	9304      	str	r3, [sp, #16]

    /* Reset the FLEXCAN */
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SOFTRST_MASK) | FLEXCAN_MCR_SOFTRST(1U);
    c244:	9b01      	ldr	r3, [sp, #4]
    c246:	681b      	ldr	r3, [r3, #0]
    c248:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    c24c:	9b01      	ldr	r3, [sp, #4]
    c24e:	601a      	str	r2, [r3, #0]
    /* Wait for reset cycle to complete */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c250:	2000      	movs	r0, #0
    c252:	f7f5 ffd5 	bl	2200 <OsIf_GetCounter>
    c256:	4603      	mov	r3, r0
    c258:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    c25a:	e00f      	b.n	c27c <FlexCAN_Init+0x54>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c25c:	ab02      	add	r3, sp, #8
    c25e:	2100      	movs	r1, #0
    c260:	4618      	mov	r0, r3
    c262:	f7f5 ffe6 	bl	2232 <OsIf_GetElapsed>
    c266:	4602      	mov	r2, r0
    c268:	9b05      	ldr	r3, [sp, #20]
    c26a:	4413      	add	r3, r2
    c26c:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    c26e:	9a05      	ldr	r2, [sp, #20]
    c270:	9b03      	ldr	r3, [sp, #12]
    c272:	429a      	cmp	r2, r3
    c274:	d302      	bcc.n	c27c <FlexCAN_Init+0x54>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    c276:	2303      	movs	r3, #3
    c278:	9304      	str	r3, [sp, #16]
            break;
    c27a:	e005      	b.n	c288 <FlexCAN_Init+0x60>
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    c27c:	9b01      	ldr	r3, [sp, #4]
    c27e:	681b      	ldr	r3, [r3, #0]
    c280:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    c284:	2b00      	cmp	r3, #0
    c286:	d1e9      	bne.n	c25c <FlexCAN_Init+0x34>
        }
    }
    if (FLEXCAN_STATUS_SUCCESS == returnResult)
    c288:	9b04      	ldr	r3, [sp, #16]
    c28a:	2b00      	cmp	r3, #0
    c28c:	d136      	bne.n	c2fc <FlexCAN_Init+0xd4>
    {
        /* Avoid Abort Transmission, use Inactive MB */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_AEN_MASK) | FLEXCAN_MCR_AEN(1U);
    c28e:	9b01      	ldr	r3, [sp, #4]
    c290:	681b      	ldr	r3, [r3, #0]
    c292:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    c296:	9b01      	ldr	r3, [sp, #4]
    c298:	601a      	str	r2, [r3, #0]
        /* Clear FlexCAN memory */
        FlexCAN_ClearRAM(base);
    c29a:	9801      	ldr	r0, [sp, #4]
    c29c:	f7ff fd40 	bl	bd20 <FlexCAN_ClearRAM>
        /* Rx global mask*/
        (base->RXMGMASK) = (uint32)(FLEXCAN_RXMGMASK_MG_MASK);
    c2a0:	9b01      	ldr	r3, [sp, #4]
    c2a2:	f04f 32ff 	mov.w	r2, #4294967295
    c2a6:	611a      	str	r2, [r3, #16]
        /* Rx reg 14 mask*/
        (base->RX14MASK) =  (uint32)(FLEXCAN_RX14MASK_RX14M_MASK);
    c2a8:	9b01      	ldr	r3, [sp, #4]
    c2aa:	f04f 32ff 	mov.w	r2, #4294967295
    c2ae:	615a      	str	r2, [r3, #20]
        /* Rx reg 15 mask*/
        (base->RX15MASK) = (uint32)(FLEXCAN_RX15MASK_RX15M_MASK);
    c2b0:	9b01      	ldr	r3, [sp, #4]
    c2b2:	f04f 32ff 	mov.w	r2, #4294967295
    c2b6:	619a      	str	r2, [r3, #24]
        /* Disable all MB interrupts */
        (base->IMASK1) = 0x0;
    c2b8:	9b01      	ldr	r3, [sp, #4]
    c2ba:	2200      	movs	r2, #0
    c2bc:	629a      	str	r2, [r3, #40]	; 0x28
        /* Clear all MB interrupt flags */
        (base->IFLAG1) = FLEXCAN_IMASK1_BUF31TO0M_MASK;
    c2be:	9b01      	ldr	r3, [sp, #4]
    c2c0:	f04f 32ff 	mov.w	r2, #4294967295
    c2c4:	631a      	str	r2, [r3, #48]	; 0x30
            (base->IMASK4) = 0x0;
            (base->IFLAG4) = FLEXCAN_IMASK4_BUF127TO96M_MASK;
        }
#endif
        /* Clear all error interrupt flags */
        (base->ESR1) = FLEXCAN_IP_ALL_INT;
    c2c6:	9b01      	ldr	r3, [sp, #4]
    c2c8:	4a10      	ldr	r2, [pc, #64]	; (c30c <FlexCAN_Init+0xe4>)
    c2ca:	621a      	str	r2, [r3, #32]
        /* clear registers which are not effected by soft reset */
        base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    c2cc:	9b01      	ldr	r3, [sp, #4]
    c2ce:	2200      	movs	r2, #0
    c2d0:	605a      	str	r2, [r3, #4]
        base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    c2d2:	9b01      	ldr	r3, [sp, #4]
    c2d4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    c2d8:	635a      	str	r2, [r3, #52]	; 0x34
        base->CBT   = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    c2da:	9b01      	ldr	r3, [sp, #4]
    c2dc:	2200      	movs	r2, #0
    c2de:	651a      	str	r2, [r3, #80]	; 0x50
        base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
        base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    c2e0:	9801      	ldr	r0, [sp, #4]
    c2e2:	f000 f85b 	bl	c39c <FlexCAN_IsFDAvailable>
    c2e6:	4603      	mov	r3, r0
    c2e8:	2b00      	cmp	r3, #0
    c2ea:	d007      	beq.n	c2fc <FlexCAN_Init+0xd4>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    c2ec:	9b01      	ldr	r3, [sp, #4]
    c2ee:	2200      	movs	r2, #0
    c2f0:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    c2f4:	9b01      	ldr	r3, [sp, #4]
    c2f6:	4a06      	ldr	r2, [pc, #24]	; (c310 <FlexCAN_Init+0xe8>)
    c2f8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    #if defined(CAN_FEATURE_S32K1XX)
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
#endif /* (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON) */
    }
    return returnResult;
    c2fc:	9b04      	ldr	r3, [sp, #16]
}
    c2fe:	4618      	mov	r0, r3
    c300:	b007      	add	sp, #28
    c302:	f85d fb04 	ldr.w	pc, [sp], #4
    c306:	bf00      	nop
    c308:	000f4240 	.word	0x000f4240
    c30c:	003b0006 	.word	0x003b0006
    c310:	80004100 	.word	0x80004100

0000c314 <FlexCAN_EnableRxFifo>:
 * This function will enable the Rx FIFO feature.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnableRxFifo(FLEXCAN_Type * base,
                                         uint32 numOfFilters)
{
    c314:	b500      	push	{lr}
    c316:	b087      	sub	sp, #28
    c318:	9001      	str	r0, [sp, #4]
    c31a:	9100      	str	r1, [sp, #0]
    uint32 i;
    uint16 noOfMbx = (uint16)FlexCAN_GetMaxMbNum(base);
    c31c:	9801      	ldr	r0, [sp, #4]
    c31e:	f7ff fdfb 	bl	bf18 <FlexCAN_GetMaxMbNum>
    c322:	4603      	mov	r3, r0
    c324:	f8ad 300e 	strh.w	r3, [sp, #14]
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    c328:	2300      	movs	r3, #0
    c32a:	9304      	str	r3, [sp, #16]

    /* RxFIFO cannot be enabled if FD is enabled */
    if (((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U)
    c32c:	9b01      	ldr	r3, [sp, #4]
    c32e:	681b      	ldr	r3, [r3, #0]
    c330:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    c334:	2b00      	cmp	r3, #0
    c336:	d001      	beq.n	c33c <FlexCAN_EnableRxFifo+0x28>
    {
        stat = FLEXCAN_STATUS_ERROR;
    c338:	2301      	movs	r3, #1
    c33a:	9304      	str	r3, [sp, #16]
    }
    if (FLEXCAN_STATUS_SUCCESS == stat)
    c33c:	9b04      	ldr	r3, [sp, #16]
    c33e:	2b00      	cmp	r3, #0
    c340:	d127      	bne.n	c392 <FlexCAN_EnableRxFifo+0x7e>
    {
        /* Enable RX FIFO */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_RFEN_MASK) | FLEXCAN_MCR_RFEN(1U);
    c342:	9b01      	ldr	r3, [sp, #4]
    c344:	681b      	ldr	r3, [r3, #0]
    c346:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
    c34a:	9b01      	ldr	r3, [sp, #4]
    c34c:	601a      	str	r2, [r3, #0]
        /* Set the number of the RX FIFO filters needed */
        base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RFFN_MASK) | ((numOfFilters << FLEXCAN_CTRL2_RFFN_SHIFT) & FLEXCAN_CTRL2_RFFN_MASK);
    c34e:	9b01      	ldr	r3, [sp, #4]
    c350:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c352:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    c356:	9b00      	ldr	r3, [sp, #0]
    c358:	061b      	lsls	r3, r3, #24
    c35a:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    c35e:	431a      	orrs	r2, r3
    c360:	9b01      	ldr	r3, [sp, #4]
    c362:	635a      	str	r2, [r3, #52]	; 0x34
        /* RX FIFO global mask, take in consideration all filter fields*/
        (base->RXFGMASK) = FLEXCAN_RXFGMASK_FGM_MASK;
    c364:	9b01      	ldr	r3, [sp, #4]
    c366:	f04f 32ff 	mov.w	r2, #4294967295
    c36a:	649a      	str	r2, [r3, #72]	; 0x48

        for (i = 0U; i < noOfMbx; i++)
    c36c:	2300      	movs	r3, #0
    c36e:	9305      	str	r3, [sp, #20]
    c370:	e00a      	b.n	c388 <FlexCAN_EnableRxFifo+0x74>
        {
            /* RX individual mask */
            base->RXIMR[i] = (FLEXCAN_RXIMR_MI_MASK << FLEXCAN_IP_ID_EXT_SHIFT) & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    c372:	9b01      	ldr	r3, [sp, #4]
    c374:	9a05      	ldr	r2, [sp, #20]
    c376:	f502 7208 	add.w	r2, r2, #544	; 0x220
    c37a:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    c37e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0U; i < noOfMbx; i++)
    c382:	9b05      	ldr	r3, [sp, #20]
    c384:	3301      	adds	r3, #1
    c386:	9305      	str	r3, [sp, #20]
    c388:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    c38c:	9a05      	ldr	r2, [sp, #20]
    c38e:	429a      	cmp	r2, r3
    c390:	d3ef      	bcc.n	c372 <FlexCAN_EnableRxFifo+0x5e>
        }
    }
    return stat;
    c392:	9b04      	ldr	r3, [sp, #16]
}
    c394:	4618      	mov	r0, r3
    c396:	b007      	add	sp, #28
    c398:	f85d fb04 	ldr.w	pc, [sp], #4

0000c39c <FlexCAN_IsFDAvailable>:
 * Description   : Checks if FlexCAN has FD Support.
 * This function is private.
 *
 *END**************************************************************************/
boolean FlexCAN_IsFDAvailable(const FLEXCAN_Type * base)
{
    c39c:	b084      	sub	sp, #16
    c39e:	9001      	str	r0, [sp, #4]
    uint32 i=0U;
    c3a0:	2300      	movs	r3, #0
    c3a2:	9303      	str	r3, [sp, #12]
    static FLEXCAN_Type * const flexcanBase[] = CAN_BASE_PTRS_HAS_FD;
    boolean returnValue = FALSE;
    c3a4:	2300      	movs	r3, #0
    c3a6:	f88d 300b 	strb.w	r3, [sp, #11]
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    c3aa:	2300      	movs	r3, #0
    c3ac:	9303      	str	r3, [sp, #12]
    c3ae:	e00d      	b.n	c3cc <FlexCAN_IsFDAvailable+0x30>
    {
        if (base == flexcanBase[i])
    c3b0:	4a0a      	ldr	r2, [pc, #40]	; (c3dc <FlexCAN_IsFDAvailable+0x40>)
    c3b2:	9b03      	ldr	r3, [sp, #12]
    c3b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c3b8:	9a01      	ldr	r2, [sp, #4]
    c3ba:	429a      	cmp	r2, r3
    c3bc:	d103      	bne.n	c3c6 <FlexCAN_IsFDAvailable+0x2a>
        {
            returnValue = TRUE;
    c3be:	2301      	movs	r3, #1
    c3c0:	f88d 300b 	strb.w	r3, [sp, #11]
            break;
    c3c4:	e005      	b.n	c3d2 <FlexCAN_IsFDAvailable+0x36>
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    c3c6:	9b03      	ldr	r3, [sp, #12]
    c3c8:	3301      	adds	r3, #1
    c3ca:	9303      	str	r3, [sp, #12]
    c3cc:	9b03      	ldr	r3, [sp, #12]
    c3ce:	2b00      	cmp	r3, #0
    c3d0:	d0ee      	beq.n	c3b0 <FlexCAN_IsFDAvailable+0x14>
        }
    }

    return returnValue;
    c3d2:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    c3d6:	4618      	mov	r0, r3
    c3d8:	b004      	add	sp, #16
    c3da:	4770      	bx	lr
    c3dc:	0001059c 	.word	0x0001059c

0000c3e0 <FlexCAN_SetPayloadSize>:
 * Description   : Sets the payload size of the MBs.
 *
 *END**************************************************************************/
void FlexCAN_SetPayloadSize(FLEXCAN_Type * base,
                            const Flexcan_Ip_PayloadSizeType * payloadSize)
{
    c3e0:	b500      	push	{lr}
    c3e2:	b085      	sub	sp, #20
    c3e4:	9001      	str	r0, [sp, #4]
    c3e6:	9100      	str	r1, [sp, #0]
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
    DevAssert(FlexCAN_IsFDEnabled(base) || (FLEXCAN_PAYLOAD_SIZE_8 == payloadSize->payloadBlock3));
    #endif
#endif
    /* If FD is not enabled, only 8 bytes payload is supported */
    if (FlexCAN_IsFDEnabled(base))
    c3e8:	9801      	ldr	r0, [sp, #4]
    c3ea:	f7ff fbd6 	bl	bb9a <FlexCAN_IsFDEnabled>
    c3ee:	4603      	mov	r3, r0
    c3f0:	2b00      	cmp	r3, #0
    c3f2:	d011      	beq.n	c418 <FlexCAN_SetPayloadSize+0x38>
    {
        tmp = base->FDCTRL;
    c3f4:	9b01      	ldr	r3, [sp, #4]
    c3f6:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    c3fa:	9303      	str	r3, [sp, #12]
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR0_MASK);
    c3fc:	9b03      	ldr	r3, [sp, #12]
    c3fe:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    c402:	9303      	str	r3, [sp, #12]
        tmp |= ((uint32)payloadSize->payloadBlock0) << FLEXCAN_FDCTRL_MBDSR0_SHIFT;
    c404:	9b00      	ldr	r3, [sp, #0]
    c406:	681b      	ldr	r3, [r3, #0]
    c408:	041b      	lsls	r3, r3, #16
    c40a:	9a03      	ldr	r2, [sp, #12]
    c40c:	4313      	orrs	r3, r2
    c40e:	9303      	str	r3, [sp, #12]
#endif
#if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR3_MASK);
        tmp |= ((uint32)payloadSize->payloadBlock3) << FLEXCAN_FDCTRL_MBDSR3_SHIFT;
#endif
        base->FDCTRL = tmp;
    c410:	9b01      	ldr	r3, [sp, #4]
    c412:	9a03      	ldr	r2, [sp, #12]
    c414:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
}
    c418:	bf00      	nop
    c41a:	b005      	add	sp, #20
    c41c:	f85d fb04 	ldr.w	pc, [sp], #4

0000c420 <FlexCAN_GetPayloadSize>:
 * Function Name : FLEXCAN_GetPayloadSize
 * Description   : Returns the payload size of the MBs (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_GetPayloadSize(const FLEXCAN_Type * base, uint8 mbdsrIdx)
{
    c420:	b500      	push	{lr}
    c422:	b085      	sub	sp, #20
    c424:	9001      	str	r0, [sp, #4]
    c426:	460b      	mov	r3, r1
    c428:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 payloadSize = 0U;
    c42c:	2300      	movs	r3, #0
    c42e:	9303      	str	r3, [sp, #12]

#if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    c430:	9801      	ldr	r0, [sp, #4]
    c432:	f7ff ffb3 	bl	c39c <FlexCAN_IsFDAvailable>
    c436:	4603      	mov	r3, r0
    c438:	2b00      	cmp	r3, #0
    c43a:	d019      	beq.n	c470 <FlexCAN_GetPayloadSize+0x50>
    {
#endif /* defined(CAN_FEATURE_S32K1XX) */
    switch (mbdsrIdx)
    c43c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    c440:	2b00      	cmp	r3, #0
    c442:	d10a      	bne.n	c45a <FlexCAN_GetPayloadSize+0x3a>
    {
        case 0 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    c444:	9b01      	ldr	r3, [sp, #4]
    c446:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    c44a:	0c1b      	lsrs	r3, r3, #16
    c44c:	f003 0303 	and.w	r3, r3, #3
    c450:	2208      	movs	r2, #8
    c452:	fa02 f303 	lsl.w	r3, r2, r3
    c456:	9303      	str	r3, [sp, #12]
    c458:	e00c      	b.n	c474 <FlexCAN_GetPayloadSize+0x54>
        case 2 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR2_MASK) >> FLEXCAN_FDCTRL_MBDSR2_SHIFT); } break;
    #endif
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        case 3 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR3_MASK) >> FLEXCAN_FDCTRL_MBDSR3_SHIFT); } break;
    #endif
        default :{  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    c45a:	9b01      	ldr	r3, [sp, #4]
    c45c:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    c460:	0c1b      	lsrs	r3, r3, #16
    c462:	f003 0303 	and.w	r3, r3, #3
    c466:	2208      	movs	r2, #8
    c468:	fa02 f303 	lsl.w	r3, r2, r3
    c46c:	9303      	str	r3, [sp, #12]
    c46e:	e001      	b.n	c474 <FlexCAN_GetPayloadSize+0x54>
    }
    #if defined(CAN_FEATURE_S32K1XX)
    }
    else
    {
        payloadSize = 8U;
    c470:	2308      	movs	r3, #8
    c472:	9303      	str	r3, [sp, #12]
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
    return (uint8)payloadSize;
    c474:	9b03      	ldr	r3, [sp, #12]
    c476:	b2db      	uxtb	r3, r3
}
    c478:	4618      	mov	r0, r3
    c47a:	b005      	add	sp, #20
    c47c:	f85d fb04 	ldr.w	pc, [sp], #4

0000c480 <FlexCAN_GetMbPayloadSize>:



uint8 FlexCAN_GetMbPayloadSize(const FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    c480:	b500      	push	{lr}
    c482:	b087      	sub	sp, #28
    c484:	9001      	str	r0, [sp, #4]
    c486:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    c488:	2308      	movs	r3, #8
    c48a:	f88d 3014 	strb.w	r3, [sp, #20]
    uint32 ramBlockSize = 512U;
    c48e:	f44f 7300 	mov.w	r3, #512	; 0x200
    c492:	9304      	str	r3, [sp, #16]
    uint8 can_real_payload = 8U;
    c494:	2308      	movs	r3, #8
    c496:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 maxMbBlockNum = 0U;
    c49a:	2300      	movs	r3, #0
    c49c:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8 i=0U;
    c4a0:	2300      	movs	r3, #0
    c4a2:	f88d 3015 	strb.w	r3, [sp, #21]
    uint8 mb_size = 0U;
    c4a6:	2300      	movs	r3, #0
    c4a8:	f88d 300f 	strb.w	r3, [sp, #15]

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    c4ac:	2300      	movs	r3, #0
    c4ae:	f88d 3015 	strb.w	r3, [sp, #21]
    c4b2:	e024      	b.n	c4fe <FlexCAN_GetMbPayloadSize+0x7e>
    {
        /* Check that the number of MBs is supported based on the payload size*/
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        can_real_payload = FlexCAN_GetPayloadSize(base, i);
    c4b4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c4b8:	4619      	mov	r1, r3
    c4ba:	9801      	ldr	r0, [sp, #4]
    c4bc:	f7ff ffb0 	bl	c420 <FlexCAN_GetPayloadSize>
    c4c0:	4603      	mov	r3, r0
    c4c2:	f88d 3017 	strb.w	r3, [sp, #23]
#endif /* Else can_real_payload will remain as 8 payload size */
        mb_size = (uint8)(can_real_payload + arbitration_field_size);
    c4c6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    c4ca:	f89d 3014 	ldrb.w	r3, [sp, #20]
    c4ce:	4413      	add	r3, r2
    c4d0:	f88d 300f 	strb.w	r3, [sp, #15]
        maxMbBlockNum += (uint8)(ramBlockSize / mb_size);
    c4d4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c4d8:	9a04      	ldr	r2, [sp, #16]
    c4da:	fbb2 f3f3 	udiv	r3, r2, r3
    c4de:	b2da      	uxtb	r2, r3
    c4e0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c4e4:	4413      	add	r3, r2
    c4e6:	f88d 3016 	strb.w	r3, [sp, #22]
        if (maxMbBlockNum > maxMsgBuffNum)
    c4ea:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c4ee:	9a00      	ldr	r2, [sp, #0]
    c4f0:	429a      	cmp	r2, r3
    c4f2:	d309      	bcc.n	c508 <FlexCAN_GetMbPayloadSize+0x88>
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    c4f4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c4f8:	3301      	adds	r3, #1
    c4fa:	f88d 3015 	strb.w	r3, [sp, #21]
    c4fe:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c502:	2b00      	cmp	r3, #0
    c504:	d0d6      	beq.n	c4b4 <FlexCAN_GetMbPayloadSize+0x34>
    c506:	e000      	b.n	c50a <FlexCAN_GetMbPayloadSize+0x8a>
        {
            break;
    c508:	bf00      	nop
    {
        can_real_payload = 64U;
    }
 #endif

    return can_real_payload;
    c50a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    c50e:	4618      	mov	r0, r3
    c510:	b007      	add	sp, #28
    c512:	f85d fb04 	ldr.w	pc, [sp], #4

0000c516 <FlexCAN_LockRxMsgBuff>:
 * Description   : Lock the RX message buffer.
 * This function will lock the RX message buffer.
 *
 *END**************************************************************************/
void FlexCAN_LockRxMsgBuff(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    c516:	b500      	push	{lr}
    c518:	b085      	sub	sp, #20
    c51a:	9001      	str	r0, [sp, #4]
    c51c:	9100      	str	r1, [sp, #0]
    volatile const uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    c51e:	9900      	ldr	r1, [sp, #0]
    c520:	9801      	ldr	r0, [sp, #4]
    c522:	f7ff fc7f 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    c526:	9003      	str	r0, [sp, #12]

    /* Lock the mailbox by reading it */
    (void)*flexcan_mb;
    c528:	9b03      	ldr	r3, [sp, #12]
    c52a:	681b      	ldr	r3, [r3, #0]
}
    c52c:	bf00      	nop
    c52e:	b005      	add	sp, #20
    c530:	f85d fb04 	ldr.w	pc, [sp], #4

0000c534 <FlexCAN_SetMsgBuffIntCmd>:
                                               uint8 u8Instance,
                                               uint32 msgBuffIdx,
                                               boolean enable,
                                               boolean bIsIntActive
                                              )
{
    c534:	b500      	push	{lr}
    c536:	b087      	sub	sp, #28
    c538:	9003      	str	r0, [sp, #12]
    c53a:	9201      	str	r2, [sp, #4]
    c53c:	461a      	mov	r2, r3
    c53e:	460b      	mov	r3, r1
    c540:	f88d 300b 	strb.w	r3, [sp, #11]
    c544:	4613      	mov	r3, r2
    c546:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp;
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    c54a:	2300      	movs	r3, #0
    c54c:	9305      	str	r3, [sp, #20]

        /* Enable the corresponding message buffer Interrupt */
        temp = 1UL << (msgBuffIdx % 32U);
    c54e:	9b01      	ldr	r3, [sp, #4]
    c550:	f003 031f 	and.w	r3, r3, #31
    c554:	2201      	movs	r2, #1
    c556:	fa02 f303 	lsl.w	r3, r2, r3
    c55a:	9304      	str	r3, [sp, #16]
        if (msgBuffIdx < 32U)
    c55c:	9b01      	ldr	r3, [sp, #4]
    c55e:	2b1f      	cmp	r3, #31
    c560:	d837      	bhi.n	c5d2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
        {
            if (enable)
    c562:	f89d 300a 	ldrb.w	r3, [sp, #10]
    c566:	2b00      	cmp	r3, #0
    c568:	d01b      	beq.n	c5a2 <FlexCAN_SetMsgBuffIntCmd+0x6e>
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    c56a:	f001 fcf9 	bl	df60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) | (temp));
    c56e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c572:	4a1a      	ldr	r2, [pc, #104]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c574:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    c578:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c57c:	9a04      	ldr	r2, [sp, #16]
    c57e:	430a      	orrs	r2, r1
    c580:	4916      	ldr	r1, [pc, #88]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c582:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                if (TRUE == bIsIntActive)
    c586:	f89d 3020 	ldrb.w	r3, [sp, #32]
    c58a:	2b00      	cmp	r3, #0
    c58c:	d006      	beq.n	c59c <FlexCAN_SetMsgBuffIntCmd+0x68>
                {
                    base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    c58e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c592:	4a12      	ldr	r2, [pc, #72]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c594:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    c598:	9b03      	ldr	r3, [sp, #12]
    c59a:	629a      	str	r2, [r3, #40]	; 0x28
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    c59c:	f001 fd0c 	bl	dfb8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
    c5a0:	e017      	b.n	c5d2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
            }
            else
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    c5a2:	f001 fcdd 	bl	df60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) & ~(temp));
    c5a6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5aa:	4a0c      	ldr	r2, [pc, #48]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c5ac:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    c5b0:	9b04      	ldr	r3, [sp, #16]
    c5b2:	43da      	mvns	r2, r3
    c5b4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5b8:	400a      	ands	r2, r1
    c5ba:	4908      	ldr	r1, [pc, #32]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c5bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    c5c0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5c4:	4a05      	ldr	r2, [pc, #20]	; (c5dc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    c5c6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    c5ca:	9b03      	ldr	r3, [sp, #12]
    c5cc:	629a      	str	r2, [r3, #40]	; 0x28
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    c5ce:	f001 fcf3 	bl	dfb8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
            }
        }
#endif /* if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */

    return stat;
    c5d2:	9b05      	ldr	r3, [sp, #20]
}
    c5d4:	4618      	mov	r0, r3
    c5d6:	b007      	add	sp, #28
    c5d8:	f85d fb04 	ldr.w	pc, [sp], #4
    c5dc:	1fff8fc4 	.word	0x1fff8fc4

0000c5e0 <FLEXCAN_ClearMsgBuffIntCmd>:
void FLEXCAN_ClearMsgBuffIntCmd(FLEXCAN_Type * pBase,
                                uint8 u8Instance,
                                uint32 mb_idx,
                                boolean bIsIntActive
                               )
{
    c5e0:	b500      	push	{lr}
    c5e2:	b087      	sub	sp, #28
    c5e4:	9003      	str	r0, [sp, #12]
    c5e6:	9201      	str	r2, [sp, #4]
    c5e8:	461a      	mov	r2, r3
    c5ea:	460b      	mov	r3, r1
    c5ec:	f88d 300b 	strb.w	r3, [sp, #11]
    c5f0:	4613      	mov	r3, r2
    c5f2:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp = (1UL << (mb_idx % 32U));
    c5f6:	9b01      	ldr	r3, [sp, #4]
    c5f8:	f003 031f 	and.w	r3, r3, #31
    c5fc:	2201      	movs	r2, #1
    c5fe:	fa02 f303 	lsl.w	r3, r2, r3
    c602:	9305      	str	r3, [sp, #20]

 /* Stop the running transfer. */
    if (mb_idx < 32U)
    c604:	9b01      	ldr	r3, [sp, #4]
    c606:	2b1f      	cmp	r3, #31
    c608:	d818      	bhi.n	c63c <FLEXCAN_ClearMsgBuffIntCmd+0x5c>
    {
          /* Start critical section: implementation depends on integrator */
          SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    c60a:	f001 fa6b 	bl	dae4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
          FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = (pBase->IMASK1 & (~temp));
    c60e:	9b03      	ldr	r3, [sp, #12]
    c610:	6a99      	ldr	r1, [r3, #40]	; 0x28
    c612:	9b05      	ldr	r3, [sp, #20]
    c614:	43da      	mvns	r2, r3
    c616:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c61a:	400a      	ands	r2, r1
    c61c:	4909      	ldr	r1, [pc, #36]	; (c644 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    c61e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
          if (TRUE == bIsIntActive)
    c622:	f89d 300a 	ldrb.w	r3, [sp, #10]
    c626:	2b00      	cmp	r3, #0
    c628:	d006      	beq.n	c638 <FLEXCAN_ClearMsgBuffIntCmd+0x58>
          {
              pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    c62a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c62e:	4a05      	ldr	r2, [pc, #20]	; (c644 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    c630:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    c634:	9b03      	ldr	r3, [sp, #12]
    c636:	629a      	str	r2, [r3, #40]	; 0x28
          }
          /* End critical section: implementation depends on integrator */
          SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    c638:	f001 fa80 	bl	db3c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    }
#endif /* #if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */
}
    c63c:	bf00      	nop
    c63e:	b007      	add	sp, #28
    c640:	f85d fb04 	ldr.w	pc, [sp], #4
    c644:	1fff8fc4 	.word	0x1fff8fc4

0000c648 <FlexCAN_DisableInterrupts>:


void FlexCAN_DisableInterrupts(FLEXCAN_Type * pBase)
{
    c648:	b082      	sub	sp, #8
    c64a:	9001      	str	r0, [sp, #4]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = 0U;
    c64c:	9b01      	ldr	r3, [sp, #4]
    c64e:	2200      	movs	r2, #0
    c650:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = 0U;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    c652:	bf00      	nop
    c654:	b002      	add	sp, #8
    c656:	4770      	bx	lr

0000c658 <FlexCAN_EnableInterrupts>:

void FlexCAN_EnableInterrupts(FLEXCAN_Type * pBase, uint8 u8Instance)
{
    c658:	b082      	sub	sp, #8
    c65a:	9001      	str	r0, [sp, #4]
    c65c:	460b      	mov	r3, r1
    c65e:	f88d 3003 	strb.w	r3, [sp, #3]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    c662:	f89d 3003 	ldrb.w	r3, [sp, #3]
    c666:	4a04      	ldr	r2, [pc, #16]	; (c678 <FlexCAN_EnableInterrupts+0x20>)
    c668:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    c66c:	9b01      	ldr	r3, [sp, #4]
    c66e:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = FlexCAN_Ip_au32ImaskBuff[u8Instance][3U];
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    c670:	bf00      	nop
    c672:	b002      	add	sp, #8
    c674:	4770      	bx	lr
    c676:	bf00      	nop
    c678:	1fff8fc4 	.word	0x1fff8fc4

0000c67c <FlexCAN_SetRxMsgBuff>:
void FlexCAN_SetRxMsgBuff(const FLEXCAN_Type * base,
                          uint32 msgBuffIdx,
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId
                         )
{
    c67c:	b500      	push	{lr}
    c67e:	b087      	sub	sp, #28
    c680:	9003      	str	r0, [sp, #12]
    c682:	9102      	str	r1, [sp, #8]
    c684:	9201      	str	r2, [sp, #4]
    c686:	9300      	str	r3, [sp, #0]
    volatile uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    c688:	9902      	ldr	r1, [sp, #8]
    c68a:	9803      	ldr	r0, [sp, #12]
    c68c:	f7ff fbca 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    c690:	9005      	str	r0, [sp, #20]
    volatile uint32 * flexcan_mb_id = &flexcan_mb[1];
    c692:	9b05      	ldr	r3, [sp, #20]
    c694:	3304      	adds	r3, #4
    c696:	9304      	str	r3, [sp, #16]
    DevAssert(cs != NULL_PTR);
#endif


    /* Clean up the arbitration field area */
    *flexcan_mb = 0;
    c698:	9b05      	ldr	r3, [sp, #20]
    c69a:	2200      	movs	r2, #0
    c69c:	601a      	str	r2, [r3, #0]
    *flexcan_mb_id = 0;
    c69e:	9b04      	ldr	r3, [sp, #16]
    c6a0:	2200      	movs	r2, #0
    c6a2:	601a      	str	r2, [r3, #0]

    /* Set the ID according the format structure */
    if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    c6a4:	9b01      	ldr	r3, [sp, #4]
    c6a6:	685b      	ldr	r3, [r3, #4]
    c6a8:	2b01      	cmp	r3, #1
    c6aa:	d119      	bne.n	c6e0 <FlexCAN_SetRxMsgBuff+0x64>
    {
        /* Set IDE */
        *flexcan_mb |= FLEXCAN_IP_CS_IDE_MASK;
    c6ac:	9b05      	ldr	r3, [sp, #20]
    c6ae:	681b      	ldr	r3, [r3, #0]
    c6b0:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    c6b4:	9b05      	ldr	r3, [sp, #20]
    c6b6:	601a      	str	r2, [r3, #0]

        /* Clear SRR bit */
        *flexcan_mb &= ~FLEXCAN_IP_CS_SRR_MASK;
    c6b8:	9b05      	ldr	r3, [sp, #20]
    c6ba:	681b      	ldr	r3, [r3, #0]
    c6bc:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
    c6c0:	9b05      	ldr	r3, [sp, #20]
    c6c2:	601a      	str	r2, [r3, #0]

        /* ID [28-0] */
        *flexcan_mb_id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    c6c4:	9b04      	ldr	r3, [sp, #16]
    c6c6:	681b      	ldr	r3, [r3, #0]
    c6c8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    c6cc:	9b04      	ldr	r3, [sp, #16]
    c6ce:	601a      	str	r2, [r3, #0]
        *flexcan_mb_id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    c6d0:	9b04      	ldr	r3, [sp, #16]
    c6d2:	681a      	ldr	r2, [r3, #0]
    c6d4:	9b00      	ldr	r3, [sp, #0]
    c6d6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    c6da:	431a      	orrs	r2, r3
    c6dc:	9b04      	ldr	r3, [sp, #16]
    c6de:	601a      	str	r2, [r3, #0]
    }

    if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    c6e0:	9b01      	ldr	r3, [sp, #4]
    c6e2:	685b      	ldr	r3, [r3, #4]
    c6e4:	2b00      	cmp	r3, #0
    c6e6:	d116      	bne.n	c716 <FlexCAN_SetRxMsgBuff+0x9a>
    {
        /* Make sure IDE and SRR are not set */
        *flexcan_mb &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    c6e8:	9b05      	ldr	r3, [sp, #20]
    c6ea:	681b      	ldr	r3, [r3, #0]
    c6ec:	f423 02c0 	bic.w	r2, r3, #6291456	; 0x600000
    c6f0:	9b05      	ldr	r3, [sp, #20]
    c6f2:	601a      	str	r2, [r3, #0]

        /* ID[28-18] */
        *flexcan_mb_id &= ~FLEXCAN_IP_ID_STD_MASK;
    c6f4:	9b04      	ldr	r3, [sp, #16]
    c6f6:	681b      	ldr	r3, [r3, #0]
    c6f8:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    c6fc:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    c700:	9a04      	ldr	r2, [sp, #16]
    c702:	6013      	str	r3, [r2, #0]
        *flexcan_mb_id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    c704:	9b04      	ldr	r3, [sp, #16]
    c706:	681a      	ldr	r2, [r3, #0]
    c708:	9b00      	ldr	r3, [sp, #0]
    c70a:	0499      	lsls	r1, r3, #18
    c70c:	4b0e      	ldr	r3, [pc, #56]	; (c748 <FlexCAN_SetRxMsgBuff+0xcc>)
    c70e:	400b      	ands	r3, r1
    c710:	431a      	orrs	r2, r3
    c712:	9b04      	ldr	r3, [sp, #16]
    c714:	601a      	str	r2, [r3, #0]
    }

    /* Set MB CODE */
    if ((uint32)FLEXCAN_RX_NOT_USED != cs->code)
    c716:	9b01      	ldr	r3, [sp, #4]
    c718:	681b      	ldr	r3, [r3, #0]
    c71a:	2b0f      	cmp	r3, #15
    c71c:	d00f      	beq.n	c73e <FlexCAN_SetRxMsgBuff+0xc2>
    {
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    c71e:	9b05      	ldr	r3, [sp, #20]
    c720:	681b      	ldr	r3, [r3, #0]
    c722:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    c726:	9b05      	ldr	r3, [sp, #20]
    c728:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    c72a:	9b05      	ldr	r3, [sp, #20]
    c72c:	681a      	ldr	r2, [r3, #0]
    c72e:	9b01      	ldr	r3, [sp, #4]
    c730:	681b      	ldr	r3, [r3, #0]
    c732:	061b      	lsls	r3, r3, #24
    c734:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    c738:	431a      	orrs	r2, r3
    c73a:	9b05      	ldr	r3, [sp, #20]
    c73c:	601a      	str	r2, [r3, #0]
    }
}
    c73e:	bf00      	nop
    c740:	b007      	add	sp, #28
    c742:	f85d fb04 	ldr.w	pc, [sp], #4
    c746:	bf00      	nop
    c748:	1ffc0000 	.word	0x1ffc0000

0000c74c <FlexCAN_GetMsgBuffTimestamp>:
 * Function Name : FlexCAN_GetMsgBuffTimestamp
 * Description   : Get a message buffer timestamp value.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMsgBuffTimestamp(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    c74c:	b500      	push	{lr}
    c74e:	b085      	sub	sp, #20
    c750:	9001      	str	r0, [sp, #4]
    c752:	9100      	str	r1, [sp, #0]
    uint32 TimeStamp = 0U;
    c754:	2300      	movs	r3, #0
    c756:	9303      	str	r3, [sp, #12]
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    c758:	9900      	ldr	r1, [sp, #0]
    c75a:	9801      	ldr	r0, [sp, #4]
    c75c:	f7ff fb62 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    c760:	9002      	str	r0, [sp, #8]
        TimeStamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        TimeStamp = (uint32)((*Flexcan_Mb & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    c762:	9b02      	ldr	r3, [sp, #8]
    c764:	681b      	ldr	r3, [r3, #0]
    c766:	b29b      	uxth	r3, r3
    c768:	9303      	str	r3, [sp, #12]
    }
    return TimeStamp;
    c76a:	9b03      	ldr	r3, [sp, #12]
}
    c76c:	4618      	mov	r0, r3
    c76e:	b005      	add	sp, #20
    c770:	f85d fb04 	ldr.w	pc, [sp], #4

0000c774 <FlexCAN_GetMsgBuff>:
 *END**************************************************************************/
void FlexCAN_GetMsgBuff(const FLEXCAN_Type * base,
                        uint32 msgBuffIdx,
                        Flexcan_Ip_MsgBuffType * msgBuff
                       )
{
    c774:	b500      	push	{lr}
    c776:	b08d      	sub	sp, #52	; 0x34
    c778:	9003      	str	r0, [sp, #12]
    c77a:	9102      	str	r1, [sp, #8]
    c77c:	9201      	str	r2, [sp, #4]

    uint8 i;
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    c77e:	9902      	ldr	r1, [sp, #8]
    c780:	9803      	ldr	r0, [sp, #12]
    c782:	f7ff fb4f 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    c786:	900a      	str	r0, [sp, #40]	; 0x28
    volatile const uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    c788:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c78a:	3304      	adds	r3, #4
    c78c:	9309      	str	r3, [sp, #36]	; 0x24
    volatile const uint8 * Flexcan_Mb_Data = (volatile const uint8 *)(&Flexcan_Mb[2]);
    c78e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c790:	3308      	adds	r3, #8
    c792:	9308      	str	r3, [sp, #32]
    volatile const uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    c794:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c796:	3308      	adds	r3, #8
    c798:	9307      	str	r3, [sp, #28]
    uint32 * MsgBuff_Data_32 = NULL_PTR;
    c79a:	2300      	movs	r3, #0
    c79c:	9306      	str	r3, [sp, #24]
    uint32 MbWord;

    uint8 Flexcan_Mb_Dlc_Value = (uint8)(((*Flexcan_Mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    c79e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c7a0:	681b      	ldr	r3, [r3, #0]
    c7a2:	0c1b      	lsrs	r3, r3, #16
    c7a4:	b2db      	uxtb	r3, r3
    c7a6:	f003 030f 	and.w	r3, r3, #15
    c7aa:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Payload_Size = FlexCAN_ComputePayloadSize(Flexcan_Mb_Dlc_Value);
    c7ae:	f89d 3017 	ldrb.w	r3, [sp, #23]
    c7b2:	4618      	mov	r0, r3
    c7b4:	f7ff faed 	bl	bd92 <FlexCAN_ComputePayloadSize>
    c7b8:	4603      	mov	r3, r0
    c7ba:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(msgBuff != NULL_PTR);
#endif
    /* Asign after NULL Check */
    MsgBuff_Data_32 = (uint32 *)(msgBuff->data);
    c7be:	9b01      	ldr	r3, [sp, #4]
    c7c0:	3308      	adds	r3, #8
    c7c2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    /* Payload Size is based on MBDSR for 1 MBDSR corresponds 32 * 8Bytes MBs  */
    if (Payload_Size > FlexCAN_GetMbPayloadSize(base, msgBuffIdx))
    c7c4:	9902      	ldr	r1, [sp, #8]
    c7c6:	9803      	ldr	r0, [sp, #12]
    c7c8:	f7ff fe5a 	bl	c480 <FlexCAN_GetMbPayloadSize>
    c7cc:	4603      	mov	r3, r0
    c7ce:	461a      	mov	r2, r3
    c7d0:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    c7d4:	4293      	cmp	r3, r2
    c7d6:	d906      	bls.n	c7e6 <FlexCAN_GetMsgBuff+0x72>
    {
        Payload_Size = FlexCAN_GetMbPayloadSize(base, msgBuffIdx);
    c7d8:	9902      	ldr	r1, [sp, #8]
    c7da:	9803      	ldr	r0, [sp, #12]
    c7dc:	f7ff fe50 	bl	c480 <FlexCAN_GetMbPayloadSize>
    c7e0:	4603      	mov	r3, r0
    c7e2:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    msgBuff->dataLen = Payload_Size;
    c7e6:	9b01      	ldr	r3, [sp, #4]
    c7e8:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    c7ec:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Get a MB field values */
    msgBuff->cs = *Flexcan_Mb;
    c7f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c7f2:	681a      	ldr	r2, [r3, #0]
    c7f4:	9b01      	ldr	r3, [sp, #4]
    c7f6:	601a      	str	r2, [r3, #0]
    if ((msgBuff->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    c7f8:	9b01      	ldr	r3, [sp, #4]
    c7fa:	681b      	ldr	r3, [r3, #0]
    c7fc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    c800:	2b00      	cmp	r3, #0
    c802:	d004      	beq.n	c80e <FlexCAN_GetMsgBuff+0x9a>
    {
        msgBuff->msgId = (*Flexcan_Mb_Id);
    c804:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c806:	681a      	ldr	r2, [r3, #0]
    c808:	9b01      	ldr	r3, [sp, #4]
    c80a:	605a      	str	r2, [r3, #4]
    c80c:	e004      	b.n	c818 <FlexCAN_GetMsgBuff+0xa4>
    }
    else
    {
        msgBuff->msgId = (*Flexcan_Mb_Id) >> FLEXCAN_IP_ID_STD_SHIFT;
    c80e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c810:	681b      	ldr	r3, [r3, #0]
    c812:	0c9a      	lsrs	r2, r3, #18
    c814:	9b01      	ldr	r3, [sp, #4]
    c816:	605a      	str	r2, [r3, #4]
        msgBuff->time_stamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        msgBuff->time_stamp = (uint32)((msgBuff->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    c818:	9b01      	ldr	r3, [sp, #4]
    c81a:	681b      	ldr	r3, [r3, #0]
    c81c:	b29a      	uxth	r2, r3
    c81e:	9b01      	ldr	r3, [sp, #4]
    c820:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, MsgBuff_Data_32[i >> 2U]);
        }
    }

#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    c822:	2300      	movs	r3, #0
    c824:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    c828:	e025      	b.n	c876 <FlexCAN_GetMsgBuff+0x102>
    {
        MbWord = Flexcan_Mb_Data_32[i >> 2U];
    c82a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c82e:	089b      	lsrs	r3, r3, #2
    c830:	b2db      	uxtb	r3, r3
    c832:	009b      	lsls	r3, r3, #2
    c834:	9a07      	ldr	r2, [sp, #28]
    c836:	4413      	add	r3, r2
    c838:	681b      	ldr	r3, [r3, #0]
    c83a:	9304      	str	r3, [sp, #16]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (MsgBuff_Data_32[i >> 2U]));
    c83c:	9b04      	ldr	r3, [sp, #16]
    c83e:	0e1a      	lsrs	r2, r3, #24
    c840:	9b04      	ldr	r3, [sp, #16]
    c842:	0a1b      	lsrs	r3, r3, #8
    c844:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    c848:	431a      	orrs	r2, r3
    c84a:	9b04      	ldr	r3, [sp, #16]
    c84c:	021b      	lsls	r3, r3, #8
    c84e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    c852:	ea42 0103 	orr.w	r1, r2, r3
    c856:	9b04      	ldr	r3, [sp, #16]
    c858:	061a      	lsls	r2, r3, #24
    c85a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c85e:	089b      	lsrs	r3, r3, #2
    c860:	b2db      	uxtb	r3, r3
    c862:	009b      	lsls	r3, r3, #2
    c864:	9806      	ldr	r0, [sp, #24]
    c866:	4403      	add	r3, r0
    c868:	430a      	orrs	r2, r1
    c86a:	601a      	str	r2, [r3, #0]
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    c86c:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c870:	3304      	adds	r3, #4
    c872:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    c876:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    c87a:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    c87e:	f023 0303 	bic.w	r3, r3, #3
    c882:	429a      	cmp	r2, r3
    c884:	d3d1      	bcc.n	c82a <FlexCAN_GetMsgBuff+0xb6>
    }

#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (; i < Payload_Size; i++)
    c886:	e014      	b.n	c8b2 <FlexCAN_GetMsgBuff+0x13e>
    {   /* Max allowed value for index is 63 */
        msgBuff->data[i] = Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(i)];
    c888:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c88c:	f083 0303 	eor.w	r3, r3, #3
    c890:	b2db      	uxtb	r3, r3
    c892:	461a      	mov	r2, r3
    c894:	9b08      	ldr	r3, [sp, #32]
    c896:	441a      	add	r2, r3
    c898:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c89c:	7812      	ldrb	r2, [r2, #0]
    c89e:	b2d1      	uxtb	r1, r2
    c8a0:	9a01      	ldr	r2, [sp, #4]
    c8a2:	4413      	add	r3, r2
    c8a4:	460a      	mov	r2, r1
    c8a6:	721a      	strb	r2, [r3, #8]
    for (; i < Payload_Size; i++)
    c8a8:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    c8ac:	3301      	adds	r3, #1
    c8ae:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    c8b2:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    c8b6:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    c8ba:	429a      	cmp	r2, r3
    c8bc:	d3e4      	bcc.n	c888 <FlexCAN_GetMsgBuff+0x114>
    }
}
    c8be:	bf00      	nop
    c8c0:	bf00      	nop
    c8c2:	b00d      	add	sp, #52	; 0x34
    c8c4:	f85d fb04 	ldr.w	pc, [sp], #4

0000c8c8 <FlexCAN_SetTxMsgBuff>:
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId,
                          const uint8 * msgData,
                          const boolean isRemote
                         )
{
    c8c8:	b500      	push	{lr}
    c8ca:	b08d      	sub	sp, #52	; 0x34
    c8cc:	9003      	str	r0, [sp, #12]
    c8ce:	9102      	str	r1, [sp, #8]
    c8d0:	9201      	str	r2, [sp, #4]
    c8d2:	9300      	str	r3, [sp, #0]
    uint32 Flexcan_Mb_Config = 0;
    c8d4:	2300      	movs	r3, #0
    c8d6:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 DataByte;
    uint8 Dlc_Value;
    uint8 Payload_Size;
    volatile uint32 * Flexcan_Mb = pMbAddr;
    c8d8:	9b03      	ldr	r3, [sp, #12]
    c8da:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    c8dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c8de:	3304      	adds	r3, #4
    c8e0:	9308      	str	r3, [sp, #32]
    volatile uint8 * Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    c8e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c8e4:	3308      	adds	r3, #8
    c8e6:	9307      	str	r3, [sp, #28]
    volatile uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    c8e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c8ea:	3308      	adds	r3, #8
    c8ec:	9306      	str	r3, [sp, #24]
    const uint32 * MsgData_32 = (const uint32*)msgData;
    c8ee:	9b00      	ldr	r3, [sp, #0]
    c8f0:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(cs != NULL_PTR);
    #endif

        /* Clean up the arbitration field area and set TxMB Inactive */
        *Flexcan_Mb = (uint32)((((uint32)FLEXCAN_TX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    c8f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c8f4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    c8f8:	601a      	str	r2, [r3, #0]
        *Flexcan_Mb_Id = 0;
    c8fa:	9b08      	ldr	r3, [sp, #32]
    c8fc:	2200      	movs	r2, #0
    c8fe:	601a      	str	r2, [r3, #0]

        /* Compute the value of the DLC field */
        Dlc_Value = FlexCAN_ComputeDLCValue((uint8)cs->dataLen);
    c900:	9b02      	ldr	r3, [sp, #8]
    c902:	689b      	ldr	r3, [r3, #8]
    c904:	b2db      	uxtb	r3, r3
    c906:	4618      	mov	r0, r3
    c908:	f7ff f9f4 	bl	bcf4 <FlexCAN_ComputeDLCValue>
    c90c:	4603      	mov	r3, r0
    c90e:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Copy user's buffer into the message buffer data area */
        if (msgData != NULL_PTR)
    c912:	9b00      	ldr	r3, [sp, #0]
    c914:	2b00      	cmp	r3, #0
    c916:	d065      	beq.n	c9e4 <FlexCAN_SetTxMsgBuff+0x11c>
        {
#if (defined(S32K116) || defined (S32K118))
            (void)MsgData_32;
            DataByte = FlexCAN_DataTransferTxMsgBuff(Flexcan_Mb_Data_32, cs, msgData);
#else
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    c918:	2300      	movs	r3, #0
    c91a:	930a      	str	r3, [sp, #40]	; 0x28
    c91c:	e02c      	b.n	c978 <FlexCAN_SetTxMsgBuff+0xb0>
            {
                FLEXCAN_IP_SWAP_BYTES_IN_WORD((MsgData_32[DataByte >> 2U]), (Flexcan_Mb_Data_32[DataByte >> 2U]));
    c91e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c920:	089b      	lsrs	r3, r3, #2
    c922:	009b      	lsls	r3, r3, #2
    c924:	9a05      	ldr	r2, [sp, #20]
    c926:	4413      	add	r3, r2
    c928:	681b      	ldr	r3, [r3, #0]
    c92a:	0e1a      	lsrs	r2, r3, #24
    c92c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c92e:	089b      	lsrs	r3, r3, #2
    c930:	009b      	lsls	r3, r3, #2
    c932:	9905      	ldr	r1, [sp, #20]
    c934:	440b      	add	r3, r1
    c936:	681b      	ldr	r3, [r3, #0]
    c938:	0a1b      	lsrs	r3, r3, #8
    c93a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    c93e:	431a      	orrs	r2, r3
    c940:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c942:	089b      	lsrs	r3, r3, #2
    c944:	009b      	lsls	r3, r3, #2
    c946:	9905      	ldr	r1, [sp, #20]
    c948:	440b      	add	r3, r1
    c94a:	681b      	ldr	r3, [r3, #0]
    c94c:	021b      	lsls	r3, r3, #8
    c94e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    c952:	ea42 0103 	orr.w	r1, r2, r3
    c956:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c958:	089b      	lsrs	r3, r3, #2
    c95a:	009b      	lsls	r3, r3, #2
    c95c:	9a05      	ldr	r2, [sp, #20]
    c95e:	4413      	add	r3, r2
    c960:	681b      	ldr	r3, [r3, #0]
    c962:	061a      	lsls	r2, r3, #24
    c964:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c966:	089b      	lsrs	r3, r3, #2
    c968:	009b      	lsls	r3, r3, #2
    c96a:	9806      	ldr	r0, [sp, #24]
    c96c:	4403      	add	r3, r0
    c96e:	430a      	orrs	r2, r1
    c970:	601a      	str	r2, [r3, #0]
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    c972:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c974:	3304      	adds	r3, #4
    c976:	930a      	str	r3, [sp, #40]	; 0x28
    c978:	9b02      	ldr	r3, [sp, #8]
    c97a:	689b      	ldr	r3, [r3, #8]
    c97c:	f023 0303 	bic.w	r3, r3, #3
    c980:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c982:	429a      	cmp	r2, r3
    c984:	d3cb      	bcc.n	c91e <FlexCAN_SetTxMsgBuff+0x56>
            }
#endif /* (defined(S32K116) || defined (S32K118)) */
            for ( ; DataByte < cs->dataLen; DataByte++)
    c986:	e00c      	b.n	c9a2 <FlexCAN_SetTxMsgBuff+0xda>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] =  msgData[DataByte];
    c988:	9a00      	ldr	r2, [sp, #0]
    c98a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c98c:	441a      	add	r2, r3
    c98e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c990:	f083 0303 	eor.w	r3, r3, #3
    c994:	9907      	ldr	r1, [sp, #28]
    c996:	440b      	add	r3, r1
    c998:	7812      	ldrb	r2, [r2, #0]
    c99a:	701a      	strb	r2, [r3, #0]
            for ( ; DataByte < cs->dataLen; DataByte++)
    c99c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c99e:	3301      	adds	r3, #1
    c9a0:	930a      	str	r3, [sp, #40]	; 0x28
    c9a2:	9b02      	ldr	r3, [sp, #8]
    c9a4:	689b      	ldr	r3, [r3, #8]
    c9a6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c9a8:	429a      	cmp	r2, r3
    c9aa:	d3ed      	bcc.n	c988 <FlexCAN_SetTxMsgBuff+0xc0>
            }
        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            Payload_Size = FlexCAN_ComputePayloadSize(Dlc_Value);
    c9ac:	f89d 3013 	ldrb.w	r3, [sp, #19]
    c9b0:	4618      	mov	r0, r3
    c9b2:	f7ff f9ee 	bl	bd92 <FlexCAN_ComputePayloadSize>
    c9b6:	4603      	mov	r3, r0
    c9b8:	f88d 3012 	strb.w	r3, [sp, #18]
            /* Add padding, if needed */
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    c9bc:	9b02      	ldr	r3, [sp, #8]
    c9be:	689b      	ldr	r3, [r3, #8]
    c9c0:	930a      	str	r3, [sp, #40]	; 0x28
    c9c2:	e00a      	b.n	c9da <FlexCAN_SetTxMsgBuff+0x112>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] = cs->fd_padding;
    c9c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c9c6:	f083 0303 	eor.w	r3, r3, #3
    c9ca:	9a07      	ldr	r2, [sp, #28]
    c9cc:	4413      	add	r3, r2
    c9ce:	9a02      	ldr	r2, [sp, #8]
    c9d0:	7b52      	ldrb	r2, [r2, #13]
    c9d2:	701a      	strb	r2, [r3, #0]
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    c9d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c9d6:	3301      	adds	r3, #1
    c9d8:	930a      	str	r3, [sp, #40]	; 0x28
    c9da:	f89d 3012 	ldrb.w	r3, [sp, #18]
    c9de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c9e0:	429a      	cmp	r2, r3
    c9e2:	d3ef      	bcc.n	c9c4 <FlexCAN_SetTxMsgBuff+0xfc>
            }
        #endif /* FLEXCAN_IP_FEATURE_HAS_FD */
        }
        /* Set the ID according the format structure */
        if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    c9e4:	9b02      	ldr	r3, [sp, #8]
    c9e6:	685b      	ldr	r3, [r3, #4]
    c9e8:	2b01      	cmp	r3, #1
    c9ea:	d111      	bne.n	ca10 <FlexCAN_SetTxMsgBuff+0x148>
        {
            /* ID [28-0] */
            *Flexcan_Mb_Id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    c9ec:	9b08      	ldr	r3, [sp, #32]
    c9ee:	681b      	ldr	r3, [r3, #0]
    c9f0:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    c9f4:	9b08      	ldr	r3, [sp, #32]
    c9f6:	601a      	str	r2, [r3, #0]
            *Flexcan_Mb_Id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    c9f8:	9b08      	ldr	r3, [sp, #32]
    c9fa:	681a      	ldr	r2, [r3, #0]
    c9fc:	9b01      	ldr	r3, [sp, #4]
    c9fe:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    ca02:	431a      	orrs	r2, r3
    ca04:	9b08      	ldr	r3, [sp, #32]
    ca06:	601a      	str	r2, [r3, #0]
            /* Set IDE and SRR bit*/
            Flexcan_Mb_Config |= (FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    ca08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca0a:	f443 03c0 	orr.w	r3, r3, #6291456	; 0x600000
    ca0e:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    ca10:	9b02      	ldr	r3, [sp, #8]
    ca12:	685b      	ldr	r3, [r3, #4]
    ca14:	2b00      	cmp	r3, #0
    ca16:	d114      	bne.n	ca42 <FlexCAN_SetTxMsgBuff+0x17a>
        {
            /* ID[28-18] */
            *Flexcan_Mb_Id &= ~FLEXCAN_IP_ID_STD_MASK;
    ca18:	9b08      	ldr	r3, [sp, #32]
    ca1a:	681b      	ldr	r3, [r3, #0]
    ca1c:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    ca20:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    ca24:	9a08      	ldr	r2, [sp, #32]
    ca26:	6013      	str	r3, [r2, #0]
            *Flexcan_Mb_Id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    ca28:	9b08      	ldr	r3, [sp, #32]
    ca2a:	681a      	ldr	r2, [r3, #0]
    ca2c:	9b01      	ldr	r3, [sp, #4]
    ca2e:	0499      	lsls	r1, r3, #18
    ca30:	4b2b      	ldr	r3, [pc, #172]	; (cae0 <FlexCAN_SetTxMsgBuff+0x218>)
    ca32:	400b      	ands	r3, r1
    ca34:	431a      	orrs	r2, r3
    ca36:	9b08      	ldr	r3, [sp, #32]
    ca38:	601a      	str	r2, [r3, #0]
            /* make sure IDE and SRR are not set */
            Flexcan_Mb_Config &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    ca3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca3c:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
    ca40:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        /* Set the length of data in bytes */
        Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_DLC_MASK;
    ca42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca44:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    ca48:	930b      	str	r3, [sp, #44]	; 0x2c
        Flexcan_Mb_Config |= ((uint32)Dlc_Value << FLEXCAN_IP_CS_DLC_SHIFT) & FLEXCAN_IP_CS_DLC_MASK;
    ca4a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    ca4e:	041b      	lsls	r3, r3, #16
    ca50:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    ca54:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ca56:	4313      	orrs	r3, r2
    ca58:	930b      	str	r3, [sp, #44]	; 0x2c
        /* Set MB CODE */
        if (cs->code != (uint32)FLEXCAN_TX_NOT_USED)
    ca5a:	9b02      	ldr	r3, [sp, #8]
    ca5c:	681b      	ldr	r3, [r3, #0]
    ca5e:	2b0f      	cmp	r3, #15
    ca60:	d03a      	beq.n	cad8 <FlexCAN_SetTxMsgBuff+0x210>
        {
            if ((uint32)FLEXCAN_TX_REMOTE == cs->code)
    ca62:	9b02      	ldr	r3, [sp, #8]
    ca64:	681b      	ldr	r3, [r3, #0]
    ca66:	2b1c      	cmp	r3, #28
    ca68:	d104      	bne.n	ca74 <FlexCAN_SetTxMsgBuff+0x1ac>
            {
                /* Set RTR bit */
                Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    ca6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca6c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    ca70:	930b      	str	r3, [sp, #44]	; 0x2c
    ca72:	e007      	b.n	ca84 <FlexCAN_SetTxMsgBuff+0x1bc>
            }
            else
            {
                if (TRUE == isRemote)
    ca74:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    ca78:	2b00      	cmp	r3, #0
    ca7a:	d003      	beq.n	ca84 <FlexCAN_SetTxMsgBuff+0x1bc>
                {
                    /* Set RTR bit */
                    Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    ca7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca7e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    ca82:	930b      	str	r3, [sp, #44]	; 0x2c
                }
            }
            /* Reset the code */
            Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_CODE_MASK;
    ca84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ca86:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    ca8a:	930b      	str	r3, [sp, #44]	; 0x2c
            /* Set the code */
            if (cs->fd_enable)
    ca8c:	9b02      	ldr	r3, [sp, #8]
    ca8e:	7b1b      	ldrb	r3, [r3, #12]
    ca90:	2b00      	cmp	r3, #0
    ca92:	d00e      	beq.n	cab2 <FlexCAN_SetTxMsgBuff+0x1ea>
            {
                Flexcan_Mb_Config |= ((cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK) | FLEXCAN_IP_MB_EDL_MASK;
    ca94:	9b02      	ldr	r3, [sp, #8]
    ca96:	681b      	ldr	r3, [r3, #0]
    ca98:	061b      	lsls	r3, r3, #24
    ca9a:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    ca9e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    caa0:	4313      	orrs	r3, r2
    caa2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    caa6:	930b      	str	r3, [sp, #44]	; 0x2c
                /* In case of FD frame not supported RTR */
                Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_RTR_MASK;
    caa8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    caaa:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    caae:	930b      	str	r3, [sp, #44]	; 0x2c
    cab0:	e007      	b.n	cac2 <FlexCAN_SetTxMsgBuff+0x1fa>
            }
            else
            {
                Flexcan_Mb_Config |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    cab2:	9b02      	ldr	r3, [sp, #8]
    cab4:	681b      	ldr	r3, [r3, #0]
    cab6:	061b      	lsls	r3, r3, #24
    cab8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    cabc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cabe:	4313      	orrs	r3, r2
    cac0:	930b      	str	r3, [sp, #44]	; 0x2c
            }

            if (cs->enable_brs)
    cac2:	9b02      	ldr	r3, [sp, #8]
    cac4:	7b9b      	ldrb	r3, [r3, #14]
    cac6:	2b00      	cmp	r3, #0
    cac8:	d003      	beq.n	cad2 <FlexCAN_SetTxMsgBuff+0x20a>
            {
                Flexcan_Mb_Config |= FLEXCAN_IP_MB_BRS_MASK;
    caca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cacc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    cad0:	930b      	str	r3, [sp, #44]	; 0x2c
            }
            *Flexcan_Mb = Flexcan_Mb_Config;
    cad2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cad4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cad6:	601a      	str	r2, [r3, #0]
        }
}
    cad8:	bf00      	nop
    cada:	b00d      	add	sp, #52	; 0x34
    cadc:	f85d fb04 	ldr.w	pc, [sp], #4
    cae0:	1ffc0000 	.word	0x1ffc0000

0000cae4 <FlexCAN_SetMaxMsgBuffNum>:
 * Description   : Set the number of the last Message Buffers.
 * This function will define the number of the last Message Buffers
 *
 *END***************************************************************************/
Flexcan_Ip_StatusType FlexCAN_SetMaxMsgBuffNum(FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    cae4:	b500      	push	{lr}
    cae6:	b08f      	sub	sp, #60	; 0x3c
    cae8:	9001      	str	r0, [sp, #4]
    caea:	9100      	str	r1, [sp, #0]
    uint32 MsgBuffIdx;
    uint32 DataByte;
    const volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    caec:	9b01      	ldr	r3, [sp, #4]
    caee:	3380      	adds	r3, #128	; 0x80
    caf0:	930a      	str	r3, [sp, #40]	; 0x28
#if (STD_ON == FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY)
    const volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */
    const volatile uint32 * ValEndMbPointer = NULL_PTR;
    caf2:	2300      	movs	r3, #0
    caf4:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 *Flexcan_Mb = NULL_PTR;
    caf6:	2300      	movs	r3, #0
    caf8:	9308      	str	r3, [sp, #32]
    volatile uint32 *Flexcan_Mb_Id   = NULL_PTR ;
    cafa:	2300      	movs	r3, #0
    cafc:	9307      	str	r3, [sp, #28]
    volatile uint8  *Flexcan_Mb_Data = NULL_PTR;
    cafe:	2300      	movs	r3, #0
    cb00:	9306      	str	r3, [sp, #24]
    uint8 Arbitration_Field_Size = 8U;
    cb02:	2308      	movs	r3, #8
    cb04:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, maxMsgBuffNum - (uint32)1U);
    cb08:	9b00      	ldr	r3, [sp, #0]
    cb0a:	3b01      	subs	r3, #1
    cb0c:	4619      	mov	r1, r3
    cb0e:	9801      	ldr	r0, [sp, #4]
    cb10:	f7ff fcb6 	bl	c480 <FlexCAN_GetMbPayloadSize>
    cb14:	4603      	mov	r3, r0
    cb16:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_PtrSizeType ValEndMb = 0U;
    cb1a:	2300      	movs	r3, #0
    cb1c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_PtrSizeType ValEndRam = 0U;
    cb1e:	2300      	movs	r3, #0
    cb20:	9303      	str	r3, [sp, #12]
    Flexcan_Ip_StatusType Status = FLEXCAN_STATUS_SUCCESS;
    cb22:	2300      	movs	r3, #0
    cb24:	930b      	str	r3, [sp, #44]	; 0x2c

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(maxMsgBuffNum>0U);
    #endif

    ValEndMbPointer = FlexCAN_GetMsgBuffRegion(base, (maxMsgBuffNum - (uint32)1U));
    cb26:	9b00      	ldr	r3, [sp, #0]
    cb28:	3b01      	subs	r3, #1
    cb2a:	4619      	mov	r1, r3
    cb2c:	9801      	ldr	r0, [sp, #4]
    cb2e:	f7ff f979 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    cb32:	9009      	str	r0, [sp, #36]	; 0x24

    ValEndMb = (Flexcan_Ip_PtrSizeType)ValEndMbPointer + Can_Real_Payload + Arbitration_Field_Size;
    cb34:	f89d 2016 	ldrb.w	r2, [sp, #22]
    cb38:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cb3a:	441a      	add	r2, r3
    cb3c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    cb40:	4413      	add	r3, r2
    cb42:	9304      	str	r3, [sp, #16]
    else
    {
        ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    }
#else
    ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    cb44:	9801      	ldr	r0, [sp, #4]
    cb46:	f7ff f9e7 	bl	bf18 <FlexCAN_GetMaxMbNum>
    cb4a:	4603      	mov	r3, r0
    cb4c:	011b      	lsls	r3, r3, #4
    cb4e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    cb50:	4413      	add	r3, r2
    cb52:	9303      	str	r3, [sp, #12]
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */

    if ((ValEndMb > ValEndRam) || (maxMsgBuffNum > FlexCAN_GetMaxMbNum(base)))
    cb54:	9a04      	ldr	r2, [sp, #16]
    cb56:	9b03      	ldr	r3, [sp, #12]
    cb58:	429a      	cmp	r2, r3
    cb5a:	d806      	bhi.n	cb6a <FlexCAN_SetMaxMsgBuffNum+0x86>
    cb5c:	9801      	ldr	r0, [sp, #4]
    cb5e:	f7ff f9db 	bl	bf18 <FlexCAN_GetMaxMbNum>
    cb62:	4602      	mov	r2, r0
    cb64:	9b00      	ldr	r3, [sp, #0]
    cb66:	4293      	cmp	r3, r2
    cb68:	d901      	bls.n	cb6e <FlexCAN_SetMaxMsgBuffNum+0x8a>
    {
        Status = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    cb6a:	2304      	movs	r3, #4
    cb6c:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    if (FLEXCAN_STATUS_SUCCESS == Status)
    cb6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cb70:	2b00      	cmp	r3, #0
    cb72:	d142      	bne.n	cbfa <FlexCAN_SetMaxMsgBuffNum+0x116>
    {
        /* Set the maximum number of MBs*/
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MAXMB_MASK) | (((maxMsgBuffNum-1U) << FLEXCAN_MCR_MAXMB_SHIFT) & FLEXCAN_MCR_MAXMB_MASK);
    cb74:	9b01      	ldr	r3, [sp, #4]
    cb76:	681b      	ldr	r3, [r3, #0]
    cb78:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
    cb7c:	9b00      	ldr	r3, [sp, #0]
    cb7e:	3b01      	subs	r3, #1
    cb80:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    cb84:	431a      	orrs	r2, r3
    cb86:	9b01      	ldr	r3, [sp, #4]
    cb88:	601a      	str	r2, [r3, #0]
        if (!(((base->MCR & FLEXCAN_MCR_RFEN_MASK) >> FLEXCAN_MCR_RFEN_SHIFT) != 0U))
    cb8a:	9b01      	ldr	r3, [sp, #4]
    cb8c:	681b      	ldr	r3, [r3, #0]
    cb8e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
    cb92:	2b00      	cmp	r3, #0
    cb94:	d131      	bne.n	cbfa <FlexCAN_SetMaxMsgBuffNum+0x116>
        {
            /* Initialize all message buffers as inactive */
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    cb96:	2300      	movs	r3, #0
    cb98:	930d      	str	r3, [sp, #52]	; 0x34
    cb9a:	e02a      	b.n	cbf2 <FlexCAN_SetMaxMsgBuffNum+0x10e>
            {
                Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, MsgBuffIdx);
    cb9c:	990d      	ldr	r1, [sp, #52]	; 0x34
    cb9e:	9801      	ldr	r0, [sp, #4]
    cba0:	f7ff f940 	bl	be24 <FlexCAN_GetMsgBuffRegion>
    cba4:	9008      	str	r0, [sp, #32]
                Flexcan_Mb_Id   = &Flexcan_Mb[1];
    cba6:	9b08      	ldr	r3, [sp, #32]
    cba8:	3304      	adds	r3, #4
    cbaa:	9307      	str	r3, [sp, #28]
                Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    cbac:	9b08      	ldr	r3, [sp, #32]
    cbae:	3308      	adds	r3, #8
    cbb0:	9306      	str	r3, [sp, #24]
                *Flexcan_Mb = 0x0U;
    cbb2:	9b08      	ldr	r3, [sp, #32]
    cbb4:	2200      	movs	r2, #0
    cbb6:	601a      	str	r2, [r3, #0]
                *Flexcan_Mb_Id = 0x0U;
    cbb8:	9b07      	ldr	r3, [sp, #28]
    cbba:	2200      	movs	r2, #0
    cbbc:	601a      	str	r2, [r3, #0]
                Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, MsgBuffIdx);
    cbbe:	990d      	ldr	r1, [sp, #52]	; 0x34
    cbc0:	9801      	ldr	r0, [sp, #4]
    cbc2:	f7ff fc5d 	bl	c480 <FlexCAN_GetMbPayloadSize>
    cbc6:	4603      	mov	r3, r0
    cbc8:	f88d 3016 	strb.w	r3, [sp, #22]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    cbcc:	2300      	movs	r3, #0
    cbce:	930c      	str	r3, [sp, #48]	; 0x30
    cbd0:	e007      	b.n	cbe2 <FlexCAN_SetMaxMsgBuffNum+0xfe>
                {
                   Flexcan_Mb_Data[DataByte] = 0x0U;
    cbd2:	9a06      	ldr	r2, [sp, #24]
    cbd4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    cbd6:	4413      	add	r3, r2
    cbd8:	2200      	movs	r2, #0
    cbda:	701a      	strb	r2, [r3, #0]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    cbdc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    cbde:	3301      	adds	r3, #1
    cbe0:	930c      	str	r3, [sp, #48]	; 0x30
    cbe2:	f89d 3016 	ldrb.w	r3, [sp, #22]
    cbe6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    cbe8:	429a      	cmp	r2, r3
    cbea:	d3f2      	bcc.n	cbd2 <FlexCAN_SetMaxMsgBuffNum+0xee>
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    cbec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    cbee:	3301      	adds	r3, #1
    cbf0:	930d      	str	r3, [sp, #52]	; 0x34
    cbf2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    cbf4:	9b00      	ldr	r3, [sp, #0]
    cbf6:	429a      	cmp	r2, r3
    cbf8:	d3d0      	bcc.n	cb9c <FlexCAN_SetMaxMsgBuffNum+0xb8>
                }
            }
        }
    }
    return Status;
    cbfa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    cbfc:	4618      	mov	r0, r3
    cbfe:	b00f      	add	sp, #60	; 0x3c
    cc00:	f85d fb04 	ldr.w	pc, [sp], #4

0000cc04 <FlexCAN_SetOperationMode>:
 * Description   : Enable a FlexCAN operation mode.
 * This function will enable one of the modes listed in flexcan_operation_modes_t.
 *
 *END**************************************************************************/
void FlexCAN_SetOperationMode(FLEXCAN_Type * base, Flexcan_Ip_ModesType mode)
{
    cc04:	b500      	push	{lr}
    cc06:	b083      	sub	sp, #12
    cc08:	9001      	str	r0, [sp, #4]
    cc0a:	9100      	str	r1, [sp, #0]
    switch (mode)
    cc0c:	9b00      	ldr	r3, [sp, #0]
    cc0e:	2b02      	cmp	r3, #2
    cc10:	d01d      	beq.n	cc4e <FlexCAN_SetOperationMode+0x4a>
    cc12:	9b00      	ldr	r3, [sp, #0]
    cc14:	2b02      	cmp	r3, #2
    cc16:	d82b      	bhi.n	cc70 <FlexCAN_SetOperationMode+0x6c>
    cc18:	9b00      	ldr	r3, [sp, #0]
    cc1a:	2b00      	cmp	r3, #0
    cc1c:	d003      	beq.n	cc26 <FlexCAN_SetOperationMode+0x22>
    cc1e:	9b00      	ldr	r3, [sp, #0]
    cc20:	2b01      	cmp	r3, #1
    cc22:	d00d      	beq.n	cc40 <FlexCAN_SetOperationMode+0x3c>
            /* Enable Self Reception */
            FlexCAN_SetSelfReception(base, TRUE);
            break;
        default:
            /* Should not get here */
            break;
    cc24:	e024      	b.n	cc70 <FlexCAN_SetOperationMode+0x6c>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    cc26:	9b01      	ldr	r3, [sp, #4]
    cc28:	685b      	ldr	r3, [r3, #4]
    cc2a:	f023 0208 	bic.w	r2, r3, #8
    cc2e:	9b01      	ldr	r3, [sp, #4]
    cc30:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(0U);
    cc32:	9b01      	ldr	r3, [sp, #4]
    cc34:	685b      	ldr	r3, [r3, #4]
    cc36:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
    cc3a:	9b01      	ldr	r3, [sp, #4]
    cc3c:	605a      	str	r2, [r3, #4]
            break;
    cc3e:	e018      	b.n	cc72 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(1U);
    cc40:	9b01      	ldr	r3, [sp, #4]
    cc42:	685b      	ldr	r3, [r3, #4]
    cc44:	f043 0208 	orr.w	r2, r3, #8
    cc48:	9b01      	ldr	r3, [sp, #4]
    cc4a:	605a      	str	r2, [r3, #4]
            break;
    cc4c:	e011      	b.n	cc72 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(1U);
    cc4e:	9b01      	ldr	r3, [sp, #4]
    cc50:	685b      	ldr	r3, [r3, #4]
    cc52:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    cc56:	9b01      	ldr	r3, [sp, #4]
    cc58:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    cc5a:	9b01      	ldr	r3, [sp, #4]
    cc5c:	685b      	ldr	r3, [r3, #4]
    cc5e:	f023 0208 	bic.w	r2, r3, #8
    cc62:	9b01      	ldr	r3, [sp, #4]
    cc64:	605a      	str	r2, [r3, #4]
            FlexCAN_SetSelfReception(base, TRUE);
    cc66:	2101      	movs	r1, #1
    cc68:	9801      	ldr	r0, [sp, #4]
    cc6a:	f7fe ff7f 	bl	bb6c <FlexCAN_SetSelfReception>
            break;
    cc6e:	e000      	b.n	cc72 <FlexCAN_SetOperationMode+0x6e>
            break;
    cc70:	bf00      	nop
    }
}
    cc72:	bf00      	nop
    cc74:	b003      	add	sp, #12
    cc76:	f85d fb04 	ldr.w	pc, [sp], #4

0000cc7a <FlexCAN_SetRxFifoFilter>:
 *END**************************************************************************/
void FlexCAN_SetRxFifoFilter(FLEXCAN_Type * base,
                             Flexcan_Ip_RxFifoIdElementFormatType idFormat,
                             const Flexcan_Ip_IdTableType * idFilterTable
                            )
{
    cc7a:	b500      	push	{lr}
    cc7c:	b08d      	sub	sp, #52	; 0x34
    cc7e:	9003      	str	r0, [sp, #12]
    cc80:	9102      	str	r1, [sp, #8]
    cc82:	9201      	str	r2, [sp, #4]

    /* Set RX FIFO ID filter table elements*/
    uint32 i, j, NumOfFilters;
    uint32 Val1 = 0UL, Val2 = 0UL, Val = 0UL;
    cc84:	2300      	movs	r3, #0
    cc86:	9309      	str	r3, [sp, #36]	; 0x24
    cc88:	2300      	movs	r3, #0
    cc8a:	9308      	str	r3, [sp, #32]
    cc8c:	2300      	movs	r3, #0
    cc8e:	9307      	str	r3, [sp, #28]
    volatile uint32 * FilterTable = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_RX_FIFO_FILTER_TABLE_OFFSET);
    cc90:	9b03      	ldr	r3, [sp, #12]
    cc92:	33e0      	adds	r3, #224	; 0xe0
    cc94:	9306      	str	r3, [sp, #24]

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert((idFilterTable != NULL_PTR) || (FLEXCAN_RX_FIFO_ID_FORMAT_D == idFormat));
    #endif

    NumOfFilters = (((base->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    cc96:	9b03      	ldr	r3, [sp, #12]
    cc98:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    cc9a:	0e1b      	lsrs	r3, r3, #24
    cc9c:	f003 030f 	and.w	r3, r3, #15
    cca0:	9305      	str	r3, [sp, #20]
    cca2:	9b02      	ldr	r3, [sp, #8]
    cca4:	2b03      	cmp	r3, #3
    cca6:	f200 81e7 	bhi.w	d078 <FlexCAN_SetRxFifoFilter+0x3fe>
    ccaa:	a201      	add	r2, pc, #4	; (adr r2, ccb0 <FlexCAN_SetRxFifoFilter+0x36>)
    ccac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ccb0:	0000ccc1 	.word	0x0000ccc1
    ccb4:	0000cd5b 	.word	0x0000cd5b
    ccb8:	0000ce95 	.word	0x0000ce95
    ccbc:	0000d063 	.word	0x0000d063
    switch (idFormat)
    {
        case (FLEXCAN_RX_FIFO_ID_FORMAT_A):
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    ccc0:	f000 ffb4 	bl	dc2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            /* One full ID (standard and extended) per ID Filter Table element.*/
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    ccc4:	9b03      	ldr	r3, [sp, #12]
    ccc6:	681b      	ldr	r3, [r3, #0]
    ccc8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
            (base->MCR) =
    cccc:	9b03      	ldr	r3, [sp, #12]
    ccce:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_A)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    ccd0:	f000 ffd8 	bl	dc84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    ccd4:	2300      	movs	r3, #0
    ccd6:	930b      	str	r3, [sp, #44]	; 0x2c
    ccd8:	e038      	b.n	cd4c <FlexCAN_SetRxFifoFilter+0xd2>
            {
                Val = 0UL;
    ccda:	2300      	movs	r3, #0
    ccdc:	9307      	str	r3, [sp, #28]

                if (idFilterTable[i].isRemoteFrame)
    ccde:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cce0:	00db      	lsls	r3, r3, #3
    cce2:	9a01      	ldr	r2, [sp, #4]
    cce4:	4413      	add	r3, r2
    cce6:	781b      	ldrb	r3, [r3, #0]
    cce8:	2b00      	cmp	r3, #0
    ccea:	d002      	beq.n	ccf2 <FlexCAN_SetRxFifoFilter+0x78>
                {
                    Val = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    ccec:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    ccf0:	9307      	str	r3, [sp, #28]
                }

                if (idFilterTable[i].isExtendedFrame)
    ccf2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ccf4:	00db      	lsls	r3, r3, #3
    ccf6:	9a01      	ldr	r2, [sp, #4]
    ccf8:	4413      	add	r3, r2
    ccfa:	785b      	ldrb	r3, [r3, #1]
    ccfc:	2b00      	cmp	r3, #0
    ccfe:	d013      	beq.n	cd28 <FlexCAN_SetRxFifoFilter+0xae>
                {
                    Val |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    cd00:	9b07      	ldr	r3, [sp, #28]
    cd02:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    cd06:	9307      	str	r3, [sp, #28]
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) &
    cd08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cd0a:	00db      	lsls	r3, r3, #3
    cd0c:	9a01      	ldr	r2, [sp, #4]
    cd0e:	4413      	add	r3, r2
    cd10:	685b      	ldr	r3, [r3, #4]
    cd12:	005b      	lsls	r3, r3, #1
    cd14:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
    cd18:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cd1a:	009b      	lsls	r3, r3, #2
    cd1c:	9a06      	ldr	r2, [sp, #24]
    cd1e:	4413      	add	r3, r2
    cd20:	9a07      	ldr	r2, [sp, #28]
    cd22:	440a      	add	r2, r1
    cd24:	601a      	str	r2, [r3, #0]
    cd26:	e00e      	b.n	cd46 <FlexCAN_SetRxFifoFilter+0xcc>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK
                                           );
                }
                else
                {
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) &
    cd28:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cd2a:	00db      	lsls	r3, r3, #3
    cd2c:	9a01      	ldr	r2, [sp, #4]
    cd2e:	4413      	add	r3, r2
    cd30:	685b      	ldr	r3, [r3, #4]
    cd32:	04da      	lsls	r2, r3, #19
    cd34:	4b9d      	ldr	r3, [pc, #628]	; (cfac <FlexCAN_SetRxFifoFilter+0x332>)
    cd36:	4013      	ands	r3, r2
    cd38:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cd3a:	0092      	lsls	r2, r2, #2
    cd3c:	9906      	ldr	r1, [sp, #24]
    cd3e:	440a      	add	r2, r1
    cd40:	9907      	ldr	r1, [sp, #28]
    cd42:	440b      	add	r3, r1
    cd44:	6013      	str	r3, [r2, #0]
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    cd46:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cd48:	3301      	adds	r3, #1
    cd4a:	930b      	str	r3, [sp, #44]	; 0x2c
    cd4c:	9b05      	ldr	r3, [sp, #20]
    cd4e:	3301      	adds	r3, #1
    cd50:	00db      	lsls	r3, r3, #3
    cd52:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cd54:	429a      	cmp	r2, r3
    cd56:	d3c0      	bcc.n	ccda <FlexCAN_SetRxFifoFilter+0x60>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_MASK
                                           );
                }
            }
            break;
    cd58:	e18f      	b.n	d07a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_B):
            /* Two full standard IDs or two partial 14-bit (standard and extended) IDs*/
            /* per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    cd5a:	f000 ff67 	bl	dc2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) | ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_B)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
    cd5e:	9b03      	ldr	r3, [sp, #12]
    cd60:	681b      	ldr	r3, [r3, #0]
    cd62:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    cd66:	f443 7280 	orr.w	r2, r3, #256	; 0x100
            (base->MCR) =
    cd6a:	9b03      	ldr	r3, [sp, #12]
    cd6c:	601a      	str	r2, [r3, #0]
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    cd6e:	f000 ff89 	bl	dc84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    cd72:	2300      	movs	r3, #0
    cd74:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    cd76:	2300      	movs	r3, #0
    cd78:	930b      	str	r3, [sp, #44]	; 0x2c
    cd7a:	e083      	b.n	ce84 <FlexCAN_SetRxFifoFilter+0x20a>
            {
                Val1 = 0U;
    cd7c:	2300      	movs	r3, #0
    cd7e:	9309      	str	r3, [sp, #36]	; 0x24
                Val2 = 0U;
    cd80:	2300      	movs	r3, #0
    cd82:	9308      	str	r3, [sp, #32]

                if (idFilterTable[j].isRemoteFrame)
    cd84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cd86:	00db      	lsls	r3, r3, #3
    cd88:	9a01      	ldr	r2, [sp, #4]
    cd8a:	4413      	add	r3, r2
    cd8c:	781b      	ldrb	r3, [r3, #0]
    cd8e:	2b00      	cmp	r3, #0
    cd90:	d002      	beq.n	cd98 <FlexCAN_SetRxFifoFilter+0x11e>
                {
                    Val1 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    cd92:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    cd96:	9309      	str	r3, [sp, #36]	; 0x24
                }

                if (idFilterTable[j + 1U].isRemoteFrame)
    cd98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cd9a:	3301      	adds	r3, #1
    cd9c:	00db      	lsls	r3, r3, #3
    cd9e:	9a01      	ldr	r2, [sp, #4]
    cda0:	4413      	add	r3, r2
    cda2:	781b      	ldrb	r3, [r3, #0]
    cda4:	2b00      	cmp	r3, #0
    cda6:	d002      	beq.n	cdae <FlexCAN_SetRxFifoFilter+0x134>
                {
                    Val2 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;
    cda8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    cdac:	9308      	str	r3, [sp, #32]
                }

                if (idFilterTable[j].isExtendedFrame)
    cdae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cdb0:	00db      	lsls	r3, r3, #3
    cdb2:	9a01      	ldr	r2, [sp, #4]
    cdb4:	4413      	add	r3, r2
    cdb6:	785b      	ldrb	r3, [r3, #1]
    cdb8:	2b00      	cmp	r3, #0
    cdba:	d014      	beq.n	cde6 <FlexCAN_SetRxFifoFilter+0x16c>
                {
                    Val1 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    cdbc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cdbe:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    cdc2:	9309      	str	r3, [sp, #36]	; 0x24

                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    cdc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cdc6:	00db      	lsls	r3, r3, #3
    cdc8:	9a01      	ldr	r2, [sp, #4]
    cdca:	4413      	add	r3, r2
    cdcc:	685b      	ldr	r3, [r3, #4]
    cdce:	0bdb      	lsrs	r3, r3, #15
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1
    cdd0:	041a      	lsls	r2, r3, #16
    cdd2:	4b77      	ldr	r3, [pc, #476]	; (cfb0 <FlexCAN_SetRxFifoFilter+0x336>)
    cdd4:	4013      	ands	r3, r2
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    cdd6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cdd8:	0092      	lsls	r2, r2, #2
    cdda:	9906      	ldr	r1, [sp, #24]
    cddc:	440a      	add	r2, r1
    cdde:	9909      	ldr	r1, [sp, #36]	; 0x24
    cde0:	440b      	add	r3, r1
    cde2:	6013      	str	r3, [r2, #0]
    cde4:	e00e      	b.n	ce04 <FlexCAN_SetRxFifoFilter+0x18a>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + ((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    cde6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cde8:	00db      	lsls	r3, r3, #3
    cdea:	9a01      	ldr	r2, [sp, #4]
    cdec:	4413      	add	r3, r2
    cdee:	685b      	ldr	r3, [r3, #4]
    cdf0:	04da      	lsls	r2, r3, #19
    cdf2:	4b6e      	ldr	r3, [pc, #440]	; (cfac <FlexCAN_SetRxFifoFilter+0x332>)
    cdf4:	4013      	ands	r3, r2
    cdf6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    cdf8:	0092      	lsls	r2, r2, #2
    cdfa:	9906      	ldr	r1, [sp, #24]
    cdfc:	440a      	add	r2, r1
    cdfe:	9909      	ldr	r1, [sp, #36]	; 0x24
    ce00:	440b      	add	r3, r1
    ce02:	6013      	str	r3, [r2, #0]
                                              FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    ce04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ce06:	3301      	adds	r3, #1
    ce08:	00db      	lsls	r3, r3, #3
    ce0a:	9a01      	ldr	r2, [sp, #4]
    ce0c:	4413      	add	r3, r2
    ce0e:	785b      	ldrb	r3, [r3, #1]
    ce10:	2b00      	cmp	r3, #0
    ce12:	d01a      	beq.n	ce4a <FlexCAN_SetRxFifoFilter+0x1d0>
                {
                    Val2 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;
    ce14:	9b08      	ldr	r3, [sp, #32]
    ce16:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    ce1a:	9308      	str	r3, [sp, #32]

                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    ce1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ce1e:	009b      	lsls	r3, r3, #2
    ce20:	9a06      	ldr	r2, [sp, #24]
    ce22:	4413      	add	r3, r2
    ce24:	6819      	ldr	r1, [r3, #0]
    ce26:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ce28:	3301      	adds	r3, #1
    ce2a:	00db      	lsls	r3, r3, #3
    ce2c:	9a01      	ldr	r2, [sp, #4]
    ce2e:	4413      	add	r3, r2
    ce30:	685b      	ldr	r3, [r3, #4]
    ce32:	0bdb      	lsrs	r3, r3, #15
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2
    ce34:	f3c3 020d 	ubfx	r2, r3, #0, #14
                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    ce38:	9b08      	ldr	r3, [sp, #32]
    ce3a:	441a      	add	r2, r3
    ce3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ce3e:	009b      	lsls	r3, r3, #2
    ce40:	9806      	ldr	r0, [sp, #24]
    ce42:	4403      	add	r3, r0
    ce44:	430a      	orrs	r2, r1
    ce46:	601a      	str	r2, [r3, #0]
    ce48:	e016      	b.n	ce78 <FlexCAN_SetRxFifoFilter+0x1fe>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val2 + ((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    ce4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ce4c:	009b      	lsls	r3, r3, #2
    ce4e:	9a06      	ldr	r2, [sp, #24]
    ce50:	4413      	add	r3, r2
    ce52:	6819      	ldr	r1, [r3, #0]
    ce54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ce56:	3301      	adds	r3, #1
    ce58:	00db      	lsls	r3, r3, #3
    ce5a:	9a01      	ldr	r2, [sp, #4]
    ce5c:	4413      	add	r3, r2
    ce5e:	685b      	ldr	r3, [r3, #4]
    ce60:	00da      	lsls	r2, r3, #3
    ce62:	f643 73f8 	movw	r3, #16376	; 0x3ff8
    ce66:	4013      	ands	r3, r2
    ce68:	9a08      	ldr	r2, [sp, #32]
    ce6a:	441a      	add	r2, r3
    ce6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ce6e:	009b      	lsls	r3, r3, #2
    ce70:	9806      	ldr	r0, [sp, #24]
    ce72:	4403      	add	r3, r0
    ce74:	430a      	orrs	r2, r1
    ce76:	601a      	str	r2, [r3, #0]
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2
                                             );
                }

                j = j + 2U;
    ce78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ce7a:	3302      	adds	r3, #2
    ce7c:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    ce7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ce80:	3301      	adds	r3, #1
    ce82:	930b      	str	r3, [sp, #44]	; 0x2c
    ce84:	9b05      	ldr	r3, [sp, #20]
    ce86:	3301      	adds	r3, #1
    ce88:	00db      	lsls	r3, r3, #3
    ce8a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ce8c:	429a      	cmp	r2, r3
    ce8e:	f4ff af75 	bcc.w	cd7c <FlexCAN_SetRxFifoFilter+0x102>
            }
            break;
    ce92:	e0f2      	b.n	d07a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_C):
            /* Four partial 8-bit Standard IDs per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    ce94:	f000 feca 	bl	dc2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    ce98:	9b03      	ldr	r3, [sp, #12]
    ce9a:	681b      	ldr	r3, [r3, #0]
    ce9c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    cea0:	f443 7200 	orr.w	r2, r3, #512	; 0x200
            (base->MCR) =
    cea4:	9b03      	ldr	r3, [sp, #12]
    cea6:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_C)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    cea8:	f000 feec 	bl	dc84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    ceac:	2300      	movs	r3, #0
    ceae:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    ceb0:	2300      	movs	r3, #0
    ceb2:	930b      	str	r3, [sp, #44]	; 0x2c
    ceb4:	e0cd      	b.n	d052 <FlexCAN_SetRxFifoFilter+0x3d8>
            {
                if (idFilterTable[j].isExtendedFrame)
    ceb6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ceb8:	00db      	lsls	r3, r3, #3
    ceba:	9a01      	ldr	r2, [sp, #4]
    cebc:	4413      	add	r3, r2
    cebe:	785b      	ldrb	r3, [r3, #1]
    cec0:	2b00      	cmp	r3, #0
    cec2:	d00e      	beq.n	cee2 <FlexCAN_SetRxFifoFilter+0x268>
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cec4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cec6:	00db      	lsls	r3, r3, #3
    cec8:	9a01      	ldr	r2, [sp, #4]
    ceca:	4413      	add	r3, r2
    cecc:	685b      	ldr	r3, [r3, #4]
    cece:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    ced0:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    ced2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ced4:	009b      	lsls	r3, r3, #2
    ced6:	9a06      	ldr	r2, [sp, #24]
    ced8:	4413      	add	r3, r2
    ceda:	9a09      	ldr	r2, [sp, #36]	; 0x24
    cedc:	440a      	add	r2, r1
    cede:	601a      	str	r2, [r3, #0]
    cee0:	e00d      	b.n	cefe <FlexCAN_SetRxFifoFilter+0x284>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cee2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cee4:	00db      	lsls	r3, r3, #3
    cee6:	9a01      	ldr	r2, [sp, #4]
    cee8:	4413      	add	r3, r2
    ceea:	685b      	ldr	r3, [r3, #4]
    ceec:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    ceee:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cef0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cef2:	009b      	lsls	r3, r3, #2
    cef4:	9a06      	ldr	r2, [sp, #24]
    cef6:	4413      	add	r3, r2
    cef8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    cefa:	440a      	add	r2, r1
    cefc:	601a      	str	r2, [r3, #0]
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    cefe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf00:	3301      	adds	r3, #1
    cf02:	00db      	lsls	r3, r3, #3
    cf04:	9a01      	ldr	r2, [sp, #4]
    cf06:	4413      	add	r3, r2
    cf08:	785b      	ldrb	r3, [r3, #1]
    cf0a:	2b00      	cmp	r3, #0
    cf0c:	d017      	beq.n	cf3e <FlexCAN_SetRxFifoFilter+0x2c4>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cf0e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf10:	009b      	lsls	r3, r3, #2
    cf12:	9a06      	ldr	r2, [sp, #24]
    cf14:	4413      	add	r3, r2
    cf16:	6819      	ldr	r1, [r3, #0]
    cf18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf1a:	3301      	adds	r3, #1
    cf1c:	00db      	lsls	r3, r3, #3
    cf1e:	9a01      	ldr	r2, [sp, #4]
    cf20:	4413      	add	r3, r2
    cf22:	685b      	ldr	r3, [r3, #4]
    cf24:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    cf26:	041b      	lsls	r3, r3, #16
    cf28:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cf2c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf2e:	441a      	add	r2, r3
    cf30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf32:	009b      	lsls	r3, r3, #2
    cf34:	9806      	ldr	r0, [sp, #24]
    cf36:	4403      	add	r3, r0
    cf38:	430a      	orrs	r2, r1
    cf3a:	601a      	str	r2, [r3, #0]
    cf3c:	e016      	b.n	cf6c <FlexCAN_SetRxFifoFilter+0x2f2>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cf3e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf40:	009b      	lsls	r3, r3, #2
    cf42:	9a06      	ldr	r2, [sp, #24]
    cf44:	4413      	add	r3, r2
    cf46:	6819      	ldr	r1, [r3, #0]
    cf48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf4a:	3301      	adds	r3, #1
    cf4c:	00db      	lsls	r3, r3, #3
    cf4e:	9a01      	ldr	r2, [sp, #4]
    cf50:	4413      	add	r3, r2
    cf52:	685b      	ldr	r3, [r3, #4]
    cf54:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    cf56:	041b      	lsls	r3, r3, #16
    cf58:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cf5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf5e:	441a      	add	r2, r3
    cf60:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf62:	009b      	lsls	r3, r3, #2
    cf64:	9806      	ldr	r0, [sp, #24]
    cf66:	4403      	add	r3, r0
    cf68:	430a      	orrs	r2, r1
    cf6a:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 2U].isExtendedFrame)
    cf6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf6e:	3302      	adds	r3, #2
    cf70:	00db      	lsls	r3, r3, #3
    cf72:	9a01      	ldr	r2, [sp, #4]
    cf74:	4413      	add	r3, r2
    cf76:	785b      	ldrb	r3, [r3, #1]
    cf78:	2b00      	cmp	r3, #0
    cf7a:	d01b      	beq.n	cfb4 <FlexCAN_SetRxFifoFilter+0x33a>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cf7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf7e:	009b      	lsls	r3, r3, #2
    cf80:	9a06      	ldr	r2, [sp, #24]
    cf82:	4413      	add	r3, r2
    cf84:	6819      	ldr	r1, [r3, #0]
    cf86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf88:	3302      	adds	r3, #2
    cf8a:	00db      	lsls	r3, r3, #3
    cf8c:	9a01      	ldr	r2, [sp, #4]
    cf8e:	4413      	add	r3, r2
    cf90:	685b      	ldr	r3, [r3, #4]
    cf92:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    cf94:	021b      	lsls	r3, r3, #8
    cf96:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cf98:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf9a:	441a      	add	r2, r3
    cf9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf9e:	009b      	lsls	r3, r3, #2
    cfa0:	9806      	ldr	r0, [sp, #24]
    cfa2:	4403      	add	r3, r0
    cfa4:	430a      	orrs	r2, r1
    cfa6:	601a      	str	r2, [r3, #0]
    cfa8:	e01a      	b.n	cfe0 <FlexCAN_SetRxFifoFilter+0x366>
    cfaa:	bf00      	nop
    cfac:	3ff80000 	.word	0x3ff80000
    cfb0:	3fff0000 	.word	0x3fff0000
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cfb4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cfb6:	009b      	lsls	r3, r3, #2
    cfb8:	9a06      	ldr	r2, [sp, #24]
    cfba:	4413      	add	r3, r2
    cfbc:	6819      	ldr	r1, [r3, #0]
    cfbe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cfc0:	3302      	adds	r3, #2
    cfc2:	00db      	lsls	r3, r3, #3
    cfc4:	9a01      	ldr	r2, [sp, #4]
    cfc6:	4413      	add	r3, r2
    cfc8:	685b      	ldr	r3, [r3, #4]
    cfca:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    cfcc:	021b      	lsls	r3, r3, #8
    cfce:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    cfd0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cfd2:	441a      	add	r2, r3
    cfd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cfd6:	009b      	lsls	r3, r3, #2
    cfd8:	9806      	ldr	r0, [sp, #24]
    cfda:	4403      	add	r3, r0
    cfdc:	430a      	orrs	r2, r1
    cfde:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 3U].isExtendedFrame)
    cfe0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cfe2:	3303      	adds	r3, #3
    cfe4:	00db      	lsls	r3, r3, #3
    cfe6:	9a01      	ldr	r2, [sp, #4]
    cfe8:	4413      	add	r3, r2
    cfea:	785b      	ldrb	r3, [r3, #1]
    cfec:	2b00      	cmp	r3, #0
    cfee:	d015      	beq.n	d01c <FlexCAN_SetRxFifoFilter+0x3a2>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    cff0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cff2:	009b      	lsls	r3, r3, #2
    cff4:	9a06      	ldr	r2, [sp, #24]
    cff6:	4413      	add	r3, r2
    cff8:	6819      	ldr	r1, [r3, #0]
    cffa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cffc:	3303      	adds	r3, #3
    cffe:	00db      	lsls	r3, r3, #3
    d000:	9a01      	ldr	r2, [sp, #4]
    d002:	4413      	add	r3, r2
    d004:	685b      	ldr	r3, [r3, #4]
    d006:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    d008:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    d00a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d00c:	441a      	add	r2, r3
    d00e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d010:	009b      	lsls	r3, r3, #2
    d012:	9806      	ldr	r0, [sp, #24]
    d014:	4403      	add	r3, r0
    d016:	430a      	orrs	r2, r1
    d018:	601a      	str	r2, [r3, #0]
    d01a:	e014      	b.n	d046 <FlexCAN_SetRxFifoFilter+0x3cc>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 +
    d01c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d01e:	009b      	lsls	r3, r3, #2
    d020:	9a06      	ldr	r2, [sp, #24]
    d022:	4413      	add	r3, r2
    d024:	6819      	ldr	r1, [r3, #0]
                                      (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    d026:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d028:	3303      	adds	r3, #3
    d02a:	00db      	lsls	r3, r3, #3
    d02c:	9a01      	ldr	r2, [sp, #4]
    d02e:	4413      	add	r3, r2
    d030:	685b      	ldr	r3, [r3, #4]
    d032:	08db      	lsrs	r3, r3, #3
                                        FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                       ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    d034:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 +
    d036:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d038:	441a      	add	r2, r3
    d03a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d03c:	009b      	lsls	r3, r3, #2
    d03e:	9806      	ldr	r0, [sp, #24]
    d040:	4403      	add	r3, r0
    d042:	430a      	orrs	r2, r1
    d044:	601a      	str	r2, [r3, #0]
                                      );
                }

                j = j + 4U;
    d046:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d048:	3304      	adds	r3, #4
    d04a:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    d04c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d04e:	3301      	adds	r3, #1
    d050:	930b      	str	r3, [sp, #44]	; 0x2c
    d052:	9b05      	ldr	r3, [sp, #20]
    d054:	3301      	adds	r3, #1
    d056:	00db      	lsls	r3, r3, #3
    d058:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d05a:	429a      	cmp	r2, r3
    d05c:	f4ff af2b 	bcc.w	ceb6 <FlexCAN_SetRxFifoFilter+0x23c>
            }
            break;
    d060:	e00b      	b.n	d07a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_D):
            /* All frames rejected.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    d062:	f000 fde3 	bl	dc2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    d066:	9b03      	ldr	r3, [sp, #12]
    d068:	681b      	ldr	r3, [r3, #0]
    d06a:	f443 7240 	orr.w	r2, r3, #768	; 0x300
            (base->MCR) =
    d06e:	9b03      	ldr	r3, [sp, #12]
    d070:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_D)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    d072:	f000 fe07 	bl	dc84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            break;
    d076:	e000      	b.n	d07a <FlexCAN_SetRxFifoFilter+0x400>
        default:
            /* Should not get here */
            break;
    d078:	bf00      	nop
    }
}
    d07a:	bf00      	nop
    d07c:	b00d      	add	sp, #52	; 0x34
    d07e:	f85d fb04 	ldr.w	pc, [sp], #4

0000d082 <FlexCAN_ReadRxFifo>:
 * Description   : Read Rx FIFO data.
 * This function will copy MB[0] data field into user's buffer.
 *
 *END**************************************************************************/
void FlexCAN_ReadRxFifo(const FLEXCAN_Type * base, Flexcan_Ip_MsgBuffType * rxFifo)
{
    d082:	b500      	push	{lr}
    d084:	b08b      	sub	sp, #44	; 0x2c
    d086:	9001      	str	r0, [sp, #4]
    d088:	9100      	str	r1, [sp, #0]
    uint32 x;
    uint8 Index;
    const uint8 * p;
    #endif

    volatile const uint32 * flexcan_mb = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    d08a:	9b01      	ldr	r3, [sp, #4]
    d08c:	3380      	adds	r3, #128	; 0x80
    d08e:	9307      	str	r3, [sp, #28]
    volatile const uint32 * flexcan_mb_id = &flexcan_mb[1];
    d090:	9b07      	ldr	r3, [sp, #28]
    d092:	3304      	adds	r3, #4
    d094:	9306      	str	r3, [sp, #24]
    volatile const uint32 * flexcan_mb_data_32 = &flexcan_mb[2];
    d096:	9b07      	ldr	r3, [sp, #28]
    d098:	3308      	adds	r3, #8
    d09a:	9305      	str	r3, [sp, #20]
    uint32 * msgData_32 = NULL_PTR;
    d09c:	2300      	movs	r3, #0
    d09e:	9304      	str	r3, [sp, #16]
    uint8 flexcan_mb_dlc_value = (uint8)(((*flexcan_mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    d0a0:	9b07      	ldr	r3, [sp, #28]
    d0a2:	681b      	ldr	r3, [r3, #0]
    d0a4:	0c1b      	lsrs	r3, r3, #16
    d0a6:	b2db      	uxtb	r3, r3
    d0a8:	f003 030f 	and.w	r3, r3, #15
    d0ac:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 can_real_payload = FlexCAN_ComputePayloadSize(flexcan_mb_dlc_value);
    d0b0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d0b4:	4618      	mov	r0, r3
    d0b6:	f7fe fe6c 	bl	bd92 <FlexCAN_ComputePayloadSize>
    d0ba:	4603      	mov	r3, r0
    d0bc:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(rxFifo != NULL_PTR);
    #endif
    msgData_32 = (uint32 *)(rxFifo->data);
    d0c0:	9b00      	ldr	r3, [sp, #0]
    d0c2:	3308      	adds	r3, #8
    d0c4:	9304      	str	r3, [sp, #16]
       Check if the length of received data packet bigger than the maximum length accepted,
       then processing flow shall continue with the maximum length defined by configuration.
       Legacy FIFO just support in normal mode.
    */
    /* no need to check if FD enabled or not because this function just is invoked when legacy fifo enabled only ! */
    if (can_real_payload > 8U)
    d0c6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    d0ca:	2b08      	cmp	r3, #8
    d0cc:	d902      	bls.n	d0d4 <FlexCAN_ReadRxFifo+0x52>
    {
        can_real_payload = 8U;
    d0ce:	2308      	movs	r3, #8
    d0d0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    }

    rxFifo->dataLen = can_real_payload;
    d0d4:	9b00      	ldr	r3, [sp, #0]
    d0d6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    d0da:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    rxFifo->cs = *flexcan_mb;
    d0de:	9b07      	ldr	r3, [sp, #28]
    d0e0:	681a      	ldr	r2, [r3, #0]
    d0e2:	9b00      	ldr	r3, [sp, #0]
    d0e4:	601a      	str	r2, [r3, #0]
    if ((rxFifo->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    d0e6:	9b00      	ldr	r3, [sp, #0]
    d0e8:	681b      	ldr	r3, [r3, #0]
    d0ea:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    d0ee:	2b00      	cmp	r3, #0
    d0f0:	d004      	beq.n	d0fc <FlexCAN_ReadRxFifo+0x7a>
    {
        rxFifo->msgId = *flexcan_mb_id;
    d0f2:	9b06      	ldr	r3, [sp, #24]
    d0f4:	681a      	ldr	r2, [r3, #0]
    d0f6:	9b00      	ldr	r3, [sp, #0]
    d0f8:	605a      	str	r2, [r3, #4]
    d0fa:	e004      	b.n	d106 <FlexCAN_ReadRxFifo+0x84>
    }
    else
    {
        rxFifo->msgId = (*flexcan_mb_id) >> FLEXCAN_IP_ID_STD_SHIFT;
    d0fc:	9b06      	ldr	r3, [sp, #24]
    d0fe:	681b      	ldr	r3, [r3, #0]
    d100:	0c9a      	lsrs	r2, r3, #18
    d102:	9b00      	ldr	r3, [sp, #0]
    d104:	605a      	str	r2, [r3, #4]
    }
    /* Extract the IDHIT */
    rxFifo->id_hit = (uint8)base->RXFIR;
    d106:	9b01      	ldr	r3, [sp, #4]
    d108:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    d10a:	b2da      	uxtb	r2, r3
    d10c:	9b00      	ldr	r3, [sp, #0]
    d10e:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
    /* Extract the Time Stamp */
    rxFifo->time_stamp = (uint32)((rxFifo->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    d112:	9b00      	ldr	r3, [sp, #0]
    d114:	681b      	ldr	r3, [r3, #0]
    d116:	b29a      	uxth	r2, r3
    d118:	9b00      	ldr	r3, [sp, #0]
    d11a:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, msgData_32[DataByte >> 2U]);
        }
    }
#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
      /* Copy MB[0] data field into user's buffer */
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    d11c:	2300      	movs	r3, #0
    d11e:	9309      	str	r3, [sp, #36]	; 0x24
    d120:	e01f      	b.n	d162 <FlexCAN_ReadRxFifo+0xe0>
    {
        MbWord = flexcan_mb_data_32[DataByte >> 2U];
    d122:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d124:	089b      	lsrs	r3, r3, #2
    d126:	009b      	lsls	r3, r3, #2
    d128:	9a05      	ldr	r2, [sp, #20]
    d12a:	4413      	add	r3, r2
    d12c:	681b      	ldr	r3, [r3, #0]
    d12e:	9302      	str	r3, [sp, #8]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (msgData_32[DataByte >> 2U]));
    d130:	9b02      	ldr	r3, [sp, #8]
    d132:	0e1a      	lsrs	r2, r3, #24
    d134:	9b02      	ldr	r3, [sp, #8]
    d136:	0a1b      	lsrs	r3, r3, #8
    d138:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    d13c:	431a      	orrs	r2, r3
    d13e:	9b02      	ldr	r3, [sp, #8]
    d140:	021b      	lsls	r3, r3, #8
    d142:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    d146:	ea42 0103 	orr.w	r1, r2, r3
    d14a:	9b02      	ldr	r3, [sp, #8]
    d14c:	061a      	lsls	r2, r3, #24
    d14e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d150:	089b      	lsrs	r3, r3, #2
    d152:	009b      	lsls	r3, r3, #2
    d154:	9804      	ldr	r0, [sp, #16]
    d156:	4403      	add	r3, r0
    d158:	430a      	orrs	r2, r1
    d15a:	601a      	str	r2, [r3, #0]
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    d15c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d15e:	3304      	adds	r3, #4
    d160:	9309      	str	r3, [sp, #36]	; 0x24
    d162:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    d166:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d168:	429a      	cmp	r2, r3
    d16a:	d3da      	bcc.n	d122 <FlexCAN_ReadRxFifo+0xa0>
    }
#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
}
    d16c:	bf00      	nop
    d16e:	bf00      	nop
    d170:	b00b      	add	sp, #44	; 0x2c
    d172:	f85d fb04 	ldr.w	pc, [sp], #4

0000d176 <FlexCAN_IsMbOutOfRange>:
    const FLEXCAN_Type * pBase,
    uint8 u8MbIndex,
    boolean bIsLegacyFifoEn,
    uint32 u32MaxMbNum
)
{
    d176:	b088      	sub	sp, #32
    d178:	9003      	str	r0, [sp, #12]
    d17a:	9301      	str	r3, [sp, #4]
    d17c:	460b      	mov	r3, r1
    d17e:	f88d 300b 	strb.w	r3, [sp, #11]
    d182:	4613      	mov	r3, r2
    d184:	f88d 300a 	strb.w	r3, [sp, #10]
    boolean ReturnValue = FALSE;
    d188:	2300      	movs	r3, #0
    d18a:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32NumOfFiFoElement = 0U;
    d18e:	2300      	movs	r3, #0
    d190:	9306      	str	r3, [sp, #24]
    uint32 u32NumOfMbOccupiedByFiFo = 0U;
    d192:	2300      	movs	r3, #0
    d194:	9305      	str	r3, [sp, #20]

    if (u8MbIndex >= (uint8)u32MaxMbNum)
    d196:	9b01      	ldr	r3, [sp, #4]
    d198:	b2db      	uxtb	r3, r3
    d19a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    d19e:	429a      	cmp	r2, r3
    d1a0:	d303      	bcc.n	d1aa <FlexCAN_IsMbOutOfRange+0x34>
    {
       ReturnValue = TRUE;
    d1a2:	2301      	movs	r3, #1
    d1a4:	f88d 301f 	strb.w	r3, [sp, #31]
    d1a8:	e01b      	b.n	d1e2 <FlexCAN_IsMbOutOfRange+0x6c>
    }
    /* Check if RX FIFO is enabled*/
    else if (TRUE == bIsLegacyFifoEn)
    d1aa:	f89d 300a 	ldrb.w	r3, [sp, #10]
    d1ae:	2b00      	cmp	r3, #0
    d1b0:	d014      	beq.n	d1dc <FlexCAN_IsMbOutOfRange+0x66>
    {
        /* Get the number of RX FIFO Filters*/
        u32NumOfFiFoElement = (((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    d1b2:	9b03      	ldr	r3, [sp, #12]
    d1b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    d1b6:	0e1b      	lsrs	r3, r3, #24
    d1b8:	f003 030f 	and.w	r3, r3, #15
    d1bc:	9306      	str	r3, [sp, #24]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        u32NumOfMbOccupiedByFiFo = 5U + ((((u32NumOfFiFoElement) + 1U) * 8U) / 4U);
    d1be:	9b06      	ldr	r3, [sp, #24]
    d1c0:	3301      	adds	r3, #1
    d1c2:	00db      	lsls	r3, r3, #3
    d1c4:	089b      	lsrs	r3, r3, #2
    d1c6:	3305      	adds	r3, #5
    d1c8:	9305      	str	r3, [sp, #20]
        if (u8MbIndex <= u32NumOfMbOccupiedByFiFo)
    d1ca:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d1ce:	9a05      	ldr	r2, [sp, #20]
    d1d0:	429a      	cmp	r2, r3
    d1d2:	d306      	bcc.n	d1e2 <FlexCAN_IsMbOutOfRange+0x6c>
        {
            ReturnValue = TRUE;
    d1d4:	2301      	movs	r3, #1
    d1d6:	f88d 301f 	strb.w	r3, [sp, #31]
    d1da:	e002      	b.n	d1e2 <FlexCAN_IsMbOutOfRange+0x6c>
        }
    }
    else
    {
        ReturnValue = FALSE;
    d1dc:	2300      	movs	r3, #0
    d1de:	f88d 301f 	strb.w	r3, [sp, #31]
    }

    return ReturnValue;
    d1e2:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    d1e6:	4618      	mov	r0, r3
    d1e8:	b008      	add	sp, #32
    d1ea:	4770      	bx	lr

0000d1ec <FlexCAN_ConfigCtrlOptions>:
 * Description   : configure controller depending on options
 * note: should be call after FD configuration.
 *
 *END**************************************************************************/
void FlexCAN_ConfigCtrlOptions(FLEXCAN_Type * pBase, uint32 u32Options)
{
    d1ec:	b500      	push	{lr}
    d1ee:	b083      	sub	sp, #12
    d1f0:	9001      	str	r0, [sp, #4]
    d1f2:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON)
    /* If the FD feature is enabled, in order to be ISO-compliant. */
    if ((u32Options & FLEXCAN_IP_ISO_U32) != 0U)
    d1f4:	9b00      	ldr	r3, [sp, #0]
    d1f6:	f003 0320 	and.w	r3, r3, #32
    d1fa:	2b00      	cmp	r3, #0
    d1fc:	d004      	beq.n	d208 <FlexCAN_ConfigCtrlOptions+0x1c>
    {
        FlexCAN_SetIsoCan(pBase, TRUE);
    d1fe:	2101      	movs	r1, #1
    d200:	9801      	ldr	r0, [sp, #4]
    d202:	f7fe fcd8 	bl	bbb6 <FlexCAN_SetIsoCan>
    d206:	e003      	b.n	d210 <FlexCAN_ConfigCtrlOptions+0x24>
    }
    else
    {
        /* This maybe don't have sense if the Deinit returns the state of registers at init values */
        FlexCAN_SetIsoCan(pBase, FALSE);
    d208:	2100      	movs	r1, #0
    d20a:	9801      	ldr	r0, [sp, #4]
    d20c:	f7fe fcd3 	bl	bbb6 <FlexCAN_SetIsoCan>
    }
#endif /*(FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON) */
    /* Set Entire Frame Arbitration Field Comparison. */
    if ((u32Options & FLEXCAN_IP_EACEN_U32) != 0U)
    d210:	9b00      	ldr	r3, [sp, #0]
    d212:	f003 0340 	and.w	r3, r3, #64	; 0x40
    d216:	2b00      	cmp	r3, #0
    d218:	d004      	beq.n	d224 <FlexCAN_ConfigCtrlOptions+0x38>
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, TRUE);
    d21a:	2101      	movs	r1, #1
    d21c:	9801      	ldr	r0, [sp, #4]
    d21e:	f7fe fce1 	bl	bbe4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    d222:	e003      	b.n	d22c <FlexCAN_ConfigCtrlOptions+0x40>
    }
    else
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, FALSE);
    d224:	2100      	movs	r1, #0
    d226:	9801      	ldr	r0, [sp, #4]
    d228:	f7fe fcdc 	bl	bbe4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    }
#if (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)
    /* Set protocol Exception */
    if ((u32Options & FLEXCAN_IP_PROTOCOL_EXCEPTION_U32) != 0U)
    d22c:	9b00      	ldr	r3, [sp, #0]
    d22e:	f003 0308 	and.w	r3, r3, #8
    d232:	2b00      	cmp	r3, #0
    d234:	d004      	beq.n	d240 <FlexCAN_ConfigCtrlOptions+0x54>
    {
        FlexCAN_SetProtocolException(pBase, TRUE);
    d236:	2101      	movs	r1, #1
    d238:	9801      	ldr	r0, [sp, #4]
    d23a:	f7fe fcea 	bl	bc12 <FlexCAN_SetProtocolException>
    d23e:	e003      	b.n	d248 <FlexCAN_ConfigCtrlOptions+0x5c>
    }
    else
    {
        FlexCAN_SetProtocolException(pBase, FALSE);
    d240:	2100      	movs	r1, #0
    d242:	9801      	ldr	r0, [sp, #4]
    d244:	f7fe fce5 	bl	bc12 <FlexCAN_SetProtocolException>
    }
#endif /* Endif  (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)  */
    /* Set CAN Bit Sampling */
    if (((u32Options & FLEXCAN_IP_THREE_SAMPLES_U32) != 0U) && (0U == (pBase->MCR & FLEXCAN_MCR_FDEN_MASK)))
    d248:	9b00      	ldr	r3, [sp, #0]
    d24a:	f003 0302 	and.w	r3, r3, #2
    d24e:	2b00      	cmp	r3, #0
    d250:	d00a      	beq.n	d268 <FlexCAN_ConfigCtrlOptions+0x7c>
    d252:	9b01      	ldr	r3, [sp, #4]
    d254:	681b      	ldr	r3, [r3, #0]
    d256:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    d25a:	2b00      	cmp	r3, #0
    d25c:	d104      	bne.n	d268 <FlexCAN_ConfigCtrlOptions+0x7c>
    {
        FlexCAN_CanBitSampling(pBase, TRUE);
    d25e:	2101      	movs	r1, #1
    d260:	9801      	ldr	r0, [sp, #4]
    d262:	f7fe fd31 	bl	bcc8 <FlexCAN_CanBitSampling>
    d266:	e003      	b.n	d270 <FlexCAN_ConfigCtrlOptions+0x84>
    }
    else
    {
        FlexCAN_CanBitSampling(pBase, FALSE);
    d268:	2100      	movs	r1, #0
    d26a:	9801      	ldr	r0, [sp, #4]
    d26c:	f7fe fd2c 	bl	bcc8 <FlexCAN_CanBitSampling>
    }

    /* Set AutoBusOff Recovery */
    if ((u32Options & FLEXCAN_IP_BUSOFF_RECOVERY_U32) != 0U)
    d270:	9b00      	ldr	r3, [sp, #0]
    d272:	f003 0304 	and.w	r3, r3, #4
    d276:	2b00      	cmp	r3, #0
    d278:	d004      	beq.n	d284 <FlexCAN_ConfigCtrlOptions+0x98>
    {
        FlexCAN_SetBusOffAutorecovery(pBase, TRUE);
    d27a:	2101      	movs	r1, #1
    d27c:	9801      	ldr	r0, [sp, #4]
    d27e:	f7fe fcf6 	bl	bc6e <FlexCAN_SetBusOffAutorecovery>
    d282:	e003      	b.n	d28c <FlexCAN_ConfigCtrlOptions+0xa0>
    }
    else
    {
        FlexCAN_SetBusOffAutorecovery(pBase, FALSE);
    d284:	2100      	movs	r1, #0
    d286:	9801      	ldr	r0, [sp, #4]
    d288:	f7fe fcf1 	bl	bc6e <FlexCAN_SetBusOffAutorecovery>
    }
    /* Set Remote Request Store for received of Remote Request Frames */
    if ((u32Options & FLEXCAN_IP_REM_STORE_U32) != 0U)
    d28c:	9b00      	ldr	r3, [sp, #0]
    d28e:	f003 0301 	and.w	r3, r3, #1
    d292:	2b00      	cmp	r3, #0
    d294:	d004      	beq.n	d2a0 <FlexCAN_ConfigCtrlOptions+0xb4>
    {
        FlexCAN_SetRemoteReqStore(pBase, TRUE);
    d296:	2101      	movs	r1, #1
    d298:	9801      	ldr	r0, [sp, #4]
    d29a:	f7fe fcd1 	bl	bc40 <FlexCAN_SetRemoteReqStore>
    d29e:	e003      	b.n	d2a8 <FlexCAN_ConfigCtrlOptions+0xbc>
    }
    else
    {
        FlexCAN_SetRemoteReqStore(pBase, FALSE);
    d2a0:	2100      	movs	r1, #0
    d2a2:	9801      	ldr	r0, [sp, #4]
    d2a4:	f7fe fccc 	bl	bc40 <FlexCAN_SetRemoteReqStore>
    }
#if (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)
    /* Set Edge Filter */
    if ((u32Options & FLEXCAN_IP_EDGE_FILTER_U32) != 0U)
    d2a8:	9b00      	ldr	r3, [sp, #0]
    d2aa:	f003 0310 	and.w	r3, r3, #16
    d2ae:	2b00      	cmp	r3, #0
    d2b0:	d004      	beq.n	d2bc <FlexCAN_ConfigCtrlOptions+0xd0>
    {
        FlexCAN_SetEdgeFilter(pBase, TRUE);
    d2b2:	2101      	movs	r1, #1
    d2b4:	9801      	ldr	r0, [sp, #4]
    d2b6:	f7fe fcf0 	bl	bc9a <FlexCAN_SetEdgeFilter>
    else
    {
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    }
#endif /* End of (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)  */
}
    d2ba:	e003      	b.n	d2c4 <FlexCAN_ConfigCtrlOptions+0xd8>
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    d2bc:	2100      	movs	r1, #0
    d2be:	9801      	ldr	r0, [sp, #4]
    d2c0:	f7fe fceb 	bl	bc9a <FlexCAN_SetEdgeFilter>
}
    d2c4:	bf00      	nop
    d2c6:	b003      	add	sp, #12
    d2c8:	f85d fb04 	ldr.w	pc, [sp], #4

0000d2cc <FlexCAN_ResetImaskBuff>:
 * Function Name : FlexCAN_ResetImaskBuff (uses in FlexCAN_Ip_Init function only)
 * Description   : Reset Imask Buffers.
 *
 *END**************************************************************************/
void FlexCAN_ResetImaskBuff(uint8 Instance)
{
    d2cc:	b084      	sub	sp, #16
    d2ce:	4603      	mov	r3, r0
    d2d0:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ImaskCnt = 0U;
    d2d4:	2300      	movs	r3, #0
    d2d6:	f88d 300f 	strb.w	r3, [sp, #15]

    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    d2da:	2300      	movs	r3, #0
    d2dc:	f88d 300f 	strb.w	r3, [sp, #15]
    d2e0:	e00d      	b.n	d2fe <FlexCAN_ResetImaskBuff+0x32>
    {
        FlexCAN_Ip_au32ImaskBuff[Instance][ImaskCnt] = 0U;
    d2e2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    d2e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d2ea:	4909      	ldr	r1, [pc, #36]	; (d310 <FlexCAN_ResetImaskBuff+0x44>)
    d2ec:	4413      	add	r3, r2
    d2ee:	2200      	movs	r2, #0
    d2f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    d2f4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d2f8:	3301      	adds	r3, #1
    d2fa:	f88d 300f 	strb.w	r3, [sp, #15]
    d2fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d302:	2b00      	cmp	r3, #0
    d304:	d0ed      	beq.n	d2e2 <FlexCAN_ResetImaskBuff+0x16>
    }
}
    d306:	bf00      	nop
    d308:	bf00      	nop
    d30a:	b004      	add	sp, #16
    d30c:	4770      	bx	lr
    d30e:	bf00      	nop
    d310:	1fff8fc4 	.word	0x1fff8fc4

0000d314 <CAN0_ORED_IRQHandler>:

#else

/* Implementation of CAN0 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN0_ORED_IRQHandler)
{
    d314:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(0U);
    d316:	2000      	movs	r0, #0
    d318:	f7fd fb2a 	bl	a970 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    d31c:	f3bf 8f4f 	dsb	sy
}
    d320:	bf00      	nop
    d322:	bd08      	pop	{r3, pc}

0000d324 <CAN0_Error_IRQHandler>:

/* Implementation of CAN0 handler named in startup code for processing of Errors reporting. */
ISR(CAN0_Error_IRQHandler)
{
    d324:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(0U);
    d326:	2000      	movs	r0, #0
    d328:	f7fd fac2 	bl	a8b0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    d32c:	f3bf 8f4f 	dsb	sy
}
    d330:	bf00      	nop
    d332:	bd08      	pop	{r3, pc}

0000d334 <CAN0_ORED_0_15_MB_IRQHandler>:
}
#endif
/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN0_ORED_0_15_MB_IRQHandler)
{
    d334:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 0U, 15U);
    d336:	220f      	movs	r2, #15
    d338:	2100      	movs	r1, #0
    d33a:	2000      	movs	r0, #0
    d33c:	f7fd f9dc 	bl	a6f8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    d340:	f3bf 8f4f 	dsb	sy
}
    d344:	bf00      	nop
    d346:	bd08      	pop	{r3, pc}

0000d348 <CAN0_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN0_ORED_16_31_MB_IRQHandler)
{
    d348:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 16U, 31U);
    d34a:	221f      	movs	r2, #31
    d34c:	2110      	movs	r1, #16
    d34e:	2000      	movs	r0, #0
    d350:	f7fd f9d2 	bl	a6f8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    d354:	f3bf 8f4f 	dsb	sy
}
    d358:	bf00      	nop
    d35a:	bd08      	pop	{r3, pc}

0000d35c <CAN1_ORED_IRQHandler>:
#endif /* (defined(S32K142W) || defined(S32K144W) || defined(S32M243) || defined(S32M244)) */

#if (FLEXCAN_INSTANCE_COUNT > 1U)
/* Implementation of CAN1 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN1_ORED_IRQHandler)
{
    d35c:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(1U);
    d35e:	2001      	movs	r0, #1
    d360:	f7fd fb06 	bl	a970 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    d364:	f3bf 8f4f 	dsb	sy
}
    d368:	bf00      	nop
    d36a:	bd08      	pop	{r3, pc}

0000d36c <CAN1_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN1_Error_IRQHandler)
{
    d36c:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(1U);
    d36e:	2001      	movs	r0, #1
    d370:	f7fd fa9e 	bl	a8b0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    d374:	f3bf 8f4f 	dsb	sy
}
    d378:	bf00      	nop
    d37a:	bd08      	pop	{r3, pc}

0000d37c <CAN1_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN1_ORED_0_15_MB_IRQHandler)
{
    d37c:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 0U, 15U);
    d37e:	220f      	movs	r2, #15
    d380:	2100      	movs	r1, #0
    d382:	2001      	movs	r0, #1
    d384:	f7fd f9b8 	bl	a6f8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    d388:	f3bf 8f4f 	dsb	sy
}
    d38c:	bf00      	nop
    d38e:	bd08      	pop	{r3, pc}

0000d390 <CAN1_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN1_ORED_16_31_MB_IRQHandler)
{
    d390:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 16U, 31U);
    d392:	221f      	movs	r2, #31
    d394:	2110      	movs	r1, #16
    d396:	2001      	movs	r0, #1
    d398:	f7fd f9ae 	bl	a6f8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    d39c:	f3bf 8f4f 	dsb	sy
}
    d3a0:	bf00      	nop
    d3a2:	bd08      	pop	{r3, pc}

0000d3a4 <CAN2_ORED_IRQHandler>:
#endif /* (FLEXCAN_INSTANCE_COUNT > 1U) */

#if (FLEXCAN_INSTANCE_COUNT > 2U)
/* Implementation of CAN2 handler named in startup code for processing of Errors and Bus Off reporting. */
ISR(CAN2_ORED_IRQHandler)
{
    d3a4:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(2U);
    d3a6:	2002      	movs	r0, #2
    d3a8:	f7fd fae2 	bl	a970 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    d3ac:	f3bf 8f4f 	dsb	sy
}
    d3b0:	bf00      	nop
    d3b2:	bd08      	pop	{r3, pc}

0000d3b4 <CAN2_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN2_Error_IRQHandler)
{
    d3b4:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(2U);
    d3b6:	2002      	movs	r0, #2
    d3b8:	f7fd fa7a 	bl	a8b0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    d3bc:	f3bf 8f4f 	dsb	sy
}
    d3c0:	bf00      	nop
    d3c2:	bd08      	pop	{r3, pc}

0000d3c4 <CAN2_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN2 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN2_ORED_0_15_MB_IRQHandler)
{
    d3c4:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(2U, 0U, 15U);
    d3c6:	220f      	movs	r2, #15
    d3c8:	2100      	movs	r1, #0
    d3ca:	2002      	movs	r0, #2
    d3cc:	f7fd f994 	bl	a6f8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    d3d0:	f3bf 8f4f 	dsb	sy
}
    d3d4:	bf00      	nop
    d3d6:	bd08      	pop	{r3, pc}

0000d3d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
    d3d8:	b500      	push	{lr}
    d3da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d3dc:	f7f3 ff50 	bl	1280 <Sys_GetCoreID>
    d3e0:	4603      	mov	r3, r0
    d3e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId])
    d3e4:	4a10      	ldr	r2, [pc, #64]	; (d428 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    d3e6:	9b01      	ldr	r3, [sp, #4]
    d3e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d3ec:	2b00      	cmp	r3, #0
    d3ee:	d10d      	bne.n	d40c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d3f0:	f7f3 fc5a 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d3f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d3f6:	9b00      	ldr	r3, [sp, #0]
    d3f8:	f003 0301 	and.w	r3, r3, #1
    d3fc:	2b00      	cmp	r3, #0
    d3fe:	d100      	bne.n	d402 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d400:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    d402:	490a      	ldr	r1, [pc, #40]	; (d42c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x54>)
    d404:	9b01      	ldr	r3, [sp, #4]
    d406:	9a00      	ldr	r2, [sp, #0]
    d408:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]++;
    d40c:	4a06      	ldr	r2, [pc, #24]	; (d428 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    d40e:	9b01      	ldr	r3, [sp, #4]
    d410:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d414:	1c5a      	adds	r2, r3, #1
    d416:	4904      	ldr	r1, [pc, #16]	; (d428 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    d418:	9b01      	ldr	r3, [sp, #4]
    d41a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d41e:	bf00      	nop
    d420:	b003      	add	sp, #12
    d422:	f85d fb04 	ldr.w	pc, [sp], #4
    d426:	bf00      	nop
    d428:	1fff8fd4 	.word	0x1fff8fd4
    d42c:	1fff8fd0 	.word	0x1fff8fd0

0000d430 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
    d430:	b500      	push	{lr}
    d432:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d434:	f7f3 ff24 	bl	1280 <Sys_GetCoreID>
    d438:	4603      	mov	r3, r0
    d43a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]--;
    d43c:	4a0d      	ldr	r2, [pc, #52]	; (d474 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    d43e:	9b01      	ldr	r3, [sp, #4]
    d440:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d444:	1e5a      	subs	r2, r3, #1
    d446:	490b      	ldr	r1, [pc, #44]	; (d474 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    d448:	9b01      	ldr	r3, [sp, #4]
    d44a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    d44e:	4a0a      	ldr	r2, [pc, #40]	; (d478 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x48>)
    d450:	9b01      	ldr	r3, [sp, #4]
    d452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d456:	f003 0301 	and.w	r3, r3, #1
    d45a:	2b00      	cmp	r3, #0
    d45c:	d106      	bne.n	d46c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    d45e:	4a05      	ldr	r2, [pc, #20]	; (d474 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    d460:	9b01      	ldr	r3, [sp, #4]
    d462:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d466:	2b00      	cmp	r3, #0
    d468:	d100      	bne.n	d46c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d46a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d46c:	bf00      	nop
    d46e:	b003      	add	sp, #12
    d470:	f85d fb04 	ldr.w	pc, [sp], #4
    d474:	1fff8fd4 	.word	0x1fff8fd4
    d478:	1fff8fd0 	.word	0x1fff8fd0

0000d47c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
    d47c:	b500      	push	{lr}
    d47e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d480:	f7f3 fefe 	bl	1280 <Sys_GetCoreID>
    d484:	4603      	mov	r3, r0
    d486:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId])
    d488:	4a10      	ldr	r2, [pc, #64]	; (d4cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    d48a:	9b01      	ldr	r3, [sp, #4]
    d48c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d490:	2b00      	cmp	r3, #0
    d492:	d10d      	bne.n	d4b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d494:	f7f3 fc08 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d498:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d49a:	9b00      	ldr	r3, [sp, #0]
    d49c:	f003 0301 	and.w	r3, r3, #1
    d4a0:	2b00      	cmp	r3, #0
    d4a2:	d100      	bne.n	d4a6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d4a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    d4a6:	490a      	ldr	r1, [pc, #40]	; (d4d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x54>)
    d4a8:	9b01      	ldr	r3, [sp, #4]
    d4aa:	9a00      	ldr	r2, [sp, #0]
    d4ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]++;
    d4b0:	4a06      	ldr	r2, [pc, #24]	; (d4cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    d4b2:	9b01      	ldr	r3, [sp, #4]
    d4b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d4b8:	1c5a      	adds	r2, r3, #1
    d4ba:	4904      	ldr	r1, [pc, #16]	; (d4cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    d4bc:	9b01      	ldr	r3, [sp, #4]
    d4be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d4c2:	bf00      	nop
    d4c4:	b003      	add	sp, #12
    d4c6:	f85d fb04 	ldr.w	pc, [sp], #4
    d4ca:	bf00      	nop
    d4cc:	1fff8fdc 	.word	0x1fff8fdc
    d4d0:	1fff8fd8 	.word	0x1fff8fd8

0000d4d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
    d4d4:	b500      	push	{lr}
    d4d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d4d8:	f7f3 fed2 	bl	1280 <Sys_GetCoreID>
    d4dc:	4603      	mov	r3, r0
    d4de:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]--;
    d4e0:	4a0d      	ldr	r2, [pc, #52]	; (d518 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    d4e2:	9b01      	ldr	r3, [sp, #4]
    d4e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d4e8:	1e5a      	subs	r2, r3, #1
    d4ea:	490b      	ldr	r1, [pc, #44]	; (d518 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    d4ec:	9b01      	ldr	r3, [sp, #4]
    d4ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    d4f2:	4a0a      	ldr	r2, [pc, #40]	; (d51c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x48>)
    d4f4:	9b01      	ldr	r3, [sp, #4]
    d4f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d4fa:	f003 0301 	and.w	r3, r3, #1
    d4fe:	2b00      	cmp	r3, #0
    d500:	d106      	bne.n	d510 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    d502:	4a05      	ldr	r2, [pc, #20]	; (d518 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    d504:	9b01      	ldr	r3, [sp, #4]
    d506:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d50a:	2b00      	cmp	r3, #0
    d50c:	d100      	bne.n	d510 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d50e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d510:	bf00      	nop
    d512:	b003      	add	sp, #12
    d514:	f85d fb04 	ldr.w	pc, [sp], #4
    d518:	1fff8fdc 	.word	0x1fff8fdc
    d51c:	1fff8fd8 	.word	0x1fff8fd8

0000d520 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
    d520:	b500      	push	{lr}
    d522:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d524:	f7f3 feac 	bl	1280 <Sys_GetCoreID>
    d528:	4603      	mov	r3, r0
    d52a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId])
    d52c:	4a10      	ldr	r2, [pc, #64]	; (d570 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    d52e:	9b01      	ldr	r3, [sp, #4]
    d530:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d534:	2b00      	cmp	r3, #0
    d536:	d10d      	bne.n	d554 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d538:	f7f3 fbb6 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d53c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d53e:	9b00      	ldr	r3, [sp, #0]
    d540:	f003 0301 	and.w	r3, r3, #1
    d544:	2b00      	cmp	r3, #0
    d546:	d100      	bne.n	d54a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d548:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    d54a:	490a      	ldr	r1, [pc, #40]	; (d574 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x54>)
    d54c:	9b01      	ldr	r3, [sp, #4]
    d54e:	9a00      	ldr	r2, [sp, #0]
    d550:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]++;
    d554:	4a06      	ldr	r2, [pc, #24]	; (d570 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    d556:	9b01      	ldr	r3, [sp, #4]
    d558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d55c:	1c5a      	adds	r2, r3, #1
    d55e:	4904      	ldr	r1, [pc, #16]	; (d570 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    d560:	9b01      	ldr	r3, [sp, #4]
    d562:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d566:	bf00      	nop
    d568:	b003      	add	sp, #12
    d56a:	f85d fb04 	ldr.w	pc, [sp], #4
    d56e:	bf00      	nop
    d570:	1fff8fe4 	.word	0x1fff8fe4
    d574:	1fff8fe0 	.word	0x1fff8fe0

0000d578 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
    d578:	b500      	push	{lr}
    d57a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d57c:	f7f3 fe80 	bl	1280 <Sys_GetCoreID>
    d580:	4603      	mov	r3, r0
    d582:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]--;
    d584:	4a0d      	ldr	r2, [pc, #52]	; (d5bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    d586:	9b01      	ldr	r3, [sp, #4]
    d588:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d58c:	1e5a      	subs	r2, r3, #1
    d58e:	490b      	ldr	r1, [pc, #44]	; (d5bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    d590:	9b01      	ldr	r3, [sp, #4]
    d592:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    d596:	4a0a      	ldr	r2, [pc, #40]	; (d5c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x48>)
    d598:	9b01      	ldr	r3, [sp, #4]
    d59a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d59e:	f003 0301 	and.w	r3, r3, #1
    d5a2:	2b00      	cmp	r3, #0
    d5a4:	d106      	bne.n	d5b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    d5a6:	4a05      	ldr	r2, [pc, #20]	; (d5bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    d5a8:	9b01      	ldr	r3, [sp, #4]
    d5aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d5ae:	2b00      	cmp	r3, #0
    d5b0:	d100      	bne.n	d5b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d5b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d5b4:	bf00      	nop
    d5b6:	b003      	add	sp, #12
    d5b8:	f85d fb04 	ldr.w	pc, [sp], #4
    d5bc:	1fff8fe4 	.word	0x1fff8fe4
    d5c0:	1fff8fe0 	.word	0x1fff8fe0

0000d5c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
    d5c4:	b500      	push	{lr}
    d5c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d5c8:	f7f3 fe5a 	bl	1280 <Sys_GetCoreID>
    d5cc:	4603      	mov	r3, r0
    d5ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId])
    d5d0:	4a10      	ldr	r2, [pc, #64]	; (d614 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    d5d2:	9b01      	ldr	r3, [sp, #4]
    d5d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d5d8:	2b00      	cmp	r3, #0
    d5da:	d10d      	bne.n	d5f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d5dc:	f7f3 fb64 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d5e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d5e2:	9b00      	ldr	r3, [sp, #0]
    d5e4:	f003 0301 	and.w	r3, r3, #1
    d5e8:	2b00      	cmp	r3, #0
    d5ea:	d100      	bne.n	d5ee <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d5ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    d5ee:	490a      	ldr	r1, [pc, #40]	; (d618 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x54>)
    d5f0:	9b01      	ldr	r3, [sp, #4]
    d5f2:	9a00      	ldr	r2, [sp, #0]
    d5f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]++;
    d5f8:	4a06      	ldr	r2, [pc, #24]	; (d614 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    d5fa:	9b01      	ldr	r3, [sp, #4]
    d5fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d600:	1c5a      	adds	r2, r3, #1
    d602:	4904      	ldr	r1, [pc, #16]	; (d614 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    d604:	9b01      	ldr	r3, [sp, #4]
    d606:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d60a:	bf00      	nop
    d60c:	b003      	add	sp, #12
    d60e:	f85d fb04 	ldr.w	pc, [sp], #4
    d612:	bf00      	nop
    d614:	1fff8fec 	.word	0x1fff8fec
    d618:	1fff8fe8 	.word	0x1fff8fe8

0000d61c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
    d61c:	b500      	push	{lr}
    d61e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d620:	f7f3 fe2e 	bl	1280 <Sys_GetCoreID>
    d624:	4603      	mov	r3, r0
    d626:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]--;
    d628:	4a0d      	ldr	r2, [pc, #52]	; (d660 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    d62a:	9b01      	ldr	r3, [sp, #4]
    d62c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d630:	1e5a      	subs	r2, r3, #1
    d632:	490b      	ldr	r1, [pc, #44]	; (d660 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    d634:	9b01      	ldr	r3, [sp, #4]
    d636:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    d63a:	4a0a      	ldr	r2, [pc, #40]	; (d664 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x48>)
    d63c:	9b01      	ldr	r3, [sp, #4]
    d63e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d642:	f003 0301 	and.w	r3, r3, #1
    d646:	2b00      	cmp	r3, #0
    d648:	d106      	bne.n	d658 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    d64a:	4a05      	ldr	r2, [pc, #20]	; (d660 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    d64c:	9b01      	ldr	r3, [sp, #4]
    d64e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d652:	2b00      	cmp	r3, #0
    d654:	d100      	bne.n	d658 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d656:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d658:	bf00      	nop
    d65a:	b003      	add	sp, #12
    d65c:	f85d fb04 	ldr.w	pc, [sp], #4
    d660:	1fff8fec 	.word	0x1fff8fec
    d664:	1fff8fe8 	.word	0x1fff8fe8

0000d668 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
    d668:	b500      	push	{lr}
    d66a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d66c:	f7f3 fe08 	bl	1280 <Sys_GetCoreID>
    d670:	4603      	mov	r3, r0
    d672:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId])
    d674:	4a10      	ldr	r2, [pc, #64]	; (d6b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    d676:	9b01      	ldr	r3, [sp, #4]
    d678:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d67c:	2b00      	cmp	r3, #0
    d67e:	d10d      	bne.n	d69c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d680:	f7f3 fb12 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d684:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d686:	9b00      	ldr	r3, [sp, #0]
    d688:	f003 0301 	and.w	r3, r3, #1
    d68c:	2b00      	cmp	r3, #0
    d68e:	d100      	bne.n	d692 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d690:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    d692:	490a      	ldr	r1, [pc, #40]	; (d6bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x54>)
    d694:	9b01      	ldr	r3, [sp, #4]
    d696:	9a00      	ldr	r2, [sp, #0]
    d698:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]++;
    d69c:	4a06      	ldr	r2, [pc, #24]	; (d6b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    d69e:	9b01      	ldr	r3, [sp, #4]
    d6a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d6a4:	1c5a      	adds	r2, r3, #1
    d6a6:	4904      	ldr	r1, [pc, #16]	; (d6b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    d6a8:	9b01      	ldr	r3, [sp, #4]
    d6aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d6ae:	bf00      	nop
    d6b0:	b003      	add	sp, #12
    d6b2:	f85d fb04 	ldr.w	pc, [sp], #4
    d6b6:	bf00      	nop
    d6b8:	1fff8ff4 	.word	0x1fff8ff4
    d6bc:	1fff8ff0 	.word	0x1fff8ff0

0000d6c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
    d6c0:	b500      	push	{lr}
    d6c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d6c4:	f7f3 fddc 	bl	1280 <Sys_GetCoreID>
    d6c8:	4603      	mov	r3, r0
    d6ca:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]--;
    d6cc:	4a0d      	ldr	r2, [pc, #52]	; (d704 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    d6ce:	9b01      	ldr	r3, [sp, #4]
    d6d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d6d4:	1e5a      	subs	r2, r3, #1
    d6d6:	490b      	ldr	r1, [pc, #44]	; (d704 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    d6d8:	9b01      	ldr	r3, [sp, #4]
    d6da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    d6de:	4a0a      	ldr	r2, [pc, #40]	; (d708 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x48>)
    d6e0:	9b01      	ldr	r3, [sp, #4]
    d6e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d6e6:	f003 0301 	and.w	r3, r3, #1
    d6ea:	2b00      	cmp	r3, #0
    d6ec:	d106      	bne.n	d6fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    d6ee:	4a05      	ldr	r2, [pc, #20]	; (d704 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    d6f0:	9b01      	ldr	r3, [sp, #4]
    d6f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d6f6:	2b00      	cmp	r3, #0
    d6f8:	d100      	bne.n	d6fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d6fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d6fc:	bf00      	nop
    d6fe:	b003      	add	sp, #12
    d700:	f85d fb04 	ldr.w	pc, [sp], #4
    d704:	1fff8ff4 	.word	0x1fff8ff4
    d708:	1fff8ff0 	.word	0x1fff8ff0

0000d70c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
    d70c:	b500      	push	{lr}
    d70e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d710:	f7f3 fdb6 	bl	1280 <Sys_GetCoreID>
    d714:	4603      	mov	r3, r0
    d716:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId])
    d718:	4a10      	ldr	r2, [pc, #64]	; (d75c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    d71a:	9b01      	ldr	r3, [sp, #4]
    d71c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d720:	2b00      	cmp	r3, #0
    d722:	d10d      	bne.n	d740 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d724:	f7f3 fac0 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d728:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d72a:	9b00      	ldr	r3, [sp, #0]
    d72c:	f003 0301 	and.w	r3, r3, #1
    d730:	2b00      	cmp	r3, #0
    d732:	d100      	bne.n	d736 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d734:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    d736:	490a      	ldr	r1, [pc, #40]	; (d760 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x54>)
    d738:	9b01      	ldr	r3, [sp, #4]
    d73a:	9a00      	ldr	r2, [sp, #0]
    d73c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]++;
    d740:	4a06      	ldr	r2, [pc, #24]	; (d75c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    d742:	9b01      	ldr	r3, [sp, #4]
    d744:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d748:	1c5a      	adds	r2, r3, #1
    d74a:	4904      	ldr	r1, [pc, #16]	; (d75c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    d74c:	9b01      	ldr	r3, [sp, #4]
    d74e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d752:	bf00      	nop
    d754:	b003      	add	sp, #12
    d756:	f85d fb04 	ldr.w	pc, [sp], #4
    d75a:	bf00      	nop
    d75c:	1fff8ffc 	.word	0x1fff8ffc
    d760:	1fff8ff8 	.word	0x1fff8ff8

0000d764 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
    d764:	b500      	push	{lr}
    d766:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d768:	f7f3 fd8a 	bl	1280 <Sys_GetCoreID>
    d76c:	4603      	mov	r3, r0
    d76e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]--;
    d770:	4a0d      	ldr	r2, [pc, #52]	; (d7a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    d772:	9b01      	ldr	r3, [sp, #4]
    d774:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d778:	1e5a      	subs	r2, r3, #1
    d77a:	490b      	ldr	r1, [pc, #44]	; (d7a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    d77c:	9b01      	ldr	r3, [sp, #4]
    d77e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    d782:	4a0a      	ldr	r2, [pc, #40]	; (d7ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x48>)
    d784:	9b01      	ldr	r3, [sp, #4]
    d786:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d78a:	f003 0301 	and.w	r3, r3, #1
    d78e:	2b00      	cmp	r3, #0
    d790:	d106      	bne.n	d7a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    d792:	4a05      	ldr	r2, [pc, #20]	; (d7a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    d794:	9b01      	ldr	r3, [sp, #4]
    d796:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d79a:	2b00      	cmp	r3, #0
    d79c:	d100      	bne.n	d7a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d79e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d7a0:	bf00      	nop
    d7a2:	b003      	add	sp, #12
    d7a4:	f85d fb04 	ldr.w	pc, [sp], #4
    d7a8:	1fff8ffc 	.word	0x1fff8ffc
    d7ac:	1fff8ff8 	.word	0x1fff8ff8

0000d7b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
    d7b0:	b500      	push	{lr}
    d7b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d7b4:	f7f3 fd64 	bl	1280 <Sys_GetCoreID>
    d7b8:	4603      	mov	r3, r0
    d7ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId])
    d7bc:	4a10      	ldr	r2, [pc, #64]	; (d800 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    d7be:	9b01      	ldr	r3, [sp, #4]
    d7c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d7c4:	2b00      	cmp	r3, #0
    d7c6:	d10d      	bne.n	d7e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d7c8:	f7f3 fa6e 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d7cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d7ce:	9b00      	ldr	r3, [sp, #0]
    d7d0:	f003 0301 	and.w	r3, r3, #1
    d7d4:	2b00      	cmp	r3, #0
    d7d6:	d100      	bne.n	d7da <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d7d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    d7da:	490a      	ldr	r1, [pc, #40]	; (d804 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x54>)
    d7dc:	9b01      	ldr	r3, [sp, #4]
    d7de:	9a00      	ldr	r2, [sp, #0]
    d7e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]++;
    d7e4:	4a06      	ldr	r2, [pc, #24]	; (d800 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    d7e6:	9b01      	ldr	r3, [sp, #4]
    d7e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d7ec:	1c5a      	adds	r2, r3, #1
    d7ee:	4904      	ldr	r1, [pc, #16]	; (d800 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    d7f0:	9b01      	ldr	r3, [sp, #4]
    d7f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d7f6:	bf00      	nop
    d7f8:	b003      	add	sp, #12
    d7fa:	f85d fb04 	ldr.w	pc, [sp], #4
    d7fe:	bf00      	nop
    d800:	1fff9004 	.word	0x1fff9004
    d804:	1fff9000 	.word	0x1fff9000

0000d808 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
    d808:	b500      	push	{lr}
    d80a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d80c:	f7f3 fd38 	bl	1280 <Sys_GetCoreID>
    d810:	4603      	mov	r3, r0
    d812:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]--;
    d814:	4a0d      	ldr	r2, [pc, #52]	; (d84c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    d816:	9b01      	ldr	r3, [sp, #4]
    d818:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d81c:	1e5a      	subs	r2, r3, #1
    d81e:	490b      	ldr	r1, [pc, #44]	; (d84c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    d820:	9b01      	ldr	r3, [sp, #4]
    d822:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    d826:	4a0a      	ldr	r2, [pc, #40]	; (d850 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x48>)
    d828:	9b01      	ldr	r3, [sp, #4]
    d82a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d82e:	f003 0301 	and.w	r3, r3, #1
    d832:	2b00      	cmp	r3, #0
    d834:	d106      	bne.n	d844 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    d836:	4a05      	ldr	r2, [pc, #20]	; (d84c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    d838:	9b01      	ldr	r3, [sp, #4]
    d83a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d83e:	2b00      	cmp	r3, #0
    d840:	d100      	bne.n	d844 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d842:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d844:	bf00      	nop
    d846:	b003      	add	sp, #12
    d848:	f85d fb04 	ldr.w	pc, [sp], #4
    d84c:	1fff9004 	.word	0x1fff9004
    d850:	1fff9000 	.word	0x1fff9000

0000d854 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
    d854:	b500      	push	{lr}
    d856:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d858:	f7f3 fd12 	bl	1280 <Sys_GetCoreID>
    d85c:	4603      	mov	r3, r0
    d85e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId])
    d860:	4a10      	ldr	r2, [pc, #64]	; (d8a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    d862:	9b01      	ldr	r3, [sp, #4]
    d864:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d868:	2b00      	cmp	r3, #0
    d86a:	d10d      	bne.n	d888 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d86c:	f7f3 fa1c 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d870:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d872:	9b00      	ldr	r3, [sp, #0]
    d874:	f003 0301 	and.w	r3, r3, #1
    d878:	2b00      	cmp	r3, #0
    d87a:	d100      	bne.n	d87e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d87c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    d87e:	490a      	ldr	r1, [pc, #40]	; (d8a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x54>)
    d880:	9b01      	ldr	r3, [sp, #4]
    d882:	9a00      	ldr	r2, [sp, #0]
    d884:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]++;
    d888:	4a06      	ldr	r2, [pc, #24]	; (d8a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    d88a:	9b01      	ldr	r3, [sp, #4]
    d88c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d890:	1c5a      	adds	r2, r3, #1
    d892:	4904      	ldr	r1, [pc, #16]	; (d8a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    d894:	9b01      	ldr	r3, [sp, #4]
    d896:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d89a:	bf00      	nop
    d89c:	b003      	add	sp, #12
    d89e:	f85d fb04 	ldr.w	pc, [sp], #4
    d8a2:	bf00      	nop
    d8a4:	1fff900c 	.word	0x1fff900c
    d8a8:	1fff9008 	.word	0x1fff9008

0000d8ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
    d8ac:	b500      	push	{lr}
    d8ae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d8b0:	f7f3 fce6 	bl	1280 <Sys_GetCoreID>
    d8b4:	4603      	mov	r3, r0
    d8b6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]--;
    d8b8:	4a0d      	ldr	r2, [pc, #52]	; (d8f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    d8ba:	9b01      	ldr	r3, [sp, #4]
    d8bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d8c0:	1e5a      	subs	r2, r3, #1
    d8c2:	490b      	ldr	r1, [pc, #44]	; (d8f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    d8c4:	9b01      	ldr	r3, [sp, #4]
    d8c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    d8ca:	4a0a      	ldr	r2, [pc, #40]	; (d8f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x48>)
    d8cc:	9b01      	ldr	r3, [sp, #4]
    d8ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d8d2:	f003 0301 	and.w	r3, r3, #1
    d8d6:	2b00      	cmp	r3, #0
    d8d8:	d106      	bne.n	d8e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    d8da:	4a05      	ldr	r2, [pc, #20]	; (d8f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    d8dc:	9b01      	ldr	r3, [sp, #4]
    d8de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d8e2:	2b00      	cmp	r3, #0
    d8e4:	d100      	bne.n	d8e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d8e6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d8e8:	bf00      	nop
    d8ea:	b003      	add	sp, #12
    d8ec:	f85d fb04 	ldr.w	pc, [sp], #4
    d8f0:	1fff900c 	.word	0x1fff900c
    d8f4:	1fff9008 	.word	0x1fff9008

0000d8f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
    d8f8:	b500      	push	{lr}
    d8fa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d8fc:	f7f3 fcc0 	bl	1280 <Sys_GetCoreID>
    d900:	4603      	mov	r3, r0
    d902:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId])
    d904:	4a10      	ldr	r2, [pc, #64]	; (d948 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    d906:	9b01      	ldr	r3, [sp, #4]
    d908:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d90c:	2b00      	cmp	r3, #0
    d90e:	d10d      	bne.n	d92c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d910:	f7f3 f9ca 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d914:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d916:	9b00      	ldr	r3, [sp, #0]
    d918:	f003 0301 	and.w	r3, r3, #1
    d91c:	2b00      	cmp	r3, #0
    d91e:	d100      	bne.n	d922 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d920:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    d922:	490a      	ldr	r1, [pc, #40]	; (d94c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x54>)
    d924:	9b01      	ldr	r3, [sp, #4]
    d926:	9a00      	ldr	r2, [sp, #0]
    d928:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]++;
    d92c:	4a06      	ldr	r2, [pc, #24]	; (d948 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    d92e:	9b01      	ldr	r3, [sp, #4]
    d930:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d934:	1c5a      	adds	r2, r3, #1
    d936:	4904      	ldr	r1, [pc, #16]	; (d948 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    d938:	9b01      	ldr	r3, [sp, #4]
    d93a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d93e:	bf00      	nop
    d940:	b003      	add	sp, #12
    d942:	f85d fb04 	ldr.w	pc, [sp], #4
    d946:	bf00      	nop
    d948:	1fff9014 	.word	0x1fff9014
    d94c:	1fff9010 	.word	0x1fff9010

0000d950 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
    d950:	b500      	push	{lr}
    d952:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d954:	f7f3 fc94 	bl	1280 <Sys_GetCoreID>
    d958:	4603      	mov	r3, r0
    d95a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]--;
    d95c:	4a0d      	ldr	r2, [pc, #52]	; (d994 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    d95e:	9b01      	ldr	r3, [sp, #4]
    d960:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d964:	1e5a      	subs	r2, r3, #1
    d966:	490b      	ldr	r1, [pc, #44]	; (d994 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    d968:	9b01      	ldr	r3, [sp, #4]
    d96a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    d96e:	4a0a      	ldr	r2, [pc, #40]	; (d998 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x48>)
    d970:	9b01      	ldr	r3, [sp, #4]
    d972:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d976:	f003 0301 	and.w	r3, r3, #1
    d97a:	2b00      	cmp	r3, #0
    d97c:	d106      	bne.n	d98c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    d97e:	4a05      	ldr	r2, [pc, #20]	; (d994 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    d980:	9b01      	ldr	r3, [sp, #4]
    d982:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d986:	2b00      	cmp	r3, #0
    d988:	d100      	bne.n	d98c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    d98a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    d98c:	bf00      	nop
    d98e:	b003      	add	sp, #12
    d990:	f85d fb04 	ldr.w	pc, [sp], #4
    d994:	1fff9014 	.word	0x1fff9014
    d998:	1fff9010 	.word	0x1fff9010

0000d99c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
    d99c:	b500      	push	{lr}
    d99e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d9a0:	f7f3 fc6e 	bl	1280 <Sys_GetCoreID>
    d9a4:	4603      	mov	r3, r0
    d9a6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId])
    d9a8:	4a10      	ldr	r2, [pc, #64]	; (d9ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    d9aa:	9b01      	ldr	r3, [sp, #4]
    d9ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d9b0:	2b00      	cmp	r3, #0
    d9b2:	d10d      	bne.n	d9d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    d9b4:	f7f3 f978 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    d9b8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    d9ba:	9b00      	ldr	r3, [sp, #0]
    d9bc:	f003 0301 	and.w	r3, r3, #1
    d9c0:	2b00      	cmp	r3, #0
    d9c2:	d100      	bne.n	d9c6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    d9c4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    d9c6:	490a      	ldr	r1, [pc, #40]	; (d9f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x54>)
    d9c8:	9b01      	ldr	r3, [sp, #4]
    d9ca:	9a00      	ldr	r2, [sp, #0]
    d9cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]++;
    d9d0:	4a06      	ldr	r2, [pc, #24]	; (d9ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    d9d2:	9b01      	ldr	r3, [sp, #4]
    d9d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d9d8:	1c5a      	adds	r2, r3, #1
    d9da:	4904      	ldr	r1, [pc, #16]	; (d9ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    d9dc:	9b01      	ldr	r3, [sp, #4]
    d9de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    d9e2:	bf00      	nop
    d9e4:	b003      	add	sp, #12
    d9e6:	f85d fb04 	ldr.w	pc, [sp], #4
    d9ea:	bf00      	nop
    d9ec:	1fff901c 	.word	0x1fff901c
    d9f0:	1fff9018 	.word	0x1fff9018

0000d9f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
    d9f4:	b500      	push	{lr}
    d9f6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    d9f8:	f7f3 fc42 	bl	1280 <Sys_GetCoreID>
    d9fc:	4603      	mov	r3, r0
    d9fe:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]--;
    da00:	4a0d      	ldr	r2, [pc, #52]	; (da38 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    da02:	9b01      	ldr	r3, [sp, #4]
    da04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da08:	1e5a      	subs	r2, r3, #1
    da0a:	490b      	ldr	r1, [pc, #44]	; (da38 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    da0c:	9b01      	ldr	r3, [sp, #4]
    da0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    da12:	4a0a      	ldr	r2, [pc, #40]	; (da3c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x48>)
    da14:	9b01      	ldr	r3, [sp, #4]
    da16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da1a:	f003 0301 	and.w	r3, r3, #1
    da1e:	2b00      	cmp	r3, #0
    da20:	d106      	bne.n	da30 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    da22:	4a05      	ldr	r2, [pc, #20]	; (da38 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    da24:	9b01      	ldr	r3, [sp, #4]
    da26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da2a:	2b00      	cmp	r3, #0
    da2c:	d100      	bne.n	da30 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    da2e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    da30:	bf00      	nop
    da32:	b003      	add	sp, #12
    da34:	f85d fb04 	ldr.w	pc, [sp], #4
    da38:	1fff901c 	.word	0x1fff901c
    da3c:	1fff9018 	.word	0x1fff9018

0000da40 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
    da40:	b500      	push	{lr}
    da42:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    da44:	f7f3 fc1c 	bl	1280 <Sys_GetCoreID>
    da48:	4603      	mov	r3, r0
    da4a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId])
    da4c:	4a10      	ldr	r2, [pc, #64]	; (da90 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    da4e:	9b01      	ldr	r3, [sp, #4]
    da50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da54:	2b00      	cmp	r3, #0
    da56:	d10d      	bne.n	da74 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    da58:	f7f3 f926 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    da5c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    da5e:	9b00      	ldr	r3, [sp, #0]
    da60:	f003 0301 	and.w	r3, r3, #1
    da64:	2b00      	cmp	r3, #0
    da66:	d100      	bne.n	da6a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    da68:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    da6a:	490a      	ldr	r1, [pc, #40]	; (da94 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x54>)
    da6c:	9b01      	ldr	r3, [sp, #4]
    da6e:	9a00      	ldr	r2, [sp, #0]
    da70:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]++;
    da74:	4a06      	ldr	r2, [pc, #24]	; (da90 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    da76:	9b01      	ldr	r3, [sp, #4]
    da78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da7c:	1c5a      	adds	r2, r3, #1
    da7e:	4904      	ldr	r1, [pc, #16]	; (da90 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    da80:	9b01      	ldr	r3, [sp, #4]
    da82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    da86:	bf00      	nop
    da88:	b003      	add	sp, #12
    da8a:	f85d fb04 	ldr.w	pc, [sp], #4
    da8e:	bf00      	nop
    da90:	1fff9024 	.word	0x1fff9024
    da94:	1fff9020 	.word	0x1fff9020

0000da98 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
    da98:	b500      	push	{lr}
    da9a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    da9c:	f7f3 fbf0 	bl	1280 <Sys_GetCoreID>
    daa0:	4603      	mov	r3, r0
    daa2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]--;
    daa4:	4a0d      	ldr	r2, [pc, #52]	; (dadc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    daa6:	9b01      	ldr	r3, [sp, #4]
    daa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    daac:	1e5a      	subs	r2, r3, #1
    daae:	490b      	ldr	r1, [pc, #44]	; (dadc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    dab0:	9b01      	ldr	r3, [sp, #4]
    dab2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    dab6:	4a0a      	ldr	r2, [pc, #40]	; (dae0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x48>)
    dab8:	9b01      	ldr	r3, [sp, #4]
    daba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dabe:	f003 0301 	and.w	r3, r3, #1
    dac2:	2b00      	cmp	r3, #0
    dac4:	d106      	bne.n	dad4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    dac6:	4a05      	ldr	r2, [pc, #20]	; (dadc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    dac8:	9b01      	ldr	r3, [sp, #4]
    daca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dace:	2b00      	cmp	r3, #0
    dad0:	d100      	bne.n	dad4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    dad2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    dad4:	bf00      	nop
    dad6:	b003      	add	sp, #12
    dad8:	f85d fb04 	ldr.w	pc, [sp], #4
    dadc:	1fff9024 	.word	0x1fff9024
    dae0:	1fff9020 	.word	0x1fff9020

0000dae4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
    dae4:	b500      	push	{lr}
    dae6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dae8:	f7f3 fbca 	bl	1280 <Sys_GetCoreID>
    daec:	4603      	mov	r3, r0
    daee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId])
    daf0:	4a10      	ldr	r2, [pc, #64]	; (db34 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    daf2:	9b01      	ldr	r3, [sp, #4]
    daf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    daf8:	2b00      	cmp	r3, #0
    dafa:	d10d      	bne.n	db18 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    dafc:	f7f3 f8d4 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    db00:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    db02:	9b00      	ldr	r3, [sp, #0]
    db04:	f003 0301 	and.w	r3, r3, #1
    db08:	2b00      	cmp	r3, #0
    db0a:	d100      	bne.n	db0e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    db0c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    db0e:	490a      	ldr	r1, [pc, #40]	; (db38 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x54>)
    db10:	9b01      	ldr	r3, [sp, #4]
    db12:	9a00      	ldr	r2, [sp, #0]
    db14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]++;
    db18:	4a06      	ldr	r2, [pc, #24]	; (db34 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    db1a:	9b01      	ldr	r3, [sp, #4]
    db1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    db20:	1c5a      	adds	r2, r3, #1
    db22:	4904      	ldr	r1, [pc, #16]	; (db34 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    db24:	9b01      	ldr	r3, [sp, #4]
    db26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    db2a:	bf00      	nop
    db2c:	b003      	add	sp, #12
    db2e:	f85d fb04 	ldr.w	pc, [sp], #4
    db32:	bf00      	nop
    db34:	1fff902c 	.word	0x1fff902c
    db38:	1fff9028 	.word	0x1fff9028

0000db3c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
    db3c:	b500      	push	{lr}
    db3e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    db40:	f7f3 fb9e 	bl	1280 <Sys_GetCoreID>
    db44:	4603      	mov	r3, r0
    db46:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]--;
    db48:	4a0d      	ldr	r2, [pc, #52]	; (db80 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    db4a:	9b01      	ldr	r3, [sp, #4]
    db4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    db50:	1e5a      	subs	r2, r3, #1
    db52:	490b      	ldr	r1, [pc, #44]	; (db80 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    db54:	9b01      	ldr	r3, [sp, #4]
    db56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    db5a:	4a0a      	ldr	r2, [pc, #40]	; (db84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x48>)
    db5c:	9b01      	ldr	r3, [sp, #4]
    db5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    db62:	f003 0301 	and.w	r3, r3, #1
    db66:	2b00      	cmp	r3, #0
    db68:	d106      	bne.n	db78 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    db6a:	4a05      	ldr	r2, [pc, #20]	; (db80 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    db6c:	9b01      	ldr	r3, [sp, #4]
    db6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    db72:	2b00      	cmp	r3, #0
    db74:	d100      	bne.n	db78 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    db76:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    db78:	bf00      	nop
    db7a:	b003      	add	sp, #12
    db7c:	f85d fb04 	ldr.w	pc, [sp], #4
    db80:	1fff902c 	.word	0x1fff902c
    db84:	1fff9028 	.word	0x1fff9028

0000db88 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
    db88:	b500      	push	{lr}
    db8a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    db8c:	f7f3 fb78 	bl	1280 <Sys_GetCoreID>
    db90:	4603      	mov	r3, r0
    db92:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId])
    db94:	4a10      	ldr	r2, [pc, #64]	; (dbd8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    db96:	9b01      	ldr	r3, [sp, #4]
    db98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    db9c:	2b00      	cmp	r3, #0
    db9e:	d10d      	bne.n	dbbc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    dba0:	f7f3 f882 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    dba4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    dba6:	9b00      	ldr	r3, [sp, #0]
    dba8:	f003 0301 	and.w	r3, r3, #1
    dbac:	2b00      	cmp	r3, #0
    dbae:	d100      	bne.n	dbb2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    dbb0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    dbb2:	490a      	ldr	r1, [pc, #40]	; (dbdc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x54>)
    dbb4:	9b01      	ldr	r3, [sp, #4]
    dbb6:	9a00      	ldr	r2, [sp, #0]
    dbb8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]++;
    dbbc:	4a06      	ldr	r2, [pc, #24]	; (dbd8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    dbbe:	9b01      	ldr	r3, [sp, #4]
    dbc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dbc4:	1c5a      	adds	r2, r3, #1
    dbc6:	4904      	ldr	r1, [pc, #16]	; (dbd8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    dbc8:	9b01      	ldr	r3, [sp, #4]
    dbca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    dbce:	bf00      	nop
    dbd0:	b003      	add	sp, #12
    dbd2:	f85d fb04 	ldr.w	pc, [sp], #4
    dbd6:	bf00      	nop
    dbd8:	1fff9034 	.word	0x1fff9034
    dbdc:	1fff9030 	.word	0x1fff9030

0000dbe0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
    dbe0:	b500      	push	{lr}
    dbe2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dbe4:	f7f3 fb4c 	bl	1280 <Sys_GetCoreID>
    dbe8:	4603      	mov	r3, r0
    dbea:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]--;
    dbec:	4a0d      	ldr	r2, [pc, #52]	; (dc24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    dbee:	9b01      	ldr	r3, [sp, #4]
    dbf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dbf4:	1e5a      	subs	r2, r3, #1
    dbf6:	490b      	ldr	r1, [pc, #44]	; (dc24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    dbf8:	9b01      	ldr	r3, [sp, #4]
    dbfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    dbfe:	4a0a      	ldr	r2, [pc, #40]	; (dc28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x48>)
    dc00:	9b01      	ldr	r3, [sp, #4]
    dc02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc06:	f003 0301 	and.w	r3, r3, #1
    dc0a:	2b00      	cmp	r3, #0
    dc0c:	d106      	bne.n	dc1c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    dc0e:	4a05      	ldr	r2, [pc, #20]	; (dc24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    dc10:	9b01      	ldr	r3, [sp, #4]
    dc12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc16:	2b00      	cmp	r3, #0
    dc18:	d100      	bne.n	dc1c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    dc1a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    dc1c:	bf00      	nop
    dc1e:	b003      	add	sp, #12
    dc20:	f85d fb04 	ldr.w	pc, [sp], #4
    dc24:	1fff9034 	.word	0x1fff9034
    dc28:	1fff9030 	.word	0x1fff9030

0000dc2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
    dc2c:	b500      	push	{lr}
    dc2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dc30:	f7f3 fb26 	bl	1280 <Sys_GetCoreID>
    dc34:	4603      	mov	r3, r0
    dc36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId])
    dc38:	4a10      	ldr	r2, [pc, #64]	; (dc7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    dc3a:	9b01      	ldr	r3, [sp, #4]
    dc3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc40:	2b00      	cmp	r3, #0
    dc42:	d10d      	bne.n	dc60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    dc44:	f7f3 f830 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    dc48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    dc4a:	9b00      	ldr	r3, [sp, #0]
    dc4c:	f003 0301 	and.w	r3, r3, #1
    dc50:	2b00      	cmp	r3, #0
    dc52:	d100      	bne.n	dc56 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    dc54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    dc56:	490a      	ldr	r1, [pc, #40]	; (dc80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x54>)
    dc58:	9b01      	ldr	r3, [sp, #4]
    dc5a:	9a00      	ldr	r2, [sp, #0]
    dc5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]++;
    dc60:	4a06      	ldr	r2, [pc, #24]	; (dc7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    dc62:	9b01      	ldr	r3, [sp, #4]
    dc64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc68:	1c5a      	adds	r2, r3, #1
    dc6a:	4904      	ldr	r1, [pc, #16]	; (dc7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    dc6c:	9b01      	ldr	r3, [sp, #4]
    dc6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    dc72:	bf00      	nop
    dc74:	b003      	add	sp, #12
    dc76:	f85d fb04 	ldr.w	pc, [sp], #4
    dc7a:	bf00      	nop
    dc7c:	1fff903c 	.word	0x1fff903c
    dc80:	1fff9038 	.word	0x1fff9038

0000dc84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
    dc84:	b500      	push	{lr}
    dc86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dc88:	f7f3 fafa 	bl	1280 <Sys_GetCoreID>
    dc8c:	4603      	mov	r3, r0
    dc8e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]--;
    dc90:	4a0d      	ldr	r2, [pc, #52]	; (dcc8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    dc92:	9b01      	ldr	r3, [sp, #4]
    dc94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc98:	1e5a      	subs	r2, r3, #1
    dc9a:	490b      	ldr	r1, [pc, #44]	; (dcc8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    dc9c:	9b01      	ldr	r3, [sp, #4]
    dc9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    dca2:	4a0a      	ldr	r2, [pc, #40]	; (dccc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x48>)
    dca4:	9b01      	ldr	r3, [sp, #4]
    dca6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dcaa:	f003 0301 	and.w	r3, r3, #1
    dcae:	2b00      	cmp	r3, #0
    dcb0:	d106      	bne.n	dcc0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    dcb2:	4a05      	ldr	r2, [pc, #20]	; (dcc8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    dcb4:	9b01      	ldr	r3, [sp, #4]
    dcb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dcba:	2b00      	cmp	r3, #0
    dcbc:	d100      	bne.n	dcc0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    dcbe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    dcc0:	bf00      	nop
    dcc2:	b003      	add	sp, #12
    dcc4:	f85d fb04 	ldr.w	pc, [sp], #4
    dcc8:	1fff903c 	.word	0x1fff903c
    dccc:	1fff9038 	.word	0x1fff9038

0000dcd0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
    dcd0:	b500      	push	{lr}
    dcd2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dcd4:	f7f3 fad4 	bl	1280 <Sys_GetCoreID>
    dcd8:	4603      	mov	r3, r0
    dcda:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId])
    dcdc:	4a10      	ldr	r2, [pc, #64]	; (dd20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    dcde:	9b01      	ldr	r3, [sp, #4]
    dce0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dce4:	2b00      	cmp	r3, #0
    dce6:	d10d      	bne.n	dd04 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    dce8:	f7f2 ffde 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    dcec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    dcee:	9b00      	ldr	r3, [sp, #0]
    dcf0:	f003 0301 	and.w	r3, r3, #1
    dcf4:	2b00      	cmp	r3, #0
    dcf6:	d100      	bne.n	dcfa <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    dcf8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    dcfa:	490a      	ldr	r1, [pc, #40]	; (dd24 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x54>)
    dcfc:	9b01      	ldr	r3, [sp, #4]
    dcfe:	9a00      	ldr	r2, [sp, #0]
    dd00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]++;
    dd04:	4a06      	ldr	r2, [pc, #24]	; (dd20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    dd06:	9b01      	ldr	r3, [sp, #4]
    dd08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd0c:	1c5a      	adds	r2, r3, #1
    dd0e:	4904      	ldr	r1, [pc, #16]	; (dd20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    dd10:	9b01      	ldr	r3, [sp, #4]
    dd12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    dd16:	bf00      	nop
    dd18:	b003      	add	sp, #12
    dd1a:	f85d fb04 	ldr.w	pc, [sp], #4
    dd1e:	bf00      	nop
    dd20:	1fff9044 	.word	0x1fff9044
    dd24:	1fff9040 	.word	0x1fff9040

0000dd28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
    dd28:	b500      	push	{lr}
    dd2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dd2c:	f7f3 faa8 	bl	1280 <Sys_GetCoreID>
    dd30:	4603      	mov	r3, r0
    dd32:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]--;
    dd34:	4a0d      	ldr	r2, [pc, #52]	; (dd6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    dd36:	9b01      	ldr	r3, [sp, #4]
    dd38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd3c:	1e5a      	subs	r2, r3, #1
    dd3e:	490b      	ldr	r1, [pc, #44]	; (dd6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    dd40:	9b01      	ldr	r3, [sp, #4]
    dd42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    dd46:	4a0a      	ldr	r2, [pc, #40]	; (dd70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x48>)
    dd48:	9b01      	ldr	r3, [sp, #4]
    dd4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd4e:	f003 0301 	and.w	r3, r3, #1
    dd52:	2b00      	cmp	r3, #0
    dd54:	d106      	bne.n	dd64 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    dd56:	4a05      	ldr	r2, [pc, #20]	; (dd6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    dd58:	9b01      	ldr	r3, [sp, #4]
    dd5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd5e:	2b00      	cmp	r3, #0
    dd60:	d100      	bne.n	dd64 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    dd62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    dd64:	bf00      	nop
    dd66:	b003      	add	sp, #12
    dd68:	f85d fb04 	ldr.w	pc, [sp], #4
    dd6c:	1fff9044 	.word	0x1fff9044
    dd70:	1fff9040 	.word	0x1fff9040

0000dd74 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
    dd74:	b500      	push	{lr}
    dd76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dd78:	f7f3 fa82 	bl	1280 <Sys_GetCoreID>
    dd7c:	4603      	mov	r3, r0
    dd7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId])
    dd80:	4a10      	ldr	r2, [pc, #64]	; (ddc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    dd82:	9b01      	ldr	r3, [sp, #4]
    dd84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd88:	2b00      	cmp	r3, #0
    dd8a:	d10d      	bne.n	dda8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    dd8c:	f7f2 ff8c 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    dd90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    dd92:	9b00      	ldr	r3, [sp, #0]
    dd94:	f003 0301 	and.w	r3, r3, #1
    dd98:	2b00      	cmp	r3, #0
    dd9a:	d100      	bne.n	dd9e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    dd9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    dd9e:	490a      	ldr	r1, [pc, #40]	; (ddc8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x54>)
    dda0:	9b01      	ldr	r3, [sp, #4]
    dda2:	9a00      	ldr	r2, [sp, #0]
    dda4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]++;
    dda8:	4a06      	ldr	r2, [pc, #24]	; (ddc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    ddaa:	9b01      	ldr	r3, [sp, #4]
    ddac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ddb0:	1c5a      	adds	r2, r3, #1
    ddb2:	4904      	ldr	r1, [pc, #16]	; (ddc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    ddb4:	9b01      	ldr	r3, [sp, #4]
    ddb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ddba:	bf00      	nop
    ddbc:	b003      	add	sp, #12
    ddbe:	f85d fb04 	ldr.w	pc, [sp], #4
    ddc2:	bf00      	nop
    ddc4:	1fff904c 	.word	0x1fff904c
    ddc8:	1fff9048 	.word	0x1fff9048

0000ddcc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
    ddcc:	b500      	push	{lr}
    ddce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ddd0:	f7f3 fa56 	bl	1280 <Sys_GetCoreID>
    ddd4:	4603      	mov	r3, r0
    ddd6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]--;
    ddd8:	4a0d      	ldr	r2, [pc, #52]	; (de10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    ddda:	9b01      	ldr	r3, [sp, #4]
    dddc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dde0:	1e5a      	subs	r2, r3, #1
    dde2:	490b      	ldr	r1, [pc, #44]	; (de10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    dde4:	9b01      	ldr	r3, [sp, #4]
    dde6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    ddea:	4a0a      	ldr	r2, [pc, #40]	; (de14 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x48>)
    ddec:	9b01      	ldr	r3, [sp, #4]
    ddee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ddf2:	f003 0301 	and.w	r3, r3, #1
    ddf6:	2b00      	cmp	r3, #0
    ddf8:	d106      	bne.n	de08 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    ddfa:	4a05      	ldr	r2, [pc, #20]	; (de10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    ddfc:	9b01      	ldr	r3, [sp, #4]
    ddfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de02:	2b00      	cmp	r3, #0
    de04:	d100      	bne.n	de08 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    de06:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    de08:	bf00      	nop
    de0a:	b003      	add	sp, #12
    de0c:	f85d fb04 	ldr.w	pc, [sp], #4
    de10:	1fff904c 	.word	0x1fff904c
    de14:	1fff9048 	.word	0x1fff9048

0000de18 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
    de18:	b500      	push	{lr}
    de1a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    de1c:	f7f3 fa30 	bl	1280 <Sys_GetCoreID>
    de20:	4603      	mov	r3, r0
    de22:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId])
    de24:	4a10      	ldr	r2, [pc, #64]	; (de68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    de26:	9b01      	ldr	r3, [sp, #4]
    de28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de2c:	2b00      	cmp	r3, #0
    de2e:	d10d      	bne.n	de4c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    de30:	f7f2 ff3a 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    de34:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    de36:	9b00      	ldr	r3, [sp, #0]
    de38:	f003 0301 	and.w	r3, r3, #1
    de3c:	2b00      	cmp	r3, #0
    de3e:	d100      	bne.n	de42 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    de40:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    de42:	490a      	ldr	r1, [pc, #40]	; (de6c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x54>)
    de44:	9b01      	ldr	r3, [sp, #4]
    de46:	9a00      	ldr	r2, [sp, #0]
    de48:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]++;
    de4c:	4a06      	ldr	r2, [pc, #24]	; (de68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    de4e:	9b01      	ldr	r3, [sp, #4]
    de50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de54:	1c5a      	adds	r2, r3, #1
    de56:	4904      	ldr	r1, [pc, #16]	; (de68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    de58:	9b01      	ldr	r3, [sp, #4]
    de5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    de5e:	bf00      	nop
    de60:	b003      	add	sp, #12
    de62:	f85d fb04 	ldr.w	pc, [sp], #4
    de66:	bf00      	nop
    de68:	1fff9054 	.word	0x1fff9054
    de6c:	1fff9050 	.word	0x1fff9050

0000de70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
    de70:	b500      	push	{lr}
    de72:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    de74:	f7f3 fa04 	bl	1280 <Sys_GetCoreID>
    de78:	4603      	mov	r3, r0
    de7a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]--;
    de7c:	4a0d      	ldr	r2, [pc, #52]	; (deb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    de7e:	9b01      	ldr	r3, [sp, #4]
    de80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de84:	1e5a      	subs	r2, r3, #1
    de86:	490b      	ldr	r1, [pc, #44]	; (deb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    de88:	9b01      	ldr	r3, [sp, #4]
    de8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    de8e:	4a0a      	ldr	r2, [pc, #40]	; (deb8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x48>)
    de90:	9b01      	ldr	r3, [sp, #4]
    de92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de96:	f003 0301 	and.w	r3, r3, #1
    de9a:	2b00      	cmp	r3, #0
    de9c:	d106      	bne.n	deac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    de9e:	4a05      	ldr	r2, [pc, #20]	; (deb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    dea0:	9b01      	ldr	r3, [sp, #4]
    dea2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dea6:	2b00      	cmp	r3, #0
    dea8:	d100      	bne.n	deac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    deaa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    deac:	bf00      	nop
    deae:	b003      	add	sp, #12
    deb0:	f85d fb04 	ldr.w	pc, [sp], #4
    deb4:	1fff9054 	.word	0x1fff9054
    deb8:	1fff9050 	.word	0x1fff9050

0000debc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
    debc:	b500      	push	{lr}
    debe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dec0:	f7f3 f9de 	bl	1280 <Sys_GetCoreID>
    dec4:	4603      	mov	r3, r0
    dec6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId])
    dec8:	4a10      	ldr	r2, [pc, #64]	; (df0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    deca:	9b01      	ldr	r3, [sp, #4]
    decc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ded0:	2b00      	cmp	r3, #0
    ded2:	d10d      	bne.n	def0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ded4:	f7f2 fee8 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    ded8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    deda:	9b00      	ldr	r3, [sp, #0]
    dedc:	f003 0301 	and.w	r3, r3, #1
    dee0:	2b00      	cmp	r3, #0
    dee2:	d100      	bne.n	dee6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    dee4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    dee6:	490a      	ldr	r1, [pc, #40]	; (df10 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x54>)
    dee8:	9b01      	ldr	r3, [sp, #4]
    deea:	9a00      	ldr	r2, [sp, #0]
    deec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]++;
    def0:	4a06      	ldr	r2, [pc, #24]	; (df0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    def2:	9b01      	ldr	r3, [sp, #4]
    def4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    def8:	1c5a      	adds	r2, r3, #1
    defa:	4904      	ldr	r1, [pc, #16]	; (df0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    defc:	9b01      	ldr	r3, [sp, #4]
    defe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    df02:	bf00      	nop
    df04:	b003      	add	sp, #12
    df06:	f85d fb04 	ldr.w	pc, [sp], #4
    df0a:	bf00      	nop
    df0c:	1fff905c 	.word	0x1fff905c
    df10:	1fff9058 	.word	0x1fff9058

0000df14 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
    df14:	b500      	push	{lr}
    df16:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    df18:	f7f3 f9b2 	bl	1280 <Sys_GetCoreID>
    df1c:	4603      	mov	r3, r0
    df1e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]--;
    df20:	4a0d      	ldr	r2, [pc, #52]	; (df58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    df22:	9b01      	ldr	r3, [sp, #4]
    df24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df28:	1e5a      	subs	r2, r3, #1
    df2a:	490b      	ldr	r1, [pc, #44]	; (df58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    df2c:	9b01      	ldr	r3, [sp, #4]
    df2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    df32:	4a0a      	ldr	r2, [pc, #40]	; (df5c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x48>)
    df34:	9b01      	ldr	r3, [sp, #4]
    df36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df3a:	f003 0301 	and.w	r3, r3, #1
    df3e:	2b00      	cmp	r3, #0
    df40:	d106      	bne.n	df50 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    df42:	4a05      	ldr	r2, [pc, #20]	; (df58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    df44:	9b01      	ldr	r3, [sp, #4]
    df46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df4a:	2b00      	cmp	r3, #0
    df4c:	d100      	bne.n	df50 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    df4e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    df50:	bf00      	nop
    df52:	b003      	add	sp, #12
    df54:	f85d fb04 	ldr.w	pc, [sp], #4
    df58:	1fff905c 	.word	0x1fff905c
    df5c:	1fff9058 	.word	0x1fff9058

0000df60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
    df60:	b500      	push	{lr}
    df62:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    df64:	f7f3 f98c 	bl	1280 <Sys_GetCoreID>
    df68:	4603      	mov	r3, r0
    df6a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId])
    df6c:	4a10      	ldr	r2, [pc, #64]	; (dfb0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    df6e:	9b01      	ldr	r3, [sp, #4]
    df70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df74:	2b00      	cmp	r3, #0
    df76:	d10d      	bne.n	df94 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    df78:	f7f2 fe96 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    df7c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    df7e:	9b00      	ldr	r3, [sp, #0]
    df80:	f003 0301 	and.w	r3, r3, #1
    df84:	2b00      	cmp	r3, #0
    df86:	d100      	bne.n	df8a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    df88:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    df8a:	490a      	ldr	r1, [pc, #40]	; (dfb4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x54>)
    df8c:	9b01      	ldr	r3, [sp, #4]
    df8e:	9a00      	ldr	r2, [sp, #0]
    df90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]++;
    df94:	4a06      	ldr	r2, [pc, #24]	; (dfb0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    df96:	9b01      	ldr	r3, [sp, #4]
    df98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df9c:	1c5a      	adds	r2, r3, #1
    df9e:	4904      	ldr	r1, [pc, #16]	; (dfb0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    dfa0:	9b01      	ldr	r3, [sp, #4]
    dfa2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    dfa6:	bf00      	nop
    dfa8:	b003      	add	sp, #12
    dfaa:	f85d fb04 	ldr.w	pc, [sp], #4
    dfae:	bf00      	nop
    dfb0:	1fff9064 	.word	0x1fff9064
    dfb4:	1fff9060 	.word	0x1fff9060

0000dfb8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
    dfb8:	b500      	push	{lr}
    dfba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    dfbc:	f7f3 f960 	bl	1280 <Sys_GetCoreID>
    dfc0:	4603      	mov	r3, r0
    dfc2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]--;
    dfc4:	4a0d      	ldr	r2, [pc, #52]	; (dffc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    dfc6:	9b01      	ldr	r3, [sp, #4]
    dfc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dfcc:	1e5a      	subs	r2, r3, #1
    dfce:	490b      	ldr	r1, [pc, #44]	; (dffc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    dfd0:	9b01      	ldr	r3, [sp, #4]
    dfd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    dfd6:	4a0a      	ldr	r2, [pc, #40]	; (e000 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x48>)
    dfd8:	9b01      	ldr	r3, [sp, #4]
    dfda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dfde:	f003 0301 	and.w	r3, r3, #1
    dfe2:	2b00      	cmp	r3, #0
    dfe4:	d106      	bne.n	dff4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    dfe6:	4a05      	ldr	r2, [pc, #20]	; (dffc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    dfe8:	9b01      	ldr	r3, [sp, #4]
    dfea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dfee:	2b00      	cmp	r3, #0
    dff0:	d100      	bne.n	dff4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    dff2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    dff4:	bf00      	nop
    dff6:	b003      	add	sp, #12
    dff8:	f85d fb04 	ldr.w	pc, [sp], #4
    dffc:	1fff9064 	.word	0x1fff9064
    e000:	1fff9060 	.word	0x1fff9060

0000e004 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
    e004:	b500      	push	{lr}
    e006:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e008:	f7f3 f93a 	bl	1280 <Sys_GetCoreID>
    e00c:	4603      	mov	r3, r0
    e00e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId])
    e010:	4a10      	ldr	r2, [pc, #64]	; (e054 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    e012:	9b01      	ldr	r3, [sp, #4]
    e014:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e018:	2b00      	cmp	r3, #0
    e01a:	d10d      	bne.n	e038 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e01c:	f7f2 fe44 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    e020:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e022:	9b00      	ldr	r3, [sp, #0]
    e024:	f003 0301 	and.w	r3, r3, #1
    e028:	2b00      	cmp	r3, #0
    e02a:	d100      	bne.n	e02e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e02c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    e02e:	490a      	ldr	r1, [pc, #40]	; (e058 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x54>)
    e030:	9b01      	ldr	r3, [sp, #4]
    e032:	9a00      	ldr	r2, [sp, #0]
    e034:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]++;
    e038:	4a06      	ldr	r2, [pc, #24]	; (e054 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    e03a:	9b01      	ldr	r3, [sp, #4]
    e03c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e040:	1c5a      	adds	r2, r3, #1
    e042:	4904      	ldr	r1, [pc, #16]	; (e054 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    e044:	9b01      	ldr	r3, [sp, #4]
    e046:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e04a:	bf00      	nop
    e04c:	b003      	add	sp, #12
    e04e:	f85d fb04 	ldr.w	pc, [sp], #4
    e052:	bf00      	nop
    e054:	1fff906c 	.word	0x1fff906c
    e058:	1fff9068 	.word	0x1fff9068

0000e05c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
    e05c:	b500      	push	{lr}
    e05e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e060:	f7f3 f90e 	bl	1280 <Sys_GetCoreID>
    e064:	4603      	mov	r3, r0
    e066:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]--;
    e068:	4a0d      	ldr	r2, [pc, #52]	; (e0a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    e06a:	9b01      	ldr	r3, [sp, #4]
    e06c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e070:	1e5a      	subs	r2, r3, #1
    e072:	490b      	ldr	r1, [pc, #44]	; (e0a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    e074:	9b01      	ldr	r3, [sp, #4]
    e076:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    e07a:	4a0a      	ldr	r2, [pc, #40]	; (e0a4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x48>)
    e07c:	9b01      	ldr	r3, [sp, #4]
    e07e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e082:	f003 0301 	and.w	r3, r3, #1
    e086:	2b00      	cmp	r3, #0
    e088:	d106      	bne.n	e098 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    e08a:	4a05      	ldr	r2, [pc, #20]	; (e0a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    e08c:	9b01      	ldr	r3, [sp, #4]
    e08e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e092:	2b00      	cmp	r3, #0
    e094:	d100      	bne.n	e098 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e096:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e098:	bf00      	nop
    e09a:	b003      	add	sp, #12
    e09c:	f85d fb04 	ldr.w	pc, [sp], #4
    e0a0:	1fff906c 	.word	0x1fff906c
    e0a4:	1fff9068 	.word	0x1fff9068

0000e0a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
    e0a8:	b500      	push	{lr}
    e0aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e0ac:	f7f3 f8e8 	bl	1280 <Sys_GetCoreID>
    e0b0:	4603      	mov	r3, r0
    e0b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId])
    e0b4:	4a10      	ldr	r2, [pc, #64]	; (e0f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    e0b6:	9b01      	ldr	r3, [sp, #4]
    e0b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0bc:	2b00      	cmp	r3, #0
    e0be:	d10d      	bne.n	e0dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e0c0:	f7f2 fdf2 	bl	ca8 <Can_43_FLEXCAN_schm_read_msr>
    e0c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e0c6:	9b00      	ldr	r3, [sp, #0]
    e0c8:	f003 0301 	and.w	r3, r3, #1
    e0cc:	2b00      	cmp	r3, #0
    e0ce:	d100      	bne.n	e0d2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e0d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    e0d2:	490a      	ldr	r1, [pc, #40]	; (e0fc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x54>)
    e0d4:	9b01      	ldr	r3, [sp, #4]
    e0d6:	9a00      	ldr	r2, [sp, #0]
    e0d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]++;
    e0dc:	4a06      	ldr	r2, [pc, #24]	; (e0f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    e0de:	9b01      	ldr	r3, [sp, #4]
    e0e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0e4:	1c5a      	adds	r2, r3, #1
    e0e6:	4904      	ldr	r1, [pc, #16]	; (e0f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    e0e8:	9b01      	ldr	r3, [sp, #4]
    e0ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e0ee:	bf00      	nop
    e0f0:	b003      	add	sp, #12
    e0f2:	f85d fb04 	ldr.w	pc, [sp], #4
    e0f6:	bf00      	nop
    e0f8:	1fff9074 	.word	0x1fff9074
    e0fc:	1fff9070 	.word	0x1fff9070

0000e100 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
    e100:	b500      	push	{lr}
    e102:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e104:	f7f3 f8bc 	bl	1280 <Sys_GetCoreID>
    e108:	4603      	mov	r3, r0
    e10a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]--;
    e10c:	4a0d      	ldr	r2, [pc, #52]	; (e144 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    e10e:	9b01      	ldr	r3, [sp, #4]
    e110:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e114:	1e5a      	subs	r2, r3, #1
    e116:	490b      	ldr	r1, [pc, #44]	; (e144 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    e118:	9b01      	ldr	r3, [sp, #4]
    e11a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    e11e:	4a0a      	ldr	r2, [pc, #40]	; (e148 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x48>)
    e120:	9b01      	ldr	r3, [sp, #4]
    e122:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e126:	f003 0301 	and.w	r3, r3, #1
    e12a:	2b00      	cmp	r3, #0
    e12c:	d106      	bne.n	e13c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    e12e:	4a05      	ldr	r2, [pc, #20]	; (e144 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    e130:	9b01      	ldr	r3, [sp, #4]
    e132:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e136:	2b00      	cmp	r3, #0
    e138:	d100      	bne.n	e13c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e13a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e13c:	bf00      	nop
    e13e:	b003      	add	sp, #12
    e140:	f85d fb04 	ldr.w	pc, [sp], #4
    e144:	1fff9074 	.word	0x1fff9074
    e148:	1fff9070 	.word	0x1fff9070

0000e14c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    e14c:	b500      	push	{lr}
    e14e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e150:	f7f3 f896 	bl	1280 <Sys_GetCoreID>
    e154:	4603      	mov	r3, r0
    e156:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId])
    e158:	4a10      	ldr	r2, [pc, #64]	; (e19c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    e15a:	9b01      	ldr	r3, [sp, #4]
    e15c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e160:	2b00      	cmp	r3, #0
    e162:	d10d      	bne.n	e180 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e164:	f7f2 fda9 	bl	cba <Dio_schm_read_msr>
    e168:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e16a:	9b00      	ldr	r3, [sp, #0]
    e16c:	f003 0301 	and.w	r3, r3, #1
    e170:	2b00      	cmp	r3, #0
    e172:	d100      	bne.n	e176 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e174:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    e176:	490a      	ldr	r1, [pc, #40]	; (e1a0 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x54>)
    e178:	9b01      	ldr	r3, [sp, #4]
    e17a:	9a00      	ldr	r2, [sp, #0]
    e17c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]++;
    e180:	4a06      	ldr	r2, [pc, #24]	; (e19c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    e182:	9b01      	ldr	r3, [sp, #4]
    e184:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e188:	1c5a      	adds	r2, r3, #1
    e18a:	4904      	ldr	r1, [pc, #16]	; (e19c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    e18c:	9b01      	ldr	r3, [sp, #4]
    e18e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e192:	bf00      	nop
    e194:	b003      	add	sp, #12
    e196:	f85d fb04 	ldr.w	pc, [sp], #4
    e19a:	bf00      	nop
    e19c:	1fff907c 	.word	0x1fff907c
    e1a0:	1fff9078 	.word	0x1fff9078

0000e1a4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    e1a4:	b500      	push	{lr}
    e1a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e1a8:	f7f3 f86a 	bl	1280 <Sys_GetCoreID>
    e1ac:	4603      	mov	r3, r0
    e1ae:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]--;
    e1b0:	4a0d      	ldr	r2, [pc, #52]	; (e1e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    e1b2:	9b01      	ldr	r3, [sp, #4]
    e1b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1b8:	1e5a      	subs	r2, r3, #1
    e1ba:	490b      	ldr	r1, [pc, #44]	; (e1e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    e1bc:	9b01      	ldr	r3, [sp, #4]
    e1be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    e1c2:	4a0a      	ldr	r2, [pc, #40]	; (e1ec <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x48>)
    e1c4:	9b01      	ldr	r3, [sp, #4]
    e1c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1ca:	f003 0301 	and.w	r3, r3, #1
    e1ce:	2b00      	cmp	r3, #0
    e1d0:	d106      	bne.n	e1e0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    e1d2:	4a05      	ldr	r2, [pc, #20]	; (e1e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    e1d4:	9b01      	ldr	r3, [sp, #4]
    e1d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1da:	2b00      	cmp	r3, #0
    e1dc:	d100      	bne.n	e1e0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e1de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e1e0:	bf00      	nop
    e1e2:	b003      	add	sp, #12
    e1e4:	f85d fb04 	ldr.w	pc, [sp], #4
    e1e8:	1fff907c 	.word	0x1fff907c
    e1ec:	1fff9078 	.word	0x1fff9078

0000e1f0 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    e1f0:	b500      	push	{lr}
    e1f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e1f4:	f7f3 f844 	bl	1280 <Sys_GetCoreID>
    e1f8:	4603      	mov	r3, r0
    e1fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId])
    e1fc:	4a10      	ldr	r2, [pc, #64]	; (e240 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    e1fe:	9b01      	ldr	r3, [sp, #4]
    e200:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e204:	2b00      	cmp	r3, #0
    e206:	d10d      	bne.n	e224 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e208:	f7f2 fd57 	bl	cba <Dio_schm_read_msr>
    e20c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e20e:	9b00      	ldr	r3, [sp, #0]
    e210:	f003 0301 	and.w	r3, r3, #1
    e214:	2b00      	cmp	r3, #0
    e216:	d100      	bne.n	e21a <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e218:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    e21a:	490a      	ldr	r1, [pc, #40]	; (e244 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x54>)
    e21c:	9b01      	ldr	r3, [sp, #4]
    e21e:	9a00      	ldr	r2, [sp, #0]
    e220:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]++;
    e224:	4a06      	ldr	r2, [pc, #24]	; (e240 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    e226:	9b01      	ldr	r3, [sp, #4]
    e228:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e22c:	1c5a      	adds	r2, r3, #1
    e22e:	4904      	ldr	r1, [pc, #16]	; (e240 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    e230:	9b01      	ldr	r3, [sp, #4]
    e232:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e236:	bf00      	nop
    e238:	b003      	add	sp, #12
    e23a:	f85d fb04 	ldr.w	pc, [sp], #4
    e23e:	bf00      	nop
    e240:	1fff9084 	.word	0x1fff9084
    e244:	1fff9080 	.word	0x1fff9080

0000e248 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    e248:	b500      	push	{lr}
    e24a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e24c:	f7f3 f818 	bl	1280 <Sys_GetCoreID>
    e250:	4603      	mov	r3, r0
    e252:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]--;
    e254:	4a0d      	ldr	r2, [pc, #52]	; (e28c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    e256:	9b01      	ldr	r3, [sp, #4]
    e258:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e25c:	1e5a      	subs	r2, r3, #1
    e25e:	490b      	ldr	r1, [pc, #44]	; (e28c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    e260:	9b01      	ldr	r3, [sp, #4]
    e262:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    e266:	4a0a      	ldr	r2, [pc, #40]	; (e290 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x48>)
    e268:	9b01      	ldr	r3, [sp, #4]
    e26a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e26e:	f003 0301 	and.w	r3, r3, #1
    e272:	2b00      	cmp	r3, #0
    e274:	d106      	bne.n	e284 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    e276:	4a05      	ldr	r2, [pc, #20]	; (e28c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    e278:	9b01      	ldr	r3, [sp, #4]
    e27a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e27e:	2b00      	cmp	r3, #0
    e280:	d100      	bne.n	e284 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e282:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e284:	bf00      	nop
    e286:	b003      	add	sp, #12
    e288:	f85d fb04 	ldr.w	pc, [sp], #4
    e28c:	1fff9084 	.word	0x1fff9084
    e290:	1fff9080 	.word	0x1fff9080

0000e294 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    e294:	b500      	push	{lr}
    e296:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e298:	f7f2 fff2 	bl	1280 <Sys_GetCoreID>
    e29c:	4603      	mov	r3, r0
    e29e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    e2a0:	4a10      	ldr	r2, [pc, #64]	; (e2e4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    e2a2:	9b01      	ldr	r3, [sp, #4]
    e2a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2a8:	2b00      	cmp	r3, #0
    e2aa:	d10d      	bne.n	e2c8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e2ac:	f7f2 fd0e 	bl	ccc <Mcu_schm_read_msr>
    e2b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e2b2:	9b00      	ldr	r3, [sp, #0]
    e2b4:	f003 0301 	and.w	r3, r3, #1
    e2b8:	2b00      	cmp	r3, #0
    e2ba:	d100      	bne.n	e2be <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e2bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    e2be:	490a      	ldr	r1, [pc, #40]	; (e2e8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    e2c0:	9b01      	ldr	r3, [sp, #4]
    e2c2:	9a00      	ldr	r2, [sp, #0]
    e2c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    e2c8:	4a06      	ldr	r2, [pc, #24]	; (e2e4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    e2ca:	9b01      	ldr	r3, [sp, #4]
    e2cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2d0:	1c5a      	adds	r2, r3, #1
    e2d2:	4904      	ldr	r1, [pc, #16]	; (e2e4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    e2d4:	9b01      	ldr	r3, [sp, #4]
    e2d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e2da:	bf00      	nop
    e2dc:	b003      	add	sp, #12
    e2de:	f85d fb04 	ldr.w	pc, [sp], #4
    e2e2:	bf00      	nop
    e2e4:	1fff908c 	.word	0x1fff908c
    e2e8:	1fff9088 	.word	0x1fff9088

0000e2ec <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    e2ec:	b500      	push	{lr}
    e2ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e2f0:	f7f2 ffc6 	bl	1280 <Sys_GetCoreID>
    e2f4:	4603      	mov	r3, r0
    e2f6:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    e2f8:	4a0d      	ldr	r2, [pc, #52]	; (e330 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    e2fa:	9b01      	ldr	r3, [sp, #4]
    e2fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e300:	1e5a      	subs	r2, r3, #1
    e302:	490b      	ldr	r1, [pc, #44]	; (e330 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    e304:	9b01      	ldr	r3, [sp, #4]
    e306:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    e30a:	4a0a      	ldr	r2, [pc, #40]	; (e334 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    e30c:	9b01      	ldr	r3, [sp, #4]
    e30e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e312:	f003 0301 	and.w	r3, r3, #1
    e316:	2b00      	cmp	r3, #0
    e318:	d106      	bne.n	e328 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    e31a:	4a05      	ldr	r2, [pc, #20]	; (e330 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    e31c:	9b01      	ldr	r3, [sp, #4]
    e31e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e322:	2b00      	cmp	r3, #0
    e324:	d100      	bne.n	e328 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e326:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e328:	bf00      	nop
    e32a:	b003      	add	sp, #12
    e32c:	f85d fb04 	ldr.w	pc, [sp], #4
    e330:	1fff908c 	.word	0x1fff908c
    e334:	1fff9088 	.word	0x1fff9088

0000e338 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    e338:	b500      	push	{lr}
    e33a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e33c:	f7f2 ffa0 	bl	1280 <Sys_GetCoreID>
    e340:	4603      	mov	r3, r0
    e342:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    e344:	4a10      	ldr	r2, [pc, #64]	; (e388 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    e346:	9b01      	ldr	r3, [sp, #4]
    e348:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e34c:	2b00      	cmp	r3, #0
    e34e:	d10d      	bne.n	e36c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e350:	f7f2 fcbc 	bl	ccc <Mcu_schm_read_msr>
    e354:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e356:	9b00      	ldr	r3, [sp, #0]
    e358:	f003 0301 	and.w	r3, r3, #1
    e35c:	2b00      	cmp	r3, #0
    e35e:	d100      	bne.n	e362 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e360:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    e362:	490a      	ldr	r1, [pc, #40]	; (e38c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    e364:	9b01      	ldr	r3, [sp, #4]
    e366:	9a00      	ldr	r2, [sp, #0]
    e368:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    e36c:	4a06      	ldr	r2, [pc, #24]	; (e388 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    e36e:	9b01      	ldr	r3, [sp, #4]
    e370:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e374:	1c5a      	adds	r2, r3, #1
    e376:	4904      	ldr	r1, [pc, #16]	; (e388 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    e378:	9b01      	ldr	r3, [sp, #4]
    e37a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e37e:	bf00      	nop
    e380:	b003      	add	sp, #12
    e382:	f85d fb04 	ldr.w	pc, [sp], #4
    e386:	bf00      	nop
    e388:	1fff9094 	.word	0x1fff9094
    e38c:	1fff9090 	.word	0x1fff9090

0000e390 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    e390:	b500      	push	{lr}
    e392:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e394:	f7f2 ff74 	bl	1280 <Sys_GetCoreID>
    e398:	4603      	mov	r3, r0
    e39a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    e39c:	4a0d      	ldr	r2, [pc, #52]	; (e3d4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    e39e:	9b01      	ldr	r3, [sp, #4]
    e3a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3a4:	1e5a      	subs	r2, r3, #1
    e3a6:	490b      	ldr	r1, [pc, #44]	; (e3d4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    e3a8:	9b01      	ldr	r3, [sp, #4]
    e3aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    e3ae:	4a0a      	ldr	r2, [pc, #40]	; (e3d8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    e3b0:	9b01      	ldr	r3, [sp, #4]
    e3b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3b6:	f003 0301 	and.w	r3, r3, #1
    e3ba:	2b00      	cmp	r3, #0
    e3bc:	d106      	bne.n	e3cc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    e3be:	4a05      	ldr	r2, [pc, #20]	; (e3d4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    e3c0:	9b01      	ldr	r3, [sp, #4]
    e3c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3c6:	2b00      	cmp	r3, #0
    e3c8:	d100      	bne.n	e3cc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e3ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e3cc:	bf00      	nop
    e3ce:	b003      	add	sp, #12
    e3d0:	f85d fb04 	ldr.w	pc, [sp], #4
    e3d4:	1fff9094 	.word	0x1fff9094
    e3d8:	1fff9090 	.word	0x1fff9090

0000e3dc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    e3dc:	b500      	push	{lr}
    e3de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e3e0:	f7f2 ff4e 	bl	1280 <Sys_GetCoreID>
    e3e4:	4603      	mov	r3, r0
    e3e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    e3e8:	4a10      	ldr	r2, [pc, #64]	; (e42c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    e3ea:	9b01      	ldr	r3, [sp, #4]
    e3ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3f0:	2b00      	cmp	r3, #0
    e3f2:	d10d      	bne.n	e410 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e3f4:	f7f2 fc6a 	bl	ccc <Mcu_schm_read_msr>
    e3f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e3fa:	9b00      	ldr	r3, [sp, #0]
    e3fc:	f003 0301 	and.w	r3, r3, #1
    e400:	2b00      	cmp	r3, #0
    e402:	d100      	bne.n	e406 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e404:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    e406:	490a      	ldr	r1, [pc, #40]	; (e430 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    e408:	9b01      	ldr	r3, [sp, #4]
    e40a:	9a00      	ldr	r2, [sp, #0]
    e40c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    e410:	4a06      	ldr	r2, [pc, #24]	; (e42c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    e412:	9b01      	ldr	r3, [sp, #4]
    e414:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e418:	1c5a      	adds	r2, r3, #1
    e41a:	4904      	ldr	r1, [pc, #16]	; (e42c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    e41c:	9b01      	ldr	r3, [sp, #4]
    e41e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e422:	bf00      	nop
    e424:	b003      	add	sp, #12
    e426:	f85d fb04 	ldr.w	pc, [sp], #4
    e42a:	bf00      	nop
    e42c:	1fff909c 	.word	0x1fff909c
    e430:	1fff9098 	.word	0x1fff9098

0000e434 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    e434:	b500      	push	{lr}
    e436:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e438:	f7f2 ff22 	bl	1280 <Sys_GetCoreID>
    e43c:	4603      	mov	r3, r0
    e43e:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    e440:	4a0d      	ldr	r2, [pc, #52]	; (e478 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    e442:	9b01      	ldr	r3, [sp, #4]
    e444:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e448:	1e5a      	subs	r2, r3, #1
    e44a:	490b      	ldr	r1, [pc, #44]	; (e478 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    e44c:	9b01      	ldr	r3, [sp, #4]
    e44e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    e452:	4a0a      	ldr	r2, [pc, #40]	; (e47c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    e454:	9b01      	ldr	r3, [sp, #4]
    e456:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e45a:	f003 0301 	and.w	r3, r3, #1
    e45e:	2b00      	cmp	r3, #0
    e460:	d106      	bne.n	e470 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    e462:	4a05      	ldr	r2, [pc, #20]	; (e478 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    e464:	9b01      	ldr	r3, [sp, #4]
    e466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e46a:	2b00      	cmp	r3, #0
    e46c:	d100      	bne.n	e470 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e46e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e470:	bf00      	nop
    e472:	b003      	add	sp, #12
    e474:	f85d fb04 	ldr.w	pc, [sp], #4
    e478:	1fff909c 	.word	0x1fff909c
    e47c:	1fff9098 	.word	0x1fff9098

0000e480 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    e480:	b500      	push	{lr}
    e482:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e484:	f7f2 fefc 	bl	1280 <Sys_GetCoreID>
    e488:	4603      	mov	r3, r0
    e48a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    e48c:	4a10      	ldr	r2, [pc, #64]	; (e4d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    e48e:	9b01      	ldr	r3, [sp, #4]
    e490:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e494:	2b00      	cmp	r3, #0
    e496:	d10d      	bne.n	e4b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e498:	f7f2 fc21 	bl	cde <Port_schm_read_msr>
    e49c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e49e:	9b00      	ldr	r3, [sp, #0]
    e4a0:	f003 0301 	and.w	r3, r3, #1
    e4a4:	2b00      	cmp	r3, #0
    e4a6:	d100      	bne.n	e4aa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e4a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    e4aa:	490a      	ldr	r1, [pc, #40]	; (e4d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    e4ac:	9b01      	ldr	r3, [sp, #4]
    e4ae:	9a00      	ldr	r2, [sp, #0]
    e4b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    e4b4:	4a06      	ldr	r2, [pc, #24]	; (e4d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    e4b6:	9b01      	ldr	r3, [sp, #4]
    e4b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4bc:	1c5a      	adds	r2, r3, #1
    e4be:	4904      	ldr	r1, [pc, #16]	; (e4d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    e4c0:	9b01      	ldr	r3, [sp, #4]
    e4c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e4c6:	bf00      	nop
    e4c8:	b003      	add	sp, #12
    e4ca:	f85d fb04 	ldr.w	pc, [sp], #4
    e4ce:	bf00      	nop
    e4d0:	1fff90a4 	.word	0x1fff90a4
    e4d4:	1fff90a0 	.word	0x1fff90a0

0000e4d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    e4d8:	b500      	push	{lr}
    e4da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e4dc:	f7f2 fed0 	bl	1280 <Sys_GetCoreID>
    e4e0:	4603      	mov	r3, r0
    e4e2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    e4e4:	4a0d      	ldr	r2, [pc, #52]	; (e51c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    e4e6:	9b01      	ldr	r3, [sp, #4]
    e4e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4ec:	1e5a      	subs	r2, r3, #1
    e4ee:	490b      	ldr	r1, [pc, #44]	; (e51c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    e4f0:	9b01      	ldr	r3, [sp, #4]
    e4f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    e4f6:	4a0a      	ldr	r2, [pc, #40]	; (e520 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    e4f8:	9b01      	ldr	r3, [sp, #4]
    e4fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4fe:	f003 0301 	and.w	r3, r3, #1
    e502:	2b00      	cmp	r3, #0
    e504:	d106      	bne.n	e514 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    e506:	4a05      	ldr	r2, [pc, #20]	; (e51c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    e508:	9b01      	ldr	r3, [sp, #4]
    e50a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e50e:	2b00      	cmp	r3, #0
    e510:	d100      	bne.n	e514 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e512:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e514:	bf00      	nop
    e516:	b003      	add	sp, #12
    e518:	f85d fb04 	ldr.w	pc, [sp], #4
    e51c:	1fff90a4 	.word	0x1fff90a4
    e520:	1fff90a0 	.word	0x1fff90a0

0000e524 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    e524:	b500      	push	{lr}
    e526:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e528:	f7f2 feaa 	bl	1280 <Sys_GetCoreID>
    e52c:	4603      	mov	r3, r0
    e52e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    e530:	4a10      	ldr	r2, [pc, #64]	; (e574 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    e532:	9b01      	ldr	r3, [sp, #4]
    e534:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e538:	2b00      	cmp	r3, #0
    e53a:	d10d      	bne.n	e558 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e53c:	f7f2 fbcf 	bl	cde <Port_schm_read_msr>
    e540:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e542:	9b00      	ldr	r3, [sp, #0]
    e544:	f003 0301 	and.w	r3, r3, #1
    e548:	2b00      	cmp	r3, #0
    e54a:	d100      	bne.n	e54e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e54c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    e54e:	490a      	ldr	r1, [pc, #40]	; (e578 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    e550:	9b01      	ldr	r3, [sp, #4]
    e552:	9a00      	ldr	r2, [sp, #0]
    e554:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    e558:	4a06      	ldr	r2, [pc, #24]	; (e574 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    e55a:	9b01      	ldr	r3, [sp, #4]
    e55c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e560:	1c5a      	adds	r2, r3, #1
    e562:	4904      	ldr	r1, [pc, #16]	; (e574 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    e564:	9b01      	ldr	r3, [sp, #4]
    e566:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e56a:	bf00      	nop
    e56c:	b003      	add	sp, #12
    e56e:	f85d fb04 	ldr.w	pc, [sp], #4
    e572:	bf00      	nop
    e574:	1fff90ac 	.word	0x1fff90ac
    e578:	1fff90a8 	.word	0x1fff90a8

0000e57c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    e57c:	b500      	push	{lr}
    e57e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e580:	f7f2 fe7e 	bl	1280 <Sys_GetCoreID>
    e584:	4603      	mov	r3, r0
    e586:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    e588:	4a0d      	ldr	r2, [pc, #52]	; (e5c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    e58a:	9b01      	ldr	r3, [sp, #4]
    e58c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e590:	1e5a      	subs	r2, r3, #1
    e592:	490b      	ldr	r1, [pc, #44]	; (e5c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    e594:	9b01      	ldr	r3, [sp, #4]
    e596:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    e59a:	4a0a      	ldr	r2, [pc, #40]	; (e5c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    e59c:	9b01      	ldr	r3, [sp, #4]
    e59e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5a2:	f003 0301 	and.w	r3, r3, #1
    e5a6:	2b00      	cmp	r3, #0
    e5a8:	d106      	bne.n	e5b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    e5aa:	4a05      	ldr	r2, [pc, #20]	; (e5c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    e5ac:	9b01      	ldr	r3, [sp, #4]
    e5ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5b2:	2b00      	cmp	r3, #0
    e5b4:	d100      	bne.n	e5b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e5b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e5b8:	bf00      	nop
    e5ba:	b003      	add	sp, #12
    e5bc:	f85d fb04 	ldr.w	pc, [sp], #4
    e5c0:	1fff90ac 	.word	0x1fff90ac
    e5c4:	1fff90a8 	.word	0x1fff90a8

0000e5c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    e5c8:	b500      	push	{lr}
    e5ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e5cc:	f7f2 fe58 	bl	1280 <Sys_GetCoreID>
    e5d0:	4603      	mov	r3, r0
    e5d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    e5d4:	4a10      	ldr	r2, [pc, #64]	; (e618 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    e5d6:	9b01      	ldr	r3, [sp, #4]
    e5d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5dc:	2b00      	cmp	r3, #0
    e5de:	d10d      	bne.n	e5fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e5e0:	f7f2 fb7d 	bl	cde <Port_schm_read_msr>
    e5e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e5e6:	9b00      	ldr	r3, [sp, #0]
    e5e8:	f003 0301 	and.w	r3, r3, #1
    e5ec:	2b00      	cmp	r3, #0
    e5ee:	d100      	bne.n	e5f2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e5f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    e5f2:	490a      	ldr	r1, [pc, #40]	; (e61c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    e5f4:	9b01      	ldr	r3, [sp, #4]
    e5f6:	9a00      	ldr	r2, [sp, #0]
    e5f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    e5fc:	4a06      	ldr	r2, [pc, #24]	; (e618 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    e5fe:	9b01      	ldr	r3, [sp, #4]
    e600:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e604:	1c5a      	adds	r2, r3, #1
    e606:	4904      	ldr	r1, [pc, #16]	; (e618 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    e608:	9b01      	ldr	r3, [sp, #4]
    e60a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e60e:	bf00      	nop
    e610:	b003      	add	sp, #12
    e612:	f85d fb04 	ldr.w	pc, [sp], #4
    e616:	bf00      	nop
    e618:	1fff90b4 	.word	0x1fff90b4
    e61c:	1fff90b0 	.word	0x1fff90b0

0000e620 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    e620:	b500      	push	{lr}
    e622:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e624:	f7f2 fe2c 	bl	1280 <Sys_GetCoreID>
    e628:	4603      	mov	r3, r0
    e62a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    e62c:	4a0d      	ldr	r2, [pc, #52]	; (e664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    e62e:	9b01      	ldr	r3, [sp, #4]
    e630:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e634:	1e5a      	subs	r2, r3, #1
    e636:	490b      	ldr	r1, [pc, #44]	; (e664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    e638:	9b01      	ldr	r3, [sp, #4]
    e63a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    e63e:	4a0a      	ldr	r2, [pc, #40]	; (e668 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    e640:	9b01      	ldr	r3, [sp, #4]
    e642:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e646:	f003 0301 	and.w	r3, r3, #1
    e64a:	2b00      	cmp	r3, #0
    e64c:	d106      	bne.n	e65c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    e64e:	4a05      	ldr	r2, [pc, #20]	; (e664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    e650:	9b01      	ldr	r3, [sp, #4]
    e652:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e656:	2b00      	cmp	r3, #0
    e658:	d100      	bne.n	e65c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e65a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e65c:	bf00      	nop
    e65e:	b003      	add	sp, #12
    e660:	f85d fb04 	ldr.w	pc, [sp], #4
    e664:	1fff90b4 	.word	0x1fff90b4
    e668:	1fff90b0 	.word	0x1fff90b0

0000e66c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    e66c:	b500      	push	{lr}
    e66e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e670:	f7f2 fe06 	bl	1280 <Sys_GetCoreID>
    e674:	4603      	mov	r3, r0
    e676:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    e678:	4a10      	ldr	r2, [pc, #64]	; (e6bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    e67a:	9b01      	ldr	r3, [sp, #4]
    e67c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e680:	2b00      	cmp	r3, #0
    e682:	d10d      	bne.n	e6a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e684:	f7f2 fb2b 	bl	cde <Port_schm_read_msr>
    e688:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e68a:	9b00      	ldr	r3, [sp, #0]
    e68c:	f003 0301 	and.w	r3, r3, #1
    e690:	2b00      	cmp	r3, #0
    e692:	d100      	bne.n	e696 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e694:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    e696:	490a      	ldr	r1, [pc, #40]	; (e6c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    e698:	9b01      	ldr	r3, [sp, #4]
    e69a:	9a00      	ldr	r2, [sp, #0]
    e69c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    e6a0:	4a06      	ldr	r2, [pc, #24]	; (e6bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    e6a2:	9b01      	ldr	r3, [sp, #4]
    e6a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6a8:	1c5a      	adds	r2, r3, #1
    e6aa:	4904      	ldr	r1, [pc, #16]	; (e6bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    e6ac:	9b01      	ldr	r3, [sp, #4]
    e6ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e6b2:	bf00      	nop
    e6b4:	b003      	add	sp, #12
    e6b6:	f85d fb04 	ldr.w	pc, [sp], #4
    e6ba:	bf00      	nop
    e6bc:	1fff90bc 	.word	0x1fff90bc
    e6c0:	1fff90b8 	.word	0x1fff90b8

0000e6c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    e6c4:	b500      	push	{lr}
    e6c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e6c8:	f7f2 fdda 	bl	1280 <Sys_GetCoreID>
    e6cc:	4603      	mov	r3, r0
    e6ce:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    e6d0:	4a0d      	ldr	r2, [pc, #52]	; (e708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    e6d2:	9b01      	ldr	r3, [sp, #4]
    e6d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6d8:	1e5a      	subs	r2, r3, #1
    e6da:	490b      	ldr	r1, [pc, #44]	; (e708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    e6dc:	9b01      	ldr	r3, [sp, #4]
    e6de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    e6e2:	4a0a      	ldr	r2, [pc, #40]	; (e70c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    e6e4:	9b01      	ldr	r3, [sp, #4]
    e6e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6ea:	f003 0301 	and.w	r3, r3, #1
    e6ee:	2b00      	cmp	r3, #0
    e6f0:	d106      	bne.n	e700 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    e6f2:	4a05      	ldr	r2, [pc, #20]	; (e708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    e6f4:	9b01      	ldr	r3, [sp, #4]
    e6f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6fa:	2b00      	cmp	r3, #0
    e6fc:	d100      	bne.n	e700 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e6fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e700:	bf00      	nop
    e702:	b003      	add	sp, #12
    e704:	f85d fb04 	ldr.w	pc, [sp], #4
    e708:	1fff90bc 	.word	0x1fff90bc
    e70c:	1fff90b8 	.word	0x1fff90b8

0000e710 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    e710:	b500      	push	{lr}
    e712:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e714:	f7f2 fdb4 	bl	1280 <Sys_GetCoreID>
    e718:	4603      	mov	r3, r0
    e71a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    e71c:	4a10      	ldr	r2, [pc, #64]	; (e760 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    e71e:	9b01      	ldr	r3, [sp, #4]
    e720:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e724:	2b00      	cmp	r3, #0
    e726:	d10d      	bne.n	e744 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e728:	f7f2 fad9 	bl	cde <Port_schm_read_msr>
    e72c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e72e:	9b00      	ldr	r3, [sp, #0]
    e730:	f003 0301 	and.w	r3, r3, #1
    e734:	2b00      	cmp	r3, #0
    e736:	d100      	bne.n	e73a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e738:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    e73a:	490a      	ldr	r1, [pc, #40]	; (e764 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    e73c:	9b01      	ldr	r3, [sp, #4]
    e73e:	9a00      	ldr	r2, [sp, #0]
    e740:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    e744:	4a06      	ldr	r2, [pc, #24]	; (e760 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    e746:	9b01      	ldr	r3, [sp, #4]
    e748:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e74c:	1c5a      	adds	r2, r3, #1
    e74e:	4904      	ldr	r1, [pc, #16]	; (e760 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    e750:	9b01      	ldr	r3, [sp, #4]
    e752:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e756:	bf00      	nop
    e758:	b003      	add	sp, #12
    e75a:	f85d fb04 	ldr.w	pc, [sp], #4
    e75e:	bf00      	nop
    e760:	1fff90c4 	.word	0x1fff90c4
    e764:	1fff90c0 	.word	0x1fff90c0

0000e768 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    e768:	b500      	push	{lr}
    e76a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e76c:	f7f2 fd88 	bl	1280 <Sys_GetCoreID>
    e770:	4603      	mov	r3, r0
    e772:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    e774:	4a0d      	ldr	r2, [pc, #52]	; (e7ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    e776:	9b01      	ldr	r3, [sp, #4]
    e778:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e77c:	1e5a      	subs	r2, r3, #1
    e77e:	490b      	ldr	r1, [pc, #44]	; (e7ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    e780:	9b01      	ldr	r3, [sp, #4]
    e782:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    e786:	4a0a      	ldr	r2, [pc, #40]	; (e7b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    e788:	9b01      	ldr	r3, [sp, #4]
    e78a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e78e:	f003 0301 	and.w	r3, r3, #1
    e792:	2b00      	cmp	r3, #0
    e794:	d106      	bne.n	e7a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    e796:	4a05      	ldr	r2, [pc, #20]	; (e7ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    e798:	9b01      	ldr	r3, [sp, #4]
    e79a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e79e:	2b00      	cmp	r3, #0
    e7a0:	d100      	bne.n	e7a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e7a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e7a4:	bf00      	nop
    e7a6:	b003      	add	sp, #12
    e7a8:	f85d fb04 	ldr.w	pc, [sp], #4
    e7ac:	1fff90c4 	.word	0x1fff90c4
    e7b0:	1fff90c0 	.word	0x1fff90c0

0000e7b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    e7b4:	b500      	push	{lr}
    e7b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e7b8:	f7f2 fd62 	bl	1280 <Sys_GetCoreID>
    e7bc:	4603      	mov	r3, r0
    e7be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    e7c0:	4a10      	ldr	r2, [pc, #64]	; (e804 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    e7c2:	9b01      	ldr	r3, [sp, #4]
    e7c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e7c8:	2b00      	cmp	r3, #0
    e7ca:	d10d      	bne.n	e7e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e7cc:	f7f2 fa87 	bl	cde <Port_schm_read_msr>
    e7d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e7d2:	9b00      	ldr	r3, [sp, #0]
    e7d4:	f003 0301 	and.w	r3, r3, #1
    e7d8:	2b00      	cmp	r3, #0
    e7da:	d100      	bne.n	e7de <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e7dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    e7de:	490a      	ldr	r1, [pc, #40]	; (e808 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    e7e0:	9b01      	ldr	r3, [sp, #4]
    e7e2:	9a00      	ldr	r2, [sp, #0]
    e7e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    e7e8:	4a06      	ldr	r2, [pc, #24]	; (e804 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    e7ea:	9b01      	ldr	r3, [sp, #4]
    e7ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e7f0:	1c5a      	adds	r2, r3, #1
    e7f2:	4904      	ldr	r1, [pc, #16]	; (e804 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    e7f4:	9b01      	ldr	r3, [sp, #4]
    e7f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e7fa:	bf00      	nop
    e7fc:	b003      	add	sp, #12
    e7fe:	f85d fb04 	ldr.w	pc, [sp], #4
    e802:	bf00      	nop
    e804:	1fff90cc 	.word	0x1fff90cc
    e808:	1fff90c8 	.word	0x1fff90c8

0000e80c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    e80c:	b500      	push	{lr}
    e80e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e810:	f7f2 fd36 	bl	1280 <Sys_GetCoreID>
    e814:	4603      	mov	r3, r0
    e816:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    e818:	4a0d      	ldr	r2, [pc, #52]	; (e850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    e81a:	9b01      	ldr	r3, [sp, #4]
    e81c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e820:	1e5a      	subs	r2, r3, #1
    e822:	490b      	ldr	r1, [pc, #44]	; (e850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    e824:	9b01      	ldr	r3, [sp, #4]
    e826:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    e82a:	4a0a      	ldr	r2, [pc, #40]	; (e854 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    e82c:	9b01      	ldr	r3, [sp, #4]
    e82e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e832:	f003 0301 	and.w	r3, r3, #1
    e836:	2b00      	cmp	r3, #0
    e838:	d106      	bne.n	e848 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    e83a:	4a05      	ldr	r2, [pc, #20]	; (e850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    e83c:	9b01      	ldr	r3, [sp, #4]
    e83e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e842:	2b00      	cmp	r3, #0
    e844:	d100      	bne.n	e848 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e846:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e848:	bf00      	nop
    e84a:	b003      	add	sp, #12
    e84c:	f85d fb04 	ldr.w	pc, [sp], #4
    e850:	1fff90cc 	.word	0x1fff90cc
    e854:	1fff90c8 	.word	0x1fff90c8

0000e858 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    e858:	b500      	push	{lr}
    e85a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e85c:	f7f2 fd10 	bl	1280 <Sys_GetCoreID>
    e860:	4603      	mov	r3, r0
    e862:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    e864:	4a10      	ldr	r2, [pc, #64]	; (e8a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    e866:	9b01      	ldr	r3, [sp, #4]
    e868:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e86c:	2b00      	cmp	r3, #0
    e86e:	d10d      	bne.n	e88c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e870:	f7f2 fa35 	bl	cde <Port_schm_read_msr>
    e874:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e876:	9b00      	ldr	r3, [sp, #0]
    e878:	f003 0301 	and.w	r3, r3, #1
    e87c:	2b00      	cmp	r3, #0
    e87e:	d100      	bne.n	e882 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e880:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    e882:	490a      	ldr	r1, [pc, #40]	; (e8ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    e884:	9b01      	ldr	r3, [sp, #4]
    e886:	9a00      	ldr	r2, [sp, #0]
    e888:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    e88c:	4a06      	ldr	r2, [pc, #24]	; (e8a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    e88e:	9b01      	ldr	r3, [sp, #4]
    e890:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e894:	1c5a      	adds	r2, r3, #1
    e896:	4904      	ldr	r1, [pc, #16]	; (e8a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    e898:	9b01      	ldr	r3, [sp, #4]
    e89a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e89e:	bf00      	nop
    e8a0:	b003      	add	sp, #12
    e8a2:	f85d fb04 	ldr.w	pc, [sp], #4
    e8a6:	bf00      	nop
    e8a8:	1fff90d4 	.word	0x1fff90d4
    e8ac:	1fff90d0 	.word	0x1fff90d0

0000e8b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    e8b0:	b500      	push	{lr}
    e8b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e8b4:	f7f2 fce4 	bl	1280 <Sys_GetCoreID>
    e8b8:	4603      	mov	r3, r0
    e8ba:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    e8bc:	4a0d      	ldr	r2, [pc, #52]	; (e8f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    e8be:	9b01      	ldr	r3, [sp, #4]
    e8c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8c4:	1e5a      	subs	r2, r3, #1
    e8c6:	490b      	ldr	r1, [pc, #44]	; (e8f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    e8c8:	9b01      	ldr	r3, [sp, #4]
    e8ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    e8ce:	4a0a      	ldr	r2, [pc, #40]	; (e8f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    e8d0:	9b01      	ldr	r3, [sp, #4]
    e8d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8d6:	f003 0301 	and.w	r3, r3, #1
    e8da:	2b00      	cmp	r3, #0
    e8dc:	d106      	bne.n	e8ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    e8de:	4a05      	ldr	r2, [pc, #20]	; (e8f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    e8e0:	9b01      	ldr	r3, [sp, #4]
    e8e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8e6:	2b00      	cmp	r3, #0
    e8e8:	d100      	bne.n	e8ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e8ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e8ec:	bf00      	nop
    e8ee:	b003      	add	sp, #12
    e8f0:	f85d fb04 	ldr.w	pc, [sp], #4
    e8f4:	1fff90d4 	.word	0x1fff90d4
    e8f8:	1fff90d0 	.word	0x1fff90d0

0000e8fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    e8fc:	b500      	push	{lr}
    e8fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e900:	f7f2 fcbe 	bl	1280 <Sys_GetCoreID>
    e904:	4603      	mov	r3, r0
    e906:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    e908:	4a10      	ldr	r2, [pc, #64]	; (e94c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    e90a:	9b01      	ldr	r3, [sp, #4]
    e90c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e910:	2b00      	cmp	r3, #0
    e912:	d10d      	bne.n	e930 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e914:	f7f2 f9e3 	bl	cde <Port_schm_read_msr>
    e918:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e91a:	9b00      	ldr	r3, [sp, #0]
    e91c:	f003 0301 	and.w	r3, r3, #1
    e920:	2b00      	cmp	r3, #0
    e922:	d100      	bne.n	e926 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e924:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    e926:	490a      	ldr	r1, [pc, #40]	; (e950 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    e928:	9b01      	ldr	r3, [sp, #4]
    e92a:	9a00      	ldr	r2, [sp, #0]
    e92c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    e930:	4a06      	ldr	r2, [pc, #24]	; (e94c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    e932:	9b01      	ldr	r3, [sp, #4]
    e934:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e938:	1c5a      	adds	r2, r3, #1
    e93a:	4904      	ldr	r1, [pc, #16]	; (e94c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    e93c:	9b01      	ldr	r3, [sp, #4]
    e93e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e942:	bf00      	nop
    e944:	b003      	add	sp, #12
    e946:	f85d fb04 	ldr.w	pc, [sp], #4
    e94a:	bf00      	nop
    e94c:	1fff90dc 	.word	0x1fff90dc
    e950:	1fff90d8 	.word	0x1fff90d8

0000e954 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    e954:	b500      	push	{lr}
    e956:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e958:	f7f2 fc92 	bl	1280 <Sys_GetCoreID>
    e95c:	4603      	mov	r3, r0
    e95e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    e960:	4a0d      	ldr	r2, [pc, #52]	; (e998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    e962:	9b01      	ldr	r3, [sp, #4]
    e964:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e968:	1e5a      	subs	r2, r3, #1
    e96a:	490b      	ldr	r1, [pc, #44]	; (e998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    e96c:	9b01      	ldr	r3, [sp, #4]
    e96e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    e972:	4a0a      	ldr	r2, [pc, #40]	; (e99c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    e974:	9b01      	ldr	r3, [sp, #4]
    e976:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e97a:	f003 0301 	and.w	r3, r3, #1
    e97e:	2b00      	cmp	r3, #0
    e980:	d106      	bne.n	e990 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    e982:	4a05      	ldr	r2, [pc, #20]	; (e998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    e984:	9b01      	ldr	r3, [sp, #4]
    e986:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e98a:	2b00      	cmp	r3, #0
    e98c:	d100      	bne.n	e990 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e98e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e990:	bf00      	nop
    e992:	b003      	add	sp, #12
    e994:	f85d fb04 	ldr.w	pc, [sp], #4
    e998:	1fff90dc 	.word	0x1fff90dc
    e99c:	1fff90d8 	.word	0x1fff90d8

0000e9a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    e9a0:	b500      	push	{lr}
    e9a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e9a4:	f7f2 fc6c 	bl	1280 <Sys_GetCoreID>
    e9a8:	4603      	mov	r3, r0
    e9aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    e9ac:	4a10      	ldr	r2, [pc, #64]	; (e9f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    e9ae:	9b01      	ldr	r3, [sp, #4]
    e9b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e9b4:	2b00      	cmp	r3, #0
    e9b6:	d10d      	bne.n	e9d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e9b8:	f7f2 f991 	bl	cde <Port_schm_read_msr>
    e9bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e9be:	9b00      	ldr	r3, [sp, #0]
    e9c0:	f003 0301 	and.w	r3, r3, #1
    e9c4:	2b00      	cmp	r3, #0
    e9c6:	d100      	bne.n	e9ca <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e9c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    e9ca:	490a      	ldr	r1, [pc, #40]	; (e9f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    e9cc:	9b01      	ldr	r3, [sp, #4]
    e9ce:	9a00      	ldr	r2, [sp, #0]
    e9d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    e9d4:	4a06      	ldr	r2, [pc, #24]	; (e9f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    e9d6:	9b01      	ldr	r3, [sp, #4]
    e9d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e9dc:	1c5a      	adds	r2, r3, #1
    e9de:	4904      	ldr	r1, [pc, #16]	; (e9f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    e9e0:	9b01      	ldr	r3, [sp, #4]
    e9e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e9e6:	bf00      	nop
    e9e8:	b003      	add	sp, #12
    e9ea:	f85d fb04 	ldr.w	pc, [sp], #4
    e9ee:	bf00      	nop
    e9f0:	1fff90e4 	.word	0x1fff90e4
    e9f4:	1fff90e0 	.word	0x1fff90e0

0000e9f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    e9f8:	b500      	push	{lr}
    e9fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e9fc:	f7f2 fc40 	bl	1280 <Sys_GetCoreID>
    ea00:	4603      	mov	r3, r0
    ea02:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    ea04:	4a0d      	ldr	r2, [pc, #52]	; (ea3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    ea06:	9b01      	ldr	r3, [sp, #4]
    ea08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea0c:	1e5a      	subs	r2, r3, #1
    ea0e:	490b      	ldr	r1, [pc, #44]	; (ea3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    ea10:	9b01      	ldr	r3, [sp, #4]
    ea12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    ea16:	4a0a      	ldr	r2, [pc, #40]	; (ea40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    ea18:	9b01      	ldr	r3, [sp, #4]
    ea1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea1e:	f003 0301 	and.w	r3, r3, #1
    ea22:	2b00      	cmp	r3, #0
    ea24:	d106      	bne.n	ea34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    ea26:	4a05      	ldr	r2, [pc, #20]	; (ea3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    ea28:	9b01      	ldr	r3, [sp, #4]
    ea2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea2e:	2b00      	cmp	r3, #0
    ea30:	d100      	bne.n	ea34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ea32:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ea34:	bf00      	nop
    ea36:	b003      	add	sp, #12
    ea38:	f85d fb04 	ldr.w	pc, [sp], #4
    ea3c:	1fff90e4 	.word	0x1fff90e4
    ea40:	1fff90e0 	.word	0x1fff90e0

0000ea44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    ea44:	b500      	push	{lr}
    ea46:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ea48:	f7f2 fc1a 	bl	1280 <Sys_GetCoreID>
    ea4c:	4603      	mov	r3, r0
    ea4e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    ea50:	4a10      	ldr	r2, [pc, #64]	; (ea94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    ea52:	9b01      	ldr	r3, [sp, #4]
    ea54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea58:	2b00      	cmp	r3, #0
    ea5a:	d10d      	bne.n	ea78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ea5c:	f7f2 f93f 	bl	cde <Port_schm_read_msr>
    ea60:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ea62:	9b00      	ldr	r3, [sp, #0]
    ea64:	f003 0301 	and.w	r3, r3, #1
    ea68:	2b00      	cmp	r3, #0
    ea6a:	d100      	bne.n	ea6e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ea6c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    ea6e:	490a      	ldr	r1, [pc, #40]	; (ea98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    ea70:	9b01      	ldr	r3, [sp, #4]
    ea72:	9a00      	ldr	r2, [sp, #0]
    ea74:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    ea78:	4a06      	ldr	r2, [pc, #24]	; (ea94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    ea7a:	9b01      	ldr	r3, [sp, #4]
    ea7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea80:	1c5a      	adds	r2, r3, #1
    ea82:	4904      	ldr	r1, [pc, #16]	; (ea94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    ea84:	9b01      	ldr	r3, [sp, #4]
    ea86:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ea8a:	bf00      	nop
    ea8c:	b003      	add	sp, #12
    ea8e:	f85d fb04 	ldr.w	pc, [sp], #4
    ea92:	bf00      	nop
    ea94:	1fff90ec 	.word	0x1fff90ec
    ea98:	1fff90e8 	.word	0x1fff90e8

0000ea9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    ea9c:	b500      	push	{lr}
    ea9e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eaa0:	f7f2 fbee 	bl	1280 <Sys_GetCoreID>
    eaa4:	4603      	mov	r3, r0
    eaa6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    eaa8:	4a0d      	ldr	r2, [pc, #52]	; (eae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    eaaa:	9b01      	ldr	r3, [sp, #4]
    eaac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eab0:	1e5a      	subs	r2, r3, #1
    eab2:	490b      	ldr	r1, [pc, #44]	; (eae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    eab4:	9b01      	ldr	r3, [sp, #4]
    eab6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    eaba:	4a0a      	ldr	r2, [pc, #40]	; (eae4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    eabc:	9b01      	ldr	r3, [sp, #4]
    eabe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eac2:	f003 0301 	and.w	r3, r3, #1
    eac6:	2b00      	cmp	r3, #0
    eac8:	d106      	bne.n	ead8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    eaca:	4a05      	ldr	r2, [pc, #20]	; (eae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    eacc:	9b01      	ldr	r3, [sp, #4]
    eace:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ead2:	2b00      	cmp	r3, #0
    ead4:	d100      	bne.n	ead8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ead6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ead8:	bf00      	nop
    eada:	b003      	add	sp, #12
    eadc:	f85d fb04 	ldr.w	pc, [sp], #4
    eae0:	1fff90ec 	.word	0x1fff90ec
    eae4:	1fff90e8 	.word	0x1fff90e8

0000eae8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    eae8:	b500      	push	{lr}
    eaea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eaec:	f7f2 fbc8 	bl	1280 <Sys_GetCoreID>
    eaf0:	4603      	mov	r3, r0
    eaf2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    eaf4:	4a10      	ldr	r2, [pc, #64]	; (eb38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    eaf6:	9b01      	ldr	r3, [sp, #4]
    eaf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eafc:	2b00      	cmp	r3, #0
    eafe:	d10d      	bne.n	eb1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eb00:	f7f2 f8ed 	bl	cde <Port_schm_read_msr>
    eb04:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    eb06:	9b00      	ldr	r3, [sp, #0]
    eb08:	f003 0301 	and.w	r3, r3, #1
    eb0c:	2b00      	cmp	r3, #0
    eb0e:	d100      	bne.n	eb12 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eb10:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    eb12:	490a      	ldr	r1, [pc, #40]	; (eb3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    eb14:	9b01      	ldr	r3, [sp, #4]
    eb16:	9a00      	ldr	r2, [sp, #0]
    eb18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    eb1c:	4a06      	ldr	r2, [pc, #24]	; (eb38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    eb1e:	9b01      	ldr	r3, [sp, #4]
    eb20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb24:	1c5a      	adds	r2, r3, #1
    eb26:	4904      	ldr	r1, [pc, #16]	; (eb38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    eb28:	9b01      	ldr	r3, [sp, #4]
    eb2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    eb2e:	bf00      	nop
    eb30:	b003      	add	sp, #12
    eb32:	f85d fb04 	ldr.w	pc, [sp], #4
    eb36:	bf00      	nop
    eb38:	1fff90f4 	.word	0x1fff90f4
    eb3c:	1fff90f0 	.word	0x1fff90f0

0000eb40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    eb40:	b500      	push	{lr}
    eb42:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eb44:	f7f2 fb9c 	bl	1280 <Sys_GetCoreID>
    eb48:	4603      	mov	r3, r0
    eb4a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    eb4c:	4a0d      	ldr	r2, [pc, #52]	; (eb84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    eb4e:	9b01      	ldr	r3, [sp, #4]
    eb50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb54:	1e5a      	subs	r2, r3, #1
    eb56:	490b      	ldr	r1, [pc, #44]	; (eb84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    eb58:	9b01      	ldr	r3, [sp, #4]
    eb5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    eb5e:	4a0a      	ldr	r2, [pc, #40]	; (eb88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    eb60:	9b01      	ldr	r3, [sp, #4]
    eb62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb66:	f003 0301 	and.w	r3, r3, #1
    eb6a:	2b00      	cmp	r3, #0
    eb6c:	d106      	bne.n	eb7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    eb6e:	4a05      	ldr	r2, [pc, #20]	; (eb84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    eb70:	9b01      	ldr	r3, [sp, #4]
    eb72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb76:	2b00      	cmp	r3, #0
    eb78:	d100      	bne.n	eb7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    eb7a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    eb7c:	bf00      	nop
    eb7e:	b003      	add	sp, #12
    eb80:	f85d fb04 	ldr.w	pc, [sp], #4
    eb84:	1fff90f4 	.word	0x1fff90f4
    eb88:	1fff90f0 	.word	0x1fff90f0

0000eb8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    eb8c:	b500      	push	{lr}
    eb8e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eb90:	f7f2 fb76 	bl	1280 <Sys_GetCoreID>
    eb94:	4603      	mov	r3, r0
    eb96:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    eb98:	4a10      	ldr	r2, [pc, #64]	; (ebdc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    eb9a:	9b01      	ldr	r3, [sp, #4]
    eb9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eba0:	2b00      	cmp	r3, #0
    eba2:	d10d      	bne.n	ebc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eba4:	f7f2 f89b 	bl	cde <Port_schm_read_msr>
    eba8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ebaa:	9b00      	ldr	r3, [sp, #0]
    ebac:	f003 0301 	and.w	r3, r3, #1
    ebb0:	2b00      	cmp	r3, #0
    ebb2:	d100      	bne.n	ebb6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ebb4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    ebb6:	490a      	ldr	r1, [pc, #40]	; (ebe0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    ebb8:	9b01      	ldr	r3, [sp, #4]
    ebba:	9a00      	ldr	r2, [sp, #0]
    ebbc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    ebc0:	4a06      	ldr	r2, [pc, #24]	; (ebdc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    ebc2:	9b01      	ldr	r3, [sp, #4]
    ebc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ebc8:	1c5a      	adds	r2, r3, #1
    ebca:	4904      	ldr	r1, [pc, #16]	; (ebdc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    ebcc:	9b01      	ldr	r3, [sp, #4]
    ebce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ebd2:	bf00      	nop
    ebd4:	b003      	add	sp, #12
    ebd6:	f85d fb04 	ldr.w	pc, [sp], #4
    ebda:	bf00      	nop
    ebdc:	1fff90fc 	.word	0x1fff90fc
    ebe0:	1fff90f8 	.word	0x1fff90f8

0000ebe4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    ebe4:	b500      	push	{lr}
    ebe6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ebe8:	f7f2 fb4a 	bl	1280 <Sys_GetCoreID>
    ebec:	4603      	mov	r3, r0
    ebee:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    ebf0:	4a0d      	ldr	r2, [pc, #52]	; (ec28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    ebf2:	9b01      	ldr	r3, [sp, #4]
    ebf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ebf8:	1e5a      	subs	r2, r3, #1
    ebfa:	490b      	ldr	r1, [pc, #44]	; (ec28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    ebfc:	9b01      	ldr	r3, [sp, #4]
    ebfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    ec02:	4a0a      	ldr	r2, [pc, #40]	; (ec2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    ec04:	9b01      	ldr	r3, [sp, #4]
    ec06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec0a:	f003 0301 	and.w	r3, r3, #1
    ec0e:	2b00      	cmp	r3, #0
    ec10:	d106      	bne.n	ec20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    ec12:	4a05      	ldr	r2, [pc, #20]	; (ec28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    ec14:	9b01      	ldr	r3, [sp, #4]
    ec16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec1a:	2b00      	cmp	r3, #0
    ec1c:	d100      	bne.n	ec20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ec1e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ec20:	bf00      	nop
    ec22:	b003      	add	sp, #12
    ec24:	f85d fb04 	ldr.w	pc, [sp], #4
    ec28:	1fff90fc 	.word	0x1fff90fc
    ec2c:	1fff90f8 	.word	0x1fff90f8

0000ec30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    ec30:	b500      	push	{lr}
    ec32:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ec34:	f7f2 fb24 	bl	1280 <Sys_GetCoreID>
    ec38:	4603      	mov	r3, r0
    ec3a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    ec3c:	4a10      	ldr	r2, [pc, #64]	; (ec80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    ec3e:	9b01      	ldr	r3, [sp, #4]
    ec40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec44:	2b00      	cmp	r3, #0
    ec46:	d10d      	bne.n	ec64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ec48:	f7f2 f849 	bl	cde <Port_schm_read_msr>
    ec4c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ec4e:	9b00      	ldr	r3, [sp, #0]
    ec50:	f003 0301 	and.w	r3, r3, #1
    ec54:	2b00      	cmp	r3, #0
    ec56:	d100      	bne.n	ec5a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ec58:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    ec5a:	490a      	ldr	r1, [pc, #40]	; (ec84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    ec5c:	9b01      	ldr	r3, [sp, #4]
    ec5e:	9a00      	ldr	r2, [sp, #0]
    ec60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    ec64:	4a06      	ldr	r2, [pc, #24]	; (ec80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    ec66:	9b01      	ldr	r3, [sp, #4]
    ec68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec6c:	1c5a      	adds	r2, r3, #1
    ec6e:	4904      	ldr	r1, [pc, #16]	; (ec80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    ec70:	9b01      	ldr	r3, [sp, #4]
    ec72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ec76:	bf00      	nop
    ec78:	b003      	add	sp, #12
    ec7a:	f85d fb04 	ldr.w	pc, [sp], #4
    ec7e:	bf00      	nop
    ec80:	1fff9104 	.word	0x1fff9104
    ec84:	1fff9100 	.word	0x1fff9100

0000ec88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    ec88:	b500      	push	{lr}
    ec8a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ec8c:	f7f2 faf8 	bl	1280 <Sys_GetCoreID>
    ec90:	4603      	mov	r3, r0
    ec92:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    ec94:	4a0d      	ldr	r2, [pc, #52]	; (eccc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    ec96:	9b01      	ldr	r3, [sp, #4]
    ec98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec9c:	1e5a      	subs	r2, r3, #1
    ec9e:	490b      	ldr	r1, [pc, #44]	; (eccc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    eca0:	9b01      	ldr	r3, [sp, #4]
    eca2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    eca6:	4a0a      	ldr	r2, [pc, #40]	; (ecd0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    eca8:	9b01      	ldr	r3, [sp, #4]
    ecaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ecae:	f003 0301 	and.w	r3, r3, #1
    ecb2:	2b00      	cmp	r3, #0
    ecb4:	d106      	bne.n	ecc4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    ecb6:	4a05      	ldr	r2, [pc, #20]	; (eccc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    ecb8:	9b01      	ldr	r3, [sp, #4]
    ecba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ecbe:	2b00      	cmp	r3, #0
    ecc0:	d100      	bne.n	ecc4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ecc2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ecc4:	bf00      	nop
    ecc6:	b003      	add	sp, #12
    ecc8:	f85d fb04 	ldr.w	pc, [sp], #4
    eccc:	1fff9104 	.word	0x1fff9104
    ecd0:	1fff9100 	.word	0x1fff9100

0000ecd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    ecd4:	b500      	push	{lr}
    ecd6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ecd8:	f7f2 fad2 	bl	1280 <Sys_GetCoreID>
    ecdc:	4603      	mov	r3, r0
    ecde:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    ece0:	4a10      	ldr	r2, [pc, #64]	; (ed24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    ece2:	9b01      	ldr	r3, [sp, #4]
    ece4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ece8:	2b00      	cmp	r3, #0
    ecea:	d10d      	bne.n	ed08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ecec:	f7f1 fff7 	bl	cde <Port_schm_read_msr>
    ecf0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ecf2:	9b00      	ldr	r3, [sp, #0]
    ecf4:	f003 0301 	and.w	r3, r3, #1
    ecf8:	2b00      	cmp	r3, #0
    ecfa:	d100      	bne.n	ecfe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ecfc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    ecfe:	490a      	ldr	r1, [pc, #40]	; (ed28 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    ed00:	9b01      	ldr	r3, [sp, #4]
    ed02:	9a00      	ldr	r2, [sp, #0]
    ed04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    ed08:	4a06      	ldr	r2, [pc, #24]	; (ed24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    ed0a:	9b01      	ldr	r3, [sp, #4]
    ed0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed10:	1c5a      	adds	r2, r3, #1
    ed12:	4904      	ldr	r1, [pc, #16]	; (ed24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    ed14:	9b01      	ldr	r3, [sp, #4]
    ed16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ed1a:	bf00      	nop
    ed1c:	b003      	add	sp, #12
    ed1e:	f85d fb04 	ldr.w	pc, [sp], #4
    ed22:	bf00      	nop
    ed24:	1fff910c 	.word	0x1fff910c
    ed28:	1fff9108 	.word	0x1fff9108

0000ed2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    ed2c:	b500      	push	{lr}
    ed2e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ed30:	f7f2 faa6 	bl	1280 <Sys_GetCoreID>
    ed34:	4603      	mov	r3, r0
    ed36:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    ed38:	4a0d      	ldr	r2, [pc, #52]	; (ed70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    ed3a:	9b01      	ldr	r3, [sp, #4]
    ed3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed40:	1e5a      	subs	r2, r3, #1
    ed42:	490b      	ldr	r1, [pc, #44]	; (ed70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    ed44:	9b01      	ldr	r3, [sp, #4]
    ed46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    ed4a:	4a0a      	ldr	r2, [pc, #40]	; (ed74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    ed4c:	9b01      	ldr	r3, [sp, #4]
    ed4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed52:	f003 0301 	and.w	r3, r3, #1
    ed56:	2b00      	cmp	r3, #0
    ed58:	d106      	bne.n	ed68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    ed5a:	4a05      	ldr	r2, [pc, #20]	; (ed70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    ed5c:	9b01      	ldr	r3, [sp, #4]
    ed5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed62:	2b00      	cmp	r3, #0
    ed64:	d100      	bne.n	ed68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ed66:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ed68:	bf00      	nop
    ed6a:	b003      	add	sp, #12
    ed6c:	f85d fb04 	ldr.w	pc, [sp], #4
    ed70:	1fff910c 	.word	0x1fff910c
    ed74:	1fff9108 	.word	0x1fff9108

0000ed78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    ed78:	b500      	push	{lr}
    ed7a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ed7c:	f7f2 fa80 	bl	1280 <Sys_GetCoreID>
    ed80:	4603      	mov	r3, r0
    ed82:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    ed84:	4a10      	ldr	r2, [pc, #64]	; (edc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    ed86:	9b01      	ldr	r3, [sp, #4]
    ed88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed8c:	2b00      	cmp	r3, #0
    ed8e:	d10d      	bne.n	edac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ed90:	f7f1 ffa5 	bl	cde <Port_schm_read_msr>
    ed94:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ed96:	9b00      	ldr	r3, [sp, #0]
    ed98:	f003 0301 	and.w	r3, r3, #1
    ed9c:	2b00      	cmp	r3, #0
    ed9e:	d100      	bne.n	eda2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eda0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    eda2:	490a      	ldr	r1, [pc, #40]	; (edcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    eda4:	9b01      	ldr	r3, [sp, #4]
    eda6:	9a00      	ldr	r2, [sp, #0]
    eda8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    edac:	4a06      	ldr	r2, [pc, #24]	; (edc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    edae:	9b01      	ldr	r3, [sp, #4]
    edb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    edb4:	1c5a      	adds	r2, r3, #1
    edb6:	4904      	ldr	r1, [pc, #16]	; (edc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    edb8:	9b01      	ldr	r3, [sp, #4]
    edba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    edbe:	bf00      	nop
    edc0:	b003      	add	sp, #12
    edc2:	f85d fb04 	ldr.w	pc, [sp], #4
    edc6:	bf00      	nop
    edc8:	1fff9114 	.word	0x1fff9114
    edcc:	1fff9110 	.word	0x1fff9110

0000edd0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    edd0:	b500      	push	{lr}
    edd2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    edd4:	f7f2 fa54 	bl	1280 <Sys_GetCoreID>
    edd8:	4603      	mov	r3, r0
    edda:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    eddc:	4a0d      	ldr	r2, [pc, #52]	; (ee14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    edde:	9b01      	ldr	r3, [sp, #4]
    ede0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ede4:	1e5a      	subs	r2, r3, #1
    ede6:	490b      	ldr	r1, [pc, #44]	; (ee14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    ede8:	9b01      	ldr	r3, [sp, #4]
    edea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    edee:	4a0a      	ldr	r2, [pc, #40]	; (ee18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    edf0:	9b01      	ldr	r3, [sp, #4]
    edf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    edf6:	f003 0301 	and.w	r3, r3, #1
    edfa:	2b00      	cmp	r3, #0
    edfc:	d106      	bne.n	ee0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    edfe:	4a05      	ldr	r2, [pc, #20]	; (ee14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    ee00:	9b01      	ldr	r3, [sp, #4]
    ee02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee06:	2b00      	cmp	r3, #0
    ee08:	d100      	bne.n	ee0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ee0a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ee0c:	bf00      	nop
    ee0e:	b003      	add	sp, #12
    ee10:	f85d fb04 	ldr.w	pc, [sp], #4
    ee14:	1fff9114 	.word	0x1fff9114
    ee18:	1fff9110 	.word	0x1fff9110

0000ee1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    ee1c:	b500      	push	{lr}
    ee1e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ee20:	f7f2 fa2e 	bl	1280 <Sys_GetCoreID>
    ee24:	4603      	mov	r3, r0
    ee26:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    ee28:	4a10      	ldr	r2, [pc, #64]	; (ee6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    ee2a:	9b01      	ldr	r3, [sp, #4]
    ee2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee30:	2b00      	cmp	r3, #0
    ee32:	d10d      	bne.n	ee50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ee34:	f7f1 ff53 	bl	cde <Port_schm_read_msr>
    ee38:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ee3a:	9b00      	ldr	r3, [sp, #0]
    ee3c:	f003 0301 	and.w	r3, r3, #1
    ee40:	2b00      	cmp	r3, #0
    ee42:	d100      	bne.n	ee46 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ee44:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    ee46:	490a      	ldr	r1, [pc, #40]	; (ee70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    ee48:	9b01      	ldr	r3, [sp, #4]
    ee4a:	9a00      	ldr	r2, [sp, #0]
    ee4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    ee50:	4a06      	ldr	r2, [pc, #24]	; (ee6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    ee52:	9b01      	ldr	r3, [sp, #4]
    ee54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee58:	1c5a      	adds	r2, r3, #1
    ee5a:	4904      	ldr	r1, [pc, #16]	; (ee6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    ee5c:	9b01      	ldr	r3, [sp, #4]
    ee5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ee62:	bf00      	nop
    ee64:	b003      	add	sp, #12
    ee66:	f85d fb04 	ldr.w	pc, [sp], #4
    ee6a:	bf00      	nop
    ee6c:	1fff911c 	.word	0x1fff911c
    ee70:	1fff9118 	.word	0x1fff9118

0000ee74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    ee74:	b500      	push	{lr}
    ee76:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ee78:	f7f2 fa02 	bl	1280 <Sys_GetCoreID>
    ee7c:	4603      	mov	r3, r0
    ee7e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    ee80:	4a0d      	ldr	r2, [pc, #52]	; (eeb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    ee82:	9b01      	ldr	r3, [sp, #4]
    ee84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee88:	1e5a      	subs	r2, r3, #1
    ee8a:	490b      	ldr	r1, [pc, #44]	; (eeb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    ee8c:	9b01      	ldr	r3, [sp, #4]
    ee8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    ee92:	4a0a      	ldr	r2, [pc, #40]	; (eebc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    ee94:	9b01      	ldr	r3, [sp, #4]
    ee96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee9a:	f003 0301 	and.w	r3, r3, #1
    ee9e:	2b00      	cmp	r3, #0
    eea0:	d106      	bne.n	eeb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    eea2:	4a05      	ldr	r2, [pc, #20]	; (eeb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    eea4:	9b01      	ldr	r3, [sp, #4]
    eea6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eeaa:	2b00      	cmp	r3, #0
    eeac:	d100      	bne.n	eeb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    eeae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    eeb0:	bf00      	nop
    eeb2:	b003      	add	sp, #12
    eeb4:	f85d fb04 	ldr.w	pc, [sp], #4
    eeb8:	1fff911c 	.word	0x1fff911c
    eebc:	1fff9118 	.word	0x1fff9118

0000eec0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    eec0:	b500      	push	{lr}
    eec2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eec4:	f7f2 f9dc 	bl	1280 <Sys_GetCoreID>
    eec8:	4603      	mov	r3, r0
    eeca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    eecc:	4a10      	ldr	r2, [pc, #64]	; (ef10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    eece:	9b01      	ldr	r3, [sp, #4]
    eed0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eed4:	2b00      	cmp	r3, #0
    eed6:	d10d      	bne.n	eef4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eed8:	f7f1 ff01 	bl	cde <Port_schm_read_msr>
    eedc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    eede:	9b00      	ldr	r3, [sp, #0]
    eee0:	f003 0301 	and.w	r3, r3, #1
    eee4:	2b00      	cmp	r3, #0
    eee6:	d100      	bne.n	eeea <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eee8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    eeea:	490a      	ldr	r1, [pc, #40]	; (ef14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    eeec:	9b01      	ldr	r3, [sp, #4]
    eeee:	9a00      	ldr	r2, [sp, #0]
    eef0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    eef4:	4a06      	ldr	r2, [pc, #24]	; (ef10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    eef6:	9b01      	ldr	r3, [sp, #4]
    eef8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eefc:	1c5a      	adds	r2, r3, #1
    eefe:	4904      	ldr	r1, [pc, #16]	; (ef10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    ef00:	9b01      	ldr	r3, [sp, #4]
    ef02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ef06:	bf00      	nop
    ef08:	b003      	add	sp, #12
    ef0a:	f85d fb04 	ldr.w	pc, [sp], #4
    ef0e:	bf00      	nop
    ef10:	1fff9124 	.word	0x1fff9124
    ef14:	1fff9120 	.word	0x1fff9120

0000ef18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    ef18:	b500      	push	{lr}
    ef1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ef1c:	f7f2 f9b0 	bl	1280 <Sys_GetCoreID>
    ef20:	4603      	mov	r3, r0
    ef22:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    ef24:	4a0d      	ldr	r2, [pc, #52]	; (ef5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    ef26:	9b01      	ldr	r3, [sp, #4]
    ef28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef2c:	1e5a      	subs	r2, r3, #1
    ef2e:	490b      	ldr	r1, [pc, #44]	; (ef5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    ef30:	9b01      	ldr	r3, [sp, #4]
    ef32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    ef36:	4a0a      	ldr	r2, [pc, #40]	; (ef60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    ef38:	9b01      	ldr	r3, [sp, #4]
    ef3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef3e:	f003 0301 	and.w	r3, r3, #1
    ef42:	2b00      	cmp	r3, #0
    ef44:	d106      	bne.n	ef54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    ef46:	4a05      	ldr	r2, [pc, #20]	; (ef5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    ef48:	9b01      	ldr	r3, [sp, #4]
    ef4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef4e:	2b00      	cmp	r3, #0
    ef50:	d100      	bne.n	ef54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ef52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ef54:	bf00      	nop
    ef56:	b003      	add	sp, #12
    ef58:	f85d fb04 	ldr.w	pc, [sp], #4
    ef5c:	1fff9124 	.word	0x1fff9124
    ef60:	1fff9120 	.word	0x1fff9120

0000ef64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    ef64:	b500      	push	{lr}
    ef66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ef68:	f7f2 f98a 	bl	1280 <Sys_GetCoreID>
    ef6c:	4603      	mov	r3, r0
    ef6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    ef70:	4a10      	ldr	r2, [pc, #64]	; (efb4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    ef72:	9b01      	ldr	r3, [sp, #4]
    ef74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef78:	2b00      	cmp	r3, #0
    ef7a:	d10d      	bne.n	ef98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ef7c:	f7f1 feaf 	bl	cde <Port_schm_read_msr>
    ef80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ef82:	9b00      	ldr	r3, [sp, #0]
    ef84:	f003 0301 	and.w	r3, r3, #1
    ef88:	2b00      	cmp	r3, #0
    ef8a:	d100      	bne.n	ef8e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ef8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    ef8e:	490a      	ldr	r1, [pc, #40]	; (efb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    ef90:	9b01      	ldr	r3, [sp, #4]
    ef92:	9a00      	ldr	r2, [sp, #0]
    ef94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    ef98:	4a06      	ldr	r2, [pc, #24]	; (efb4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    ef9a:	9b01      	ldr	r3, [sp, #4]
    ef9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efa0:	1c5a      	adds	r2, r3, #1
    efa2:	4904      	ldr	r1, [pc, #16]	; (efb4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    efa4:	9b01      	ldr	r3, [sp, #4]
    efa6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    efaa:	bf00      	nop
    efac:	b003      	add	sp, #12
    efae:	f85d fb04 	ldr.w	pc, [sp], #4
    efb2:	bf00      	nop
    efb4:	1fff912c 	.word	0x1fff912c
    efb8:	1fff9128 	.word	0x1fff9128

0000efbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    efbc:	b500      	push	{lr}
    efbe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    efc0:	f7f2 f95e 	bl	1280 <Sys_GetCoreID>
    efc4:	4603      	mov	r3, r0
    efc6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    efc8:	4a0d      	ldr	r2, [pc, #52]	; (f000 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    efca:	9b01      	ldr	r3, [sp, #4]
    efcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efd0:	1e5a      	subs	r2, r3, #1
    efd2:	490b      	ldr	r1, [pc, #44]	; (f000 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    efd4:	9b01      	ldr	r3, [sp, #4]
    efd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    efda:	4a0a      	ldr	r2, [pc, #40]	; (f004 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    efdc:	9b01      	ldr	r3, [sp, #4]
    efde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efe2:	f003 0301 	and.w	r3, r3, #1
    efe6:	2b00      	cmp	r3, #0
    efe8:	d106      	bne.n	eff8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    efea:	4a05      	ldr	r2, [pc, #20]	; (f000 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    efec:	9b01      	ldr	r3, [sp, #4]
    efee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eff2:	2b00      	cmp	r3, #0
    eff4:	d100      	bne.n	eff8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    eff6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    eff8:	bf00      	nop
    effa:	b003      	add	sp, #12
    effc:	f85d fb04 	ldr.w	pc, [sp], #4
    f000:	1fff912c 	.word	0x1fff912c
    f004:	1fff9128 	.word	0x1fff9128

0000f008 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    f008:	b500      	push	{lr}
    f00a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f00c:	f7f2 f938 	bl	1280 <Sys_GetCoreID>
    f010:	4603      	mov	r3, r0
    f012:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    f014:	4a10      	ldr	r2, [pc, #64]	; (f058 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    f016:	9b01      	ldr	r3, [sp, #4]
    f018:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f01c:	2b00      	cmp	r3, #0
    f01e:	d10d      	bne.n	f03c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f020:	f7f1 fe5d 	bl	cde <Port_schm_read_msr>
    f024:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f026:	9b00      	ldr	r3, [sp, #0]
    f028:	f003 0301 	and.w	r3, r3, #1
    f02c:	2b00      	cmp	r3, #0
    f02e:	d100      	bne.n	f032 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f030:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    f032:	490a      	ldr	r1, [pc, #40]	; (f05c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    f034:	9b01      	ldr	r3, [sp, #4]
    f036:	9a00      	ldr	r2, [sp, #0]
    f038:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    f03c:	4a06      	ldr	r2, [pc, #24]	; (f058 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    f03e:	9b01      	ldr	r3, [sp, #4]
    f040:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f044:	1c5a      	adds	r2, r3, #1
    f046:	4904      	ldr	r1, [pc, #16]	; (f058 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    f048:	9b01      	ldr	r3, [sp, #4]
    f04a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f04e:	bf00      	nop
    f050:	b003      	add	sp, #12
    f052:	f85d fb04 	ldr.w	pc, [sp], #4
    f056:	bf00      	nop
    f058:	1fff9134 	.word	0x1fff9134
    f05c:	1fff9130 	.word	0x1fff9130

0000f060 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    f060:	b500      	push	{lr}
    f062:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f064:	f7f2 f90c 	bl	1280 <Sys_GetCoreID>
    f068:	4603      	mov	r3, r0
    f06a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    f06c:	4a0d      	ldr	r2, [pc, #52]	; (f0a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    f06e:	9b01      	ldr	r3, [sp, #4]
    f070:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f074:	1e5a      	subs	r2, r3, #1
    f076:	490b      	ldr	r1, [pc, #44]	; (f0a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    f078:	9b01      	ldr	r3, [sp, #4]
    f07a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    f07e:	4a0a      	ldr	r2, [pc, #40]	; (f0a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    f080:	9b01      	ldr	r3, [sp, #4]
    f082:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f086:	f003 0301 	and.w	r3, r3, #1
    f08a:	2b00      	cmp	r3, #0
    f08c:	d106      	bne.n	f09c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    f08e:	4a05      	ldr	r2, [pc, #20]	; (f0a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    f090:	9b01      	ldr	r3, [sp, #4]
    f092:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f096:	2b00      	cmp	r3, #0
    f098:	d100      	bne.n	f09c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f09a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f09c:	bf00      	nop
    f09e:	b003      	add	sp, #12
    f0a0:	f85d fb04 	ldr.w	pc, [sp], #4
    f0a4:	1fff9134 	.word	0x1fff9134
    f0a8:	1fff9130 	.word	0x1fff9130

0000f0ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    f0ac:	b500      	push	{lr}
    f0ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f0b0:	f7f2 f8e6 	bl	1280 <Sys_GetCoreID>
    f0b4:	4603      	mov	r3, r0
    f0b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    f0b8:	4a10      	ldr	r2, [pc, #64]	; (f0fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    f0ba:	9b01      	ldr	r3, [sp, #4]
    f0bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f0c0:	2b00      	cmp	r3, #0
    f0c2:	d10d      	bne.n	f0e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f0c4:	f7f1 fe0b 	bl	cde <Port_schm_read_msr>
    f0c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f0ca:	9b00      	ldr	r3, [sp, #0]
    f0cc:	f003 0301 	and.w	r3, r3, #1
    f0d0:	2b00      	cmp	r3, #0
    f0d2:	d100      	bne.n	f0d6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f0d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    f0d6:	490a      	ldr	r1, [pc, #40]	; (f100 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    f0d8:	9b01      	ldr	r3, [sp, #4]
    f0da:	9a00      	ldr	r2, [sp, #0]
    f0dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    f0e0:	4a06      	ldr	r2, [pc, #24]	; (f0fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    f0e2:	9b01      	ldr	r3, [sp, #4]
    f0e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f0e8:	1c5a      	adds	r2, r3, #1
    f0ea:	4904      	ldr	r1, [pc, #16]	; (f0fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    f0ec:	9b01      	ldr	r3, [sp, #4]
    f0ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f0f2:	bf00      	nop
    f0f4:	b003      	add	sp, #12
    f0f6:	f85d fb04 	ldr.w	pc, [sp], #4
    f0fa:	bf00      	nop
    f0fc:	1fff913c 	.word	0x1fff913c
    f100:	1fff9138 	.word	0x1fff9138

0000f104 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    f104:	b500      	push	{lr}
    f106:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f108:	f7f2 f8ba 	bl	1280 <Sys_GetCoreID>
    f10c:	4603      	mov	r3, r0
    f10e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    f110:	4a0d      	ldr	r2, [pc, #52]	; (f148 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    f112:	9b01      	ldr	r3, [sp, #4]
    f114:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f118:	1e5a      	subs	r2, r3, #1
    f11a:	490b      	ldr	r1, [pc, #44]	; (f148 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    f11c:	9b01      	ldr	r3, [sp, #4]
    f11e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    f122:	4a0a      	ldr	r2, [pc, #40]	; (f14c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    f124:	9b01      	ldr	r3, [sp, #4]
    f126:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f12a:	f003 0301 	and.w	r3, r3, #1
    f12e:	2b00      	cmp	r3, #0
    f130:	d106      	bne.n	f140 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    f132:	4a05      	ldr	r2, [pc, #20]	; (f148 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    f134:	9b01      	ldr	r3, [sp, #4]
    f136:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f13a:	2b00      	cmp	r3, #0
    f13c:	d100      	bne.n	f140 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f13e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f140:	bf00      	nop
    f142:	b003      	add	sp, #12
    f144:	f85d fb04 	ldr.w	pc, [sp], #4
    f148:	1fff913c 	.word	0x1fff913c
    f14c:	1fff9138 	.word	0x1fff9138

0000f150 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    f150:	b500      	push	{lr}
    f152:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f154:	f7f2 f894 	bl	1280 <Sys_GetCoreID>
    f158:	4603      	mov	r3, r0
    f15a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    f15c:	4a10      	ldr	r2, [pc, #64]	; (f1a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    f15e:	9b01      	ldr	r3, [sp, #4]
    f160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f164:	2b00      	cmp	r3, #0
    f166:	d10d      	bne.n	f184 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f168:	f7f1 fdb9 	bl	cde <Port_schm_read_msr>
    f16c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f16e:	9b00      	ldr	r3, [sp, #0]
    f170:	f003 0301 	and.w	r3, r3, #1
    f174:	2b00      	cmp	r3, #0
    f176:	d100      	bne.n	f17a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f178:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    f17a:	490a      	ldr	r1, [pc, #40]	; (f1a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    f17c:	9b01      	ldr	r3, [sp, #4]
    f17e:	9a00      	ldr	r2, [sp, #0]
    f180:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    f184:	4a06      	ldr	r2, [pc, #24]	; (f1a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    f186:	9b01      	ldr	r3, [sp, #4]
    f188:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f18c:	1c5a      	adds	r2, r3, #1
    f18e:	4904      	ldr	r1, [pc, #16]	; (f1a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    f190:	9b01      	ldr	r3, [sp, #4]
    f192:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f196:	bf00      	nop
    f198:	b003      	add	sp, #12
    f19a:	f85d fb04 	ldr.w	pc, [sp], #4
    f19e:	bf00      	nop
    f1a0:	1fff9144 	.word	0x1fff9144
    f1a4:	1fff9140 	.word	0x1fff9140

0000f1a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    f1a8:	b500      	push	{lr}
    f1aa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f1ac:	f7f2 f868 	bl	1280 <Sys_GetCoreID>
    f1b0:	4603      	mov	r3, r0
    f1b2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    f1b4:	4a0d      	ldr	r2, [pc, #52]	; (f1ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    f1b6:	9b01      	ldr	r3, [sp, #4]
    f1b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1bc:	1e5a      	subs	r2, r3, #1
    f1be:	490b      	ldr	r1, [pc, #44]	; (f1ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    f1c0:	9b01      	ldr	r3, [sp, #4]
    f1c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    f1c6:	4a0a      	ldr	r2, [pc, #40]	; (f1f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    f1c8:	9b01      	ldr	r3, [sp, #4]
    f1ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1ce:	f003 0301 	and.w	r3, r3, #1
    f1d2:	2b00      	cmp	r3, #0
    f1d4:	d106      	bne.n	f1e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    f1d6:	4a05      	ldr	r2, [pc, #20]	; (f1ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    f1d8:	9b01      	ldr	r3, [sp, #4]
    f1da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1de:	2b00      	cmp	r3, #0
    f1e0:	d100      	bne.n	f1e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f1e2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f1e4:	bf00      	nop
    f1e6:	b003      	add	sp, #12
    f1e8:	f85d fb04 	ldr.w	pc, [sp], #4
    f1ec:	1fff9144 	.word	0x1fff9144
    f1f0:	1fff9140 	.word	0x1fff9140

0000f1f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    f1f4:	b500      	push	{lr}
    f1f6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f1f8:	f7f2 f842 	bl	1280 <Sys_GetCoreID>
    f1fc:	4603      	mov	r3, r0
    f1fe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    f200:	4a10      	ldr	r2, [pc, #64]	; (f244 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    f202:	9b01      	ldr	r3, [sp, #4]
    f204:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f208:	2b00      	cmp	r3, #0
    f20a:	d10d      	bne.n	f228 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f20c:	f7f1 fd67 	bl	cde <Port_schm_read_msr>
    f210:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f212:	9b00      	ldr	r3, [sp, #0]
    f214:	f003 0301 	and.w	r3, r3, #1
    f218:	2b00      	cmp	r3, #0
    f21a:	d100      	bne.n	f21e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f21c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    f21e:	490a      	ldr	r1, [pc, #40]	; (f248 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    f220:	9b01      	ldr	r3, [sp, #4]
    f222:	9a00      	ldr	r2, [sp, #0]
    f224:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    f228:	4a06      	ldr	r2, [pc, #24]	; (f244 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    f22a:	9b01      	ldr	r3, [sp, #4]
    f22c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f230:	1c5a      	adds	r2, r3, #1
    f232:	4904      	ldr	r1, [pc, #16]	; (f244 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    f234:	9b01      	ldr	r3, [sp, #4]
    f236:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f23a:	bf00      	nop
    f23c:	b003      	add	sp, #12
    f23e:	f85d fb04 	ldr.w	pc, [sp], #4
    f242:	bf00      	nop
    f244:	1fff914c 	.word	0x1fff914c
    f248:	1fff9148 	.word	0x1fff9148

0000f24c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    f24c:	b500      	push	{lr}
    f24e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f250:	f7f2 f816 	bl	1280 <Sys_GetCoreID>
    f254:	4603      	mov	r3, r0
    f256:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    f258:	4a0d      	ldr	r2, [pc, #52]	; (f290 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    f25a:	9b01      	ldr	r3, [sp, #4]
    f25c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f260:	1e5a      	subs	r2, r3, #1
    f262:	490b      	ldr	r1, [pc, #44]	; (f290 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    f264:	9b01      	ldr	r3, [sp, #4]
    f266:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    f26a:	4a0a      	ldr	r2, [pc, #40]	; (f294 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    f26c:	9b01      	ldr	r3, [sp, #4]
    f26e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f272:	f003 0301 	and.w	r3, r3, #1
    f276:	2b00      	cmp	r3, #0
    f278:	d106      	bne.n	f288 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    f27a:	4a05      	ldr	r2, [pc, #20]	; (f290 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    f27c:	9b01      	ldr	r3, [sp, #4]
    f27e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f282:	2b00      	cmp	r3, #0
    f284:	d100      	bne.n	f288 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f286:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f288:	bf00      	nop
    f28a:	b003      	add	sp, #12
    f28c:	f85d fb04 	ldr.w	pc, [sp], #4
    f290:	1fff914c 	.word	0x1fff914c
    f294:	1fff9148 	.word	0x1fff9148

0000f298 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    f298:	b500      	push	{lr}
    f29a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f29c:	f7f1 fff0 	bl	1280 <Sys_GetCoreID>
    f2a0:	4603      	mov	r3, r0
    f2a2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    f2a4:	4a10      	ldr	r2, [pc, #64]	; (f2e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    f2a6:	9b01      	ldr	r3, [sp, #4]
    f2a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2ac:	2b00      	cmp	r3, #0
    f2ae:	d10d      	bne.n	f2cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f2b0:	f7f1 fd15 	bl	cde <Port_schm_read_msr>
    f2b4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f2b6:	9b00      	ldr	r3, [sp, #0]
    f2b8:	f003 0301 	and.w	r3, r3, #1
    f2bc:	2b00      	cmp	r3, #0
    f2be:	d100      	bne.n	f2c2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f2c0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    f2c2:	490a      	ldr	r1, [pc, #40]	; (f2ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    f2c4:	9b01      	ldr	r3, [sp, #4]
    f2c6:	9a00      	ldr	r2, [sp, #0]
    f2c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    f2cc:	4a06      	ldr	r2, [pc, #24]	; (f2e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    f2ce:	9b01      	ldr	r3, [sp, #4]
    f2d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2d4:	1c5a      	adds	r2, r3, #1
    f2d6:	4904      	ldr	r1, [pc, #16]	; (f2e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    f2d8:	9b01      	ldr	r3, [sp, #4]
    f2da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f2de:	bf00      	nop
    f2e0:	b003      	add	sp, #12
    f2e2:	f85d fb04 	ldr.w	pc, [sp], #4
    f2e6:	bf00      	nop
    f2e8:	1fff9154 	.word	0x1fff9154
    f2ec:	1fff9150 	.word	0x1fff9150

0000f2f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    f2f0:	b500      	push	{lr}
    f2f2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f2f4:	f7f1 ffc4 	bl	1280 <Sys_GetCoreID>
    f2f8:	4603      	mov	r3, r0
    f2fa:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    f2fc:	4a0d      	ldr	r2, [pc, #52]	; (f334 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    f2fe:	9b01      	ldr	r3, [sp, #4]
    f300:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f304:	1e5a      	subs	r2, r3, #1
    f306:	490b      	ldr	r1, [pc, #44]	; (f334 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    f308:	9b01      	ldr	r3, [sp, #4]
    f30a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    f30e:	4a0a      	ldr	r2, [pc, #40]	; (f338 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    f310:	9b01      	ldr	r3, [sp, #4]
    f312:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f316:	f003 0301 	and.w	r3, r3, #1
    f31a:	2b00      	cmp	r3, #0
    f31c:	d106      	bne.n	f32c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    f31e:	4a05      	ldr	r2, [pc, #20]	; (f334 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    f320:	9b01      	ldr	r3, [sp, #4]
    f322:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f326:	2b00      	cmp	r3, #0
    f328:	d100      	bne.n	f32c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f32a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f32c:	bf00      	nop
    f32e:	b003      	add	sp, #12
    f330:	f85d fb04 	ldr.w	pc, [sp], #4
    f334:	1fff9154 	.word	0x1fff9154
    f338:	1fff9150 	.word	0x1fff9150

0000f33c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    f33c:	b500      	push	{lr}
    f33e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f340:	f7f1 ff9e 	bl	1280 <Sys_GetCoreID>
    f344:	4603      	mov	r3, r0
    f346:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    f348:	4a10      	ldr	r2, [pc, #64]	; (f38c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    f34a:	9b01      	ldr	r3, [sp, #4]
    f34c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f350:	2b00      	cmp	r3, #0
    f352:	d10d      	bne.n	f370 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f354:	f7f1 fcc3 	bl	cde <Port_schm_read_msr>
    f358:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f35a:	9b00      	ldr	r3, [sp, #0]
    f35c:	f003 0301 	and.w	r3, r3, #1
    f360:	2b00      	cmp	r3, #0
    f362:	d100      	bne.n	f366 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f364:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    f366:	490a      	ldr	r1, [pc, #40]	; (f390 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    f368:	9b01      	ldr	r3, [sp, #4]
    f36a:	9a00      	ldr	r2, [sp, #0]
    f36c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    f370:	4a06      	ldr	r2, [pc, #24]	; (f38c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    f372:	9b01      	ldr	r3, [sp, #4]
    f374:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f378:	1c5a      	adds	r2, r3, #1
    f37a:	4904      	ldr	r1, [pc, #16]	; (f38c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    f37c:	9b01      	ldr	r3, [sp, #4]
    f37e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f382:	bf00      	nop
    f384:	b003      	add	sp, #12
    f386:	f85d fb04 	ldr.w	pc, [sp], #4
    f38a:	bf00      	nop
    f38c:	1fff915c 	.word	0x1fff915c
    f390:	1fff9158 	.word	0x1fff9158

0000f394 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    f394:	b500      	push	{lr}
    f396:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f398:	f7f1 ff72 	bl	1280 <Sys_GetCoreID>
    f39c:	4603      	mov	r3, r0
    f39e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    f3a0:	4a0d      	ldr	r2, [pc, #52]	; (f3d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    f3a2:	9b01      	ldr	r3, [sp, #4]
    f3a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3a8:	1e5a      	subs	r2, r3, #1
    f3aa:	490b      	ldr	r1, [pc, #44]	; (f3d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    f3ac:	9b01      	ldr	r3, [sp, #4]
    f3ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    f3b2:	4a0a      	ldr	r2, [pc, #40]	; (f3dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    f3b4:	9b01      	ldr	r3, [sp, #4]
    f3b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3ba:	f003 0301 	and.w	r3, r3, #1
    f3be:	2b00      	cmp	r3, #0
    f3c0:	d106      	bne.n	f3d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    f3c2:	4a05      	ldr	r2, [pc, #20]	; (f3d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    f3c4:	9b01      	ldr	r3, [sp, #4]
    f3c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3ca:	2b00      	cmp	r3, #0
    f3cc:	d100      	bne.n	f3d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f3ce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f3d0:	bf00      	nop
    f3d2:	b003      	add	sp, #12
    f3d4:	f85d fb04 	ldr.w	pc, [sp], #4
    f3d8:	1fff915c 	.word	0x1fff915c
    f3dc:	1fff9158 	.word	0x1fff9158

0000f3e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    f3e0:	b500      	push	{lr}
    f3e2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f3e4:	f7f1 ff4c 	bl	1280 <Sys_GetCoreID>
    f3e8:	4603      	mov	r3, r0
    f3ea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    f3ec:	4a10      	ldr	r2, [pc, #64]	; (f430 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    f3ee:	9b01      	ldr	r3, [sp, #4]
    f3f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3f4:	2b00      	cmp	r3, #0
    f3f6:	d10d      	bne.n	f414 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f3f8:	f7f1 fc71 	bl	cde <Port_schm_read_msr>
    f3fc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f3fe:	9b00      	ldr	r3, [sp, #0]
    f400:	f003 0301 	and.w	r3, r3, #1
    f404:	2b00      	cmp	r3, #0
    f406:	d100      	bne.n	f40a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f408:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    f40a:	490a      	ldr	r1, [pc, #40]	; (f434 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    f40c:	9b01      	ldr	r3, [sp, #4]
    f40e:	9a00      	ldr	r2, [sp, #0]
    f410:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    f414:	4a06      	ldr	r2, [pc, #24]	; (f430 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    f416:	9b01      	ldr	r3, [sp, #4]
    f418:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f41c:	1c5a      	adds	r2, r3, #1
    f41e:	4904      	ldr	r1, [pc, #16]	; (f430 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    f420:	9b01      	ldr	r3, [sp, #4]
    f422:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f426:	bf00      	nop
    f428:	b003      	add	sp, #12
    f42a:	f85d fb04 	ldr.w	pc, [sp], #4
    f42e:	bf00      	nop
    f430:	1fff9164 	.word	0x1fff9164
    f434:	1fff9160 	.word	0x1fff9160

0000f438 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    f438:	b500      	push	{lr}
    f43a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f43c:	f7f1 ff20 	bl	1280 <Sys_GetCoreID>
    f440:	4603      	mov	r3, r0
    f442:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    f444:	4a0d      	ldr	r2, [pc, #52]	; (f47c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    f446:	9b01      	ldr	r3, [sp, #4]
    f448:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f44c:	1e5a      	subs	r2, r3, #1
    f44e:	490b      	ldr	r1, [pc, #44]	; (f47c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    f450:	9b01      	ldr	r3, [sp, #4]
    f452:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    f456:	4a0a      	ldr	r2, [pc, #40]	; (f480 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    f458:	9b01      	ldr	r3, [sp, #4]
    f45a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f45e:	f003 0301 	and.w	r3, r3, #1
    f462:	2b00      	cmp	r3, #0
    f464:	d106      	bne.n	f474 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    f466:	4a05      	ldr	r2, [pc, #20]	; (f47c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    f468:	9b01      	ldr	r3, [sp, #4]
    f46a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f46e:	2b00      	cmp	r3, #0
    f470:	d100      	bne.n	f474 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f472:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f474:	bf00      	nop
    f476:	b003      	add	sp, #12
    f478:	f85d fb04 	ldr.w	pc, [sp], #4
    f47c:	1fff9164 	.word	0x1fff9164
    f480:	1fff9160 	.word	0x1fff9160

0000f484 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    f484:	b500      	push	{lr}
    f486:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f488:	f7f1 fefa 	bl	1280 <Sys_GetCoreID>
    f48c:	4603      	mov	r3, r0
    f48e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    f490:	4a10      	ldr	r2, [pc, #64]	; (f4d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    f492:	9b01      	ldr	r3, [sp, #4]
    f494:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f498:	2b00      	cmp	r3, #0
    f49a:	d10d      	bne.n	f4b8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f49c:	f7f1 fc1f 	bl	cde <Port_schm_read_msr>
    f4a0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f4a2:	9b00      	ldr	r3, [sp, #0]
    f4a4:	f003 0301 	and.w	r3, r3, #1
    f4a8:	2b00      	cmp	r3, #0
    f4aa:	d100      	bne.n	f4ae <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f4ac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    f4ae:	490a      	ldr	r1, [pc, #40]	; (f4d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    f4b0:	9b01      	ldr	r3, [sp, #4]
    f4b2:	9a00      	ldr	r2, [sp, #0]
    f4b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    f4b8:	4a06      	ldr	r2, [pc, #24]	; (f4d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    f4ba:	9b01      	ldr	r3, [sp, #4]
    f4bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f4c0:	1c5a      	adds	r2, r3, #1
    f4c2:	4904      	ldr	r1, [pc, #16]	; (f4d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    f4c4:	9b01      	ldr	r3, [sp, #4]
    f4c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f4ca:	bf00      	nop
    f4cc:	b003      	add	sp, #12
    f4ce:	f85d fb04 	ldr.w	pc, [sp], #4
    f4d2:	bf00      	nop
    f4d4:	1fff916c 	.word	0x1fff916c
    f4d8:	1fff9168 	.word	0x1fff9168

0000f4dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    f4dc:	b500      	push	{lr}
    f4de:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f4e0:	f7f1 fece 	bl	1280 <Sys_GetCoreID>
    f4e4:	4603      	mov	r3, r0
    f4e6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    f4e8:	4a0d      	ldr	r2, [pc, #52]	; (f520 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    f4ea:	9b01      	ldr	r3, [sp, #4]
    f4ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f4f0:	1e5a      	subs	r2, r3, #1
    f4f2:	490b      	ldr	r1, [pc, #44]	; (f520 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    f4f4:	9b01      	ldr	r3, [sp, #4]
    f4f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    f4fa:	4a0a      	ldr	r2, [pc, #40]	; (f524 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    f4fc:	9b01      	ldr	r3, [sp, #4]
    f4fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f502:	f003 0301 	and.w	r3, r3, #1
    f506:	2b00      	cmp	r3, #0
    f508:	d106      	bne.n	f518 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    f50a:	4a05      	ldr	r2, [pc, #20]	; (f520 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    f50c:	9b01      	ldr	r3, [sp, #4]
    f50e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f512:	2b00      	cmp	r3, #0
    f514:	d100      	bne.n	f518 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f516:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f518:	bf00      	nop
    f51a:	b003      	add	sp, #12
    f51c:	f85d fb04 	ldr.w	pc, [sp], #4
    f520:	1fff916c 	.word	0x1fff916c
    f524:	1fff9168 	.word	0x1fff9168

0000f528 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    f528:	b500      	push	{lr}
    f52a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f52c:	f7f1 fea8 	bl	1280 <Sys_GetCoreID>
    f530:	4603      	mov	r3, r0
    f532:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    f534:	4a10      	ldr	r2, [pc, #64]	; (f578 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    f536:	9b01      	ldr	r3, [sp, #4]
    f538:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f53c:	2b00      	cmp	r3, #0
    f53e:	d10d      	bne.n	f55c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f540:	f7f1 fbcd 	bl	cde <Port_schm_read_msr>
    f544:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f546:	9b00      	ldr	r3, [sp, #0]
    f548:	f003 0301 	and.w	r3, r3, #1
    f54c:	2b00      	cmp	r3, #0
    f54e:	d100      	bne.n	f552 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f550:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    f552:	490a      	ldr	r1, [pc, #40]	; (f57c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    f554:	9b01      	ldr	r3, [sp, #4]
    f556:	9a00      	ldr	r2, [sp, #0]
    f558:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    f55c:	4a06      	ldr	r2, [pc, #24]	; (f578 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    f55e:	9b01      	ldr	r3, [sp, #4]
    f560:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f564:	1c5a      	adds	r2, r3, #1
    f566:	4904      	ldr	r1, [pc, #16]	; (f578 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    f568:	9b01      	ldr	r3, [sp, #4]
    f56a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f56e:	bf00      	nop
    f570:	b003      	add	sp, #12
    f572:	f85d fb04 	ldr.w	pc, [sp], #4
    f576:	bf00      	nop
    f578:	1fff9174 	.word	0x1fff9174
    f57c:	1fff9170 	.word	0x1fff9170

0000f580 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    f580:	b500      	push	{lr}
    f582:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f584:	f7f1 fe7c 	bl	1280 <Sys_GetCoreID>
    f588:	4603      	mov	r3, r0
    f58a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    f58c:	4a0d      	ldr	r2, [pc, #52]	; (f5c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    f58e:	9b01      	ldr	r3, [sp, #4]
    f590:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f594:	1e5a      	subs	r2, r3, #1
    f596:	490b      	ldr	r1, [pc, #44]	; (f5c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    f598:	9b01      	ldr	r3, [sp, #4]
    f59a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    f59e:	4a0a      	ldr	r2, [pc, #40]	; (f5c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    f5a0:	9b01      	ldr	r3, [sp, #4]
    f5a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f5a6:	f003 0301 	and.w	r3, r3, #1
    f5aa:	2b00      	cmp	r3, #0
    f5ac:	d106      	bne.n	f5bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    f5ae:	4a05      	ldr	r2, [pc, #20]	; (f5c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    f5b0:	9b01      	ldr	r3, [sp, #4]
    f5b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f5b6:	2b00      	cmp	r3, #0
    f5b8:	d100      	bne.n	f5bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f5ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f5bc:	bf00      	nop
    f5be:	b003      	add	sp, #12
    f5c0:	f85d fb04 	ldr.w	pc, [sp], #4
    f5c4:	1fff9174 	.word	0x1fff9174
    f5c8:	1fff9170 	.word	0x1fff9170

0000f5cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    f5cc:	b500      	push	{lr}
    f5ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f5d0:	f7f1 fe56 	bl	1280 <Sys_GetCoreID>
    f5d4:	4603      	mov	r3, r0
    f5d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    f5d8:	4a10      	ldr	r2, [pc, #64]	; (f61c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    f5da:	9b01      	ldr	r3, [sp, #4]
    f5dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f5e0:	2b00      	cmp	r3, #0
    f5e2:	d10d      	bne.n	f600 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f5e4:	f7f1 fb7b 	bl	cde <Port_schm_read_msr>
    f5e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f5ea:	9b00      	ldr	r3, [sp, #0]
    f5ec:	f003 0301 	and.w	r3, r3, #1
    f5f0:	2b00      	cmp	r3, #0
    f5f2:	d100      	bne.n	f5f6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f5f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    f5f6:	490a      	ldr	r1, [pc, #40]	; (f620 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    f5f8:	9b01      	ldr	r3, [sp, #4]
    f5fa:	9a00      	ldr	r2, [sp, #0]
    f5fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    f600:	4a06      	ldr	r2, [pc, #24]	; (f61c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    f602:	9b01      	ldr	r3, [sp, #4]
    f604:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f608:	1c5a      	adds	r2, r3, #1
    f60a:	4904      	ldr	r1, [pc, #16]	; (f61c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    f60c:	9b01      	ldr	r3, [sp, #4]
    f60e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f612:	bf00      	nop
    f614:	b003      	add	sp, #12
    f616:	f85d fb04 	ldr.w	pc, [sp], #4
    f61a:	bf00      	nop
    f61c:	1fff917c 	.word	0x1fff917c
    f620:	1fff9178 	.word	0x1fff9178

0000f624 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    f624:	b500      	push	{lr}
    f626:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f628:	f7f1 fe2a 	bl	1280 <Sys_GetCoreID>
    f62c:	4603      	mov	r3, r0
    f62e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    f630:	4a0d      	ldr	r2, [pc, #52]	; (f668 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    f632:	9b01      	ldr	r3, [sp, #4]
    f634:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f638:	1e5a      	subs	r2, r3, #1
    f63a:	490b      	ldr	r1, [pc, #44]	; (f668 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    f63c:	9b01      	ldr	r3, [sp, #4]
    f63e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    f642:	4a0a      	ldr	r2, [pc, #40]	; (f66c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    f644:	9b01      	ldr	r3, [sp, #4]
    f646:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f64a:	f003 0301 	and.w	r3, r3, #1
    f64e:	2b00      	cmp	r3, #0
    f650:	d106      	bne.n	f660 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    f652:	4a05      	ldr	r2, [pc, #20]	; (f668 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    f654:	9b01      	ldr	r3, [sp, #4]
    f656:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f65a:	2b00      	cmp	r3, #0
    f65c:	d100      	bne.n	f660 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f65e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f660:	bf00      	nop
    f662:	b003      	add	sp, #12
    f664:	f85d fb04 	ldr.w	pc, [sp], #4
    f668:	1fff917c 	.word	0x1fff917c
    f66c:	1fff9178 	.word	0x1fff9178

0000f670 <Det_Init>:
*
*/
void Det_Init(void)
{
    /* Do nothing */
}
    f670:	bf00      	nop
    f672:	4770      	bx	lr

0000f674 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
    f674:	b510      	push	{r4, lr}
    f676:	b084      	sub	sp, #16
    f678:	4604      	mov	r4, r0
    f67a:	4608      	mov	r0, r1
    f67c:	4611      	mov	r1, r2
    f67e:	461a      	mov	r2, r3
    f680:	4623      	mov	r3, r4
    f682:	f8ad 3006 	strh.w	r3, [sp, #6]
    f686:	4603      	mov	r3, r0
    f688:	f88d 3005 	strb.w	r3, [sp, #5]
    f68c:	460b      	mov	r3, r1
    f68e:	f88d 3004 	strb.w	r3, [sp, #4]
    f692:	4613      	mov	r3, r2
    f694:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f698:	f7f1 fdf2 	bl	1280 <Sys_GetCoreID>
    f69c:	4603      	mov	r3, r0
    f69e:	9303      	str	r3, [sp, #12]

    Det_ModuleId[u32CoreId] = ModuleId;
    f6a0:	490d      	ldr	r1, [pc, #52]	; (f6d8 <Det_ReportError+0x64>)
    f6a2:	9b03      	ldr	r3, [sp, #12]
    f6a4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f6a8:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
    f6ac:	4a0b      	ldr	r2, [pc, #44]	; (f6dc <Det_ReportError+0x68>)
    f6ae:	9b03      	ldr	r3, [sp, #12]
    f6b0:	4413      	add	r3, r2
    f6b2:	f89d 2005 	ldrb.w	r2, [sp, #5]
    f6b6:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
    f6b8:	4a09      	ldr	r2, [pc, #36]	; (f6e0 <Det_ReportError+0x6c>)
    f6ba:	9b03      	ldr	r3, [sp, #12]
    f6bc:	4413      	add	r3, r2
    f6be:	f89d 2004 	ldrb.w	r2, [sp, #4]
    f6c2:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
    f6c4:	4a07      	ldr	r2, [pc, #28]	; (f6e4 <Det_ReportError+0x70>)
    f6c6:	9b03      	ldr	r3, [sp, #12]
    f6c8:	4413      	add	r3, r2
    f6ca:	f89d 2003 	ldrb.w	r2, [sp, #3]
    f6ce:	701a      	strb	r2, [r3, #0]

    return E_OK;
    f6d0:	2300      	movs	r3, #0
}
    f6d2:	4618      	mov	r0, r3
    f6d4:	b004      	add	sp, #16
    f6d6:	bd10      	pop	{r4, pc}
    f6d8:	1fff91a8 	.word	0x1fff91a8
    f6dc:	1fff9180 	.word	0x1fff9180
    f6e0:	1fff9184 	.word	0x1fff9184
    f6e4:	1fff9188 	.word	0x1fff9188

0000f6e8 <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
    f6e8:	b510      	push	{r4, lr}
    f6ea:	b084      	sub	sp, #16
    f6ec:	4604      	mov	r4, r0
    f6ee:	4608      	mov	r0, r1
    f6f0:	4611      	mov	r1, r2
    f6f2:	461a      	mov	r2, r3
    f6f4:	4623      	mov	r3, r4
    f6f6:	f8ad 3006 	strh.w	r3, [sp, #6]
    f6fa:	4603      	mov	r3, r0
    f6fc:	f88d 3005 	strb.w	r3, [sp, #5]
    f700:	460b      	mov	r3, r1
    f702:	f88d 3004 	strb.w	r3, [sp, #4]
    f706:	4613      	mov	r3, r2
    f708:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f70c:	f7f1 fdb8 	bl	1280 <Sys_GetCoreID>
    f710:	4603      	mov	r3, r0
    f712:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
    f714:	490d      	ldr	r1, [pc, #52]	; (f74c <Det_ReportRuntimeError+0x64>)
    f716:	9b03      	ldr	r3, [sp, #12]
    f718:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f71c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
    f720:	4a0b      	ldr	r2, [pc, #44]	; (f750 <Det_ReportRuntimeError+0x68>)
    f722:	9b03      	ldr	r3, [sp, #12]
    f724:	4413      	add	r3, r2
    f726:	f89d 2005 	ldrb.w	r2, [sp, #5]
    f72a:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
    f72c:	4a09      	ldr	r2, [pc, #36]	; (f754 <Det_ReportRuntimeError+0x6c>)
    f72e:	9b03      	ldr	r3, [sp, #12]
    f730:	4413      	add	r3, r2
    f732:	f89d 2004 	ldrb.w	r2, [sp, #4]
    f736:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
    f738:	4a07      	ldr	r2, [pc, #28]	; (f758 <Det_ReportRuntimeError+0x70>)
    f73a:	9b03      	ldr	r3, [sp, #12]
    f73c:	4413      	add	r3, r2
    f73e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    f742:	701a      	strb	r2, [r3, #0]

    return E_OK;
    f744:	2300      	movs	r3, #0
}
    f746:	4618      	mov	r0, r3
    f748:	b004      	add	sp, #16
    f74a:	bd10      	pop	{r4, pc}
    f74c:	1fff91ac 	.word	0x1fff91ac
    f750:	1fff918c 	.word	0x1fff918c
    f754:	1fff9190 	.word	0x1fff9190
    f758:	1fff9194 	.word	0x1fff9194

0000f75c <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
    f75c:	b510      	push	{r4, lr}
    f75e:	b084      	sub	sp, #16
    f760:	4604      	mov	r4, r0
    f762:	4608      	mov	r0, r1
    f764:	4611      	mov	r1, r2
    f766:	461a      	mov	r2, r3
    f768:	4623      	mov	r3, r4
    f76a:	f8ad 3006 	strh.w	r3, [sp, #6]
    f76e:	4603      	mov	r3, r0
    f770:	f88d 3005 	strb.w	r3, [sp, #5]
    f774:	460b      	mov	r3, r1
    f776:	f88d 3004 	strb.w	r3, [sp, #4]
    f77a:	4613      	mov	r3, r2
    f77c:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f780:	f7f1 fd7e 	bl	1280 <Sys_GetCoreID>
    f784:	4603      	mov	r3, r0
    f786:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
    f788:	490d      	ldr	r1, [pc, #52]	; (f7c0 <Det_ReportTransientFault+0x64>)
    f78a:	9b03      	ldr	r3, [sp, #12]
    f78c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f790:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
    f794:	4a0b      	ldr	r2, [pc, #44]	; (f7c4 <Det_ReportTransientFault+0x68>)
    f796:	9b03      	ldr	r3, [sp, #12]
    f798:	4413      	add	r3, r2
    f79a:	f89d 2005 	ldrb.w	r2, [sp, #5]
    f79e:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
    f7a0:	4a09      	ldr	r2, [pc, #36]	; (f7c8 <Det_ReportTransientFault+0x6c>)
    f7a2:	9b03      	ldr	r3, [sp, #12]
    f7a4:	4413      	add	r3, r2
    f7a6:	f89d 2004 	ldrb.w	r2, [sp, #4]
    f7aa:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
    f7ac:	4a07      	ldr	r2, [pc, #28]	; (f7cc <Det_ReportTransientFault+0x70>)
    f7ae:	9b03      	ldr	r3, [sp, #12]
    f7b0:	4413      	add	r3, r2
    f7b2:	f89d 2003 	ldrb.w	r2, [sp, #3]
    f7b6:	701a      	strb	r2, [r3, #0]

    return E_OK;
    f7b8:	2300      	movs	r3, #0
}
    f7ba:	4618      	mov	r0, r3
    f7bc:	b004      	add	sp, #16
    f7be:	bd10      	pop	{r4, pc}
    f7c0:	1fff91a4 	.word	0x1fff91a4
    f7c4:	1fff9198 	.word	0x1fff9198
    f7c8:	1fff919c 	.word	0x1fff919c
    f7cc:	1fff91a0 	.word	0x1fff91a0

0000f7d0 <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
    f7d0:	bf00      	nop
    f7d2:	4770      	bx	lr

0000f7d4 <CanIf_Init>:
==================================================================================================*/
#define CANIF_START_SEC_CODE
#include "CanIf_MemMap.h"

void CanIf_Init(const CanIf_ConfigType * ConfigPtr)
{
    f7d4:	b082      	sub	sp, #8
    f7d6:	9001      	str	r0, [sp, #4]
    #if (STD_ON == CANIF_PRECOMPILE_SUPPORT)
    CanIf_ConfigPtr = &CanIf_Config;
    (void)ConfigPtr;
    #else
    CanIf_ConfigPtr = ConfigPtr;
    f7d8:	4a02      	ldr	r2, [pc, #8]	; (f7e4 <CanIf_Init+0x10>)
    f7da:	9b01      	ldr	r3, [sp, #4]
    f7dc:	6013      	str	r3, [r2, #0]
    #endif
}
    f7de:	bf00      	nop
    f7e0:	b002      	add	sp, #8
    f7e2:	4770      	bx	lr
    f7e4:	1fff91b0 	.word	0x1fff91b0

0000f7e8 <CanIf_Transmit>:
Std_ReturnType CanIf_Transmit
(
    PduIdType CanTxPduId,
    const PduInfoType * PduInfoPtr
)
{
    f7e8:	b500      	push	{lr}
    f7ea:	b08b      	sub	sp, #44	; 0x2c
    f7ec:	4603      	mov	r3, r0
    f7ee:	9100      	str	r1, [sp, #0]
    f7f0:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType RetVal = E_NOT_OK;
    f7f4:	2301      	movs	r3, #1
    f7f6:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Can_HwHandleType CanHth = 0U;
    f7fa:	2300      	movs	r3, #0
    f7fc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    Can_PduType PduInfo;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
    f800:	2300      	movs	r3, #0
    f802:	9308      	str	r3, [sp, #32]
    uint8 CanIfControllerId = 0U;
    f804:	2300      	movs	r3, #0
    f806:	f88d 301f 	strb.w	r3, [sp, #31]
    const CanIf_CtrlPCConfigType * CanIfController = NULL_PTR;
    f80a:	2300      	movs	r3, #0
    f80c:	9306      	str	r3, [sp, #24]

    if (NULL_PTR != CanIf_ConfigPtr)
    f80e:	4b31      	ldr	r3, [pc, #196]	; (f8d4 <CanIf_Transmit+0xec>)
    f810:	681b      	ldr	r3, [r3, #0]
    f812:	2b00      	cmp	r3, #0
    f814:	d057      	beq.n	f8c6 <CanIf_Transmit+0xde>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
    f816:	4b2f      	ldr	r3, [pc, #188]	; (f8d4 <CanIf_Transmit+0xec>)
    f818:	681b      	ldr	r3, [r3, #0]
    f81a:	785b      	ldrb	r3, [r3, #1]
    f81c:	b29b      	uxth	r3, r3
    f81e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f822:	429a      	cmp	r2, r3
    f824:	d24f      	bcs.n	f8c6 <CanIf_Transmit+0xde>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
    f826:	4b2b      	ldr	r3, [pc, #172]	; (f8d4 <CanIf_Transmit+0xec>)
    f828:	681b      	ldr	r3, [r3, #0]
    f82a:	68d9      	ldr	r1, [r3, #12]
    f82c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f830:	4613      	mov	r3, r2
    f832:	009b      	lsls	r3, r3, #2
    f834:	4413      	add	r3, r2
    f836:	009b      	lsls	r3, r3, #2
    f838:	440b      	add	r3, r1
    f83a:	9308      	str	r3, [sp, #32]
            CanIfControllerId = TxPduInfo->CanIfCtrlId;
    f83c:	9b08      	ldr	r3, [sp, #32]
    f83e:	7b9b      	ldrb	r3, [r3, #14]
    f840:	f88d 301f 	strb.w	r3, [sp, #31]
            CanIfController = &CanIf_PCConfig.CanIfCtrlConfigPtr[CanIfControllerId];
    f844:	4b24      	ldr	r3, [pc, #144]	; (f8d8 <CanIf_Transmit+0xf0>)
    f846:	685a      	ldr	r2, [r3, #4]
    f848:	f89d 301f 	ldrb.w	r3, [sp, #31]
    f84c:	00db      	lsls	r3, r3, #3
    f84e:	4413      	add	r3, r2
    f850:	9306      	str	r3, [sp, #24]

            CanHth = TxPduInfo->CanHth;
    f852:	9b08      	ldr	r3, [sp, #32]
    f854:	899b      	ldrh	r3, [r3, #12]
    f856:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

            PduInfo.id = TxPduInfo->CanId;
    f85a:	9b08      	ldr	r3, [sp, #32]
    f85c:	685b      	ldr	r3, [r3, #4]
    f85e:	9303      	str	r3, [sp, #12]
            /* Convert Id by adding two most significant bits specify the frame type */
            switch (TxPduInfo->CanFrameType)
    f860:	9b08      	ldr	r3, [sp, #32]
    f862:	689b      	ldr	r3, [r3, #8]
    f864:	2b03      	cmp	r3, #3
    f866:	d010      	beq.n	f88a <CanIf_Transmit+0xa2>
    f868:	2b03      	cmp	r3, #3
    f86a:	d813      	bhi.n	f894 <CanIf_Transmit+0xac>
    f86c:	2b00      	cmp	r3, #0
    f86e:	d002      	beq.n	f876 <CanIf_Transmit+0x8e>
    f870:	2b01      	cmp	r3, #1
    f872:	d005      	beq.n	f880 <CanIf_Transmit+0x98>
                    PduInfo.id |= 0x40000000U;
                    break;
                }
                default:
                {
                    break;
    f874:	e00e      	b.n	f894 <CanIf_Transmit+0xac>
                    PduInfo.id |= 0x80000000U;
    f876:	9b03      	ldr	r3, [sp, #12]
    f878:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    f87c:	9303      	str	r3, [sp, #12]
                    break;
    f87e:	e00a      	b.n	f896 <CanIf_Transmit+0xae>
                    PduInfo.id |= 0xC0000000U;
    f880:	9b03      	ldr	r3, [sp, #12]
    f882:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    f886:	9303      	str	r3, [sp, #12]
                    break;
    f888:	e005      	b.n	f896 <CanIf_Transmit+0xae>
                    PduInfo.id |= 0x40000000U;
    f88a:	9b03      	ldr	r3, [sp, #12]
    f88c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    f890:	9303      	str	r3, [sp, #12]
                    break;
    f892:	e000      	b.n	f896 <CanIf_Transmit+0xae>
                    break;
    f894:	bf00      	nop
                }
            }
            
            PduInfo.length = (uint8)(PduInfoPtr->SduLength);
    f896:	9b00      	ldr	r3, [sp, #0]
    f898:	689b      	ldr	r3, [r3, #8]
    f89a:	b2db      	uxtb	r3, r3
    f89c:	f88d 3012 	strb.w	r3, [sp, #18]
            PduInfo.sdu = PduInfoPtr->SduDataPtr;
    f8a0:	9b00      	ldr	r3, [sp, #0]
    f8a2:	681b      	ldr	r3, [r3, #0]
    f8a4:	9305      	str	r3, [sp, #20]
            PduInfo.swPduHandle = CanTxPduId;
    f8a6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    f8aa:	f8ad 3010 	strh.w	r3, [sp, #16]

            RetVal = CanIfController->CanDrvConfigPtr->CanApi->CanWrite(CanHth, &PduInfo); 
    f8ae:	9b06      	ldr	r3, [sp, #24]
    f8b0:	685b      	ldr	r3, [r3, #4]
    f8b2:	685b      	ldr	r3, [r3, #4]
    f8b4:	681b      	ldr	r3, [r3, #0]
    f8b6:	a903      	add	r1, sp, #12
    f8b8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    f8bc:	4610      	mov	r0, r2
    f8be:	4798      	blx	r3
    f8c0:	4603      	mov	r3, r0
    f8c2:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
    }
    return RetVal;
    f8c6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    f8ca:	4618      	mov	r0, r3
    f8cc:	b00b      	add	sp, #44	; 0x2c
    f8ce:	f85d fb04 	ldr.w	pc, [sp], #4
    f8d2:	bf00      	nop
    f8d4:	1fff91b0 	.word	0x1fff91b0
    f8d8:	000105fc 	.word	0x000105fc

0000f8dc <CanIf_TxConfirmation>:

void CanIf_TxConfirmation
(
    PduIdType CanTxPduId
)
{
    f8dc:	b500      	push	{lr}
    f8de:	b085      	sub	sp, #20
    f8e0:	4603      	mov	r3, r0
    f8e2:	f8ad 3006 	strh.w	r3, [sp, #6]
    PduIdType UserPduId;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
    f8e6:	2300      	movs	r3, #0
    f8e8:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != CanIf_ConfigPtr)
    f8ea:	4b15      	ldr	r3, [pc, #84]	; (f940 <CanIf_TxConfirmation+0x64>)
    f8ec:	681b      	ldr	r3, [r3, #0]
    f8ee:	2b00      	cmp	r3, #0
    f8f0:	d021      	beq.n	f936 <CanIf_TxConfirmation+0x5a>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
    f8f2:	4b13      	ldr	r3, [pc, #76]	; (f940 <CanIf_TxConfirmation+0x64>)
    f8f4:	681b      	ldr	r3, [r3, #0]
    f8f6:	785b      	ldrb	r3, [r3, #1]
    f8f8:	b29b      	uxth	r3, r3
    f8fa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f8fe:	429a      	cmp	r2, r3
    f900:	d219      	bcs.n	f936 <CanIf_TxConfirmation+0x5a>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
    f902:	4b0f      	ldr	r3, [pc, #60]	; (f940 <CanIf_TxConfirmation+0x64>)
    f904:	681b      	ldr	r3, [r3, #0]
    f906:	68d9      	ldr	r1, [r3, #12]
    f908:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    f90c:	4613      	mov	r3, r2
    f90e:	009b      	lsls	r3, r3, #2
    f910:	4413      	add	r3, r2
    f912:	009b      	lsls	r3, r3, #2
    f914:	440b      	add	r3, r1
    f916:	9303      	str	r3, [sp, #12]

            if (NULL_PTR != TxPduInfo->UserTxConfirmation)
    f918:	9b03      	ldr	r3, [sp, #12]
    f91a:	691b      	ldr	r3, [r3, #16]
    f91c:	2b00      	cmp	r3, #0
    f91e:	d00a      	beq.n	f936 <CanIf_TxConfirmation+0x5a>
            {
                UserPduId = TxPduInfo->PduId;
    f920:	9b03      	ldr	r3, [sp, #12]
    f922:	881b      	ldrh	r3, [r3, #0]
    f924:	f8ad 300a 	strh.w	r3, [sp, #10]
                TxPduInfo->UserTxConfirmation(UserPduId, E_OK);
    f928:	9b03      	ldr	r3, [sp, #12]
    f92a:	691b      	ldr	r3, [r3, #16]
    f92c:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    f930:	2100      	movs	r1, #0
    f932:	4610      	mov	r0, r2
    f934:	4798      	blx	r3
            }
        }
    }
}
    f936:	bf00      	nop
    f938:	b005      	add	sp, #20
    f93a:	f85d fb04 	ldr.w	pc, [sp], #4
    f93e:	bf00      	nop
    f940:	1fff91b0 	.word	0x1fff91b0

0000f944 <CanIf_RxIndication>:
void CanIf_RxIndication
(
    const Can_HwType * Mailbox,
    const PduInfoType * PduInfoPtr
)
{
    f944:	b500      	push	{lr}
    f946:	b089      	sub	sp, #36	; 0x24
    f948:	9001      	str	r0, [sp, #4]
    f94a:	9100      	str	r1, [sp, #0]
    PduIdType UserPduId = 0U;
    f94c:	2300      	movs	r3, #0
    f94e:	f8ad 301e 	strh.w	r3, [sp, #30]
    PduInfoType PduInfo;
    const CanIf_RxPduType * RxPduInfo = NULL_PTR;
    f952:	2300      	movs	r3, #0
    f954:	9306      	str	r3, [sp, #24]
    uint8 CanDrvId = 0U;
    f956:	2300      	movs	r3, #0
    f958:	f88d 3017 	strb.w	r3, [sp, #23]

    if (NULL_PTR != CanIf_ConfigPtr)
    f95c:	4b2c      	ldr	r3, [pc, #176]	; (fa10 <CanIf_RxIndication+0xcc>)
    f95e:	681b      	ldr	r3, [r3, #0]
    f960:	2b00      	cmp	r3, #0
    f962:	d050      	beq.n	fa06 <CanIf_RxIndication+0xc2>
    {
        if ((Mailbox->ControllerId) < (CanIf_PCConfig.NumOfCtrl))
    f964:	9b01      	ldr	r3, [sp, #4]
    f966:	799a      	ldrb	r2, [r3, #6]
    f968:	4b2a      	ldr	r3, [pc, #168]	; (fa14 <CanIf_RxIndication+0xd0>)
    f96a:	781b      	ldrb	r3, [r3, #0]
    f96c:	429a      	cmp	r2, r3
    f96e:	d24a      	bcs.n	fa06 <CanIf_RxIndication+0xc2>
        {
            if ((Mailbox->Hoh) < (CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->NumCanHoh))
    f970:	9b01      	ldr	r3, [sp, #4]
    f972:	889a      	ldrh	r2, [r3, #4]
    f974:	4b27      	ldr	r3, [pc, #156]	; (fa14 <CanIf_RxIndication+0xd0>)
    f976:	6859      	ldr	r1, [r3, #4]
    f978:	9b01      	ldr	r3, [sp, #4]
    f97a:	799b      	ldrb	r3, [r3, #6]
    f97c:	00db      	lsls	r3, r3, #3
    f97e:	440b      	add	r3, r1
    f980:	685b      	ldr	r3, [r3, #4]
    f982:	885b      	ldrh	r3, [r3, #2]
    f984:	429a      	cmp	r2, r3
    f986:	d23e      	bcs.n	fa06 <CanIf_RxIndication+0xc2>
            {
                CanDrvId = CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->CanDrvId;
    f988:	4b22      	ldr	r3, [pc, #136]	; (fa14 <CanIf_RxIndication+0xd0>)
    f98a:	685a      	ldr	r2, [r3, #4]
    f98c:	9b01      	ldr	r3, [sp, #4]
    f98e:	799b      	ldrb	r3, [r3, #6]
    f990:	00db      	lsls	r3, r3, #3
    f992:	4413      	add	r3, r2
    f994:	685b      	ldr	r3, [r3, #4]
    f996:	781b      	ldrb	r3, [r3, #0]
    f998:	f88d 3017 	strb.w	r3, [sp, #23]
                RxPduInfo = CanIf_ConfigPtr->CanDrvConfigPtr[CanDrvId]->HohToRxPduMappingPtr[Mailbox->Hoh];
    f99c:	4b1c      	ldr	r3, [pc, #112]	; (fa10 <CanIf_RxIndication+0xcc>)
    f99e:	681b      	ldr	r3, [r3, #0]
    f9a0:	685a      	ldr	r2, [r3, #4]
    f9a2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    f9a6:	009b      	lsls	r3, r3, #2
    f9a8:	4413      	add	r3, r2
    f9aa:	681b      	ldr	r3, [r3, #0]
    f9ac:	681a      	ldr	r2, [r3, #0]
    f9ae:	9b01      	ldr	r3, [sp, #4]
    f9b0:	889b      	ldrh	r3, [r3, #4]
    f9b2:	009b      	lsls	r3, r3, #2
    f9b4:	4413      	add	r3, r2
    f9b6:	681b      	ldr	r3, [r3, #0]
    f9b8:	9306      	str	r3, [sp, #24]
                
                /* Will discard the Can HOH if it was not referred by any CanIf RxPDU */
                if (NULL_PTR != RxPduInfo)
    f9ba:	9b06      	ldr	r3, [sp, #24]
    f9bc:	2b00      	cmp	r3, #0
    f9be:	d022      	beq.n	fa06 <CanIf_RxIndication+0xc2>
                {
                    if (NULL_PTR != RxPduInfo->UserRxIndication)
    f9c0:	9b06      	ldr	r3, [sp, #24]
    f9c2:	689b      	ldr	r3, [r3, #8]
    f9c4:	2b00      	cmp	r3, #0
    f9c6:	d01e      	beq.n	fa06 <CanIf_RxIndication+0xc2>
                    {
                        UserPduId = RxPduInfo->PduId;
    f9c8:	9b06      	ldr	r3, [sp, #24]
    f9ca:	881b      	ldrh	r3, [r3, #0]
    f9cc:	f8ad 301e 	strh.w	r3, [sp, #30]
                        if ((TRUE == RxPduInfo->PduLengthCheck) && (PduInfoPtr->SduLength > (RxPduInfo->PduLength)))
    f9d0:	9b06      	ldr	r3, [sp, #24]
    f9d2:	789b      	ldrb	r3, [r3, #2]
    f9d4:	2b00      	cmp	r3, #0
    f9d6:	d009      	beq.n	f9ec <CanIf_RxIndication+0xa8>
    f9d8:	9b00      	ldr	r3, [sp, #0]
    f9da:	689b      	ldr	r3, [r3, #8]
    f9dc:	9a06      	ldr	r2, [sp, #24]
    f9de:	8892      	ldrh	r2, [r2, #4]
    f9e0:	4293      	cmp	r3, r2
    f9e2:	d903      	bls.n	f9ec <CanIf_RxIndication+0xa8>
                        {
                            PduInfo.SduLength = RxPduInfo->PduLength; /* Truncates exceeded data as configured on GUI */
    f9e4:	9b06      	ldr	r3, [sp, #24]
    f9e6:	889b      	ldrh	r3, [r3, #4]
    f9e8:	9304      	str	r3, [sp, #16]
    f9ea:	e002      	b.n	f9f2 <CanIf_RxIndication+0xae>
                        }
                        else
                        {
                            PduInfo.SduLength = PduInfoPtr->SduLength;
    f9ec:	9b00      	ldr	r3, [sp, #0]
    f9ee:	689b      	ldr	r3, [r3, #8]
    f9f0:	9304      	str	r3, [sp, #16]
                        }
                        PduInfo.SduDataPtr = PduInfoPtr->SduDataPtr;
    f9f2:	9b00      	ldr	r3, [sp, #0]
    f9f4:	681b      	ldr	r3, [r3, #0]
    f9f6:	9302      	str	r3, [sp, #8]
                        RxPduInfo->UserRxIndication(UserPduId, &PduInfo);
    f9f8:	9b06      	ldr	r3, [sp, #24]
    f9fa:	689b      	ldr	r3, [r3, #8]
    f9fc:	a902      	add	r1, sp, #8
    f9fe:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    fa02:	4610      	mov	r0, r2
    fa04:	4798      	blx	r3
                    }
                }
            }
        }
    }
}
    fa06:	bf00      	nop
    fa08:	b009      	add	sp, #36	; 0x24
    fa0a:	f85d fb04 	ldr.w	pc, [sp], #4
    fa0e:	bf00      	nop
    fa10:	1fff91b0 	.word	0x1fff91b0
    fa14:	000105fc 	.word	0x000105fc

0000fa18 <CanIf_ControllerModeIndication>:
void CanIf_ControllerModeIndication
( 
    uint8 ControllerId, 
    Can_ControllerStateType ControllerMode 
)
{
    fa18:	b082      	sub	sp, #8
    fa1a:	4603      	mov	r3, r0
    fa1c:	9100      	str	r1, [sp, #0]
    fa1e:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId; 
    (void)ControllerMode;
}
    fa22:	bf00      	nop
    fa24:	b002      	add	sp, #8
    fa26:	4770      	bx	lr

0000fa28 <CanIf_ControllerBusOff>:
void CanIf_ControllerBusOff
(
    uint8 ControllerId
)
{
    fa28:	b082      	sub	sp, #8
    fa2a:	4603      	mov	r3, r0
    fa2c:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
}
    fa30:	bf00      	nop
    fa32:	b002      	add	sp, #8
    fa34:	4770      	bx	lr

0000fa36 <CanIf_SetControllerMode>:

Std_ReturnType CanIf_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition )
{
    fa36:	b082      	sub	sp, #8
    fa38:	4603      	mov	r3, r0
    fa3a:	9100      	str	r1, [sp, #0]
    fa3c:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)Controller;
    (void)Transition;
}
    fa40:	bf00      	nop
    fa42:	4618      	mov	r0, r3
    fa44:	b002      	add	sp, #8
    fa46:	4770      	bx	lr

0000fa48 <CanIf_DisableControllerInterrupts>:
void CanIf_DisableControllerInterrupts( uint8 Controller )
{
    fa48:	b082      	sub	sp, #8
    fa4a:	4603      	mov	r3, r0
    fa4c:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)Controller;
}
    fa50:	bf00      	nop
    fa52:	b002      	add	sp, #8
    fa54:	4770      	bx	lr

0000fa56 <CanIf_EnableControllerInterrupts>:
void CanIf_EnableControllerInterrupts(uint8 Controller)
{
    fa56:	b082      	sub	sp, #8
    fa58:	4603      	mov	r3, r0
    fa5a:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)Controller;
}
    fa5e:	bf00      	nop
    fa60:	b002      	add	sp, #8
    fa62:	4770      	bx	lr

0000fa64 <CanIf_GetControllerErrorState>:
Std_ReturnType CanIf_GetControllerErrorState( uint8 ControllerId, Can_ErrorStateType * ErrorStatePtr)
{
    fa64:	b082      	sub	sp, #8
    fa66:	4603      	mov	r3, r0
    fa68:	9100      	str	r1, [sp, #0]
    fa6a:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
    (void)ErrorStatePtr;
}
    fa6e:	bf00      	nop
    fa70:	4618      	mov	r0, r3
    fa72:	b002      	add	sp, #8
    fa74:	4770      	bx	lr

0000fa76 <CanIf_GetControllerMode>:
Std_ReturnType CanIf_GetControllerMode( uint8 Controller, Can_ControllerStateType * ControllerModePtr )
{
    fa76:	b082      	sub	sp, #8
    fa78:	4603      	mov	r3, r0
    fa7a:	9100      	str	r1, [sp, #0]
    fa7c:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)Controller;
    (void)ControllerModePtr;
}
    fa80:	bf00      	nop
    fa82:	4618      	mov	r0, r3
    fa84:	b002      	add	sp, #8
    fa86:	4770      	bx	lr

0000fa88 <CanIf_GetControllerRxErrorCounter>:
Std_ReturnType CanIf_GetControllerRxErrorCounter(uint8 ControllerId, uint8 * RxErrorCounterPtr)
{
    fa88:	b082      	sub	sp, #8
    fa8a:	4603      	mov	r3, r0
    fa8c:	9100      	str	r1, [sp, #0]
    fa8e:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
    (void)RxErrorCounterPtr;
}
    fa92:	bf00      	nop
    fa94:	4618      	mov	r0, r3
    fa96:	b002      	add	sp, #8
    fa98:	4770      	bx	lr

0000fa9a <CanIf_GetControllerTxErrorCounter>:
Std_ReturnType CanIf_GetControllerTxErrorCounter( uint8 ControllerId, uint8 * TxErrorCounterPtr )
{
    fa9a:	b082      	sub	sp, #8
    fa9c:	4603      	mov	r3, r0
    fa9e:	9100      	str	r1, [sp, #0]
    faa0:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
    (void)TxErrorCounterPtr;
}
    faa4:	bf00      	nop
    faa6:	4618      	mov	r0, r3
    faa8:	b002      	add	sp, #8
    faaa:	4770      	bx	lr

0000faac <Fls_ACEraseRomEnd>:
    faac:	204e4143 	.word	0x204e4143
    fab0:	64756162 	.word	0x64756162
    fab4:	74617220 	.word	0x74617220
    fab8:	65732065 	.word	0x65732065
    fabc:	75732074 	.word	0x75732074
    fac0:	73656363 	.word	0x73656363
    fac4:	6c756673 	.word	0x6c756673
    fac8:	202e796c 	.word	0x202e796c
    facc:	0000000a 	.word	0x0000000a
    fad0:	6c696146 	.word	0x6c696146
    fad4:	74206465 	.word	0x74206465
    fad8:	6573206f 	.word	0x6573206f
    fadc:	41432074 	.word	0x41432074
    fae0:	6162204e 	.word	0x6162204e
    fae4:	72206475 	.word	0x72206475
    fae8:	2e657461 	.word	0x2e657461
    faec:	00000a20 	.word	0x00000a20
    faf0:	204e4143 	.word	0x204e4143
    faf4:	746e6f63 	.word	0x746e6f63
    faf8:	6c6c6f72 	.word	0x6c6c6f72
    fafc:	73207265 	.word	0x73207265
    fb00:	65746174 	.word	0x65746174
    fb04:	63616d20 	.word	0x63616d20
    fb08:	656e6968 	.word	0x656e6968
    fb0c:	74657320 	.word	0x74657320
    fb10:	63757320 	.word	0x63757320
    fb14:	73736563 	.word	0x73736563
    fb18:	6c6c7566 	.word	0x6c6c7566
    fb1c:	0a202e79 	.word	0x0a202e79
    fb20:	00000000 	.word	0x00000000
    fb24:	6c696146 	.word	0x6c696146
    fb28:	74206465 	.word	0x74206465
    fb2c:	6573206f 	.word	0x6573206f
    fb30:	41432074 	.word	0x41432074
    fb34:	6f63204e 	.word	0x6f63204e
    fb38:	6f72746e 	.word	0x6f72746e
    fb3c:	72656c6c 	.word	0x72656c6c
    fb40:	61747320 	.word	0x61747320
    fb44:	6d206574 	.word	0x6d206574
    fb48:	69686361 	.word	0x69686361
    fb4c:	202e656e 	.word	0x202e656e
    fb50:	0000000a 	.word	0x0000000a
    fb54:	74747542 	.word	0x74747542
    fb58:	31206e6f 	.word	0x31206e6f
    fb5c:	74636120 	.word	0x74636120
    fb60:	3a6e6f69 	.word	0x3a6e6f69
    fb64:	4e495320 	.word	0x4e495320
    fb68:	5f454c47 	.word	0x5f454c47
    fb6c:	43494c43 	.word	0x43494c43
    fb70:	000a204b 	.word	0x000a204b
    fb74:	74747542 	.word	0x74747542
    fb78:	31206e6f 	.word	0x31206e6f
    fb7c:	74636120 	.word	0x74636120
    fb80:	3a6e6f69 	.word	0x3a6e6f69
    fb84:	554f4420 	.word	0x554f4420
    fb88:	5f454c42 	.word	0x5f454c42
    fb8c:	43494c43 	.word	0x43494c43
    fb90:	000a204b 	.word	0x000a204b
    fb94:	74747542 	.word	0x74747542
    fb98:	31206e6f 	.word	0x31206e6f
    fb9c:	74636120 	.word	0x74636120
    fba0:	3a6e6f69 	.word	0x3a6e6f69
    fba4:	4c4f4820 	.word	0x4c4f4820
    fba8:	4c435f44 	.word	0x4c435f44
    fbac:	204b4349 	.word	0x204b4349
    fbb0:	0000000a 	.word	0x0000000a
    fbb4:	74747542 	.word	0x74747542
    fbb8:	31206e6f 	.word	0x31206e6f
    fbbc:	74636120 	.word	0x74636120
    fbc0:	3a6e6f69 	.word	0x3a6e6f69
    fbc4:	4c455220 	.word	0x4c455220
    fbc8:	45534145 	.word	0x45534145
    fbcc:	00000a20 	.word	0x00000a20
    fbd0:	74747542 	.word	0x74747542
    fbd4:	32206e6f 	.word	0x32206e6f
    fbd8:	74636120 	.word	0x74636120
    fbdc:	3a6e6f69 	.word	0x3a6e6f69
    fbe0:	4e495320 	.word	0x4e495320
    fbe4:	5f454c47 	.word	0x5f454c47
    fbe8:	43494c43 	.word	0x43494c43
    fbec:	000a204b 	.word	0x000a204b
    fbf0:	74747542 	.word	0x74747542
    fbf4:	32206e6f 	.word	0x32206e6f
    fbf8:	74636120 	.word	0x74636120
    fbfc:	3a6e6f69 	.word	0x3a6e6f69
    fc00:	554f4420 	.word	0x554f4420
    fc04:	5f454c42 	.word	0x5f454c42
    fc08:	43494c43 	.word	0x43494c43
    fc0c:	000a204b 	.word	0x000a204b
    fc10:	74747542 	.word	0x74747542
    fc14:	32206e6f 	.word	0x32206e6f
    fc18:	74636120 	.word	0x74636120
    fc1c:	3a6e6f69 	.word	0x3a6e6f69
    fc20:	4c4f4820 	.word	0x4c4f4820
    fc24:	4c435f44 	.word	0x4c435f44
    fc28:	204b4349 	.word	0x204b4349
    fc2c:	0000000a 	.word	0x0000000a
    fc30:	74747542 	.word	0x74747542
    fc34:	32206e6f 	.word	0x32206e6f
    fc38:	74636120 	.word	0x74636120
    fc3c:	3a6e6f69 	.word	0x3a6e6f69
    fc40:	4c455220 	.word	0x4c455220
    fc44:	45534145 	.word	0x45534145
    fc48:	00000a20 	.word	0x00000a20
    fc4c:	74747542 	.word	0x74747542
    fc50:	33206e6f 	.word	0x33206e6f
    fc54:	74636120 	.word	0x74636120
    fc58:	3a6e6f69 	.word	0x3a6e6f69
    fc5c:	4e495320 	.word	0x4e495320
    fc60:	5f454c47 	.word	0x5f454c47
    fc64:	43494c43 	.word	0x43494c43
    fc68:	000a204b 	.word	0x000a204b
    fc6c:	74747542 	.word	0x74747542
    fc70:	33206e6f 	.word	0x33206e6f
    fc74:	74636120 	.word	0x74636120
    fc78:	3a6e6f69 	.word	0x3a6e6f69
    fc7c:	554f4420 	.word	0x554f4420
    fc80:	5f454c42 	.word	0x5f454c42
    fc84:	43494c43 	.word	0x43494c43
    fc88:	000a204b 	.word	0x000a204b
    fc8c:	74747542 	.word	0x74747542
    fc90:	33206e6f 	.word	0x33206e6f
    fc94:	74636120 	.word	0x74636120
    fc98:	3a6e6f69 	.word	0x3a6e6f69
    fc9c:	4c4f4820 	.word	0x4c4f4820
    fca0:	4c435f44 	.word	0x4c435f44
    fca4:	204b4349 	.word	0x204b4349
    fca8:	0000000a 	.word	0x0000000a
    fcac:	74747542 	.word	0x74747542
    fcb0:	33206e6f 	.word	0x33206e6f
    fcb4:	74636120 	.word	0x74636120
    fcb8:	3a6e6f69 	.word	0x3a6e6f69
    fcbc:	4c455220 	.word	0x4c455220
    fcc0:	45534145 	.word	0x45534145
    fcc4:	00000a20 	.word	0x00000a20
    fcc8:	204e4143 	.word	0x204e4143
    fccc:	2067736d 	.word	0x2067736d
    fcd0:	35317830 	.word	0x35317830
    fcd4:	72742034 	.word	0x72742034
    fcd8:	6d736e61 	.word	0x6d736e61
    fcdc:	65747469 	.word	0x65747469
    fce0:	74612064 	.word	0x74612064
    fce4:	30303520 	.word	0x30303520
    fce8:	7370626b 	.word	0x7370626b
    fcec:	69737520 	.word	0x69737520
    fcf0:	4220676e 	.word	0x4220676e
    fcf4:	6f747475 	.word	0x6f747475
    fcf8:	25203a6e 	.word	0x25203a6e
    fcfc:	000a2064 	.word	0x000a2064
    fd00:	204e4143 	.word	0x204e4143
    fd04:	2067736d 	.word	0x2067736d
    fd08:	33327830 	.word	0x33327830
    fd0c:	72742033 	.word	0x72742033
    fd10:	6d736e61 	.word	0x6d736e61
    fd14:	65747469 	.word	0x65747469
    fd18:	74612064 	.word	0x74612064
    fd1c:	30303520 	.word	0x30303520
    fd20:	7370626b 	.word	0x7370626b
    fd24:	69737520 	.word	0x69737520
    fd28:	4220676e 	.word	0x4220676e
    fd2c:	6f747475 	.word	0x6f747475
    fd30:	25203a6e 	.word	0x25203a6e
    fd34:	000a2064 	.word	0x000a2064
    fd38:	204e4143 	.word	0x204e4143
    fd3c:	2067736d 	.word	0x2067736d
    fd40:	38337830 	.word	0x38337830
    fd44:	72742032 	.word	0x72742032
    fd48:	6d736e61 	.word	0x6d736e61
    fd4c:	65747469 	.word	0x65747469
    fd50:	74612064 	.word	0x74612064
    fd54:	30303520 	.word	0x30303520
    fd58:	7370626b 	.word	0x7370626b
    fd5c:	69737520 	.word	0x69737520
    fd60:	4220676e 	.word	0x4220676e
    fd64:	6f747475 	.word	0x6f747475
    fd68:	25203a6e 	.word	0x25203a6e
    fd6c:	000a2064 	.word	0x000a2064
    fd70:	6d726554 	.word	0x6d726554
    fd74:	6c616e69 	.word	0x6c616e69
    fd78:	00000000 	.word	0x00000000
    fd7c:	4c554e28 	.word	0x4c554e28
    fd80:	0000294c 	.word	0x0000294c

0000fd84 <Clock_Ip_au8DividerCallbackIndex>:
    fd84:	0e0d0c00 06030201 0a070409 000b0805     ................

0000fd94 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

0000fda4 <Clock_Ip_au8XoscCallbackIndex>:
    fda4:	00000100 00000000 00000000 00000000     ................

0000fdb4 <Clock_Ip_au8IrcoscCallbackIndex>:
    fdb4:	03020100 00000004 00000000 00000000     ................

0000fdc4 <Clock_Ip_au8GateCallbackIndex>:
    fdc4:	06010200 01040301 00000500 00000000     ................

0000fdd4 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

0000fde4 <Clock_Ip_au8PllCallbackIndex>:
    fde4:	00000100 00000000 00000000 00000000     ................

0000fdf4 <Clock_Ip_au8SelectorCallbackIndex>:
    fdf4:	0a090800 03020109 07060504 00000000     ................

0000fe04 <Clock_Ip_au8PcfsCallbackIndex>:
	...

0000fe14 <Clock_Ip_au8CmuCallbackIndex>:
	...

0000fe24 <Clock_Ip_au8ClockFeatures>:
	...
    fe34:	01000000 00000000 00000000 00000002     ................
    fe44:	00000000 00000300 00000000 00040000     ................
    fe54:	00000000 05000000 00000000 00000000     ................
    fe64:	00000006 00000000 00000100 00000000     ................
    fe74:	00010000 00000000 04000000 00000000     ................
    fe84:	00000000 00000005 00000001 00000401     ................
    fe94:	00000200 00050100 00030000 04020000     ................
    fea4:	04000000 02000000 00000005 00000005     ................
    feb4:	00000403 00000600 00050300 00070000     ................
    fec4:	05000000 00000000 00000000 00000006     ................
	...
    ff04:	00050000 00000000 06000000 00000100     ................
    ff14:	00000000 00030007 00000000 00000000     ................
    ff24:	00000000 00060000 00000000 07000000     ................
    ff34:	00000100 00000000 00030008 00000000     ................
	...
    ff4c:	00090000 00000000 0a000000 00000100     ................
    ff5c:	00000000 0003000b 00000000 00000000     ................
    ff6c:	00000000 000c0000 00000000 0d000000     ................
    ff7c:	00000100 00000000 0003000e 00000000     ................
    ff8c:	00000800 00000000 00090000 00000000     ................
    ff9c:	0a000000 00000000 00000000 0000000b     ................
    ffac:	00000000 00000b01 00000000 000b0200     ................
    ffbc:	00000000 0b030000 00000000 00000000     ................
	...
    ffd4:	00000400 003b003b 00040000 27002700     ....;.;......'.'
    ffe4:	01000000 00000000 00000000 00000007     ................
    fff4:	00007300 00000700 00320000 00090000     .s........2.....
   10004:	02000000 07000000 00000000 00000021     ............!...
   10014:	00000009 00000400 00000900 00030000     ................
   10024:	00070000 61000000 07000000 00000000     .......a........
   10034:	00000024 00000007 00002500 00000700     $........%......
   10044:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
   10054:	00000000 00000020 38000004 00003800     .... ......8.8..
   10064:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
   10074:	04000000 00260000 00000026 66000004     ......&.&......f
   10084:	00006600 00000400 00370037 00040000     .f......7.7.....
   10094:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
   100a4:	2e000004 00002e00 00000200 00404040     ............@@@.
   100b4:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
   100c4:	0000006b 6c000004 00006c00 00000900     k......l.l......
   100d4:	00010000 00090000 00000000 07000000     ................
   100e4:	00000000 00000036 00000007 00003100     ....6........1..
   100f4:	00000700 00490000 00070000 4a000000     ......I........J
   10104:	07000000 00000000 0000004b 00000007     ........K.......
   10114:	00004c00 00000700 004d0000 00070000     .L........M.....
   10124:	3d000000 03000000 00000000 00000000     ...=............

00010134 <Clock_Ip_au16SelectorEntryHardwareValue>:
   10134:	01010a03 01010001 04040002 02000603     ................
   10144:	00010810 02020100 00000000 00000007     ................
   10154:	00000009 00000000 00000c0e 00000000     ................
	...

0001018c <Clock_Ip_au8SelectorEntryScsHardwareValue>:
   1018c:	00020000 00000300 00000601 00000000     ................
	...

000101bc <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
   101bc:	00000700 00000000 02020000 01010303     ................
   101cc:	03020606 00000000 00000000 00000000     ................
	...

000101ec <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
   101ec:	00000001 00000000 02020000 01010303     ................
   101fc:	03020606 00000000 00000000 00000000     ................
	...

0001021c <Clock_Ip_au8DividerValueHardwareValue>:
   1021c:	00020100 00000003 00000004 00000000     ................
   1022c:	00000005 00000000 00000000 00000000     ................
   1023c:	00000006 00000000 00000000 00000000     ................
	...
   1025c:	00000007                                ....

00010260 <Clock_Ip_apxScgPeriphAsyncDivs>:
   10260:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

00010270 <Clock_Ip_aeSourceTypeClockName>:
   10270:	00000000 00000001 00000001 00000001     ................
   10280:	00000001 00000001 00000001 00000001     ................
   10290:	00000002 00000003 00000001 00000001     ................
   102a0:	00000001 00000001 00000002 00000002     ................
   102b0:	00000003 00000003 00000001 00000001     ................
   102c0:	00000004 00000004 00000004 00000004     ................
	...

0001032c <Clock_Ip_aeHwPllName>:
   1032c:	00000009                                ....

00010330 <Clock_Ip_aeHwDfsName>:
   10330:	00000057                                W...

00010334 <Clock_Ip_axDividerCallbacks>:
   10334:	000032c1 000032cb 000032e5 000032ff     .2...2...2...2..
   10344:	00003319 00003333 0000334d 00003367     .3..33..M3..g3..
   10354:	00003381 0000339b 000033b5 000033cf     .3...3...3...3..
   10364:	000033e9 00003403 0000341d              .3...4...4..

00010370 <Clock_Ip_axDividerTriggerCallbacks>:
   10370:	00003791 00003791                       .7...7..

00010378 <Clock_Ip_axExtOscCallbacks>:
   10378:	0000379d 0000379d 0000379d 000037a7     .7...7...7...7..
   10388:	0000379d 000037b1 000037cb 000037e5     .7...7...7...7..
   10398:	00003869 0000387d                       i8..}8..

000103a0 <Clock_Ip_axFracDivCallbacks>:
   103a0:	00003a3d 00003a3d 00003a47              =:..=:..G:..

000103ac <Clock_Ip_axGateCallbacks>:
   103ac:	00003a61 00003a6b 00003b6b 00003b85     a:..k:..k;...;..
   103bc:	00003b1b 00003b35 00003acb 00003ae5     .;..5;...:...:..
   103cc:	00003a7b 00003a95 00003bbb 00003bd5     {:...:...;...;..
   103dc:	00003c0b 00003c25                       .<..%<..

000103e4 <Clock_Ip_axIntOscCallbacks>:
   103e4:	00003dd1 00003dd1 00003ddb 00003de5     .=...=...=...=..
   103f4:	00003dff 00003e19 00003e2d 00003e47     .=...>..->..G>..
   10404:	00003e61 00003e75 00003e8f 00003ea9     a>..u>...>...>..
   10414:	00003f51 00003f6b 00003f85              Q?..k?...?..

00010420 <Clock_Ip_axCmuCallbacks>:
   10420:	00004521 0000452b 00004537 00004521     !E..+E..7E..!E..

00010430 <Clock_Ip_axPllCallbacks>:
   10430:	00004541 00004541 0000454b 00004541     AE..AE..KE..AE..
   10440:	00004557 00004561 0000457b 00004595     WE..aE..{E...E..
   10450:	00004639 00004625                       9F..%F..

00010458 <Clock_Ip_axPcfsCallbacks>:
   10458:	00004795                                .G..

0001045c <Clock_Ip_axSelectorCallbacks>:
   1045c:	000047a1 000047a1 000047ab 000047c5     .G...G...G...G..
   1046c:	000047a1 000047df 000047f9 00004813     .G...G...G...H..
   1047c:	0000482d 00004847 00004861 0000487b     -H..GH..aH..{H..
   1048c:	00004895 000048af 000048c9 000048e3     .H...H...H...H..
   1049c:	000048fd 00004917 00004931 0000494b     .H...I..1I..KI..
   104ac:	00004965 0000497f                       eI...I..

000104b4 <ClockSource>:
   104b4:	00000000 00000008 00000002 00000005     ................
	...
   104cc:	00000009                                ....

000104d0 <ResetReasonArray>:
   104d0:	00000000 00000001 00000002 00000003     ................
   104e0:	00000004 00000005 00000006 00000007     ................
   104f0:	00000008 00000009 0000000a 0000000b     ................
   10500:	0000000c 0000000d 0000000e              ............

0001050c <Port_au32PortCiPortBaseAddr>:
   1050c:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
   1051c:	4004d000                                ...@

00010520 <Port_au32PortCiGpioBaseAddr>:
   10520:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
   10530:	400ff100                                ...@

00010534 <Flexcan_Ip_apxBase>:
   10534:	40024000 40025000 4002b000              .@.@.P.@...@

00010540 <payload_code.3>:
   10540:	03020100 07060504 09090908 0a0a0a09     ................
   10550:	0b0b0b0a 0c0c0c0b 0d0d0d0c 0d0d0d0d     ................
   10560:	0e0e0e0d 0e0e0e0e 0e0e0e0e 0e0e0e0e     ................
   10570:	0f0f0f0e 0f0f0f0f 0f0f0f0f 0f0f0f0f     ................
   10580:	0000000f                                ....

00010584 <flexcanBase.2>:
   10584:	40024000 40025000 4002b000              .@.@.P.@...@

00010590 <maxMbNum.1>:
   10590:	00000020 00000010 00000010               ...........

0001059c <flexcanBase.0>:
   1059c:	40024000                                .@.@

000105a0 <ButtonsCfg>:
   105a0:	0000008c 0000012c 00000071 0000012c     ....,...q...,...
   105b0:	0000000c 0000012c                       ....,...

000105b8 <LedsCfg>:
   105b8:	00000060 0000006f 00000070 00010048     `...o...p...H...
   105c8:	00010049 0001004a 0001004b 0001004c     I...J...K...L...
   105d8:	0001004d 0001004e 0001004f              M...N...O...

000105e4 <Can_43_FLEXCAN_Driver_P2Func>:
   105e4:	000079d1 0000764d                       .y..Mv..

000105ec <Can_43_FLEXCAN_Driver_Config>:
   105ec:	00010000 000105e4                       ........

000105f4 <CanIf_CtrlPCConfig>:
   105f4:	00000000 000105ec                       ........

000105fc <CanIf_PCConfig>:
   105fc:	00000001 000105f4                       ........

00010604 <CanIf_TxPdu>:
   10604:	00000000 00000154 00000002 00000000     ....T...........
   10614:	000008fd 00000001 00000233 00000002     ........3.......
   10624:	00000000 00000925 00000002 00000382     ....%...........
   10634:	00000002 00000000 0000094d              ........M...

00010640 <CanIf_Can_43_FLEXCAN_HohToRxPduMapping>:
   10640:	00000000                                ....

00010644 <CanIf_Can_43_FLEXCAN_DrvConfig>:
   10644:	00010640                                @...

00010648 <CanIf_CanDrvConfig>:
   10648:	00010644                                D...

0001064c <CanIf_Config>:
   1064c:	00000300 00010648 00000000 00010604     ....H...........

0001065c <Can_43_FLEXCANIpwHwChannelConfig0>:
   1065c:	00010b24                                $...

00010660 <Can_au32HwBufferAddr_Ctrl0>:
   10660:	4002b080 4002b090 4002b0a0              ...@...@...@

0001066c <Can_aCtrlOffsetToCtrlIDMap>:
   1066c:	0000ffff                                ....

00010670 <Can_aHwObjIDToCtrlIDMap>:
   10670:	00000000                                ....

00010674 <Can_aHwObjectConfig>:
   10674:	00000000 00000001 00000000 ff030000     ................
   10684:	00000008 00000000 00000003 00000000     ................
   10694:	00010660                                `...

00010698 <Can_aBaudrateConfig_Ctrl0>:
   10698:	04030000 001d0005 00000000 00000000     ................
	...
   106b0:	00050403 0000000b 00000000 00000000     ................
   106c0:	00000000 04030000 00050005 00000000     ................
	...

000106dc <Can_apHwObject_Ctrl0>:
   106dc:	00010674                                t...

000106e0 <Can_aControllerConfig>:
   106e0:	00020000 4002b000 00000001 ffffffff     .......@........
	...
   106fc:	00030001 00010698 0001065c 00000001     ........\.......
   1070c:	000106dc                                ....

00010710 <Can_apController>:
   10710:	000106e0                                ....

00010714 <Can_43_FLEXCAN_Config>:
	...
   1071c:	0001066c 00010670 00010674 00010710     l...p...t.......

0001072c <Mcu_aClockConfigPB>:
	...
   10734:	1c000101 04000010 01000029 00000005     ........).......
   10744:	00000001 00000000 00000057 00000000     ........W.......
   10754:	00000000 00000008 007a1200 00000001     ..........z.....
   10764:	00000001 00000000 00000057 00000000     ........W.......
   10774:	00000057 00000000 00000000 00000000     W...............
	...
   10794:	00000019 00000005 0000001a 00000002     ................
   107a4:	0000001b 00000005 0000002a 00000005     ........*.......
   107b4:	00000028 0000000e 00000029 00000001     (.......).......
   107c4:	00000056 0000001c 00000032 0000002a     V.......2...*...
   107d4:	0000002b 00000014 0000002c 00000014     +.......,.......
   107e4:	0000002d 00000014 0000002e 00000014     -...............
   107f4:	0000003f 00000000 00000040 00000000     ?.......@.......
   10804:	00000041 00000000 00000042 00000000     A.......B.......
   10814:	00000031 00000000 00000045 00000000     1.......E.......
   10824:	00000046 00000000 00000047 00000000     F.......G.......
   10834:	00000044 00000000 00000030 00000000     D.......0.......
   10844:	0000003d 00000000 00000043 00000000     =.......C.......
   10854:	00000049 00000000 0000004a 00000000     I.......J.......
   10864:	0000004b 00000000 00000048 00000000     K.......H.......
   10874:	0000000c 00000001 00000000 0000000d     ................
   10884:	00000002 00000000 0000000e 00000001     ................
   10894:	00000000 0000000f 00000001 00000000     ................
   108a4:	0000001d 00000001 00000000 0000001e     ................
   108b4:	00000008 00000000 0000001f 00000001     ................
   108c4:	00000000 00000021 00000001 00000000     ....!...........
   108d4:	00000022 00000002 00000000 00000023     "...........#...
   108e4:	00000001 00000000 00000025 00000003     ........%.......
   108f4:	00000000 00000026 00000004 00000000     ....&...........
   10904:	00000027 00000002 00000000 00000032     '...........2...
   10914:	00000001 00000000 00000048 00000001     ........H.......
   10924:	00000001 00000056 00000001 00000001     ....V...........
   10934:	00000057 00000000 00000000 00000057     W...........W...
	...
   1094c:	00000057 00000000 00000000 00000057     W...........W...
	...
   10964:	00000057 00000000 00000057 00000057     W.......W...W...
	...
   10980:	00000014 00007d00 00000015 00007d00     .....}.......}..
   10990:	00000016 00007d00 00000017 00008000     .....}..........
   109a0:	00000012 00000001 00000013 00000001     ................
   109b0:	00000030 00000000 00000031 00000000     0.......1.......
   109c0:	00000032 00000000 00000033 00000000     2.......3.......
   109d0:	00000034 00000000 00000035 00000001     4.......5.......
   109e0:	00000036 00000000 00000037 00000001     6.......7.......
   109f0:	00000038 00000001 00000039 00000000     8.......9.......
   10a00:	0000003a 00000000 0000003b 00000000     :.......;.......
   10a10:	0000003c 00000001 0000003d 00000000     <.......=.......
   10a20:	0000003e 00000000 0000003f 00000000     >.......?.......
   10a30:	00000040 00000000 00000041 00000000     @.......A.......
   10a40:	00000042 00000000 00000043 00000000     B.......C.......
   10a50:	00000044 00000000 00000045 00000000     D.......E.......
   10a60:	00000046 00000000 00000047 00000000     F.......G.......
   10a70:	00000048 00000000 00000049 00000000     H.......I.......
   10a80:	0000004a 00000000 0000004b 00000000     J.......K.......
   10a90:	0000004c 00000001 0000004d 00000001     L.......M.......
   10aa0:	0000004e 00000000 0000004f 00000000     N.......O.......
   10ab0:	00000050 00000001 00000051 00000001     P.......Q.......
   10ac0:	00000052 00000001 00000053 00000001     R.......S.......
   10ad0:	00000054 00000001 00000055 00000000     T.......U.......
   10ae0:	00000056 00000001 00000057 00000000     V.......W.......
   10af0:	00000000 00000057 00000000 00000057     ....W.......W...
	...

00010b24 <Flexcan_aCtrlConfigPB>:
   10b24:	00000003 00000000 00000000 00000000     ................
   10b34:	00000040 00000000 00000100 00000003     @...............
   10b44:	00000004 00000005 0000000b 00000000     ................
   10b54:	00000004 00000004 00000005 0000000b     ................
	...
   10b6c:	00008e79 00008f25                       y...%...

00010b74 <aIrqConfiguration>:
   10b74:	0000005c 00000f01 0000d3a5 0000005d     \...........]...
   10b84:	00000f01 0000d3b5 0000005f 00000f01     ........_.......
   10b94:	0000d3c5                                ....

00010b98 <intCtrlConfig>:
   10b98:	00000003 00010b74                       ....t...

00010ba0 <Mcu_Config>:
   10ba0:	0000005a 00000000 00000001 00000001     Z...............
   10bb0:	000110a4 0001072c 000110b0              ....,.......

00010bbc <OsIf_xPredefinedConfig>:
   10bbc:	00000000 02dc6c00                       .....l..

00010bc4 <OsIf_apxPredefinedConfig>:
   10bc4:	00010bbc                                ....

00010bc8 <Platform_uConfiguration>:
   10bc8:	00010bd0                                ....

00010bcc <Platform_Config>:
   10bcc:	00010bc8                                ....

00010bd0 <ipwConfig>:
   10bd0:	00010b98 00000000                       ........

00010bd8 <g_pin_mux_InitConfigArr>:
   10bd8:	4004c000 400ff0c0 00000010 00000002     ...@...@........
   10be8:	00000001 00000002 00000000 00000000     ................
   10bf8:	00000000 00000100 4004c000 400ff0c0     ...........@...@
   10c08:	0000000f 00000002 00000001 00000002     ................
	...
   10c24:	00000100 4004c000 400ff0c0 00000000     .......@...@....
   10c34:	00000002 00000001 00000002 00000000     ................
	...
   10c4c:	00000100 4004c000 400ff0c0 00000011     .......@...@....
   10c5c:	00000002 00000001 00000001 00000000     ................
	...
   10c78:	4004d000 400ff100 0000000c 00000002     ...@...@........
   10c88:	00000001 00000001 00000000 00000000     ................
	...
   10ca0:	40049000 400ff000 0000000c 00000002     ...@...@........
   10cb0:	00000001 00000001 00000000 00000000     ................
	...
   10cc8:	4004b000 400ff080 00000008 00000002     ...@...@........
   10cd8:	00000001 00000002 00000000 00000000     ................
	...
   10cf0:	4004b000 400ff080 00000009 00000002     ...@...@........
   10d00:	00000001 00000002 00000000 00000000     ................
	...
   10d18:	4004b000 400ff080 0000000a 00000002     ...@...@........
   10d28:	00000001 00000002 00000000 00000000     ................
	...
   10d40:	4004b000 400ff080 0000000b 00000002     ...@...@........
   10d50:	00000001 00000002 00000000 00000000     ................
	...
   10d68:	4004b000 400ff080 0000000c 00000002     ...@...@........
   10d78:	00000001 00000002 00000000 00000000     ................
	...
   10d90:	4004b000 400ff080 0000000d 00000002     ...@...@........
   10da0:	00000001 00000002 00000000 00000000     ................
	...
   10db8:	4004b000 400ff080 0000000e 00000002     ...@...@........
   10dc8:	00000001 00000002 00000000 00000000     ................
	...
   10de0:	4004b000 400ff080 0000000f 00000002     ...@...@........
   10df0:	00000001 00000002 00000000 00000000     ................
	...
   10e08:	4004b000 00000000 00000011 00000002     ...@............
   10e18:	00000003 00000001 00000000 00000000     ................
	...
   10e30:	4004b000 00000000 00000010 00000002     ...@............
   10e40:	00000003 00000001 00000000 00000000     ................
	...

00010e58 <au8Port_PartitionList>:
   10e58:	00000001                                ....

00010e5c <au32Port_PinToPartitionMap>:
   10e5c:	00000001 00000001 00000001 00000001     ................
   10e6c:	00000001 00000001 00000001 00000001     ................
   10e7c:	00000001 00000001 00000001 00000001     ................
   10e8c:	00000001 00000001 00000001 00000001     ................

00010e9c <Port_au16NoUnUsedPadsArrayDefault>:
   10e9c:	00010000 00030002 00070006 00090008     ................
   10eac:	000d000b 000f000e 00110010 00210020     ............ .!.
   10ebc:	00230022 00250024 00270026 00290028     ".#.$.%.&.'.(.).
   10ecc:	002b002a 002d002c 002f002e 00310030     *.+.,.-.../.0.1.
   10edc:	00410040 00430042 00470046 00620061     @.A.B.C.F.G.a.b.
   10eec:	00640063 00660065 00680067 006a0069     c.d.e.f.g.h.i.j.
   10efc:	006c006b 006e006d 00810080 00830082     k.l.m.n.........
   10f0c:	00850084 00870086 00890088 008b008a     ................
   10f1c:	008e008d 0090008f                       ........

00010f24 <Port_UnUsedPin>:
   10f24:	00000100 00000001 00000000              ............

00010f30 <Port_aPinConfigDefault>:
   10f30:	00000070 00000100 00000001 00000002     p...............
   10f40:	00010001 00000051 00000300 00000000     ....Q...........
   10f50:	00000001 00010000 00000050 00000300     ........P.......
   10f60:	00000000 00000001 00010000 0000006f     ............o...
   10f70:	00000100 00000001 00000002 00010001     ................
   10f80:	00000060 00000100 00000001 00000002     `...............
   10f90:	00010001 00000071 00000100 00000000     ....q...........
   10fa0:	00000001 00010001 0000008c 00000100     ................
   10fb0:	00000000 00000001 00010001 0000000c     ................
   10fc0:	00000100 00000000 00000001 00010001     ................
   10fd0:	00000048 00000100 00000000 00000002     H...............
   10fe0:	00010001 00000049 00000100 00000000     ....I...........
   10ff0:	00000002 00010001 0000004a 00000100     ........J.......
   11000:	00000000 00000002 00010001 0000004b     ............K...
   11010:	00000100 00000000 00000002 00010001     ................
   11020:	0000004c 00000100 00000000 00000002     L...............
   11030:	00010001 0000004d 00000100 00000000     ....M...........
   11040:	00000002 00010001 0000004e 00000100     ........N.......
   11050:	00000000 00000002 00010001 0000004f     ............O...
   11060:	00000100 00000000 00000002 00010001     ................

00011070 <Port_Config>:
   11070:	00440010 00010e9c 00010f24 00010f30     ..D.....$...0...
	...
   11088:	00010e5c 00010e58 00010bd8              \...X.......

00011094 <Power_Ip_RCM_ConfigPB>:
	...

0001109c <Power_Ip_PMC_ConfigPB>:
   1109c:	00000000                                ....

000110a0 <Power_Ip_SMC_ConfigPB>:
   110a0:	00000000                                ....

000110a4 <Power_Ip_aModeConfigPB>:
	...

000110b0 <Power_Ip_HwIPsConfigPB>:
   110b0:	00011094 0001109c 000110a0              ............

000110bc <_aInitStr.0>:
   110bc:	00000000 54540000 45522052 53454747     ......TTR REGGES
   110cc:	00000000                                ....

000110d0 <_aV2C.0>:
   110d0:	33323130 37363534 42413938 46454443     0123456789ABCDEF

000110e0 <__INIT_TABLE>:
   110e0:	00000002 	.word	0x00000002
   110e4:	1fff8b10 	.word	0x1fff8b10
   110e8:	00011108 	.word	0x00011108
   110ec:	00011138 	.word	0x00011138
   110f0:	1fff8800 	.word	0x1fff8800
   110f4:	00000000 	.word	0x00000000
   110f8:	00000310 	.word	0x00000310

000110fc <__ZERO_TABLE>:
   110fc:	00000001 	.word	0x00000001
   11100:	1fff8b40 	.word	0x1fff8b40
   11104:	1fff96a0 	.word	0x1fff96a0
