
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000c9b 	.word	0x00000c9b
  10:	00000c9d 	.word	0x00000c9d
  14:	00000c9f 	.word	0x00000c9f
  18:	00000ca1 	.word	0x00000ca1
	...
  2c:	00000ca3 	.word	0x00000ca3
  30:	00000ca5 	.word	0x00000ca5
  34:	00000000 	.word	0x00000000
  38:	00000ca7 	.word	0x00000ca7
  3c:	00000ca9 	.word	0x00000ca9
  40:	00000cab 	.word	0x00000cab
  44:	00000cab 	.word	0x00000cab
  48:	00000cab 	.word	0x00000cab
  4c:	00000cab 	.word	0x00000cab
  50:	00000cab 	.word	0x00000cab
  54:	00000cab 	.word	0x00000cab
  58:	00000cab 	.word	0x00000cab
  5c:	00000cab 	.word	0x00000cab
  60:	00000cab 	.word	0x00000cab
  64:	00000cab 	.word	0x00000cab
  68:	00000cab 	.word	0x00000cab
  6c:	00000cab 	.word	0x00000cab
  70:	00000cab 	.word	0x00000cab
  74:	00000cab 	.word	0x00000cab
  78:	00000cab 	.word	0x00000cab
  7c:	00000cab 	.word	0x00000cab
  80:	00000cab 	.word	0x00000cab
  84:	00000cab 	.word	0x00000cab
  88:	00000cab 	.word	0x00000cab
  8c:	00000cab 	.word	0x00000cab
  90:	00000cab 	.word	0x00000cab
  94:	00000cab 	.word	0x00000cab
  98:	00000cab 	.word	0x00000cab
  9c:	00000cab 	.word	0x00000cab
  a0:	00000cab 	.word	0x00000cab
  a4:	00000cab 	.word	0x00000cab
  a8:	00000cab 	.word	0x00000cab
  ac:	00000cab 	.word	0x00000cab
  b0:	00000cab 	.word	0x00000cab
  b4:	00000cab 	.word	0x00000cab
  b8:	00000cab 	.word	0x00000cab
  bc:	00000cab 	.word	0x00000cab
  c0:	00000cab 	.word	0x00000cab
  c4:	00000cab 	.word	0x00000cab
  c8:	00000cab 	.word	0x00000cab
  cc:	00000cab 	.word	0x00000cab
  d0:	00000cab 	.word	0x00000cab
  d4:	00000cab 	.word	0x00000cab
  d8:	00000cab 	.word	0x00000cab
  dc:	00000cab 	.word	0x00000cab
  e0:	00000cab 	.word	0x00000cab
  e4:	00000cab 	.word	0x00000cab
  e8:	00000cab 	.word	0x00000cab
  ec:	00000cab 	.word	0x00000cab
  f0:	00000cab 	.word	0x00000cab
  f4:	00000cab 	.word	0x00000cab
  f8:	00000cab 	.word	0x00000cab
  fc:	00000cab 	.word	0x00000cab
 100:	00000cab 	.word	0x00000cab
 104:	00000cab 	.word	0x00000cab
 108:	00000cab 	.word	0x00000cab
 10c:	00000cab 	.word	0x00000cab
 110:	00000cab 	.word	0x00000cab
 114:	00000cab 	.word	0x00000cab
 118:	00000cab 	.word	0x00000cab
 11c:	00000cab 	.word	0x00000cab
 120:	00000cab 	.word	0x00000cab
 124:	00000cab 	.word	0x00000cab
 128:	00000cab 	.word	0x00000cab
 12c:	00000cab 	.word	0x00000cab
 130:	00000cab 	.word	0x00000cab
 134:	00000cab 	.word	0x00000cab
 138:	00000cab 	.word	0x00000cab
 13c:	00000cab 	.word	0x00000cab
 140:	00000cab 	.word	0x00000cab
 144:	00000cab 	.word	0x00000cab
 148:	00000cab 	.word	0x00000cab
 14c:	00000cab 	.word	0x00000cab
 150:	00000cab 	.word	0x00000cab
 154:	00000cab 	.word	0x00000cab
 158:	00000cab 	.word	0x00000cab
 15c:	00000cab 	.word	0x00000cab
 160:	00000cab 	.word	0x00000cab
 164:	00000cab 	.word	0x00000cab
 168:	00000cab 	.word	0x00000cab
 16c:	00000cab 	.word	0x00000cab
 170:	00000cab 	.word	0x00000cab
 174:	00000cab 	.word	0x00000cab
 178:	00000cab 	.word	0x00000cab
 17c:	00000cab 	.word	0x00000cab
 180:	00000cab 	.word	0x00000cab
 184:	00000cab 	.word	0x00000cab
 188:	00000cab 	.word	0x00000cab
 18c:	00000cab 	.word	0x00000cab
 190:	00000cab 	.word	0x00000cab
 194:	00000cab 	.word	0x00000cab
 198:	00000cab 	.word	0x00000cab
 19c:	00000cab 	.word	0x00000cab
 1a0:	00000cab 	.word	0x00000cab
 1a4:	00000cab 	.word	0x00000cab
 1a8:	00000cab 	.word	0x00000cab
 1ac:	00000cab 	.word	0x00000cab
 1b0:	00000cab 	.word	0x00000cab
 1b4:	00000cab 	.word	0x00000cab
 1b8:	00000cab 	.word	0x00000cab
 1bc:	00000cab 	.word	0x00000cab
 1c0:	00000cab 	.word	0x00000cab
 1c4:	00000cab 	.word	0x00000cab
 1c8:	00000cab 	.word	0x00000cab
 1cc:	00000cab 	.word	0x00000cab
 1d0:	00000cab 	.word	0x00000cab
 1d4:	00000cab 	.word	0x00000cab
 1d8:	00000cab 	.word	0x00000cab
 1dc:	00000cab 	.word	0x00000cab
 1e0:	00000cab 	.word	0x00000cab
 1e4:	00000cab 	.word	0x00000cab
 1e8:	00000cab 	.word	0x00000cab
 1ec:	00000cab 	.word	0x00000cab
 1f0:	00000cab 	.word	0x00000cab
 1f4:	00000cab 	.word	0x00000cab
 1f8:	00000cab 	.word	0x00000cab
 1fc:	00000cab 	.word	0x00000cab
 200:	00000cab 	.word	0x00000cab
 204:	00000cab 	.word	0x00000cab
 208:	00000cab 	.word	0x00000cab
 20c:	00000cab 	.word	0x00000cab
 210:	00000cab 	.word	0x00000cab
 214:	00000cab 	.word	0x00000cab
 218:	00000cab 	.word	0x00000cab
 21c:	00000cab 	.word	0x00000cab
 220:	00000cab 	.word	0x00000cab
 224:	00000cab 	.word	0x00000cab
 228:	00000cab 	.word	0x00000cab
 22c:	00000cab 	.word	0x00000cab
 230:	00000cab 	.word	0x00000cab
 234:	00000cab 	.word	0x00000cab
 238:	00000cab 	.word	0x00000cab
 23c:	00000cab 	.word	0x00000cab
 240:	00000cab 	.word	0x00000cab
 244:	00000cab 	.word	0x00000cab
 248:	00000cab 	.word	0x00000cab
 24c:	00000cab 	.word	0x00000cab
 250:	00000cab 	.word	0x00000cab
 254:	00000cab 	.word	0x00000cab
 258:	00000cab 	.word	0x00000cab
 25c:	00000cab 	.word	0x00000cab
 260:	00000cab 	.word	0x00000cab
 264:	00000cab 	.word	0x00000cab
 268:	00000cab 	.word	0x00000cab
 26c:	00000cab 	.word	0x00000cab
 270:	00000cab 	.word	0x00000cab
 274:	00000cab 	.word	0x00000cab
 278:	00000cab 	.word	0x00000cab
 27c:	00000cab 	.word	0x00000cab
 280:	00000cab 	.word	0x00000cab
 284:	00000cab 	.word	0x00000cab
 288:	00000cab 	.word	0x00000cab
 28c:	00000cab 	.word	0x00000cab
 290:	00000cab 	.word	0x00000cab
 294:	00000cab 	.word	0x00000cab
 298:	00000cab 	.word	0x00000cab
 29c:	00000cab 	.word	0x00000cab
 2a0:	00000cab 	.word	0x00000cab
 2a4:	00000cab 	.word	0x00000cab
 2a8:	00000cab 	.word	0x00000cab
 2ac:	00000cab 	.word	0x00000cab
 2b0:	00000cab 	.word	0x00000cab
 2b4:	00000cab 	.word	0x00000cab
 2b8:	00000cab 	.word	0x00000cab
 2bc:	00000cab 	.word	0x00000cab
 2c0:	00000cab 	.word	0x00000cab
 2c4:	00000cab 	.word	0x00000cab
 2c8:	00000cab 	.word	0x00000cab
 2cc:	00000cab 	.word	0x00000cab
 2d0:	00000cab 	.word	0x00000cab
 2d4:	00000cab 	.word	0x00000cab
 2d8:	00000cab 	.word	0x00000cab
 2dc:	00000cab 	.word	0x00000cab
 2e0:	00000cab 	.word	0x00000cab
 2e4:	00000cab 	.word	0x00000cab
 2e8:	00000cab 	.word	0x00000cab
 2ec:	00000cab 	.word	0x00000cab
 2f0:	00000cab 	.word	0x00000cab
 2f4:	00000cab 	.word	0x00000cab
 2f8:	00000cab 	.word	0x00000cab
 2fc:	00000cab 	.word	0x00000cab
 300:	00000cab 	.word	0x00000cab
 304:	00000cab 	.word	0x00000cab
 308:	00000cab 	.word	0x00000cab
 30c:	00000cab 	.word	0x00000cab

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fb41 	bl	b08 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fc00 	bl	c90 <startup_go_to_user_mode>
     490:	f000 fa34 	bl	8fc <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff8f0c 	.word	0x1fff8f0c

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fb4b 	bl	c34 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <Delay>:
void read_data( uint16 addr, uint8 *data, uint8 size );

/*this is dummy delay function prepare just for this example, in a real application 
no delay shall be used*/
void Delay( uint32 ms )
{
     8b0:	b500      	push	{lr}
     8b2:	b087      	sub	sp, #28
     8b4:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
     8b6:	9b01      	ldr	r3, [sp, #4]
     8b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8bc:	fb02 f303 	mul.w	r3, r2, r3
     8c0:	2101      	movs	r1, #1
     8c2:	4618      	mov	r0, r3
     8c4:	f001 f9f2 	bl	1cac <OsIf_MicrosToTicks>
     8c8:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
     8ca:	2001      	movs	r0, #1
     8cc:	f001 f9a2 	bl	1c14 <OsIf_GetCounter>
     8d0:	4603      	mov	r3, r0
     8d2:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
     8d4:	2300      	movs	r3, #0
     8d6:	9305      	str	r3, [sp, #20]
    do
    {
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     8d8:	ab03      	add	r3, sp, #12
     8da:	2101      	movs	r1, #1
     8dc:	4618      	mov	r0, r3
     8de:	f001 f9b2 	bl	1c46 <OsIf_GetElapsed>
     8e2:	4602      	mov	r2, r0
     8e4:	9b05      	ldr	r3, [sp, #20]
     8e6:	4413      	add	r3, r2
     8e8:	9305      	str	r3, [sp, #20]
    }while( ElapsedTime < Timeout );
     8ea:	9a05      	ldr	r2, [sp, #20]
     8ec:	9b04      	ldr	r3, [sp, #16]
     8ee:	429a      	cmp	r2, r3
     8f0:	d3f2      	bcc.n	8d8 <__BSS_SRAM_SIZE+0x18>
}
     8f2:	bf00      	nop
     8f4:	bf00      	nop
     8f6:	b007      	add	sp, #28
     8f8:	f85d fb04 	ldr.w	pc, [sp], #4

000008fc <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     8fc:	b500      	push	{lr}
     8fe:	b085      	sub	sp, #20
    Spi_DataBufferType TxBuffer[4] = { 0x00, 0x01, 0x02, 0x03 };
     900:	4b24      	ldr	r3, [pc, #144]	; (994 <main+0x98>)
     902:	9301      	str	r3, [sp, #4]
    Spi_DataBufferType RxBuffer[4];
    uint16 Address = 0x0009;
     904:	2309      	movs	r3, #9
     906:	f8ad 300c 	strh.w	r3, [sp, #12]
    uint16 sizeTX = sizeof(TxBuffer);
     90a:	2304      	movs	r3, #4
     90c:	f8ad 300a 	strh.w	r3, [sp, #10]
    uint16 sizeRX = sizeof(RxBuffer);
     910:	2304      	movs	r3, #4
     912:	f8ad 3008 	strh.w	r3, [sp, #8]

    EcuM_Init();
     916:	f000 f841 	bl	99c <EcuM_Init>
    SEGGER_RTT_Init();
     91a:	f000 fb59 	bl	fd0 <SEGGER_RTT_Init>

    write_data( Address, TxBuffer, sizeTX );
     91e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
     922:	b2da      	uxtb	r2, r3
     924:	a901      	add	r1, sp, #4
     926:	f8bd 300c 	ldrh.w	r3, [sp, #12]
     92a:	4618      	mov	r0, r3
     92c:	f000 f854 	bl	9d8 <write_data>

    /*Wait for the data to be recorded in memory, it is not the best way to
    do it, so it's just for demonstration purposes*/
    Delay( 5 );
     930:	2005      	movs	r0, #5
     932:	f7ff ffbd 	bl	8b0 <Delay>

    read_data( Address, RxBuffer, sizeRX );
     936:	f8bd 3008 	ldrh.w	r3, [sp, #8]
     93a:	b2da      	uxtb	r2, r3
     93c:	4669      	mov	r1, sp
     93e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
     942:	4618      	mov	r0, r3
     944:	f000 f87c 	bl	a40 <read_data>

    for(uint8 i = 0; i < sizeRX ; i++)
     948:	2300      	movs	r3, #0
     94a:	f88d 300f 	strb.w	r3, [sp, #15]
     94e:	e015      	b.n	97c <main+0x80>
    {
        SEGGER_RTT_printf(0, "Data from eeprom 1: 0x%x, Address: 0x%x\n", RxBuffer[i], Address+i );
     950:	f89d 300f 	ldrb.w	r3, [sp, #15]
     954:	aa04      	add	r2, sp, #16
     956:	4413      	add	r3, r2
     958:	f813 3c10 	ldrb.w	r3, [r3, #-16]
     95c:	4619      	mov	r1, r3
     95e:	f8bd 200c 	ldrh.w	r2, [sp, #12]
     962:	f89d 300f 	ldrb.w	r3, [sp, #15]
     966:	4413      	add	r3, r2
     968:	460a      	mov	r2, r1
     96a:	490b      	ldr	r1, [pc, #44]	; (998 <main+0x9c>)
     96c:	2000      	movs	r0, #0
     96e:	f000 fe97 	bl	16a0 <SEGGER_RTT_printf>
    for(uint8 i = 0; i < sizeRX ; i++)
     972:	f89d 300f 	ldrb.w	r3, [sp, #15]
     976:	3301      	adds	r3, #1
     978:	f88d 300f 	strb.w	r3, [sp, #15]
     97c:	f89d 300f 	ldrb.w	r3, [sp, #15]
     980:	b29b      	uxth	r3, r3
     982:	f8bd 2008 	ldrh.w	r2, [sp, #8]
     986:	429a      	cmp	r2, r3
     988:	d8e2      	bhi.n	950 <main+0x54>
    }

    while( 1u )
    {
        Delay( 10u );
     98a:	200a      	movs	r0, #10
     98c:	f7ff ff90 	bl	8b0 <Delay>
     990:	e7fb      	b.n	98a <main+0x8e>
     992:	bf00      	nop
     994:	03020100 	.word	0x03020100
     998:	0000a5f0 	.word	0x0000a5f0

0000099c <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     99c:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );
     99e:	480b      	ldr	r0, [pc, #44]	; (9cc <EcuM_Init+0x30>)
     9a0:	f004 fec4 	bl	572c <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     9a4:	2000      	movs	r0, #0
     9a6:	f004 ff15 	bl	57d4 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     9aa:	2000      	movs	r0, #0
     9ac:	f004 ff36 	bl	581c <Mcu_SetMode>

    /*Init the internal tick reference Systick Timer*/
    OsIf_Init( NULL_PTR );
     9b0:	2000      	movs	r0, #0
     9b2:	f001 f926 	bl	1c02 <OsIf_Init>
    /*enable and setup interrupts*/
    Platform_Init( NULL_PTR );
     9b6:	2000      	movs	r0, #0
     9b8:	f001 f820 	bl	19fc <Platform_Init>

    /*Apply all the Pin Port microcontroller configuration, for this case
    only Port Pin 122  (D16) is configured as output*/
    Port_Init( &Port_Config );
     9bc:	4804      	ldr	r0, [pc, #16]	; (9d0 <EcuM_Init+0x34>)
     9be:	f005 fab7 	bl	5f30 <Port_Init>

    /*init the FlexCAN0 with the paramters set in Tresos in loop back mode*/
    Spi_Init( &Spi_Config );
     9c2:	4804      	ldr	r0, [pc, #16]	; (9d4 <EcuM_Init+0x38>)
     9c4:	f007 f9f4 	bl	7db0 <Spi_Init>
}
     9c8:	bf00      	nop
     9ca:	bd08      	pop	{r3, pc}
     9cc:	0000b288 	.word	0x0000b288
     9d0:	0000b4b0 	.word	0x0000b4b0
     9d4:	0000b64c 	.word	0x0000b64c

000009d8 <write_data>:
    SEGGER_RTT_printf(0, "[Debug] Data read from eeprom 1 - RxBuffer[0]: 0x%x\n", buffer[0] );
    return buffer[0];
}

void write_data( uint16 addr, uint8 *data, uint8 size )
{
     9d8:	b500      	push	{lr}
     9da:	b085      	sub	sp, #20
     9dc:	4603      	mov	r3, r0
     9de:	9100      	str	r1, [sp, #0]
     9e0:	f8ad 3006 	strh.w	r3, [sp, #6]
     9e4:	4613      	mov	r3, r2
     9e6:	f88d 3005 	strb.w	r3, [sp, #5]
    uint8 Wren, Cmd;

    /*Enable writing instructions in the eeprom memory by sending a 0x06
    and send it in the first Job*/
    Wren = 0x06;                //WREN: 0000 0110 - Set the write enable latch (enable write operations)
     9ea:	2306      	movs	r3, #6
     9ec:	f88d 300f 	strb.w	r3, [sp, #15]
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Wren, &Wren, NULL, 1 );
     9f0:	f10d 010f 	add.w	r1, sp, #15
     9f4:	2301      	movs	r3, #1
     9f6:	2200      	movs	r2, #0
     9f8:	2000      	movs	r0, #0
     9fa:	f007 fa8b 	bl	7f14 <Spi_SetupEB>

    /*Set up the buffer for the Write command + Memory Address and four bytes of data
    in the second job*/
    Cmd = 0x02;                 //WRITE: 0000 0010 - Write data to memory array beginning at selected address
     9fe:	2302      	movs	r3, #2
     a00:	f88d 300e 	strb.w	r3, [sp, #14]
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Cmd, &Cmd, NULL, 1 );
     a04:	f10d 010e 	add.w	r1, sp, #14
     a08:	2301      	movs	r3, #1
     a0a:	2200      	movs	r2, #0
     a0c:	2001      	movs	r0, #1
     a0e:	f007 fa81 	bl	7f14 <Spi_SetupEB>
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Addr, (Spi_DataBufferType*)&addr, NULL, 1 );
     a12:	f10d 0106 	add.w	r1, sp, #6
     a16:	2301      	movs	r3, #1
     a18:	2200      	movs	r2, #0
     a1a:	2002      	movs	r0, #2
     a1c:	f007 fa7a 	bl	7f14 <Spi_SetupEB>
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Data, data, NULL, size );
     a20:	f89d 3005 	ldrb.w	r3, [sp, #5]
     a24:	b29b      	uxth	r3, r3
     a26:	2200      	movs	r2, #0
     a28:	9900      	ldr	r1, [sp, #0]
     a2a:	2003      	movs	r0, #3
     a2c:	f007 fa72 	bl	7f14 <Spi_SetupEB>
    /*Send the data to the eeprom memory, two jobs*/
    Spi_SyncTransmit( SpiConf_SpiSequence_SpiSequence_Write );
     a30:	2000      	movs	r0, #0
     a32:	f007 fb47 	bl	80c4 <Spi_SyncTransmit>
}
     a36:	bf00      	nop
     a38:	b005      	add	sp, #20
     a3a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000a40 <read_data>:
void read_data( uint16 addr, uint8 *data, uint8 size )
{
     a40:	b500      	push	{lr}
     a42:	b085      	sub	sp, #20
     a44:	4603      	mov	r3, r0
     a46:	9100      	str	r1, [sp, #0]
     a48:	f8ad 3006 	strh.w	r3, [sp, #6]
     a4c:	4613      	mov	r3, r2
     a4e:	f88d 3005 	strb.w	r3, [sp, #5]
    uint8 Cmd;

    /*Set up the buffer with the read command + address to read and the buffer to store
    the read data in one job*/
    Cmd = 0x03;                 //READ: 0000 0011 - Read data from memory array beginning at selected address
     a52:	2303      	movs	r3, #3
     a54:	f88d 300e 	strb.w	r3, [sp, #14]
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Cmd, &Cmd, NULL, 1 );
     a58:	f10d 010e 	add.w	r1, sp, #14
     a5c:	2301      	movs	r3, #1
     a5e:	2200      	movs	r2, #0
     a60:	2001      	movs	r0, #1
     a62:	f007 fa57 	bl	7f14 <Spi_SetupEB>
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Addr, (Spi_DataBufferType*)&addr, NULL, 1 );
     a66:	f10d 0106 	add.w	r1, sp, #6
     a6a:	2301      	movs	r3, #1
     a6c:	2200      	movs	r2, #0
     a6e:	2002      	movs	r0, #2
     a70:	f007 fa50 	bl	7f14 <Spi_SetupEB>
    Spi_SetupEB( SpiConf_SpiChannel_SpiChannel_Data, NULL, data, size );
     a74:	f89d 3005 	ldrb.w	r3, [sp, #5]
     a78:	b29b      	uxth	r3, r3
     a7a:	9a00      	ldr	r2, [sp, #0]
     a7c:	2100      	movs	r1, #0
     a7e:	2003      	movs	r0, #3
     a80:	f007 fa48 	bl	7f14 <Spi_SetupEB>
    Spi_SyncTransmit( SpiConf_SpiSequence_SpiSequence_Read );
     a84:	2001      	movs	r0, #1
     a86:	f007 fb1d 	bl	80c4 <Spi_SyncTransmit>
    for(uint8 i = 0; i < size ; i++)
     a8a:	2300      	movs	r3, #0
     a8c:	f88d 300f 	strb.w	r3, [sp, #15]
     a90:	e010      	b.n	ab4 <read_data+0x74>
    {
        SEGGER_RTT_printf(0, "[Debug] Data read from eeprom 1 - RxBuffer[%d]: 0x%x\n", i, data[i] );
     a92:	f89d 100f 	ldrb.w	r1, [sp, #15]
     a96:	f89d 300f 	ldrb.w	r3, [sp, #15]
     a9a:	9a00      	ldr	r2, [sp, #0]
     a9c:	4413      	add	r3, r2
     a9e:	781b      	ldrb	r3, [r3, #0]
     aa0:	460a      	mov	r2, r1
     aa2:	490a      	ldr	r1, [pc, #40]	; (acc <read_data+0x8c>)
     aa4:	2000      	movs	r0, #0
     aa6:	f000 fdfb 	bl	16a0 <SEGGER_RTT_printf>
    for(uint8 i = 0; i < size ; i++)
     aaa:	f89d 300f 	ldrb.w	r3, [sp, #15]
     aae:	3301      	adds	r3, #1
     ab0:	f88d 300f 	strb.w	r3, [sp, #15]
     ab4:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ab8:	f89d 3005 	ldrb.w	r3, [sp, #5]
     abc:	429a      	cmp	r2, r3
     abe:	d3e8      	bcc.n	a92 <read_data+0x52>

    }
}
     ac0:	bf00      	nop
     ac2:	bf00      	nop
     ac4:	b005      	add	sp, #20
     ac6:	f85d fb04 	ldr.w	pc, [sp], #4
     aca:	bf00      	nop
     acc:	0000a654 	.word	0x0000a654

00000ad0 <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     ad0:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     ad2:	f3ef 8310 	mrs	r3, PRIMASK
     ad6:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     ad8:	4623      	mov	r3, r4
}
     ada:	4618      	mov	r0, r3
     adc:	f85d 4b04 	ldr.w	r4, [sp], #4
     ae0:	4770      	bx	lr

00000ae2 <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     ae2:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     ae4:	f3ef 8310 	mrs	r3, PRIMASK
     ae8:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     aea:	4623      	mov	r3, r4
}
     aec:	4618      	mov	r0, r3
     aee:	f85d 4b04 	ldr.w	r4, [sp], #4
     af2:	4770      	bx	lr

00000af4 <Spi_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Spi_schm_read_msr(void)
{
     af4:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     af6:	f3ef 8310 	mrs	r3, PRIMASK
     afa:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     afc:	4623      	mov	r3, r4
}
     afe:	4618      	mov	r0, r3
     b00:	f85d 4b04 	ldr.w	r4, [sp], #4
     b04:	4770      	bx	lr
	...

00000b08 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     b08:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     b0a:	2300      	movs	r3, #0
     b0c:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     b0e:	2300      	movs	r3, #0
     b10:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     b12:	2300      	movs	r3, #0
     b14:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     b16:	2300      	movs	r3, #0
     b18:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     b1a:	4b44      	ldr	r3, [pc, #272]	; (c2c <init_data_bss+0x124>)
     b1c:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     b1e:	4b44      	ldr	r3, [pc, #272]	; (c30 <init_data_bss+0x128>)
     b20:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     b22:	9b05      	ldr	r3, [sp, #20]
     b24:	681b      	ldr	r3, [r3, #0]
     b26:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     b28:	9b05      	ldr	r3, [sp, #20]
     b2a:	3304      	adds	r3, #4
     b2c:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     b2e:	9b05      	ldr	r3, [sp, #20]
     b30:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     b32:	2300      	movs	r3, #0
     b34:	9309      	str	r3, [sp, #36]	; 0x24
     b36:	e03d      	b.n	bb4 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     b38:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b3a:	4613      	mov	r3, r2
     b3c:	005b      	lsls	r3, r3, #1
     b3e:	4413      	add	r3, r2
     b40:	009b      	lsls	r3, r3, #2
     b42:	461a      	mov	r2, r3
     b44:	9b03      	ldr	r3, [sp, #12]
     b46:	4413      	add	r3, r2
     b48:	685b      	ldr	r3, [r3, #4]
     b4a:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     b4c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b4e:	4613      	mov	r3, r2
     b50:	005b      	lsls	r3, r3, #1
     b52:	4413      	add	r3, r2
     b54:	009b      	lsls	r3, r3, #2
     b56:	461a      	mov	r2, r3
     b58:	9b03      	ldr	r3, [sp, #12]
     b5a:	4413      	add	r3, r2
     b5c:	681b      	ldr	r3, [r3, #0]
     b5e:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     b60:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b62:	4613      	mov	r3, r2
     b64:	005b      	lsls	r3, r3, #1
     b66:	4413      	add	r3, r2
     b68:	009b      	lsls	r3, r3, #2
     b6a:	461a      	mov	r2, r3
     b6c:	9b03      	ldr	r3, [sp, #12]
     b6e:	4413      	add	r3, r2
     b70:	689b      	ldr	r3, [r3, #8]
     b72:	4619      	mov	r1, r3
     b74:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b76:	4613      	mov	r3, r2
     b78:	005b      	lsls	r3, r3, #1
     b7a:	4413      	add	r3, r2
     b7c:	009b      	lsls	r3, r3, #2
     b7e:	461a      	mov	r2, r3
     b80:	9b03      	ldr	r3, [sp, #12]
     b82:	4413      	add	r3, r2
     b84:	685b      	ldr	r3, [r3, #4]
     b86:	1acb      	subs	r3, r1, r3
     b88:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     b8a:	2300      	movs	r3, #0
     b8c:	9308      	str	r3, [sp, #32]
     b8e:	e00a      	b.n	ba6 <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     b90:	9a00      	ldr	r2, [sp, #0]
     b92:	9b08      	ldr	r3, [sp, #32]
     b94:	441a      	add	r2, r3
     b96:	9901      	ldr	r1, [sp, #4]
     b98:	9b08      	ldr	r3, [sp, #32]
     b9a:	440b      	add	r3, r1
     b9c:	7812      	ldrb	r2, [r2, #0]
     b9e:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     ba0:	9b08      	ldr	r3, [sp, #32]
     ba2:	3301      	adds	r3, #1
     ba4:	9308      	str	r3, [sp, #32]
     ba6:	9a08      	ldr	r2, [sp, #32]
     ba8:	9b06      	ldr	r3, [sp, #24]
     baa:	429a      	cmp	r2, r3
     bac:	d3f0      	bcc.n	b90 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     bae:	9b09      	ldr	r3, [sp, #36]	; 0x24
     bb0:	3301      	adds	r3, #1
     bb2:	9309      	str	r3, [sp, #36]	; 0x24
     bb4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     bb6:	9b07      	ldr	r3, [sp, #28]
     bb8:	429a      	cmp	r2, r3
     bba:	d3bd      	bcc.n	b38 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     bbc:	9b04      	ldr	r3, [sp, #16]
     bbe:	681b      	ldr	r3, [r3, #0]
     bc0:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     bc2:	9b04      	ldr	r3, [sp, #16]
     bc4:	3304      	adds	r3, #4
     bc6:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     bc8:	9b04      	ldr	r3, [sp, #16]
     bca:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     bcc:	2300      	movs	r3, #0
     bce:	9309      	str	r3, [sp, #36]	; 0x24
     bd0:	e024      	b.n	c1c <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     bd2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     bd4:	00db      	lsls	r3, r3, #3
     bd6:	9a02      	ldr	r2, [sp, #8]
     bd8:	4413      	add	r3, r2
     bda:	681b      	ldr	r3, [r3, #0]
     bdc:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     bde:	9b09      	ldr	r3, [sp, #36]	; 0x24
     be0:	00db      	lsls	r3, r3, #3
     be2:	9a02      	ldr	r2, [sp, #8]
     be4:	4413      	add	r3, r2
     be6:	685b      	ldr	r3, [r3, #4]
     be8:	4619      	mov	r1, r3
     bea:	9b09      	ldr	r3, [sp, #36]	; 0x24
     bec:	00db      	lsls	r3, r3, #3
     bee:	9a02      	ldr	r2, [sp, #8]
     bf0:	4413      	add	r3, r2
     bf2:	681b      	ldr	r3, [r3, #0]
     bf4:	1acb      	subs	r3, r1, r3
     bf6:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     bf8:	2300      	movs	r3, #0
     bfa:	9308      	str	r3, [sp, #32]
     bfc:	e007      	b.n	c0e <init_data_bss+0x106>
        {
            ram[j] = 0U;
     bfe:	9a01      	ldr	r2, [sp, #4]
     c00:	9b08      	ldr	r3, [sp, #32]
     c02:	4413      	add	r3, r2
     c04:	2200      	movs	r2, #0
     c06:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     c08:	9b08      	ldr	r3, [sp, #32]
     c0a:	3301      	adds	r3, #1
     c0c:	9308      	str	r3, [sp, #32]
     c0e:	9a08      	ldr	r2, [sp, #32]
     c10:	9b06      	ldr	r3, [sp, #24]
     c12:	429a      	cmp	r2, r3
     c14:	d3f3      	bcc.n	bfe <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     c16:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c18:	3301      	adds	r3, #1
     c1a:	9309      	str	r3, [sp, #36]	; 0x24
     c1c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     c1e:	9b07      	ldr	r3, [sp, #28]
     c20:	429a      	cmp	r2, r3
     c22:	d3d6      	bcc.n	bd2 <init_data_bss+0xca>
        }
    }
}
     c24:	bf00      	nop
     c26:	bf00      	nop
     c28:	b00a      	add	sp, #40	; 0x28
     c2a:	4770      	bx	lr
     c2c:	0000b690 	.word	0x0000b690
     c30:	0000b6ac 	.word	0x0000b6ac

00000c34 <sys_m4_cache_init>:
{
     c34:	b084      	sub	sp, #16
     c36:	4603      	mov	r3, r0
     c38:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     c3c:	2300      	movs	r3, #0
     c3e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     c42:	f89d 3007 	ldrb.w	r3, [sp, #7]
     c46:	2b00      	cmp	r3, #0
     c48:	d118      	bne.n	c7c <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     c4a:	4b10      	ldr	r3, [pc, #64]	; (c8c <sys_m4_cache_init+0x58>)
     c4c:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     c50:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     c52:	4b0e      	ldr	r3, [pc, #56]	; (c8c <sys_m4_cache_init+0x58>)
     c54:	681b      	ldr	r3, [r3, #0]
     c56:	4a0d      	ldr	r2, [pc, #52]	; (c8c <sys_m4_cache_init+0x58>)
     c58:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     c5c:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     c5e:	bf00      	nop
     c60:	4b0a      	ldr	r3, [pc, #40]	; (c8c <sys_m4_cache_init+0x58>)
     c62:	681b      	ldr	r3, [r3, #0]
     c64:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     c68:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     c6c:	d0f8      	beq.n	c60 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     c6e:	4b07      	ldr	r3, [pc, #28]	; (c8c <sys_m4_cache_init+0x58>)
     c70:	681b      	ldr	r3, [r3, #0]
     c72:	4a06      	ldr	r2, [pc, #24]	; (c8c <sys_m4_cache_init+0x58>)
     c74:	f043 0301 	orr.w	r3, r3, #1
     c78:	6013      	str	r3, [r2, #0]
     c7a:	e002      	b.n	c82 <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     c7c:	2301      	movs	r3, #1
     c7e:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     c82:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     c86:	4618      	mov	r0, r3
     c88:	b004      	add	sp, #16
     c8a:	4770      	bx	lr
     c8c:	e0082000 	.word	0xe0082000

00000c90 <startup_go_to_user_mode>:
}
     c90:	bf00      	nop
     c92:	4770      	bx	lr

00000c94 <Sys_GetCoreID>:
    return 0U;
     c94:	2300      	movs	r3, #0
}
     c96:	4618      	mov	r0, r3
     c98:	4770      	bx	lr

00000c9a <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     c9a:	e7fe      	b.n	c9a <HardFault_Handler>

00000c9c <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     c9c:	e7fe      	b.n	c9c <MemManage_Handler>

00000c9e <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     c9e:	e7fe      	b.n	c9e <BusFault_Handler>

00000ca0 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     ca0:	e7fe      	b.n	ca0 <UsageFault_Handler>

00000ca2 <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     ca2:	e7fe      	b.n	ca2 <SVC_Handler>

00000ca4 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     ca4:	e7fe      	b.n	ca4 <DebugMon_Handler>

00000ca6 <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     ca6:	e7fe      	b.n	ca6 <PendSV_Handler>

00000ca8 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     ca8:	e7fe      	b.n	ca8 <SysTick_Handler>

00000caa <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     caa:	e7fe      	b.n	caa <undefined_handler>

00000cac <_DoInit>:
      if (pRTTCBInit->acID[0] != 'S') {                                                      \
        _DoInit();                                                                           \
      }                                                                                      \
    } while (0)

static void _DoInit(void) {
     cac:	b500      	push	{lr}
     cae:	b083      	sub	sp, #12
  static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
     cb0:	4b26      	ldr	r3, [pc, #152]	; (d4c <_DoInit+0xa0>)
     cb2:	9300      	str	r3, [sp, #0]
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     cb4:	22a8      	movs	r2, #168	; 0xa8
     cb6:	2100      	movs	r1, #0
     cb8:	9800      	ldr	r0, [sp, #0]
     cba:	f000 fd13 	bl	16e4 <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
     cbe:	9b00      	ldr	r3, [sp, #0]
     cc0:	2203      	movs	r2, #3
     cc2:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
     cc4:	9b00      	ldr	r3, [sp, #0]
     cc6:	2203      	movs	r2, #3
     cc8:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
     cca:	9b00      	ldr	r3, [sp, #0]
     ccc:	4a20      	ldr	r2, [pc, #128]	; (d50 <_DoInit+0xa4>)
     cce:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
     cd0:	9b00      	ldr	r3, [sp, #0]
     cd2:	4a20      	ldr	r2, [pc, #128]	; (d54 <_DoInit+0xa8>)
     cd4:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
     cd6:	9b00      	ldr	r3, [sp, #0]
     cd8:	f44f 6280 	mov.w	r2, #1024	; 0x400
     cdc:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
     cde:	9b00      	ldr	r3, [sp, #0]
     ce0:	2200      	movs	r2, #0
     ce2:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
     ce4:	9b00      	ldr	r3, [sp, #0]
     ce6:	2200      	movs	r2, #0
     ce8:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     cea:	9b00      	ldr	r3, [sp, #0]
     cec:	2200      	movs	r2, #0
     cee:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
     cf0:	9b00      	ldr	r3, [sp, #0]
     cf2:	4a17      	ldr	r2, [pc, #92]	; (d50 <_DoInit+0xa4>)
     cf4:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
     cf6:	9b00      	ldr	r3, [sp, #0]
     cf8:	4a17      	ldr	r2, [pc, #92]	; (d58 <_DoInit+0xac>)
     cfa:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
     cfc:	9b00      	ldr	r3, [sp, #0]
     cfe:	2210      	movs	r2, #16
     d00:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
     d02:	9b00      	ldr	r3, [sp, #0]
     d04:	2200      	movs	r2, #0
     d06:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
     d08:	9b00      	ldr	r3, [sp, #0]
     d0a:	2200      	movs	r2, #0
     d0c:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     d0e:	9b00      	ldr	r3, [sp, #0]
     d10:	2200      	movs	r2, #0
     d12:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     d14:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     d18:	2300      	movs	r3, #0
     d1a:	9301      	str	r3, [sp, #4]
     d1c:	e00c      	b.n	d38 <_DoInit+0x8c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
     d1e:	9b01      	ldr	r3, [sp, #4]
     d20:	f1c3 030f 	rsb	r3, r3, #15
     d24:	4a0d      	ldr	r2, [pc, #52]	; (d5c <_DoInit+0xb0>)
     d26:	5cd1      	ldrb	r1, [r2, r3]
     d28:	9a00      	ldr	r2, [sp, #0]
     d2a:	9b01      	ldr	r3, [sp, #4]
     d2c:	4413      	add	r3, r2
     d2e:	460a      	mov	r2, r1
     d30:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     d32:	9b01      	ldr	r3, [sp, #4]
     d34:	3301      	adds	r3, #1
     d36:	9301      	str	r3, [sp, #4]
     d38:	9b01      	ldr	r3, [sp, #4]
     d3a:	2b0f      	cmp	r3, #15
     d3c:	d9ef      	bls.n	d1e <_DoInit+0x72>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     d3e:	f3bf 8f5f 	dmb	sy
}
     d42:	bf00      	nop
     d44:	b003      	add	sp, #12
     d46:	f85d fb04 	ldr.w	pc, [sp], #4
     d4a:	bf00      	nop
     d4c:	1fff8f40 	.word	0x1fff8f40
     d50:	0000a68c 	.word	0x0000a68c
     d54:	1fff8fe8 	.word	0x1fff8fe8
     d58:	1fff93e8 	.word	0x1fff93e8
     d5c:	0000b66c 	.word	0x0000b66c

00000d60 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     d60:	b500      	push	{lr}
     d62:	b08b      	sub	sp, #44	; 0x2c
     d64:	9003      	str	r0, [sp, #12]
     d66:	9102      	str	r1, [sp, #8]
     d68:	9201      	str	r2, [sp, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
     d6a:	2300      	movs	r3, #0
     d6c:	9308      	str	r3, [sp, #32]
  WrOff = pRing->WrOff;
     d6e:	9b03      	ldr	r3, [sp, #12]
     d70:	68db      	ldr	r3, [r3, #12]
     d72:	9307      	str	r3, [sp, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
     d74:	9b03      	ldr	r3, [sp, #12]
     d76:	691b      	ldr	r3, [r3, #16]
     d78:	9306      	str	r3, [sp, #24]
    if (RdOff > WrOff) {
     d7a:	9a06      	ldr	r2, [sp, #24]
     d7c:	9b07      	ldr	r3, [sp, #28]
     d7e:	429a      	cmp	r2, r3
     d80:	d905      	bls.n	d8e <_WriteBlocking+0x2e>
      NumBytesToWrite = RdOff - WrOff - 1u;
     d82:	9a06      	ldr	r2, [sp, #24]
     d84:	9b07      	ldr	r3, [sp, #28]
     d86:	1ad3      	subs	r3, r2, r3
     d88:	3b01      	subs	r3, #1
     d8a:	9309      	str	r3, [sp, #36]	; 0x24
     d8c:	e007      	b.n	d9e <_WriteBlocking+0x3e>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     d8e:	9b03      	ldr	r3, [sp, #12]
     d90:	689a      	ldr	r2, [r3, #8]
     d92:	9906      	ldr	r1, [sp, #24]
     d94:	9b07      	ldr	r3, [sp, #28]
     d96:	1acb      	subs	r3, r1, r3
     d98:	4413      	add	r3, r2
     d9a:	3b01      	subs	r3, #1
     d9c:	9309      	str	r3, [sp, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
     d9e:	9b03      	ldr	r3, [sp, #12]
     da0:	689a      	ldr	r2, [r3, #8]
     da2:	9b07      	ldr	r3, [sp, #28]
     da4:	1ad3      	subs	r3, r2, r3
     da6:	9a09      	ldr	r2, [sp, #36]	; 0x24
     da8:	4293      	cmp	r3, r2
     daa:	bf28      	it	cs
     dac:	4613      	movcs	r3, r2
     dae:	9309      	str	r3, [sp, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     db0:	9a09      	ldr	r2, [sp, #36]	; 0x24
     db2:	9b01      	ldr	r3, [sp, #4]
     db4:	4293      	cmp	r3, r2
     db6:	bf28      	it	cs
     db8:	4613      	movcs	r3, r2
     dba:	9309      	str	r3, [sp, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     dbc:	9b03      	ldr	r3, [sp, #12]
     dbe:	685a      	ldr	r2, [r3, #4]
     dc0:	9b07      	ldr	r3, [sp, #28]
     dc2:	4413      	add	r3, r2
     dc4:	9305      	str	r3, [sp, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     dc6:	9a09      	ldr	r2, [sp, #36]	; 0x24
     dc8:	9902      	ldr	r1, [sp, #8]
     dca:	9805      	ldr	r0, [sp, #20]
     dcc:	f000 fc7c 	bl	16c8 <memcpy>
    NumBytesWritten += NumBytesToWrite;
     dd0:	9a08      	ldr	r2, [sp, #32]
     dd2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     dd4:	4413      	add	r3, r2
     dd6:	9308      	str	r3, [sp, #32]
    pBuffer         += NumBytesToWrite;
     dd8:	9a02      	ldr	r2, [sp, #8]
     dda:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ddc:	4413      	add	r3, r2
     dde:	9302      	str	r3, [sp, #8]
    NumBytes        -= NumBytesToWrite;
     de0:	9a01      	ldr	r2, [sp, #4]
     de2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     de4:	1ad3      	subs	r3, r2, r3
     de6:	9301      	str	r3, [sp, #4]
    WrOff           += NumBytesToWrite;
     de8:	9a07      	ldr	r2, [sp, #28]
     dea:	9b09      	ldr	r3, [sp, #36]	; 0x24
     dec:	4413      	add	r3, r2
     dee:	9307      	str	r3, [sp, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
     df0:	9b03      	ldr	r3, [sp, #12]
     df2:	689b      	ldr	r3, [r3, #8]
     df4:	9a07      	ldr	r2, [sp, #28]
     df6:	429a      	cmp	r2, r3
     df8:	d101      	bne.n	dfe <_WriteBlocking+0x9e>
      WrOff = 0u;
     dfa:	2300      	movs	r3, #0
     dfc:	9307      	str	r3, [sp, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     dfe:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
     e02:	9b03      	ldr	r3, [sp, #12]
     e04:	9a07      	ldr	r2, [sp, #28]
     e06:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
     e08:	9b01      	ldr	r3, [sp, #4]
     e0a:	2b00      	cmp	r3, #0
     e0c:	d1b2      	bne.n	d74 <_WriteBlocking+0x14>
  return NumBytesWritten;
     e0e:	9b08      	ldr	r3, [sp, #32]
}
     e10:	4618      	mov	r0, r3
     e12:	b00b      	add	sp, #44	; 0x2c
     e14:	f85d fb04 	ldr.w	pc, [sp], #4

00000e18 <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     e18:	b500      	push	{lr}
     e1a:	b089      	sub	sp, #36	; 0x24
     e1c:	9003      	str	r0, [sp, #12]
     e1e:	9102      	str	r1, [sp, #8]
     e20:	9201      	str	r2, [sp, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
     e22:	9b03      	ldr	r3, [sp, #12]
     e24:	68db      	ldr	r3, [r3, #12]
     e26:	9307      	str	r3, [sp, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
     e28:	9b03      	ldr	r3, [sp, #12]
     e2a:	689a      	ldr	r2, [r3, #8]
     e2c:	9b07      	ldr	r3, [sp, #28]
     e2e:	1ad3      	subs	r3, r2, r3
     e30:	9306      	str	r3, [sp, #24]
  if (Rem > NumBytes) {
     e32:	9a06      	ldr	r2, [sp, #24]
     e34:	9b01      	ldr	r3, [sp, #4]
     e36:	429a      	cmp	r2, r3
     e38:	d911      	bls.n	e5e <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     e3a:	9b03      	ldr	r3, [sp, #12]
     e3c:	685a      	ldr	r2, [r3, #4]
     e3e:	9b07      	ldr	r3, [sp, #28]
     e40:	4413      	add	r3, r2
     e42:	9304      	str	r3, [sp, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
     e44:	9a01      	ldr	r2, [sp, #4]
     e46:	9902      	ldr	r1, [sp, #8]
     e48:	9804      	ldr	r0, [sp, #16]
     e4a:	f000 fc3d 	bl	16c8 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     e4e:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
     e52:	9a07      	ldr	r2, [sp, #28]
     e54:	9b01      	ldr	r3, [sp, #4]
     e56:	441a      	add	r2, r3
     e58:	9b03      	ldr	r3, [sp, #12]
     e5a:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
     e5c:	e01f      	b.n	e9e <_WriteNoCheck+0x86>
    NumBytesAtOnce = Rem;
     e5e:	9b06      	ldr	r3, [sp, #24]
     e60:	9305      	str	r3, [sp, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     e62:	9b03      	ldr	r3, [sp, #12]
     e64:	685a      	ldr	r2, [r3, #4]
     e66:	9b07      	ldr	r3, [sp, #28]
     e68:	4413      	add	r3, r2
     e6a:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     e6c:	9a05      	ldr	r2, [sp, #20]
     e6e:	9902      	ldr	r1, [sp, #8]
     e70:	9804      	ldr	r0, [sp, #16]
     e72:	f000 fc29 	bl	16c8 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
     e76:	9a01      	ldr	r2, [sp, #4]
     e78:	9b06      	ldr	r3, [sp, #24]
     e7a:	1ad3      	subs	r3, r2, r3
     e7c:	9305      	str	r3, [sp, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
     e7e:	9b03      	ldr	r3, [sp, #12]
     e80:	685b      	ldr	r3, [r3, #4]
     e82:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     e84:	9a02      	ldr	r2, [sp, #8]
     e86:	9b06      	ldr	r3, [sp, #24]
     e88:	4413      	add	r3, r2
     e8a:	9a05      	ldr	r2, [sp, #20]
     e8c:	4619      	mov	r1, r3
     e8e:	9804      	ldr	r0, [sp, #16]
     e90:	f000 fc1a 	bl	16c8 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     e94:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
     e98:	9b03      	ldr	r3, [sp, #12]
     e9a:	9a05      	ldr	r2, [sp, #20]
     e9c:	60da      	str	r2, [r3, #12]
}
     e9e:	bf00      	nop
     ea0:	b009      	add	sp, #36	; 0x24
     ea2:	f85d fb04 	ldr.w	pc, [sp], #4

00000ea6 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
     ea6:	b086      	sub	sp, #24
     ea8:	9001      	str	r0, [sp, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
     eaa:	9b01      	ldr	r3, [sp, #4]
     eac:	691b      	ldr	r3, [r3, #16]
     eae:	9304      	str	r3, [sp, #16]
  WrOff = pRing->WrOff;
     eb0:	9b01      	ldr	r3, [sp, #4]
     eb2:	68db      	ldr	r3, [r3, #12]
     eb4:	9303      	str	r3, [sp, #12]
  if (RdOff <= WrOff) {
     eb6:	9a04      	ldr	r2, [sp, #16]
     eb8:	9b03      	ldr	r3, [sp, #12]
     eba:	429a      	cmp	r2, r3
     ebc:	d808      	bhi.n	ed0 <_GetAvailWriteSpace+0x2a>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
     ebe:	9b01      	ldr	r3, [sp, #4]
     ec0:	689a      	ldr	r2, [r3, #8]
     ec2:	9b03      	ldr	r3, [sp, #12]
     ec4:	1ad2      	subs	r2, r2, r3
     ec6:	9b04      	ldr	r3, [sp, #16]
     ec8:	4413      	add	r3, r2
     eca:	3b01      	subs	r3, #1
     ecc:	9305      	str	r3, [sp, #20]
     ece:	e004      	b.n	eda <_GetAvailWriteSpace+0x34>
  } else {
    r = RdOff - WrOff - 1u;
     ed0:	9a04      	ldr	r2, [sp, #16]
     ed2:	9b03      	ldr	r3, [sp, #12]
     ed4:	1ad3      	subs	r3, r2, r3
     ed6:	3b01      	subs	r3, #1
     ed8:	9305      	str	r3, [sp, #20]
  }
  return r;
     eda:	9b05      	ldr	r3, [sp, #20]
}
     edc:	4618      	mov	r0, r3
     ede:	b006      	add	sp, #24
     ee0:	4770      	bx	lr
	...

00000ee4 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     ee4:	b500      	push	{lr}
     ee6:	b089      	sub	sp, #36	; 0x24
     ee8:	9003      	str	r0, [sp, #12]
     eea:	9102      	str	r1, [sp, #8]
     eec:	9201      	str	r2, [sp, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
     eee:	9b02      	ldr	r3, [sp, #8]
     ef0:	9306      	str	r3, [sp, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
     ef2:	9b03      	ldr	r3, [sp, #12]
     ef4:	1c5a      	adds	r2, r3, #1
     ef6:	4613      	mov	r3, r2
     ef8:	005b      	lsls	r3, r3, #1
     efa:	4413      	add	r3, r2
     efc:	00db      	lsls	r3, r3, #3
     efe:	4a20      	ldr	r2, [pc, #128]	; (f80 <SEGGER_RTT_WriteNoLock+0x9c>)
     f00:	4413      	add	r3, r2
     f02:	9305      	str	r3, [sp, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
     f04:	9b05      	ldr	r3, [sp, #20]
     f06:	695b      	ldr	r3, [r3, #20]
     f08:	2b02      	cmp	r3, #2
     f0a:	d029      	beq.n	f60 <SEGGER_RTT_WriteNoLock+0x7c>
     f0c:	2b02      	cmp	r3, #2
     f0e:	d82e      	bhi.n	f6e <SEGGER_RTT_WriteNoLock+0x8a>
     f10:	2b00      	cmp	r3, #0
     f12:	d002      	beq.n	f1a <SEGGER_RTT_WriteNoLock+0x36>
     f14:	2b01      	cmp	r3, #1
     f16:	d013      	beq.n	f40 <SEGGER_RTT_WriteNoLock+0x5c>
     f18:	e029      	b.n	f6e <SEGGER_RTT_WriteNoLock+0x8a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
     f1a:	9805      	ldr	r0, [sp, #20]
     f1c:	f7ff ffc3 	bl	ea6 <_GetAvailWriteSpace>
     f20:	9004      	str	r0, [sp, #16]
    if (Avail < NumBytes) {
     f22:	9a04      	ldr	r2, [sp, #16]
     f24:	9b01      	ldr	r3, [sp, #4]
     f26:	429a      	cmp	r2, r3
     f28:	d202      	bcs.n	f30 <SEGGER_RTT_WriteNoLock+0x4c>
      Status = 0u;
     f2a:	2300      	movs	r3, #0
     f2c:	9307      	str	r3, [sp, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
     f2e:	e021      	b.n	f74 <SEGGER_RTT_WriteNoLock+0x90>
      Status = NumBytes;
     f30:	9b01      	ldr	r3, [sp, #4]
     f32:	9307      	str	r3, [sp, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
     f34:	9a01      	ldr	r2, [sp, #4]
     f36:	9906      	ldr	r1, [sp, #24]
     f38:	9805      	ldr	r0, [sp, #20]
     f3a:	f7ff ff6d 	bl	e18 <_WriteNoCheck>
    break;
     f3e:	e019      	b.n	f74 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
     f40:	9805      	ldr	r0, [sp, #20]
     f42:	f7ff ffb0 	bl	ea6 <_GetAvailWriteSpace>
     f46:	9004      	str	r0, [sp, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
     f48:	9a01      	ldr	r2, [sp, #4]
     f4a:	9b04      	ldr	r3, [sp, #16]
     f4c:	4293      	cmp	r3, r2
     f4e:	bf28      	it	cs
     f50:	4613      	movcs	r3, r2
     f52:	9307      	str	r3, [sp, #28]
    _WriteNoCheck(pRing, pData, Status);
     f54:	9a07      	ldr	r2, [sp, #28]
     f56:	9906      	ldr	r1, [sp, #24]
     f58:	9805      	ldr	r0, [sp, #20]
     f5a:	f7ff ff5d 	bl	e18 <_WriteNoCheck>
    break;
     f5e:	e009      	b.n	f74 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
     f60:	9a01      	ldr	r2, [sp, #4]
     f62:	9906      	ldr	r1, [sp, #24]
     f64:	9805      	ldr	r0, [sp, #20]
     f66:	f7ff fefb 	bl	d60 <_WriteBlocking>
     f6a:	9007      	str	r0, [sp, #28]
    break;
     f6c:	e002      	b.n	f74 <SEGGER_RTT_WriteNoLock+0x90>
  default:
    Status = 0u;
     f6e:	2300      	movs	r3, #0
     f70:	9307      	str	r3, [sp, #28]
    break;
     f72:	bf00      	nop
  }
  //
  // Finish up.
  //
  return Status;
     f74:	9b07      	ldr	r3, [sp, #28]
}
     f76:	4618      	mov	r0, r3
     f78:	b009      	add	sp, #36	; 0x24
     f7a:	f85d fb04 	ldr.w	pc, [sp], #4
     f7e:	bf00      	nop
     f80:	1fff8f40 	.word	0x1fff8f40

00000f84 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     f84:	b500      	push	{lr}
     f86:	b089      	sub	sp, #36	; 0x24
     f88:	9003      	str	r0, [sp, #12]
     f8a:	9102      	str	r1, [sp, #8]
     f8c:	9201      	str	r2, [sp, #4]
  unsigned Status;

  INIT();
     f8e:	4b0f      	ldr	r3, [pc, #60]	; (fcc <SEGGER_RTT_Write+0x48>)
     f90:	9307      	str	r3, [sp, #28]
     f92:	9b07      	ldr	r3, [sp, #28]
     f94:	781b      	ldrb	r3, [r3, #0]
     f96:	b2db      	uxtb	r3, r3
     f98:	2b53      	cmp	r3, #83	; 0x53
     f9a:	d001      	beq.n	fa0 <SEGGER_RTT_Write+0x1c>
     f9c:	f7ff fe86 	bl	cac <_DoInit>
  SEGGER_RTT_LOCK();
     fa0:	f3ef 8311 	mrs	r3, BASEPRI
     fa4:	f04f 0120 	mov.w	r1, #32
     fa8:	f381 8811 	msr	BASEPRI, r1
     fac:	9306      	str	r3, [sp, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
     fae:	9a01      	ldr	r2, [sp, #4]
     fb0:	9902      	ldr	r1, [sp, #8]
     fb2:	9803      	ldr	r0, [sp, #12]
     fb4:	f7ff ff96 	bl	ee4 <SEGGER_RTT_WriteNoLock>
     fb8:	9005      	str	r0, [sp, #20]
  SEGGER_RTT_UNLOCK();
     fba:	9b06      	ldr	r3, [sp, #24]
     fbc:	f383 8811 	msr	BASEPRI, r3
  return Status;
     fc0:	9b05      	ldr	r3, [sp, #20]
}
     fc2:	4618      	mov	r0, r3
     fc4:	b009      	add	sp, #36	; 0x24
     fc6:	f85d fb04 	ldr.w	pc, [sp], #4
     fca:	bf00      	nop
     fcc:	1fff8f40 	.word	0x1fff8f40

00000fd0 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
     fd0:	b508      	push	{r3, lr}
  _DoInit();
     fd2:	f7ff fe6b 	bl	cac <_DoInit>
}
     fd6:	bf00      	nop
     fd8:	bd08      	pop	{r3, pc}

00000fda <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
     fda:	b500      	push	{lr}
     fdc:	b085      	sub	sp, #20
     fde:	9001      	str	r0, [sp, #4]
     fe0:	460b      	mov	r3, r1
     fe2:	f88d 3003 	strb.w	r3, [sp, #3]
  unsigned Cnt;

  Cnt = p->Cnt;
     fe6:	9b01      	ldr	r3, [sp, #4]
     fe8:	689b      	ldr	r3, [r3, #8]
     fea:	9303      	str	r3, [sp, #12]
  if ((Cnt + 1u) <= p->BufferSize) {
     fec:	9b03      	ldr	r3, [sp, #12]
     fee:	1c5a      	adds	r2, r3, #1
     ff0:	9b01      	ldr	r3, [sp, #4]
     ff2:	685b      	ldr	r3, [r3, #4]
     ff4:	429a      	cmp	r2, r3
     ff6:	d80f      	bhi.n	1018 <_StoreChar+0x3e>
    *(p->pBuffer + Cnt) = c;
     ff8:	9b01      	ldr	r3, [sp, #4]
     ffa:	681a      	ldr	r2, [r3, #0]
     ffc:	9b03      	ldr	r3, [sp, #12]
     ffe:	4413      	add	r3, r2
    1000:	f89d 2003 	ldrb.w	r2, [sp, #3]
    1004:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
    1006:	9b03      	ldr	r3, [sp, #12]
    1008:	1c5a      	adds	r2, r3, #1
    100a:	9b01      	ldr	r3, [sp, #4]
    100c:	609a      	str	r2, [r3, #8]
    p->ReturnValue++;
    100e:	9b01      	ldr	r3, [sp, #4]
    1010:	68db      	ldr	r3, [r3, #12]
    1012:	1c5a      	adds	r2, r3, #1
    1014:	9b01      	ldr	r3, [sp, #4]
    1016:	60da      	str	r2, [r3, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
    1018:	9b01      	ldr	r3, [sp, #4]
    101a:	689a      	ldr	r2, [r3, #8]
    101c:	9b01      	ldr	r3, [sp, #4]
    101e:	685b      	ldr	r3, [r3, #4]
    1020:	429a      	cmp	r2, r3
    1022:	d115      	bne.n	1050 <_StoreChar+0x76>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
    1024:	9b01      	ldr	r3, [sp, #4]
    1026:	6918      	ldr	r0, [r3, #16]
    1028:	9b01      	ldr	r3, [sp, #4]
    102a:	6819      	ldr	r1, [r3, #0]
    102c:	9b01      	ldr	r3, [sp, #4]
    102e:	689b      	ldr	r3, [r3, #8]
    1030:	461a      	mov	r2, r3
    1032:	f7ff ffa7 	bl	f84 <SEGGER_RTT_Write>
    1036:	4602      	mov	r2, r0
    1038:	9b01      	ldr	r3, [sp, #4]
    103a:	689b      	ldr	r3, [r3, #8]
    103c:	429a      	cmp	r2, r3
    103e:	d004      	beq.n	104a <_StoreChar+0x70>
      p->ReturnValue = -1;
    1040:	9b01      	ldr	r3, [sp, #4]
    1042:	f04f 32ff 	mov.w	r2, #4294967295
    1046:	60da      	str	r2, [r3, #12]
    } else {
      p->Cnt = 0u;
    }
  }
}
    1048:	e002      	b.n	1050 <_StoreChar+0x76>
      p->Cnt = 0u;
    104a:	9b01      	ldr	r3, [sp, #4]
    104c:	2200      	movs	r2, #0
    104e:	609a      	str	r2, [r3, #8]
}
    1050:	bf00      	nop
    1052:	b005      	add	sp, #20
    1054:	f85d fb04 	ldr.w	pc, [sp], #4

00001058 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    1058:	b500      	push	{lr}
    105a:	b08b      	sub	sp, #44	; 0x2c
    105c:	9003      	str	r0, [sp, #12]
    105e:	9102      	str	r1, [sp, #8]
    1060:	9201      	str	r2, [sp, #4]
    1062:	9300      	str	r3, [sp, #0]
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
    1064:	9b02      	ldr	r3, [sp, #8]
    1066:	9308      	str	r3, [sp, #32]
  Digit = 1u;
    1068:	2301      	movs	r3, #1
    106a:	9309      	str	r3, [sp, #36]	; 0x24
  //
  // Get actual field width
  //
  Width = 1u;
    106c:	2301      	movs	r3, #1
    106e:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    1070:	e007      	b.n	1082 <_PrintUnsigned+0x2a>
    Number = (Number / Base);
    1072:	9a08      	ldr	r2, [sp, #32]
    1074:	9b01      	ldr	r3, [sp, #4]
    1076:	fbb2 f3f3 	udiv	r3, r2, r3
    107a:	9308      	str	r3, [sp, #32]
    Width++;
    107c:	9b07      	ldr	r3, [sp, #28]
    107e:	3301      	adds	r3, #1
    1080:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    1082:	9a08      	ldr	r2, [sp, #32]
    1084:	9b01      	ldr	r3, [sp, #4]
    1086:	429a      	cmp	r2, r3
    1088:	d2f3      	bcs.n	1072 <_PrintUnsigned+0x1a>
  }
  if (NumDigits > Width) {
    108a:	9a00      	ldr	r2, [sp, #0]
    108c:	9b07      	ldr	r3, [sp, #28]
    108e:	429a      	cmp	r2, r3
    1090:	d901      	bls.n	1096 <_PrintUnsigned+0x3e>
    Width = NumDigits;
    1092:	9b00      	ldr	r3, [sp, #0]
    1094:	9307      	str	r3, [sp, #28]
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
    1096:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1098:	f003 0301 	and.w	r3, r3, #1
    109c:	2b00      	cmp	r3, #0
    109e:	d128      	bne.n	10f2 <_PrintUnsigned+0x9a>
    if (FieldWidth != 0u) {
    10a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    10a2:	2b00      	cmp	r3, #0
    10a4:	d025      	beq.n	10f2 <_PrintUnsigned+0x9a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
    10a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    10a8:	f003 0302 	and.w	r3, r3, #2
    10ac:	2b00      	cmp	r3, #0
    10ae:	d006      	beq.n	10be <_PrintUnsigned+0x66>
    10b0:	9b00      	ldr	r3, [sp, #0]
    10b2:	2b00      	cmp	r3, #0
    10b4:	d103      	bne.n	10be <_PrintUnsigned+0x66>
        c = '0';
    10b6:	2330      	movs	r3, #48	; 0x30
    10b8:	f88d 301b 	strb.w	r3, [sp, #27]
    10bc:	e002      	b.n	10c4 <_PrintUnsigned+0x6c>
      } else {
        c = ' ';
    10be:	2320      	movs	r3, #32
    10c0:	f88d 301b 	strb.w	r3, [sp, #27]
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    10c4:	e00c      	b.n	10e0 <_PrintUnsigned+0x88>
        FieldWidth--;
    10c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    10c8:	3b01      	subs	r3, #1
    10ca:	930c      	str	r3, [sp, #48]	; 0x30
        _StoreChar(pBufferDesc, c);
    10cc:	f89d 301b 	ldrb.w	r3, [sp, #27]
    10d0:	4619      	mov	r1, r3
    10d2:	9803      	ldr	r0, [sp, #12]
    10d4:	f7ff ff81 	bl	fda <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    10d8:	9b03      	ldr	r3, [sp, #12]
    10da:	68db      	ldr	r3, [r3, #12]
    10dc:	2b00      	cmp	r3, #0
    10de:	db07      	blt.n	10f0 <_PrintUnsigned+0x98>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    10e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    10e2:	2b00      	cmp	r3, #0
    10e4:	d005      	beq.n	10f2 <_PrintUnsigned+0x9a>
    10e6:	9a07      	ldr	r2, [sp, #28]
    10e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    10ea:	429a      	cmp	r2, r3
    10ec:	d3eb      	bcc.n	10c6 <_PrintUnsigned+0x6e>
    10ee:	e000      	b.n	10f2 <_PrintUnsigned+0x9a>
          break;
    10f0:	bf00      	nop
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
    10f2:	9b03      	ldr	r3, [sp, #12]
    10f4:	68db      	ldr	r3, [r3, #12]
    10f6:	2b00      	cmp	r3, #0
    10f8:	db55      	blt.n	11a6 <_PrintUnsigned+0x14e>
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    10fa:	9b00      	ldr	r3, [sp, #0]
    10fc:	2b01      	cmp	r3, #1
    10fe:	d903      	bls.n	1108 <_PrintUnsigned+0xb0>
        NumDigits--;
    1100:	9b00      	ldr	r3, [sp, #0]
    1102:	3b01      	subs	r3, #1
    1104:	9300      	str	r3, [sp, #0]
    1106:	e009      	b.n	111c <_PrintUnsigned+0xc4>
      } else {
        Div = v / Digit;
    1108:	9a02      	ldr	r2, [sp, #8]
    110a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    110c:	fbb2 f3f3 	udiv	r3, r2, r3
    1110:	9305      	str	r3, [sp, #20]
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    1112:	9a05      	ldr	r2, [sp, #20]
    1114:	9b01      	ldr	r3, [sp, #4]
    1116:	429a      	cmp	r2, r3
    1118:	d200      	bcs.n	111c <_PrintUnsigned+0xc4>
          break;
    111a:	e005      	b.n	1128 <_PrintUnsigned+0xd0>
        }
      }
      Digit *= Base;
    111c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    111e:	9a01      	ldr	r2, [sp, #4]
    1120:	fb02 f303 	mul.w	r3, r2, r3
    1124:	9309      	str	r3, [sp, #36]	; 0x24
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    1126:	e7e8      	b.n	10fa <_PrintUnsigned+0xa2>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    1128:	9a02      	ldr	r2, [sp, #8]
    112a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    112c:	fbb2 f3f3 	udiv	r3, r2, r3
    1130:	9305      	str	r3, [sp, #20]
      v -= Div * Digit;
    1132:	9b05      	ldr	r3, [sp, #20]
    1134:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1136:	fb02 f303 	mul.w	r3, r2, r3
    113a:	9a02      	ldr	r2, [sp, #8]
    113c:	1ad3      	subs	r3, r2, r3
    113e:	9302      	str	r3, [sp, #8]
      _StoreChar(pBufferDesc, _aV2C[Div]);
    1140:	4a1b      	ldr	r2, [pc, #108]	; (11b0 <_PrintUnsigned+0x158>)
    1142:	9b05      	ldr	r3, [sp, #20]
    1144:	4413      	add	r3, r2
    1146:	781b      	ldrb	r3, [r3, #0]
    1148:	4619      	mov	r1, r3
    114a:	9803      	ldr	r0, [sp, #12]
    114c:	f7ff ff45 	bl	fda <_StoreChar>
      if (pBufferDesc->ReturnValue < 0) {
    1150:	9b03      	ldr	r3, [sp, #12]
    1152:	68db      	ldr	r3, [r3, #12]
    1154:	2b00      	cmp	r3, #0
    1156:	db08      	blt.n	116a <_PrintUnsigned+0x112>
        break;
      }
      Digit /= Base;
    1158:	9a09      	ldr	r2, [sp, #36]	; 0x24
    115a:	9b01      	ldr	r3, [sp, #4]
    115c:	fbb2 f3f3 	udiv	r3, r2, r3
    1160:	9309      	str	r3, [sp, #36]	; 0x24
    } while (Digit);
    1162:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1164:	2b00      	cmp	r3, #0
    1166:	d1df      	bne.n	1128 <_PrintUnsigned+0xd0>
    1168:	e000      	b.n	116c <_PrintUnsigned+0x114>
        break;
    116a:	bf00      	nop
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    116c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    116e:	f003 0301 	and.w	r3, r3, #1
    1172:	2b00      	cmp	r3, #0
    1174:	d017      	beq.n	11a6 <_PrintUnsigned+0x14e>
      if (FieldWidth != 0u) {
    1176:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1178:	2b00      	cmp	r3, #0
    117a:	d014      	beq.n	11a6 <_PrintUnsigned+0x14e>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    117c:	e00a      	b.n	1194 <_PrintUnsigned+0x13c>
          FieldWidth--;
    117e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1180:	3b01      	subs	r3, #1
    1182:	930c      	str	r3, [sp, #48]	; 0x30
          _StoreChar(pBufferDesc, ' ');
    1184:	2120      	movs	r1, #32
    1186:	9803      	ldr	r0, [sp, #12]
    1188:	f7ff ff27 	bl	fda <_StoreChar>
          if (pBufferDesc->ReturnValue < 0) {
    118c:	9b03      	ldr	r3, [sp, #12]
    118e:	68db      	ldr	r3, [r3, #12]
    1190:	2b00      	cmp	r3, #0
    1192:	db07      	blt.n	11a4 <_PrintUnsigned+0x14c>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1194:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1196:	2b00      	cmp	r3, #0
    1198:	d005      	beq.n	11a6 <_PrintUnsigned+0x14e>
    119a:	9a07      	ldr	r2, [sp, #28]
    119c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    119e:	429a      	cmp	r2, r3
    11a0:	d3ed      	bcc.n	117e <_PrintUnsigned+0x126>
          }
        }
      }
    }
  }
}
    11a2:	e000      	b.n	11a6 <_PrintUnsigned+0x14e>
            break;
    11a4:	bf00      	nop
}
    11a6:	bf00      	nop
    11a8:	b00b      	add	sp, #44	; 0x2c
    11aa:	f85d fb04 	ldr.w	pc, [sp], #4
    11ae:	bf00      	nop
    11b0:	0000b680 	.word	0x0000b680

000011b4 <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    11b4:	b500      	push	{lr}
    11b6:	b089      	sub	sp, #36	; 0x24
    11b8:	9005      	str	r0, [sp, #20]
    11ba:	9104      	str	r1, [sp, #16]
    11bc:	9203      	str	r2, [sp, #12]
    11be:	9302      	str	r3, [sp, #8]
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    11c0:	9b04      	ldr	r3, [sp, #16]
    11c2:	2b00      	cmp	r3, #0
    11c4:	bfb8      	it	lt
    11c6:	425b      	neglt	r3, r3
    11c8:	9306      	str	r3, [sp, #24]

  //
  // Get actual field width
  //
  Width = 1u;
    11ca:	2301      	movs	r3, #1
    11cc:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    11ce:	e007      	b.n	11e0 <_PrintInt+0x2c>
    Number = (Number / (int)Base);
    11d0:	9b03      	ldr	r3, [sp, #12]
    11d2:	9a06      	ldr	r2, [sp, #24]
    11d4:	fb92 f3f3 	sdiv	r3, r2, r3
    11d8:	9306      	str	r3, [sp, #24]
    Width++;
    11da:	9b07      	ldr	r3, [sp, #28]
    11dc:	3301      	adds	r3, #1
    11de:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    11e0:	9b03      	ldr	r3, [sp, #12]
    11e2:	9a06      	ldr	r2, [sp, #24]
    11e4:	429a      	cmp	r2, r3
    11e6:	daf3      	bge.n	11d0 <_PrintInt+0x1c>
  }
  if (NumDigits > Width) {
    11e8:	9a02      	ldr	r2, [sp, #8]
    11ea:	9b07      	ldr	r3, [sp, #28]
    11ec:	429a      	cmp	r2, r3
    11ee:	d901      	bls.n	11f4 <_PrintInt+0x40>
    Width = NumDigits;
    11f0:	9b02      	ldr	r3, [sp, #8]
    11f2:	9307      	str	r3, [sp, #28]
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    11f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11f6:	2b00      	cmp	r3, #0
    11f8:	d00a      	beq.n	1210 <_PrintInt+0x5c>
    11fa:	9b04      	ldr	r3, [sp, #16]
    11fc:	2b00      	cmp	r3, #0
    11fe:	db04      	blt.n	120a <_PrintInt+0x56>
    1200:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1202:	f003 0304 	and.w	r3, r3, #4
    1206:	2b00      	cmp	r3, #0
    1208:	d002      	beq.n	1210 <_PrintInt+0x5c>
    FieldWidth--;
    120a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    120c:	3b01      	subs	r3, #1
    120e:	930a      	str	r3, [sp, #40]	; 0x28
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    1210:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1212:	f003 0302 	and.w	r3, r3, #2
    1216:	2b00      	cmp	r3, #0
    1218:	d002      	beq.n	1220 <_PrintInt+0x6c>
    121a:	9b02      	ldr	r3, [sp, #8]
    121c:	2b00      	cmp	r3, #0
    121e:	d01c      	beq.n	125a <_PrintInt+0xa6>
    1220:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1222:	f003 0301 	and.w	r3, r3, #1
    1226:	2b00      	cmp	r3, #0
    1228:	d117      	bne.n	125a <_PrintInt+0xa6>
    if (FieldWidth != 0u) {
    122a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    122c:	2b00      	cmp	r3, #0
    122e:	d014      	beq.n	125a <_PrintInt+0xa6>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1230:	e00a      	b.n	1248 <_PrintInt+0x94>
        FieldWidth--;
    1232:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1234:	3b01      	subs	r3, #1
    1236:	930a      	str	r3, [sp, #40]	; 0x28
        _StoreChar(pBufferDesc, ' ');
    1238:	2120      	movs	r1, #32
    123a:	9805      	ldr	r0, [sp, #20]
    123c:	f7ff fecd 	bl	fda <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    1240:	9b05      	ldr	r3, [sp, #20]
    1242:	68db      	ldr	r3, [r3, #12]
    1244:	2b00      	cmp	r3, #0
    1246:	db07      	blt.n	1258 <_PrintInt+0xa4>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1248:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    124a:	2b00      	cmp	r3, #0
    124c:	d005      	beq.n	125a <_PrintInt+0xa6>
    124e:	9a07      	ldr	r2, [sp, #28]
    1250:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1252:	429a      	cmp	r2, r3
    1254:	d3ed      	bcc.n	1232 <_PrintInt+0x7e>
    1256:	e000      	b.n	125a <_PrintInt+0xa6>
          break;
    1258:	bf00      	nop
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    125a:	9b05      	ldr	r3, [sp, #20]
    125c:	68db      	ldr	r3, [r3, #12]
    125e:	2b00      	cmp	r3, #0
    1260:	db4a      	blt.n	12f8 <_PrintInt+0x144>
    if (v < 0) {
    1262:	9b04      	ldr	r3, [sp, #16]
    1264:	2b00      	cmp	r3, #0
    1266:	da07      	bge.n	1278 <_PrintInt+0xc4>
      v = -v;
    1268:	9b04      	ldr	r3, [sp, #16]
    126a:	425b      	negs	r3, r3
    126c:	9304      	str	r3, [sp, #16]
      _StoreChar(pBufferDesc, '-');
    126e:	212d      	movs	r1, #45	; 0x2d
    1270:	9805      	ldr	r0, [sp, #20]
    1272:	f7ff feb2 	bl	fda <_StoreChar>
    1276:	e008      	b.n	128a <_PrintInt+0xd6>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    1278:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    127a:	f003 0304 	and.w	r3, r3, #4
    127e:	2b00      	cmp	r3, #0
    1280:	d003      	beq.n	128a <_PrintInt+0xd6>
      _StoreChar(pBufferDesc, '+');
    1282:	212b      	movs	r1, #43	; 0x2b
    1284:	9805      	ldr	r0, [sp, #20]
    1286:	f7ff fea8 	bl	fda <_StoreChar>
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    128a:	9b05      	ldr	r3, [sp, #20]
    128c:	68db      	ldr	r3, [r3, #12]
    128e:	2b00      	cmp	r3, #0
    1290:	db32      	blt.n	12f8 <_PrintInt+0x144>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    1292:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1294:	f003 0302 	and.w	r3, r3, #2
    1298:	2b00      	cmp	r3, #0
    129a:	d01f      	beq.n	12dc <_PrintInt+0x128>
    129c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    129e:	f003 0301 	and.w	r3, r3, #1
    12a2:	2b00      	cmp	r3, #0
    12a4:	d11a      	bne.n	12dc <_PrintInt+0x128>
    12a6:	9b02      	ldr	r3, [sp, #8]
    12a8:	2b00      	cmp	r3, #0
    12aa:	d117      	bne.n	12dc <_PrintInt+0x128>
        if (FieldWidth != 0u) {
    12ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12ae:	2b00      	cmp	r3, #0
    12b0:	d014      	beq.n	12dc <_PrintInt+0x128>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    12b2:	e00a      	b.n	12ca <_PrintInt+0x116>
            FieldWidth--;
    12b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12b6:	3b01      	subs	r3, #1
    12b8:	930a      	str	r3, [sp, #40]	; 0x28
            _StoreChar(pBufferDesc, '0');
    12ba:	2130      	movs	r1, #48	; 0x30
    12bc:	9805      	ldr	r0, [sp, #20]
    12be:	f7ff fe8c 	bl	fda <_StoreChar>
            if (pBufferDesc->ReturnValue < 0) {
    12c2:	9b05      	ldr	r3, [sp, #20]
    12c4:	68db      	ldr	r3, [r3, #12]
    12c6:	2b00      	cmp	r3, #0
    12c8:	db07      	blt.n	12da <_PrintInt+0x126>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    12ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12cc:	2b00      	cmp	r3, #0
    12ce:	d005      	beq.n	12dc <_PrintInt+0x128>
    12d0:	9a07      	ldr	r2, [sp, #28]
    12d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12d4:	429a      	cmp	r2, r3
    12d6:	d3ed      	bcc.n	12b4 <_PrintInt+0x100>
    12d8:	e000      	b.n	12dc <_PrintInt+0x128>
              break;
    12da:	bf00      	nop
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    12dc:	9b05      	ldr	r3, [sp, #20]
    12de:	68db      	ldr	r3, [r3, #12]
    12e0:	2b00      	cmp	r3, #0
    12e2:	db09      	blt.n	12f8 <_PrintInt+0x144>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    12e4:	9904      	ldr	r1, [sp, #16]
    12e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    12e8:	9301      	str	r3, [sp, #4]
    12ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12ec:	9300      	str	r3, [sp, #0]
    12ee:	9b02      	ldr	r3, [sp, #8]
    12f0:	9a03      	ldr	r2, [sp, #12]
    12f2:	9805      	ldr	r0, [sp, #20]
    12f4:	f7ff feb0 	bl	1058 <_PrintUnsigned>
      }
    }
  }
}
    12f8:	bf00      	nop
    12fa:	b009      	add	sp, #36	; 0x24
    12fc:	f85d fb04 	ldr.w	pc, [sp], #4

00001300 <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    1300:	b500      	push	{lr}
    1302:	b0a3      	sub	sp, #140	; 0x8c
    1304:	9005      	str	r0, [sp, #20]
    1306:	9104      	str	r1, [sp, #16]
    1308:	9203      	str	r2, [sp, #12]
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    130a:	ab06      	add	r3, sp, #24
    130c:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    130e:	2340      	movs	r3, #64	; 0x40
    1310:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.Cnt            = 0u;
    1312:	2300      	movs	r3, #0
    1314:	9318      	str	r3, [sp, #96]	; 0x60
  BufferDesc.RTTBufferIndex = BufferIndex;
    1316:	9b05      	ldr	r3, [sp, #20]
    1318:	931a      	str	r3, [sp, #104]	; 0x68
  BufferDesc.ReturnValue    = 0;
    131a:	2300      	movs	r3, #0
    131c:	9319      	str	r3, [sp, #100]	; 0x64

  do {
    c = *sFormat;
    131e:	9b04      	ldr	r3, [sp, #16]
    1320:	781b      	ldrb	r3, [r3, #0]
    1322:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    sFormat++;
    1326:	9b04      	ldr	r3, [sp, #16]
    1328:	3301      	adds	r3, #1
    132a:	9304      	str	r3, [sp, #16]
    if (c == 0u) {
    132c:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1330:	2b00      	cmp	r3, #0
    1332:	f000 819c 	beq.w	166e <SEGGER_RTT_vprintf+0x36e>
      break;
    }
    if (c == '%') {
    1336:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    133a:	2b25      	cmp	r3, #37	; 0x25
    133c:	f040 818b 	bne.w	1656 <SEGGER_RTT_vprintf+0x356>
      //
      // Filter out flags
      //
      FormatFlags = 0u;
    1340:	2300      	movs	r3, #0
    1342:	931e      	str	r3, [sp, #120]	; 0x78
      v = 1;
    1344:	2301      	movs	r3, #1
    1346:	9320      	str	r3, [sp, #128]	; 0x80
      do {
        c = *sFormat;
    1348:	9b04      	ldr	r3, [sp, #16]
    134a:	781b      	ldrb	r3, [r3, #0]
    134c:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        switch (c) {
    1350:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1354:	3b23      	subs	r3, #35	; 0x23
    1356:	2b0d      	cmp	r3, #13
    1358:	d83e      	bhi.n	13d8 <SEGGER_RTT_vprintf+0xd8>
    135a:	a201      	add	r2, pc, #4	; (adr r2, 1360 <SEGGER_RTT_vprintf+0x60>)
    135c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1360:	000013c9 	.word	0x000013c9
    1364:	000013d9 	.word	0x000013d9
    1368:	000013d9 	.word	0x000013d9
    136c:	000013d9 	.word	0x000013d9
    1370:	000013d9 	.word	0x000013d9
    1374:	000013d9 	.word	0x000013d9
    1378:	000013d9 	.word	0x000013d9
    137c:	000013d9 	.word	0x000013d9
    1380:	000013b9 	.word	0x000013b9
    1384:	000013d9 	.word	0x000013d9
    1388:	00001399 	.word	0x00001399
    138c:	000013d9 	.word	0x000013d9
    1390:	000013d9 	.word	0x000013d9
    1394:	000013a9 	.word	0x000013a9
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    1398:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    139a:	f043 0301 	orr.w	r3, r3, #1
    139e:	931e      	str	r3, [sp, #120]	; 0x78
    13a0:	9b04      	ldr	r3, [sp, #16]
    13a2:	3301      	adds	r3, #1
    13a4:	9304      	str	r3, [sp, #16]
    13a6:	e01a      	b.n	13de <SEGGER_RTT_vprintf+0xde>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    13a8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    13aa:	f043 0302 	orr.w	r3, r3, #2
    13ae:	931e      	str	r3, [sp, #120]	; 0x78
    13b0:	9b04      	ldr	r3, [sp, #16]
    13b2:	3301      	adds	r3, #1
    13b4:	9304      	str	r3, [sp, #16]
    13b6:	e012      	b.n	13de <SEGGER_RTT_vprintf+0xde>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    13b8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    13ba:	f043 0304 	orr.w	r3, r3, #4
    13be:	931e      	str	r3, [sp, #120]	; 0x78
    13c0:	9b04      	ldr	r3, [sp, #16]
    13c2:	3301      	adds	r3, #1
    13c4:	9304      	str	r3, [sp, #16]
    13c6:	e00a      	b.n	13de <SEGGER_RTT_vprintf+0xde>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    13c8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    13ca:	f043 0308 	orr.w	r3, r3, #8
    13ce:	931e      	str	r3, [sp, #120]	; 0x78
    13d0:	9b04      	ldr	r3, [sp, #16]
    13d2:	3301      	adds	r3, #1
    13d4:	9304      	str	r3, [sp, #16]
    13d6:	e002      	b.n	13de <SEGGER_RTT_vprintf+0xde>
        default:  v = 0; break;
    13d8:	2300      	movs	r3, #0
    13da:	9320      	str	r3, [sp, #128]	; 0x80
    13dc:	bf00      	nop
        }
      } while (v);
    13de:	9b20      	ldr	r3, [sp, #128]	; 0x80
    13e0:	2b00      	cmp	r3, #0
    13e2:	d1b1      	bne.n	1348 <SEGGER_RTT_vprintf+0x48>
      //
      // filter out field with
      //
      FieldWidth = 0u;
    13e4:	2300      	movs	r3, #0
    13e6:	931d      	str	r3, [sp, #116]	; 0x74
      do {
        c = *sFormat;
    13e8:	9b04      	ldr	r3, [sp, #16]
    13ea:	781b      	ldrb	r3, [r3, #0]
    13ec:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c < '0') || (c > '9')) {
    13f0:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    13f4:	2b2f      	cmp	r3, #47	; 0x2f
    13f6:	d912      	bls.n	141e <SEGGER_RTT_vprintf+0x11e>
    13f8:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    13fc:	2b39      	cmp	r3, #57	; 0x39
    13fe:	d80e      	bhi.n	141e <SEGGER_RTT_vprintf+0x11e>
          break;
        }
        sFormat++;
    1400:	9b04      	ldr	r3, [sp, #16]
    1402:	3301      	adds	r3, #1
    1404:	9304      	str	r3, [sp, #16]
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    1406:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    1408:	4613      	mov	r3, r2
    140a:	009b      	lsls	r3, r3, #2
    140c:	4413      	add	r3, r2
    140e:	005b      	lsls	r3, r3, #1
    1410:	461a      	mov	r2, r3
    1412:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1416:	4413      	add	r3, r2
    1418:	3b30      	subs	r3, #48	; 0x30
    141a:	931d      	str	r3, [sp, #116]	; 0x74
        c = *sFormat;
    141c:	e7e4      	b.n	13e8 <SEGGER_RTT_vprintf+0xe8>
      } while (1);

      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
    141e:	2300      	movs	r3, #0
    1420:	931f      	str	r3, [sp, #124]	; 0x7c
      c = *sFormat;
    1422:	9b04      	ldr	r3, [sp, #16]
    1424:	781b      	ldrb	r3, [r3, #0]
    1426:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      if (c == '.') {
    142a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    142e:	2b2e      	cmp	r3, #46	; 0x2e
    1430:	d11d      	bne.n	146e <SEGGER_RTT_vprintf+0x16e>
        sFormat++;
    1432:	9b04      	ldr	r3, [sp, #16]
    1434:	3301      	adds	r3, #1
    1436:	9304      	str	r3, [sp, #16]
        do {
          c = *sFormat;
    1438:	9b04      	ldr	r3, [sp, #16]
    143a:	781b      	ldrb	r3, [r3, #0]
    143c:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
          if ((c < '0') || (c > '9')) {
    1440:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1444:	2b2f      	cmp	r3, #47	; 0x2f
    1446:	d912      	bls.n	146e <SEGGER_RTT_vprintf+0x16e>
    1448:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    144c:	2b39      	cmp	r3, #57	; 0x39
    144e:	d80e      	bhi.n	146e <SEGGER_RTT_vprintf+0x16e>
            break;
          }
          sFormat++;
    1450:	9b04      	ldr	r3, [sp, #16]
    1452:	3301      	adds	r3, #1
    1454:	9304      	str	r3, [sp, #16]
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    1456:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    1458:	4613      	mov	r3, r2
    145a:	009b      	lsls	r3, r3, #2
    145c:	4413      	add	r3, r2
    145e:	005b      	lsls	r3, r3, #1
    1460:	461a      	mov	r2, r3
    1462:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1466:	4413      	add	r3, r2
    1468:	3b30      	subs	r3, #48	; 0x30
    146a:	931f      	str	r3, [sp, #124]	; 0x7c
          c = *sFormat;
    146c:	e7e4      	b.n	1438 <SEGGER_RTT_vprintf+0x138>
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    146e:	9b04      	ldr	r3, [sp, #16]
    1470:	781b      	ldrb	r3, [r3, #0]
    1472:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      do {
        if ((c == 'l') || (c == 'h')) {
    1476:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    147a:	2b6c      	cmp	r3, #108	; 0x6c
    147c:	d003      	beq.n	1486 <SEGGER_RTT_vprintf+0x186>
    147e:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1482:	2b68      	cmp	r3, #104	; 0x68
    1484:	d107      	bne.n	1496 <SEGGER_RTT_vprintf+0x196>
          sFormat++;
    1486:	9b04      	ldr	r3, [sp, #16]
    1488:	3301      	adds	r3, #1
    148a:	9304      	str	r3, [sp, #16]
          c = *sFormat;
    148c:	9b04      	ldr	r3, [sp, #16]
    148e:	781b      	ldrb	r3, [r3, #0]
    1490:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c == 'l') || (c == 'h')) {
    1494:	e7ef      	b.n	1476 <SEGGER_RTT_vprintf+0x176>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    1496:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    149a:	2b25      	cmp	r3, #37	; 0x25
    149c:	f000 80d0 	beq.w	1640 <SEGGER_RTT_vprintf+0x340>
    14a0:	2b25      	cmp	r3, #37	; 0x25
    14a2:	f2c0 80d3 	blt.w	164c <SEGGER_RTT_vprintf+0x34c>
    14a6:	2b78      	cmp	r3, #120	; 0x78
    14a8:	f300 80d0 	bgt.w	164c <SEGGER_RTT_vprintf+0x34c>
    14ac:	2b58      	cmp	r3, #88	; 0x58
    14ae:	f2c0 80cd 	blt.w	164c <SEGGER_RTT_vprintf+0x34c>
    14b2:	3b58      	subs	r3, #88	; 0x58
    14b4:	2b20      	cmp	r3, #32
    14b6:	f200 80c9 	bhi.w	164c <SEGGER_RTT_vprintf+0x34c>
    14ba:	a201      	add	r2, pc, #4	; (adr r2, 14c0 <SEGGER_RTT_vprintf+0x1c0>)
    14bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    14c0:	000015b1 	.word	0x000015b1
    14c4:	0000164d 	.word	0x0000164d
    14c8:	0000164d 	.word	0x0000164d
    14cc:	0000164d 	.word	0x0000164d
    14d0:	0000164d 	.word	0x0000164d
    14d4:	0000164d 	.word	0x0000164d
    14d8:	0000164d 	.word	0x0000164d
    14dc:	0000164d 	.word	0x0000164d
    14e0:	0000164d 	.word	0x0000164d
    14e4:	0000164d 	.word	0x0000164d
    14e8:	0000164d 	.word	0x0000164d
    14ec:	00001545 	.word	0x00001545
    14f0:	00001569 	.word	0x00001569
    14f4:	0000164d 	.word	0x0000164d
    14f8:	0000164d 	.word	0x0000164d
    14fc:	0000164d 	.word	0x0000164d
    1500:	0000164d 	.word	0x0000164d
    1504:	0000164d 	.word	0x0000164d
    1508:	0000164d 	.word	0x0000164d
    150c:	0000164d 	.word	0x0000164d
    1510:	0000164d 	.word	0x0000164d
    1514:	0000164d 	.word	0x0000164d
    1518:	0000164d 	.word	0x0000164d
    151c:	0000164d 	.word	0x0000164d
    1520:	0000161d 	.word	0x0000161d
    1524:	0000164d 	.word	0x0000164d
    1528:	0000164d 	.word	0x0000164d
    152c:	000015d5 	.word	0x000015d5
    1530:	0000164d 	.word	0x0000164d
    1534:	0000158d 	.word	0x0000158d
    1538:	0000164d 	.word	0x0000164d
    153c:	0000164d 	.word	0x0000164d
    1540:	000015b1 	.word	0x000015b1
      case 'c': {
        char c0;
        v = va_arg(*pParamList, int);
    1544:	9b03      	ldr	r3, [sp, #12]
    1546:	681b      	ldr	r3, [r3, #0]
    1548:	1d19      	adds	r1, r3, #4
    154a:	9a03      	ldr	r2, [sp, #12]
    154c:	6011      	str	r1, [r2, #0]
    154e:	681b      	ldr	r3, [r3, #0]
    1550:	9320      	str	r3, [sp, #128]	; 0x80
        c0 = (char)v;
    1552:	9b20      	ldr	r3, [sp, #128]	; 0x80
    1554:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
        _StoreChar(&BufferDesc, c0);
    1558:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
    155c:	ab16      	add	r3, sp, #88	; 0x58
    155e:	4611      	mov	r1, r2
    1560:	4618      	mov	r0, r3
    1562:	f7ff fd3a 	bl	fda <_StoreChar>
        break;
    1566:	e072      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      }
      case 'd':
        v = va_arg(*pParamList, int);
    1568:	9b03      	ldr	r3, [sp, #12]
    156a:	681b      	ldr	r3, [r3, #0]
    156c:	1d19      	adds	r1, r3, #4
    156e:	9a03      	ldr	r2, [sp, #12]
    1570:	6011      	str	r1, [r2, #0]
    1572:	681b      	ldr	r3, [r3, #0]
    1574:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    1576:	a816      	add	r0, sp, #88	; 0x58
    1578:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    157a:	9301      	str	r3, [sp, #4]
    157c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    157e:	9300      	str	r3, [sp, #0]
    1580:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1582:	220a      	movs	r2, #10
    1584:	9920      	ldr	r1, [sp, #128]	; 0x80
    1586:	f7ff fe15 	bl	11b4 <_PrintInt>
        break;
    158a:	e060      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      case 'u':
        v = va_arg(*pParamList, int);
    158c:	9b03      	ldr	r3, [sp, #12]
    158e:	681b      	ldr	r3, [r3, #0]
    1590:	1d19      	adds	r1, r3, #4
    1592:	9a03      	ldr	r2, [sp, #12]
    1594:	6011      	str	r1, [r2, #0]
    1596:	681b      	ldr	r3, [r3, #0]
    1598:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    159a:	9920      	ldr	r1, [sp, #128]	; 0x80
    159c:	a816      	add	r0, sp, #88	; 0x58
    159e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    15a0:	9301      	str	r3, [sp, #4]
    15a2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    15a4:	9300      	str	r3, [sp, #0]
    15a6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    15a8:	220a      	movs	r2, #10
    15aa:	f7ff fd55 	bl	1058 <_PrintUnsigned>
        break;
    15ae:	e04e      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      case 'x':
      case 'X':
        v = va_arg(*pParamList, int);
    15b0:	9b03      	ldr	r3, [sp, #12]
    15b2:	681b      	ldr	r3, [r3, #0]
    15b4:	1d19      	adds	r1, r3, #4
    15b6:	9a03      	ldr	r2, [sp, #12]
    15b8:	6011      	str	r1, [r2, #0]
    15ba:	681b      	ldr	r3, [r3, #0]
    15bc:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    15be:	9920      	ldr	r1, [sp, #128]	; 0x80
    15c0:	a816      	add	r0, sp, #88	; 0x58
    15c2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    15c4:	9301      	str	r3, [sp, #4]
    15c6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    15c8:	9300      	str	r3, [sp, #0]
    15ca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    15cc:	2210      	movs	r2, #16
    15ce:	f7ff fd43 	bl	1058 <_PrintUnsigned>
        break;
    15d2:	e03c      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      case 's':
        {
          const char * s = va_arg(*pParamList, const char *);
    15d4:	9b03      	ldr	r3, [sp, #12]
    15d6:	681b      	ldr	r3, [r3, #0]
    15d8:	1d19      	adds	r1, r3, #4
    15da:	9a03      	ldr	r2, [sp, #12]
    15dc:	6011      	str	r1, [r2, #0]
    15de:	681b      	ldr	r3, [r3, #0]
    15e0:	931c      	str	r3, [sp, #112]	; 0x70
          if (s == NULL) {
    15e2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    15e4:	2b00      	cmp	r3, #0
    15e6:	d101      	bne.n	15ec <SEGGER_RTT_vprintf+0x2ec>
            s = "(NULL)";  // Print (NULL) instead of crashing or breaking, as it is more informative to the user.
    15e8:	4b2c      	ldr	r3, [pc, #176]	; (169c <SEGGER_RTT_vprintf+0x39c>)
    15ea:	931c      	str	r3, [sp, #112]	; 0x70
          }
          do {
            c = *s;
    15ec:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    15ee:	781b      	ldrb	r3, [r3, #0]
    15f0:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
            s++;
    15f4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    15f6:	3301      	adds	r3, #1
    15f8:	931c      	str	r3, [sp, #112]	; 0x70
            if (c == '\0') {
    15fa:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    15fe:	2b00      	cmp	r3, #0
    1600:	d00a      	beq.n	1618 <SEGGER_RTT_vprintf+0x318>
              break;
            }
           _StoreChar(&BufferDesc, c);
    1602:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    1606:	ab16      	add	r3, sp, #88	; 0x58
    1608:	4611      	mov	r1, r2
    160a:	4618      	mov	r0, r3
    160c:	f7ff fce5 	bl	fda <_StoreChar>
          } while (BufferDesc.ReturnValue >= 0);
    1610:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1612:	2b00      	cmp	r3, #0
    1614:	daea      	bge.n	15ec <SEGGER_RTT_vprintf+0x2ec>
        }
        break;
    1616:	e01a      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
              break;
    1618:	bf00      	nop
        break;
    161a:	e018      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      case 'p':
        v = va_arg(*pParamList, int);
    161c:	9b03      	ldr	r3, [sp, #12]
    161e:	681b      	ldr	r3, [r3, #0]
    1620:	1d19      	adds	r1, r3, #4
    1622:	9a03      	ldr	r2, [sp, #12]
    1624:	6011      	str	r1, [r2, #0]
    1626:	681b      	ldr	r3, [r3, #0]
    1628:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    162a:	9920      	ldr	r1, [sp, #128]	; 0x80
    162c:	a816      	add	r0, sp, #88	; 0x58
    162e:	2300      	movs	r3, #0
    1630:	9301      	str	r3, [sp, #4]
    1632:	2308      	movs	r3, #8
    1634:	9300      	str	r3, [sp, #0]
    1636:	2308      	movs	r3, #8
    1638:	2210      	movs	r2, #16
    163a:	f7ff fd0d 	bl	1058 <_PrintUnsigned>
        break;
    163e:	e006      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      case '%':
        _StoreChar(&BufferDesc, '%');
    1640:	ab16      	add	r3, sp, #88	; 0x58
    1642:	2125      	movs	r1, #37	; 0x25
    1644:	4618      	mov	r0, r3
    1646:	f7ff fcc8 	bl	fda <_StoreChar>
        break;
    164a:	e000      	b.n	164e <SEGGER_RTT_vprintf+0x34e>
      default:
        break;
    164c:	bf00      	nop
      }
      sFormat++;
    164e:	9b04      	ldr	r3, [sp, #16]
    1650:	3301      	adds	r3, #1
    1652:	9304      	str	r3, [sp, #16]
    1654:	e006      	b.n	1664 <SEGGER_RTT_vprintf+0x364>
    } else {
      _StoreChar(&BufferDesc, c);
    1656:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    165a:	ab16      	add	r3, sp, #88	; 0x58
    165c:	4611      	mov	r1, r2
    165e:	4618      	mov	r0, r3
    1660:	f7ff fcbb 	bl	fda <_StoreChar>
    }
  } while (BufferDesc.ReturnValue >= 0);
    1664:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1666:	2b00      	cmp	r3, #0
    1668:	f6bf ae59 	bge.w	131e <SEGGER_RTT_vprintf+0x1e>
    166c:	e000      	b.n	1670 <SEGGER_RTT_vprintf+0x370>
      break;
    166e:	bf00      	nop

  if (BufferDesc.ReturnValue > 0) {
    1670:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1672:	2b00      	cmp	r3, #0
    1674:	dd0c      	ble.n	1690 <SEGGER_RTT_vprintf+0x390>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    1676:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1678:	2b00      	cmp	r3, #0
    167a:	d005      	beq.n	1688 <SEGGER_RTT_vprintf+0x388>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    167c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    167e:	ab06      	add	r3, sp, #24
    1680:	4619      	mov	r1, r3
    1682:	9805      	ldr	r0, [sp, #20]
    1684:	f7ff fc7e 	bl	f84 <SEGGER_RTT_Write>
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    1688:	9b19      	ldr	r3, [sp, #100]	; 0x64
    168a:	9a18      	ldr	r2, [sp, #96]	; 0x60
    168c:	4413      	add	r3, r2
    168e:	9319      	str	r3, [sp, #100]	; 0x64
  }
  return BufferDesc.ReturnValue;
    1690:	9b19      	ldr	r3, [sp, #100]	; 0x64
}
    1692:	4618      	mov	r0, r3
    1694:	b023      	add	sp, #140	; 0x8c
    1696:	f85d fb04 	ldr.w	pc, [sp], #4
    169a:	bf00      	nop
    169c:	0000a698 	.word	0x0000a698

000016a0 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    16a0:	b40e      	push	{r1, r2, r3}
    16a2:	b500      	push	{lr}
    16a4:	b084      	sub	sp, #16
    16a6:	9001      	str	r0, [sp, #4]
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    16a8:	ab06      	add	r3, sp, #24
    16aa:	9302      	str	r3, [sp, #8]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    16ac:	ab02      	add	r3, sp, #8
    16ae:	461a      	mov	r2, r3
    16b0:	9905      	ldr	r1, [sp, #20]
    16b2:	9801      	ldr	r0, [sp, #4]
    16b4:	f7ff fe24 	bl	1300 <SEGGER_RTT_vprintf>
    16b8:	9003      	str	r0, [sp, #12]
  va_end(ParamList);
  return r;
    16ba:	9b03      	ldr	r3, [sp, #12]
}
    16bc:	4618      	mov	r0, r3
    16be:	b004      	add	sp, #16
    16c0:	f85d eb04 	ldr.w	lr, [sp], #4
    16c4:	b003      	add	sp, #12
    16c6:	4770      	bx	lr

000016c8 <memcpy>:
    16c8:	440a      	add	r2, r1
    16ca:	4291      	cmp	r1, r2
    16cc:	f100 33ff 	add.w	r3, r0, #4294967295
    16d0:	d100      	bne.n	16d4 <memcpy+0xc>
    16d2:	4770      	bx	lr
    16d4:	b510      	push	{r4, lr}
    16d6:	f811 4b01 	ldrb.w	r4, [r1], #1
    16da:	f803 4f01 	strb.w	r4, [r3, #1]!
    16de:	4291      	cmp	r1, r2
    16e0:	d1f9      	bne.n	16d6 <memcpy+0xe>
    16e2:	bd10      	pop	{r4, pc}

000016e4 <memset>:
    16e4:	4402      	add	r2, r0
    16e6:	4603      	mov	r3, r0
    16e8:	4293      	cmp	r3, r2
    16ea:	d100      	bne.n	16ee <memset+0xa>
    16ec:	4770      	bx	lr
    16ee:	f803 1b01 	strb.w	r1, [r3], #1
    16f2:	e7f9      	b.n	16e8 <memset+0x4>

000016f4 <IntCtrl_Ip_InstallHandlerPrivileged>:
#endif

void IntCtrl_Ip_InstallHandlerPrivileged(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    16f4:	b086      	sub	sp, #24
    16f6:	9003      	str	r0, [sp, #12]
    16f8:	9102      	str	r1, [sp, #8]
    16fa:	9201      	str	r2, [sp, #4]

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber)] = pfNewHandler;
    OsIf_ResumeAllInterrupts();
#else
    IntCtrl_Ip_IrqHandlerType *pVectorRam = (IntCtrl_Ip_IrqHandlerType *)S32_SCB->VTOR;
    16fc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1700:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    1704:	9305      	str	r3, [sp, #20]

    /* Save the former handler pointer */
    if (pfOldHandler != NULL_PTR)
    1706:	9b01      	ldr	r3, [sp, #4]
    1708:	2b00      	cmp	r3, #0
    170a:	d007      	beq.n	171c <IntCtrl_Ip_InstallHandlerPrivileged+0x28>
    {
        *pfOldHandler = (IntCtrl_Ip_IrqHandlerType)pVectorRam[((sint32)eIrqNumber) + 16];
    170c:	9b03      	ldr	r3, [sp, #12]
    170e:	3310      	adds	r3, #16
    1710:	009b      	lsls	r3, r3, #2
    1712:	9a05      	ldr	r2, [sp, #20]
    1714:	4413      	add	r3, r2
    1716:	681a      	ldr	r2, [r3, #0]
    1718:	9b01      	ldr	r3, [sp, #4]
    171a:	601a      	str	r2, [r3, #0]
    }

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber) + 16] = pfNewHandler;
    171c:	9b03      	ldr	r3, [sp, #12]
    171e:	3310      	adds	r3, #16
    1720:	009b      	lsls	r3, r3, #2
    1722:	9a05      	ldr	r2, [sp, #20]
    1724:	4413      	add	r3, r2
    1726:	9a02      	ldr	r2, [sp, #8]
    1728:	601a      	str	r2, [r3, #0]
    S32_SCB->ICIALLU = 0UL;
#endif
    
#endif /* (INT_CTRL_IP_CORTEXR == STD_ON) || (INT_CTRL_IP_CORTEXA == STD_ON) */
/*LDRA_NOANALYSIS*/
    MCAL_INSTRUCTION_SYNC_BARRIER();
    172a:	f3bf 8f6f 	isb	sy
    MCAL_DATA_SYNC_BARRIER();
    172e:	f3bf 8f4f 	dsb	sy
/*LDRA_ANALYSIS*/    
}
    1732:	bf00      	nop
    1734:	b006      	add	sp, #24
    1736:	4770      	bx	lr

00001738 <IntCtrl_Ip_EnableIrqPrivileged>:

void IntCtrl_Ip_EnableIrqPrivileged(IRQn_Type eIrqNumber)
{
    1738:	b082      	sub	sp, #8
    173a:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ISENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ISER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    173c:	9b01      	ldr	r3, [sp, #4]
    173e:	f003 021f 	and.w	r2, r3, #31
    1742:	4905      	ldr	r1, [pc, #20]	; (1758 <IntCtrl_Ip_EnableIrqPrivileged+0x20>)
    1744:	9b01      	ldr	r3, [sp, #4]
    1746:	095b      	lsrs	r3, r3, #5
    1748:	2001      	movs	r0, #1
    174a:	fa00 f202 	lsl.w	r2, r0, r2
    174e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    1752:	bf00      	nop
    1754:	b002      	add	sp, #8
    1756:	4770      	bx	lr
    1758:	e000e100 	.word	0xe000e100

0000175c <IntCtrl_Ip_DisableIrqPrivileged>:

void IntCtrl_Ip_DisableIrqPrivileged(IRQn_Type eIrqNumber)
{
    175c:	b082      	sub	sp, #8
    175e:	9001      	str	r0, [sp, #4]
    {
        S32_GICD->GICD_ICENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ICER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1760:	9b01      	ldr	r3, [sp, #4]
    1762:	f003 021f 	and.w	r2, r3, #31
    1766:	4906      	ldr	r1, [pc, #24]	; (1780 <IntCtrl_Ip_DisableIrqPrivileged+0x24>)
    1768:	9b01      	ldr	r3, [sp, #4]
    176a:	095b      	lsrs	r3, r3, #5
    176c:	2001      	movs	r0, #1
    176e:	fa00 f202 	lsl.w	r2, r0, r2
    1772:	3320      	adds	r3, #32
    1774:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    1778:	bf00      	nop
    177a:	b002      	add	sp, #8
    177c:	4770      	bx	lr
    177e:	bf00      	nop
    1780:	e000e100 	.word	0xe000e100

00001784 <IntCtrl_Ip_SetPriorityPrivileged>:

void IntCtrl_Ip_SetPriorityPrivileged(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1784:	b084      	sub	sp, #16
    1786:	9001      	str	r0, [sp, #4]
    1788:	460b      	mov	r3, r1
    178a:	f88d 3003 	strb.w	r3, [sp, #3]
#endif

#endif /* (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON) */

#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8) (8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    178e:	2304      	movs	r3, #4
    1790:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Set Priority for device specific Interrupts */
        S32_NVIC->IP[(uint32)(eIrqNumber)] = (uint8)((((uint32)u8Priority) << shift) & 0xFFUL);
    1794:	f89d 2003 	ldrb.w	r2, [sp, #3]
    1798:	f89d 300f 	ldrb.w	r3, [sp, #15]
    179c:	fa02 f103 	lsl.w	r1, r2, r3
    17a0:	4a04      	ldr	r2, [pc, #16]	; (17b4 <IntCtrl_Ip_SetPriorityPrivileged+0x30>)
    17a2:	9b01      	ldr	r3, [sp, #4]
    17a4:	b2c9      	uxtb	r1, r1
    17a6:	4413      	add	r3, r2
    17a8:	460a      	mov	r2, r1
    17aa:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] &= ~(0xFFUL << priByteShift);
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] |= ((uint32)(((((uint32)u8Priority) << shift_gic)) & 0xFFUL)) << priByteShift;
        }
    #endif
#endif
}
    17ae:	bf00      	nop
    17b0:	b004      	add	sp, #16
    17b2:	4770      	bx	lr
    17b4:	e000e100 	.word	0xe000e100

000017b8 <IntCtrl_Ip_GetPriorityPrivileged>:

uint8 IntCtrl_Ip_GetPriorityPrivileged(IRQn_Type eIrqNumber)
{
    17b8:	b084      	sub	sp, #16
    17ba:	9001      	str	r0, [sp, #4]

    uint8 priority;


#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8)(8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    17bc:	2304      	movs	r3, #4
    17be:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Get Priority for device specific Interrupts  */
        priority = (uint8)(S32_NVIC->IP[(uint32)(eIrqNumber)] >> shift);
    17c2:	4a09      	ldr	r2, [pc, #36]	; (17e8 <IntCtrl_Ip_GetPriorityPrivileged+0x30>)
    17c4:	9b01      	ldr	r3, [sp, #4]
    17c6:	4413      	add	r3, r2
    17c8:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
    17cc:	b2db      	uxtb	r3, r3
    17ce:	461a      	mov	r2, r3
    17d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    17d4:	fa42 f303 	asr.w	r3, r2, r3
    17d8:	f88d 300e 	strb.w	r3, [sp, #14]
            uint8 priByteShift = (uint8)((((uint8)(eIrqNumber)) & 0x3U) << 3U);
            priority = ((uint8)(IP_GIC500->GICD.IPRIORITYR[iprVectorId] >> priByteShift)) >> shift_gic;
        }
    #endif
#endif
    return priority;
    17dc:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    17e0:	4618      	mov	r0, r3
    17e2:	b004      	add	sp, #16
    17e4:	4770      	bx	lr
    17e6:	bf00      	nop
    17e8:	e000e100 	.word	0xe000e100

000017ec <IntCtrl_Ip_ClearPendingPrivileged>:

void IntCtrl_Ip_ClearPendingPrivileged(IRQn_Type eIrqNumber)
{
    17ec:	b082      	sub	sp, #8
    17ee:	9001      	str	r0, [sp, #4]
    }
#endif

#else
    /* Clear Pending Interrupt */
    S32_NVIC->ICPR[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    17f0:	9b01      	ldr	r3, [sp, #4]
    17f2:	f003 021f 	and.w	r2, r3, #31
    17f6:	4906      	ldr	r1, [pc, #24]	; (1810 <IntCtrl_Ip_ClearPendingPrivileged+0x24>)
    17f8:	9b01      	ldr	r3, [sp, #4]
    17fa:	095b      	lsrs	r3, r3, #5
    17fc:	2001      	movs	r0, #1
    17fe:	fa00 f202 	lsl.w	r2, r0, r2
    1802:	3360      	adds	r3, #96	; 0x60
    1804:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
    1808:	bf00      	nop
    180a:	b002      	add	sp, #8
    180c:	4770      	bx	lr
    180e:	bf00      	nop
    1810:	e000e100 	.word	0xe000e100

00001814 <IntCtrl_Ip_Init>:
 * @internal
 * @brief         Initializes the configured interrupts at interrupt controller level.
 * @implements    IntCtrl_Ip_Init_Activity
 */
IntCtrl_Ip_StatusType IntCtrl_Ip_Init(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1814:	b500      	push	{lr}
    1816:	b085      	sub	sp, #20
    1818:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(pIntCtrlCtrlConfig != NULL_PTR);
    DevAssert(pIntCtrlCtrlConfig->u32ConfigIrqCount <= INT_CTRL_IP_IRQ_COUNT);
#endif
    uint32 irqIdx;
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    181a:	2300      	movs	r3, #0
    181c:	9303      	str	r3, [sp, #12]
    181e:	e05d      	b.n	18dc <IntCtrl_Ip_Init+0xc8>
    {
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1820:	9b01      	ldr	r3, [sp, #4]
    1822:	6859      	ldr	r1, [r3, #4]
    1824:	9a03      	ldr	r2, [sp, #12]
    1826:	4613      	mov	r3, r2
    1828:	005b      	lsls	r3, r3, #1
    182a:	4413      	add	r3, r2
    182c:	009b      	lsls	r3, r3, #2
    182e:	440b      	add	r3, r1
    1830:	681b      	ldr	r3, [r3, #0]
    1832:	4618      	mov	r0, r3
    1834:	f000 f899 	bl	196a <IntCtrl_Ip_ClearPending>
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1838:	9b01      	ldr	r3, [sp, #4]
    183a:	6859      	ldr	r1, [r3, #4]
    183c:	9a03      	ldr	r2, [sp, #12]
    183e:	4613      	mov	r3, r2
    1840:	005b      	lsls	r3, r3, #1
    1842:	4413      	add	r3, r2
    1844:	009b      	lsls	r3, r3, #2
    1846:	440b      	add	r3, r1
    1848:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    184a:	9b01      	ldr	r3, [sp, #4]
    184c:	6859      	ldr	r1, [r3, #4]
    184e:	9a03      	ldr	r2, [sp, #12]
    1850:	4613      	mov	r3, r2
    1852:	005b      	lsls	r3, r3, #1
    1854:	4413      	add	r3, r2
    1856:	009b      	lsls	r3, r3, #2
    1858:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    185a:	795b      	ldrb	r3, [r3, #5]
    185c:	4619      	mov	r1, r3
    185e:	f000 f869 	bl	1934 <IntCtrl_Ip_SetPriority>

        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1862:	9b01      	ldr	r3, [sp, #4]
    1864:	6859      	ldr	r1, [r3, #4]
    1866:	9a03      	ldr	r2, [sp, #12]
    1868:	4613      	mov	r3, r2
    186a:	005b      	lsls	r3, r3, #1
    186c:	4413      	add	r3, r2
    186e:	009b      	lsls	r3, r3, #2
    1870:	440b      	add	r3, r1
    1872:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1874:	9b01      	ldr	r3, [sp, #4]
    1876:	6859      	ldr	r1, [r3, #4]
    1878:	9a03      	ldr	r2, [sp, #12]
    187a:	4613      	mov	r3, r2
    187c:	005b      	lsls	r3, r3, #1
    187e:	4413      	add	r3, r2
    1880:	009b      	lsls	r3, r3, #2
    1882:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1884:	689b      	ldr	r3, [r3, #8]
    1886:	2200      	movs	r2, #0
    1888:	4619      	mov	r1, r3
    188a:	f000 f831 	bl	18f0 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    188e:	9b01      	ldr	r3, [sp, #4]
    1890:	6859      	ldr	r1, [r3, #4]
    1892:	9a03      	ldr	r2, [sp, #12]
    1894:	4613      	mov	r3, r2
    1896:	005b      	lsls	r3, r3, #1
    1898:	4413      	add	r3, r2
    189a:	009b      	lsls	r3, r3, #2
    189c:	440b      	add	r3, r1
    189e:	791b      	ldrb	r3, [r3, #4]
    18a0:	2b00      	cmp	r3, #0
    18a2:	d00c      	beq.n	18be <IntCtrl_Ip_Init+0xaa>
        {
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    18a4:	9b01      	ldr	r3, [sp, #4]
    18a6:	6859      	ldr	r1, [r3, #4]
    18a8:	9a03      	ldr	r2, [sp, #12]
    18aa:	4613      	mov	r3, r2
    18ac:	005b      	lsls	r3, r3, #1
    18ae:	4413      	add	r3, r2
    18b0:	009b      	lsls	r3, r3, #2
    18b2:	440b      	add	r3, r1
    18b4:	681b      	ldr	r3, [r3, #0]
    18b6:	4618      	mov	r0, r3
    18b8:	f000 f828 	bl	190c <IntCtrl_Ip_EnableIrq>
    18bc:	e00b      	b.n	18d6 <IntCtrl_Ip_Init+0xc2>
        }
        else
        {
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    18be:	9b01      	ldr	r3, [sp, #4]
    18c0:	6859      	ldr	r1, [r3, #4]
    18c2:	9a03      	ldr	r2, [sp, #12]
    18c4:	4613      	mov	r3, r2
    18c6:	005b      	lsls	r3, r3, #1
    18c8:	4413      	add	r3, r2
    18ca:	009b      	lsls	r3, r3, #2
    18cc:	440b      	add	r3, r1
    18ce:	681b      	ldr	r3, [r3, #0]
    18d0:	4618      	mov	r0, r3
    18d2:	f000 f825 	bl	1920 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    18d6:	9b03      	ldr	r3, [sp, #12]
    18d8:	3301      	adds	r3, #1
    18da:	9303      	str	r3, [sp, #12]
    18dc:	9b01      	ldr	r3, [sp, #4]
    18de:	681b      	ldr	r3, [r3, #0]
    18e0:	9a03      	ldr	r2, [sp, #12]
    18e2:	429a      	cmp	r2, r3
    18e4:	d39c      	bcc.n	1820 <IntCtrl_Ip_Init+0xc>
        }
    }

    return INTCTRL_IP_STATUS_SUCCESS;
    18e6:	2300      	movs	r3, #0
}
    18e8:	4618      	mov	r0, r3
    18ea:	b005      	add	sp, #20
    18ec:	f85d fb04 	ldr.w	pc, [sp], #4

000018f0 <IntCtrl_Ip_InstallHandler>:
 * @implements    IntCtrl_Ip_InstallHandler_Activity
 */
void IntCtrl_Ip_InstallHandler(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    18f0:	b500      	push	{lr}
    18f2:	b085      	sub	sp, #20
    18f4:	9003      	str	r0, [sp, #12]
    18f6:	9102      	str	r1, [sp, #8]
    18f8:	9201      	str	r2, [sp, #4]
    Call_IntCtrl_Ip_InstallHandlerPrivileged(eIrqNumber,pfNewHandler,pfOldHandler);
    18fa:	9a01      	ldr	r2, [sp, #4]
    18fc:	9902      	ldr	r1, [sp, #8]
    18fe:	9803      	ldr	r0, [sp, #12]
    1900:	f7ff fef8 	bl	16f4 <IntCtrl_Ip_InstallHandlerPrivileged>
}
    1904:	bf00      	nop
    1906:	b005      	add	sp, #20
    1908:	f85d fb04 	ldr.w	pc, [sp], #4

0000190c <IntCtrl_Ip_EnableIrq>:
 * @internal
 * @brief         Enables an interrupt request.
 * @implements    IntCtrl_Ip_EnableIrq_Activity
 */
void IntCtrl_Ip_EnableIrq(IRQn_Type eIrqNumber)
{
    190c:	b500      	push	{lr}
    190e:	b083      	sub	sp, #12
    1910:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_EnableIrqPrivileged(eIrqNumber);
    1912:	9801      	ldr	r0, [sp, #4]
    1914:	f7ff ff10 	bl	1738 <IntCtrl_Ip_EnableIrqPrivileged>
}
    1918:	bf00      	nop
    191a:	b003      	add	sp, #12
    191c:	f85d fb04 	ldr.w	pc, [sp], #4

00001920 <IntCtrl_Ip_DisableIrq>:
 * @internal
 * @brief         Disables an interrupt request.
 * @implements    IntCtrl_Ip_DisableIrq_Activity
 */
void IntCtrl_Ip_DisableIrq(IRQn_Type eIrqNumber)
{
    1920:	b500      	push	{lr}
    1922:	b083      	sub	sp, #12
    1924:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_DisableIrqPrivileged(eIrqNumber);
    1926:	9801      	ldr	r0, [sp, #4]
    1928:	f7ff ff18 	bl	175c <IntCtrl_Ip_DisableIrqPrivileged>
}
    192c:	bf00      	nop
    192e:	b003      	add	sp, #12
    1930:	f85d fb04 	ldr.w	pc, [sp], #4

00001934 <IntCtrl_Ip_SetPriority>:
 * @internal
 * @brief         Sets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_SetPriority_Activity
 */
void IntCtrl_Ip_SetPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1934:	b500      	push	{lr}
    1936:	b083      	sub	sp, #12
    1938:	9001      	str	r0, [sp, #4]
    193a:	460b      	mov	r3, r1
    193c:	f88d 3003 	strb.w	r3, [sp, #3]
    Call_IntCtrl_Ip_SetPriorityPrivileged(eIrqNumber,u8Priority);
    1940:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1944:	4619      	mov	r1, r3
    1946:	9801      	ldr	r0, [sp, #4]
    1948:	f7ff ff1c 	bl	1784 <IntCtrl_Ip_SetPriorityPrivileged>
}
    194c:	bf00      	nop
    194e:	b003      	add	sp, #12
    1950:	f85d fb04 	ldr.w	pc, [sp], #4

00001954 <IntCtrl_Ip_GetPriority>:
 * @internal
 * @brief         Gets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_GetPriority_Activity
 */
uint8 IntCtrl_Ip_GetPriority(IRQn_Type eIrqNumber)
{
    1954:	b500      	push	{lr}
    1956:	b083      	sub	sp, #12
    1958:	9001      	str	r0, [sp, #4]
    return (uint8)Call_IntCtrl_Ip_GetPriorityPrivileged(eIrqNumber);
    195a:	9801      	ldr	r0, [sp, #4]
    195c:	f7ff ff2c 	bl	17b8 <IntCtrl_Ip_GetPriorityPrivileged>
    1960:	4603      	mov	r3, r0
}
    1962:	4618      	mov	r0, r3
    1964:	b003      	add	sp, #12
    1966:	f85d fb04 	ldr.w	pc, [sp], #4

0000196a <IntCtrl_Ip_ClearPending>:
 * @internal
 * @brief         Clears the pending flag for an interrupt request.
 * @implements    IntCtrl_Ip_ClearPending_Activity
 */
void IntCtrl_Ip_ClearPending(IRQn_Type eIrqNumber)
{
    196a:	b500      	push	{lr}
    196c:	b083      	sub	sp, #12
    196e:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_ClearPendingPrivileged(eIrqNumber);
    1970:	9801      	ldr	r0, [sp, #4]
    1972:	f7ff ff3b 	bl	17ec <IntCtrl_Ip_ClearPendingPrivileged>
}
    1976:	bf00      	nop
    1978:	b003      	add	sp, #12
    197a:	f85d fb04 	ldr.w	pc, [sp], #4
    197e:	bf00      	nop

00001980 <Platform_Ipw_SetIrq>:
/**
 * @internal
 * @brief         Enables/disables an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1980:	b500      	push	{lr}
    1982:	b083      	sub	sp, #12
    1984:	9001      	str	r0, [sp, #4]
    1986:	460b      	mov	r3, r1
    1988:	f88d 3003 	strb.w	r3, [sp, #3]
    if (bEnable)
    198c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1990:	2b00      	cmp	r3, #0
    1992:	d003      	beq.n	199c <Platform_Ipw_SetIrq+0x1c>
    {
        IntCtrl_Ip_EnableIrq(eIrqNumber);
    1994:	9801      	ldr	r0, [sp, #4]
    1996:	f7ff ffb9 	bl	190c <IntCtrl_Ip_EnableIrq>
    }
    else
    {
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    }
}
    199a:	e002      	b.n	19a2 <Platform_Ipw_SetIrq+0x22>
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    199c:	9801      	ldr	r0, [sp, #4]
    199e:	f7ff ffbf 	bl	1920 <IntCtrl_Ip_DisableIrq>
}
    19a2:	bf00      	nop
    19a4:	b003      	add	sp, #12
    19a6:	f85d fb04 	ldr.w	pc, [sp], #4

000019aa <Platform_Ipw_SetIrqPriority>:
/**
 * @internal
 * @brief         Sets the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    19aa:	b500      	push	{lr}
    19ac:	b083      	sub	sp, #12
    19ae:	9001      	str	r0, [sp, #4]
    19b0:	460b      	mov	r3, r1
    19b2:	f88d 3003 	strb.w	r3, [sp, #3]
    IntCtrl_Ip_SetPriority(eIrqNumber, u8Priority);
    19b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    19ba:	4619      	mov	r1, r3
    19bc:	9801      	ldr	r0, [sp, #4]
    19be:	f7ff ffb9 	bl	1934 <IntCtrl_Ip_SetPriority>
}
    19c2:	bf00      	nop
    19c4:	b003      	add	sp, #12
    19c6:	f85d fb04 	ldr.w	pc, [sp], #4

000019ca <Platform_Ipw_GetIrqPriority>:
/**
 * @internal
 * @brief         Returns the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline uint8 Platform_Ipw_GetIrqPriority(IRQn_Type eIrqNumber)
{
    19ca:	b500      	push	{lr}
    19cc:	b083      	sub	sp, #12
    19ce:	9001      	str	r0, [sp, #4]
    return IntCtrl_Ip_GetPriority(eIrqNumber);
    19d0:	9801      	ldr	r0, [sp, #4]
    19d2:	f7ff ffbf 	bl	1954 <IntCtrl_Ip_GetPriority>
    19d6:	4603      	mov	r3, r0
}
    19d8:	4618      	mov	r0, r3
    19da:	b003      	add	sp, #12
    19dc:	f85d fb04 	ldr.w	pc, [sp], #4

000019e0 <Platform_Ipw_InstallIrqHandler>:
 * @brief         Installs a new interrupt handler by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_InstallIrqHandler(IRQn_Type eIrqNumber,
                                                  const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                                                  IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    19e0:	b500      	push	{lr}
    19e2:	b085      	sub	sp, #20
    19e4:	9003      	str	r0, [sp, #12]
    19e6:	9102      	str	r1, [sp, #8]
    19e8:	9201      	str	r2, [sp, #4]
    IntCtrl_Ip_InstallHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    19ea:	9a01      	ldr	r2, [sp, #4]
    19ec:	9902      	ldr	r1, [sp, #8]
    19ee:	9803      	ldr	r0, [sp, #12]
    19f0:	f7ff ff7e 	bl	18f0 <IntCtrl_Ip_InstallHandler>
}
    19f4:	bf00      	nop
    19f6:	b005      	add	sp, #20
    19f8:	f85d fb04 	ldr.w	pc, [sp], #4

000019fc <Platform_Init>:
 * @internal
 * @brief         Initializes the platform settings based on user configuration.
 * @implements    Platform_Init_Activity
 */
void Platform_Init(const Platform_ConfigType *pConfig)
{
    19fc:	b500      	push	{lr}
    19fe:	b085      	sub	sp, #20
    1a00:	9001      	str	r0, [sp, #4]
    uint8 u8CoreId;

    u8CoreId = (uint8)Platform_GetCoreID();
    1a02:	2300      	movs	r3, #0
    1a04:	f88d 300f 	strb.w	r3, [sp, #15]
        {
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
#endif /*(PLATFORM_DEV_ERROR_DETECT == STD_ON)*/


            Platform_Ipw_Init(Platform_Config[u8CoreId]->pIpwConfig);
    1a08:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1a0c:	4a05      	ldr	r2, [pc, #20]	; (1a24 <Platform_Init+0x28>)
    1a0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1a12:	681b      	ldr	r3, [r3, #0]
    1a14:	4618      	mov	r0, r3
    1a16:	f000 f8c7 	bl	1ba8 <Platform_Ipw_Init>
        }
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
    }
#endif /* (PLATFORM_DEV_ERROR_DETECT == STD_ON)*/

}
    1a1a:	bf00      	nop
    1a1c:	b005      	add	sp, #20
    1a1e:	f85d fb04 	ldr.w	pc, [sp], #4
    1a22:	bf00      	nop
    1a24:	0000b2b4 	.word	0x0000b2b4

00001a28 <Platform_SetIrq>:
 * @internal
 * @brief         Configures (enables/disables) an interrupt request.
 * @implements    Platform_SetIrq_Activity
 */
Std_ReturnType Platform_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1a28:	b500      	push	{lr}
    1a2a:	b085      	sub	sp, #20
    1a2c:	9001      	str	r0, [sp, #4]
    1a2e:	460b      	mov	r3, r1
    1a30:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1a34:	2300      	movs	r3, #0
    1a36:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrq(eIrqNumber, bEnable);
    1a3a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a3e:	4619      	mov	r1, r3
    1a40:	9801      	ldr	r0, [sp, #4]
    1a42:	f7ff ff9d 	bl	1980 <Platform_Ipw_SetIrq>
    }
    return RetValue;
    1a46:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1a4a:	4618      	mov	r0, r3
    1a4c:	b005      	add	sp, #20
    1a4e:	f85d fb04 	ldr.w	pc, [sp], #4

00001a52 <Platform_SetIrqPriority>:
 * @internal
 * @brief         Configures the priority of an interrupt request.
 * @implements    Platform_SetIrqPriority_Activity
 */
Std_ReturnType Platform_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1a52:	b500      	push	{lr}
    1a54:	b085      	sub	sp, #20
    1a56:	9001      	str	r0, [sp, #4]
    1a58:	460b      	mov	r3, r1
    1a5a:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1a5e:	2300      	movs	r3, #0
    1a60:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_SetIrqPriority(eIrqNumber, u8Priority);
    1a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a68:	4619      	mov	r1, r3
    1a6a:	9801      	ldr	r0, [sp, #4]
    1a6c:	f7ff ff9d 	bl	19aa <Platform_Ipw_SetIrqPriority>
    }
    return RetValue;
    1a70:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1a74:	4618      	mov	r0, r3
    1a76:	b005      	add	sp, #20
    1a78:	f85d fb04 	ldr.w	pc, [sp], #4

00001a7c <Platform_GetIrqPriority>:
 * @internal
 * @brief         Returns the priority of an interrupt request.
 * @implements    Platform_GetIrqPriority_Activity
 */
Std_ReturnType Platform_GetIrqPriority(IRQn_Type eIrqNumber, uint8 * u8Priority)
{
    1a7c:	b500      	push	{lr}
    1a7e:	b085      	sub	sp, #20
    1a80:	9001      	str	r0, [sp, #4]
    1a82:	9100      	str	r1, [sp, #0]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1a84:	2300      	movs	r3, #0
    1a86:	f88d 300f 	strb.w	r3, [sp, #15]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        *u8Priority = Platform_Ipw_GetIrqPriority(eIrqNumber);
    1a8a:	9801      	ldr	r0, [sp, #4]
    1a8c:	f7ff ff9d 	bl	19ca <Platform_Ipw_GetIrqPriority>
    1a90:	4603      	mov	r3, r0
    1a92:	461a      	mov	r2, r3
    1a94:	9b00      	ldr	r3, [sp, #0]
    1a96:	701a      	strb	r2, [r3, #0]
    }

    return RetValue;
    1a98:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1a9c:	4618      	mov	r0, r3
    1a9e:	b005      	add	sp, #20
    1aa0:	f85d fb04 	ldr.w	pc, [sp], #4

00001aa4 <Platform_InstallIrqHandler>:
 * @implements    Platform_InstallIrqHandler_Activity
 */
Std_ReturnType Platform_InstallIrqHandler(IRQn_Type eIrqNumber,
                                          const Platform_IrqHandlerType pfNewHandler,
                                          Platform_IrqHandlerType* const pfOldHandler)
{
    1aa4:	b500      	push	{lr}
    1aa6:	b087      	sub	sp, #28
    1aa8:	9003      	str	r0, [sp, #12]
    1aaa:	9102      	str	r1, [sp, #8]
    1aac:	9201      	str	r2, [sp, #4]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1aae:	2300      	movs	r3, #0
    1ab0:	f88d 3017 	strb.w	r3, [sp, #23]
        RetValue = (Std_ReturnType)E_NOT_OK;
    }
    else
#endif
    {
        Platform_Ipw_InstallIrqHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1ab4:	9a01      	ldr	r2, [sp, #4]
    1ab6:	9902      	ldr	r1, [sp, #8]
    1ab8:	9803      	ldr	r0, [sp, #12]
    1aba:	f7ff ff91 	bl	19e0 <Platform_Ipw_InstallIrqHandler>
    }
    return RetValue;
    1abe:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    1ac2:	4618      	mov	r0, r3
    1ac4:	b007      	add	sp, #28
    1ac6:	f85d fb04 	ldr.w	pc, [sp], #4
    1aca:	bf00      	nop

00001acc <Platform_Ipw_InitIntCtrl>:
#endif



static Std_ReturnType Platform_Ipw_InitIntCtrl(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1acc:	b500      	push	{lr}
    1ace:	b085      	sub	sp, #20
    1ad0:	9001      	str	r0, [sp, #4]
    uint32 irqIdx;
    
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1ad2:	2300      	movs	r3, #0
    1ad4:	9303      	str	r3, [sp, #12]
    1ad6:	e05d      	b.n	1b94 <Platform_Ipw_InitIntCtrl+0xc8>
    {   
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1ad8:	9b01      	ldr	r3, [sp, #4]
    1ada:	6859      	ldr	r1, [r3, #4]
    1adc:	9a03      	ldr	r2, [sp, #12]
    1ade:	4613      	mov	r3, r2
    1ae0:	005b      	lsls	r3, r3, #1
    1ae2:	4413      	add	r3, r2
    1ae4:	009b      	lsls	r3, r3, #2
    1ae6:	440b      	add	r3, r1
    1ae8:	681b      	ldr	r3, [r3, #0]
    1aea:	4618      	mov	r0, r3
    1aec:	f7ff ff3d 	bl	196a <IntCtrl_Ip_ClearPending>
        /* interrupt number for which the priority is set */
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1af0:	9b01      	ldr	r3, [sp, #4]
    1af2:	6859      	ldr	r1, [r3, #4]
    1af4:	9a03      	ldr	r2, [sp, #12]
    1af6:	4613      	mov	r3, r2
    1af8:	005b      	lsls	r3, r3, #1
    1afa:	4413      	add	r3, r2
    1afc:	009b      	lsls	r3, r3, #2
    1afe:	440b      	add	r3, r1
    1b00:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1b02:	9b01      	ldr	r3, [sp, #4]
    1b04:	6859      	ldr	r1, [r3, #4]
    1b06:	9a03      	ldr	r2, [sp, #12]
    1b08:	4613      	mov	r3, r2
    1b0a:	005b      	lsls	r3, r3, #1
    1b0c:	4413      	add	r3, r2
    1b0e:	009b      	lsls	r3, r3, #2
    1b10:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1b12:	795b      	ldrb	r3, [r3, #5]
    1b14:	4619      	mov	r1, r3
    1b16:	f7ff ff0d 	bl	1934 <IntCtrl_Ip_SetPriority>
        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1b1a:	9b01      	ldr	r3, [sp, #4]
    1b1c:	6859      	ldr	r1, [r3, #4]
    1b1e:	9a03      	ldr	r2, [sp, #12]
    1b20:	4613      	mov	r3, r2
    1b22:	005b      	lsls	r3, r3, #1
    1b24:	4413      	add	r3, r2
    1b26:	009b      	lsls	r3, r3, #2
    1b28:	440b      	add	r3, r1
    1b2a:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1b2c:	9b01      	ldr	r3, [sp, #4]
    1b2e:	6859      	ldr	r1, [r3, #4]
    1b30:	9a03      	ldr	r2, [sp, #12]
    1b32:	4613      	mov	r3, r2
    1b34:	005b      	lsls	r3, r3, #1
    1b36:	4413      	add	r3, r2
    1b38:	009b      	lsls	r3, r3, #2
    1b3a:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1b3c:	689b      	ldr	r3, [r3, #8]
    1b3e:	2200      	movs	r2, #0
    1b40:	4619      	mov	r1, r3
    1b42:	f7ff fed5 	bl	18f0 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        /* Enable interrupt */                       
        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1b46:	9b01      	ldr	r3, [sp, #4]
    1b48:	6859      	ldr	r1, [r3, #4]
    1b4a:	9a03      	ldr	r2, [sp, #12]
    1b4c:	4613      	mov	r3, r2
    1b4e:	005b      	lsls	r3, r3, #1
    1b50:	4413      	add	r3, r2
    1b52:	009b      	lsls	r3, r3, #2
    1b54:	440b      	add	r3, r1
    1b56:	791b      	ldrb	r3, [r3, #4]
    1b58:	2b00      	cmp	r3, #0
    1b5a:	d00c      	beq.n	1b76 <Platform_Ipw_InitIntCtrl+0xaa>
        {   
            /* enables the interrupt request at interrupt controller level. */
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1b5c:	9b01      	ldr	r3, [sp, #4]
    1b5e:	6859      	ldr	r1, [r3, #4]
    1b60:	9a03      	ldr	r2, [sp, #12]
    1b62:	4613      	mov	r3, r2
    1b64:	005b      	lsls	r3, r3, #1
    1b66:	4413      	add	r3, r2
    1b68:	009b      	lsls	r3, r3, #2
    1b6a:	440b      	add	r3, r1
    1b6c:	681b      	ldr	r3, [r3, #0]
    1b6e:	4618      	mov	r0, r3
    1b70:	f7ff fecc 	bl	190c <IntCtrl_Ip_EnableIrq>
    1b74:	e00b      	b.n	1b8e <Platform_Ipw_InitIntCtrl+0xc2>
        }
        else
        {   
            /* disables the interrupt request at interrupt controller level.*/
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1b76:	9b01      	ldr	r3, [sp, #4]
    1b78:	6859      	ldr	r1, [r3, #4]
    1b7a:	9a03      	ldr	r2, [sp, #12]
    1b7c:	4613      	mov	r3, r2
    1b7e:	005b      	lsls	r3, r3, #1
    1b80:	4413      	add	r3, r2
    1b82:	009b      	lsls	r3, r3, #2
    1b84:	440b      	add	r3, r1
    1b86:	681b      	ldr	r3, [r3, #0]
    1b88:	4618      	mov	r0, r3
    1b8a:	f7ff fec9 	bl	1920 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1b8e:	9b03      	ldr	r3, [sp, #12]
    1b90:	3301      	adds	r3, #1
    1b92:	9303      	str	r3, [sp, #12]
    1b94:	9b01      	ldr	r3, [sp, #4]
    1b96:	681b      	ldr	r3, [r3, #0]
    1b98:	9a03      	ldr	r2, [sp, #12]
    1b9a:	429a      	cmp	r2, r3
    1b9c:	d39c      	bcc.n	1ad8 <Platform_Ipw_InitIntCtrl+0xc>
        }
    }

    return E_OK;
    1b9e:	2300      	movs	r3, #0
}
    1ba0:	4618      	mov	r0, r3
    1ba2:	b005      	add	sp, #20
    1ba4:	f85d fb04 	ldr.w	pc, [sp], #4

00001ba8 <Platform_Ipw_Init>:

/**
 * @brief         Initializes the platform settings based on user configuration.
 */
void Platform_Ipw_Init(const Platform_Ipw_ConfigType *pConfig)
{    
    1ba8:	b500      	push	{lr}
    1baa:	b085      	sub	sp, #20
    1bac:	9001      	str	r0, [sp, #4]
#if ((PLATFORM_SYS_CFG == STD_ON)&&(INT_CTRL_IP_CORTEXM == STD_ON))
    uint8 irqIdx;
#endif
    Std_ReturnType ret = (Std_ReturnType)E_OK;
    1bae:	2300      	movs	r3, #0
    1bb0:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Initialize interrupts at interrupt controller level */
    if (NULL_PTR != pConfig->pIntCtrlConfig)
    1bb4:	9b01      	ldr	r3, [sp, #4]
    1bb6:	681b      	ldr	r3, [r3, #0]
    1bb8:	2b00      	cmp	r3, #0
    1bba:	d007      	beq.n	1bcc <Platform_Ipw_Init+0x24>
    {
        ret = Platform_Ipw_InitIntCtrl(pConfig->pIntCtrlConfig);
    1bbc:	9b01      	ldr	r3, [sp, #4]
    1bbe:	681b      	ldr	r3, [r3, #0]
    1bc0:	4618      	mov	r0, r3
    1bc2:	f7ff ff83 	bl	1acc <Platform_Ipw_InitIntCtrl>
    1bc6:	4603      	mov	r3, r0
    1bc8:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    if(ret == (Std_ReturnType)E_OK)
    1bcc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1bd0:	2b00      	cmp	r3, #0
            /* Call_System_Ip_SetAhbSlavePriority((pConfig->aSystemConfig)->bAhbSlavePriority); */
#endif
        }  
#endif
    }
}
    1bd2:	bf00      	nop
    1bd4:	b005      	add	sp, #20
    1bd6:	f85d fb04 	ldr.w	pc, [sp], #4

00001bda <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
    1bda:	2300      	movs	r3, #0
}
    1bdc:	4618      	mov	r0, r3
    1bde:	4770      	bx	lr

00001be0 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    1be0:	b082      	sub	sp, #8
    1be2:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    1be4:	2301      	movs	r3, #1
}
    1be6:	4618      	mov	r0, r3
    1be8:	b002      	add	sp, #8
    1bea:	4770      	bx	lr

00001bec <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    1bec:	b082      	sub	sp, #8
    1bee:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    1bf0:	bf00      	nop
    1bf2:	b002      	add	sp, #8
    1bf4:	4770      	bx	lr

00001bf6 <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    1bf6:	b082      	sub	sp, #8
    1bf8:	9001      	str	r0, [sp, #4]
    return Micros;
    1bfa:	9b01      	ldr	r3, [sp, #4]
}
    1bfc:	4618      	mov	r0, r3
    1bfe:	b002      	add	sp, #8
    1c00:	4770      	bx	lr

00001c02 <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    1c02:	b500      	push	{lr}
    1c04:	b083      	sub	sp, #12
    1c06:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    1c08:	f000 f86c 	bl	1ce4 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    1c0c:	bf00      	nop
    1c0e:	b003      	add	sp, #12
    1c10:	f85d fb04 	ldr.w	pc, [sp], #4

00001c14 <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    1c14:	b500      	push	{lr}
    1c16:	b085      	sub	sp, #20
    1c18:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    1c1a:	2300      	movs	r3, #0
    1c1c:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1c1e:	9b01      	ldr	r3, [sp, #4]
    1c20:	2b00      	cmp	r3, #0
    1c22:	d003      	beq.n	1c2c <OsIf_GetCounter+0x18>
    1c24:	9b01      	ldr	r3, [sp, #4]
    1c26:	2b01      	cmp	r3, #1
    1c28:	d004      	beq.n	1c34 <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1c2a:	e007      	b.n	1c3c <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    1c2c:	f7ff ffd5 	bl	1bda <OsIf_Timer_Dummy_GetCounter>
    1c30:	9003      	str	r0, [sp, #12]
            break;
    1c32:	e003      	b.n	1c3c <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    1c34:	f000 f872 	bl	1d1c <OsIf_Timer_System_GetCounter>
    1c38:	9003      	str	r0, [sp, #12]
            break;
    1c3a:	bf00      	nop
    }

    return Value;
    1c3c:	9b03      	ldr	r3, [sp, #12]
}
    1c3e:	4618      	mov	r0, r3
    1c40:	b005      	add	sp, #20
    1c42:	f85d fb04 	ldr.w	pc, [sp], #4

00001c46 <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    1c46:	b500      	push	{lr}
    1c48:	b085      	sub	sp, #20
    1c4a:	9001      	str	r0, [sp, #4]
    1c4c:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1c4e:	2300      	movs	r3, #0
    1c50:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1c52:	9b00      	ldr	r3, [sp, #0]
    1c54:	2b00      	cmp	r3, #0
    1c56:	d003      	beq.n	1c60 <OsIf_GetElapsed+0x1a>
    1c58:	9b00      	ldr	r3, [sp, #0]
    1c5a:	2b01      	cmp	r3, #1
    1c5c:	d005      	beq.n	1c6a <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1c5e:	e009      	b.n	1c74 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    1c60:	9801      	ldr	r0, [sp, #4]
    1c62:	f7ff ffbd 	bl	1be0 <OsIf_Timer_Dummy_GetElapsed>
    1c66:	9003      	str	r0, [sp, #12]
            break;
    1c68:	e004      	b.n	1c74 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    1c6a:	9801      	ldr	r0, [sp, #4]
    1c6c:	f000 f864 	bl	1d38 <OsIf_Timer_System_GetElapsed>
    1c70:	9003      	str	r0, [sp, #12]
            break;
    1c72:	bf00      	nop
    }

    return Value;
    1c74:	9b03      	ldr	r3, [sp, #12]
}
    1c76:	4618      	mov	r0, r3
    1c78:	b005      	add	sp, #20
    1c7a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c7e <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    1c7e:	b500      	push	{lr}
    1c80:	b083      	sub	sp, #12
    1c82:	9001      	str	r0, [sp, #4]
    1c84:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    1c86:	9b00      	ldr	r3, [sp, #0]
    1c88:	2b00      	cmp	r3, #0
    1c8a:	d003      	beq.n	1c94 <OsIf_SetTimerFrequency+0x16>
    1c8c:	9b00      	ldr	r3, [sp, #0]
    1c8e:	2b01      	cmp	r3, #1
    1c90:	d004      	beq.n	1c9c <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1c92:	e007      	b.n	1ca4 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    1c94:	9801      	ldr	r0, [sp, #4]
    1c96:	f7ff ffa9 	bl	1bec <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    1c9a:	e003      	b.n	1ca4 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    1c9c:	9801      	ldr	r0, [sp, #4]
    1c9e:	f000 f85b 	bl	1d58 <OsIf_Timer_System_SetTimerFrequency>
            break;
    1ca2:	bf00      	nop
    }
}
    1ca4:	bf00      	nop
    1ca6:	b003      	add	sp, #12
    1ca8:	f85d fb04 	ldr.w	pc, [sp], #4

00001cac <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    1cac:	b500      	push	{lr}
    1cae:	b085      	sub	sp, #20
    1cb0:	9001      	str	r0, [sp, #4]
    1cb2:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1cb4:	2300      	movs	r3, #0
    1cb6:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1cb8:	9b00      	ldr	r3, [sp, #0]
    1cba:	2b00      	cmp	r3, #0
    1cbc:	d003      	beq.n	1cc6 <OsIf_MicrosToTicks+0x1a>
    1cbe:	9b00      	ldr	r3, [sp, #0]
    1cc0:	2b01      	cmp	r3, #1
    1cc2:	d005      	beq.n	1cd0 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1cc4:	e009      	b.n	1cda <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    1cc6:	9801      	ldr	r0, [sp, #4]
    1cc8:	f7ff ff95 	bl	1bf6 <OsIf_Timer_Dummy_MicrosToTicks>
    1ccc:	9003      	str	r0, [sp, #12]
            break;
    1cce:	e004      	b.n	1cda <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    1cd0:	9801      	ldr	r0, [sp, #4]
    1cd2:	f000 f84f 	bl	1d74 <OsIf_Timer_System_MicrosToTicks>
    1cd6:	9003      	str	r0, [sp, #12]
            break;
    1cd8:	bf00      	nop
    }

    return Value;
    1cda:	9b03      	ldr	r3, [sp, #12]
}
    1cdc:	4618      	mov	r0, r3
    1cde:	b005      	add	sp, #20
    1ce0:	f85d fb04 	ldr.w	pc, [sp], #4

00001ce4 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    1ce4:	b500      	push	{lr}
    1ce6:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    1ce8:	2300      	movs	r3, #0
    1cea:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    1cec:	4a09      	ldr	r2, [pc, #36]	; (1d14 <OsIf_Timer_System_Init+0x30>)
    1cee:	9b01      	ldr	r3, [sp, #4]
    1cf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1cf4:	685a      	ldr	r2, [r3, #4]
    1cf6:	4908      	ldr	r1, [pc, #32]	; (1d18 <OsIf_Timer_System_Init+0x34>)
    1cf8:	9b01      	ldr	r3, [sp, #4]
    1cfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    1cfe:	4a06      	ldr	r2, [pc, #24]	; (1d18 <OsIf_Timer_System_Init+0x34>)
    1d00:	9b01      	ldr	r3, [sp, #4]
    1d02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1d06:	4618      	mov	r0, r3
    1d08:	f000 f868 	bl	1ddc <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    1d0c:	bf00      	nop
    1d0e:	b003      	add	sp, #12
    1d10:	f85d fb04 	ldr.w	pc, [sp], #4
    1d14:	0000b2ac 	.word	0x0000b2ac
    1d18:	1fff8b40 	.word	0x1fff8b40

00001d1c <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    1d1c:	b500      	push	{lr}
    1d1e:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    1d20:	2300      	movs	r3, #0
    1d22:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1d24:	2300      	movs	r3, #0
    1d26:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    1d28:	f000 f86c 	bl	1e04 <OsIf_Timer_System_Internal_GetCounter>
    1d2c:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    1d2e:	9b01      	ldr	r3, [sp, #4]
}
    1d30:	4618      	mov	r0, r3
    1d32:	b003      	add	sp, #12
    1d34:	f85d fb04 	ldr.w	pc, [sp], #4

00001d38 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    1d38:	b500      	push	{lr}
    1d3a:	b085      	sub	sp, #20
    1d3c:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    1d3e:	2300      	movs	r3, #0
    1d40:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    1d42:	2300      	movs	r3, #0
    1d44:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    1d46:	9801      	ldr	r0, [sp, #4]
    1d48:	f000 f864 	bl	1e14 <OsIf_Timer_System_Internal_GetElapsed>
    1d4c:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    1d4e:	9b03      	ldr	r3, [sp, #12]
}
    1d50:	4618      	mov	r0, r3
    1d52:	b005      	add	sp, #20
    1d54:	f85d fb04 	ldr.w	pc, [sp], #4

00001d58 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    1d58:	b084      	sub	sp, #16
    1d5a:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1d5c:	2300      	movs	r3, #0
    1d5e:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    1d60:	4903      	ldr	r1, [pc, #12]	; (1d70 <OsIf_Timer_System_SetTimerFrequency+0x18>)
    1d62:	9b03      	ldr	r3, [sp, #12]
    1d64:	9a01      	ldr	r2, [sp, #4]
    1d66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    1d6a:	bf00      	nop
    1d6c:	b004      	add	sp, #16
    1d6e:	4770      	bx	lr
    1d70:	1fff8b40 	.word	0x1fff8b40

00001d74 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    1d74:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d76:	b087      	sub	sp, #28
    1d78:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    1d7a:	2100      	movs	r1, #0
    1d7c:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    1d7e:	2100      	movs	r1, #0
    1d80:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    1d82:	9901      	ldr	r1, [sp, #4]
    1d84:	2000      	movs	r0, #0
    1d86:	460e      	mov	r6, r1
    1d88:	4607      	mov	r7, r0
    1d8a:	4812      	ldr	r0, [pc, #72]	; (1dd4 <OsIf_Timer_System_MicrosToTicks+0x60>)
    1d8c:	9904      	ldr	r1, [sp, #16]
    1d8e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    1d92:	2000      	movs	r0, #0
    1d94:	460c      	mov	r4, r1
    1d96:	4605      	mov	r5, r0
    1d98:	fb04 f007 	mul.w	r0, r4, r7
    1d9c:	fb06 f105 	mul.w	r1, r6, r5
    1da0:	4401      	add	r1, r0
    1da2:	fba6 2304 	umull	r2, r3, r6, r4
    1da6:	4419      	add	r1, r3
    1da8:	460b      	mov	r3, r1
    1daa:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1dae:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    1db2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    1db6:	4a08      	ldr	r2, [pc, #32]	; (1dd8 <OsIf_Timer_System_MicrosToTicks+0x64>)
    1db8:	f04f 0300 	mov.w	r3, #0
    1dbc:	f7fe fbf2 	bl	5a4 <__aeabi_uldivmod>
    1dc0:	4602      	mov	r2, r0
    1dc2:	460b      	mov	r3, r1
    1dc4:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    1dc8:	9b02      	ldr	r3, [sp, #8]
    1dca:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    1dcc:	9b05      	ldr	r3, [sp, #20]
}
    1dce:	4618      	mov	r0, r3
    1dd0:	b007      	add	sp, #28
    1dd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1dd4:	1fff8b40 	.word	0x1fff8b40
    1dd8:	000f4240 	.word	0x000f4240

00001ddc <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    1ddc:	b082      	sub	sp, #8
    1dde:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    1de0:	4b07      	ldr	r3, [pc, #28]	; (1e00 <OsIf_Timer_System_Internal_Init+0x24>)
    1de2:	2200      	movs	r2, #0
    1de4:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    1de6:	4b06      	ldr	r3, [pc, #24]	; (1e00 <OsIf_Timer_System_Internal_Init+0x24>)
    1de8:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    1dec:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    1dee:	4b04      	ldr	r3, [pc, #16]	; (1e00 <OsIf_Timer_System_Internal_Init+0x24>)
    1df0:	2200      	movs	r2, #0
    1df2:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    1df4:	4b02      	ldr	r3, [pc, #8]	; (1e00 <OsIf_Timer_System_Internal_Init+0x24>)
    1df6:	2205      	movs	r2, #5
    1df8:	601a      	str	r2, [r3, #0]
}
    1dfa:	bf00      	nop
    1dfc:	b002      	add	sp, #8
    1dfe:	4770      	bx	lr
    1e00:	e000e010 	.word	0xe000e010

00001e04 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    1e04:	4b02      	ldr	r3, [pc, #8]	; (1e10 <OsIf_Timer_System_Internal_GetCounter+0xc>)
    1e06:	689b      	ldr	r3, [r3, #8]
    1e08:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    1e0c:	4618      	mov	r0, r3
    1e0e:	4770      	bx	lr
    1e10:	e000e010 	.word	0xe000e010

00001e14 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    1e14:	b084      	sub	sp, #16
    1e16:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    1e18:	4b10      	ldr	r3, [pc, #64]	; (1e5c <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    1e1a:	689b      	ldr	r3, [r3, #8]
    1e1c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    1e20:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    1e22:	2300      	movs	r3, #0
    1e24:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    1e26:	9b01      	ldr	r3, [sp, #4]
    1e28:	681b      	ldr	r3, [r3, #0]
    1e2a:	9a02      	ldr	r2, [sp, #8]
    1e2c:	429a      	cmp	r2, r3
    1e2e:	d909      	bls.n	1e44 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    1e30:	9b01      	ldr	r3, [sp, #4]
    1e32:	681a      	ldr	r2, [r3, #0]
    1e34:	9b02      	ldr	r3, [sp, #8]
    1e36:	1ad3      	subs	r3, r2, r3
    1e38:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    1e3c:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    1e40:	9303      	str	r3, [sp, #12]
    1e42:	e004      	b.n	1e4e <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    1e44:	9b01      	ldr	r3, [sp, #4]
    1e46:	681a      	ldr	r2, [r3, #0]
    1e48:	9b02      	ldr	r3, [sp, #8]
    1e4a:	1ad3      	subs	r3, r2, r3
    1e4c:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    1e4e:	9b01      	ldr	r3, [sp, #4]
    1e50:	9a02      	ldr	r2, [sp, #8]
    1e52:	601a      	str	r2, [r3, #0]

    return dif;
    1e54:	9b03      	ldr	r3, [sp, #12]
}
    1e56:	4618      	mov	r0, r3
    1e58:	b004      	add	sp, #16
    1e5a:	4770      	bx	lr
    1e5c:	e000e010 	.word	0xe000e010

00001e60 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    1e60:	b082      	sub	sp, #8
    1e62:	9001      	str	r0, [sp, #4]
    1e64:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    1e66:	bf00      	nop
    1e68:	b002      	add	sp, #8
    1e6a:	4770      	bx	lr

00001e6c <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    1e6c:	b500      	push	{lr}
    1e6e:	b085      	sub	sp, #20
    1e70:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    1e72:	4b24      	ldr	r3, [pc, #144]	; (1f04 <Clock_Ip_UpdateDriverContext+0x98>)
    1e74:	2201      	movs	r2, #1
    1e76:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    1e78:	4b23      	ldr	r3, [pc, #140]	; (1f08 <Clock_Ip_UpdateDriverContext+0x9c>)
    1e7a:	681b      	ldr	r3, [r3, #0]
    1e7c:	2102      	movs	r1, #2
    1e7e:	4618      	mov	r0, r3
    1e80:	f003 fc32 	bl	56e8 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    1e84:	2300      	movs	r3, #0
    1e86:	f88d 300f 	strb.w	r3, [sp, #15]
    1e8a:	e015      	b.n	1eb8 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    1e8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1e90:	9a01      	ldr	r2, [sp, #4]
    1e92:	334a      	adds	r3, #74	; 0x4a
    1e94:	00db      	lsls	r3, r3, #3
    1e96:	4413      	add	r3, r2
    1e98:	6858      	ldr	r0, [r3, #4]
    1e9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1e9e:	9a01      	ldr	r2, [sp, #4]
    1ea0:	334a      	adds	r3, #74	; 0x4a
    1ea2:	00db      	lsls	r3, r3, #3
    1ea4:	4413      	add	r3, r2
    1ea6:	689b      	ldr	r3, [r3, #8]
    1ea8:	4619      	mov	r1, r3
    1eaa:	f001 fadc 	bl	3466 <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    1eae:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1eb2:	3301      	adds	r3, #1
    1eb4:	f88d 300f 	strb.w	r3, [sp, #15]
    1eb8:	9b01      	ldr	r3, [sp, #4]
    1eba:	7bdb      	ldrb	r3, [r3, #15]
    1ebc:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1ec0:	429a      	cmp	r2, r3
    1ec2:	d3e3      	bcc.n	1e8c <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    1ec4:	f000 f824 	bl	1f10 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    1ec8:	2301      	movs	r3, #1
    1eca:	f88d 300f 	strb.w	r3, [sp, #15]
    1ece:	e00e      	b.n	1eee <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    1ed0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1ed4:	9b01      	ldr	r3, [sp, #4]
    1ed6:	327e      	adds	r2, #126	; 0x7e
    1ed8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1edc:	490b      	ldr	r1, [pc, #44]	; (1f0c <Clock_Ip_UpdateDriverContext+0xa0>)
    1ede:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1ee2:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    1ee4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1ee8:	3301      	adds	r3, #1
    1eea:	f88d 300f 	strb.w	r3, [sp, #15]
    1eee:	9b01      	ldr	r3, [sp, #4]
    1ef0:	7cdb      	ldrb	r3, [r3, #19]
    1ef2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1ef6:	429a      	cmp	r2, r3
    1ef8:	d3ea      	bcc.n	1ed0 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    1efa:	bf00      	nop
    1efc:	bf00      	nop
    1efe:	b005      	add	sp, #20
    1f00:	f85d fb04 	ldr.w	pc, [sp], #4
    1f04:	1fff8b10 	.word	0x1fff8b10
    1f08:	1fff8b44 	.word	0x1fff8b44
    1f0c:	1fff8b50 	.word	0x1fff8b50

00001f10 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    1f10:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    1f12:	4b23      	ldr	r3, [pc, #140]	; (1fa0 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1f14:	781b      	ldrb	r3, [r3, #0]
    1f16:	f083 0301 	eor.w	r3, r3, #1
    1f1a:	b2db      	uxtb	r3, r3
    1f1c:	2b00      	cmp	r3, #0
    1f1e:	d03d      	beq.n	1f9c <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    1f20:	4b1f      	ldr	r3, [pc, #124]	; (1fa0 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1f22:	2201      	movs	r2, #1
    1f24:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    1f26:	4b1f      	ldr	r3, [pc, #124]	; (1fa4 <Clock_Ip_CallEmptyCallbacks+0x94>)
    1f28:	685b      	ldr	r3, [r3, #4]
    1f2a:	2100      	movs	r1, #0
    1f2c:	2000      	movs	r0, #0
    1f2e:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    1f30:	4b1c      	ldr	r3, [pc, #112]	; (1fa4 <Clock_Ip_CallEmptyCallbacks+0x94>)
    1f32:	689b      	ldr	r3, [r3, #8]
    1f34:	2057      	movs	r0, #87	; 0x57
    1f36:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f38:	4b1b      	ldr	r3, [pc, #108]	; (1fa8 <Clock_Ip_CallEmptyCallbacks+0x98>)
    1f3a:	681b      	ldr	r3, [r3, #0]
    1f3c:	2000      	movs	r0, #0
    1f3e:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    1f40:	4b1a      	ldr	r3, [pc, #104]	; (1fac <Clock_Ip_CallEmptyCallbacks+0x9c>)
    1f42:	681b      	ldr	r3, [r3, #0]
    1f44:	2000      	movs	r0, #0
    1f46:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    1f48:	4b19      	ldr	r3, [pc, #100]	; (1fb0 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    1f4a:	681b      	ldr	r3, [r3, #0]
    1f4c:	2000      	movs	r0, #0
    1f4e:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f50:	4b18      	ldr	r3, [pc, #96]	; (1fb4 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    1f52:	685b      	ldr	r3, [r3, #4]
    1f54:	2000      	movs	r0, #0
    1f56:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    1f58:	4b16      	ldr	r3, [pc, #88]	; (1fb4 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    1f5a:	689b      	ldr	r3, [r3, #8]
    1f5c:	2057      	movs	r0, #87	; 0x57
    1f5e:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f60:	4b15      	ldr	r3, [pc, #84]	; (1fb8 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    1f62:	681b      	ldr	r3, [r3, #0]
    1f64:	2000      	movs	r0, #0
    1f66:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    1f68:	4b13      	ldr	r3, [pc, #76]	; (1fb8 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    1f6a:	685b      	ldr	r3, [r3, #4]
    1f6c:	2100      	movs	r1, #0
    1f6e:	2057      	movs	r0, #87	; 0x57
    1f70:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f72:	4b12      	ldr	r3, [pc, #72]	; (1fbc <Clock_Ip_CallEmptyCallbacks+0xac>)
    1f74:	681b      	ldr	r3, [r3, #0]
    1f76:	2000      	movs	r0, #0
    1f78:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f7a:	4b11      	ldr	r3, [pc, #68]	; (1fc0 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    1f7c:	685b      	ldr	r3, [r3, #4]
    1f7e:	2000      	movs	r0, #0
    1f80:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    1f82:	4b0f      	ldr	r3, [pc, #60]	; (1fc0 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    1f84:	689b      	ldr	r3, [r3, #8]
    1f86:	2057      	movs	r0, #87	; 0x57
    1f88:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1f8a:	4b0e      	ldr	r3, [pc, #56]	; (1fc4 <Clock_Ip_CallEmptyCallbacks+0xb4>)
    1f8c:	685b      	ldr	r3, [r3, #4]
    1f8e:	2000      	movs	r0, #0
    1f90:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    1f92:	4b0d      	ldr	r3, [pc, #52]	; (1fc8 <Clock_Ip_CallEmptyCallbacks+0xb8>)
    1f94:	681b      	ldr	r3, [r3, #0]
    1f96:	2100      	movs	r1, #0
    1f98:	2000      	movs	r0, #0
    1f9a:	4798      	blx	r3
    }
}
    1f9c:	bf00      	nop
    1f9e:	bd08      	pop	{r3, pc}
    1fa0:	1fff8b48 	.word	0x1fff8b48
    1fa4:	0000ad3c 	.word	0x0000ad3c
    1fa8:	0000ac50 	.word	0x0000ac50
    1fac:	0000ac8c 	.word	0x0000ac8c
    1fb0:	0000ac94 	.word	0x0000ac94
    1fb4:	0000acbc 	.word	0x0000acbc
    1fb8:	0000acc8 	.word	0x0000acc8
    1fbc:	0000ad00 	.word	0x0000ad00
    1fc0:	0000ad4c 	.word	0x0000ad4c
    1fc4:	0000ad78 	.word	0x0000ad78
    1fc8:	0000ad74 	.word	0x0000ad74

00001fcc <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    1fcc:	b500      	push	{lr}
    1fce:	b085      	sub	sp, #20
    1fd0:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    1fd2:	9b01      	ldr	r3, [sp, #4]
    1fd4:	7adb      	ldrb	r3, [r3, #11]
    1fd6:	9303      	str	r3, [sp, #12]
    1fd8:	e01f      	b.n	201a <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    1fda:	9b03      	ldr	r3, [sp, #12]
    1fdc:	1e5a      	subs	r2, r3, #1
    1fde:	9b01      	ldr	r3, [sp, #4]
    1fe0:	320d      	adds	r2, #13
    1fe2:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1fe6:	495a      	ldr	r1, [pc, #360]	; (2150 <Clock_Ip_ResetClockConfiguration+0x184>)
    1fe8:	4613      	mov	r3, r2
    1fea:	00db      	lsls	r3, r3, #3
    1fec:	4413      	add	r3, r2
    1fee:	440b      	add	r3, r1
    1ff0:	3301      	adds	r3, #1
    1ff2:	781b      	ldrb	r3, [r3, #0]
    1ff4:	461a      	mov	r2, r3
    1ff6:	4b57      	ldr	r3, [pc, #348]	; (2154 <Clock_Ip_ResetClockConfiguration+0x188>)
    1ff8:	5c9b      	ldrb	r3, [r3, r2]
    1ffa:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    1ffc:	4a56      	ldr	r2, [pc, #344]	; (2158 <Clock_Ip_ResetClockConfiguration+0x18c>)
    1ffe:	9b02      	ldr	r3, [sp, #8]
    2000:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2004:	9a03      	ldr	r2, [sp, #12]
    2006:	3a01      	subs	r2, #1
    2008:	320d      	adds	r2, #13
    200a:	00d2      	lsls	r2, r2, #3
    200c:	9901      	ldr	r1, [sp, #4]
    200e:	440a      	add	r2, r1
    2010:	4610      	mov	r0, r2
    2012:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    2014:	9b03      	ldr	r3, [sp, #12]
    2016:	3b01      	subs	r3, #1
    2018:	9303      	str	r3, [sp, #12]
    201a:	9b03      	ldr	r3, [sp, #12]
    201c:	2b00      	cmp	r3, #0
    201e:	d1dc      	bne.n	1fda <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2020:	9b01      	ldr	r3, [sp, #4]
    2022:	7b9b      	ldrb	r3, [r3, #14]
    2024:	9303      	str	r3, [sp, #12]
    2026:	e026      	b.n	2076 <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2028:	9b03      	ldr	r3, [sp, #12]
    202a:	3b01      	subs	r3, #1
    202c:	9a01      	ldr	r2, [sp, #4]
    202e:	3324      	adds	r3, #36	; 0x24
    2030:	011b      	lsls	r3, r3, #4
    2032:	4413      	add	r3, r2
    2034:	3304      	adds	r3, #4
    2036:	681a      	ldr	r2, [r3, #0]
    2038:	4945      	ldr	r1, [pc, #276]	; (2150 <Clock_Ip_ResetClockConfiguration+0x184>)
    203a:	4613      	mov	r3, r2
    203c:	00db      	lsls	r3, r3, #3
    203e:	4413      	add	r3, r2
    2040:	440b      	add	r3, r1
    2042:	3301      	adds	r3, #1
    2044:	781b      	ldrb	r3, [r3, #0]
    2046:	461a      	mov	r2, r3
    2048:	4b44      	ldr	r3, [pc, #272]	; (215c <Clock_Ip_ResetClockConfiguration+0x190>)
    204a:	5c9b      	ldrb	r3, [r3, r2]
    204c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    204e:	4944      	ldr	r1, [pc, #272]	; (2160 <Clock_Ip_ResetClockConfiguration+0x194>)
    2050:	9a02      	ldr	r2, [sp, #8]
    2052:	4613      	mov	r3, r2
    2054:	005b      	lsls	r3, r3, #1
    2056:	4413      	add	r3, r2
    2058:	009b      	lsls	r3, r3, #2
    205a:	440b      	add	r3, r1
    205c:	681b      	ldr	r3, [r3, #0]
    205e:	9a03      	ldr	r2, [sp, #12]
    2060:	3a01      	subs	r2, #1
    2062:	3224      	adds	r2, #36	; 0x24
    2064:	0112      	lsls	r2, r2, #4
    2066:	9901      	ldr	r1, [sp, #4]
    2068:	440a      	add	r2, r1
    206a:	3204      	adds	r2, #4
    206c:	4610      	mov	r0, r2
    206e:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2070:	9b03      	ldr	r3, [sp, #12]
    2072:	3b01      	subs	r3, #1
    2074:	9303      	str	r3, [sp, #12]
    2076:	9b03      	ldr	r3, [sp, #12]
    2078:	2b00      	cmp	r3, #0
    207a:	d1d5      	bne.n	2028 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    207c:	9b01      	ldr	r3, [sp, #4]
    207e:	7a9b      	ldrb	r3, [r3, #10]
    2080:	9303      	str	r3, [sp, #12]
    2082:	e02a      	b.n	20da <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2084:	9b03      	ldr	r3, [sp, #12]
    2086:	1e5a      	subs	r2, r3, #1
    2088:	9901      	ldr	r1, [sp, #4]
    208a:	4613      	mov	r3, r2
    208c:	009b      	lsls	r3, r3, #2
    208e:	4413      	add	r3, r2
    2090:	00db      	lsls	r3, r3, #3
    2092:	440b      	add	r3, r1
    2094:	3340      	adds	r3, #64	; 0x40
    2096:	681a      	ldr	r2, [r3, #0]
    2098:	492d      	ldr	r1, [pc, #180]	; (2150 <Clock_Ip_ResetClockConfiguration+0x184>)
    209a:	4613      	mov	r3, r2
    209c:	00db      	lsls	r3, r3, #3
    209e:	4413      	add	r3, r2
    20a0:	440b      	add	r3, r1
    20a2:	3301      	adds	r3, #1
    20a4:	781b      	ldrb	r3, [r3, #0]
    20a6:	461a      	mov	r2, r3
    20a8:	4b2e      	ldr	r3, [pc, #184]	; (2164 <Clock_Ip_ResetClockConfiguration+0x198>)
    20aa:	5c9b      	ldrb	r3, [r3, r2]
    20ac:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    20ae:	492e      	ldr	r1, [pc, #184]	; (2168 <Clock_Ip_ResetClockConfiguration+0x19c>)
    20b0:	9a02      	ldr	r2, [sp, #8]
    20b2:	4613      	mov	r3, r2
    20b4:	009b      	lsls	r3, r3, #2
    20b6:	4413      	add	r3, r2
    20b8:	009b      	lsls	r3, r3, #2
    20ba:	440b      	add	r3, r1
    20bc:	6819      	ldr	r1, [r3, #0]
    20be:	9b03      	ldr	r3, [sp, #12]
    20c0:	1e5a      	subs	r2, r3, #1
    20c2:	4613      	mov	r3, r2
    20c4:	009b      	lsls	r3, r3, #2
    20c6:	4413      	add	r3, r2
    20c8:	00db      	lsls	r3, r3, #3
    20ca:	3340      	adds	r3, #64	; 0x40
    20cc:	9a01      	ldr	r2, [sp, #4]
    20ce:	4413      	add	r3, r2
    20d0:	4618      	mov	r0, r3
    20d2:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    20d4:	9b03      	ldr	r3, [sp, #12]
    20d6:	3b01      	subs	r3, #1
    20d8:	9303      	str	r3, [sp, #12]
    20da:	9b03      	ldr	r3, [sp, #12]
    20dc:	2b00      	cmp	r3, #0
    20de:	d1d1      	bne.n	2084 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    20e0:	9b01      	ldr	r3, [sp, #4]
    20e2:	7a5b      	ldrb	r3, [r3, #9]
    20e4:	9303      	str	r3, [sp, #12]
    20e6:	e02b      	b.n	2140 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    20e8:	9b03      	ldr	r3, [sp, #12]
    20ea:	1e5a      	subs	r2, r3, #1
    20ec:	9901      	ldr	r1, [sp, #4]
    20ee:	4613      	mov	r3, r2
    20f0:	009b      	lsls	r3, r3, #2
    20f2:	4413      	add	r3, r2
    20f4:	009b      	lsls	r3, r3, #2
    20f6:	440b      	add	r3, r1
    20f8:	332c      	adds	r3, #44	; 0x2c
    20fa:	681a      	ldr	r2, [r3, #0]
    20fc:	4914      	ldr	r1, [pc, #80]	; (2150 <Clock_Ip_ResetClockConfiguration+0x184>)
    20fe:	4613      	mov	r3, r2
    2100:	00db      	lsls	r3, r3, #3
    2102:	4413      	add	r3, r2
    2104:	440b      	add	r3, r1
    2106:	3301      	adds	r3, #1
    2108:	781b      	ldrb	r3, [r3, #0]
    210a:	461a      	mov	r2, r3
    210c:	4b17      	ldr	r3, [pc, #92]	; (216c <Clock_Ip_ResetClockConfiguration+0x1a0>)
    210e:	5c9b      	ldrb	r3, [r3, r2]
    2110:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    2112:	4917      	ldr	r1, [pc, #92]	; (2170 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    2114:	9a02      	ldr	r2, [sp, #8]
    2116:	4613      	mov	r3, r2
    2118:	009b      	lsls	r3, r3, #2
    211a:	4413      	add	r3, r2
    211c:	009b      	lsls	r3, r3, #2
    211e:	440b      	add	r3, r1
    2120:	6819      	ldr	r1, [r3, #0]
    2122:	9b03      	ldr	r3, [sp, #12]
    2124:	1e5a      	subs	r2, r3, #1
    2126:	4613      	mov	r3, r2
    2128:	009b      	lsls	r3, r3, #2
    212a:	4413      	add	r3, r2
    212c:	009b      	lsls	r3, r3, #2
    212e:	3328      	adds	r3, #40	; 0x28
    2130:	9a01      	ldr	r2, [sp, #4]
    2132:	4413      	add	r3, r2
    2134:	3304      	adds	r3, #4
    2136:	4618      	mov	r0, r3
    2138:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    213a:	9b03      	ldr	r3, [sp, #12]
    213c:	3b01      	subs	r3, #1
    213e:	9303      	str	r3, [sp, #12]
    2140:	9b03      	ldr	r3, [sp, #12]
    2142:	2b00      	cmp	r3, #0
    2144:	d1d0      	bne.n	20e8 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    2146:	bf00      	nop
    2148:	bf00      	nop
    214a:	b005      	add	sp, #20
    214c:	f85d fb04 	ldr.w	pc, [sp], #4
    2150:	0000a740 	.word	0x0000a740
    2154:	0000a710 	.word	0x0000a710
    2158:	0000ad78 	.word	0x0000ad78
    215c:	0000a6f0 	.word	0x0000a6f0
    2160:	0000acbc 	.word	0x0000acbc
    2164:	0000a700 	.word	0x0000a700
    2168:	0000ad4c 	.word	0x0000ad4c
    216c:	0000a6c0 	.word	0x0000a6c0
    2170:	0000ac94 	.word	0x0000ac94

00002174 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    2174:	b500      	push	{lr}
    2176:	b085      	sub	sp, #20
    2178:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    217a:	2301      	movs	r3, #1
    217c:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    217e:	9801      	ldr	r0, [sp, #4]
    2180:	f000 f818 	bl	21b4 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    2184:	4b0a      	ldr	r3, [pc, #40]	; (21b0 <Clock_Ip_Init+0x3c>)
    2186:	781b      	ldrb	r3, [r3, #0]
    2188:	2b00      	cmp	r3, #0
    218a:	d00a      	beq.n	21a2 <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    218c:	f000 fb74 	bl	2878 <Clock_Ip_GetPllStatus>
    2190:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    2192:	9b02      	ldr	r3, [sp, #8]
    2194:	2b00      	cmp	r3, #0
    2196:	d106      	bne.n	21a6 <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    2198:	f000 fbf2 	bl	2980 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    219c:	2300      	movs	r3, #0
    219e:	9303      	str	r3, [sp, #12]
    21a0:	e001      	b.n	21a6 <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    21a2:	2300      	movs	r3, #0
    21a4:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    21a6:	9b03      	ldr	r3, [sp, #12]
}
    21a8:	4618      	mov	r0, r3
    21aa:	b005      	add	sp, #20
    21ac:	f85d fb04 	ldr.w	pc, [sp], #4
    21b0:	1fff8b4c 	.word	0x1fff8b4c

000021b4 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    21b4:	b510      	push	{r4, lr}
    21b6:	b084      	sub	sp, #16
    21b8:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    21ba:	4a9f      	ldr	r2, [pc, #636]	; (2438 <Clock_Ip_InitClock+0x284>)
    21bc:	9b01      	ldr	r3, [sp, #4]
    21be:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    21c0:	2101      	movs	r1, #1
    21c2:	9801      	ldr	r0, [sp, #4]
    21c4:	f003 fa90 	bl	56e8 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    21c8:	4b9b      	ldr	r3, [pc, #620]	; (2438 <Clock_Ip_InitClock+0x284>)
    21ca:	681b      	ldr	r3, [r3, #0]
    21cc:	2b00      	cmp	r3, #0
    21ce:	d030      	beq.n	2232 <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    21d0:	2300      	movs	r3, #0
    21d2:	9303      	str	r3, [sp, #12]
    21d4:	e027      	b.n	2226 <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    21d6:	9901      	ldr	r1, [sp, #4]
    21d8:	9a03      	ldr	r2, [sp, #12]
    21da:	4613      	mov	r3, r2
    21dc:	009b      	lsls	r3, r3, #2
    21de:	4413      	add	r3, r2
    21e0:	009b      	lsls	r3, r3, #2
    21e2:	440b      	add	r3, r1
    21e4:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    21e8:	681a      	ldr	r2, [r3, #0]
    21ea:	4994      	ldr	r1, [pc, #592]	; (243c <Clock_Ip_InitClock+0x288>)
    21ec:	4613      	mov	r3, r2
    21ee:	00db      	lsls	r3, r3, #3
    21f0:	4413      	add	r3, r2
    21f2:	440b      	add	r3, r1
    21f4:	3301      	adds	r3, #1
    21f6:	781b      	ldrb	r3, [r3, #0]
    21f8:	461a      	mov	r2, r3
    21fa:	4b91      	ldr	r3, [pc, #580]	; (2440 <Clock_Ip_InitClock+0x28c>)
    21fc:	5c9b      	ldrb	r3, [r3, r2]
    21fe:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    2200:	4a90      	ldr	r2, [pc, #576]	; (2444 <Clock_Ip_InitClock+0x290>)
    2202:	9b02      	ldr	r3, [sp, #8]
    2204:	011b      	lsls	r3, r3, #4
    2206:	4413      	add	r3, r2
    2208:	6819      	ldr	r1, [r3, #0]
    220a:	9a03      	ldr	r2, [sp, #12]
    220c:	4613      	mov	r3, r2
    220e:	009b      	lsls	r3, r3, #2
    2210:	4413      	add	r3, r2
    2212:	009b      	lsls	r3, r3, #2
    2214:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2218:	9a01      	ldr	r2, [sp, #4]
    221a:	4413      	add	r3, r2
    221c:	4618      	mov	r0, r3
    221e:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    2220:	9b03      	ldr	r3, [sp, #12]
    2222:	3301      	adds	r3, #1
    2224:	9303      	str	r3, [sp, #12]
    2226:	9b01      	ldr	r3, [sp, #4]
    2228:	7c9b      	ldrb	r3, [r3, #18]
    222a:	461a      	mov	r2, r3
    222c:	9b03      	ldr	r3, [sp, #12]
    222e:	4293      	cmp	r3, r2
    2230:	d3d1      	bcc.n	21d6 <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    2232:	9801      	ldr	r0, [sp, #4]
    2234:	f7ff feca 	bl	1fcc <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2238:	2300      	movs	r3, #0
    223a:	9303      	str	r3, [sp, #12]
    223c:	e029      	b.n	2292 <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    223e:	9901      	ldr	r1, [sp, #4]
    2240:	9a03      	ldr	r2, [sp, #12]
    2242:	4613      	mov	r3, r2
    2244:	005b      	lsls	r3, r3, #1
    2246:	4413      	add	r3, r2
    2248:	009b      	lsls	r3, r3, #2
    224a:	440b      	add	r3, r1
    224c:	3314      	adds	r3, #20
    224e:	681a      	ldr	r2, [r3, #0]
    2250:	497a      	ldr	r1, [pc, #488]	; (243c <Clock_Ip_InitClock+0x288>)
    2252:	4613      	mov	r3, r2
    2254:	00db      	lsls	r3, r3, #3
    2256:	4413      	add	r3, r2
    2258:	440b      	add	r3, r1
    225a:	3301      	adds	r3, #1
    225c:	781b      	ldrb	r3, [r3, #0]
    225e:	461a      	mov	r2, r3
    2260:	4b79      	ldr	r3, [pc, #484]	; (2448 <Clock_Ip_InitClock+0x294>)
    2262:	5c9b      	ldrb	r3, [r3, r2]
    2264:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    2266:	4979      	ldr	r1, [pc, #484]	; (244c <Clock_Ip_InitClock+0x298>)
    2268:	9a02      	ldr	r2, [sp, #8]
    226a:	4613      	mov	r3, r2
    226c:	005b      	lsls	r3, r3, #1
    226e:	4413      	add	r3, r2
    2270:	009b      	lsls	r3, r3, #2
    2272:	440b      	add	r3, r1
    2274:	6819      	ldr	r1, [r3, #0]
    2276:	9a03      	ldr	r2, [sp, #12]
    2278:	4613      	mov	r3, r2
    227a:	005b      	lsls	r3, r3, #1
    227c:	4413      	add	r3, r2
    227e:	009b      	lsls	r3, r3, #2
    2280:	3310      	adds	r3, #16
    2282:	9a01      	ldr	r2, [sp, #4]
    2284:	4413      	add	r3, r2
    2286:	3304      	adds	r3, #4
    2288:	4618      	mov	r0, r3
    228a:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    228c:	9b03      	ldr	r3, [sp, #12]
    228e:	3301      	adds	r3, #1
    2290:	9303      	str	r3, [sp, #12]
    2292:	9b01      	ldr	r3, [sp, #4]
    2294:	7a1b      	ldrb	r3, [r3, #8]
    2296:	461a      	mov	r2, r3
    2298:	9b03      	ldr	r3, [sp, #12]
    229a:	4293      	cmp	r3, r2
    229c:	d3cf      	bcc.n	223e <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    229e:	2300      	movs	r3, #0
    22a0:	9303      	str	r3, [sp, #12]
    22a2:	e02a      	b.n	22fa <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    22a4:	9901      	ldr	r1, [sp, #4]
    22a6:	9a03      	ldr	r2, [sp, #12]
    22a8:	4613      	mov	r3, r2
    22aa:	009b      	lsls	r3, r3, #2
    22ac:	4413      	add	r3, r2
    22ae:	009b      	lsls	r3, r3, #2
    22b0:	440b      	add	r3, r1
    22b2:	332c      	adds	r3, #44	; 0x2c
    22b4:	681a      	ldr	r2, [r3, #0]
    22b6:	4961      	ldr	r1, [pc, #388]	; (243c <Clock_Ip_InitClock+0x288>)
    22b8:	4613      	mov	r3, r2
    22ba:	00db      	lsls	r3, r3, #3
    22bc:	4413      	add	r3, r2
    22be:	440b      	add	r3, r1
    22c0:	3301      	adds	r3, #1
    22c2:	781b      	ldrb	r3, [r3, #0]
    22c4:	461a      	mov	r2, r3
    22c6:	4b62      	ldr	r3, [pc, #392]	; (2450 <Clock_Ip_InitClock+0x29c>)
    22c8:	5c9b      	ldrb	r3, [r3, r2]
    22ca:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    22cc:	4961      	ldr	r1, [pc, #388]	; (2454 <Clock_Ip_InitClock+0x2a0>)
    22ce:	9a02      	ldr	r2, [sp, #8]
    22d0:	4613      	mov	r3, r2
    22d2:	009b      	lsls	r3, r3, #2
    22d4:	4413      	add	r3, r2
    22d6:	009b      	lsls	r3, r3, #2
    22d8:	440b      	add	r3, r1
    22da:	3304      	adds	r3, #4
    22dc:	6819      	ldr	r1, [r3, #0]
    22de:	9a03      	ldr	r2, [sp, #12]
    22e0:	4613      	mov	r3, r2
    22e2:	009b      	lsls	r3, r3, #2
    22e4:	4413      	add	r3, r2
    22e6:	009b      	lsls	r3, r3, #2
    22e8:	3328      	adds	r3, #40	; 0x28
    22ea:	9a01      	ldr	r2, [sp, #4]
    22ec:	4413      	add	r3, r2
    22ee:	3304      	adds	r3, #4
    22f0:	4618      	mov	r0, r3
    22f2:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    22f4:	9b03      	ldr	r3, [sp, #12]
    22f6:	3301      	adds	r3, #1
    22f8:	9303      	str	r3, [sp, #12]
    22fa:	9b01      	ldr	r3, [sp, #4]
    22fc:	7a5b      	ldrb	r3, [r3, #9]
    22fe:	461a      	mov	r2, r3
    2300:	9b03      	ldr	r3, [sp, #12]
    2302:	4293      	cmp	r3, r2
    2304:	d3ce      	bcc.n	22a4 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    2306:	9801      	ldr	r0, [sp, #4]
    2308:	f7ff fdb0 	bl	1e6c <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    230c:	2300      	movs	r3, #0
    230e:	9303      	str	r3, [sp, #12]
    2310:	e028      	b.n	2364 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    2312:	9901      	ldr	r1, [sp, #4]
    2314:	9a03      	ldr	r2, [sp, #12]
    2316:	4613      	mov	r3, r2
    2318:	009b      	lsls	r3, r3, #2
    231a:	4413      	add	r3, r2
    231c:	009b      	lsls	r3, r3, #2
    231e:	440b      	add	r3, r1
    2320:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    2324:	681a      	ldr	r2, [r3, #0]
    2326:	4945      	ldr	r1, [pc, #276]	; (243c <Clock_Ip_InitClock+0x288>)
    2328:	4613      	mov	r3, r2
    232a:	00db      	lsls	r3, r3, #3
    232c:	4413      	add	r3, r2
    232e:	440b      	add	r3, r1
    2330:	3301      	adds	r3, #1
    2332:	781b      	ldrb	r3, [r3, #0]
    2334:	461a      	mov	r2, r3
    2336:	4b48      	ldr	r3, [pc, #288]	; (2458 <Clock_Ip_InitClock+0x2a4>)
    2338:	5c9b      	ldrb	r3, [r3, r2]
    233a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    233c:	4a47      	ldr	r2, [pc, #284]	; (245c <Clock_Ip_InitClock+0x2a8>)
    233e:	9b02      	ldr	r3, [sp, #8]
    2340:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    2344:	9a03      	ldr	r2, [sp, #12]
    2346:	4613      	mov	r3, r2
    2348:	009b      	lsls	r3, r3, #2
    234a:	4413      	add	r3, r2
    234c:	009b      	lsls	r3, r3, #2
    234e:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    2352:	9a01      	ldr	r2, [sp, #4]
    2354:	4413      	add	r3, r2
    2356:	3304      	adds	r3, #4
    2358:	9903      	ldr	r1, [sp, #12]
    235a:	4618      	mov	r0, r3
    235c:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    235e:	9b03      	ldr	r3, [sp, #12]
    2360:	3301      	adds	r3, #1
    2362:	9303      	str	r3, [sp, #12]
    2364:	9b01      	ldr	r3, [sp, #4]
    2366:	7c5b      	ldrb	r3, [r3, #17]
    2368:	461a      	mov	r2, r3
    236a:	9b03      	ldr	r3, [sp, #12]
    236c:	4293      	cmp	r3, r2
    236e:	d3d0      	bcc.n	2312 <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2370:	2300      	movs	r3, #0
    2372:	9303      	str	r3, [sp, #12]
    2374:	e026      	b.n	23c4 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2376:	9901      	ldr	r1, [sp, #4]
    2378:	9a03      	ldr	r2, [sp, #12]
    237a:	4613      	mov	r3, r2
    237c:	005b      	lsls	r3, r3, #1
    237e:	4413      	add	r3, r2
    2380:	009b      	lsls	r3, r3, #2
    2382:	440b      	add	r3, r1
    2384:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2388:	681a      	ldr	r2, [r3, #0]
    238a:	492c      	ldr	r1, [pc, #176]	; (243c <Clock_Ip_InitClock+0x288>)
    238c:	4613      	mov	r3, r2
    238e:	00db      	lsls	r3, r3, #3
    2390:	4413      	add	r3, r2
    2392:	440b      	add	r3, r1
    2394:	3301      	adds	r3, #1
    2396:	781b      	ldrb	r3, [r3, #0]
    2398:	461a      	mov	r2, r3
    239a:	4b31      	ldr	r3, [pc, #196]	; (2460 <Clock_Ip_InitClock+0x2ac>)
    239c:	5c9b      	ldrb	r3, [r3, r2]
    239e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    23a0:	4a30      	ldr	r2, [pc, #192]	; (2464 <Clock_Ip_InitClock+0x2b0>)
    23a2:	9b02      	ldr	r3, [sp, #8]
    23a4:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    23a8:	9a03      	ldr	r2, [sp, #12]
    23aa:	4613      	mov	r3, r2
    23ac:	005b      	lsls	r3, r3, #1
    23ae:	4413      	add	r3, r2
    23b0:	009b      	lsls	r3, r3, #2
    23b2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    23b6:	9a01      	ldr	r2, [sp, #4]
    23b8:	4413      	add	r3, r2
    23ba:	4618      	mov	r0, r3
    23bc:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    23be:	9b03      	ldr	r3, [sp, #12]
    23c0:	3301      	adds	r3, #1
    23c2:	9303      	str	r3, [sp, #12]
    23c4:	9b01      	ldr	r3, [sp, #4]
    23c6:	7b5b      	ldrb	r3, [r3, #13]
    23c8:	461a      	mov	r2, r3
    23ca:	9b03      	ldr	r3, [sp, #12]
    23cc:	4293      	cmp	r3, r2
    23ce:	d3d2      	bcc.n	2376 <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    23d0:	2300      	movs	r3, #0
    23d2:	9303      	str	r3, [sp, #12]
    23d4:	e026      	b.n	2424 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    23d6:	9901      	ldr	r1, [sp, #4]
    23d8:	9a03      	ldr	r2, [sp, #12]
    23da:	4613      	mov	r3, r2
    23dc:	005b      	lsls	r3, r3, #1
    23de:	4413      	add	r3, r2
    23e0:	009b      	lsls	r3, r3, #2
    23e2:	440b      	add	r3, r1
    23e4:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    23e8:	681a      	ldr	r2, [r3, #0]
    23ea:	4914      	ldr	r1, [pc, #80]	; (243c <Clock_Ip_InitClock+0x288>)
    23ec:	4613      	mov	r3, r2
    23ee:	00db      	lsls	r3, r3, #3
    23f0:	4413      	add	r3, r2
    23f2:	440b      	add	r3, r1
    23f4:	3301      	adds	r3, #1
    23f6:	781b      	ldrb	r3, [r3, #0]
    23f8:	461a      	mov	r2, r3
    23fa:	4b1b      	ldr	r3, [pc, #108]	; (2468 <Clock_Ip_InitClock+0x2b4>)
    23fc:	5c9b      	ldrb	r3, [r3, r2]
    23fe:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    2400:	4a1a      	ldr	r2, [pc, #104]	; (246c <Clock_Ip_InitClock+0x2b8>)
    2402:	9b02      	ldr	r3, [sp, #8]
    2404:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    2408:	9a03      	ldr	r2, [sp, #12]
    240a:	4613      	mov	r3, r2
    240c:	005b      	lsls	r3, r3, #1
    240e:	4413      	add	r3, r2
    2410:	009b      	lsls	r3, r3, #2
    2412:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2416:	9a01      	ldr	r2, [sp, #4]
    2418:	4413      	add	r3, r2
    241a:	4618      	mov	r0, r3
    241c:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    241e:	9b03      	ldr	r3, [sp, #12]
    2420:	3301      	adds	r3, #1
    2422:	9303      	str	r3, [sp, #12]
    2424:	9b01      	ldr	r3, [sp, #4]
    2426:	7b1b      	ldrb	r3, [r3, #12]
    2428:	461a      	mov	r2, r3
    242a:	9b03      	ldr	r3, [sp, #12]
    242c:	4293      	cmp	r3, r2
    242e:	d3d2      	bcc.n	23d6 <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2430:	2300      	movs	r3, #0
    2432:	9303      	str	r3, [sp, #12]
    2434:	e044      	b.n	24c0 <Clock_Ip_InitClock+0x30c>
    2436:	bf00      	nop
    2438:	1fff8b44 	.word	0x1fff8b44
    243c:	0000a740 	.word	0x0000a740
    2440:	0000a730 	.word	0x0000a730
    2444:	0000ad3c 	.word	0x0000ad3c
    2448:	0000a6d0 	.word	0x0000a6d0
    244c:	0000ad00 	.word	0x0000ad00
    2450:	0000a6c0 	.word	0x0000a6c0
    2454:	0000ac94 	.word	0x0000ac94
    2458:	0000a720 	.word	0x0000a720
    245c:	0000ad74 	.word	0x0000ad74
    2460:	0000a6b0 	.word	0x0000a6b0
    2464:	0000ac8c 	.word	0x0000ac8c
    2468:	0000a6a0 	.word	0x0000a6a0
    246c:	0000ac50 	.word	0x0000ac50
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2470:	9901      	ldr	r1, [sp, #4]
    2472:	9a03      	ldr	r2, [sp, #12]
    2474:	4613      	mov	r3, r2
    2476:	005b      	lsls	r3, r3, #1
    2478:	4413      	add	r3, r2
    247a:	009b      	lsls	r3, r3, #2
    247c:	440b      	add	r3, r1
    247e:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2482:	681a      	ldr	r2, [r3, #0]
    2484:	49ac      	ldr	r1, [pc, #688]	; (2738 <Clock_Ip_InitClock+0x584>)
    2486:	4613      	mov	r3, r2
    2488:	00db      	lsls	r3, r3, #3
    248a:	4413      	add	r3, r2
    248c:	440b      	add	r3, r1
    248e:	3301      	adds	r3, #1
    2490:	781b      	ldrb	r3, [r3, #0]
    2492:	461a      	mov	r2, r3
    2494:	4ba9      	ldr	r3, [pc, #676]	; (273c <Clock_Ip_InitClock+0x588>)
    2496:	5c9b      	ldrb	r3, [r3, r2]
    2498:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    249a:	4aa9      	ldr	r2, [pc, #676]	; (2740 <Clock_Ip_InitClock+0x58c>)
    249c:	9b02      	ldr	r3, [sp, #8]
    249e:	00db      	lsls	r3, r3, #3
    24a0:	4413      	add	r3, r2
    24a2:	6859      	ldr	r1, [r3, #4]
    24a4:	9a03      	ldr	r2, [sp, #12]
    24a6:	4613      	mov	r3, r2
    24a8:	005b      	lsls	r3, r3, #1
    24aa:	4413      	add	r3, r2
    24ac:	009b      	lsls	r3, r3, #2
    24ae:	f503 730e 	add.w	r3, r3, #568	; 0x238
    24b2:	9a01      	ldr	r2, [sp, #4]
    24b4:	4413      	add	r3, r2
    24b6:	4618      	mov	r0, r3
    24b8:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    24ba:	9b03      	ldr	r3, [sp, #12]
    24bc:	3301      	adds	r3, #1
    24be:	9303      	str	r3, [sp, #12]
    24c0:	9b01      	ldr	r3, [sp, #4]
    24c2:	7b5b      	ldrb	r3, [r3, #13]
    24c4:	461a      	mov	r2, r3
    24c6:	9b03      	ldr	r3, [sp, #12]
    24c8:	4293      	cmp	r3, r2
    24ca:	d3d1      	bcc.n	2470 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    24cc:	2300      	movs	r3, #0
    24ce:	9303      	str	r3, [sp, #12]
    24d0:	e029      	b.n	2526 <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    24d2:	9901      	ldr	r1, [sp, #4]
    24d4:	9a03      	ldr	r2, [sp, #12]
    24d6:	4613      	mov	r3, r2
    24d8:	009b      	lsls	r3, r3, #2
    24da:	4413      	add	r3, r2
    24dc:	00db      	lsls	r3, r3, #3
    24de:	440b      	add	r3, r1
    24e0:	3340      	adds	r3, #64	; 0x40
    24e2:	681a      	ldr	r2, [r3, #0]
    24e4:	4994      	ldr	r1, [pc, #592]	; (2738 <Clock_Ip_InitClock+0x584>)
    24e6:	4613      	mov	r3, r2
    24e8:	00db      	lsls	r3, r3, #3
    24ea:	4413      	add	r3, r2
    24ec:	440b      	add	r3, r1
    24ee:	3301      	adds	r3, #1
    24f0:	781b      	ldrb	r3, [r3, #0]
    24f2:	461a      	mov	r2, r3
    24f4:	4b93      	ldr	r3, [pc, #588]	; (2744 <Clock_Ip_InitClock+0x590>)
    24f6:	5c9b      	ldrb	r3, [r3, r2]
    24f8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    24fa:	4993      	ldr	r1, [pc, #588]	; (2748 <Clock_Ip_InitClock+0x594>)
    24fc:	9a02      	ldr	r2, [sp, #8]
    24fe:	4613      	mov	r3, r2
    2500:	009b      	lsls	r3, r3, #2
    2502:	4413      	add	r3, r2
    2504:	009b      	lsls	r3, r3, #2
    2506:	440b      	add	r3, r1
    2508:	3304      	adds	r3, #4
    250a:	6819      	ldr	r1, [r3, #0]
    250c:	9a03      	ldr	r2, [sp, #12]
    250e:	4613      	mov	r3, r2
    2510:	009b      	lsls	r3, r3, #2
    2512:	4413      	add	r3, r2
    2514:	00db      	lsls	r3, r3, #3
    2516:	3340      	adds	r3, #64	; 0x40
    2518:	9a01      	ldr	r2, [sp, #4]
    251a:	4413      	add	r3, r2
    251c:	4618      	mov	r0, r3
    251e:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2520:	9b03      	ldr	r3, [sp, #12]
    2522:	3301      	adds	r3, #1
    2524:	9303      	str	r3, [sp, #12]
    2526:	9b01      	ldr	r3, [sp, #4]
    2528:	7a9b      	ldrb	r3, [r3, #10]
    252a:	461a      	mov	r2, r3
    252c:	9b03      	ldr	r3, [sp, #12]
    252e:	4293      	cmp	r3, r2
    2530:	d3cf      	bcc.n	24d2 <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2532:	2300      	movs	r3, #0
    2534:	9303      	str	r3, [sp, #12]
    2536:	e029      	b.n	258c <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2538:	9901      	ldr	r1, [sp, #4]
    253a:	9a03      	ldr	r2, [sp, #12]
    253c:	4613      	mov	r3, r2
    253e:	009b      	lsls	r3, r3, #2
    2540:	4413      	add	r3, r2
    2542:	009b      	lsls	r3, r3, #2
    2544:	440b      	add	r3, r1
    2546:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    254a:	681a      	ldr	r2, [r3, #0]
    254c:	497a      	ldr	r1, [pc, #488]	; (2738 <Clock_Ip_InitClock+0x584>)
    254e:	4613      	mov	r3, r2
    2550:	00db      	lsls	r3, r3, #3
    2552:	4413      	add	r3, r2
    2554:	440b      	add	r3, r1
    2556:	3301      	adds	r3, #1
    2558:	781b      	ldrb	r3, [r3, #0]
    255a:	461a      	mov	r2, r3
    255c:	4b7b      	ldr	r3, [pc, #492]	; (274c <Clock_Ip_InitClock+0x598>)
    255e:	5c9b      	ldrb	r3, [r3, r2]
    2560:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    2562:	4a7b      	ldr	r2, [pc, #492]	; (2750 <Clock_Ip_InitClock+0x59c>)
    2564:	9b02      	ldr	r3, [sp, #8]
    2566:	011b      	lsls	r3, r3, #4
    2568:	4413      	add	r3, r2
    256a:	3304      	adds	r3, #4
    256c:	681c      	ldr	r4, [r3, #0]
    256e:	9a03      	ldr	r2, [sp, #12]
    2570:	4613      	mov	r3, r2
    2572:	009b      	lsls	r3, r3, #2
    2574:	4413      	add	r3, r2
    2576:	009b      	lsls	r3, r3, #2
    2578:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    257c:	9a01      	ldr	r2, [sp, #4]
    257e:	4413      	add	r3, r2
    2580:	9903      	ldr	r1, [sp, #12]
    2582:	4618      	mov	r0, r3
    2584:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2586:	9b03      	ldr	r3, [sp, #12]
    2588:	3301      	adds	r3, #1
    258a:	9303      	str	r3, [sp, #12]
    258c:	9b01      	ldr	r3, [sp, #4]
    258e:	7c9b      	ldrb	r3, [r3, #18]
    2590:	461a      	mov	r2, r3
    2592:	9b03      	ldr	r3, [sp, #12]
    2594:	4293      	cmp	r3, r2
    2596:	d3cf      	bcc.n	2538 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2598:	2300      	movs	r3, #0
    259a:	9303      	str	r3, [sp, #12]
    259c:	e02a      	b.n	25f4 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    259e:	9901      	ldr	r1, [sp, #4]
    25a0:	9a03      	ldr	r2, [sp, #12]
    25a2:	4613      	mov	r3, r2
    25a4:	009b      	lsls	r3, r3, #2
    25a6:	4413      	add	r3, r2
    25a8:	009b      	lsls	r3, r3, #2
    25aa:	440b      	add	r3, r1
    25ac:	332c      	adds	r3, #44	; 0x2c
    25ae:	681a      	ldr	r2, [r3, #0]
    25b0:	4961      	ldr	r1, [pc, #388]	; (2738 <Clock_Ip_InitClock+0x584>)
    25b2:	4613      	mov	r3, r2
    25b4:	00db      	lsls	r3, r3, #3
    25b6:	4413      	add	r3, r2
    25b8:	440b      	add	r3, r1
    25ba:	3301      	adds	r3, #1
    25bc:	781b      	ldrb	r3, [r3, #0]
    25be:	461a      	mov	r2, r3
    25c0:	4b64      	ldr	r3, [pc, #400]	; (2754 <Clock_Ip_InitClock+0x5a0>)
    25c2:	5c9b      	ldrb	r3, [r3, r2]
    25c4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    25c6:	4964      	ldr	r1, [pc, #400]	; (2758 <Clock_Ip_InitClock+0x5a4>)
    25c8:	9a02      	ldr	r2, [sp, #8]
    25ca:	4613      	mov	r3, r2
    25cc:	009b      	lsls	r3, r3, #2
    25ce:	4413      	add	r3, r2
    25d0:	009b      	lsls	r3, r3, #2
    25d2:	440b      	add	r3, r1
    25d4:	3308      	adds	r3, #8
    25d6:	6819      	ldr	r1, [r3, #0]
    25d8:	9a03      	ldr	r2, [sp, #12]
    25da:	4613      	mov	r3, r2
    25dc:	009b      	lsls	r3, r3, #2
    25de:	4413      	add	r3, r2
    25e0:	009b      	lsls	r3, r3, #2
    25e2:	3328      	adds	r3, #40	; 0x28
    25e4:	9a01      	ldr	r2, [sp, #4]
    25e6:	4413      	add	r3, r2
    25e8:	3304      	adds	r3, #4
    25ea:	4618      	mov	r0, r3
    25ec:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    25ee:	9b03      	ldr	r3, [sp, #12]
    25f0:	3301      	adds	r3, #1
    25f2:	9303      	str	r3, [sp, #12]
    25f4:	9b01      	ldr	r3, [sp, #4]
    25f6:	7a5b      	ldrb	r3, [r3, #9]
    25f8:	461a      	mov	r2, r3
    25fa:	9b03      	ldr	r3, [sp, #12]
    25fc:	4293      	cmp	r3, r2
    25fe:	d3ce      	bcc.n	259e <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2600:	2300      	movs	r3, #0
    2602:	9303      	str	r3, [sp, #12]
    2604:	e029      	b.n	265a <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    2606:	9901      	ldr	r1, [sp, #4]
    2608:	9a03      	ldr	r2, [sp, #12]
    260a:	4613      	mov	r3, r2
    260c:	009b      	lsls	r3, r3, #2
    260e:	4413      	add	r3, r2
    2610:	00db      	lsls	r3, r3, #3
    2612:	440b      	add	r3, r1
    2614:	3340      	adds	r3, #64	; 0x40
    2616:	681a      	ldr	r2, [r3, #0]
    2618:	4947      	ldr	r1, [pc, #284]	; (2738 <Clock_Ip_InitClock+0x584>)
    261a:	4613      	mov	r3, r2
    261c:	00db      	lsls	r3, r3, #3
    261e:	4413      	add	r3, r2
    2620:	440b      	add	r3, r1
    2622:	3301      	adds	r3, #1
    2624:	781b      	ldrb	r3, [r3, #0]
    2626:	461a      	mov	r2, r3
    2628:	4b46      	ldr	r3, [pc, #280]	; (2744 <Clock_Ip_InitClock+0x590>)
    262a:	5c9b      	ldrb	r3, [r3, r2]
    262c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    262e:	4946      	ldr	r1, [pc, #280]	; (2748 <Clock_Ip_InitClock+0x594>)
    2630:	9a02      	ldr	r2, [sp, #8]
    2632:	4613      	mov	r3, r2
    2634:	009b      	lsls	r3, r3, #2
    2636:	4413      	add	r3, r2
    2638:	009b      	lsls	r3, r3, #2
    263a:	440b      	add	r3, r1
    263c:	330c      	adds	r3, #12
    263e:	6819      	ldr	r1, [r3, #0]
    2640:	9a03      	ldr	r2, [sp, #12]
    2642:	4613      	mov	r3, r2
    2644:	009b      	lsls	r3, r3, #2
    2646:	4413      	add	r3, r2
    2648:	00db      	lsls	r3, r3, #3
    264a:	3340      	adds	r3, #64	; 0x40
    264c:	9a01      	ldr	r2, [sp, #4]
    264e:	4413      	add	r3, r2
    2650:	4618      	mov	r0, r3
    2652:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2654:	9b03      	ldr	r3, [sp, #12]
    2656:	3301      	adds	r3, #1
    2658:	9303      	str	r3, [sp, #12]
    265a:	9b01      	ldr	r3, [sp, #4]
    265c:	7a9b      	ldrb	r3, [r3, #10]
    265e:	461a      	mov	r2, r3
    2660:	9b03      	ldr	r3, [sp, #12]
    2662:	4293      	cmp	r3, r2
    2664:	d3cf      	bcc.n	2606 <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    2666:	2300      	movs	r3, #0
    2668:	9303      	str	r3, [sp, #12]
    266a:	e025      	b.n	26b8 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    266c:	9a01      	ldr	r2, [sp, #4]
    266e:	9b03      	ldr	r3, [sp, #12]
    2670:	3324      	adds	r3, #36	; 0x24
    2672:	011b      	lsls	r3, r3, #4
    2674:	4413      	add	r3, r2
    2676:	3304      	adds	r3, #4
    2678:	681a      	ldr	r2, [r3, #0]
    267a:	492f      	ldr	r1, [pc, #188]	; (2738 <Clock_Ip_InitClock+0x584>)
    267c:	4613      	mov	r3, r2
    267e:	00db      	lsls	r3, r3, #3
    2680:	4413      	add	r3, r2
    2682:	440b      	add	r3, r1
    2684:	3301      	adds	r3, #1
    2686:	781b      	ldrb	r3, [r3, #0]
    2688:	461a      	mov	r2, r3
    268a:	4b34      	ldr	r3, [pc, #208]	; (275c <Clock_Ip_InitClock+0x5a8>)
    268c:	5c9b      	ldrb	r3, [r3, r2]
    268e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    2690:	4933      	ldr	r1, [pc, #204]	; (2760 <Clock_Ip_InitClock+0x5ac>)
    2692:	9a02      	ldr	r2, [sp, #8]
    2694:	4613      	mov	r3, r2
    2696:	005b      	lsls	r3, r3, #1
    2698:	4413      	add	r3, r2
    269a:	009b      	lsls	r3, r3, #2
    269c:	440b      	add	r3, r1
    269e:	3304      	adds	r3, #4
    26a0:	681b      	ldr	r3, [r3, #0]
    26a2:	9a03      	ldr	r2, [sp, #12]
    26a4:	3224      	adds	r2, #36	; 0x24
    26a6:	0112      	lsls	r2, r2, #4
    26a8:	9901      	ldr	r1, [sp, #4]
    26aa:	440a      	add	r2, r1
    26ac:	3204      	adds	r2, #4
    26ae:	4610      	mov	r0, r2
    26b0:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    26b2:	9b03      	ldr	r3, [sp, #12]
    26b4:	3301      	adds	r3, #1
    26b6:	9303      	str	r3, [sp, #12]
    26b8:	9b01      	ldr	r3, [sp, #4]
    26ba:	7b9b      	ldrb	r3, [r3, #14]
    26bc:	461a      	mov	r2, r3
    26be:	9b03      	ldr	r3, [sp, #12]
    26c0:	4293      	cmp	r3, r2
    26c2:	d3d3      	bcc.n	266c <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    26c4:	4b27      	ldr	r3, [pc, #156]	; (2764 <Clock_Ip_InitClock+0x5b0>)
    26c6:	2200      	movs	r2, #0
    26c8:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    26ca:	4b26      	ldr	r3, [pc, #152]	; (2764 <Clock_Ip_InitClock+0x5b0>)
    26cc:	2200      	movs	r2, #0
    26ce:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    26d0:	4b24      	ldr	r3, [pc, #144]	; (2764 <Clock_Ip_InitClock+0x5b0>)
    26d2:	2201      	movs	r2, #1
    26d4:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    26d6:	4b23      	ldr	r3, [pc, #140]	; (2764 <Clock_Ip_InitClock+0x5b0>)
    26d8:	2200      	movs	r2, #0
    26da:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    26dc:	f000 fa9c 	bl	2c18 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    26e0:	2300      	movs	r3, #0
    26e2:	9303      	str	r3, [sp, #12]
    26e4:	e04c      	b.n	2780 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    26e6:	9a01      	ldr	r2, [sp, #4]
    26e8:	9b03      	ldr	r3, [sp, #12]
    26ea:	330d      	adds	r3, #13
    26ec:	00db      	lsls	r3, r3, #3
    26ee:	4413      	add	r3, r2
    26f0:	685b      	ldr	r3, [r3, #4]
    26f2:	4a1d      	ldr	r2, [pc, #116]	; (2768 <Clock_Ip_InitClock+0x5b4>)
    26f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    26f8:	2b03      	cmp	r3, #3
    26fa:	d03b      	beq.n	2774 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    26fc:	9b01      	ldr	r3, [sp, #4]
    26fe:	9a03      	ldr	r2, [sp, #12]
    2700:	320d      	adds	r2, #13
    2702:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2706:	490c      	ldr	r1, [pc, #48]	; (2738 <Clock_Ip_InitClock+0x584>)
    2708:	4613      	mov	r3, r2
    270a:	00db      	lsls	r3, r3, #3
    270c:	4413      	add	r3, r2
    270e:	440b      	add	r3, r1
    2710:	3301      	adds	r3, #1
    2712:	781b      	ldrb	r3, [r3, #0]
    2714:	461a      	mov	r2, r3
    2716:	4b15      	ldr	r3, [pc, #84]	; (276c <Clock_Ip_InitClock+0x5b8>)
    2718:	5c9b      	ldrb	r3, [r3, r2]
    271a:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    271c:	4a14      	ldr	r2, [pc, #80]	; (2770 <Clock_Ip_InitClock+0x5bc>)
    271e:	9b02      	ldr	r3, [sp, #8]
    2720:	00db      	lsls	r3, r3, #3
    2722:	4413      	add	r3, r2
    2724:	685b      	ldr	r3, [r3, #4]
    2726:	9a03      	ldr	r2, [sp, #12]
    2728:	320d      	adds	r2, #13
    272a:	00d2      	lsls	r2, r2, #3
    272c:	9901      	ldr	r1, [sp, #4]
    272e:	440a      	add	r2, r1
    2730:	4610      	mov	r0, r2
    2732:	4798      	blx	r3
    2734:	e021      	b.n	277a <Clock_Ip_InitClock+0x5c6>
    2736:	bf00      	nop
    2738:	0000a740 	.word	0x0000a740
    273c:	0000a6b0 	.word	0x0000a6b0
    2740:	0000ac8c 	.word	0x0000ac8c
    2744:	0000a700 	.word	0x0000a700
    2748:	0000ad4c 	.word	0x0000ad4c
    274c:	0000a730 	.word	0x0000a730
    2750:	0000ad3c 	.word	0x0000ad3c
    2754:	0000a6c0 	.word	0x0000a6c0
    2758:	0000ac94 	.word	0x0000ac94
    275c:	0000a6f0 	.word	0x0000a6f0
    2760:	0000acbc 	.word	0x0000acbc
    2764:	1fff8b4c 	.word	0x1fff8b4c
    2768:	0000ab8c 	.word	0x0000ab8c
    276c:	0000a710 	.word	0x0000a710
    2770:	0000ad78 	.word	0x0000ad78
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    2774:	4b3a      	ldr	r3, [pc, #232]	; (2860 <Clock_Ip_InitClock+0x6ac>)
    2776:	2201      	movs	r2, #1
    2778:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    277a:	9b03      	ldr	r3, [sp, #12]
    277c:	3301      	adds	r3, #1
    277e:	9303      	str	r3, [sp, #12]
    2780:	9b01      	ldr	r3, [sp, #4]
    2782:	7adb      	ldrb	r3, [r3, #11]
    2784:	461a      	mov	r2, r3
    2786:	9b03      	ldr	r3, [sp, #12]
    2788:	4293      	cmp	r3, r2
    278a:	d3ac      	bcc.n	26e6 <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    278c:	4b34      	ldr	r3, [pc, #208]	; (2860 <Clock_Ip_InitClock+0x6ac>)
    278e:	781b      	ldrb	r3, [r3, #0]
    2790:	f083 0301 	eor.w	r3, r3, #1
    2794:	b2db      	uxtb	r3, r3
    2796:	2b00      	cmp	r3, #0
    2798:	d05e      	beq.n	2858 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    279a:	2300      	movs	r3, #0
    279c:	9303      	str	r3, [sp, #12]
    279e:	e01f      	b.n	27e0 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    27a0:	9a01      	ldr	r2, [sp, #4]
    27a2:	9b03      	ldr	r3, [sp, #12]
    27a4:	334e      	adds	r3, #78	; 0x4e
    27a6:	00db      	lsls	r3, r3, #3
    27a8:	4413      	add	r3, r2
    27aa:	685a      	ldr	r2, [r3, #4]
    27ac:	492d      	ldr	r1, [pc, #180]	; (2864 <Clock_Ip_InitClock+0x6b0>)
    27ae:	4613      	mov	r3, r2
    27b0:	00db      	lsls	r3, r3, #3
    27b2:	4413      	add	r3, r2
    27b4:	440b      	add	r3, r1
    27b6:	3301      	adds	r3, #1
    27b8:	781b      	ldrb	r3, [r3, #0]
    27ba:	461a      	mov	r2, r3
    27bc:	4b2a      	ldr	r3, [pc, #168]	; (2868 <Clock_Ip_InitClock+0x6b4>)
    27be:	5c9b      	ldrb	r3, [r3, r2]
    27c0:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    27c2:	4a2a      	ldr	r2, [pc, #168]	; (286c <Clock_Ip_InitClock+0x6b8>)
    27c4:	9b02      	ldr	r3, [sp, #8]
    27c6:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    27ca:	9a03      	ldr	r2, [sp, #12]
    27cc:	324e      	adds	r2, #78	; 0x4e
    27ce:	00d2      	lsls	r2, r2, #3
    27d0:	9901      	ldr	r1, [sp, #4]
    27d2:	440a      	add	r2, r1
    27d4:	3204      	adds	r2, #4
    27d6:	4610      	mov	r0, r2
    27d8:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    27da:	9b03      	ldr	r3, [sp, #12]
    27dc:	3301      	adds	r3, #1
    27de:	9303      	str	r3, [sp, #12]
    27e0:	9b01      	ldr	r3, [sp, #4]
    27e2:	7c1b      	ldrb	r3, [r3, #16]
    27e4:	461a      	mov	r2, r3
    27e6:	9b03      	ldr	r3, [sp, #12]
    27e8:	4293      	cmp	r3, r2
    27ea:	d3d9      	bcc.n	27a0 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    27ec:	2300      	movs	r3, #0
    27ee:	9303      	str	r3, [sp, #12]
    27f0:	e028      	b.n	2844 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    27f2:	9901      	ldr	r1, [sp, #4]
    27f4:	9a03      	ldr	r2, [sp, #12]
    27f6:	4613      	mov	r3, r2
    27f8:	009b      	lsls	r3, r3, #2
    27fa:	4413      	add	r3, r2
    27fc:	009b      	lsls	r3, r3, #2
    27fe:	440b      	add	r3, r1
    2800:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2804:	681a      	ldr	r2, [r3, #0]
    2806:	4917      	ldr	r1, [pc, #92]	; (2864 <Clock_Ip_InitClock+0x6b0>)
    2808:	4613      	mov	r3, r2
    280a:	00db      	lsls	r3, r3, #3
    280c:	4413      	add	r3, r2
    280e:	440b      	add	r3, r1
    2810:	3301      	adds	r3, #1
    2812:	781b      	ldrb	r3, [r3, #0]
    2814:	461a      	mov	r2, r3
    2816:	4b16      	ldr	r3, [pc, #88]	; (2870 <Clock_Ip_InitClock+0x6bc>)
    2818:	5c9b      	ldrb	r3, [r3, r2]
    281a:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    281c:	4a15      	ldr	r2, [pc, #84]	; (2874 <Clock_Ip_InitClock+0x6c0>)
    281e:	9b02      	ldr	r3, [sp, #8]
    2820:	011b      	lsls	r3, r3, #4
    2822:	4413      	add	r3, r2
    2824:	330c      	adds	r3, #12
    2826:	6819      	ldr	r1, [r3, #0]
    2828:	9a03      	ldr	r2, [sp, #12]
    282a:	4613      	mov	r3, r2
    282c:	009b      	lsls	r3, r3, #2
    282e:	4413      	add	r3, r2
    2830:	009b      	lsls	r3, r3, #2
    2832:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2836:	9a01      	ldr	r2, [sp, #4]
    2838:	4413      	add	r3, r2
    283a:	4618      	mov	r0, r3
    283c:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    283e:	9b03      	ldr	r3, [sp, #12]
    2840:	3301      	adds	r3, #1
    2842:	9303      	str	r3, [sp, #12]
    2844:	9b01      	ldr	r3, [sp, #4]
    2846:	7c9b      	ldrb	r3, [r3, #18]
    2848:	461a      	mov	r2, r3
    284a:	9b03      	ldr	r3, [sp, #12]
    284c:	4293      	cmp	r3, r2
    284e:	d3d0      	bcc.n	27f2 <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2850:	2104      	movs	r1, #4
    2852:	9801      	ldr	r0, [sp, #4]
    2854:	f002 ff48 	bl	56e8 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    2858:	bf00      	nop
    285a:	b004      	add	sp, #16
    285c:	bd10      	pop	{r4, pc}
    285e:	bf00      	nop
    2860:	1fff8b4c 	.word	0x1fff8b4c
    2864:	0000a740 	.word	0x0000a740
    2868:	0000a6e0 	.word	0x0000a6e0
    286c:	0000acc8 	.word	0x0000acc8
    2870:	0000a730 	.word	0x0000a730
    2874:	0000ad3c 	.word	0x0000ad3c

00002878 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    2878:	b500      	push	{lr}
    287a:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    287c:	2302      	movs	r3, #2
    287e:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2880:	2300      	movs	r3, #0
    2882:	9304      	str	r3, [sp, #16]
    2884:	e02c      	b.n	28e0 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    2886:	4a36      	ldr	r2, [pc, #216]	; (2960 <Clock_Ip_GetPllStatus+0xe8>)
    2888:	9b04      	ldr	r3, [sp, #16]
    288a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    288e:	4935      	ldr	r1, [pc, #212]	; (2964 <Clock_Ip_GetPllStatus+0xec>)
    2890:	4613      	mov	r3, r2
    2892:	00db      	lsls	r3, r3, #3
    2894:	4413      	add	r3, r2
    2896:	440b      	add	r3, r1
    2898:	3301      	adds	r3, #1
    289a:	781b      	ldrb	r3, [r3, #0]
    289c:	461a      	mov	r2, r3
    289e:	4b32      	ldr	r3, [pc, #200]	; (2968 <Clock_Ip_GetPllStatus+0xf0>)
    28a0:	5c9b      	ldrb	r3, [r3, r2]
    28a2:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    28a4:	4931      	ldr	r1, [pc, #196]	; (296c <Clock_Ip_GetPllStatus+0xf4>)
    28a6:	9a03      	ldr	r2, [sp, #12]
    28a8:	4613      	mov	r3, r2
    28aa:	009b      	lsls	r3, r3, #2
    28ac:	4413      	add	r3, r2
    28ae:	009b      	lsls	r3, r3, #2
    28b0:	440b      	add	r3, r1
    28b2:	3308      	adds	r3, #8
    28b4:	681b      	ldr	r3, [r3, #0]
    28b6:	492a      	ldr	r1, [pc, #168]	; (2960 <Clock_Ip_GetPllStatus+0xe8>)
    28b8:	9a04      	ldr	r2, [sp, #16]
    28ba:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    28be:	4610      	mov	r0, r2
    28c0:	4798      	blx	r3
    28c2:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    28c4:	9b02      	ldr	r3, [sp, #8]
    28c6:	2b01      	cmp	r3, #1
    28c8:	d102      	bne.n	28d0 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    28ca:	2301      	movs	r3, #1
    28cc:	9305      	str	r3, [sp, #20]
            break;
    28ce:	e00d      	b.n	28ec <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    28d0:	9b02      	ldr	r3, [sp, #8]
    28d2:	2b02      	cmp	r3, #2
    28d4:	d101      	bne.n	28da <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    28d6:	2300      	movs	r3, #0
    28d8:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    28da:	9b04      	ldr	r3, [sp, #16]
    28dc:	3301      	adds	r3, #1
    28de:	9304      	str	r3, [sp, #16]
    28e0:	4b23      	ldr	r3, [pc, #140]	; (2970 <Clock_Ip_GetPllStatus+0xf8>)
    28e2:	789b      	ldrb	r3, [r3, #2]
    28e4:	461a      	mov	r2, r3
    28e6:	9b04      	ldr	r3, [sp, #16]
    28e8:	4293      	cmp	r3, r2
    28ea:	d3cc      	bcc.n	2886 <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    28ec:	9b05      	ldr	r3, [sp, #20]
    28ee:	2b00      	cmp	r3, #0
    28f0:	d130      	bne.n	2954 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    28f2:	2300      	movs	r3, #0
    28f4:	9304      	str	r3, [sp, #16]
    28f6:	e027      	b.n	2948 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    28f8:	4a1e      	ldr	r2, [pc, #120]	; (2974 <Clock_Ip_GetPllStatus+0xfc>)
    28fa:	9b04      	ldr	r3, [sp, #16]
    28fc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2900:	4918      	ldr	r1, [pc, #96]	; (2964 <Clock_Ip_GetPllStatus+0xec>)
    2902:	4613      	mov	r3, r2
    2904:	00db      	lsls	r3, r3, #3
    2906:	4413      	add	r3, r2
    2908:	440b      	add	r3, r1
    290a:	3301      	adds	r3, #1
    290c:	781b      	ldrb	r3, [r3, #0]
    290e:	461a      	mov	r2, r3
    2910:	4b19      	ldr	r3, [pc, #100]	; (2978 <Clock_Ip_GetPllStatus+0x100>)
    2912:	5c9b      	ldrb	r3, [r3, r2]
    2914:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    2916:	4919      	ldr	r1, [pc, #100]	; (297c <Clock_Ip_GetPllStatus+0x104>)
    2918:	9a03      	ldr	r2, [sp, #12]
    291a:	4613      	mov	r3, r2
    291c:	005b      	lsls	r3, r3, #1
    291e:	4413      	add	r3, r2
    2920:	009b      	lsls	r3, r3, #2
    2922:	440b      	add	r3, r1
    2924:	3308      	adds	r3, #8
    2926:	681b      	ldr	r3, [r3, #0]
    2928:	4912      	ldr	r1, [pc, #72]	; (2974 <Clock_Ip_GetPllStatus+0xfc>)
    292a:	9a04      	ldr	r2, [sp, #16]
    292c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2930:	4610      	mov	r0, r2
    2932:	4798      	blx	r3
    2934:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    2936:	9b01      	ldr	r3, [sp, #4]
    2938:	2b01      	cmp	r3, #1
    293a:	d102      	bne.n	2942 <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    293c:	2301      	movs	r3, #1
    293e:	9305      	str	r3, [sp, #20]
                break;
    2940:	e008      	b.n	2954 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2942:	9b04      	ldr	r3, [sp, #16]
    2944:	3301      	adds	r3, #1
    2946:	9304      	str	r3, [sp, #16]
    2948:	4b09      	ldr	r3, [pc, #36]	; (2970 <Clock_Ip_GetPllStatus+0xf8>)
    294a:	78db      	ldrb	r3, [r3, #3]
    294c:	461a      	mov	r2, r3
    294e:	9b04      	ldr	r3, [sp, #16]
    2950:	4293      	cmp	r3, r2
    2952:	d3d1      	bcc.n	28f8 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    2954:	9b05      	ldr	r3, [sp, #20]
}
    2956:	4618      	mov	r0, r3
    2958:	b007      	add	sp, #28
    295a:	f85d fb04 	ldr.w	pc, [sp], #4
    295e:	bf00      	nop
    2960:	0000ac48 	.word	0x0000ac48
    2964:	0000a740 	.word	0x0000a740
    2968:	0000a700 	.word	0x0000a700
    296c:	0000ad4c 	.word	0x0000ad4c
    2970:	1fff8b4c 	.word	0x1fff8b4c
    2974:	0000ac4c 	.word	0x0000ac4c
    2978:	0000a6f0 	.word	0x0000a6f0
    297c:	0000acbc 	.word	0x0000acbc

00002980 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    2980:	b500      	push	{lr}
    2982:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2984:	4b55      	ldr	r3, [pc, #340]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2986:	681b      	ldr	r3, [r3, #0]
    2988:	2b00      	cmp	r3, #0
    298a:	f000 80a2 	beq.w	2ad2 <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    298e:	2300      	movs	r3, #0
    2990:	9301      	str	r3, [sp, #4]
    2992:	e02c      	b.n	29ee <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    2994:	4b51      	ldr	r3, [pc, #324]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2996:	681a      	ldr	r2, [r3, #0]
    2998:	9b01      	ldr	r3, [sp, #4]
    299a:	330d      	adds	r3, #13
    299c:	00db      	lsls	r3, r3, #3
    299e:	4413      	add	r3, r2
    29a0:	685b      	ldr	r3, [r3, #4]
    29a2:	4a4f      	ldr	r2, [pc, #316]	; (2ae0 <Clock_Ip_DistributePll+0x160>)
    29a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    29a8:	2b03      	cmp	r3, #3
    29aa:	d11d      	bne.n	29e8 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    29ac:	4b4b      	ldr	r3, [pc, #300]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    29ae:	681b      	ldr	r3, [r3, #0]
    29b0:	9a01      	ldr	r2, [sp, #4]
    29b2:	320d      	adds	r2, #13
    29b4:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    29b8:	494a      	ldr	r1, [pc, #296]	; (2ae4 <Clock_Ip_DistributePll+0x164>)
    29ba:	4613      	mov	r3, r2
    29bc:	00db      	lsls	r3, r3, #3
    29be:	4413      	add	r3, r2
    29c0:	440b      	add	r3, r1
    29c2:	3301      	adds	r3, #1
    29c4:	781b      	ldrb	r3, [r3, #0]
    29c6:	461a      	mov	r2, r3
    29c8:	4b47      	ldr	r3, [pc, #284]	; (2ae8 <Clock_Ip_DistributePll+0x168>)
    29ca:	5c9b      	ldrb	r3, [r3, r2]
    29cc:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    29ce:	4a47      	ldr	r2, [pc, #284]	; (2aec <Clock_Ip_DistributePll+0x16c>)
    29d0:	9b00      	ldr	r3, [sp, #0]
    29d2:	00db      	lsls	r3, r3, #3
    29d4:	4413      	add	r3, r2
    29d6:	685b      	ldr	r3, [r3, #4]
    29d8:	4a40      	ldr	r2, [pc, #256]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    29da:	6811      	ldr	r1, [r2, #0]
    29dc:	9a01      	ldr	r2, [sp, #4]
    29de:	320d      	adds	r2, #13
    29e0:	00d2      	lsls	r2, r2, #3
    29e2:	440a      	add	r2, r1
    29e4:	4610      	mov	r0, r2
    29e6:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    29e8:	9b01      	ldr	r3, [sp, #4]
    29ea:	3301      	adds	r3, #1
    29ec:	9301      	str	r3, [sp, #4]
    29ee:	4b3b      	ldr	r3, [pc, #236]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    29f0:	681b      	ldr	r3, [r3, #0]
    29f2:	7adb      	ldrb	r3, [r3, #11]
    29f4:	461a      	mov	r2, r3
    29f6:	9b01      	ldr	r3, [sp, #4]
    29f8:	4293      	cmp	r3, r2
    29fa:	d3cb      	bcc.n	2994 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    29fc:	4b3c      	ldr	r3, [pc, #240]	; (2af0 <Clock_Ip_DistributePll+0x170>)
    29fe:	781b      	ldrb	r3, [r3, #0]
    2a00:	2b00      	cmp	r3, #0
    2a02:	d066      	beq.n	2ad2 <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2a04:	2300      	movs	r3, #0
    2a06:	9301      	str	r3, [sp, #4]
    2a08:	e021      	b.n	2a4e <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2a0a:	4b34      	ldr	r3, [pc, #208]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2a0c:	681a      	ldr	r2, [r3, #0]
    2a0e:	9b01      	ldr	r3, [sp, #4]
    2a10:	334e      	adds	r3, #78	; 0x4e
    2a12:	00db      	lsls	r3, r3, #3
    2a14:	4413      	add	r3, r2
    2a16:	685a      	ldr	r2, [r3, #4]
    2a18:	4932      	ldr	r1, [pc, #200]	; (2ae4 <Clock_Ip_DistributePll+0x164>)
    2a1a:	4613      	mov	r3, r2
    2a1c:	00db      	lsls	r3, r3, #3
    2a1e:	4413      	add	r3, r2
    2a20:	440b      	add	r3, r1
    2a22:	3301      	adds	r3, #1
    2a24:	781b      	ldrb	r3, [r3, #0]
    2a26:	461a      	mov	r2, r3
    2a28:	4b32      	ldr	r3, [pc, #200]	; (2af4 <Clock_Ip_DistributePll+0x174>)
    2a2a:	5c9b      	ldrb	r3, [r3, r2]
    2a2c:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    2a2e:	4a32      	ldr	r2, [pc, #200]	; (2af8 <Clock_Ip_DistributePll+0x178>)
    2a30:	9b00      	ldr	r3, [sp, #0]
    2a32:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2a36:	4a29      	ldr	r2, [pc, #164]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2a38:	6811      	ldr	r1, [r2, #0]
    2a3a:	9a01      	ldr	r2, [sp, #4]
    2a3c:	324e      	adds	r2, #78	; 0x4e
    2a3e:	00d2      	lsls	r2, r2, #3
    2a40:	440a      	add	r2, r1
    2a42:	3204      	adds	r2, #4
    2a44:	4610      	mov	r0, r2
    2a46:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2a48:	9b01      	ldr	r3, [sp, #4]
    2a4a:	3301      	adds	r3, #1
    2a4c:	9301      	str	r3, [sp, #4]
    2a4e:	4b23      	ldr	r3, [pc, #140]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2a50:	681b      	ldr	r3, [r3, #0]
    2a52:	7c1b      	ldrb	r3, [r3, #16]
    2a54:	461a      	mov	r2, r3
    2a56:	9b01      	ldr	r3, [sp, #4]
    2a58:	4293      	cmp	r3, r2
    2a5a:	d3d6      	bcc.n	2a0a <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2a5c:	2300      	movs	r3, #0
    2a5e:	9301      	str	r3, [sp, #4]
    2a60:	e02a      	b.n	2ab8 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2a62:	4b1e      	ldr	r3, [pc, #120]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2a64:	6819      	ldr	r1, [r3, #0]
    2a66:	9a01      	ldr	r2, [sp, #4]
    2a68:	4613      	mov	r3, r2
    2a6a:	009b      	lsls	r3, r3, #2
    2a6c:	4413      	add	r3, r2
    2a6e:	009b      	lsls	r3, r3, #2
    2a70:	440b      	add	r3, r1
    2a72:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2a76:	681a      	ldr	r2, [r3, #0]
    2a78:	491a      	ldr	r1, [pc, #104]	; (2ae4 <Clock_Ip_DistributePll+0x164>)
    2a7a:	4613      	mov	r3, r2
    2a7c:	00db      	lsls	r3, r3, #3
    2a7e:	4413      	add	r3, r2
    2a80:	440b      	add	r3, r1
    2a82:	3301      	adds	r3, #1
    2a84:	781b      	ldrb	r3, [r3, #0]
    2a86:	461a      	mov	r2, r3
    2a88:	4b1c      	ldr	r3, [pc, #112]	; (2afc <Clock_Ip_DistributePll+0x17c>)
    2a8a:	5c9b      	ldrb	r3, [r3, r2]
    2a8c:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    2a8e:	4a1c      	ldr	r2, [pc, #112]	; (2b00 <Clock_Ip_DistributePll+0x180>)
    2a90:	9b00      	ldr	r3, [sp, #0]
    2a92:	011b      	lsls	r3, r3, #4
    2a94:	4413      	add	r3, r2
    2a96:	330c      	adds	r3, #12
    2a98:	6819      	ldr	r1, [r3, #0]
    2a9a:	4b10      	ldr	r3, [pc, #64]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2a9c:	6818      	ldr	r0, [r3, #0]
    2a9e:	9a01      	ldr	r2, [sp, #4]
    2aa0:	4613      	mov	r3, r2
    2aa2:	009b      	lsls	r3, r3, #2
    2aa4:	4413      	add	r3, r2
    2aa6:	009b      	lsls	r3, r3, #2
    2aa8:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2aac:	4403      	add	r3, r0
    2aae:	4618      	mov	r0, r3
    2ab0:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2ab2:	9b01      	ldr	r3, [sp, #4]
    2ab4:	3301      	adds	r3, #1
    2ab6:	9301      	str	r3, [sp, #4]
    2ab8:	4b08      	ldr	r3, [pc, #32]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2aba:	681b      	ldr	r3, [r3, #0]
    2abc:	7c9b      	ldrb	r3, [r3, #18]
    2abe:	461a      	mov	r2, r3
    2ac0:	9b01      	ldr	r3, [sp, #4]
    2ac2:	4293      	cmp	r3, r2
    2ac4:	d3cd      	bcc.n	2a62 <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2ac6:	4b05      	ldr	r3, [pc, #20]	; (2adc <Clock_Ip_DistributePll+0x15c>)
    2ac8:	681b      	ldr	r3, [r3, #0]
    2aca:	2104      	movs	r1, #4
    2acc:	4618      	mov	r0, r3
    2ace:	f002 fe0b 	bl	56e8 <Clock_Ip_Command>
        }
    }
}
    2ad2:	bf00      	nop
    2ad4:	b003      	add	sp, #12
    2ad6:	f85d fb04 	ldr.w	pc, [sp], #4
    2ada:	bf00      	nop
    2adc:	1fff8b44 	.word	0x1fff8b44
    2ae0:	0000ab8c 	.word	0x0000ab8c
    2ae4:	0000a740 	.word	0x0000a740
    2ae8:	0000a710 	.word	0x0000a710
    2aec:	0000ad78 	.word	0x0000ad78
    2af0:	1fff8b4c 	.word	0x1fff8b4c
    2af4:	0000a6e0 	.word	0x0000a6e0
    2af8:	0000acc8 	.word	0x0000acc8
    2afc:	0000a730 	.word	0x0000a730
    2b00:	0000ad3c 	.word	0x0000ad3c

00002b04 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    2b04:	b500      	push	{lr}
    2b06:	b085      	sub	sp, #20
    2b08:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2b0a:	490c      	ldr	r1, [pc, #48]	; (2b3c <Clock_Ip_DisableClockMonitor+0x38>)
    2b0c:	9a01      	ldr	r2, [sp, #4]
    2b0e:	4613      	mov	r3, r2
    2b10:	00db      	lsls	r3, r3, #3
    2b12:	4413      	add	r3, r2
    2b14:	440b      	add	r3, r1
    2b16:	3301      	adds	r3, #1
    2b18:	781b      	ldrb	r3, [r3, #0]
    2b1a:	461a      	mov	r2, r3
    2b1c:	4b08      	ldr	r3, [pc, #32]	; (2b40 <Clock_Ip_DisableClockMonitor+0x3c>)
    2b1e:	5c9b      	ldrb	r3, [r3, r2]
    2b20:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    2b22:	4a08      	ldr	r2, [pc, #32]	; (2b44 <Clock_Ip_DisableClockMonitor+0x40>)
    2b24:	9b03      	ldr	r3, [sp, #12]
    2b26:	011b      	lsls	r3, r3, #4
    2b28:	4413      	add	r3, r2
    2b2a:	3308      	adds	r3, #8
    2b2c:	681b      	ldr	r3, [r3, #0]
    2b2e:	9801      	ldr	r0, [sp, #4]
    2b30:	4798      	blx	r3
}
    2b32:	bf00      	nop
    2b34:	b005      	add	sp, #20
    2b36:	f85d fb04 	ldr.w	pc, [sp], #4
    2b3a:	bf00      	nop
    2b3c:	0000a740 	.word	0x0000a740
    2b40:	0000a730 	.word	0x0000a730
    2b44:	0000ad3c 	.word	0x0000ad3c

00002b48 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    2b48:	b082      	sub	sp, #8
    2b4a:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    2b4c:	4a02      	ldr	r2, [pc, #8]	; (2b58 <Clock_Ip_InstallNotificationsCallback+0x10>)
    2b4e:	9b01      	ldr	r3, [sp, #4]
    2b50:	6013      	str	r3, [r2, #0]
}
    2b52:	bf00      	nop
    2b54:	b002      	add	sp, #8
    2b56:	4770      	bx	lr
    2b58:	1fff8b14 	.word	0x1fff8b14

00002b5c <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    2b5c:	b500      	push	{lr}
    2b5e:	b085      	sub	sp, #20
    2b60:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2b62:	490c      	ldr	r1, [pc, #48]	; (2b94 <Clock_Ip_DisableModuleClock+0x38>)
    2b64:	9a01      	ldr	r2, [sp, #4]
    2b66:	4613      	mov	r3, r2
    2b68:	00db      	lsls	r3, r3, #3
    2b6a:	4413      	add	r3, r2
    2b6c:	440b      	add	r3, r1
    2b6e:	3301      	adds	r3, #1
    2b70:	781b      	ldrb	r3, [r3, #0]
    2b72:	461a      	mov	r2, r3
    2b74:	4b08      	ldr	r3, [pc, #32]	; (2b98 <Clock_Ip_DisableModuleClock+0x3c>)
    2b76:	5c9b      	ldrb	r3, [r3, r2]
    2b78:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    2b7a:	4a08      	ldr	r2, [pc, #32]	; (2b9c <Clock_Ip_DisableModuleClock+0x40>)
    2b7c:	9b03      	ldr	r3, [sp, #12]
    2b7e:	00db      	lsls	r3, r3, #3
    2b80:	4413      	add	r3, r2
    2b82:	685b      	ldr	r3, [r3, #4]
    2b84:	2101      	movs	r1, #1
    2b86:	9801      	ldr	r0, [sp, #4]
    2b88:	4798      	blx	r3
}
    2b8a:	bf00      	nop
    2b8c:	b005      	add	sp, #20
    2b8e:	f85d fb04 	ldr.w	pc, [sp], #4
    2b92:	bf00      	nop
    2b94:	0000a740 	.word	0x0000a740
    2b98:	0000a6e0 	.word	0x0000a6e0
    2b9c:	0000acc8 	.word	0x0000acc8

00002ba0 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    2ba0:	b500      	push	{lr}
    2ba2:	b085      	sub	sp, #20
    2ba4:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2ba6:	490c      	ldr	r1, [pc, #48]	; (2bd8 <Clock_Ip_EnableModuleClock+0x38>)
    2ba8:	9a01      	ldr	r2, [sp, #4]
    2baa:	4613      	mov	r3, r2
    2bac:	00db      	lsls	r3, r3, #3
    2bae:	4413      	add	r3, r2
    2bb0:	440b      	add	r3, r1
    2bb2:	3301      	adds	r3, #1
    2bb4:	781b      	ldrb	r3, [r3, #0]
    2bb6:	461a      	mov	r2, r3
    2bb8:	4b08      	ldr	r3, [pc, #32]	; (2bdc <Clock_Ip_EnableModuleClock+0x3c>)
    2bba:	5c9b      	ldrb	r3, [r3, r2]
    2bbc:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    2bbe:	4a08      	ldr	r2, [pc, #32]	; (2be0 <Clock_Ip_EnableModuleClock+0x40>)
    2bc0:	9b03      	ldr	r3, [sp, #12]
    2bc2:	00db      	lsls	r3, r3, #3
    2bc4:	4413      	add	r3, r2
    2bc6:	685b      	ldr	r3, [r3, #4]
    2bc8:	2100      	movs	r1, #0
    2bca:	9801      	ldr	r0, [sp, #4]
    2bcc:	4798      	blx	r3
}
    2bce:	bf00      	nop
    2bd0:	b005      	add	sp, #20
    2bd2:	f85d fb04 	ldr.w	pc, [sp], #4
    2bd6:	bf00      	nop
    2bd8:	0000a740 	.word	0x0000a740
    2bdc:	0000a6e0 	.word	0x0000a6e0
    2be0:	0000acc8 	.word	0x0000acc8

00002be4 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    2be4:	b500      	push	{lr}
    2be6:	b083      	sub	sp, #12
    2be8:	9001      	str	r0, [sp, #4]
    2bea:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    2bec:	4b08      	ldr	r3, [pc, #32]	; (2c10 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    2bee:	2200      	movs	r2, #0
    2bf0:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2bf2:	4b08      	ldr	r3, [pc, #32]	; (2c14 <Clock_Ip_PowerModeChangeNotification+0x30>)
    2bf4:	681b      	ldr	r3, [r3, #0]
    2bf6:	2102      	movs	r1, #2
    2bf8:	4618      	mov	r0, r3
    2bfa:	f002 fd75 	bl	56e8 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    2bfe:	9900      	ldr	r1, [sp, #0]
    2c00:	9801      	ldr	r0, [sp, #4]
    2c02:	f002 fc51 	bl	54a8 <Clock_Ip_ClockPowerModeChangeNotification>
}
    2c06:	bf00      	nop
    2c08:	b003      	add	sp, #12
    2c0a:	f85d fb04 	ldr.w	pc, [sp], #4
    2c0e:	bf00      	nop
    2c10:	1fff8b10 	.word	0x1fff8b10
    2c14:	1fff8b44 	.word	0x1fff8b44

00002c18 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    2c18:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    2c1a:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    2c1e:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    2c20:	4b06      	ldr	r3, [pc, #24]	; (2c3c <Clock_Ip_SetWaitStates+0x24>)
    2c22:	785b      	ldrb	r3, [r3, #1]
    2c24:	2b00      	cmp	r3, #0
    2c26:	d005      	beq.n	2c34 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    2c28:	9b01      	ldr	r3, [sp, #4]
    2c2a:	3b01      	subs	r3, #1
    2c2c:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    2c2e:	9b01      	ldr	r3, [sp, #4]
    2c30:	2b00      	cmp	r3, #0
    2c32:	d1f9      	bne.n	2c28 <Clock_Ip_SetWaitStates+0x10>
    }
}
    2c34:	bf00      	nop
    2c36:	b002      	add	sp, #8
    2c38:	4770      	bx	lr
    2c3a:	bf00      	nop
    2c3c:	1fff8b4c 	.word	0x1fff8b4c

00002c40 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    2c40:	b500      	push	{lr}
    2c42:	b083      	sub	sp, #12
    2c44:	9001      	str	r0, [sp, #4]
    2c46:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    2c48:	4b04      	ldr	r3, [pc, #16]	; (2c5c <Clock_Ip_ReportClockErrors+0x1c>)
    2c4a:	681b      	ldr	r3, [r3, #0]
    2c4c:	9900      	ldr	r1, [sp, #0]
    2c4e:	9801      	ldr	r0, [sp, #4]
    2c50:	4798      	blx	r3
}
    2c52:	bf00      	nop
    2c54:	b003      	add	sp, #12
    2c56:	f85d fb04 	ldr.w	pc, [sp], #4
    2c5a:	bf00      	nop
    2c5c:	1fff8b14 	.word	0x1fff8b14

00002c60 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    2c60:	b500      	push	{lr}
    2c62:	b085      	sub	sp, #20
    2c64:	9003      	str	r0, [sp, #12]
    2c66:	9102      	str	r1, [sp, #8]
    2c68:	9201      	str	r2, [sp, #4]
    2c6a:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    2c6c:	2000      	movs	r0, #0
    2c6e:	f7fe ffd1 	bl	1c14 <OsIf_GetCounter>
    2c72:	4602      	mov	r2, r0
    2c74:	9b03      	ldr	r3, [sp, #12]
    2c76:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    2c78:	9b02      	ldr	r3, [sp, #8]
    2c7a:	2200      	movs	r2, #0
    2c7c:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    2c7e:	2100      	movs	r1, #0
    2c80:	9800      	ldr	r0, [sp, #0]
    2c82:	f7ff f813 	bl	1cac <OsIf_MicrosToTicks>
    2c86:	4602      	mov	r2, r0
    2c88:	9b01      	ldr	r3, [sp, #4]
    2c8a:	601a      	str	r2, [r3, #0]
}
    2c8c:	bf00      	nop
    2c8e:	b005      	add	sp, #20
    2c90:	f85d fb04 	ldr.w	pc, [sp], #4

00002c94 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    2c94:	b500      	push	{lr}
    2c96:	b087      	sub	sp, #28
    2c98:	9003      	str	r0, [sp, #12]
    2c9a:	9102      	str	r1, [sp, #8]
    2c9c:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    2c9e:	2300      	movs	r3, #0
    2ca0:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    2ca4:	2100      	movs	r1, #0
    2ca6:	9803      	ldr	r0, [sp, #12]
    2ca8:	f7fe ffcd 	bl	1c46 <OsIf_GetElapsed>
    2cac:	4602      	mov	r2, r0
    2cae:	9b02      	ldr	r3, [sp, #8]
    2cb0:	681b      	ldr	r3, [r3, #0]
    2cb2:	441a      	add	r2, r3
    2cb4:	9b02      	ldr	r3, [sp, #8]
    2cb6:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    2cb8:	9b02      	ldr	r3, [sp, #8]
    2cba:	681b      	ldr	r3, [r3, #0]
    2cbc:	9a01      	ldr	r2, [sp, #4]
    2cbe:	429a      	cmp	r2, r3
    2cc0:	d802      	bhi.n	2cc8 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    2cc2:	2301      	movs	r3, #1
    2cc4:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    2cc8:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    2ccc:	4618      	mov	r0, r3
    2cce:	b007      	add	sp, #28
    2cd0:	f85d fb04 	ldr.w	pc, [sp], #4

00002cd4 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    2cd4:	b082      	sub	sp, #8
    2cd6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2cd8:	bf00      	nop
    2cda:	b002      	add	sp, #8
    2cdc:	4770      	bx	lr

00002cde <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    2cde:	b500      	push	{lr}
    2ce0:	b083      	sub	sp, #12
    2ce2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ce4:	9b01      	ldr	r3, [sp, #4]
    2ce6:	2b00      	cmp	r3, #0
    2ce8:	d002      	beq.n	2cf0 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    2cea:	9801      	ldr	r0, [sp, #4]
    2cec:	f000 f8ad 	bl	2e4a <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cf0:	bf00      	nop
    2cf2:	b003      	add	sp, #12
    2cf4:	f85d fb04 	ldr.w	pc, [sp], #4

00002cf8 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    2cf8:	b500      	push	{lr}
    2cfa:	b083      	sub	sp, #12
    2cfc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2cfe:	9b01      	ldr	r3, [sp, #4]
    2d00:	2b00      	cmp	r3, #0
    2d02:	d002      	beq.n	2d0a <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    2d04:	9801      	ldr	r0, [sp, #4]
    2d06:	f000 f8cd 	bl	2ea4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d0a:	bf00      	nop
    2d0c:	b003      	add	sp, #12
    2d0e:	f85d fb04 	ldr.w	pc, [sp], #4

00002d12 <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2d12:	b500      	push	{lr}
    2d14:	b083      	sub	sp, #12
    2d16:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d18:	9b01      	ldr	r3, [sp, #4]
    2d1a:	2b00      	cmp	r3, #0
    2d1c:	d002      	beq.n	2d24 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    2d1e:	9801      	ldr	r0, [sp, #4]
    2d20:	f000 f8ee 	bl	2f00 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d24:	bf00      	nop
    2d26:	b003      	add	sp, #12
    2d28:	f85d fb04 	ldr.w	pc, [sp], #4

00002d2c <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2d2c:	b500      	push	{lr}
    2d2e:	b083      	sub	sp, #12
    2d30:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d32:	9b01      	ldr	r3, [sp, #4]
    2d34:	2b00      	cmp	r3, #0
    2d36:	d002      	beq.n	2d3e <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    2d38:	9801      	ldr	r0, [sp, #4]
    2d3a:	f000 f8f9 	bl	2f30 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d3e:	bf00      	nop
    2d40:	b003      	add	sp, #12
    2d42:	f85d fb04 	ldr.w	pc, [sp], #4

00002d46 <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2d46:	b500      	push	{lr}
    2d48:	b083      	sub	sp, #12
    2d4a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d4c:	9b01      	ldr	r3, [sp, #4]
    2d4e:	2b00      	cmp	r3, #0
    2d50:	d002      	beq.n	2d58 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    2d52:	9801      	ldr	r0, [sp, #4]
    2d54:	f000 f904 	bl	2f60 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d58:	bf00      	nop
    2d5a:	b003      	add	sp, #12
    2d5c:	f85d fb04 	ldr.w	pc, [sp], #4

00002d60 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2d60:	b500      	push	{lr}
    2d62:	b083      	sub	sp, #12
    2d64:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d66:	9b01      	ldr	r3, [sp, #4]
    2d68:	2b00      	cmp	r3, #0
    2d6a:	d002      	beq.n	2d72 <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    2d6c:	9801      	ldr	r0, [sp, #4]
    2d6e:	f000 f90f 	bl	2f90 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d72:	bf00      	nop
    2d74:	b003      	add	sp, #12
    2d76:	f85d fb04 	ldr.w	pc, [sp], #4

00002d7a <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2d7a:	b500      	push	{lr}
    2d7c:	b083      	sub	sp, #12
    2d7e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d80:	9b01      	ldr	r3, [sp, #4]
    2d82:	2b00      	cmp	r3, #0
    2d84:	d002      	beq.n	2d8c <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    2d86:	9801      	ldr	r0, [sp, #4]
    2d88:	f000 f91a 	bl	2fc0 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d8c:	bf00      	nop
    2d8e:	b003      	add	sp, #12
    2d90:	f85d fb04 	ldr.w	pc, [sp], #4

00002d94 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2d94:	b500      	push	{lr}
    2d96:	b083      	sub	sp, #12
    2d98:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d9a:	9b01      	ldr	r3, [sp, #4]
    2d9c:	2b00      	cmp	r3, #0
    2d9e:	d002      	beq.n	2da6 <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    2da0:	9801      	ldr	r0, [sp, #4]
    2da2:	f000 f925 	bl	2ff0 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2da6:	bf00      	nop
    2da8:	b003      	add	sp, #12
    2daa:	f85d fb04 	ldr.w	pc, [sp], #4

00002dae <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2dae:	b500      	push	{lr}
    2db0:	b083      	sub	sp, #12
    2db2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2db4:	9b01      	ldr	r3, [sp, #4]
    2db6:	2b00      	cmp	r3, #0
    2db8:	d002      	beq.n	2dc0 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    2dba:	9801      	ldr	r0, [sp, #4]
    2dbc:	f000 f930 	bl	3020 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2dc0:	bf00      	nop
    2dc2:	b003      	add	sp, #12
    2dc4:	f85d fb04 	ldr.w	pc, [sp], #4

00002dc8 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2dc8:	b500      	push	{lr}
    2dca:	b083      	sub	sp, #12
    2dcc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2dce:	9b01      	ldr	r3, [sp, #4]
    2dd0:	2b00      	cmp	r3, #0
    2dd2:	d002      	beq.n	2dda <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    2dd4:	9801      	ldr	r0, [sp, #4]
    2dd6:	f000 f93b 	bl	3050 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2dda:	bf00      	nop
    2ddc:	b003      	add	sp, #12
    2dde:	f85d fb04 	ldr.w	pc, [sp], #4

00002de2 <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2de2:	b500      	push	{lr}
    2de4:	b083      	sub	sp, #12
    2de6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2de8:	9b01      	ldr	r3, [sp, #4]
    2dea:	2b00      	cmp	r3, #0
    2dec:	d002      	beq.n	2df4 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    2dee:	9801      	ldr	r0, [sp, #4]
    2df0:	f000 f946 	bl	3080 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2df4:	bf00      	nop
    2df6:	b003      	add	sp, #12
    2df8:	f85d fb04 	ldr.w	pc, [sp], #4

00002dfc <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    2dfc:	b500      	push	{lr}
    2dfe:	b083      	sub	sp, #12
    2e00:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e02:	9b01      	ldr	r3, [sp, #4]
    2e04:	2b00      	cmp	r3, #0
    2e06:	d002      	beq.n	2e0e <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    2e08:	9801      	ldr	r0, [sp, #4]
    2e0a:	f000 f951 	bl	30b0 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e0e:	bf00      	nop
    2e10:	b003      	add	sp, #12
    2e12:	f85d fb04 	ldr.w	pc, [sp], #4

00002e16 <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    2e16:	b500      	push	{lr}
    2e18:	b083      	sub	sp, #12
    2e1a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e1c:	9b01      	ldr	r3, [sp, #4]
    2e1e:	2b00      	cmp	r3, #0
    2e20:	d002      	beq.n	2e28 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    2e22:	9801      	ldr	r0, [sp, #4]
    2e24:	f000 f95e 	bl	30e4 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e28:	bf00      	nop
    2e2a:	b003      	add	sp, #12
    2e2c:	f85d fb04 	ldr.w	pc, [sp], #4

00002e30 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    2e30:	b500      	push	{lr}
    2e32:	b083      	sub	sp, #12
    2e34:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e36:	9b01      	ldr	r3, [sp, #4]
    2e38:	2b00      	cmp	r3, #0
    2e3a:	d002      	beq.n	2e42 <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    2e3c:	9801      	ldr	r0, [sp, #4]
    2e3e:	f000 f98b 	bl	3158 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e42:	bf00      	nop
    2e44:	b003      	add	sp, #12
    2e46:	f85d fb04 	ldr.w	pc, [sp], #4

00002e4a <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2e4a:	b086      	sub	sp, #24
    2e4c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2e4e:	9b01      	ldr	r3, [sp, #4]
    2e50:	681a      	ldr	r2, [r3, #0]
    2e52:	4911      	ldr	r1, [pc, #68]	; (2e98 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    2e54:	4613      	mov	r3, r2
    2e56:	00db      	lsls	r3, r3, #3
    2e58:	4413      	add	r3, r2
    2e5a:	440b      	add	r3, r1
    2e5c:	781b      	ldrb	r3, [r3, #0]
    2e5e:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    2e60:	9b01      	ldr	r3, [sp, #4]
    2e62:	685b      	ldr	r3, [r3, #4]
    2e64:	4a0d      	ldr	r2, [pc, #52]	; (2e9c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    2e66:	5cd3      	ldrb	r3, [r2, r3]
    2e68:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    2e6a:	4a0d      	ldr	r2, [pc, #52]	; (2ea0 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    2e6c:	9b05      	ldr	r3, [sp, #20]
    2e6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2e72:	681b      	ldr	r3, [r3, #0]
    2e74:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    2e76:	9b03      	ldr	r3, [sp, #12]
    2e78:	f023 0307 	bic.w	r3, r3, #7
    2e7c:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    2e7e:	9a03      	ldr	r2, [sp, #12]
    2e80:	9b04      	ldr	r3, [sp, #16]
    2e82:	4313      	orrs	r3, r2
    2e84:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    2e86:	4a06      	ldr	r2, [pc, #24]	; (2ea0 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    2e88:	9b05      	ldr	r3, [sp, #20]
    2e8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2e8e:	9a03      	ldr	r2, [sp, #12]
    2e90:	601a      	str	r2, [r3, #0]
}
    2e92:	bf00      	nop
    2e94:	b006      	add	sp, #24
    2e96:	4770      	bx	lr
    2e98:	0000a740 	.word	0x0000a740
    2e9c:	0000ab38 	.word	0x0000ab38
    2ea0:	0000ab7c 	.word	0x0000ab7c

00002ea4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2ea4:	b086      	sub	sp, #24
    2ea6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2ea8:	9b01      	ldr	r3, [sp, #4]
    2eaa:	681a      	ldr	r2, [r3, #0]
    2eac:	4911      	ldr	r1, [pc, #68]	; (2ef4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    2eae:	4613      	mov	r3, r2
    2eb0:	00db      	lsls	r3, r3, #3
    2eb2:	4413      	add	r3, r2
    2eb4:	440b      	add	r3, r1
    2eb6:	781b      	ldrb	r3, [r3, #0]
    2eb8:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    2eba:	9b01      	ldr	r3, [sp, #4]
    2ebc:	685b      	ldr	r3, [r3, #4]
    2ebe:	4a0e      	ldr	r2, [pc, #56]	; (2ef8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    2ec0:	5cd3      	ldrb	r3, [r2, r3]
    2ec2:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    2ec4:	4a0d      	ldr	r2, [pc, #52]	; (2efc <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    2ec6:	9b05      	ldr	r3, [sp, #20]
    2ec8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2ecc:	681b      	ldr	r3, [r3, #0]
    2ece:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    2ed0:	9b03      	ldr	r3, [sp, #12]
    2ed2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    2ed6:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    2ed8:	9b04      	ldr	r3, [sp, #16]
    2eda:	021b      	lsls	r3, r3, #8
    2edc:	9a03      	ldr	r2, [sp, #12]
    2ede:	4313      	orrs	r3, r2
    2ee0:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    2ee2:	4a06      	ldr	r2, [pc, #24]	; (2efc <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    2ee4:	9b05      	ldr	r3, [sp, #20]
    2ee6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2eea:	9a03      	ldr	r2, [sp, #12]
    2eec:	601a      	str	r2, [r3, #0]
}
    2eee:	bf00      	nop
    2ef0:	b006      	add	sp, #24
    2ef2:	4770      	bx	lr
    2ef4:	0000a740 	.word	0x0000a740
    2ef8:	0000ab38 	.word	0x0000ab38
    2efc:	0000ab7c 	.word	0x0000ab7c

00002f00 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2f00:	b084      	sub	sp, #16
    2f02:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2f04:	4b09      	ldr	r3, [pc, #36]	; (2f2c <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    2f06:	695b      	ldr	r3, [r3, #20]
    2f08:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    2f0a:	9b03      	ldr	r3, [sp, #12]
    2f0c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2f10:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    2f12:	9b01      	ldr	r3, [sp, #4]
    2f14:	685b      	ldr	r3, [r3, #4]
    2f16:	3b01      	subs	r3, #1
    2f18:	041b      	lsls	r3, r3, #16
    2f1a:	9a03      	ldr	r2, [sp, #12]
    2f1c:	4313      	orrs	r3, r2
    2f1e:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2f20:	4a02      	ldr	r2, [pc, #8]	; (2f2c <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    2f22:	9b03      	ldr	r3, [sp, #12]
    2f24:	6153      	str	r3, [r2, #20]
}
    2f26:	bf00      	nop
    2f28:	b004      	add	sp, #16
    2f2a:	4770      	bx	lr
    2f2c:	40064000 	.word	0x40064000

00002f30 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2f30:	b084      	sub	sp, #16
    2f32:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2f34:	4b09      	ldr	r3, [pc, #36]	; (2f5c <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    2f36:	695b      	ldr	r3, [r3, #20]
    2f38:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    2f3a:	9b03      	ldr	r3, [sp, #12]
    2f3c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2f40:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    2f42:	9b01      	ldr	r3, [sp, #4]
    2f44:	685b      	ldr	r3, [r3, #4]
    2f46:	3b01      	subs	r3, #1
    2f48:	011b      	lsls	r3, r3, #4
    2f4a:	9a03      	ldr	r2, [sp, #12]
    2f4c:	4313      	orrs	r3, r2
    2f4e:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2f50:	4a02      	ldr	r2, [pc, #8]	; (2f5c <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    2f52:	9b03      	ldr	r3, [sp, #12]
    2f54:	6153      	str	r3, [r2, #20]
}
    2f56:	bf00      	nop
    2f58:	b004      	add	sp, #16
    2f5a:	4770      	bx	lr
    2f5c:	40064000 	.word	0x40064000

00002f60 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2f60:	b084      	sub	sp, #16
    2f62:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2f64:	4b09      	ldr	r3, [pc, #36]	; (2f8c <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    2f66:	695b      	ldr	r3, [r3, #20]
    2f68:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    2f6a:	9b03      	ldr	r3, [sp, #12]
    2f6c:	f023 030f 	bic.w	r3, r3, #15
    2f70:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    2f72:	9b01      	ldr	r3, [sp, #4]
    2f74:	685b      	ldr	r3, [r3, #4]
    2f76:	3b01      	subs	r3, #1
    2f78:	9a03      	ldr	r2, [sp, #12]
    2f7a:	4313      	orrs	r3, r2
    2f7c:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2f7e:	4a03      	ldr	r2, [pc, #12]	; (2f8c <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    2f80:	9b03      	ldr	r3, [sp, #12]
    2f82:	6153      	str	r3, [r2, #20]
}
    2f84:	bf00      	nop
    2f86:	b004      	add	sp, #16
    2f88:	4770      	bx	lr
    2f8a:	bf00      	nop
    2f8c:	40064000 	.word	0x40064000

00002f90 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2f90:	b084      	sub	sp, #16
    2f92:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2f94:	4b09      	ldr	r3, [pc, #36]	; (2fbc <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    2f96:	699b      	ldr	r3, [r3, #24]
    2f98:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    2f9a:	9b03      	ldr	r3, [sp, #12]
    2f9c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2fa0:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    2fa2:	9b01      	ldr	r3, [sp, #4]
    2fa4:	685b      	ldr	r3, [r3, #4]
    2fa6:	3b01      	subs	r3, #1
    2fa8:	041b      	lsls	r3, r3, #16
    2faa:	9a03      	ldr	r2, [sp, #12]
    2fac:	4313      	orrs	r3, r2
    2fae:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2fb0:	4a02      	ldr	r2, [pc, #8]	; (2fbc <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    2fb2:	9b03      	ldr	r3, [sp, #12]
    2fb4:	6193      	str	r3, [r2, #24]
}
    2fb6:	bf00      	nop
    2fb8:	b004      	add	sp, #16
    2fba:	4770      	bx	lr
    2fbc:	40064000 	.word	0x40064000

00002fc0 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2fc0:	b084      	sub	sp, #16
    2fc2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2fc4:	4b09      	ldr	r3, [pc, #36]	; (2fec <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    2fc6:	699b      	ldr	r3, [r3, #24]
    2fc8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    2fca:	9b03      	ldr	r3, [sp, #12]
    2fcc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2fd0:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    2fd2:	9b01      	ldr	r3, [sp, #4]
    2fd4:	685b      	ldr	r3, [r3, #4]
    2fd6:	3b01      	subs	r3, #1
    2fd8:	011b      	lsls	r3, r3, #4
    2fda:	9a03      	ldr	r2, [sp, #12]
    2fdc:	4313      	orrs	r3, r2
    2fde:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2fe0:	4a02      	ldr	r2, [pc, #8]	; (2fec <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    2fe2:	9b03      	ldr	r3, [sp, #12]
    2fe4:	6193      	str	r3, [r2, #24]
}
    2fe6:	bf00      	nop
    2fe8:	b004      	add	sp, #16
    2fea:	4770      	bx	lr
    2fec:	40064000 	.word	0x40064000

00002ff0 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2ff0:	b084      	sub	sp, #16
    2ff2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2ff4:	4b09      	ldr	r3, [pc, #36]	; (301c <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    2ff6:	699b      	ldr	r3, [r3, #24]
    2ff8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    2ffa:	9b03      	ldr	r3, [sp, #12]
    2ffc:	f023 030f 	bic.w	r3, r3, #15
    3000:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    3002:	9b01      	ldr	r3, [sp, #4]
    3004:	685b      	ldr	r3, [r3, #4]
    3006:	3b01      	subs	r3, #1
    3008:	9a03      	ldr	r2, [sp, #12]
    300a:	4313      	orrs	r3, r2
    300c:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    300e:	4a03      	ldr	r2, [pc, #12]	; (301c <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    3010:	9b03      	ldr	r3, [sp, #12]
    3012:	6193      	str	r3, [r2, #24]
}
    3014:	bf00      	nop
    3016:	b004      	add	sp, #16
    3018:	4770      	bx	lr
    301a:	bf00      	nop
    301c:	40064000 	.word	0x40064000

00003020 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3020:	b084      	sub	sp, #16
    3022:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3024:	4b09      	ldr	r3, [pc, #36]	; (304c <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    3026:	69db      	ldr	r3, [r3, #28]
    3028:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    302a:	9b03      	ldr	r3, [sp, #12]
    302c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    3030:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    3032:	9b01      	ldr	r3, [sp, #4]
    3034:	685b      	ldr	r3, [r3, #4]
    3036:	3b01      	subs	r3, #1
    3038:	041b      	lsls	r3, r3, #16
    303a:	9a03      	ldr	r2, [sp, #12]
    303c:	4313      	orrs	r3, r2
    303e:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    3040:	4a02      	ldr	r2, [pc, #8]	; (304c <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    3042:	9b03      	ldr	r3, [sp, #12]
    3044:	61d3      	str	r3, [r2, #28]
}
    3046:	bf00      	nop
    3048:	b004      	add	sp, #16
    304a:	4770      	bx	lr
    304c:	40064000 	.word	0x40064000

00003050 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3050:	b084      	sub	sp, #16
    3052:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3054:	4b09      	ldr	r3, [pc, #36]	; (307c <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    3056:	69db      	ldr	r3, [r3, #28]
    3058:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    305a:	9b03      	ldr	r3, [sp, #12]
    305c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3060:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    3062:	9b01      	ldr	r3, [sp, #4]
    3064:	685b      	ldr	r3, [r3, #4]
    3066:	3b01      	subs	r3, #1
    3068:	011b      	lsls	r3, r3, #4
    306a:	9a03      	ldr	r2, [sp, #12]
    306c:	4313      	orrs	r3, r2
    306e:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    3070:	4a02      	ldr	r2, [pc, #8]	; (307c <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    3072:	9b03      	ldr	r3, [sp, #12]
    3074:	61d3      	str	r3, [r2, #28]
}
    3076:	bf00      	nop
    3078:	b004      	add	sp, #16
    307a:	4770      	bx	lr
    307c:	40064000 	.word	0x40064000

00003080 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3080:	b084      	sub	sp, #16
    3082:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    3084:	4b09      	ldr	r3, [pc, #36]	; (30ac <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    3086:	69db      	ldr	r3, [r3, #28]
    3088:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    308a:	9b03      	ldr	r3, [sp, #12]
    308c:	f023 030f 	bic.w	r3, r3, #15
    3090:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    3092:	9b01      	ldr	r3, [sp, #4]
    3094:	685b      	ldr	r3, [r3, #4]
    3096:	3b01      	subs	r3, #1
    3098:	9a03      	ldr	r2, [sp, #12]
    309a:	4313      	orrs	r3, r2
    309c:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    309e:	4a03      	ldr	r2, [pc, #12]	; (30ac <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    30a0:	9b03      	ldr	r3, [sp, #12]
    30a2:	61d3      	str	r3, [r2, #28]
}
    30a4:	bf00      	nop
    30a6:	b004      	add	sp, #16
    30a8:	4770      	bx	lr
    30aa:	bf00      	nop
    30ac:	40064000 	.word	0x40064000

000030b0 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    30b0:	b084      	sub	sp, #16
    30b2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    30b4:	4b0a      	ldr	r3, [pc, #40]	; (30e0 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    30b6:	685b      	ldr	r3, [r3, #4]
    30b8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    30ba:	9b03      	ldr	r3, [sp, #12]
    30bc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    30c0:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    30c2:	9b01      	ldr	r3, [sp, #4]
    30c4:	685b      	ldr	r3, [r3, #4]
    30c6:	3b01      	subs	r3, #1
    30c8:	021b      	lsls	r3, r3, #8
    30ca:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    30ce:	9a03      	ldr	r2, [sp, #12]
    30d0:	4313      	orrs	r3, r2
    30d2:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    30d4:	4a02      	ldr	r2, [pc, #8]	; (30e0 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    30d6:	9b03      	ldr	r3, [sp, #12]
    30d8:	6053      	str	r3, [r2, #4]
}
    30da:	bf00      	nop
    30dc:	b004      	add	sp, #16
    30de:	4770      	bx	lr
    30e0:	40048000 	.word	0x40048000

000030e4 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    30e4:	b084      	sub	sp, #16
    30e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    30e8:	4919      	ldr	r1, [pc, #100]	; (3150 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    30ea:	9b01      	ldr	r3, [sp, #4]
    30ec:	681a      	ldr	r2, [r3, #0]
    30ee:	4819      	ldr	r0, [pc, #100]	; (3154 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    30f0:	4613      	mov	r3, r2
    30f2:	00db      	lsls	r3, r3, #3
    30f4:	4413      	add	r3, r2
    30f6:	4403      	add	r3, r0
    30f8:	3305      	adds	r3, #5
    30fa:	781b      	ldrb	r3, [r3, #0]
    30fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3100:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    3102:	9b03      	ldr	r3, [sp, #12]
    3104:	f023 030f 	bic.w	r3, r3, #15
    3108:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    310a:	9b01      	ldr	r3, [sp, #4]
    310c:	685b      	ldr	r3, [r3, #4]
    310e:	3b01      	subs	r3, #1
    3110:	f003 0307 	and.w	r3, r3, #7
    3114:	9a03      	ldr	r2, [sp, #12]
    3116:	4313      	orrs	r3, r2
    3118:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    311a:	9b01      	ldr	r3, [sp, #4]
    311c:	7a1b      	ldrb	r3, [r3, #8]
    311e:	3b01      	subs	r3, #1
    3120:	00db      	lsls	r3, r3, #3
    3122:	f003 0308 	and.w	r3, r3, #8
    3126:	9a03      	ldr	r2, [sp, #12]
    3128:	4313      	orrs	r3, r2
    312a:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    312c:	4908      	ldr	r1, [pc, #32]	; (3150 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    312e:	9b01      	ldr	r3, [sp, #4]
    3130:	681a      	ldr	r2, [r3, #0]
    3132:	4808      	ldr	r0, [pc, #32]	; (3154 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    3134:	4613      	mov	r3, r2
    3136:	00db      	lsls	r3, r3, #3
    3138:	4413      	add	r3, r2
    313a:	4403      	add	r3, r0
    313c:	3305      	adds	r3, #5
    313e:	781b      	ldrb	r3, [r3, #0]
    3140:	461a      	mov	r2, r3
    3142:	9b03      	ldr	r3, [sp, #12]
    3144:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    3148:	bf00      	nop
    314a:	b004      	add	sp, #16
    314c:	4770      	bx	lr
    314e:	bf00      	nop
    3150:	40065000 	.word	0x40065000
    3154:	0000a740 	.word	0x0000a740

00003158 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3158:	b084      	sub	sp, #16
    315a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    315c:	4b10      	ldr	r3, [pc, #64]	; (31a0 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    315e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3160:	4a0f      	ldr	r2, [pc, #60]	; (31a0 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3162:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    3166:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    3168:	4b0d      	ldr	r3, [pc, #52]	; (31a0 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    316a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    316c:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    316e:	9b03      	ldr	r3, [sp, #12]
    3170:	f023 030f 	bic.w	r3, r3, #15
    3174:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    3176:	9b01      	ldr	r3, [sp, #4]
    3178:	685b      	ldr	r3, [r3, #4]
    317a:	3b01      	subs	r3, #1
    317c:	005b      	lsls	r3, r3, #1
    317e:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    3182:	9b01      	ldr	r3, [sp, #4]
    3184:	7a1b      	ldrb	r3, [r3, #8]
    3186:	3b01      	subs	r3, #1
    3188:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    318c:	4313      	orrs	r3, r2
    318e:	9a03      	ldr	r2, [sp, #12]
    3190:	4313      	orrs	r3, r2
    3192:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    3194:	4a02      	ldr	r2, [pc, #8]	; (31a0 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3196:	9b03      	ldr	r3, [sp, #12]
    3198:	6693      	str	r3, [r2, #104]	; 0x68
}
    319a:	bf00      	nop
    319c:	b004      	add	sp, #16
    319e:	4770      	bx	lr
    31a0:	40048000 	.word	0x40048000

000031a4 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    31a4:	b082      	sub	sp, #8
    31a6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    31a8:	bf00      	nop
    31aa:	b002      	add	sp, #8
    31ac:	4770      	bx	lr
	...

000031b0 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    31b0:	b082      	sub	sp, #8
    31b2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    31b4:	bf00      	nop
    31b6:	b002      	add	sp, #8
    31b8:	4770      	bx	lr

000031ba <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    31ba:	b082      	sub	sp, #8
    31bc:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    31be:	bf00      	nop
    31c0:	b002      	add	sp, #8
    31c2:	4770      	bx	lr

000031c4 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    31c4:	b500      	push	{lr}
    31c6:	b083      	sub	sp, #12
    31c8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31ca:	9b01      	ldr	r3, [sp, #4]
    31cc:	2b00      	cmp	r3, #0
    31ce:	d002      	beq.n	31d6 <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    31d0:	9801      	ldr	r0, [sp, #4]
    31d2:	f000 f86a 	bl	32aa <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31d6:	bf00      	nop
    31d8:	b003      	add	sp, #12
    31da:	f85d fb04 	ldr.w	pc, [sp], #4

000031de <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    31de:	b500      	push	{lr}
    31e0:	b083      	sub	sp, #12
    31e2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31e4:	9b01      	ldr	r3, [sp, #4]
    31e6:	2b00      	cmp	r3, #0
    31e8:	d002      	beq.n	31f0 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    31ea:	9801      	ldr	r0, [sp, #4]
    31ec:	f000 f884 	bl	32f8 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    31f0:	bf00      	nop
    31f2:	b003      	add	sp, #12
    31f4:	f85d fb04 	ldr.w	pc, [sp], #4

000031f8 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    31f8:	b500      	push	{lr}
    31fa:	b089      	sub	sp, #36	; 0x24
    31fc:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    31fe:	2300      	movs	r3, #0
    3200:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    3204:	9b01      	ldr	r3, [sp, #4]
    3206:	2b00      	cmp	r3, #0
    3208:	d031      	beq.n	326e <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    320a:	4b1b      	ldr	r3, [pc, #108]	; (3278 <Clock_Ip_CompleteSOSC+0x80>)
    320c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3210:	f003 0301 	and.w	r3, r3, #1
    3214:	2b00      	cmp	r3, #0
    3216:	d02a      	beq.n	326e <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3218:	aa03      	add	r2, sp, #12
    321a:	a904      	add	r1, sp, #16
    321c:	a805      	add	r0, sp, #20
    321e:	f24c 3350 	movw	r3, #50000	; 0xc350
    3222:	f7ff fd1d 	bl	2c60 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    3226:	4b14      	ldr	r3, [pc, #80]	; (3278 <Clock_Ip_CompleteSOSC+0x80>)
    3228:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    322c:	0e1b      	lsrs	r3, r3, #24
    322e:	f003 0301 	and.w	r3, r3, #1
    3232:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3234:	9a03      	ldr	r2, [sp, #12]
    3236:	a904      	add	r1, sp, #16
    3238:	ab05      	add	r3, sp, #20
    323a:	4618      	mov	r0, r3
    323c:	f7ff fd2a 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3240:	4603      	mov	r3, r0
    3242:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    3246:	9b06      	ldr	r3, [sp, #24]
    3248:	2b00      	cmp	r3, #0
    324a:	d106      	bne.n	325a <Clock_Ip_CompleteSOSC+0x62>
    324c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3250:	f083 0301 	eor.w	r3, r3, #1
    3254:	b2db      	uxtb	r3, r3
    3256:	2b00      	cmp	r3, #0
    3258:	d1e5      	bne.n	3226 <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    325a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    325e:	2b00      	cmp	r3, #0
    3260:	d005      	beq.n	326e <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3262:	9b01      	ldr	r3, [sp, #4]
    3264:	681b      	ldr	r3, [r3, #0]
    3266:	4619      	mov	r1, r3
    3268:	2001      	movs	r0, #1
    326a:	f7ff fce9 	bl	2c40 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    326e:	bf00      	nop
    3270:	b009      	add	sp, #36	; 0x24
    3272:	f85d fb04 	ldr.w	pc, [sp], #4
    3276:	bf00      	nop
    3278:	40064000 	.word	0x40064000

0000327c <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    327c:	b500      	push	{lr}
    327e:	b083      	sub	sp, #12
    3280:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    3282:	9801      	ldr	r0, [sp, #4]
    3284:	f000 f8c0 	bl	3408 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3288:	bf00      	nop
    328a:	b003      	add	sp, #12
    328c:	f85d fb04 	ldr.w	pc, [sp], #4

00003290 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    3290:	b500      	push	{lr}
    3292:	b083      	sub	sp, #12
    3294:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3296:	9b01      	ldr	r3, [sp, #4]
    3298:	2b00      	cmp	r3, #0
    329a:	d002      	beq.n	32a2 <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    329c:	9801      	ldr	r0, [sp, #4]
    329e:	f000 f8c3 	bl	3428 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32a2:	bf00      	nop
    32a4:	b003      	add	sp, #12
    32a6:	f85d fb04 	ldr.w	pc, [sp], #4

000032aa <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    32aa:	b082      	sub	sp, #8
    32ac:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    32ae:	4b11      	ldr	r3, [pc, #68]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32b0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    32b4:	4a0f      	ldr	r2, [pc, #60]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32b6:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    32ba:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    32be:	4b0d      	ldr	r3, [pc, #52]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32c0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    32c4:	4a0b      	ldr	r2, [pc, #44]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32c6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    32ca:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    32ce:	4b09      	ldr	r3, [pc, #36]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32d0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    32d4:	4a07      	ldr	r2, [pc, #28]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32d6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    32da:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    32de:	4b05      	ldr	r3, [pc, #20]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32e0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    32e4:	4a03      	ldr	r2, [pc, #12]	; (32f4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    32e6:	f023 0301 	bic.w	r3, r3, #1
    32ea:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    32ee:	bf00      	nop
    32f0:	b002      	add	sp, #8
    32f2:	4770      	bx	lr
    32f4:	40064000 	.word	0x40064000

000032f8 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    32f8:	b082      	sub	sp, #8
    32fa:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    32fc:	9b01      	ldr	r3, [sp, #4]
    32fe:	891b      	ldrh	r3, [r3, #8]
    3300:	2b01      	cmp	r3, #1
    3302:	d174      	bne.n	33ee <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    3304:	9b01      	ldr	r3, [sp, #4]
    3306:	7bdb      	ldrb	r3, [r3, #15]
    3308:	2b00      	cmp	r3, #0
    330a:	d002      	beq.n	3312 <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    330c:	2b01      	cmp	r3, #1
    330e:	d009      	beq.n	3324 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    3310:	e011      	b.n	3336 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    3312:	4b39      	ldr	r3, [pc, #228]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3314:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3318:	4a37      	ldr	r2, [pc, #220]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    331a:	f023 0308 	bic.w	r3, r3, #8
    331e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    3322:	e008      	b.n	3336 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    3324:	4b34      	ldr	r3, [pc, #208]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3326:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    332a:	4a33      	ldr	r2, [pc, #204]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    332c:	f043 0308 	orr.w	r3, r3, #8
    3330:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    3334:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    3336:	4b30      	ldr	r3, [pc, #192]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3338:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    333c:	4a2e      	ldr	r2, [pc, #184]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    333e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    3342:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    3346:	9b01      	ldr	r3, [sp, #4]
    3348:	685b      	ldr	r3, [r3, #4]
    334a:	4a2c      	ldr	r2, [pc, #176]	; (33fc <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    334c:	4293      	cmp	r3, r2
    334e:	d90d      	bls.n	336c <Clock_Ip_SetSOSC_TrustedCall+0x74>
    3350:	9b01      	ldr	r3, [sp, #4]
    3352:	685b      	ldr	r3, [r3, #4]
    3354:	4a2a      	ldr	r2, [pc, #168]	; (3400 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    3356:	4293      	cmp	r3, r2
    3358:	d208      	bcs.n	336c <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    335a:	4b27      	ldr	r3, [pc, #156]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    335c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3360:	4a25      	ldr	r2, [pc, #148]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3362:	f043 0320 	orr.w	r3, r3, #32
    3366:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    336a:	e007      	b.n	337c <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    336c:	4b22      	ldr	r3, [pc, #136]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    336e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3372:	4a21      	ldr	r2, [pc, #132]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3374:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    3378:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    337c:	9b01      	ldr	r3, [sp, #4]
    337e:	7b1b      	ldrb	r3, [r3, #12]
    3380:	2b00      	cmp	r3, #0
    3382:	d108      	bne.n	3396 <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    3384:	4b1c      	ldr	r3, [pc, #112]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3386:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    338a:	4a1b      	ldr	r2, [pc, #108]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    338c:	f043 0304 	orr.w	r3, r3, #4
    3390:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    3394:	e007      	b.n	33a6 <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    3396:	4b18      	ldr	r3, [pc, #96]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3398:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    339c:	4a16      	ldr	r2, [pc, #88]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    339e:	f023 0304 	bic.w	r3, r3, #4
    33a2:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    33a6:	9b01      	ldr	r3, [sp, #4]
    33a8:	7c1b      	ldrb	r3, [r3, #16]
    33aa:	2b02      	cmp	r3, #2
    33ac:	d011      	beq.n	33d2 <Clock_Ip_SetSOSC_TrustedCall+0xda>
    33ae:	2b02      	cmp	r3, #2
    33b0:	dc14      	bgt.n	33dc <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    33b2:	2b00      	cmp	r3, #0
    33b4:	d002      	beq.n	33bc <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    33b6:	2b01      	cmp	r3, #1
    33b8:	d005      	beq.n	33c6 <Clock_Ip_SetSOSC_TrustedCall+0xce>
    33ba:	e00f      	b.n	33dc <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    33bc:	4b0e      	ldr	r3, [pc, #56]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    33be:	2201      	movs	r2, #1
    33c0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    33c4:	e014      	b.n	33f0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    33c6:	4b0c      	ldr	r3, [pc, #48]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    33c8:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    33cc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    33d0:	e00e      	b.n	33f0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    33d2:	4b09      	ldr	r3, [pc, #36]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    33d4:	4a0b      	ldr	r2, [pc, #44]	; (3404 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    33d6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    33da:	e009      	b.n	33f0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    33dc:	4b06      	ldr	r3, [pc, #24]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    33de:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    33e2:	4a05      	ldr	r2, [pc, #20]	; (33f8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    33e4:	f043 0301 	orr.w	r3, r3, #1
    33e8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    33ec:	e000      	b.n	33f0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    33ee:	bf00      	nop
}
    33f0:	bf00      	nop
    33f2:	b002      	add	sp, #8
    33f4:	4770      	bx	lr
    33f6:	bf00      	nop
    33f8:	40064000 	.word	0x40064000
    33fc:	003d08ff 	.word	0x003d08ff
    3400:	007a1200 	.word	0x007a1200
    3404:	00030001 	.word	0x00030001

00003408 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    3408:	b082      	sub	sp, #8
    340a:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    340c:	4b05      	ldr	r3, [pc, #20]	; (3424 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    340e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3412:	4a04      	ldr	r2, [pc, #16]	; (3424 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    3414:	f023 0301 	bic.w	r3, r3, #1
    3418:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    341c:	bf00      	nop
    341e:	b002      	add	sp, #8
    3420:	4770      	bx	lr
    3422:	bf00      	nop
    3424:	40064000 	.word	0x40064000

00003428 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3428:	b082      	sub	sp, #8
    342a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    342c:	9b01      	ldr	r3, [sp, #4]
    342e:	891b      	ldrh	r3, [r3, #8]
    3430:	2b01      	cmp	r3, #1
    3432:	d107      	bne.n	3444 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    3434:	4b05      	ldr	r3, [pc, #20]	; (344c <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    3436:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    343a:	4a04      	ldr	r2, [pc, #16]	; (344c <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    343c:	f043 0301 	orr.w	r3, r3, #1
    3440:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    3444:	bf00      	nop
    3446:	b002      	add	sp, #8
    3448:	4770      	bx	lr
    344a:	bf00      	nop
    344c:	40064000 	.word	0x40064000

00003450 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    3450:	b082      	sub	sp, #8
    3452:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3454:	bf00      	nop
    3456:	b002      	add	sp, #8
    3458:	4770      	bx	lr

0000345a <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    345a:	b082      	sub	sp, #8
    345c:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    345e:	2300      	movs	r3, #0
}
    3460:	4618      	mov	r0, r3
    3462:	b002      	add	sp, #8
    3464:	4770      	bx	lr

00003466 <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    3466:	b082      	sub	sp, #8
    3468:	9001      	str	r0, [sp, #4]
    346a:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    346c:	bf00      	nop
    346e:	b002      	add	sp, #8
    3470:	4770      	bx	lr
	...

00003474 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    3474:	b082      	sub	sp, #8
    3476:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3478:	bf00      	nop
    347a:	b002      	add	sp, #8
    347c:	4770      	bx	lr

0000347e <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    347e:	b082      	sub	sp, #8
    3480:	9001      	str	r0, [sp, #4]
    3482:	460b      	mov	r3, r1
    3484:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    3488:	bf00      	nop
    348a:	b002      	add	sp, #8
    348c:	4770      	bx	lr

0000348e <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    348e:	b500      	push	{lr}
    3490:	b083      	sub	sp, #12
    3492:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3494:	9b01      	ldr	r3, [sp, #4]
    3496:	2b00      	cmp	r3, #0
    3498:	d002      	beq.n	34a0 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    349a:	9801      	ldr	r0, [sp, #4]
    349c:	f000 f8e7 	bl	366e <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    34a0:	bf00      	nop
    34a2:	b003      	add	sp, #12
    34a4:	f85d fb04 	ldr.w	pc, [sp], #4

000034a8 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    34a8:	b500      	push	{lr}
    34aa:	b085      	sub	sp, #20
    34ac:	9001      	str	r0, [sp, #4]
    34ae:	460b      	mov	r3, r1
    34b0:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    34b4:	9b01      	ldr	r3, [sp, #4]
    34b6:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    34b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    34bc:	2b00      	cmp	r3, #0
    34be:	d003      	beq.n	34c8 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    34c0:	2300      	movs	r3, #0
    34c2:	f8ad 300c 	strh.w	r3, [sp, #12]
    34c6:	e002      	b.n	34ce <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    34c8:	2301      	movs	r3, #1
    34ca:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    34ce:	ab02      	add	r3, sp, #8
    34d0:	4618      	mov	r0, r3
    34d2:	f7ff ffdc 	bl	348e <Clock_Ip_ClockSetSimLPO1KEnable>
}
    34d6:	bf00      	nop
    34d8:	b005      	add	sp, #20
    34da:	f85d fb04 	ldr.w	pc, [sp], #4

000034de <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    34de:	b500      	push	{lr}
    34e0:	b083      	sub	sp, #12
    34e2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    34e4:	9b01      	ldr	r3, [sp, #4]
    34e6:	2b00      	cmp	r3, #0
    34e8:	d002      	beq.n	34f0 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    34ea:	9801      	ldr	r0, [sp, #4]
    34ec:	f000 f8d6 	bl	369c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    34f0:	bf00      	nop
    34f2:	b003      	add	sp, #12
    34f4:	f85d fb04 	ldr.w	pc, [sp], #4

000034f8 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    34f8:	b500      	push	{lr}
    34fa:	b085      	sub	sp, #20
    34fc:	9001      	str	r0, [sp, #4]
    34fe:	460b      	mov	r3, r1
    3500:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3504:	9b01      	ldr	r3, [sp, #4]
    3506:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3508:	f89d 3003 	ldrb.w	r3, [sp, #3]
    350c:	2b00      	cmp	r3, #0
    350e:	d003      	beq.n	3518 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    3510:	2300      	movs	r3, #0
    3512:	f8ad 300c 	strh.w	r3, [sp, #12]
    3516:	e002      	b.n	351e <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3518:	2301      	movs	r3, #1
    351a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    351e:	ab02      	add	r3, sp, #8
    3520:	4618      	mov	r0, r3
    3522:	f7ff ffdc 	bl	34de <Clock_Ip_ClockSetSimLPO32KEnable>
}
    3526:	bf00      	nop
    3528:	b005      	add	sp, #20
    352a:	f85d fb04 	ldr.w	pc, [sp], #4

0000352e <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    352e:	b500      	push	{lr}
    3530:	b083      	sub	sp, #12
    3532:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3534:	9b01      	ldr	r3, [sp, #4]
    3536:	2b00      	cmp	r3, #0
    3538:	d002      	beq.n	3540 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    353a:	9801      	ldr	r0, [sp, #4]
    353c:	f000 f8c6 	bl	36cc <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3540:	bf00      	nop
    3542:	b003      	add	sp, #12
    3544:	f85d fb04 	ldr.w	pc, [sp], #4

00003548 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3548:	b500      	push	{lr}
    354a:	b085      	sub	sp, #20
    354c:	9001      	str	r0, [sp, #4]
    354e:	460b      	mov	r3, r1
    3550:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3554:	9b01      	ldr	r3, [sp, #4]
    3556:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3558:	f89d 3003 	ldrb.w	r3, [sp, #3]
    355c:	2b00      	cmp	r3, #0
    355e:	d003      	beq.n	3568 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    3560:	2300      	movs	r3, #0
    3562:	f8ad 300c 	strh.w	r3, [sp, #12]
    3566:	e002      	b.n	356e <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3568:	2301      	movs	r3, #1
    356a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    356e:	ab02      	add	r3, sp, #8
    3570:	4618      	mov	r0, r3
    3572:	f7ff ffdc 	bl	352e <Clock_Ip_ClockSetSimClkoutEnable>
}
    3576:	bf00      	nop
    3578:	b005      	add	sp, #20
    357a:	f85d fb04 	ldr.w	pc, [sp], #4

0000357e <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    357e:	b500      	push	{lr}
    3580:	b083      	sub	sp, #12
    3582:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3584:	9b01      	ldr	r3, [sp, #4]
    3586:	2b00      	cmp	r3, #0
    3588:	d002      	beq.n	3590 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    358a:	9801      	ldr	r0, [sp, #4]
    358c:	f000 f8b6 	bl	36fc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3590:	bf00      	nop
    3592:	b003      	add	sp, #12
    3594:	f85d fb04 	ldr.w	pc, [sp], #4

00003598 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3598:	b500      	push	{lr}
    359a:	b085      	sub	sp, #20
    359c:	9001      	str	r0, [sp, #4]
    359e:	460b      	mov	r3, r1
    35a0:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    35a4:	9b01      	ldr	r3, [sp, #4]
    35a6:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    35a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    35ac:	2b00      	cmp	r3, #0
    35ae:	d003      	beq.n	35b8 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    35b0:	2300      	movs	r3, #0
    35b2:	f8ad 300c 	strh.w	r3, [sp, #12]
    35b6:	e002      	b.n	35be <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    35b8:	2301      	movs	r3, #1
    35ba:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    35be:	ab02      	add	r3, sp, #8
    35c0:	4618      	mov	r0, r3
    35c2:	f7ff ffdc 	bl	357e <Clock_Ip_ClockSetPccCgcEnable>
}
    35c6:	bf00      	nop
    35c8:	b005      	add	sp, #20
    35ca:	f85d fb04 	ldr.w	pc, [sp], #4

000035ce <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    35ce:	b500      	push	{lr}
    35d0:	b083      	sub	sp, #12
    35d2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    35d4:	9b01      	ldr	r3, [sp, #4]
    35d6:	2b00      	cmp	r3, #0
    35d8:	d002      	beq.n	35e0 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    35da:	9801      	ldr	r0, [sp, #4]
    35dc:	f000 f8bc 	bl	3758 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    35e0:	bf00      	nop
    35e2:	b003      	add	sp, #12
    35e4:	f85d fb04 	ldr.w	pc, [sp], #4

000035e8 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    35e8:	b500      	push	{lr}
    35ea:	b085      	sub	sp, #20
    35ec:	9001      	str	r0, [sp, #4]
    35ee:	460b      	mov	r3, r1
    35f0:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    35f4:	9b01      	ldr	r3, [sp, #4]
    35f6:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    35f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    35fc:	2b00      	cmp	r3, #0
    35fe:	d003      	beq.n	3608 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    3600:	2300      	movs	r3, #0
    3602:	f8ad 300c 	strh.w	r3, [sp, #12]
    3606:	e002      	b.n	360e <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3608:	2301      	movs	r3, #1
    360a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    360e:	ab02      	add	r3, sp, #8
    3610:	4618      	mov	r0, r3
    3612:	f7ff ffdc 	bl	35ce <Clock_Ip_ClockSetSimGate>
}
    3616:	bf00      	nop
    3618:	b005      	add	sp, #20
    361a:	f85d fb04 	ldr.w	pc, [sp], #4

0000361e <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    361e:	b500      	push	{lr}
    3620:	b083      	sub	sp, #12
    3622:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3624:	9b01      	ldr	r3, [sp, #4]
    3626:	2b00      	cmp	r3, #0
    3628:	d002      	beq.n	3630 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    362a:	9801      	ldr	r0, [sp, #4]
    362c:	f000 f8c0 	bl	37b0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3630:	bf00      	nop
    3632:	b003      	add	sp, #12
    3634:	f85d fb04 	ldr.w	pc, [sp], #4

00003638 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3638:	b500      	push	{lr}
    363a:	b085      	sub	sp, #20
    363c:	9001      	str	r0, [sp, #4]
    363e:	460b      	mov	r3, r1
    3640:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3644:	9b01      	ldr	r3, [sp, #4]
    3646:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3648:	f89d 3003 	ldrb.w	r3, [sp, #3]
    364c:	2b00      	cmp	r3, #0
    364e:	d003      	beq.n	3658 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    3650:	2300      	movs	r3, #0
    3652:	f8ad 300c 	strh.w	r3, [sp, #12]
    3656:	e002      	b.n	365e <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3658:	2301      	movs	r3, #1
    365a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    365e:	ab02      	add	r3, sp, #8
    3660:	4618      	mov	r0, r3
    3662:	f7ff ffdc 	bl	361e <Clock_Ip_ClockSetSimTraceEnable>
}
    3666:	bf00      	nop
    3668:	b005      	add	sp, #20
    366a:	f85d fb04 	ldr.w	pc, [sp], #4

0000366e <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    366e:	b084      	sub	sp, #16
    3670:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3672:	4b09      	ldr	r3, [pc, #36]	; (3698 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3674:	691b      	ldr	r3, [r3, #16]
    3676:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    3678:	9b03      	ldr	r3, [sp, #12]
    367a:	f023 0301 	bic.w	r3, r3, #1
    367e:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3680:	9b01      	ldr	r3, [sp, #4]
    3682:	889b      	ldrh	r3, [r3, #4]
    3684:	461a      	mov	r2, r3
    3686:	9b03      	ldr	r3, [sp, #12]
    3688:	4313      	orrs	r3, r2
    368a:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    368c:	4a02      	ldr	r2, [pc, #8]	; (3698 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    368e:	9b03      	ldr	r3, [sp, #12]
    3690:	6113      	str	r3, [r2, #16]
}
    3692:	bf00      	nop
    3694:	b004      	add	sp, #16
    3696:	4770      	bx	lr
    3698:	40048000 	.word	0x40048000

0000369c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    369c:	b084      	sub	sp, #16
    369e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    36a0:	4b09      	ldr	r3, [pc, #36]	; (36c8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    36a2:	691b      	ldr	r3, [r3, #16]
    36a4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    36a6:	9b03      	ldr	r3, [sp, #12]
    36a8:	f023 0302 	bic.w	r3, r3, #2
    36ac:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    36ae:	9b01      	ldr	r3, [sp, #4]
    36b0:	889b      	ldrh	r3, [r3, #4]
    36b2:	005b      	lsls	r3, r3, #1
    36b4:	9a03      	ldr	r2, [sp, #12]
    36b6:	4313      	orrs	r3, r2
    36b8:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    36ba:	4a03      	ldr	r2, [pc, #12]	; (36c8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    36bc:	9b03      	ldr	r3, [sp, #12]
    36be:	6113      	str	r3, [r2, #16]
}
    36c0:	bf00      	nop
    36c2:	b004      	add	sp, #16
    36c4:	4770      	bx	lr
    36c6:	bf00      	nop
    36c8:	40048000 	.word	0x40048000

000036cc <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    36cc:	b084      	sub	sp, #16
    36ce:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    36d0:	4b09      	ldr	r3, [pc, #36]	; (36f8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    36d2:	685b      	ldr	r3, [r3, #4]
    36d4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    36d6:	9b03      	ldr	r3, [sp, #12]
    36d8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    36dc:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    36de:	9b01      	ldr	r3, [sp, #4]
    36e0:	889b      	ldrh	r3, [r3, #4]
    36e2:	02db      	lsls	r3, r3, #11
    36e4:	9a03      	ldr	r2, [sp, #12]
    36e6:	4313      	orrs	r3, r2
    36e8:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    36ea:	4a03      	ldr	r2, [pc, #12]	; (36f8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    36ec:	9b03      	ldr	r3, [sp, #12]
    36ee:	6053      	str	r3, [r2, #4]
}
    36f0:	bf00      	nop
    36f2:	b004      	add	sp, #16
    36f4:	4770      	bx	lr
    36f6:	bf00      	nop
    36f8:	40048000 	.word	0x40048000

000036fc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    36fc:	b084      	sub	sp, #16
    36fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    3700:	4913      	ldr	r1, [pc, #76]	; (3750 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3702:	9b01      	ldr	r3, [sp, #4]
    3704:	681a      	ldr	r2, [r3, #0]
    3706:	4813      	ldr	r0, [pc, #76]	; (3754 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3708:	4613      	mov	r3, r2
    370a:	00db      	lsls	r3, r3, #3
    370c:	4413      	add	r3, r2
    370e:	4403      	add	r3, r0
    3710:	3306      	adds	r3, #6
    3712:	781b      	ldrb	r3, [r3, #0]
    3714:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3718:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    371a:	9b03      	ldr	r3, [sp, #12]
    371c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    3720:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    3722:	9b01      	ldr	r3, [sp, #4]
    3724:	889b      	ldrh	r3, [r3, #4]
    3726:	079b      	lsls	r3, r3, #30
    3728:	9a03      	ldr	r2, [sp, #12]
    372a:	4313      	orrs	r3, r2
    372c:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    372e:	4908      	ldr	r1, [pc, #32]	; (3750 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3730:	9b01      	ldr	r3, [sp, #4]
    3732:	681a      	ldr	r2, [r3, #0]
    3734:	4807      	ldr	r0, [pc, #28]	; (3754 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3736:	4613      	mov	r3, r2
    3738:	00db      	lsls	r3, r3, #3
    373a:	4413      	add	r3, r2
    373c:	4403      	add	r3, r0
    373e:	3306      	adds	r3, #6
    3740:	781b      	ldrb	r3, [r3, #0]
    3742:	461a      	mov	r2, r3
    3744:	9b03      	ldr	r3, [sp, #12]
    3746:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    374a:	bf00      	nop
    374c:	b004      	add	sp, #16
    374e:	4770      	bx	lr
    3750:	40065000 	.word	0x40065000
    3754:	0000a740 	.word	0x0000a740

00003758 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3758:	b086      	sub	sp, #24
    375a:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    375c:	9b01      	ldr	r3, [sp, #4]
    375e:	889b      	ldrh	r3, [r3, #4]
    3760:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    3762:	9b01      	ldr	r3, [sp, #4]
    3764:	681a      	ldr	r2, [r3, #0]
    3766:	4910      	ldr	r1, [pc, #64]	; (37a8 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    3768:	4613      	mov	r3, r2
    376a:	00db      	lsls	r3, r3, #3
    376c:	4413      	add	r3, r2
    376e:	440b      	add	r3, r1
    3770:	3306      	adds	r3, #6
    3772:	781b      	ldrb	r3, [r3, #0]
    3774:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    3776:	4b0d      	ldr	r3, [pc, #52]	; (37ac <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3778:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    377a:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    377c:	2201      	movs	r2, #1
    377e:	9b04      	ldr	r3, [sp, #16]
    3780:	fa02 f303 	lsl.w	r3, r2, r3
    3784:	43db      	mvns	r3, r3
    3786:	9a03      	ldr	r2, [sp, #12]
    3788:	4013      	ands	r3, r2
    378a:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    378c:	9a05      	ldr	r2, [sp, #20]
    378e:	9b04      	ldr	r3, [sp, #16]
    3790:	fa02 f303 	lsl.w	r3, r2, r3
    3794:	9a03      	ldr	r2, [sp, #12]
    3796:	4313      	orrs	r3, r2
    3798:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    379a:	4a04      	ldr	r2, [pc, #16]	; (37ac <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    379c:	9b03      	ldr	r3, [sp, #12]
    379e:	6413      	str	r3, [r2, #64]	; 0x40
}
    37a0:	bf00      	nop
    37a2:	b006      	add	sp, #24
    37a4:	4770      	bx	lr
    37a6:	bf00      	nop
    37a8:	0000a740 	.word	0x0000a740
    37ac:	40048000 	.word	0x40048000

000037b0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    37b0:	b084      	sub	sp, #16
    37b2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    37b4:	4b0a      	ldr	r3, [pc, #40]	; (37e0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    37b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    37b8:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    37ba:	9b01      	ldr	r3, [sp, #4]
    37bc:	889b      	ldrh	r3, [r3, #4]
    37be:	2b01      	cmp	r3, #1
    37c0:	d104      	bne.n	37cc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    37c2:	9b03      	ldr	r3, [sp, #12]
    37c4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    37c8:	9303      	str	r3, [sp, #12]
    37ca:	e003      	b.n	37d4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    37cc:	9b03      	ldr	r3, [sp, #12]
    37ce:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    37d2:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    37d4:	4a02      	ldr	r2, [pc, #8]	; (37e0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    37d6:	9b03      	ldr	r3, [sp, #12]
    37d8:	6693      	str	r3, [r2, #104]	; 0x68
}
    37da:	bf00      	nop
    37dc:	b004      	add	sp, #16
    37de:	4770      	bx	lr
    37e0:	40048000 	.word	0x40048000

000037e4 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    37e4:	b082      	sub	sp, #8
    37e6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    37e8:	bf00      	nop
    37ea:	b002      	add	sp, #8
    37ec:	4770      	bx	lr

000037ee <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    37ee:	b082      	sub	sp, #8
    37f0:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    37f2:	bf00      	nop
    37f4:	b002      	add	sp, #8
    37f6:	4770      	bx	lr

000037f8 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    37f8:	b500      	push	{lr}
    37fa:	b083      	sub	sp, #12
    37fc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37fe:	9b01      	ldr	r3, [sp, #4]
    3800:	2b00      	cmp	r3, #0
    3802:	d002      	beq.n	380a <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    3804:	9801      	ldr	r0, [sp, #4]
    3806:	f000 f8d1 	bl	39ac <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    380a:	bf00      	nop
    380c:	b003      	add	sp, #12
    380e:	f85d fb04 	ldr.w	pc, [sp], #4

00003812 <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3812:	b500      	push	{lr}
    3814:	b083      	sub	sp, #12
    3816:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3818:	9b01      	ldr	r3, [sp, #4]
    381a:	2b00      	cmp	r3, #0
    381c:	d002      	beq.n	3824 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    381e:	9801      	ldr	r0, [sp, #4]
    3820:	f000 f950 	bl	3ac4 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3824:	bf00      	nop
    3826:	b003      	add	sp, #12
    3828:	f85d fb04 	ldr.w	pc, [sp], #4

0000382c <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    382c:	b500      	push	{lr}
    382e:	b083      	sub	sp, #12
    3830:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    3832:	9801      	ldr	r0, [sp, #4]
    3834:	f000 f98e 	bl	3b54 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3838:	bf00      	nop
    383a:	b003      	add	sp, #12
    383c:	f85d fb04 	ldr.w	pc, [sp], #4

00003840 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3840:	b500      	push	{lr}
    3842:	b083      	sub	sp, #12
    3844:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3846:	9b01      	ldr	r3, [sp, #4]
    3848:	2b00      	cmp	r3, #0
    384a:	d002      	beq.n	3852 <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    384c:	9801      	ldr	r0, [sp, #4]
    384e:	f000 f999 	bl	3b84 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3852:	bf00      	nop
    3854:	b003      	add	sp, #12
    3856:	f85d fb04 	ldr.w	pc, [sp], #4

0000385a <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    385a:	b500      	push	{lr}
    385c:	b083      	sub	sp, #12
    385e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3860:	9b01      	ldr	r3, [sp, #4]
    3862:	2b00      	cmp	r3, #0
    3864:	d002      	beq.n	386c <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    3866:	9801      	ldr	r0, [sp, #4]
    3868:	f000 f9b0 	bl	3bcc <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    386c:	bf00      	nop
    386e:	b003      	add	sp, #12
    3870:	f85d fb04 	ldr.w	pc, [sp], #4

00003874 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    3874:	b500      	push	{lr}
    3876:	b083      	sub	sp, #12
    3878:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    387a:	9801      	ldr	r0, [sp, #4]
    387c:	f000 f9ba 	bl	3bf4 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3880:	bf00      	nop
    3882:	b003      	add	sp, #12
    3884:	f85d fb04 	ldr.w	pc, [sp], #4

00003888 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3888:	b500      	push	{lr}
    388a:	b083      	sub	sp, #12
    388c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    388e:	9b01      	ldr	r3, [sp, #4]
    3890:	2b00      	cmp	r3, #0
    3892:	d002      	beq.n	389a <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    3894:	9801      	ldr	r0, [sp, #4]
    3896:	f000 f9bd 	bl	3c14 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    389a:	bf00      	nop
    389c:	b003      	add	sp, #12
    389e:	f85d fb04 	ldr.w	pc, [sp], #4

000038a2 <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    38a2:	b500      	push	{lr}
    38a4:	b083      	sub	sp, #12
    38a6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    38a8:	9b01      	ldr	r3, [sp, #4]
    38aa:	2b00      	cmp	r3, #0
    38ac:	d002      	beq.n	38b4 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    38ae:	9801      	ldr	r0, [sp, #4]
    38b0:	f000 f9d4 	bl	3c5c <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    38b4:	bf00      	nop
    38b6:	b003      	add	sp, #12
    38b8:	f85d fb04 	ldr.w	pc, [sp], #4

000038bc <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    38bc:	b500      	push	{lr}
    38be:	b083      	sub	sp, #12
    38c0:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    38c2:	9801      	ldr	r0, [sp, #4]
    38c4:	f000 f9de 	bl	3c84 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    38c8:	bf00      	nop
    38ca:	b003      	add	sp, #12
    38cc:	f85d fb04 	ldr.w	pc, [sp], #4

000038d0 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    38d0:	b500      	push	{lr}
    38d2:	b089      	sub	sp, #36	; 0x24
    38d4:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    38d6:	2300      	movs	r3, #0
    38d8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    38dc:	4b20      	ldr	r3, [pc, #128]	; (3960 <SetInputSouceSytemClock+0x90>)
    38de:	695b      	ldr	r3, [r3, #20]
    38e0:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    38e2:	9b06      	ldr	r3, [sp, #24]
    38e4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    38e8:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    38ea:	9b01      	ldr	r3, [sp, #4]
    38ec:	061b      	lsls	r3, r3, #24
    38ee:	9a06      	ldr	r2, [sp, #24]
    38f0:	4313      	orrs	r3, r2
    38f2:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    38f4:	4a1a      	ldr	r2, [pc, #104]	; (3960 <SetInputSouceSytemClock+0x90>)
    38f6:	9b06      	ldr	r3, [sp, #24]
    38f8:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    38fa:	aa02      	add	r2, sp, #8
    38fc:	a903      	add	r1, sp, #12
    38fe:	a804      	add	r0, sp, #16
    3900:	f24c 3350 	movw	r3, #50000	; 0xc350
    3904:	f7ff f9ac 	bl	2c60 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    3908:	4b15      	ldr	r3, [pc, #84]	; (3960 <SetInputSouceSytemClock+0x90>)
    390a:	691b      	ldr	r3, [r3, #16]
    390c:	0e1b      	lsrs	r3, r3, #24
    390e:	f003 030f 	and.w	r3, r3, #15
    3912:	9a01      	ldr	r2, [sp, #4]
    3914:	429a      	cmp	r2, r3
    3916:	bf0c      	ite	eq
    3918:	2301      	moveq	r3, #1
    391a:	2300      	movne	r3, #0
    391c:	b2db      	uxtb	r3, r3
    391e:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3920:	9a02      	ldr	r2, [sp, #8]
    3922:	a903      	add	r1, sp, #12
    3924:	ab04      	add	r3, sp, #16
    3926:	4618      	mov	r0, r3
    3928:	f7ff f9b4 	bl	2c94 <Clock_Ip_TimeoutExpired>
    392c:	4603      	mov	r3, r0
    392e:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    3932:	9b05      	ldr	r3, [sp, #20]
    3934:	2b00      	cmp	r3, #0
    3936:	d106      	bne.n	3946 <SetInputSouceSytemClock+0x76>
    3938:	f89d 301f 	ldrb.w	r3, [sp, #31]
    393c:	f083 0301 	eor.w	r3, r3, #1
    3940:	b2db      	uxtb	r3, r3
    3942:	2b00      	cmp	r3, #0
    3944:	d1e0      	bne.n	3908 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    3946:	f89d 301f 	ldrb.w	r3, [sp, #31]
    394a:	2b00      	cmp	r3, #0
    394c:	d003      	beq.n	3956 <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    394e:	2105      	movs	r1, #5
    3950:	2001      	movs	r0, #1
    3952:	f7ff f975 	bl	2c40 <Clock_Ip_ReportClockErrors>
    }
}
    3956:	bf00      	nop
    3958:	b009      	add	sp, #36	; 0x24
    395a:	f85d fb04 	ldr.w	pc, [sp], #4
    395e:	bf00      	nop
    3960:	40064000 	.word	0x40064000

00003964 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3964:	b500      	push	{lr}
    3966:	b083      	sub	sp, #12
    3968:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    396a:	9b01      	ldr	r3, [sp, #4]
    396c:	2b00      	cmp	r3, #0
    396e:	d002      	beq.n	3976 <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    3970:	9801      	ldr	r0, [sp, #4]
    3972:	f000 f997 	bl	3ca4 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3976:	bf00      	nop
    3978:	b003      	add	sp, #12
    397a:	f85d fb04 	ldr.w	pc, [sp], #4

0000397e <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    397e:	b500      	push	{lr}
    3980:	b083      	sub	sp, #12
    3982:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3984:	9b01      	ldr	r3, [sp, #4]
    3986:	2b00      	cmp	r3, #0
    3988:	d002      	beq.n	3990 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    398a:	9801      	ldr	r0, [sp, #4]
    398c:	f000 fa7e 	bl	3e8c <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3990:	bf00      	nop
    3992:	b003      	add	sp, #12
    3994:	f85d fb04 	ldr.w	pc, [sp], #4

00003998 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    3998:	b500      	push	{lr}
    399a:	b083      	sub	sp, #12
    399c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    399e:	9801      	ldr	r0, [sp, #4]
    39a0:	f000 fab8 	bl	3f14 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    39a4:	bf00      	nop
    39a6:	b003      	add	sp, #12
    39a8:	f85d fb04 	ldr.w	pc, [sp], #4

000039ac <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    39ac:	b500      	push	{lr}
    39ae:	b08b      	sub	sp, #44	; 0x2c
    39b0:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    39b2:	2300      	movs	r3, #0
    39b4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    39b8:	9b01      	ldr	r3, [sp, #4]
    39ba:	2b00      	cmp	r3, #0
    39bc:	d10b      	bne.n	39d6 <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    39be:	2305      	movs	r3, #5
    39c0:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    39c2:	2301      	movs	r3, #1
    39c4:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    39c8:	2301      	movs	r3, #1
    39ca:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    39ce:	2301      	movs	r3, #1
    39d0:	f88d 3010 	strb.w	r3, [sp, #16]
    39d4:	e00e      	b.n	39f4 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    39d6:	9b01      	ldr	r3, [sp, #4]
    39d8:	681b      	ldr	r3, [r3, #0]
    39da:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    39dc:	9b01      	ldr	r3, [sp, #4]
    39de:	79db      	ldrb	r3, [r3, #7]
    39e0:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    39e4:	9b01      	ldr	r3, [sp, #4]
    39e6:	889b      	ldrh	r3, [r3, #4]
    39e8:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    39ec:	9b01      	ldr	r3, [sp, #4]
    39ee:	7a1b      	ldrb	r3, [r3, #8]
    39f0:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    39f4:	4b32      	ldr	r3, [pc, #200]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    39f6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    39fa:	4a31      	ldr	r2, [pc, #196]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    39fc:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3a00:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    3a04:	4b2e      	ldr	r3, [pc, #184]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a06:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3a0a:	4a2d      	ldr	r2, [pc, #180]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a0c:	f023 0301 	bic.w	r3, r3, #1
    3a10:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3a14:	4b2a      	ldr	r3, [pc, #168]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a16:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3a1a:	4a29      	ldr	r2, [pc, #164]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a1c:	f023 0304 	bic.w	r3, r3, #4
    3a20:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    3a24:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    3a28:	2b01      	cmp	r3, #1
    3a2a:	d144      	bne.n	3ab6 <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    3a2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    3a30:	4a23      	ldr	r2, [pc, #140]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a32:	f003 0301 	and.w	r3, r3, #1
    3a36:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3a3a:	4b21      	ldr	r3, [pc, #132]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a3c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3a40:	4a1f      	ldr	r2, [pc, #124]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a42:	f043 0301 	orr.w	r3, r3, #1
    3a46:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    3a4a:	4b1d      	ldr	r3, [pc, #116]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a4c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3a50:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3a54:	009b      	lsls	r3, r3, #2
    3a56:	f003 0304 	and.w	r3, r3, #4
    3a5a:	4919      	ldr	r1, [pc, #100]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a5c:	4313      	orrs	r3, r2
    3a5e:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3a62:	aa05      	add	r2, sp, #20
    3a64:	a906      	add	r1, sp, #24
    3a66:	a807      	add	r0, sp, #28
    3a68:	f24c 3350 	movw	r3, #50000	; 0xc350
    3a6c:	f7ff f8f8 	bl	2c60 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3a70:	4b13      	ldr	r3, [pc, #76]	; (3ac0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3a72:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3a76:	0e1b      	lsrs	r3, r3, #24
    3a78:	f003 0301 	and.w	r3, r3, #1
    3a7c:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3a7e:	9a05      	ldr	r2, [sp, #20]
    3a80:	a906      	add	r1, sp, #24
    3a82:	ab07      	add	r3, sp, #28
    3a84:	4618      	mov	r0, r3
    3a86:	f7ff f905 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3a8a:	4603      	mov	r3, r0
    3a8c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3a90:	9b08      	ldr	r3, [sp, #32]
    3a92:	2b00      	cmp	r3, #0
    3a94:	d106      	bne.n	3aa4 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    3a96:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3a9a:	f083 0301 	eor.w	r3, r3, #1
    3a9e:	b2db      	uxtb	r3, r3
    3aa0:	2b00      	cmp	r3, #0
    3aa2:	d1e5      	bne.n	3a70 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    3aa4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3aa8:	2b00      	cmp	r3, #0
    3aaa:	d004      	beq.n	3ab6 <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    3aac:	9b02      	ldr	r3, [sp, #8]
    3aae:	4619      	mov	r1, r3
    3ab0:	2001      	movs	r0, #1
    3ab2:	f7ff f8c5 	bl	2c40 <Clock_Ip_ReportClockErrors>
        }
    }
}
    3ab6:	bf00      	nop
    3ab8:	b00b      	add	sp, #44	; 0x2c
    3aba:	f85d fb04 	ldr.w	pc, [sp], #4
    3abe:	bf00      	nop
    3ac0:	40064000 	.word	0x40064000

00003ac4 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3ac4:	b500      	push	{lr}
    3ac6:	b089      	sub	sp, #36	; 0x24
    3ac8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3aca:	2300      	movs	r3, #0
    3acc:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3ad0:	4b1f      	ldr	r3, [pc, #124]	; (3b50 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3ad2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ad6:	4a1e      	ldr	r2, [pc, #120]	; (3b50 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3ad8:	f043 0301 	orr.w	r3, r3, #1
    3adc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    3ae0:	4b1b      	ldr	r3, [pc, #108]	; (3b50 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3ae2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ae6:	4a1a      	ldr	r2, [pc, #104]	; (3b50 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3ae8:	f043 0304 	orr.w	r3, r3, #4
    3aec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3af0:	aa03      	add	r2, sp, #12
    3af2:	a904      	add	r1, sp, #16
    3af4:	a805      	add	r0, sp, #20
    3af6:	f24c 3350 	movw	r3, #50000	; 0xc350
    3afa:	f7ff f8b1 	bl	2c60 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3afe:	4b14      	ldr	r3, [pc, #80]	; (3b50 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3b00:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b04:	0e1b      	lsrs	r3, r3, #24
    3b06:	f003 0301 	and.w	r3, r3, #1
    3b0a:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3b0c:	9a03      	ldr	r2, [sp, #12]
    3b0e:	a904      	add	r1, sp, #16
    3b10:	ab05      	add	r3, sp, #20
    3b12:	4618      	mov	r0, r3
    3b14:	f7ff f8be 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3b18:	4603      	mov	r3, r0
    3b1a:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3b1e:	9b06      	ldr	r3, [sp, #24]
    3b20:	2b00      	cmp	r3, #0
    3b22:	d106      	bne.n	3b32 <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    3b24:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3b28:	f083 0301 	eor.w	r3, r3, #1
    3b2c:	b2db      	uxtb	r3, r3
    3b2e:	2b00      	cmp	r3, #0
    3b30:	d1e5      	bne.n	3afe <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    3b32:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3b36:	2b00      	cmp	r3, #0
    3b38:	d005      	beq.n	3b46 <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3b3a:	9b01      	ldr	r3, [sp, #4]
    3b3c:	681b      	ldr	r3, [r3, #0]
    3b3e:	4619      	mov	r1, r3
    3b40:	2001      	movs	r0, #1
    3b42:	f7ff f87d 	bl	2c40 <Clock_Ip_ReportClockErrors>
    }
}
    3b46:	bf00      	nop
    3b48:	b009      	add	sp, #36	; 0x24
    3b4a:	f85d fb04 	ldr.w	pc, [sp], #4
    3b4e:	bf00      	nop
    3b50:	40064000 	.word	0x40064000

00003b54 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    3b54:	b082      	sub	sp, #8
    3b56:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    3b58:	4b09      	ldr	r3, [pc, #36]	; (3b80 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3b5a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b5e:	4a08      	ldr	r2, [pc, #32]	; (3b80 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3b60:	f023 0301 	bic.w	r3, r3, #1
    3b64:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3b68:	4b05      	ldr	r3, [pc, #20]	; (3b80 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3b6a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b6e:	4a04      	ldr	r2, [pc, #16]	; (3b80 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3b70:	f023 0304 	bic.w	r3, r3, #4
    3b74:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3b78:	bf00      	nop
    3b7a:	b002      	add	sp, #8
    3b7c:	4770      	bx	lr
    3b7e:	bf00      	nop
    3b80:	40064000 	.word	0x40064000

00003b84 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3b84:	b082      	sub	sp, #8
    3b86:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3b88:	4b0f      	ldr	r3, [pc, #60]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3b8a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b8e:	4a0e      	ldr	r2, [pc, #56]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3b90:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3b94:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3b98:	4b0b      	ldr	r3, [pc, #44]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3b9a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b9e:	4a0a      	ldr	r2, [pc, #40]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3ba0:	f023 0304 	bic.w	r3, r3, #4
    3ba4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    3ba8:	4b07      	ldr	r3, [pc, #28]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3baa:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3bae:	9b01      	ldr	r3, [sp, #4]
    3bb0:	7a1b      	ldrb	r3, [r3, #8]
    3bb2:	009b      	lsls	r3, r3, #2
    3bb4:	f003 0304 	and.w	r3, r3, #4
    3bb8:	4903      	ldr	r1, [pc, #12]	; (3bc8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3bba:	4313      	orrs	r3, r2
    3bbc:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3bc0:	bf00      	nop
    3bc2:	b002      	add	sp, #8
    3bc4:	4770      	bx	lr
    3bc6:	bf00      	nop
    3bc8:	40064000 	.word	0x40064000

00003bcc <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3bcc:	b082      	sub	sp, #8
    3bce:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3bd0:	9b01      	ldr	r3, [sp, #4]
    3bd2:	889b      	ldrh	r3, [r3, #4]
    3bd4:	2b01      	cmp	r3, #1
    3bd6:	d107      	bne.n	3be8 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    3bd8:	4b05      	ldr	r3, [pc, #20]	; (3bf0 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3bda:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3bde:	4a04      	ldr	r2, [pc, #16]	; (3bf0 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3be0:	f043 0304 	orr.w	r3, r3, #4
    3be4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3be8:	bf00      	nop
    3bea:	b002      	add	sp, #8
    3bec:	4770      	bx	lr
    3bee:	bf00      	nop
    3bf0:	40064000 	.word	0x40064000

00003bf4 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    3bf4:	b082      	sub	sp, #8
    3bf6:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3bf8:	4b05      	ldr	r3, [pc, #20]	; (3c10 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3bfa:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3bfe:	4a04      	ldr	r2, [pc, #16]	; (3c10 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3c00:	f023 0304 	bic.w	r3, r3, #4
    3c04:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3c08:	bf00      	nop
    3c0a:	b002      	add	sp, #8
    3c0c:	4770      	bx	lr
    3c0e:	bf00      	nop
    3c10:	40064000 	.word	0x40064000

00003c14 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3c14:	b082      	sub	sp, #8
    3c16:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3c18:	4b0f      	ldr	r3, [pc, #60]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c1a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c1e:	4a0e      	ldr	r2, [pc, #56]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c20:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3c24:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3c28:	4b0b      	ldr	r3, [pc, #44]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c2a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c2e:	4a0a      	ldr	r2, [pc, #40]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c30:	f023 0302 	bic.w	r3, r3, #2
    3c34:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    3c38:	4b07      	ldr	r3, [pc, #28]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c3a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3c3e:	9b01      	ldr	r3, [sp, #4]
    3c40:	7a5b      	ldrb	r3, [r3, #9]
    3c42:	005b      	lsls	r3, r3, #1
    3c44:	f003 0302 	and.w	r3, r3, #2
    3c48:	4903      	ldr	r1, [pc, #12]	; (3c58 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3c4a:	4313      	orrs	r3, r2
    3c4c:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3c50:	bf00      	nop
    3c52:	b002      	add	sp, #8
    3c54:	4770      	bx	lr
    3c56:	bf00      	nop
    3c58:	40064000 	.word	0x40064000

00003c5c <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3c5c:	b082      	sub	sp, #8
    3c5e:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3c60:	9b01      	ldr	r3, [sp, #4]
    3c62:	889b      	ldrh	r3, [r3, #4]
    3c64:	2b01      	cmp	r3, #1
    3c66:	d107      	bne.n	3c78 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    3c68:	4b05      	ldr	r3, [pc, #20]	; (3c80 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3c6a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c6e:	4a04      	ldr	r2, [pc, #16]	; (3c80 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3c70:	f043 0302 	orr.w	r3, r3, #2
    3c74:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3c78:	bf00      	nop
    3c7a:	b002      	add	sp, #8
    3c7c:	4770      	bx	lr
    3c7e:	bf00      	nop
    3c80:	40064000 	.word	0x40064000

00003c84 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    3c84:	b082      	sub	sp, #8
    3c86:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3c88:	4b05      	ldr	r3, [pc, #20]	; (3ca0 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3c8a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c8e:	4a04      	ldr	r2, [pc, #16]	; (3ca0 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3c90:	f023 0302 	bic.w	r3, r3, #2
    3c94:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3c98:	bf00      	nop
    3c9a:	b002      	add	sp, #8
    3c9c:	4770      	bx	lr
    3c9e:	bf00      	nop
    3ca0:	40064000 	.word	0x40064000

00003ca4 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3ca4:	b500      	push	{lr}
    3ca6:	b08b      	sub	sp, #44	; 0x2c
    3ca8:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3caa:	9b01      	ldr	r3, [sp, #4]
    3cac:	681a      	ldr	r2, [r3, #0]
    3cae:	4975      	ldr	r1, [pc, #468]	; (3e84 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    3cb0:	4613      	mov	r3, r2
    3cb2:	00db      	lsls	r3, r3, #3
    3cb4:	4413      	add	r3, r2
    3cb6:	440b      	add	r3, r1
    3cb8:	781b      	ldrb	r3, [r3, #0]
    3cba:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    3cbc:	2300      	movs	r3, #0
    3cbe:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    3cc2:	2300      	movs	r3, #0
    3cc4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    3cc8:	4b6f      	ldr	r3, [pc, #444]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3cca:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3cce:	4a6e      	ldr	r2, [pc, #440]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3cd0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3cd4:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    3cd8:	4b6b      	ldr	r3, [pc, #428]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3cda:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3cde:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    3ce2:	2b00      	cmp	r3, #0
    3ce4:	d07d      	beq.n	3de2 <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3ce6:	9b01      	ldr	r3, [sp, #4]
    3ce8:	79db      	ldrb	r3, [r3, #7]
    3cea:	461a      	mov	r2, r3
    3cec:	4b66      	ldr	r3, [pc, #408]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3cee:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3cf2:	f003 0303 	and.w	r3, r3, #3
    3cf6:	429a      	cmp	r2, r3
    3cf8:	d10b      	bne.n	3d12 <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    3cfa:	9b01      	ldr	r3, [sp, #4]
    3cfc:	799b      	ldrb	r3, [r3, #6]
    3cfe:	461a      	mov	r2, r3
    3d00:	4b61      	ldr	r3, [pc, #388]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d02:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3d06:	08db      	lsrs	r3, r3, #3
    3d08:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3d0c:	429a      	cmp	r2, r3
    3d0e:	f000 80b4 	beq.w	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    3d12:	4b5d      	ldr	r3, [pc, #372]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d14:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d18:	f003 0301 	and.w	r3, r3, #1
    3d1c:	2b00      	cmp	r3, #0
    3d1e:	d105      	bne.n	3d2c <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    3d20:	2301      	movs	r3, #1
    3d22:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    3d26:	2000      	movs	r0, #0
    3d28:	f7ff fd66 	bl	37f8 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    3d2c:	2002      	movs	r0, #2
    3d2e:	f7ff fdcf 	bl	38d0 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3d32:	4b55      	ldr	r3, [pc, #340]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d34:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3d38:	4a53      	ldr	r2, [pc, #332]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d3a:	f023 0301 	bic.w	r3, r3, #1
    3d3e:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    3d42:	9b01      	ldr	r3, [sp, #4]
    3d44:	889b      	ldrh	r3, [r3, #4]
    3d46:	2b01      	cmp	r3, #1
    3d48:	f040 8097 	bne.w	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3d4c:	9b01      	ldr	r3, [sp, #4]
    3d4e:	79db      	ldrb	r3, [r3, #7]
    3d50:	4a4d      	ldr	r2, [pc, #308]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d52:	f003 0303 	and.w	r3, r3, #3
    3d56:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    3d5a:	4b4b      	ldr	r3, [pc, #300]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d5c:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3d60:	9b01      	ldr	r3, [sp, #4]
    3d62:	799b      	ldrb	r3, [r3, #6]
    3d64:	00db      	lsls	r3, r3, #3
    3d66:	f003 0308 	and.w	r3, r3, #8
    3d6a:	4313      	orrs	r3, r2
    3d6c:	4a46      	ldr	r2, [pc, #280]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d6e:	f043 0301 	orr.w	r3, r3, #1
    3d72:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3d76:	aa03      	add	r2, sp, #12
    3d78:	a904      	add	r1, sp, #16
    3d7a:	a805      	add	r0, sp, #20
    3d7c:	f24c 3350 	movw	r3, #50000	; 0xc350
    3d80:	f7fe ff6e 	bl	2c60 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3d84:	4b40      	ldr	r3, [pc, #256]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3d86:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3d8a:	0e1b      	lsrs	r3, r3, #24
    3d8c:	f003 0301 	and.w	r3, r3, #1
    3d90:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3d92:	9a03      	ldr	r2, [sp, #12]
    3d94:	a904      	add	r1, sp, #16
    3d96:	ab05      	add	r3, sp, #20
    3d98:	4618      	mov	r0, r3
    3d9a:	f7fe ff7b 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3d9e:	4603      	mov	r3, r0
    3da0:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3da4:	9b06      	ldr	r3, [sp, #24]
    3da6:	2b00      	cmp	r3, #0
    3da8:	d106      	bne.n	3db8 <Clock_Ip_SetFirc_TrustedCall+0x114>
    3daa:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3dae:	f083 0301 	eor.w	r3, r3, #1
    3db2:	b2db      	uxtb	r3, r3
    3db4:	2b00      	cmp	r3, #0
    3db6:	d1e5      	bne.n	3d84 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    3db8:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3dbc:	2b00      	cmp	r3, #0
    3dbe:	d005      	beq.n	3dcc <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3dc0:	9b01      	ldr	r3, [sp, #4]
    3dc2:	681b      	ldr	r3, [r3, #0]
    3dc4:	4619      	mov	r1, r3
    3dc6:	2001      	movs	r0, #1
    3dc8:	f7fe ff3a 	bl	2c40 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    3dcc:	2003      	movs	r0, #3
    3dce:	f7ff fd7f 	bl	38d0 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    3dd2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3dd6:	2b00      	cmp	r3, #0
    3dd8:	d04f      	beq.n	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    3dda:	2002      	movs	r0, #2
    3ddc:	f7ff fd26 	bl	382c <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    3de0:	e04b      	b.n	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3de2:	4b29      	ldr	r3, [pc, #164]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3de4:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3de8:	4a27      	ldr	r2, [pc, #156]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3dea:	f023 0301 	bic.w	r3, r3, #1
    3dee:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    3df2:	9b01      	ldr	r3, [sp, #4]
    3df4:	889b      	ldrh	r3, [r3, #4]
    3df6:	2b01      	cmp	r3, #1
    3df8:	d13f      	bne.n	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3dfa:	9b01      	ldr	r3, [sp, #4]
    3dfc:	79db      	ldrb	r3, [r3, #7]
    3dfe:	4a22      	ldr	r2, [pc, #136]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e00:	f003 0303 	and.w	r3, r3, #3
    3e04:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    3e08:	4b1f      	ldr	r3, [pc, #124]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e0a:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3e0e:	9b01      	ldr	r3, [sp, #4]
    3e10:	799b      	ldrb	r3, [r3, #6]
    3e12:	00db      	lsls	r3, r3, #3
    3e14:	f003 0308 	and.w	r3, r3, #8
    3e18:	4313      	orrs	r3, r2
    3e1a:	4a1b      	ldr	r2, [pc, #108]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e1c:	f043 0301 	orr.w	r3, r3, #1
    3e20:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3e24:	aa03      	add	r2, sp, #12
    3e26:	a904      	add	r1, sp, #16
    3e28:	a805      	add	r0, sp, #20
    3e2a:	f24c 3350 	movw	r3, #50000	; 0xc350
    3e2e:	f7fe ff17 	bl	2c60 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3e32:	4b15      	ldr	r3, [pc, #84]	; (3e88 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e34:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3e38:	0e1b      	lsrs	r3, r3, #24
    3e3a:	f003 0301 	and.w	r3, r3, #1
    3e3e:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3e40:	9a03      	ldr	r2, [sp, #12]
    3e42:	a904      	add	r1, sp, #16
    3e44:	ab05      	add	r3, sp, #20
    3e46:	4618      	mov	r0, r3
    3e48:	f7fe ff24 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3e4c:	4603      	mov	r3, r0
    3e4e:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3e52:	9b06      	ldr	r3, [sp, #24]
    3e54:	2b00      	cmp	r3, #0
    3e56:	d106      	bne.n	3e66 <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    3e58:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e5c:	f083 0301 	eor.w	r3, r3, #1
    3e60:	b2db      	uxtb	r3, r3
    3e62:	2b00      	cmp	r3, #0
    3e64:	d1e5      	bne.n	3e32 <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    3e66:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e6a:	2b00      	cmp	r3, #0
    3e6c:	d005      	beq.n	3e7a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3e6e:	9b01      	ldr	r3, [sp, #4]
    3e70:	681b      	ldr	r3, [r3, #0]
    3e72:	4619      	mov	r1, r3
    3e74:	2001      	movs	r0, #1
    3e76:	f7fe fee3 	bl	2c40 <Clock_Ip_ReportClockErrors>
}
    3e7a:	bf00      	nop
    3e7c:	b00b      	add	sp, #44	; 0x2c
    3e7e:	f85d fb04 	ldr.w	pc, [sp], #4
    3e82:	bf00      	nop
    3e84:	0000a740 	.word	0x0000a740
    3e88:	40064000 	.word	0x40064000

00003e8c <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3e8c:	b500      	push	{lr}
    3e8e:	b089      	sub	sp, #36	; 0x24
    3e90:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3e92:	2300      	movs	r3, #0
    3e94:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    3e98:	9b01      	ldr	r3, [sp, #4]
    3e9a:	889b      	ldrh	r3, [r3, #4]
    3e9c:	2b01      	cmp	r3, #1
    3e9e:	d132      	bne.n	3f06 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    3ea0:	4b1b      	ldr	r3, [pc, #108]	; (3f10 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    3ea2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ea6:	4a1a      	ldr	r2, [pc, #104]	; (3f10 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    3ea8:	f043 0301 	orr.w	r3, r3, #1
    3eac:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3eb0:	aa03      	add	r2, sp, #12
    3eb2:	a904      	add	r1, sp, #16
    3eb4:	a805      	add	r0, sp, #20
    3eb6:	f24c 3350 	movw	r3, #50000	; 0xc350
    3eba:	f7fe fed1 	bl	2c60 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3ebe:	4b14      	ldr	r3, [pc, #80]	; (3f10 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    3ec0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ec4:	0e1b      	lsrs	r3, r3, #24
    3ec6:	f003 0301 	and.w	r3, r3, #1
    3eca:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3ecc:	9a03      	ldr	r2, [sp, #12]
    3ece:	a904      	add	r1, sp, #16
    3ed0:	ab05      	add	r3, sp, #20
    3ed2:	4618      	mov	r0, r3
    3ed4:	f7fe fede 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3ed8:	4603      	mov	r3, r0
    3eda:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3ede:	9b06      	ldr	r3, [sp, #24]
    3ee0:	2b00      	cmp	r3, #0
    3ee2:	d106      	bne.n	3ef2 <Clock_Ip_EnableFirc_TrustedCall+0x66>
    3ee4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ee8:	f083 0301 	eor.w	r3, r3, #1
    3eec:	b2db      	uxtb	r3, r3
    3eee:	2b00      	cmp	r3, #0
    3ef0:	d1e5      	bne.n	3ebe <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    3ef2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ef6:	2b00      	cmp	r3, #0
    3ef8:	d005      	beq.n	3f06 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3efa:	9b01      	ldr	r3, [sp, #4]
    3efc:	681b      	ldr	r3, [r3, #0]
    3efe:	4619      	mov	r1, r3
    3f00:	2001      	movs	r0, #1
    3f02:	f7fe fe9d 	bl	2c40 <Clock_Ip_ReportClockErrors>
        }
    }
}
    3f06:	bf00      	nop
    3f08:	b009      	add	sp, #36	; 0x24
    3f0a:	f85d fb04 	ldr.w	pc, [sp], #4
    3f0e:	bf00      	nop
    3f10:	40064000 	.word	0x40064000

00003f14 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    3f14:	b082      	sub	sp, #8
    3f16:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    3f18:	4b05      	ldr	r3, [pc, #20]	; (3f30 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    3f1a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f1e:	4a04      	ldr	r2, [pc, #16]	; (3f30 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    3f20:	f023 0301 	bic.w	r3, r3, #1
    3f24:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    3f28:	bf00      	nop
    3f2a:	b002      	add	sp, #8
    3f2c:	4770      	bx	lr
    3f2e:	bf00      	nop
    3f30:	40064000 	.word	0x40064000

00003f34 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    3f34:	b082      	sub	sp, #8
    3f36:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3f38:	bf00      	nop
    3f3a:	b002      	add	sp, #8
    3f3c:	4770      	bx	lr

00003f3e <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    3f3e:	b082      	sub	sp, #8
    3f40:	9001      	str	r0, [sp, #4]
    3f42:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    3f44:	bf00      	nop
    3f46:	b002      	add	sp, #8
    3f48:	4770      	bx	lr

00003f4a <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    3f4a:	b082      	sub	sp, #8
    3f4c:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3f4e:	bf00      	nop
    3f50:	b002      	add	sp, #8
    3f52:	4770      	bx	lr

00003f54 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    3f54:	b082      	sub	sp, #8
    3f56:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3f58:	bf00      	nop
    3f5a:	b002      	add	sp, #8
    3f5c:	4770      	bx	lr

00003f5e <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    3f5e:	b082      	sub	sp, #8
    3f60:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    3f62:	2302      	movs	r3, #2
}
    3f64:	4618      	mov	r0, r3
    3f66:	b002      	add	sp, #8
    3f68:	4770      	bx	lr

00003f6a <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    3f6a:	b082      	sub	sp, #8
    3f6c:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    3f6e:	bf00      	nop
    3f70:	b002      	add	sp, #8
    3f72:	4770      	bx	lr

00003f74 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    3f74:	b500      	push	{lr}
    3f76:	b083      	sub	sp, #12
    3f78:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3f7a:	9b01      	ldr	r3, [sp, #4]
    3f7c:	2b00      	cmp	r3, #0
    3f7e:	d002      	beq.n	3f86 <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    3f80:	9801      	ldr	r0, [sp, #4]
    3f82:	f000 f870 	bl	4066 <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3f86:	bf00      	nop
    3f88:	b003      	add	sp, #12
    3f8a:	f85d fb04 	ldr.w	pc, [sp], #4

00003f8e <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    3f8e:	b500      	push	{lr}
    3f90:	b083      	sub	sp, #12
    3f92:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3f94:	9b01      	ldr	r3, [sp, #4]
    3f96:	2b00      	cmp	r3, #0
    3f98:	d002      	beq.n	3fa0 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    3f9a:	9801      	ldr	r0, [sp, #4]
    3f9c:	f000 f89a 	bl	40d4 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3fa0:	bf00      	nop
    3fa2:	b003      	add	sp, #12
    3fa4:	f85d fb04 	ldr.w	pc, [sp], #4

00003fa8 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    3fa8:	b500      	push	{lr}
    3faa:	b089      	sub	sp, #36	; 0x24
    3fac:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    3fae:	2301      	movs	r3, #1
    3fb0:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    3fb2:	2300      	movs	r3, #0
    3fb4:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    3fb8:	4b1e      	ldr	r3, [pc, #120]	; (4034 <Clock_Ip_CompleteSpll+0x8c>)
    3fba:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3fbe:	f003 0301 	and.w	r3, r3, #1
    3fc2:	2b00      	cmp	r3, #0
    3fc4:	d02f      	beq.n	4026 <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3fc6:	aa02      	add	r2, sp, #8
    3fc8:	a903      	add	r1, sp, #12
    3fca:	a804      	add	r0, sp, #16
    3fcc:	f24c 3350 	movw	r3, #50000	; 0xc350
    3fd0:	f7fe fe46 	bl	2c60 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    3fd4:	4b17      	ldr	r3, [pc, #92]	; (4034 <Clock_Ip_CompleteSpll+0x8c>)
    3fd6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3fda:	0e1b      	lsrs	r3, r3, #24
    3fdc:	f003 0301 	and.w	r3, r3, #1
    3fe0:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3fe2:	9a02      	ldr	r2, [sp, #8]
    3fe4:	a903      	add	r1, sp, #12
    3fe6:	ab04      	add	r3, sp, #16
    3fe8:	4618      	mov	r0, r3
    3fea:	f7fe fe53 	bl	2c94 <Clock_Ip_TimeoutExpired>
    3fee:	4603      	mov	r3, r0
    3ff0:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    3ff4:	9b05      	ldr	r3, [sp, #20]
    3ff6:	2b00      	cmp	r3, #0
    3ff8:	d106      	bne.n	4008 <Clock_Ip_CompleteSpll+0x60>
    3ffa:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3ffe:	f083 0301 	eor.w	r3, r3, #1
    4002:	b2db      	uxtb	r3, r3
    4004:	2b00      	cmp	r3, #0
    4006:	d1e5      	bne.n	3fd4 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    4008:	f89d 301b 	ldrb.w	r3, [sp, #27]
    400c:	f083 0301 	eor.w	r3, r3, #1
    4010:	b2db      	uxtb	r3, r3
    4012:	2b00      	cmp	r3, #0
    4014:	d002      	beq.n	401c <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    4016:	2302      	movs	r3, #2
    4018:	9307      	str	r3, [sp, #28]
    401a:	e006      	b.n	402a <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    401c:	9901      	ldr	r1, [sp, #4]
    401e:	2001      	movs	r0, #1
    4020:	f7fe fe0e 	bl	2c40 <Clock_Ip_ReportClockErrors>
    4024:	e001      	b.n	402a <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    4026:	2300      	movs	r3, #0
    4028:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    402a:	9b07      	ldr	r3, [sp, #28]
}
    402c:	4618      	mov	r0, r3
    402e:	b009      	add	sp, #36	; 0x24
    4030:	f85d fb04 	ldr.w	pc, [sp], #4
    4034:	40064000 	.word	0x40064000

00004038 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    4038:	b500      	push	{lr}
    403a:	b083      	sub	sp, #12
    403c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    403e:	9801      	ldr	r0, [sp, #4]
    4040:	f000 f886 	bl	4150 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    4044:	bf00      	nop
    4046:	b003      	add	sp, #12
    4048:	f85d fb04 	ldr.w	pc, [sp], #4

0000404c <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    404c:	b500      	push	{lr}
    404e:	b083      	sub	sp, #12
    4050:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4052:	9b01      	ldr	r3, [sp, #4]
    4054:	2b00      	cmp	r3, #0
    4056:	d002      	beq.n	405e <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    4058:	9801      	ldr	r0, [sp, #4]
    405a:	f000 f891 	bl	4180 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    405e:	bf00      	nop
    4060:	b003      	add	sp, #12
    4062:	f85d fb04 	ldr.w	pc, [sp], #4

00004066 <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4066:	b082      	sub	sp, #8
    4068:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    406a:	4b19      	ldr	r3, [pc, #100]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    406c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4070:	4a17      	ldr	r2, [pc, #92]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4072:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4076:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    407a:	4b15      	ldr	r3, [pc, #84]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    407c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4080:	4a13      	ldr	r2, [pc, #76]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4082:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    4086:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    408a:	4b11      	ldr	r3, [pc, #68]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    408c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4090:	4a0f      	ldr	r2, [pc, #60]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4092:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    4096:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    409a:	4b0d      	ldr	r3, [pc, #52]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    409c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    40a0:	4a0b      	ldr	r2, [pc, #44]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    40a2:	f023 0301 	bic.w	r3, r3, #1
    40a6:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    40aa:	4b09      	ldr	r3, [pc, #36]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    40ac:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    40b0:	4a07      	ldr	r2, [pc, #28]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    40b2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    40b6:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    40ba:	4b05      	ldr	r3, [pc, #20]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    40bc:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    40c0:	4a03      	ldr	r2, [pc, #12]	; (40d0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    40c2:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    40c6:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    40ca:	bf00      	nop
    40cc:	b002      	add	sp, #8
    40ce:	4770      	bx	lr
    40d0:	40064000 	.word	0x40064000

000040d4 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    40d4:	b082      	sub	sp, #8
    40d6:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    40d8:	9b01      	ldr	r3, [sp, #4]
    40da:	889b      	ldrh	r3, [r3, #4]
    40dc:	2b01      	cmp	r3, #1
    40de:	d12f      	bne.n	4140 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    40e0:	4b1a      	ldr	r3, [pc, #104]	; (414c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    40e2:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    40e6:	9b01      	ldr	r3, [sp, #4]
    40e8:	7b5b      	ldrb	r3, [r3, #13]
    40ea:	3b01      	subs	r3, #1
    40ec:	021b      	lsls	r3, r3, #8
    40ee:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    40f2:	9b01      	ldr	r3, [sp, #4]
    40f4:	7d1b      	ldrb	r3, [r3, #20]
    40f6:	3b10      	subs	r3, #16
    40f8:	041b      	lsls	r3, r3, #16
    40fa:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    40fe:	430b      	orrs	r3, r1
    4100:	4912      	ldr	r1, [pc, #72]	; (414c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4102:	4313      	orrs	r3, r2
    4104:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    4108:	9b01      	ldr	r3, [sp, #4]
    410a:	7fdb      	ldrb	r3, [r3, #31]
    410c:	2b02      	cmp	r3, #2
    410e:	d011      	beq.n	4134 <Clock_Ip_SetSpll_TrustedCall+0x60>
    4110:	2b02      	cmp	r3, #2
    4112:	dc17      	bgt.n	4144 <Clock_Ip_SetSpll_TrustedCall+0x70>
    4114:	2b00      	cmp	r3, #0
    4116:	d002      	beq.n	411e <Clock_Ip_SetSpll_TrustedCall+0x4a>
    4118:	2b01      	cmp	r3, #1
    411a:	d005      	beq.n	4128 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    411c:	e012      	b.n	4144 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    411e:	4b0b      	ldr	r3, [pc, #44]	; (414c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4120:	2200      	movs	r2, #0
    4122:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4126:	e00e      	b.n	4146 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4128:	4b08      	ldr	r3, [pc, #32]	; (414c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    412a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    412e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4132:	e008      	b.n	4146 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4134:	4b05      	ldr	r3, [pc, #20]	; (414c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4136:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    413a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    413e:	e002      	b.n	4146 <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    4140:	bf00      	nop
    4142:	e000      	b.n	4146 <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    4144:	bf00      	nop
}
    4146:	bf00      	nop
    4148:	b002      	add	sp, #8
    414a:	4770      	bx	lr
    414c:	40064000 	.word	0x40064000

00004150 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    4150:	b082      	sub	sp, #8
    4152:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4154:	4b09      	ldr	r3, [pc, #36]	; (417c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4156:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    415a:	4a08      	ldr	r2, [pc, #32]	; (417c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    415c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4160:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4164:	4b05      	ldr	r3, [pc, #20]	; (417c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4166:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    416a:	4a04      	ldr	r2, [pc, #16]	; (417c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    416c:	f023 0301 	bic.w	r3, r3, #1
    4170:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    4174:	bf00      	nop
    4176:	b002      	add	sp, #8
    4178:	4770      	bx	lr
    417a:	bf00      	nop
    417c:	40064000 	.word	0x40064000

00004180 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4180:	b082      	sub	sp, #8
    4182:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    4184:	9b01      	ldr	r3, [sp, #4]
    4186:	889b      	ldrh	r3, [r3, #4]
    4188:	2b01      	cmp	r3, #1
    418a:	d107      	bne.n	419c <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    418c:	4b05      	ldr	r3, [pc, #20]	; (41a4 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    418e:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4192:	4a04      	ldr	r2, [pc, #16]	; (41a4 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    4194:	f043 0301 	orr.w	r3, r3, #1
    4198:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    419c:	bf00      	nop
    419e:	b002      	add	sp, #8
    41a0:	4770      	bx	lr
    41a2:	bf00      	nop
    41a4:	40064000 	.word	0x40064000

000041a8 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    41a8:	b082      	sub	sp, #8
    41aa:	9001      	str	r0, [sp, #4]
    41ac:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    41ae:	bf00      	nop
    41b0:	b002      	add	sp, #8
    41b2:	4770      	bx	lr

000041b4 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    41b4:	b082      	sub	sp, #8
    41b6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    41b8:	bf00      	nop
    41ba:	b002      	add	sp, #8
    41bc:	4770      	bx	lr

000041be <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    41be:	b500      	push	{lr}
    41c0:	b083      	sub	sp, #12
    41c2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    41c4:	9b01      	ldr	r3, [sp, #4]
    41c6:	2b00      	cmp	r3, #0
    41c8:	d002      	beq.n	41d0 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    41ca:	9801      	ldr	r0, [sp, #4]
    41cc:	f000 f8ee 	bl	43ac <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    41d0:	bf00      	nop
    41d2:	b003      	add	sp, #12
    41d4:	f85d fb04 	ldr.w	pc, [sp], #4

000041d8 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    41d8:	b500      	push	{lr}
    41da:	b083      	sub	sp, #12
    41dc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    41de:	9b01      	ldr	r3, [sp, #4]
    41e0:	2b00      	cmp	r3, #0
    41e2:	d002      	beq.n	41ea <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    41e4:	9801      	ldr	r0, [sp, #4]
    41e6:	f000 f8ff 	bl	43e8 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    41ea:	bf00      	nop
    41ec:	b003      	add	sp, #12
    41ee:	f85d fb04 	ldr.w	pc, [sp], #4

000041f2 <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    41f2:	b500      	push	{lr}
    41f4:	b083      	sub	sp, #12
    41f6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    41f8:	9b01      	ldr	r3, [sp, #4]
    41fa:	2b00      	cmp	r3, #0
    41fc:	d002      	beq.n	4204 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    41fe:	9801      	ldr	r0, [sp, #4]
    4200:	f000 f912 	bl	4428 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4204:	bf00      	nop
    4206:	b003      	add	sp, #12
    4208:	f85d fb04 	ldr.w	pc, [sp], #4

0000420c <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    420c:	b500      	push	{lr}
    420e:	b083      	sub	sp, #12
    4210:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4212:	9b01      	ldr	r3, [sp, #4]
    4214:	2b00      	cmp	r3, #0
    4216:	d002      	beq.n	421e <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    4218:	9801      	ldr	r0, [sp, #4]
    421a:	f000 f925 	bl	4468 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    421e:	bf00      	nop
    4220:	b003      	add	sp, #12
    4222:	f85d fb04 	ldr.w	pc, [sp], #4

00004226 <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4226:	b500      	push	{lr}
    4228:	b083      	sub	sp, #12
    422a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    422c:	9b01      	ldr	r3, [sp, #4]
    422e:	2b00      	cmp	r3, #0
    4230:	d002      	beq.n	4238 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    4232:	9801      	ldr	r0, [sp, #4]
    4234:	f000 f936 	bl	44a4 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4238:	bf00      	nop
    423a:	b003      	add	sp, #12
    423c:	f85d fb04 	ldr.w	pc, [sp], #4

00004240 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    4240:	b500      	push	{lr}
    4242:	b083      	sub	sp, #12
    4244:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4246:	9b01      	ldr	r3, [sp, #4]
    4248:	2b00      	cmp	r3, #0
    424a:	d002      	beq.n	4252 <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    424c:	9801      	ldr	r0, [sp, #4]
    424e:	f000 f949 	bl	44e4 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4252:	bf00      	nop
    4254:	b003      	add	sp, #12
    4256:	f85d fb04 	ldr.w	pc, [sp], #4

0000425a <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    425a:	b500      	push	{lr}
    425c:	b083      	sub	sp, #12
    425e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4260:	9b01      	ldr	r3, [sp, #4]
    4262:	2b00      	cmp	r3, #0
    4264:	d002      	beq.n	426c <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    4266:	9801      	ldr	r0, [sp, #4]
    4268:	f000 f958 	bl	451c <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    426c:	bf00      	nop
    426e:	b003      	add	sp, #12
    4270:	f85d fb04 	ldr.w	pc, [sp], #4

00004274 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    4274:	b500      	push	{lr}
    4276:	b083      	sub	sp, #12
    4278:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    427a:	9b01      	ldr	r3, [sp, #4]
    427c:	2b00      	cmp	r3, #0
    427e:	d002      	beq.n	4286 <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    4280:	9801      	ldr	r0, [sp, #4]
    4282:	f000 f969 	bl	4558 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4286:	bf00      	nop
    4288:	b003      	add	sp, #12
    428a:	f85d fb04 	ldr.w	pc, [sp], #4

0000428e <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    428e:	b500      	push	{lr}
    4290:	b083      	sub	sp, #12
    4292:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4294:	9b01      	ldr	r3, [sp, #4]
    4296:	2b00      	cmp	r3, #0
    4298:	d002      	beq.n	42a0 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    429a:	9801      	ldr	r0, [sp, #4]
    429c:	f000 f978 	bl	4590 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    42a0:	bf00      	nop
    42a2:	b003      	add	sp, #12
    42a4:	f85d fb04 	ldr.w	pc, [sp], #4

000042a8 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    42a8:	b500      	push	{lr}
    42aa:	b083      	sub	sp, #12
    42ac:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    42ae:	9b01      	ldr	r3, [sp, #4]
    42b0:	2b00      	cmp	r3, #0
    42b2:	d002      	beq.n	42ba <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    42b4:	9801      	ldr	r0, [sp, #4]
    42b6:	f000 f989 	bl	45cc <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    42ba:	bf00      	nop
    42bc:	b003      	add	sp, #12
    42be:	f85d fb04 	ldr.w	pc, [sp], #4

000042c2 <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    42c2:	b500      	push	{lr}
    42c4:	b083      	sub	sp, #12
    42c6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    42c8:	9b01      	ldr	r3, [sp, #4]
    42ca:	2b00      	cmp	r3, #0
    42cc:	d002      	beq.n	42d4 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    42ce:	9801      	ldr	r0, [sp, #4]
    42d0:	f000 f998 	bl	4604 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    42d4:	bf00      	nop
    42d6:	b003      	add	sp, #12
    42d8:	f85d fb04 	ldr.w	pc, [sp], #4

000042dc <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    42dc:	b500      	push	{lr}
    42de:	b083      	sub	sp, #12
    42e0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    42e2:	9b01      	ldr	r3, [sp, #4]
    42e4:	2b00      	cmp	r3, #0
    42e6:	d002      	beq.n	42ee <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    42e8:	9801      	ldr	r0, [sp, #4]
    42ea:	f000 f9a9 	bl	4640 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    42ee:	bf00      	nop
    42f0:	b003      	add	sp, #12
    42f2:	f85d fb04 	ldr.w	pc, [sp], #4

000042f6 <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    42f6:	b500      	push	{lr}
    42f8:	b083      	sub	sp, #12
    42fa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    42fc:	9b01      	ldr	r3, [sp, #4]
    42fe:	2b00      	cmp	r3, #0
    4300:	d002      	beq.n	4308 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    4302:	9801      	ldr	r0, [sp, #4]
    4304:	f000 f9e6 	bl	46d4 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4308:	bf00      	nop
    430a:	b003      	add	sp, #12
    430c:	f85d fb04 	ldr.w	pc, [sp], #4

00004310 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4310:	b500      	push	{lr}
    4312:	b083      	sub	sp, #12
    4314:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4316:	9b01      	ldr	r3, [sp, #4]
    4318:	2b00      	cmp	r3, #0
    431a:	d002      	beq.n	4322 <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    431c:	9801      	ldr	r0, [sp, #4]
    431e:	f000 fa25 	bl	476c <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4322:	bf00      	nop
    4324:	b003      	add	sp, #12
    4326:	f85d fb04 	ldr.w	pc, [sp], #4

0000432a <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    432a:	b500      	push	{lr}
    432c:	b083      	sub	sp, #12
    432e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4330:	9b01      	ldr	r3, [sp, #4]
    4332:	2b00      	cmp	r3, #0
    4334:	d002      	beq.n	433c <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    4336:	9801      	ldr	r0, [sp, #4]
    4338:	f000 fa2a 	bl	4790 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    433c:	bf00      	nop
    433e:	b003      	add	sp, #12
    4340:	f85d fb04 	ldr.w	pc, [sp], #4

00004344 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    4344:	b500      	push	{lr}
    4346:	b083      	sub	sp, #12
    4348:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    434a:	9b01      	ldr	r3, [sp, #4]
    434c:	2b00      	cmp	r3, #0
    434e:	d002      	beq.n	4356 <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    4350:	9801      	ldr	r0, [sp, #4]
    4352:	f000 fa3b 	bl	47cc <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4356:	bf00      	nop
    4358:	b003      	add	sp, #12
    435a:	f85d fb04 	ldr.w	pc, [sp], #4

0000435e <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    435e:	b500      	push	{lr}
    4360:	b083      	sub	sp, #12
    4362:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4364:	9b01      	ldr	r3, [sp, #4]
    4366:	2b00      	cmp	r3, #0
    4368:	d002      	beq.n	4370 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    436a:	9801      	ldr	r0, [sp, #4]
    436c:	f000 fa56 	bl	481c <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4370:	bf00      	nop
    4372:	b003      	add	sp, #12
    4374:	f85d fb04 	ldr.w	pc, [sp], #4

00004378 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    4378:	b500      	push	{lr}
    437a:	b083      	sub	sp, #12
    437c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    437e:	9b01      	ldr	r3, [sp, #4]
    4380:	2b00      	cmp	r3, #0
    4382:	d002      	beq.n	438a <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    4384:	9801      	ldr	r0, [sp, #4]
    4386:	f000 fa79 	bl	487c <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    438a:	bf00      	nop
    438c:	b003      	add	sp, #12
    438e:	f85d fb04 	ldr.w	pc, [sp], #4

00004392 <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    4392:	b500      	push	{lr}
    4394:	b083      	sub	sp, #12
    4396:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4398:	9b01      	ldr	r3, [sp, #4]
    439a:	2b00      	cmp	r3, #0
    439c:	d002      	beq.n	43a4 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    439e:	9801      	ldr	r0, [sp, #4]
    43a0:	f000 fa8a 	bl	48b8 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    43a4:	bf00      	nop
    43a6:	b003      	add	sp, #12
    43a8:	f85d fb04 	ldr.w	pc, [sp], #4

000043ac <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    43ac:	b084      	sub	sp, #16
    43ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    43b0:	4b0b      	ldr	r3, [pc, #44]	; (43e0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    43b2:	795b      	ldrb	r3, [r3, #5]
    43b4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    43b6:	4b0b      	ldr	r3, [pc, #44]	; (43e4 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    43b8:	695b      	ldr	r3, [r3, #20]
    43ba:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    43bc:	9b02      	ldr	r3, [sp, #8]
    43be:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    43c2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    43c4:	9b03      	ldr	r3, [sp, #12]
    43c6:	061b      	lsls	r3, r3, #24
    43c8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    43cc:	9a02      	ldr	r2, [sp, #8]
    43ce:	4313      	orrs	r3, r2
    43d0:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    43d2:	4a04      	ldr	r2, [pc, #16]	; (43e4 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    43d4:	9b02      	ldr	r3, [sp, #8]
    43d6:	6153      	str	r3, [r2, #20]
}
    43d8:	bf00      	nop
    43da:	b004      	add	sp, #16
    43dc:	4770      	bx	lr
    43de:	bf00      	nop
    43e0:	0000aaa8 	.word	0x0000aaa8
    43e4:	40064000 	.word	0x40064000

000043e8 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    43e8:	b084      	sub	sp, #16
    43ea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    43ec:	9b01      	ldr	r3, [sp, #4]
    43ee:	685b      	ldr	r3, [r3, #4]
    43f0:	4a0b      	ldr	r2, [pc, #44]	; (4420 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    43f2:	5cd3      	ldrb	r3, [r2, r3]
    43f4:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    43f6:	4b0b      	ldr	r3, [pc, #44]	; (4424 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    43f8:	695b      	ldr	r3, [r3, #20]
    43fa:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    43fc:	9b02      	ldr	r3, [sp, #8]
    43fe:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4402:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    4404:	9b03      	ldr	r3, [sp, #12]
    4406:	061b      	lsls	r3, r3, #24
    4408:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    440c:	9a02      	ldr	r2, [sp, #8]
    440e:	4313      	orrs	r3, r2
    4410:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    4412:	4a04      	ldr	r2, [pc, #16]	; (4424 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    4414:	9b02      	ldr	r3, [sp, #8]
    4416:	6153      	str	r3, [r2, #20]
}
    4418:	bf00      	nop
    441a:	b004      	add	sp, #16
    441c:	4770      	bx	lr
    441e:	bf00      	nop
    4420:	0000aaa8 	.word	0x0000aaa8
    4424:	40064000 	.word	0x40064000

00004428 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4428:	b084      	sub	sp, #16
    442a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    442c:	9b01      	ldr	r3, [sp, #4]
    442e:	685b      	ldr	r3, [r3, #4]
    4430:	4a0b      	ldr	r2, [pc, #44]	; (4460 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    4432:	5cd3      	ldrb	r3, [r2, r3]
    4434:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    4436:	4b0b      	ldr	r3, [pc, #44]	; (4464 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    4438:	699b      	ldr	r3, [r3, #24]
    443a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    443c:	9b02      	ldr	r3, [sp, #8]
    443e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4442:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    4444:	9b03      	ldr	r3, [sp, #12]
    4446:	061b      	lsls	r3, r3, #24
    4448:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    444c:	9a02      	ldr	r2, [sp, #8]
    444e:	4313      	orrs	r3, r2
    4450:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    4452:	4a04      	ldr	r2, [pc, #16]	; (4464 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    4454:	9b02      	ldr	r3, [sp, #8]
    4456:	6193      	str	r3, [r2, #24]
}
    4458:	bf00      	nop
    445a:	b004      	add	sp, #16
    445c:	4770      	bx	lr
    445e:	bf00      	nop
    4460:	0000aaa8 	.word	0x0000aaa8
    4464:	40064000 	.word	0x40064000

00004468 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4468:	b084      	sub	sp, #16
    446a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    446c:	4b0b      	ldr	r3, [pc, #44]	; (449c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    446e:	795b      	ldrb	r3, [r3, #5]
    4470:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    4472:	4b0b      	ldr	r3, [pc, #44]	; (44a0 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    4474:	69db      	ldr	r3, [r3, #28]
    4476:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4478:	9b02      	ldr	r3, [sp, #8]
    447a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    447e:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4480:	9b03      	ldr	r3, [sp, #12]
    4482:	061b      	lsls	r3, r3, #24
    4484:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4488:	9a02      	ldr	r2, [sp, #8]
    448a:	4313      	orrs	r3, r2
    448c:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    448e:	4a04      	ldr	r2, [pc, #16]	; (44a0 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    4490:	9b02      	ldr	r3, [sp, #8]
    4492:	61d3      	str	r3, [r2, #28]
}
    4494:	bf00      	nop
    4496:	b004      	add	sp, #16
    4498:	4770      	bx	lr
    449a:	bf00      	nop
    449c:	0000aaa8 	.word	0x0000aaa8
    44a0:	40064000 	.word	0x40064000

000044a4 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    44a4:	b084      	sub	sp, #16
    44a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    44a8:	9b01      	ldr	r3, [sp, #4]
    44aa:	685b      	ldr	r3, [r3, #4]
    44ac:	4a0b      	ldr	r2, [pc, #44]	; (44dc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    44ae:	5cd3      	ldrb	r3, [r2, r3]
    44b0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    44b2:	4b0b      	ldr	r3, [pc, #44]	; (44e0 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    44b4:	69db      	ldr	r3, [r3, #28]
    44b6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    44b8:	9b02      	ldr	r3, [sp, #8]
    44ba:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    44be:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    44c0:	9b03      	ldr	r3, [sp, #12]
    44c2:	061b      	lsls	r3, r3, #24
    44c4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    44c8:	9a02      	ldr	r2, [sp, #8]
    44ca:	4313      	orrs	r3, r2
    44cc:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    44ce:	4a04      	ldr	r2, [pc, #16]	; (44e0 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    44d0:	9b02      	ldr	r3, [sp, #8]
    44d2:	61d3      	str	r3, [r2, #28]
}
    44d4:	bf00      	nop
    44d6:	b004      	add	sp, #16
    44d8:	4770      	bx	lr
    44da:	bf00      	nop
    44dc:	0000aaa8 	.word	0x0000aaa8
    44e0:	40064000 	.word	0x40064000

000044e4 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    44e4:	b084      	sub	sp, #16
    44e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    44e8:	4b0a      	ldr	r3, [pc, #40]	; (4514 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    44ea:	7b9b      	ldrb	r3, [r3, #14]
    44ec:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    44ee:	4b0a      	ldr	r3, [pc, #40]	; (4518 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    44f0:	691b      	ldr	r3, [r3, #16]
    44f2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    44f4:	9b02      	ldr	r3, [sp, #8]
    44f6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    44fa:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    44fc:	9b03      	ldr	r3, [sp, #12]
    44fe:	011b      	lsls	r3, r3, #4
    4500:	9a02      	ldr	r2, [sp, #8]
    4502:	4313      	orrs	r3, r2
    4504:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4506:	4a04      	ldr	r2, [pc, #16]	; (4518 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4508:	9b02      	ldr	r3, [sp, #8]
    450a:	6113      	str	r3, [r2, #16]
}
    450c:	bf00      	nop
    450e:	b004      	add	sp, #16
    4510:	4770      	bx	lr
    4512:	bf00      	nop
    4514:	0000aa50 	.word	0x0000aa50
    4518:	40048000 	.word	0x40048000

0000451c <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    451c:	b084      	sub	sp, #16
    451e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4520:	9b01      	ldr	r3, [sp, #4]
    4522:	685b      	ldr	r3, [r3, #4]
    4524:	4a0a      	ldr	r2, [pc, #40]	; (4550 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    4526:	5cd3      	ldrb	r3, [r2, r3]
    4528:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    452a:	4b0a      	ldr	r3, [pc, #40]	; (4554 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    452c:	691b      	ldr	r3, [r3, #16]
    452e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    4530:	9b02      	ldr	r3, [sp, #8]
    4532:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4536:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4538:	9b03      	ldr	r3, [sp, #12]
    453a:	011b      	lsls	r3, r3, #4
    453c:	9a02      	ldr	r2, [sp, #8]
    453e:	4313      	orrs	r3, r2
    4540:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4542:	4a04      	ldr	r2, [pc, #16]	; (4554 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    4544:	9b02      	ldr	r3, [sp, #8]
    4546:	6113      	str	r3, [r2, #16]
}
    4548:	bf00      	nop
    454a:	b004      	add	sp, #16
    454c:	4770      	bx	lr
    454e:	bf00      	nop
    4550:	0000aa50 	.word	0x0000aa50
    4554:	40048000 	.word	0x40048000

00004558 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4558:	b084      	sub	sp, #16
    455a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    455c:	4b0a      	ldr	r3, [pc, #40]	; (4588 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    455e:	785b      	ldrb	r3, [r3, #1]
    4560:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4562:	4b0a      	ldr	r3, [pc, #40]	; (458c <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    4564:	691b      	ldr	r3, [r3, #16]
    4566:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    4568:	9b02      	ldr	r3, [sp, #8]
    456a:	f023 030c 	bic.w	r3, r3, #12
    456e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4570:	9b03      	ldr	r3, [sp, #12]
    4572:	009b      	lsls	r3, r3, #2
    4574:	9a02      	ldr	r2, [sp, #8]
    4576:	4313      	orrs	r3, r2
    4578:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    457a:	4a04      	ldr	r2, [pc, #16]	; (458c <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    457c:	9b02      	ldr	r3, [sp, #8]
    457e:	6113      	str	r3, [r2, #16]
}
    4580:	bf00      	nop
    4582:	b004      	add	sp, #16
    4584:	4770      	bx	lr
    4586:	bf00      	nop
    4588:	0000ab08 	.word	0x0000ab08
    458c:	40048000 	.word	0x40048000

00004590 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4590:	b084      	sub	sp, #16
    4592:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4594:	9b01      	ldr	r3, [sp, #4]
    4596:	685b      	ldr	r3, [r3, #4]
    4598:	4a0a      	ldr	r2, [pc, #40]	; (45c4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    459a:	5cd3      	ldrb	r3, [r2, r3]
    459c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    459e:	4b0a      	ldr	r3, [pc, #40]	; (45c8 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    45a0:	691b      	ldr	r3, [r3, #16]
    45a2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    45a4:	9b02      	ldr	r3, [sp, #8]
    45a6:	f023 030c 	bic.w	r3, r3, #12
    45aa:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    45ac:	9b03      	ldr	r3, [sp, #12]
    45ae:	009b      	lsls	r3, r3, #2
    45b0:	9a02      	ldr	r2, [sp, #8]
    45b2:	4313      	orrs	r3, r2
    45b4:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    45b6:	4a04      	ldr	r2, [pc, #16]	; (45c8 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    45b8:	9b02      	ldr	r3, [sp, #8]
    45ba:	6113      	str	r3, [r2, #16]
}
    45bc:	bf00      	nop
    45be:	b004      	add	sp, #16
    45c0:	4770      	bx	lr
    45c2:	bf00      	nop
    45c4:	0000ab08 	.word	0x0000ab08
    45c8:	40048000 	.word	0x40048000

000045cc <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    45cc:	b084      	sub	sp, #16
    45ce:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    45d0:	4b0a      	ldr	r3, [pc, #40]	; (45fc <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    45d2:	795b      	ldrb	r3, [r3, #5]
    45d4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    45d6:	4b0a      	ldr	r3, [pc, #40]	; (4600 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    45d8:	6a1b      	ldr	r3, [r3, #32]
    45da:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    45dc:	9b02      	ldr	r3, [sp, #8]
    45de:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    45e2:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    45e4:	9b03      	ldr	r3, [sp, #12]
    45e6:	061b      	lsls	r3, r3, #24
    45e8:	9a02      	ldr	r2, [sp, #8]
    45ea:	4313      	orrs	r3, r2
    45ec:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    45ee:	4a04      	ldr	r2, [pc, #16]	; (4600 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    45f0:	9b02      	ldr	r3, [sp, #8]
    45f2:	6213      	str	r3, [r2, #32]
}
    45f4:	bf00      	nop
    45f6:	b004      	add	sp, #16
    45f8:	4770      	bx	lr
    45fa:	bf00      	nop
    45fc:	0000aaa8 	.word	0x0000aaa8
    4600:	40064000 	.word	0x40064000

00004604 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4604:	b084      	sub	sp, #16
    4606:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4608:	9b01      	ldr	r3, [sp, #4]
    460a:	685b      	ldr	r3, [r3, #4]
    460c:	4a0a      	ldr	r2, [pc, #40]	; (4638 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    460e:	5cd3      	ldrb	r3, [r2, r3]
    4610:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    4612:	4b0a      	ldr	r3, [pc, #40]	; (463c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    4614:	6a1b      	ldr	r3, [r3, #32]
    4616:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    4618:	9b02      	ldr	r3, [sp, #8]
    461a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    461e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    4620:	9b03      	ldr	r3, [sp, #12]
    4622:	061b      	lsls	r3, r3, #24
    4624:	9a02      	ldr	r2, [sp, #8]
    4626:	4313      	orrs	r3, r2
    4628:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    462a:	4a04      	ldr	r2, [pc, #16]	; (463c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    462c:	9b02      	ldr	r3, [sp, #8]
    462e:	6213      	str	r3, [r2, #32]
}
    4630:	bf00      	nop
    4632:	b004      	add	sp, #16
    4634:	4770      	bx	lr
    4636:	bf00      	nop
    4638:	0000aaa8 	.word	0x0000aaa8
    463c:	40064000 	.word	0x40064000

00004640 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4640:	b086      	sub	sp, #24
    4642:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4644:	4b20      	ldr	r3, [pc, #128]	; (46c8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    4646:	795b      	ldrb	r3, [r3, #5]
    4648:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    464a:	9b01      	ldr	r3, [sp, #4]
    464c:	681a      	ldr	r2, [r3, #0]
    464e:	491f      	ldr	r1, [pc, #124]	; (46cc <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    4650:	4613      	mov	r3, r2
    4652:	00db      	lsls	r3, r3, #3
    4654:	4413      	add	r3, r2
    4656:	440b      	add	r3, r1
    4658:	781b      	ldrb	r3, [r3, #0]
    465a:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    465c:	4b1c      	ldr	r3, [pc, #112]	; (46d0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    465e:	68db      	ldr	r3, [r3, #12]
    4660:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    4662:	9b03      	ldr	r3, [sp, #12]
    4664:	2b03      	cmp	r3, #3
    4666:	d813      	bhi.n	4690 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4668:	9b03      	ldr	r3, [sp, #12]
    466a:	005b      	lsls	r3, r3, #1
    466c:	3318      	adds	r3, #24
    466e:	2203      	movs	r2, #3
    4670:	fa02 f303 	lsl.w	r3, r2, r3
    4674:	43db      	mvns	r3, r3
    4676:	9a05      	ldr	r2, [sp, #20]
    4678:	4013      	ands	r3, r2
    467a:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    467c:	9b03      	ldr	r3, [sp, #12]
    467e:	005b      	lsls	r3, r3, #1
    4680:	3318      	adds	r3, #24
    4682:	9a04      	ldr	r2, [sp, #16]
    4684:	fa02 f303 	lsl.w	r3, r2, r3
    4688:	9a05      	ldr	r2, [sp, #20]
    468a:	4313      	orrs	r3, r2
    468c:	9305      	str	r3, [sp, #20]
    468e:	e014      	b.n	46ba <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4690:	9b03      	ldr	r3, [sp, #12]
    4692:	3b04      	subs	r3, #4
    4694:	005b      	lsls	r3, r3, #1
    4696:	3310      	adds	r3, #16
    4698:	2203      	movs	r2, #3
    469a:	fa02 f303 	lsl.w	r3, r2, r3
    469e:	43db      	mvns	r3, r3
    46a0:	9a05      	ldr	r2, [sp, #20]
    46a2:	4013      	ands	r3, r2
    46a4:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    46a6:	9b03      	ldr	r3, [sp, #12]
    46a8:	3b04      	subs	r3, #4
    46aa:	005b      	lsls	r3, r3, #1
    46ac:	3310      	adds	r3, #16
    46ae:	9a04      	ldr	r2, [sp, #16]
    46b0:	fa02 f303 	lsl.w	r3, r2, r3
    46b4:	9a05      	ldr	r2, [sp, #20]
    46b6:	4313      	orrs	r3, r2
    46b8:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    46ba:	4a05      	ldr	r2, [pc, #20]	; (46d0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    46bc:	9b05      	ldr	r3, [sp, #20]
    46be:	60d3      	str	r3, [r2, #12]
}
    46c0:	bf00      	nop
    46c2:	b006      	add	sp, #24
    46c4:	4770      	bx	lr
    46c6:	bf00      	nop
    46c8:	0000aa50 	.word	0x0000aa50
    46cc:	0000a740 	.word	0x0000a740
    46d0:	40048000 	.word	0x40048000

000046d4 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    46d4:	b086      	sub	sp, #24
    46d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    46d8:	9b01      	ldr	r3, [sp, #4]
    46da:	685b      	ldr	r3, [r3, #4]
    46dc:	4a20      	ldr	r2, [pc, #128]	; (4760 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    46de:	5cd3      	ldrb	r3, [r2, r3]
    46e0:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    46e2:	9b01      	ldr	r3, [sp, #4]
    46e4:	681a      	ldr	r2, [r3, #0]
    46e6:	491f      	ldr	r1, [pc, #124]	; (4764 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    46e8:	4613      	mov	r3, r2
    46ea:	00db      	lsls	r3, r3, #3
    46ec:	4413      	add	r3, r2
    46ee:	440b      	add	r3, r1
    46f0:	781b      	ldrb	r3, [r3, #0]
    46f2:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    46f4:	4b1c      	ldr	r3, [pc, #112]	; (4768 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    46f6:	68db      	ldr	r3, [r3, #12]
    46f8:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    46fa:	9b03      	ldr	r3, [sp, #12]
    46fc:	2b03      	cmp	r3, #3
    46fe:	d813      	bhi.n	4728 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4700:	9b03      	ldr	r3, [sp, #12]
    4702:	005b      	lsls	r3, r3, #1
    4704:	3318      	adds	r3, #24
    4706:	2203      	movs	r2, #3
    4708:	fa02 f303 	lsl.w	r3, r2, r3
    470c:	43db      	mvns	r3, r3
    470e:	9a05      	ldr	r2, [sp, #20]
    4710:	4013      	ands	r3, r2
    4712:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4714:	9b03      	ldr	r3, [sp, #12]
    4716:	005b      	lsls	r3, r3, #1
    4718:	3318      	adds	r3, #24
    471a:	9a04      	ldr	r2, [sp, #16]
    471c:	fa02 f303 	lsl.w	r3, r2, r3
    4720:	9a05      	ldr	r2, [sp, #20]
    4722:	4313      	orrs	r3, r2
    4724:	9305      	str	r3, [sp, #20]
    4726:	e014      	b.n	4752 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4728:	9b03      	ldr	r3, [sp, #12]
    472a:	3b04      	subs	r3, #4
    472c:	005b      	lsls	r3, r3, #1
    472e:	3310      	adds	r3, #16
    4730:	2203      	movs	r2, #3
    4732:	fa02 f303 	lsl.w	r3, r2, r3
    4736:	43db      	mvns	r3, r3
    4738:	9a05      	ldr	r2, [sp, #20]
    473a:	4013      	ands	r3, r2
    473c:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    473e:	9b03      	ldr	r3, [sp, #12]
    4740:	3b04      	subs	r3, #4
    4742:	005b      	lsls	r3, r3, #1
    4744:	3310      	adds	r3, #16
    4746:	9a04      	ldr	r2, [sp, #16]
    4748:	fa02 f303 	lsl.w	r3, r2, r3
    474c:	9a05      	ldr	r2, [sp, #20]
    474e:	4313      	orrs	r3, r2
    4750:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    4752:	4a05      	ldr	r2, [pc, #20]	; (4768 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    4754:	9b05      	ldr	r3, [sp, #20]
    4756:	60d3      	str	r3, [r2, #12]
}
    4758:	bf00      	nop
    475a:	b006      	add	sp, #24
    475c:	4770      	bx	lr
    475e:	bf00      	nop
    4760:	0000aa50 	.word	0x0000aa50
    4764:	0000a740 	.word	0x0000a740
    4768:	40048000 	.word	0x40048000

0000476c <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    476c:	b084      	sub	sp, #16
    476e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    4770:	4b06      	ldr	r3, [pc, #24]	; (478c <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4772:	685b      	ldr	r3, [r3, #4]
    4774:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    4776:	9b03      	ldr	r3, [sp, #12]
    4778:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    477c:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    477e:	4a03      	ldr	r2, [pc, #12]	; (478c <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4780:	9b03      	ldr	r3, [sp, #12]
    4782:	6053      	str	r3, [r2, #4]
}
    4784:	bf00      	nop
    4786:	b004      	add	sp, #16
    4788:	4770      	bx	lr
    478a:	bf00      	nop
    478c:	40048000 	.word	0x40048000

00004790 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4790:	b084      	sub	sp, #16
    4792:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4794:	9b01      	ldr	r3, [sp, #4]
    4796:	685b      	ldr	r3, [r3, #4]
    4798:	4a0a      	ldr	r2, [pc, #40]	; (47c4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    479a:	5cd3      	ldrb	r3, [r2, r3]
    479c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    479e:	4b0a      	ldr	r3, [pc, #40]	; (47c8 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    47a0:	685b      	ldr	r3, [r3, #4]
    47a2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    47a4:	9b02      	ldr	r3, [sp, #8]
    47a6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    47aa:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    47ac:	9b03      	ldr	r3, [sp, #12]
    47ae:	011b      	lsls	r3, r3, #4
    47b0:	9a02      	ldr	r2, [sp, #8]
    47b2:	4313      	orrs	r3, r2
    47b4:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    47b6:	4a04      	ldr	r2, [pc, #16]	; (47c8 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    47b8:	9b02      	ldr	r3, [sp, #8]
    47ba:	6053      	str	r3, [r2, #4]
}
    47bc:	bf00      	nop
    47be:	b004      	add	sp, #16
    47c0:	4770      	bx	lr
    47c2:	bf00      	nop
    47c4:	0000aa50 	.word	0x0000aa50
    47c8:	40048000 	.word	0x40048000

000047cc <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    47cc:	b084      	sub	sp, #16
    47ce:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    47d0:	9b01      	ldr	r3, [sp, #4]
    47d2:	681a      	ldr	r2, [r3, #0]
    47d4:	490f      	ldr	r1, [pc, #60]	; (4814 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    47d6:	4613      	mov	r3, r2
    47d8:	00db      	lsls	r3, r3, #3
    47da:	4413      	add	r3, r2
    47dc:	440b      	add	r3, r1
    47de:	3304      	adds	r3, #4
    47e0:	781b      	ldrb	r3, [r3, #0]
    47e2:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    47e4:	4a0c      	ldr	r2, [pc, #48]	; (4818 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    47e6:	9b03      	ldr	r3, [sp, #12]
    47e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    47ec:	490a      	ldr	r1, [pc, #40]	; (4818 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    47ee:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    47f2:	9b03      	ldr	r3, [sp, #12]
    47f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    47f8:	4a07      	ldr	r2, [pc, #28]	; (4818 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    47fa:	9b03      	ldr	r3, [sp, #12]
    47fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4800:	4905      	ldr	r1, [pc, #20]	; (4818 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4802:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    4806:	9b03      	ldr	r3, [sp, #12]
    4808:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    480c:	bf00      	nop
    480e:	b004      	add	sp, #16
    4810:	4770      	bx	lr
    4812:	bf00      	nop
    4814:	0000a740 	.word	0x0000a740
    4818:	40065000 	.word	0x40065000

0000481c <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    481c:	b086      	sub	sp, #24
    481e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4820:	9b01      	ldr	r3, [sp, #4]
    4822:	681a      	ldr	r2, [r3, #0]
    4824:	4912      	ldr	r1, [pc, #72]	; (4870 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    4826:	4613      	mov	r3, r2
    4828:	00db      	lsls	r3, r3, #3
    482a:	4413      	add	r3, r2
    482c:	440b      	add	r3, r1
    482e:	3304      	adds	r3, #4
    4830:	781b      	ldrb	r3, [r3, #0]
    4832:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4834:	9b01      	ldr	r3, [sp, #4]
    4836:	685b      	ldr	r3, [r3, #4]
    4838:	4a0e      	ldr	r2, [pc, #56]	; (4874 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    483a:	5cd3      	ldrb	r3, [r2, r3]
    483c:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    483e:	4a0e      	ldr	r2, [pc, #56]	; (4878 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4840:	9b05      	ldr	r3, [sp, #20]
    4842:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4846:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    4848:	9b03      	ldr	r3, [sp, #12]
    484a:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    484e:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    4850:	9b04      	ldr	r3, [sp, #16]
    4852:	061b      	lsls	r3, r3, #24
    4854:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    4858:	9a03      	ldr	r2, [sp, #12]
    485a:	4313      	orrs	r3, r2
    485c:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    485e:	4906      	ldr	r1, [pc, #24]	; (4878 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4860:	9b05      	ldr	r3, [sp, #20]
    4862:	9a03      	ldr	r2, [sp, #12]
    4864:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4868:	bf00      	nop
    486a:	b006      	add	sp, #24
    486c:	4770      	bx	lr
    486e:	bf00      	nop
    4870:	0000a740 	.word	0x0000a740
    4874:	0000aad8 	.word	0x0000aad8
    4878:	40065000 	.word	0x40065000

0000487c <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    487c:	b084      	sub	sp, #16
    487e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4880:	4b0b      	ldr	r3, [pc, #44]	; (48b0 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    4882:	7f1b      	ldrb	r3, [r3, #28]
    4884:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    4886:	4b0b      	ldr	r3, [pc, #44]	; (48b4 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4888:	685b      	ldr	r3, [r3, #4]
    488a:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    488c:	9b02      	ldr	r3, [sp, #8]
    488e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4892:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4894:	9b03      	ldr	r3, [sp, #12]
    4896:	031b      	lsls	r3, r3, #12
    4898:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    489c:	9a02      	ldr	r2, [sp, #8]
    489e:	4313      	orrs	r3, r2
    48a0:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    48a2:	4a04      	ldr	r2, [pc, #16]	; (48b4 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    48a4:	9b02      	ldr	r3, [sp, #8]
    48a6:	6053      	str	r3, [r2, #4]
}
    48a8:	bf00      	nop
    48aa:	b004      	add	sp, #16
    48ac:	4770      	bx	lr
    48ae:	bf00      	nop
    48b0:	0000aa50 	.word	0x0000aa50
    48b4:	40048000 	.word	0x40048000

000048b8 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    48b8:	b084      	sub	sp, #16
    48ba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    48bc:	9b01      	ldr	r3, [sp, #4]
    48be:	685b      	ldr	r3, [r3, #4]
    48c0:	4a0b      	ldr	r2, [pc, #44]	; (48f0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    48c2:	5cd3      	ldrb	r3, [r2, r3]
    48c4:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    48c6:	4b0b      	ldr	r3, [pc, #44]	; (48f4 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    48c8:	685b      	ldr	r3, [r3, #4]
    48ca:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    48cc:	9b02      	ldr	r3, [sp, #8]
    48ce:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    48d2:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    48d4:	9b03      	ldr	r3, [sp, #12]
    48d6:	031b      	lsls	r3, r3, #12
    48d8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    48dc:	9a02      	ldr	r2, [sp, #8]
    48de:	4313      	orrs	r3, r2
    48e0:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    48e2:	4a04      	ldr	r2, [pc, #16]	; (48f4 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    48e4:	9b02      	ldr	r3, [sp, #8]
    48e6:	6053      	str	r3, [r2, #4]
}
    48e8:	bf00      	nop
    48ea:	b004      	add	sp, #16
    48ec:	4770      	bx	lr
    48ee:	bf00      	nop
    48f0:	0000aa50 	.word	0x0000aa50
    48f4:	40048000 	.word	0x40048000

000048f8 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    48f8:	b500      	push	{lr}
    48fa:	b085      	sub	sp, #20
    48fc:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    48fe:	2300      	movs	r3, #0
    4900:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    4904:	9b01      	ldr	r3, [sp, #4]
    4906:	2b00      	cmp	r3, #0
    4908:	d037      	beq.n	497a <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    490a:	2300      	movs	r3, #0
    490c:	9303      	str	r3, [sp, #12]
    490e:	e02b      	b.n	4968 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4910:	4b29      	ldr	r3, [pc, #164]	; (49b8 <DisableSafeClock+0xc0>)
    4912:	6819      	ldr	r1, [r3, #0]
    4914:	9a03      	ldr	r2, [sp, #12]
    4916:	4613      	mov	r3, r2
    4918:	005b      	lsls	r3, r3, #1
    491a:	4413      	add	r3, r2
    491c:	009b      	lsls	r3, r3, #2
    491e:	440b      	add	r3, r1
    4920:	3314      	adds	r3, #20
    4922:	681b      	ldr	r3, [r3, #0]
    4924:	2b05      	cmp	r3, #5
    4926:	d11c      	bne.n	4962 <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    4928:	2301      	movs	r3, #1
    492a:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    492e:	4b22      	ldr	r3, [pc, #136]	; (49b8 <DisableSafeClock+0xc0>)
    4930:	6819      	ldr	r1, [r3, #0]
    4932:	9a03      	ldr	r2, [sp, #12]
    4934:	4613      	mov	r3, r2
    4936:	005b      	lsls	r3, r3, #1
    4938:	4413      	add	r3, r2
    493a:	009b      	lsls	r3, r3, #2
    493c:	440b      	add	r3, r1
    493e:	3318      	adds	r3, #24
    4940:	881b      	ldrh	r3, [r3, #0]
    4942:	2b00      	cmp	r3, #0
    4944:	d118      	bne.n	4978 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4946:	4b1d      	ldr	r3, [pc, #116]	; (49bc <DisableSafeClock+0xc4>)
    4948:	791b      	ldrb	r3, [r3, #4]
    494a:	4619      	mov	r1, r3
    494c:	4a1c      	ldr	r2, [pc, #112]	; (49c0 <DisableSafeClock+0xc8>)
    494e:	460b      	mov	r3, r1
    4950:	005b      	lsls	r3, r3, #1
    4952:	440b      	add	r3, r1
    4954:	009b      	lsls	r3, r3, #2
    4956:	4413      	add	r3, r2
    4958:	3308      	adds	r3, #8
    495a:	681b      	ldr	r3, [r3, #0]
    495c:	2005      	movs	r0, #5
    495e:	4798      	blx	r3
                }
                break;
    4960:	e00a      	b.n	4978 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4962:	9b03      	ldr	r3, [sp, #12]
    4964:	3301      	adds	r3, #1
    4966:	9303      	str	r3, [sp, #12]
    4968:	4b13      	ldr	r3, [pc, #76]	; (49b8 <DisableSafeClock+0xc0>)
    496a:	681b      	ldr	r3, [r3, #0]
    496c:	7a1b      	ldrb	r3, [r3, #8]
    496e:	461a      	mov	r2, r3
    4970:	9b03      	ldr	r3, [sp, #12]
    4972:	4293      	cmp	r3, r2
    4974:	d3cc      	bcc.n	4910 <DisableSafeClock+0x18>
    4976:	e000      	b.n	497a <DisableSafeClock+0x82>
                break;
    4978:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    497a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    497e:	f083 0301 	eor.w	r3, r3, #1
    4982:	b2db      	uxtb	r3, r3
    4984:	2b00      	cmp	r3, #0
    4986:	d013      	beq.n	49b0 <DisableSafeClock+0xb8>
    4988:	4b0e      	ldr	r3, [pc, #56]	; (49c4 <DisableSafeClock+0xcc>)
    498a:	781b      	ldrb	r3, [r3, #0]
    498c:	f083 0301 	eor.w	r3, r3, #1
    4990:	b2db      	uxtb	r3, r3
    4992:	2b00      	cmp	r3, #0
    4994:	d00c      	beq.n	49b0 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4996:	4b09      	ldr	r3, [pc, #36]	; (49bc <DisableSafeClock+0xc4>)
    4998:	791b      	ldrb	r3, [r3, #4]
    499a:	4619      	mov	r1, r3
    499c:	4a08      	ldr	r2, [pc, #32]	; (49c0 <DisableSafeClock+0xc8>)
    499e:	460b      	mov	r3, r1
    49a0:	005b      	lsls	r3, r3, #1
    49a2:	440b      	add	r3, r1
    49a4:	009b      	lsls	r3, r3, #2
    49a6:	4413      	add	r3, r2
    49a8:	3308      	adds	r3, #8
    49aa:	681b      	ldr	r3, [r3, #0]
    49ac:	2005      	movs	r0, #5
    49ae:	4798      	blx	r3
    }
}
    49b0:	bf00      	nop
    49b2:	b005      	add	sp, #20
    49b4:	f85d fb04 	ldr.w	pc, [sp], #4
    49b8:	1fff8ba8 	.word	0x1fff8ba8
    49bc:	0000a6d0 	.word	0x0000a6d0
    49c0:	0000ad00 	.word	0x0000ad00
    49c4:	1fff8b18 	.word	0x1fff8b18

000049c8 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    49c8:	4b06      	ldr	r3, [pc, #24]	; (49e4 <SetFircToResetValue_TrustedCall+0x1c>)
    49ca:	2200      	movs	r2, #0
    49cc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    49d0:	4b04      	ldr	r3, [pc, #16]	; (49e4 <SetFircToResetValue_TrustedCall+0x1c>)
    49d2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    49d6:	4a03      	ldr	r2, [pc, #12]	; (49e4 <SetFircToResetValue_TrustedCall+0x1c>)
    49d8:	f043 0301 	orr.w	r3, r3, #1
    49dc:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    49e0:	bf00      	nop
    49e2:	4770      	bx	lr
    49e4:	40064000 	.word	0x40064000

000049e8 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    49e8:	b084      	sub	sp, #16
    49ea:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    49ec:	2303      	movs	r3, #3
    49ee:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    49f0:	2300      	movs	r3, #0
    49f2:	9302      	str	r3, [sp, #8]
    49f4:	e028      	b.n	4a48 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    49f6:	9b01      	ldr	r3, [sp, #4]
    49f8:	9a02      	ldr	r2, [sp, #8]
    49fa:	320d      	adds	r2, #13
    49fc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4a00:	2b28      	cmp	r3, #40	; 0x28
    4a02:	d10b      	bne.n	4a1c <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4a04:	9a01      	ldr	r2, [sp, #4]
    4a06:	9b02      	ldr	r3, [sp, #8]
    4a08:	330d      	adds	r3, #13
    4a0a:	00db      	lsls	r3, r3, #3
    4a0c:	4413      	add	r3, r2
    4a0e:	685b      	ldr	r3, [r3, #4]
    4a10:	4a2b      	ldr	r2, [pc, #172]	; (4ac0 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    4a12:	5cd3      	ldrb	r3, [r2, r3]
    4a14:	011b      	lsls	r3, r3, #4
    4a16:	9a03      	ldr	r2, [sp, #12]
    4a18:	4313      	orrs	r3, r2
    4a1a:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    4a1c:	9b01      	ldr	r3, [sp, #4]
    4a1e:	9a02      	ldr	r2, [sp, #8]
    4a20:	320d      	adds	r2, #13
    4a22:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4a26:	2b29      	cmp	r3, #41	; 0x29
    4a28:	d10b      	bne.n	4a42 <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4a2a:	9a01      	ldr	r2, [sp, #4]
    4a2c:	9b02      	ldr	r3, [sp, #8]
    4a2e:	330d      	adds	r3, #13
    4a30:	00db      	lsls	r3, r3, #3
    4a32:	4413      	add	r3, r2
    4a34:	685b      	ldr	r3, [r3, #4]
    4a36:	4a23      	ldr	r2, [pc, #140]	; (4ac4 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    4a38:	5cd3      	ldrb	r3, [r2, r3]
    4a3a:	009b      	lsls	r3, r3, #2
    4a3c:	9a03      	ldr	r2, [sp, #12]
    4a3e:	4313      	orrs	r3, r2
    4a40:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4a42:	9b02      	ldr	r3, [sp, #8]
    4a44:	3301      	adds	r3, #1
    4a46:	9302      	str	r3, [sp, #8]
    4a48:	9b01      	ldr	r3, [sp, #4]
    4a4a:	7adb      	ldrb	r3, [r3, #11]
    4a4c:	461a      	mov	r2, r3
    4a4e:	9b02      	ldr	r3, [sp, #8]
    4a50:	4293      	cmp	r3, r2
    4a52:	d3d0      	bcc.n	49f6 <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4a54:	2300      	movs	r3, #0
    4a56:	9302      	str	r3, [sp, #8]
    4a58:	e026      	b.n	4aa8 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    4a5a:	9a01      	ldr	r2, [sp, #4]
    4a5c:	9b02      	ldr	r3, [sp, #8]
    4a5e:	334e      	adds	r3, #78	; 0x4e
    4a60:	00db      	lsls	r3, r3, #3
    4a62:	4413      	add	r3, r2
    4a64:	685b      	ldr	r3, [r3, #4]
    4a66:	2b12      	cmp	r3, #18
    4a68:	d109      	bne.n	4a7e <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    4a6a:	9a01      	ldr	r2, [sp, #4]
    4a6c:	9b02      	ldr	r3, [sp, #8]
    4a6e:	334e      	adds	r3, #78	; 0x4e
    4a70:	00db      	lsls	r3, r3, #3
    4a72:	4413      	add	r3, r2
    4a74:	891b      	ldrh	r3, [r3, #8]
    4a76:	005b      	lsls	r3, r3, #1
    4a78:	9a03      	ldr	r2, [sp, #12]
    4a7a:	4313      	orrs	r3, r2
    4a7c:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    4a7e:	9a01      	ldr	r2, [sp, #4]
    4a80:	9b02      	ldr	r3, [sp, #8]
    4a82:	334e      	adds	r3, #78	; 0x4e
    4a84:	00db      	lsls	r3, r3, #3
    4a86:	4413      	add	r3, r2
    4a88:	685b      	ldr	r3, [r3, #4]
    4a8a:	2b13      	cmp	r3, #19
    4a8c:	d109      	bne.n	4aa2 <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    4a8e:	9a01      	ldr	r2, [sp, #4]
    4a90:	9b02      	ldr	r3, [sp, #8]
    4a92:	334e      	adds	r3, #78	; 0x4e
    4a94:	00db      	lsls	r3, r3, #3
    4a96:	4413      	add	r3, r2
    4a98:	891b      	ldrh	r3, [r3, #8]
    4a9a:	461a      	mov	r2, r3
    4a9c:	9b03      	ldr	r3, [sp, #12]
    4a9e:	4313      	orrs	r3, r2
    4aa0:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4aa2:	9b02      	ldr	r3, [sp, #8]
    4aa4:	3301      	adds	r3, #1
    4aa6:	9302      	str	r3, [sp, #8]
    4aa8:	9b01      	ldr	r3, [sp, #4]
    4aaa:	7c1b      	ldrb	r3, [r3, #16]
    4aac:	461a      	mov	r2, r3
    4aae:	9b02      	ldr	r3, [sp, #8]
    4ab0:	4293      	cmp	r3, r2
    4ab2:	d3d2      	bcc.n	4a5a <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    4ab4:	4a04      	ldr	r2, [pc, #16]	; (4ac8 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    4ab6:	9b03      	ldr	r3, [sp, #12]
    4ab8:	6113      	str	r3, [r2, #16]
}
    4aba:	bf00      	nop
    4abc:	b004      	add	sp, #16
    4abe:	4770      	bx	lr
    4ac0:	0000aa50 	.word	0x0000aa50
    4ac4:	0000ab08 	.word	0x0000ab08
    4ac8:	40048000 	.word	0x40048000

00004acc <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    4acc:	b500      	push	{lr}
    4ace:	b089      	sub	sp, #36	; 0x24
    4ad0:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    4ad2:	2300      	movs	r3, #0
    4ad4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    4ad8:	4a21      	ldr	r2, [pc, #132]	; (4b60 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    4ada:	9b01      	ldr	r3, [sp, #4]
    4adc:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    4ade:	4b21      	ldr	r3, [pc, #132]	; (4b64 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4ae0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4ae4:	f003 0301 	and.w	r3, r3, #1
    4ae8:	2b00      	cmp	r3, #0
    4aea:	d12e      	bne.n	4b4a <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    4aec:	4b1e      	ldr	r3, [pc, #120]	; (4b68 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4aee:	2200      	movs	r2, #0
    4af0:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    4af2:	f7ff ff69 	bl	49c8 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4af6:	aa03      	add	r2, sp, #12
    4af8:	a904      	add	r1, sp, #16
    4afa:	a805      	add	r0, sp, #20
    4afc:	f24c 3350 	movw	r3, #50000	; 0xc350
    4b00:	f7fe f8ae 	bl	2c60 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4b04:	4b17      	ldr	r3, [pc, #92]	; (4b64 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4b06:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4b0a:	0e1b      	lsrs	r3, r3, #24
    4b0c:	f003 0301 	and.w	r3, r3, #1
    4b10:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4b12:	9a03      	ldr	r2, [sp, #12]
    4b14:	a904      	add	r1, sp, #16
    4b16:	ab05      	add	r3, sp, #20
    4b18:	4618      	mov	r0, r3
    4b1a:	f7fe f8bb 	bl	2c94 <Clock_Ip_TimeoutExpired>
    4b1e:	4603      	mov	r3, r0
    4b20:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    4b24:	9b06      	ldr	r3, [sp, #24]
    4b26:	2b00      	cmp	r3, #0
    4b28:	d106      	bne.n	4b38 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    4b2a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4b2e:	f083 0301 	eor.w	r3, r3, #1
    4b32:	b2db      	uxtb	r3, r3
    4b34:	2b00      	cmp	r3, #0
    4b36:	d1e5      	bne.n	4b04 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    4b38:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4b3c:	2b00      	cmp	r3, #0
    4b3e:	d007      	beq.n	4b50 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    4b40:	2105      	movs	r1, #5
    4b42:	2001      	movs	r0, #1
    4b44:	f7fe f87c 	bl	2c40 <Clock_Ip_ReportClockErrors>
    4b48:	e002      	b.n	4b50 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    4b4a:	4b07      	ldr	r3, [pc, #28]	; (4b68 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4b4c:	2201      	movs	r2, #1
    4b4e:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    4b50:	9801      	ldr	r0, [sp, #4]
    4b52:	f7ff ff49 	bl	49e8 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    4b56:	bf00      	nop
    4b58:	b009      	add	sp, #36	; 0x24
    4b5a:	f85d fb04 	ldr.w	pc, [sp], #4
    4b5e:	bf00      	nop
    4b60:	1fff8ba8 	.word	0x1fff8ba8
    4b64:	40064000 	.word	0x40064000
    4b68:	1fff8b18 	.word	0x1fff8b18

00004b6c <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    4b6c:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    4b6e:	2300      	movs	r3, #0
    4b70:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4b72:	4b29      	ldr	r3, [pc, #164]	; (4c18 <getFircConfig+0xac>)
    4b74:	681b      	ldr	r3, [r3, #0]
    4b76:	2b00      	cmp	r3, #0
    4b78:	d024      	beq.n	4bc4 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4b7a:	2300      	movs	r3, #0
    4b7c:	9301      	str	r3, [sp, #4]
    4b7e:	e01a      	b.n	4bb6 <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4b80:	4b25      	ldr	r3, [pc, #148]	; (4c18 <getFircConfig+0xac>)
    4b82:	6819      	ldr	r1, [r3, #0]
    4b84:	9a01      	ldr	r2, [sp, #4]
    4b86:	4613      	mov	r3, r2
    4b88:	005b      	lsls	r3, r3, #1
    4b8a:	4413      	add	r3, r2
    4b8c:	009b      	lsls	r3, r3, #2
    4b8e:	440b      	add	r3, r1
    4b90:	3314      	adds	r3, #20
    4b92:	681b      	ldr	r3, [r3, #0]
    4b94:	2b05      	cmp	r3, #5
    4b96:	d10b      	bne.n	4bb0 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    4b98:	4b1f      	ldr	r3, [pc, #124]	; (4c18 <getFircConfig+0xac>)
    4b9a:	6819      	ldr	r1, [r3, #0]
    4b9c:	9a01      	ldr	r2, [sp, #4]
    4b9e:	4613      	mov	r3, r2
    4ba0:	005b      	lsls	r3, r3, #1
    4ba2:	4413      	add	r3, r2
    4ba4:	009b      	lsls	r3, r3, #2
    4ba6:	3310      	adds	r3, #16
    4ba8:	440b      	add	r3, r1
    4baa:	3304      	adds	r3, #4
    4bac:	9300      	str	r3, [sp, #0]
                break;
    4bae:	e009      	b.n	4bc4 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4bb0:	9b01      	ldr	r3, [sp, #4]
    4bb2:	3301      	adds	r3, #1
    4bb4:	9301      	str	r3, [sp, #4]
    4bb6:	4b18      	ldr	r3, [pc, #96]	; (4c18 <getFircConfig+0xac>)
    4bb8:	681b      	ldr	r3, [r3, #0]
    4bba:	7a1b      	ldrb	r3, [r3, #8]
    4bbc:	461a      	mov	r2, r3
    4bbe:	9b01      	ldr	r3, [sp, #4]
    4bc0:	4293      	cmp	r3, r2
    4bc2:	d3dd      	bcc.n	4b80 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4bc4:	9b00      	ldr	r3, [sp, #0]
    4bc6:	2b00      	cmp	r3, #0
    4bc8:	d121      	bne.n	4c0e <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    4bca:	4b14      	ldr	r3, [pc, #80]	; (4c1c <getFircConfig+0xb0>)
    4bcc:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    4bce:	4b13      	ldr	r3, [pc, #76]	; (4c1c <getFircConfig+0xb0>)
    4bd0:	2205      	movs	r2, #5
    4bd2:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    4bd4:	4b12      	ldr	r3, [pc, #72]	; (4c20 <getFircConfig+0xb4>)
    4bd6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4bda:	b29b      	uxth	r3, r3
    4bdc:	f003 0301 	and.w	r3, r3, #1
    4be0:	b29a      	uxth	r2, r3
    4be2:	4b0e      	ldr	r3, [pc, #56]	; (4c1c <getFircConfig+0xb0>)
    4be4:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    4be6:	4b0e      	ldr	r3, [pc, #56]	; (4c20 <getFircConfig+0xb4>)
    4be8:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    4bec:	b2db      	uxtb	r3, r3
    4bee:	f003 0303 	and.w	r3, r3, #3
    4bf2:	b2da      	uxtb	r2, r3
    4bf4:	4b09      	ldr	r3, [pc, #36]	; (4c1c <getFircConfig+0xb0>)
    4bf6:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    4bf8:	4b09      	ldr	r3, [pc, #36]	; (4c20 <getFircConfig+0xb4>)
    4bfa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4bfe:	b2db      	uxtb	r3, r3
    4c00:	10db      	asrs	r3, r3, #3
    4c02:	b2db      	uxtb	r3, r3
    4c04:	f003 0301 	and.w	r3, r3, #1
    4c08:	b2da      	uxtb	r2, r3
    4c0a:	4b04      	ldr	r3, [pc, #16]	; (4c1c <getFircConfig+0xb0>)
    4c0c:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    4c0e:	9b00      	ldr	r3, [sp, #0]
}
    4c10:	4618      	mov	r0, r3
    4c12:	b002      	add	sp, #8
    4c14:	4770      	bx	lr
    4c16:	bf00      	nop
    4c18:	1fff8ba8 	.word	0x1fff8ba8
    4c1c:	1fff8c14 	.word	0x1fff8c14
    4c20:	40064000 	.word	0x40064000

00004c24 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    4c24:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    4c26:	2300      	movs	r3, #0
    4c28:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4c2a:	4b20      	ldr	r3, [pc, #128]	; (4cac <getSoscConfig+0x88>)
    4c2c:	681b      	ldr	r3, [r3, #0]
    4c2e:	2b00      	cmp	r3, #0
    4c30:	d024      	beq.n	4c7c <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4c32:	2300      	movs	r3, #0
    4c34:	9301      	str	r3, [sp, #4]
    4c36:	e01a      	b.n	4c6e <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    4c38:	4b1c      	ldr	r3, [pc, #112]	; (4cac <getSoscConfig+0x88>)
    4c3a:	6819      	ldr	r1, [r3, #0]
    4c3c:	9a01      	ldr	r2, [sp, #4]
    4c3e:	4613      	mov	r3, r2
    4c40:	009b      	lsls	r3, r3, #2
    4c42:	4413      	add	r3, r2
    4c44:	009b      	lsls	r3, r3, #2
    4c46:	440b      	add	r3, r1
    4c48:	332c      	adds	r3, #44	; 0x2c
    4c4a:	681b      	ldr	r3, [r3, #0]
    4c4c:	2b08      	cmp	r3, #8
    4c4e:	d10b      	bne.n	4c68 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    4c50:	4b16      	ldr	r3, [pc, #88]	; (4cac <getSoscConfig+0x88>)
    4c52:	6819      	ldr	r1, [r3, #0]
    4c54:	9a01      	ldr	r2, [sp, #4]
    4c56:	4613      	mov	r3, r2
    4c58:	009b      	lsls	r3, r3, #2
    4c5a:	4413      	add	r3, r2
    4c5c:	009b      	lsls	r3, r3, #2
    4c5e:	3328      	adds	r3, #40	; 0x28
    4c60:	440b      	add	r3, r1
    4c62:	3304      	adds	r3, #4
    4c64:	9300      	str	r3, [sp, #0]
                break;
    4c66:	e009      	b.n	4c7c <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4c68:	9b01      	ldr	r3, [sp, #4]
    4c6a:	3301      	adds	r3, #1
    4c6c:	9301      	str	r3, [sp, #4]
    4c6e:	4b0f      	ldr	r3, [pc, #60]	; (4cac <getSoscConfig+0x88>)
    4c70:	681b      	ldr	r3, [r3, #0]
    4c72:	7a5b      	ldrb	r3, [r3, #9]
    4c74:	461a      	mov	r2, r3
    4c76:	9b01      	ldr	r3, [sp, #4]
    4c78:	4293      	cmp	r3, r2
    4c7a:	d3dd      	bcc.n	4c38 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4c7c:	9b00      	ldr	r3, [sp, #0]
    4c7e:	2b00      	cmp	r3, #0
    4c80:	d110      	bne.n	4ca4 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    4c82:	4b0b      	ldr	r3, [pc, #44]	; (4cb0 <getSoscConfig+0x8c>)
    4c84:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    4c86:	4b0a      	ldr	r3, [pc, #40]	; (4cb0 <getSoscConfig+0x8c>)
    4c88:	2208      	movs	r2, #8
    4c8a:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    4c8c:	4b09      	ldr	r3, [pc, #36]	; (4cb4 <getSoscConfig+0x90>)
    4c8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    4c92:	b29b      	uxth	r3, r3
    4c94:	f003 0301 	and.w	r3, r3, #1
    4c98:	b29a      	uxth	r2, r3
    4c9a:	4b05      	ldr	r3, [pc, #20]	; (4cb0 <getSoscConfig+0x8c>)
    4c9c:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    4c9e:	4b04      	ldr	r3, [pc, #16]	; (4cb0 <getSoscConfig+0x8c>)
    4ca0:	4a05      	ldr	r2, [pc, #20]	; (4cb8 <getSoscConfig+0x94>)
    4ca2:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    4ca4:	9b00      	ldr	r3, [sp, #0]
}
    4ca6:	4618      	mov	r0, r3
    4ca8:	b002      	add	sp, #8
    4caa:	4770      	bx	lr
    4cac:	1fff8ba8 	.word	0x1fff8ba8
    4cb0:	1fff8c20 	.word	0x1fff8c20
    4cb4:	40064000 	.word	0x40064000
    4cb8:	02625a00 	.word	0x02625a00

00004cbc <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    4cbc:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    4cbe:	2300      	movs	r3, #0
    4cc0:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4cc2:	4b28      	ldr	r3, [pc, #160]	; (4d64 <getSpllConfig+0xa8>)
    4cc4:	681b      	ldr	r3, [r3, #0]
    4cc6:	2b00      	cmp	r3, #0
    4cc8:	d023      	beq.n	4d12 <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4cca:	2300      	movs	r3, #0
    4ccc:	9301      	str	r3, [sp, #4]
    4cce:	e019      	b.n	4d04 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    4cd0:	4b24      	ldr	r3, [pc, #144]	; (4d64 <getSpllConfig+0xa8>)
    4cd2:	6819      	ldr	r1, [r3, #0]
    4cd4:	9a01      	ldr	r2, [sp, #4]
    4cd6:	4613      	mov	r3, r2
    4cd8:	009b      	lsls	r3, r3, #2
    4cda:	4413      	add	r3, r2
    4cdc:	00db      	lsls	r3, r3, #3
    4cde:	440b      	add	r3, r1
    4ce0:	3340      	adds	r3, #64	; 0x40
    4ce2:	681b      	ldr	r3, [r3, #0]
    4ce4:	2b09      	cmp	r3, #9
    4ce6:	d10a      	bne.n	4cfe <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    4ce8:	4b1e      	ldr	r3, [pc, #120]	; (4d64 <getSpllConfig+0xa8>)
    4cea:	6819      	ldr	r1, [r3, #0]
    4cec:	9a01      	ldr	r2, [sp, #4]
    4cee:	4613      	mov	r3, r2
    4cf0:	009b      	lsls	r3, r3, #2
    4cf2:	4413      	add	r3, r2
    4cf4:	00db      	lsls	r3, r3, #3
    4cf6:	3340      	adds	r3, #64	; 0x40
    4cf8:	440b      	add	r3, r1
    4cfa:	9300      	str	r3, [sp, #0]
                break;
    4cfc:	e009      	b.n	4d12 <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4cfe:	9b01      	ldr	r3, [sp, #4]
    4d00:	3301      	adds	r3, #1
    4d02:	9301      	str	r3, [sp, #4]
    4d04:	4b17      	ldr	r3, [pc, #92]	; (4d64 <getSpllConfig+0xa8>)
    4d06:	681b      	ldr	r3, [r3, #0]
    4d08:	7a9b      	ldrb	r3, [r3, #10]
    4d0a:	461a      	mov	r2, r3
    4d0c:	9b01      	ldr	r3, [sp, #4]
    4d0e:	4293      	cmp	r3, r2
    4d10:	d3de      	bcc.n	4cd0 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4d12:	9b00      	ldr	r3, [sp, #0]
    4d14:	2b00      	cmp	r3, #0
    4d16:	d121      	bne.n	4d5c <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    4d18:	4b13      	ldr	r3, [pc, #76]	; (4d68 <getSpllConfig+0xac>)
    4d1a:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    4d1c:	4b12      	ldr	r3, [pc, #72]	; (4d68 <getSpllConfig+0xac>)
    4d1e:	2209      	movs	r2, #9
    4d20:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    4d22:	4b12      	ldr	r3, [pc, #72]	; (4d6c <getSpllConfig+0xb0>)
    4d24:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4d28:	b29b      	uxth	r3, r3
    4d2a:	f003 0301 	and.w	r3, r3, #1
    4d2e:	b29a      	uxth	r2, r3
    4d30:	4b0d      	ldr	r3, [pc, #52]	; (4d68 <getSpllConfig+0xac>)
    4d32:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    4d34:	4b0d      	ldr	r3, [pc, #52]	; (4d6c <getSpllConfig+0xb0>)
    4d36:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4d3a:	0a1b      	lsrs	r3, r3, #8
    4d3c:	b2db      	uxtb	r3, r3
    4d3e:	f003 0307 	and.w	r3, r3, #7
    4d42:	b2da      	uxtb	r2, r3
    4d44:	4b08      	ldr	r3, [pc, #32]	; (4d68 <getSpllConfig+0xac>)
    4d46:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    4d48:	4b08      	ldr	r3, [pc, #32]	; (4d6c <getSpllConfig+0xb0>)
    4d4a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4d4e:	0c1b      	lsrs	r3, r3, #16
    4d50:	b2db      	uxtb	r3, r3
    4d52:	f003 031f 	and.w	r3, r3, #31
    4d56:	b2da      	uxtb	r2, r3
    4d58:	4b03      	ldr	r3, [pc, #12]	; (4d68 <getSpllConfig+0xac>)
    4d5a:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    4d5c:	9b00      	ldr	r3, [sp, #0]
}
    4d5e:	4618      	mov	r0, r3
    4d60:	b002      	add	sp, #8
    4d62:	4770      	bx	lr
    4d64:	1fff8ba8 	.word	0x1fff8ba8
    4d68:	1fff8c34 	.word	0x1fff8c34
    4d6c:	40064000 	.word	0x40064000

00004d70 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    4d70:	b086      	sub	sp, #24
    4d72:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    4d74:	2300      	movs	r3, #0
    4d76:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    4d78:	9b01      	ldr	r3, [sp, #4]
    4d7a:	2b1b      	cmp	r3, #27
    4d7c:	d00f      	beq.n	4d9e <getSelectorConfig+0x2e>
    4d7e:	9b01      	ldr	r3, [sp, #4]
    4d80:	2b1b      	cmp	r3, #27
    4d82:	d80f      	bhi.n	4da4 <getSelectorConfig+0x34>
    4d84:	9b01      	ldr	r3, [sp, #4]
    4d86:	2b19      	cmp	r3, #25
    4d88:	d003      	beq.n	4d92 <getSelectorConfig+0x22>
    4d8a:	9b01      	ldr	r3, [sp, #4]
    4d8c:	2b1a      	cmp	r3, #26
    4d8e:	d003      	beq.n	4d98 <getSelectorConfig+0x28>
    4d90:	e008      	b.n	4da4 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    4d92:	2300      	movs	r3, #0
    4d94:	9304      	str	r3, [sp, #16]
            break;
    4d96:	e008      	b.n	4daa <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    4d98:	2301      	movs	r3, #1
    4d9a:	9304      	str	r3, [sp, #16]
            break;
    4d9c:	e005      	b.n	4daa <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    4d9e:	2302      	movs	r3, #2
    4da0:	9304      	str	r3, [sp, #16]
            break;
    4da2:	e002      	b.n	4daa <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    4da4:	2300      	movs	r3, #0
    4da6:	9304      	str	r3, [sp, #16]
            break;
    4da8:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4daa:	4b36      	ldr	r3, [pc, #216]	; (4e84 <getSelectorConfig+0x114>)
    4dac:	681b      	ldr	r3, [r3, #0]
    4dae:	2b00      	cmp	r3, #0
    4db0:	d01d      	beq.n	4dee <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    4db2:	2300      	movs	r3, #0
    4db4:	9303      	str	r3, [sp, #12]
    4db6:	e013      	b.n	4de0 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    4db8:	4b32      	ldr	r3, [pc, #200]	; (4e84 <getSelectorConfig+0x114>)
    4dba:	681b      	ldr	r3, [r3, #0]
    4dbc:	9a03      	ldr	r2, [sp, #12]
    4dbe:	320d      	adds	r2, #13
    4dc0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4dc4:	9a01      	ldr	r2, [sp, #4]
    4dc6:	429a      	cmp	r2, r3
    4dc8:	d107      	bne.n	4dda <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    4dca:	4b2e      	ldr	r3, [pc, #184]	; (4e84 <getSelectorConfig+0x114>)
    4dcc:	681a      	ldr	r2, [r3, #0]
    4dce:	9b03      	ldr	r3, [sp, #12]
    4dd0:	330d      	adds	r3, #13
    4dd2:	00db      	lsls	r3, r3, #3
    4dd4:	4413      	add	r3, r2
    4dd6:	9305      	str	r3, [sp, #20]
                break;
    4dd8:	e009      	b.n	4dee <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    4dda:	9b03      	ldr	r3, [sp, #12]
    4ddc:	3301      	adds	r3, #1
    4dde:	9303      	str	r3, [sp, #12]
    4de0:	4b28      	ldr	r3, [pc, #160]	; (4e84 <getSelectorConfig+0x114>)
    4de2:	681b      	ldr	r3, [r3, #0]
    4de4:	7adb      	ldrb	r3, [r3, #11]
    4de6:	461a      	mov	r2, r3
    4de8:	9b03      	ldr	r3, [sp, #12]
    4dea:	4293      	cmp	r3, r2
    4dec:	d3e4      	bcc.n	4db8 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4dee:	9b05      	ldr	r3, [sp, #20]
    4df0:	2b00      	cmp	r3, #0
    4df2:	d140      	bne.n	4e76 <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    4df4:	9b04      	ldr	r3, [sp, #16]
    4df6:	00db      	lsls	r3, r3, #3
    4df8:	4a23      	ldr	r2, [pc, #140]	; (4e88 <getSelectorConfig+0x118>)
    4dfa:	4413      	add	r3, r2
    4dfc:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    4dfe:	4922      	ldr	r1, [pc, #136]	; (4e88 <getSelectorConfig+0x118>)
    4e00:	9b04      	ldr	r3, [sp, #16]
    4e02:	9a01      	ldr	r2, [sp, #4]
    4e04:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    4e08:	9b01      	ldr	r3, [sp, #4]
    4e0a:	2b1b      	cmp	r3, #27
    4e0c:	d025      	beq.n	4e5a <getSelectorConfig+0xea>
    4e0e:	9b01      	ldr	r3, [sp, #4]
    4e10:	2b1b      	cmp	r3, #27
    4e12:	d832      	bhi.n	4e7a <getSelectorConfig+0x10a>
    4e14:	9b01      	ldr	r3, [sp, #4]
    4e16:	2b19      	cmp	r3, #25
    4e18:	d003      	beq.n	4e22 <getSelectorConfig+0xb2>
    4e1a:	9b01      	ldr	r3, [sp, #4]
    4e1c:	2b1a      	cmp	r3, #26
    4e1e:	d00e      	beq.n	4e3e <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4e20:	e02b      	b.n	4e7a <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    4e22:	4b1a      	ldr	r3, [pc, #104]	; (4e8c <getSelectorConfig+0x11c>)
    4e24:	695b      	ldr	r3, [r3, #20]
    4e26:	0e1b      	lsrs	r3, r3, #24
    4e28:	f003 030f 	and.w	r3, r3, #15
    4e2c:	4a18      	ldr	r2, [pc, #96]	; (4e90 <getSelectorConfig+0x120>)
    4e2e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4e32:	4915      	ldr	r1, [pc, #84]	; (4e88 <getSelectorConfig+0x118>)
    4e34:	9b04      	ldr	r3, [sp, #16]
    4e36:	00db      	lsls	r3, r3, #3
    4e38:	440b      	add	r3, r1
    4e3a:	605a      	str	r2, [r3, #4]
                break;
    4e3c:	e01e      	b.n	4e7c <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    4e3e:	4b13      	ldr	r3, [pc, #76]	; (4e8c <getSelectorConfig+0x11c>)
    4e40:	699b      	ldr	r3, [r3, #24]
    4e42:	0e1b      	lsrs	r3, r3, #24
    4e44:	f003 030f 	and.w	r3, r3, #15
    4e48:	4a11      	ldr	r2, [pc, #68]	; (4e90 <getSelectorConfig+0x120>)
    4e4a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4e4e:	490e      	ldr	r1, [pc, #56]	; (4e88 <getSelectorConfig+0x118>)
    4e50:	9b04      	ldr	r3, [sp, #16]
    4e52:	00db      	lsls	r3, r3, #3
    4e54:	440b      	add	r3, r1
    4e56:	605a      	str	r2, [r3, #4]
                break;
    4e58:	e010      	b.n	4e7c <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    4e5a:	4b0c      	ldr	r3, [pc, #48]	; (4e8c <getSelectorConfig+0x11c>)
    4e5c:	69db      	ldr	r3, [r3, #28]
    4e5e:	0e1b      	lsrs	r3, r3, #24
    4e60:	f003 030f 	and.w	r3, r3, #15
    4e64:	4a0a      	ldr	r2, [pc, #40]	; (4e90 <getSelectorConfig+0x120>)
    4e66:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4e6a:	4907      	ldr	r1, [pc, #28]	; (4e88 <getSelectorConfig+0x118>)
    4e6c:	9b04      	ldr	r3, [sp, #16]
    4e6e:	00db      	lsls	r3, r3, #3
    4e70:	440b      	add	r3, r1
    4e72:	605a      	str	r2, [r3, #4]
                break;
    4e74:	e002      	b.n	4e7c <getSelectorConfig+0x10c>
        }
    }
    4e76:	bf00      	nop
    4e78:	e000      	b.n	4e7c <getSelectorConfig+0x10c>
                break;
    4e7a:	bf00      	nop

    return ReturnValue;
    4e7c:	9b05      	ldr	r3, [sp, #20]
}
    4e7e:	4618      	mov	r0, r3
    4e80:	b006      	add	sp, #24
    4e82:	4770      	bx	lr
    4e84:	1fff8ba8 	.word	0x1fff8ba8
    4e88:	1fff8c5c 	.word	0x1fff8c5c
    4e8c:	40064000 	.word	0x40064000
    4e90:	0000add0 	.word	0x0000add0

00004e94 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    4e94:	b086      	sub	sp, #24
    4e96:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4e98:	2300      	movs	r3, #0
    4e9a:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4e9c:	2300      	movs	r3, #0
    4e9e:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4ea0:	9b01      	ldr	r3, [sp, #4]
    4ea2:	2b1f      	cmp	r3, #31
    4ea4:	d00f      	beq.n	4ec6 <getCoreDividerConfig+0x32>
    4ea6:	9b01      	ldr	r3, [sp, #4]
    4ea8:	2b1f      	cmp	r3, #31
    4eaa:	d80f      	bhi.n	4ecc <getCoreDividerConfig+0x38>
    4eac:	9b01      	ldr	r3, [sp, #4]
    4eae:	2b1d      	cmp	r3, #29
    4eb0:	d003      	beq.n	4eba <getCoreDividerConfig+0x26>
    4eb2:	9b01      	ldr	r3, [sp, #4]
    4eb4:	2b1e      	cmp	r3, #30
    4eb6:	d003      	beq.n	4ec0 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4eb8:	e008      	b.n	4ecc <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    4eba:	2300      	movs	r3, #0
    4ebc:	9304      	str	r3, [sp, #16]
            break;
    4ebe:	e006      	b.n	4ece <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4ec0:	2301      	movs	r3, #1
    4ec2:	9304      	str	r3, [sp, #16]
            break;
    4ec4:	e003      	b.n	4ece <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    4ec6:	2302      	movs	r3, #2
    4ec8:	9304      	str	r3, [sp, #16]
            break;
    4eca:	e000      	b.n	4ece <getCoreDividerConfig+0x3a>
                break;
    4ecc:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4ece:	4b41      	ldr	r3, [pc, #260]	; (4fd4 <getCoreDividerConfig+0x140>)
    4ed0:	681b      	ldr	r3, [r3, #0]
    4ed2:	2b00      	cmp	r3, #0
    4ed4:	d026      	beq.n	4f24 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4ed6:	2300      	movs	r3, #0
    4ed8:	9303      	str	r3, [sp, #12]
    4eda:	e01c      	b.n	4f16 <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4edc:	4b3d      	ldr	r3, [pc, #244]	; (4fd4 <getCoreDividerConfig+0x140>)
    4ede:	6819      	ldr	r1, [r3, #0]
    4ee0:	9a03      	ldr	r2, [sp, #12]
    4ee2:	4613      	mov	r3, r2
    4ee4:	005b      	lsls	r3, r3, #1
    4ee6:	4413      	add	r3, r2
    4ee8:	009b      	lsls	r3, r3, #2
    4eea:	440b      	add	r3, r1
    4eec:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4ef0:	681b      	ldr	r3, [r3, #0]
    4ef2:	9a01      	ldr	r2, [sp, #4]
    4ef4:	429a      	cmp	r2, r3
    4ef6:	d10b      	bne.n	4f10 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    4ef8:	4b36      	ldr	r3, [pc, #216]	; (4fd4 <getCoreDividerConfig+0x140>)
    4efa:	6819      	ldr	r1, [r3, #0]
    4efc:	9a03      	ldr	r2, [sp, #12]
    4efe:	4613      	mov	r3, r2
    4f00:	005b      	lsls	r3, r3, #1
    4f02:	4413      	add	r3, r2
    4f04:	009b      	lsls	r3, r3, #2
    4f06:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4f0a:	440b      	add	r3, r1
    4f0c:	9305      	str	r3, [sp, #20]
                break;
    4f0e:	e009      	b.n	4f24 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4f10:	9b03      	ldr	r3, [sp, #12]
    4f12:	3301      	adds	r3, #1
    4f14:	9303      	str	r3, [sp, #12]
    4f16:	4b2f      	ldr	r3, [pc, #188]	; (4fd4 <getCoreDividerConfig+0x140>)
    4f18:	681b      	ldr	r3, [r3, #0]
    4f1a:	7b1b      	ldrb	r3, [r3, #12]
    4f1c:	461a      	mov	r2, r3
    4f1e:	9b03      	ldr	r3, [sp, #12]
    4f20:	4293      	cmp	r3, r2
    4f22:	d3db      	bcc.n	4edc <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4f24:	9b05      	ldr	r3, [sp, #20]
    4f26:	2b00      	cmp	r3, #0
    4f28:	d14d      	bne.n	4fc6 <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    4f2a:	9a04      	ldr	r2, [sp, #16]
    4f2c:	4613      	mov	r3, r2
    4f2e:	005b      	lsls	r3, r3, #1
    4f30:	4413      	add	r3, r2
    4f32:	009b      	lsls	r3, r3, #2
    4f34:	4a28      	ldr	r2, [pc, #160]	; (4fd8 <getCoreDividerConfig+0x144>)
    4f36:	4413      	add	r3, r2
    4f38:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    4f3a:	4927      	ldr	r1, [pc, #156]	; (4fd8 <getCoreDividerConfig+0x144>)
    4f3c:	9a04      	ldr	r2, [sp, #16]
    4f3e:	4613      	mov	r3, r2
    4f40:	005b      	lsls	r3, r3, #1
    4f42:	4413      	add	r3, r2
    4f44:	009b      	lsls	r3, r3, #2
    4f46:	440b      	add	r3, r1
    4f48:	9a01      	ldr	r2, [sp, #4]
    4f4a:	601a      	str	r2, [r3, #0]
        switch(Name)
    4f4c:	9b01      	ldr	r3, [sp, #4]
    4f4e:	2b1f      	cmp	r3, #31
    4f50:	d029      	beq.n	4fa6 <getCoreDividerConfig+0x112>
    4f52:	9b01      	ldr	r3, [sp, #4]
    4f54:	2b1f      	cmp	r3, #31
    4f56:	d838      	bhi.n	4fca <getCoreDividerConfig+0x136>
    4f58:	9b01      	ldr	r3, [sp, #4]
    4f5a:	2b1d      	cmp	r3, #29
    4f5c:	d003      	beq.n	4f66 <getCoreDividerConfig+0xd2>
    4f5e:	9b01      	ldr	r3, [sp, #4]
    4f60:	2b1e      	cmp	r3, #30
    4f62:	d010      	beq.n	4f86 <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4f64:	e031      	b.n	4fca <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    4f66:	4b1d      	ldr	r3, [pc, #116]	; (4fdc <getCoreDividerConfig+0x148>)
    4f68:	695b      	ldr	r3, [r3, #20]
    4f6a:	0c1b      	lsrs	r3, r3, #16
    4f6c:	f003 030f 	and.w	r3, r3, #15
    4f70:	1c59      	adds	r1, r3, #1
    4f72:	4819      	ldr	r0, [pc, #100]	; (4fd8 <getCoreDividerConfig+0x144>)
    4f74:	9a04      	ldr	r2, [sp, #16]
    4f76:	4613      	mov	r3, r2
    4f78:	005b      	lsls	r3, r3, #1
    4f7a:	4413      	add	r3, r2
    4f7c:	009b      	lsls	r3, r3, #2
    4f7e:	4403      	add	r3, r0
    4f80:	3304      	adds	r3, #4
    4f82:	6019      	str	r1, [r3, #0]
                break;
    4f84:	e022      	b.n	4fcc <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    4f86:	4b15      	ldr	r3, [pc, #84]	; (4fdc <getCoreDividerConfig+0x148>)
    4f88:	699b      	ldr	r3, [r3, #24]
    4f8a:	0c1b      	lsrs	r3, r3, #16
    4f8c:	f003 030f 	and.w	r3, r3, #15
    4f90:	1c59      	adds	r1, r3, #1
    4f92:	4811      	ldr	r0, [pc, #68]	; (4fd8 <getCoreDividerConfig+0x144>)
    4f94:	9a04      	ldr	r2, [sp, #16]
    4f96:	4613      	mov	r3, r2
    4f98:	005b      	lsls	r3, r3, #1
    4f9a:	4413      	add	r3, r2
    4f9c:	009b      	lsls	r3, r3, #2
    4f9e:	4403      	add	r3, r0
    4fa0:	3304      	adds	r3, #4
    4fa2:	6019      	str	r1, [r3, #0]
                break;
    4fa4:	e012      	b.n	4fcc <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    4fa6:	4b0d      	ldr	r3, [pc, #52]	; (4fdc <getCoreDividerConfig+0x148>)
    4fa8:	69db      	ldr	r3, [r3, #28]
    4faa:	0c1b      	lsrs	r3, r3, #16
    4fac:	f003 030f 	and.w	r3, r3, #15
    4fb0:	1c59      	adds	r1, r3, #1
    4fb2:	4809      	ldr	r0, [pc, #36]	; (4fd8 <getCoreDividerConfig+0x144>)
    4fb4:	9a04      	ldr	r2, [sp, #16]
    4fb6:	4613      	mov	r3, r2
    4fb8:	005b      	lsls	r3, r3, #1
    4fba:	4413      	add	r3, r2
    4fbc:	009b      	lsls	r3, r3, #2
    4fbe:	4403      	add	r3, r0
    4fc0:	3304      	adds	r3, #4
    4fc2:	6019      	str	r1, [r3, #0]
                break;
    4fc4:	e002      	b.n	4fcc <getCoreDividerConfig+0x138>
        }
    }
    4fc6:	bf00      	nop
    4fc8:	e000      	b.n	4fcc <getCoreDividerConfig+0x138>
                break;
    4fca:	bf00      	nop

    return ReturnValue;
    4fcc:	9b05      	ldr	r3, [sp, #20]
}
    4fce:	4618      	mov	r0, r3
    4fd0:	b006      	add	sp, #24
    4fd2:	4770      	bx	lr
    4fd4:	1fff8ba8 	.word	0x1fff8ba8
    4fd8:	1fff8c74 	.word	0x1fff8c74
    4fdc:	40064000 	.word	0x40064000

00004fe0 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    4fe0:	b086      	sub	sp, #24
    4fe2:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4fe4:	2300      	movs	r3, #0
    4fe6:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4fe8:	2300      	movs	r3, #0
    4fea:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4fec:	9b01      	ldr	r3, [sp, #4]
    4fee:	2b23      	cmp	r3, #35	; 0x23
    4ff0:	d00f      	beq.n	5012 <getBusDividerConfig+0x32>
    4ff2:	9b01      	ldr	r3, [sp, #4]
    4ff4:	2b23      	cmp	r3, #35	; 0x23
    4ff6:	d80f      	bhi.n	5018 <getBusDividerConfig+0x38>
    4ff8:	9b01      	ldr	r3, [sp, #4]
    4ffa:	2b21      	cmp	r3, #33	; 0x21
    4ffc:	d003      	beq.n	5006 <getBusDividerConfig+0x26>
    4ffe:	9b01      	ldr	r3, [sp, #4]
    5000:	2b22      	cmp	r3, #34	; 0x22
    5002:	d003      	beq.n	500c <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    5004:	e008      	b.n	5018 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    5006:	2300      	movs	r3, #0
    5008:	9304      	str	r3, [sp, #16]
            break;
    500a:	e006      	b.n	501a <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    500c:	2301      	movs	r3, #1
    500e:	9304      	str	r3, [sp, #16]
            break;
    5010:	e003      	b.n	501a <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    5012:	2302      	movs	r3, #2
    5014:	9304      	str	r3, [sp, #16]
            break;
    5016:	e000      	b.n	501a <getBusDividerConfig+0x3a>
                break;
    5018:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    501a:	4b41      	ldr	r3, [pc, #260]	; (5120 <getBusDividerConfig+0x140>)
    501c:	681b      	ldr	r3, [r3, #0]
    501e:	2b00      	cmp	r3, #0
    5020:	d026      	beq.n	5070 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5022:	2300      	movs	r3, #0
    5024:	9303      	str	r3, [sp, #12]
    5026:	e01c      	b.n	5062 <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5028:	4b3d      	ldr	r3, [pc, #244]	; (5120 <getBusDividerConfig+0x140>)
    502a:	6819      	ldr	r1, [r3, #0]
    502c:	9a03      	ldr	r2, [sp, #12]
    502e:	4613      	mov	r3, r2
    5030:	005b      	lsls	r3, r3, #1
    5032:	4413      	add	r3, r2
    5034:	009b      	lsls	r3, r3, #2
    5036:	440b      	add	r3, r1
    5038:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    503c:	681b      	ldr	r3, [r3, #0]
    503e:	9a01      	ldr	r2, [sp, #4]
    5040:	429a      	cmp	r2, r3
    5042:	d10b      	bne.n	505c <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5044:	4b36      	ldr	r3, [pc, #216]	; (5120 <getBusDividerConfig+0x140>)
    5046:	6819      	ldr	r1, [r3, #0]
    5048:	9a03      	ldr	r2, [sp, #12]
    504a:	4613      	mov	r3, r2
    504c:	005b      	lsls	r3, r3, #1
    504e:	4413      	add	r3, r2
    5050:	009b      	lsls	r3, r3, #2
    5052:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5056:	440b      	add	r3, r1
    5058:	9305      	str	r3, [sp, #20]
                break;
    505a:	e009      	b.n	5070 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    505c:	9b03      	ldr	r3, [sp, #12]
    505e:	3301      	adds	r3, #1
    5060:	9303      	str	r3, [sp, #12]
    5062:	4b2f      	ldr	r3, [pc, #188]	; (5120 <getBusDividerConfig+0x140>)
    5064:	681b      	ldr	r3, [r3, #0]
    5066:	7b1b      	ldrb	r3, [r3, #12]
    5068:	461a      	mov	r2, r3
    506a:	9b03      	ldr	r3, [sp, #12]
    506c:	4293      	cmp	r3, r2
    506e:	d3db      	bcc.n	5028 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5070:	9b05      	ldr	r3, [sp, #20]
    5072:	2b00      	cmp	r3, #0
    5074:	d14d      	bne.n	5112 <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    5076:	9a04      	ldr	r2, [sp, #16]
    5078:	4613      	mov	r3, r2
    507a:	005b      	lsls	r3, r3, #1
    507c:	4413      	add	r3, r2
    507e:	009b      	lsls	r3, r3, #2
    5080:	4a28      	ldr	r2, [pc, #160]	; (5124 <getBusDividerConfig+0x144>)
    5082:	4413      	add	r3, r2
    5084:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    5086:	4927      	ldr	r1, [pc, #156]	; (5124 <getBusDividerConfig+0x144>)
    5088:	9a04      	ldr	r2, [sp, #16]
    508a:	4613      	mov	r3, r2
    508c:	005b      	lsls	r3, r3, #1
    508e:	4413      	add	r3, r2
    5090:	009b      	lsls	r3, r3, #2
    5092:	440b      	add	r3, r1
    5094:	9a01      	ldr	r2, [sp, #4]
    5096:	601a      	str	r2, [r3, #0]
        switch(Name)
    5098:	9b01      	ldr	r3, [sp, #4]
    509a:	2b23      	cmp	r3, #35	; 0x23
    509c:	d029      	beq.n	50f2 <getBusDividerConfig+0x112>
    509e:	9b01      	ldr	r3, [sp, #4]
    50a0:	2b23      	cmp	r3, #35	; 0x23
    50a2:	d838      	bhi.n	5116 <getBusDividerConfig+0x136>
    50a4:	9b01      	ldr	r3, [sp, #4]
    50a6:	2b21      	cmp	r3, #33	; 0x21
    50a8:	d003      	beq.n	50b2 <getBusDividerConfig+0xd2>
    50aa:	9b01      	ldr	r3, [sp, #4]
    50ac:	2b22      	cmp	r3, #34	; 0x22
    50ae:	d010      	beq.n	50d2 <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    50b0:	e031      	b.n	5116 <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    50b2:	4b1d      	ldr	r3, [pc, #116]	; (5128 <getBusDividerConfig+0x148>)
    50b4:	695b      	ldr	r3, [r3, #20]
    50b6:	091b      	lsrs	r3, r3, #4
    50b8:	f003 030f 	and.w	r3, r3, #15
    50bc:	1c59      	adds	r1, r3, #1
    50be:	4819      	ldr	r0, [pc, #100]	; (5124 <getBusDividerConfig+0x144>)
    50c0:	9a04      	ldr	r2, [sp, #16]
    50c2:	4613      	mov	r3, r2
    50c4:	005b      	lsls	r3, r3, #1
    50c6:	4413      	add	r3, r2
    50c8:	009b      	lsls	r3, r3, #2
    50ca:	4403      	add	r3, r0
    50cc:	3304      	adds	r3, #4
    50ce:	6019      	str	r1, [r3, #0]
                break;
    50d0:	e022      	b.n	5118 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    50d2:	4b15      	ldr	r3, [pc, #84]	; (5128 <getBusDividerConfig+0x148>)
    50d4:	699b      	ldr	r3, [r3, #24]
    50d6:	091b      	lsrs	r3, r3, #4
    50d8:	f003 030f 	and.w	r3, r3, #15
    50dc:	1c59      	adds	r1, r3, #1
    50de:	4811      	ldr	r0, [pc, #68]	; (5124 <getBusDividerConfig+0x144>)
    50e0:	9a04      	ldr	r2, [sp, #16]
    50e2:	4613      	mov	r3, r2
    50e4:	005b      	lsls	r3, r3, #1
    50e6:	4413      	add	r3, r2
    50e8:	009b      	lsls	r3, r3, #2
    50ea:	4403      	add	r3, r0
    50ec:	3304      	adds	r3, #4
    50ee:	6019      	str	r1, [r3, #0]
                break;
    50f0:	e012      	b.n	5118 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    50f2:	4b0d      	ldr	r3, [pc, #52]	; (5128 <getBusDividerConfig+0x148>)
    50f4:	69db      	ldr	r3, [r3, #28]
    50f6:	091b      	lsrs	r3, r3, #4
    50f8:	f003 030f 	and.w	r3, r3, #15
    50fc:	1c59      	adds	r1, r3, #1
    50fe:	4809      	ldr	r0, [pc, #36]	; (5124 <getBusDividerConfig+0x144>)
    5100:	9a04      	ldr	r2, [sp, #16]
    5102:	4613      	mov	r3, r2
    5104:	005b      	lsls	r3, r3, #1
    5106:	4413      	add	r3, r2
    5108:	009b      	lsls	r3, r3, #2
    510a:	4403      	add	r3, r0
    510c:	3304      	adds	r3, #4
    510e:	6019      	str	r1, [r3, #0]
                break;
    5110:	e002      	b.n	5118 <getBusDividerConfig+0x138>
        }
    }
    5112:	bf00      	nop
    5114:	e000      	b.n	5118 <getBusDividerConfig+0x138>
                break;
    5116:	bf00      	nop

    return ReturnValue;
    5118:	9b05      	ldr	r3, [sp, #20]
}
    511a:	4618      	mov	r0, r3
    511c:	b006      	add	sp, #24
    511e:	4770      	bx	lr
    5120:	1fff8ba8 	.word	0x1fff8ba8
    5124:	1fff8c98 	.word	0x1fff8c98
    5128:	40064000 	.word	0x40064000

0000512c <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    512c:	b086      	sub	sp, #24
    512e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    5130:	2300      	movs	r3, #0
    5132:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5134:	2300      	movs	r3, #0
    5136:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5138:	9b01      	ldr	r3, [sp, #4]
    513a:	2b27      	cmp	r3, #39	; 0x27
    513c:	d00f      	beq.n	515e <getSlowDividerConfig+0x32>
    513e:	9b01      	ldr	r3, [sp, #4]
    5140:	2b27      	cmp	r3, #39	; 0x27
    5142:	d80f      	bhi.n	5164 <getSlowDividerConfig+0x38>
    5144:	9b01      	ldr	r3, [sp, #4]
    5146:	2b25      	cmp	r3, #37	; 0x25
    5148:	d003      	beq.n	5152 <getSlowDividerConfig+0x26>
    514a:	9b01      	ldr	r3, [sp, #4]
    514c:	2b26      	cmp	r3, #38	; 0x26
    514e:	d003      	beq.n	5158 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    5150:	e008      	b.n	5164 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    5152:	2300      	movs	r3, #0
    5154:	9304      	str	r3, [sp, #16]
            break;
    5156:	e006      	b.n	5166 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5158:	2301      	movs	r3, #1
    515a:	9304      	str	r3, [sp, #16]
            break;
    515c:	e003      	b.n	5166 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    515e:	2302      	movs	r3, #2
    5160:	9304      	str	r3, [sp, #16]
            break;
    5162:	e000      	b.n	5166 <getSlowDividerConfig+0x3a>
                break;
    5164:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5166:	4b40      	ldr	r3, [pc, #256]	; (5268 <getSlowDividerConfig+0x13c>)
    5168:	681b      	ldr	r3, [r3, #0]
    516a:	2b00      	cmp	r3, #0
    516c:	d026      	beq.n	51bc <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    516e:	2300      	movs	r3, #0
    5170:	9303      	str	r3, [sp, #12]
    5172:	e01c      	b.n	51ae <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5174:	4b3c      	ldr	r3, [pc, #240]	; (5268 <getSlowDividerConfig+0x13c>)
    5176:	6819      	ldr	r1, [r3, #0]
    5178:	9a03      	ldr	r2, [sp, #12]
    517a:	4613      	mov	r3, r2
    517c:	005b      	lsls	r3, r3, #1
    517e:	4413      	add	r3, r2
    5180:	009b      	lsls	r3, r3, #2
    5182:	440b      	add	r3, r1
    5184:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5188:	681b      	ldr	r3, [r3, #0]
    518a:	9a01      	ldr	r2, [sp, #4]
    518c:	429a      	cmp	r2, r3
    518e:	d10b      	bne.n	51a8 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5190:	4b35      	ldr	r3, [pc, #212]	; (5268 <getSlowDividerConfig+0x13c>)
    5192:	6819      	ldr	r1, [r3, #0]
    5194:	9a03      	ldr	r2, [sp, #12]
    5196:	4613      	mov	r3, r2
    5198:	005b      	lsls	r3, r3, #1
    519a:	4413      	add	r3, r2
    519c:	009b      	lsls	r3, r3, #2
    519e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    51a2:	440b      	add	r3, r1
    51a4:	9305      	str	r3, [sp, #20]
                break;
    51a6:	e009      	b.n	51bc <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    51a8:	9b03      	ldr	r3, [sp, #12]
    51aa:	3301      	adds	r3, #1
    51ac:	9303      	str	r3, [sp, #12]
    51ae:	4b2e      	ldr	r3, [pc, #184]	; (5268 <getSlowDividerConfig+0x13c>)
    51b0:	681b      	ldr	r3, [r3, #0]
    51b2:	7b1b      	ldrb	r3, [r3, #12]
    51b4:	461a      	mov	r2, r3
    51b6:	9b03      	ldr	r3, [sp, #12]
    51b8:	4293      	cmp	r3, r2
    51ba:	d3db      	bcc.n	5174 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    51bc:	9b05      	ldr	r3, [sp, #20]
    51be:	2b00      	cmp	r3, #0
    51c0:	d14a      	bne.n	5258 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    51c2:	9a04      	ldr	r2, [sp, #16]
    51c4:	4613      	mov	r3, r2
    51c6:	005b      	lsls	r3, r3, #1
    51c8:	4413      	add	r3, r2
    51ca:	009b      	lsls	r3, r3, #2
    51cc:	4a27      	ldr	r2, [pc, #156]	; (526c <getSlowDividerConfig+0x140>)
    51ce:	4413      	add	r3, r2
    51d0:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    51d2:	4926      	ldr	r1, [pc, #152]	; (526c <getSlowDividerConfig+0x140>)
    51d4:	9a04      	ldr	r2, [sp, #16]
    51d6:	4613      	mov	r3, r2
    51d8:	005b      	lsls	r3, r3, #1
    51da:	4413      	add	r3, r2
    51dc:	009b      	lsls	r3, r3, #2
    51de:	440b      	add	r3, r1
    51e0:	9a01      	ldr	r2, [sp, #4]
    51e2:	601a      	str	r2, [r3, #0]
        switch(Name)
    51e4:	9b01      	ldr	r3, [sp, #4]
    51e6:	2b27      	cmp	r3, #39	; 0x27
    51e8:	d027      	beq.n	523a <getSlowDividerConfig+0x10e>
    51ea:	9b01      	ldr	r3, [sp, #4]
    51ec:	2b27      	cmp	r3, #39	; 0x27
    51ee:	d835      	bhi.n	525c <getSlowDividerConfig+0x130>
    51f0:	9b01      	ldr	r3, [sp, #4]
    51f2:	2b25      	cmp	r3, #37	; 0x25
    51f4:	d003      	beq.n	51fe <getSlowDividerConfig+0xd2>
    51f6:	9b01      	ldr	r3, [sp, #4]
    51f8:	2b26      	cmp	r3, #38	; 0x26
    51fa:	d00f      	beq.n	521c <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    51fc:	e02e      	b.n	525c <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    51fe:	4b1c      	ldr	r3, [pc, #112]	; (5270 <getSlowDividerConfig+0x144>)
    5200:	695b      	ldr	r3, [r3, #20]
    5202:	f003 030f 	and.w	r3, r3, #15
    5206:	1c59      	adds	r1, r3, #1
    5208:	4818      	ldr	r0, [pc, #96]	; (526c <getSlowDividerConfig+0x140>)
    520a:	9a04      	ldr	r2, [sp, #16]
    520c:	4613      	mov	r3, r2
    520e:	005b      	lsls	r3, r3, #1
    5210:	4413      	add	r3, r2
    5212:	009b      	lsls	r3, r3, #2
    5214:	4403      	add	r3, r0
    5216:	3304      	adds	r3, #4
    5218:	6019      	str	r1, [r3, #0]
                break;
    521a:	e020      	b.n	525e <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    521c:	4b14      	ldr	r3, [pc, #80]	; (5270 <getSlowDividerConfig+0x144>)
    521e:	699b      	ldr	r3, [r3, #24]
    5220:	f003 030f 	and.w	r3, r3, #15
    5224:	1c59      	adds	r1, r3, #1
    5226:	4811      	ldr	r0, [pc, #68]	; (526c <getSlowDividerConfig+0x140>)
    5228:	9a04      	ldr	r2, [sp, #16]
    522a:	4613      	mov	r3, r2
    522c:	005b      	lsls	r3, r3, #1
    522e:	4413      	add	r3, r2
    5230:	009b      	lsls	r3, r3, #2
    5232:	4403      	add	r3, r0
    5234:	3304      	adds	r3, #4
    5236:	6019      	str	r1, [r3, #0]
                break;
    5238:	e011      	b.n	525e <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    523a:	4b0d      	ldr	r3, [pc, #52]	; (5270 <getSlowDividerConfig+0x144>)
    523c:	69db      	ldr	r3, [r3, #28]
    523e:	f003 030f 	and.w	r3, r3, #15
    5242:	1c59      	adds	r1, r3, #1
    5244:	4809      	ldr	r0, [pc, #36]	; (526c <getSlowDividerConfig+0x140>)
    5246:	9a04      	ldr	r2, [sp, #16]
    5248:	4613      	mov	r3, r2
    524a:	005b      	lsls	r3, r3, #1
    524c:	4413      	add	r3, r2
    524e:	009b      	lsls	r3, r3, #2
    5250:	4403      	add	r3, r0
    5252:	3304      	adds	r3, #4
    5254:	6019      	str	r1, [r3, #0]
                break;
    5256:	e002      	b.n	525e <getSlowDividerConfig+0x132>
        }
    }
    5258:	bf00      	nop
    525a:	e000      	b.n	525e <getSlowDividerConfig+0x132>
                break;
    525c:	bf00      	nop

    return ReturnValue;
    525e:	9b05      	ldr	r3, [sp, #20]
}
    5260:	4618      	mov	r0, r3
    5262:	b006      	add	sp, #24
    5264:	4770      	bx	lr
    5266:	bf00      	nop
    5268:	1fff8ba8 	.word	0x1fff8ba8
    526c:	1fff8cbc 	.word	0x1fff8cbc
    5270:	40064000 	.word	0x40064000

00005274 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    5274:	b500      	push	{lr}
    5276:	b083      	sub	sp, #12
    5278:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    527a:	4b64      	ldr	r3, [pc, #400]	; (540c <Clock_Ip_ClockInitializeObjects+0x198>)
    527c:	781b      	ldrb	r3, [r3, #0]
    527e:	f083 0301 	eor.w	r3, r3, #1
    5282:	b2db      	uxtb	r3, r3
    5284:	2b00      	cmp	r3, #0
    5286:	d05b      	beq.n	5340 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    5288:	4b60      	ldr	r3, [pc, #384]	; (540c <Clock_Ip_ClockInitializeObjects+0x198>)
    528a:	2201      	movs	r2, #1
    528c:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    528e:	4b60      	ldr	r3, [pc, #384]	; (5410 <Clock_Ip_ClockInitializeObjects+0x19c>)
    5290:	785b      	ldrb	r3, [r3, #1]
    5292:	461a      	mov	r2, r3
    5294:	4613      	mov	r3, r2
    5296:	009b      	lsls	r3, r3, #2
    5298:	4413      	add	r3, r2
    529a:	009b      	lsls	r3, r3, #2
    529c:	4a5d      	ldr	r2, [pc, #372]	; (5414 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    529e:	4413      	add	r3, r2
    52a0:	4a5d      	ldr	r2, [pc, #372]	; (5418 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    52a2:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    52a4:	4b5d      	ldr	r3, [pc, #372]	; (541c <Clock_Ip_ClockInitializeObjects+0x1a8>)
    52a6:	785b      	ldrb	r3, [r3, #1]
    52a8:	461a      	mov	r2, r3
    52aa:	4613      	mov	r3, r2
    52ac:	009b      	lsls	r3, r3, #2
    52ae:	4413      	add	r3, r2
    52b0:	009b      	lsls	r3, r3, #2
    52b2:	4a5b      	ldr	r2, [pc, #364]	; (5420 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    52b4:	4413      	add	r3, r2
    52b6:	4a5b      	ldr	r2, [pc, #364]	; (5424 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    52b8:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    52ba:	4b5b      	ldr	r3, [pc, #364]	; (5428 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    52bc:	791b      	ldrb	r3, [r3, #4]
    52be:	461a      	mov	r2, r3
    52c0:	4613      	mov	r3, r2
    52c2:	005b      	lsls	r3, r3, #1
    52c4:	4413      	add	r3, r2
    52c6:	009b      	lsls	r3, r3, #2
    52c8:	4a58      	ldr	r2, [pc, #352]	; (542c <Clock_Ip_ClockInitializeObjects+0x1b8>)
    52ca:	4413      	add	r3, r2
    52cc:	4a58      	ldr	r2, [pc, #352]	; (5430 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    52ce:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    52d0:	4b58      	ldr	r3, [pc, #352]	; (5434 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    52d2:	795b      	ldrb	r3, [r3, #5]
    52d4:	00db      	lsls	r3, r3, #3
    52d6:	4a58      	ldr	r2, [pc, #352]	; (5438 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    52d8:	4413      	add	r3, r2
    52da:	4a58      	ldr	r2, [pc, #352]	; (543c <Clock_Ip_ClockInitializeObjects+0x1c8>)
    52dc:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    52de:	4b55      	ldr	r3, [pc, #340]	; (5434 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    52e0:	79db      	ldrb	r3, [r3, #7]
    52e2:	00db      	lsls	r3, r3, #3
    52e4:	4a54      	ldr	r2, [pc, #336]	; (5438 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    52e6:	4413      	add	r3, r2
    52e8:	4a55      	ldr	r2, [pc, #340]	; (5440 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    52ea:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    52ec:	4b55      	ldr	r3, [pc, #340]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    52ee:	799b      	ldrb	r3, [r3, #6]
    52f0:	009b      	lsls	r3, r3, #2
    52f2:	4a55      	ldr	r2, [pc, #340]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    52f4:	4413      	add	r3, r2
    52f6:	4a55      	ldr	r2, [pc, #340]	; (544c <Clock_Ip_ClockInitializeObjects+0x1d8>)
    52f8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    52fa:	4b52      	ldr	r3, [pc, #328]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    52fc:	7a1b      	ldrb	r3, [r3, #8]
    52fe:	009b      	lsls	r3, r3, #2
    5300:	4a51      	ldr	r2, [pc, #324]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5302:	4413      	add	r3, r2
    5304:	4a52      	ldr	r2, [pc, #328]	; (5450 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    5306:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    5308:	4b4e      	ldr	r3, [pc, #312]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    530a:	7a5b      	ldrb	r3, [r3, #9]
    530c:	009b      	lsls	r3, r3, #2
    530e:	4a4e      	ldr	r2, [pc, #312]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5310:	4413      	add	r3, r2
    5312:	4a50      	ldr	r2, [pc, #320]	; (5454 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    5314:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    5316:	4b4b      	ldr	r3, [pc, #300]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5318:	7adb      	ldrb	r3, [r3, #11]
    531a:	009b      	lsls	r3, r3, #2
    531c:	4a4a      	ldr	r2, [pc, #296]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    531e:	4413      	add	r3, r2
    5320:	4a4d      	ldr	r2, [pc, #308]	; (5458 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    5322:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    5324:	4b47      	ldr	r3, [pc, #284]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5326:	7b1b      	ldrb	r3, [r3, #12]
    5328:	009b      	lsls	r3, r3, #2
    532a:	4a47      	ldr	r2, [pc, #284]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    532c:	4413      	add	r3, r2
    532e:	4a4b      	ldr	r2, [pc, #300]	; (545c <Clock_Ip_ClockInitializeObjects+0x1e8>)
    5330:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    5332:	4b44      	ldr	r3, [pc, #272]	; (5444 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5334:	7b9b      	ldrb	r3, [r3, #14]
    5336:	009b      	lsls	r3, r3, #2
    5338:	4a43      	ldr	r2, [pc, #268]	; (5448 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    533a:	4413      	add	r3, r2
    533c:	4a48      	ldr	r2, [pc, #288]	; (5460 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    533e:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    5340:	4b48      	ldr	r3, [pc, #288]	; (5464 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    5342:	781b      	ldrb	r3, [r3, #0]
    5344:	2b00      	cmp	r3, #0
    5346:	d002      	beq.n	534e <Clock_Ip_ClockInitializeObjects+0xda>
    5348:	9b01      	ldr	r3, [sp, #4]
    534a:	2b00      	cmp	r3, #0
    534c:	d003      	beq.n	5356 <Clock_Ip_ClockInitializeObjects+0xe2>
    534e:	4b46      	ldr	r3, [pc, #280]	; (5468 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    5350:	781b      	ldrb	r3, [r3, #0]
    5352:	2b00      	cmp	r3, #0
    5354:	d056      	beq.n	5404 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    5356:	f7ff fc09 	bl	4b6c <getFircConfig>
    535a:	4603      	mov	r3, r0
    535c:	4a43      	ldr	r2, [pc, #268]	; (546c <Clock_Ip_ClockInitializeObjects+0x1f8>)
    535e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    5360:	f7ff fc60 	bl	4c24 <getSoscConfig>
    5364:	4603      	mov	r3, r0
    5366:	4a42      	ldr	r2, [pc, #264]	; (5470 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    5368:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    536a:	f7ff fca7 	bl	4cbc <getSpllConfig>
    536e:	4603      	mov	r3, r0
    5370:	4a40      	ldr	r2, [pc, #256]	; (5474 <Clock_Ip_ClockInitializeObjects+0x200>)
    5372:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    5374:	2019      	movs	r0, #25
    5376:	f7ff fcfb 	bl	4d70 <getSelectorConfig>
    537a:	4603      	mov	r3, r0
    537c:	4a3e      	ldr	r2, [pc, #248]	; (5478 <Clock_Ip_ClockInitializeObjects+0x204>)
    537e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    5380:	201a      	movs	r0, #26
    5382:	f7ff fcf5 	bl	4d70 <getSelectorConfig>
    5386:	4603      	mov	r3, r0
    5388:	4a3c      	ldr	r2, [pc, #240]	; (547c <Clock_Ip_ClockInitializeObjects+0x208>)
    538a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    538c:	201b      	movs	r0, #27
    538e:	f7ff fcef 	bl	4d70 <getSelectorConfig>
    5392:	4603      	mov	r3, r0
    5394:	4a3a      	ldr	r2, [pc, #232]	; (5480 <Clock_Ip_ClockInitializeObjects+0x20c>)
    5396:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    5398:	201d      	movs	r0, #29
    539a:	f7ff fd7b 	bl	4e94 <getCoreDividerConfig>
    539e:	4603      	mov	r3, r0
    53a0:	4a38      	ldr	r2, [pc, #224]	; (5484 <Clock_Ip_ClockInitializeObjects+0x210>)
    53a2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    53a4:	201e      	movs	r0, #30
    53a6:	f7ff fd75 	bl	4e94 <getCoreDividerConfig>
    53aa:	4603      	mov	r3, r0
    53ac:	4a36      	ldr	r2, [pc, #216]	; (5488 <Clock_Ip_ClockInitializeObjects+0x214>)
    53ae:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    53b0:	201f      	movs	r0, #31
    53b2:	f7ff fd6f 	bl	4e94 <getCoreDividerConfig>
    53b6:	4603      	mov	r3, r0
    53b8:	4a34      	ldr	r2, [pc, #208]	; (548c <Clock_Ip_ClockInitializeObjects+0x218>)
    53ba:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    53bc:	2021      	movs	r0, #33	; 0x21
    53be:	f7ff fe0f 	bl	4fe0 <getBusDividerConfig>
    53c2:	4603      	mov	r3, r0
    53c4:	4a32      	ldr	r2, [pc, #200]	; (5490 <Clock_Ip_ClockInitializeObjects+0x21c>)
    53c6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    53c8:	2022      	movs	r0, #34	; 0x22
    53ca:	f7ff fe09 	bl	4fe0 <getBusDividerConfig>
    53ce:	4603      	mov	r3, r0
    53d0:	4a30      	ldr	r2, [pc, #192]	; (5494 <Clock_Ip_ClockInitializeObjects+0x220>)
    53d2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    53d4:	2023      	movs	r0, #35	; 0x23
    53d6:	f7ff fe03 	bl	4fe0 <getBusDividerConfig>
    53da:	4603      	mov	r3, r0
    53dc:	4a2e      	ldr	r2, [pc, #184]	; (5498 <Clock_Ip_ClockInitializeObjects+0x224>)
    53de:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    53e0:	2025      	movs	r0, #37	; 0x25
    53e2:	f7ff fea3 	bl	512c <getSlowDividerConfig>
    53e6:	4603      	mov	r3, r0
    53e8:	4a2c      	ldr	r2, [pc, #176]	; (549c <Clock_Ip_ClockInitializeObjects+0x228>)
    53ea:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    53ec:	2026      	movs	r0, #38	; 0x26
    53ee:	f7ff fe9d 	bl	512c <getSlowDividerConfig>
    53f2:	4603      	mov	r3, r0
    53f4:	4a2a      	ldr	r2, [pc, #168]	; (54a0 <Clock_Ip_ClockInitializeObjects+0x22c>)
    53f6:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    53f8:	2027      	movs	r0, #39	; 0x27
    53fa:	f7ff fe97 	bl	512c <getSlowDividerConfig>
    53fe:	4603      	mov	r3, r0
    5400:	4a28      	ldr	r2, [pc, #160]	; (54a4 <Clock_Ip_ClockInitializeObjects+0x230>)
    5402:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    5404:	bf00      	nop
    5406:	b003      	add	sp, #12
    5408:	f85d fb04 	ldr.w	pc, [sp], #4
    540c:	1fff8ce0 	.word	0x1fff8ce0
    5410:	0000a700 	.word	0x0000a700
    5414:	0000ad4c 	.word	0x0000ad4c
    5418:	1fff8bac 	.word	0x1fff8bac
    541c:	0000a6c0 	.word	0x0000a6c0
    5420:	0000ac94 	.word	0x0000ac94
    5424:	1fff8bb0 	.word	0x1fff8bb0
    5428:	0000a6d0 	.word	0x0000a6d0
    542c:	0000ad00 	.word	0x0000ad00
    5430:	1fff8bb4 	.word	0x1fff8bb4
    5434:	0000a710 	.word	0x0000a710
    5438:	0000ad78 	.word	0x0000ad78
    543c:	1fff8bb8 	.word	0x1fff8bb8
    5440:	1fff8bf4 	.word	0x1fff8bf4
    5444:	0000a6a0 	.word	0x0000a6a0
    5448:	0000ac50 	.word	0x0000ac50
    544c:	1fff8bbc 	.word	0x1fff8bbc
    5450:	1fff8bf8 	.word	0x1fff8bf8
    5454:	1fff8bc0 	.word	0x1fff8bc0
    5458:	1fff8bfc 	.word	0x1fff8bfc
    545c:	1fff8bc4 	.word	0x1fff8bc4
    5460:	1fff8c00 	.word	0x1fff8c00
    5464:	1fff8b19 	.word	0x1fff8b19
    5468:	1fff8b10 	.word	0x1fff8b10
    546c:	1fff8bc8 	.word	0x1fff8bc8
    5470:	1fff8bcc 	.word	0x1fff8bcc
    5474:	1fff8bd0 	.word	0x1fff8bd0
    5478:	1fff8bd4 	.word	0x1fff8bd4
    547c:	1fff8bd8 	.word	0x1fff8bd8
    5480:	1fff8c04 	.word	0x1fff8c04
    5484:	1fff8bdc 	.word	0x1fff8bdc
    5488:	1fff8be0 	.word	0x1fff8be0
    548c:	1fff8c08 	.word	0x1fff8c08
    5490:	1fff8be4 	.word	0x1fff8be4
    5494:	1fff8be8 	.word	0x1fff8be8
    5498:	1fff8c0c 	.word	0x1fff8c0c
    549c:	1fff8bec 	.word	0x1fff8bec
    54a0:	1fff8bf0 	.word	0x1fff8bf0
    54a4:	1fff8c10 	.word	0x1fff8c10

000054a8 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    54a8:	b500      	push	{lr}
    54aa:	b083      	sub	sp, #12
    54ac:	9001      	str	r0, [sp, #4]
    54ae:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    54b0:	9b01      	ldr	r3, [sp, #4]
    54b2:	2b03      	cmp	r3, #3
    54b4:	f000 8090 	beq.w	55d8 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    54b8:	9b01      	ldr	r3, [sp, #4]
    54ba:	2b03      	cmp	r3, #3
    54bc:	f200 80d3 	bhi.w	5666 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    54c0:	9b01      	ldr	r3, [sp, #4]
    54c2:	2b00      	cmp	r3, #0
    54c4:	d040      	beq.n	5548 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    54c6:	9b01      	ldr	r3, [sp, #4]
    54c8:	3b01      	subs	r3, #1
    54ca:	2b01      	cmp	r3, #1
    54cc:	f200 80cb 	bhi.w	5666 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    54d0:	9b00      	ldr	r3, [sp, #0]
    54d2:	2b00      	cmp	r3, #0
    54d4:	f040 80c9 	bne.w	566a <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    54d8:	4b68      	ldr	r3, [pc, #416]	; (567c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    54da:	2200      	movs	r2, #0
    54dc:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    54de:	4b68      	ldr	r3, [pc, #416]	; (5680 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    54e0:	681b      	ldr	r3, [r3, #0]
    54e2:	685b      	ldr	r3, [r3, #4]
    54e4:	4a67      	ldr	r2, [pc, #412]	; (5684 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    54e6:	6812      	ldr	r2, [r2, #0]
    54e8:	4610      	mov	r0, r2
    54ea:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    54ec:	4b66      	ldr	r3, [pc, #408]	; (5688 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    54ee:	681b      	ldr	r3, [r3, #0]
    54f0:	681b      	ldr	r3, [r3, #0]
    54f2:	4a66      	ldr	r2, [pc, #408]	; (568c <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    54f4:	6812      	ldr	r2, [r2, #0]
    54f6:	4610      	mov	r0, r2
    54f8:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    54fa:	4b65      	ldr	r3, [pc, #404]	; (5690 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    54fc:	681b      	ldr	r3, [r3, #0]
    54fe:	681b      	ldr	r3, [r3, #0]
    5500:	4a64      	ldr	r2, [pc, #400]	; (5694 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    5502:	6812      	ldr	r2, [r2, #0]
    5504:	4610      	mov	r0, r2
    5506:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    5508:	4b63      	ldr	r3, [pc, #396]	; (5698 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    550a:	681b      	ldr	r3, [r3, #0]
    550c:	681b      	ldr	r3, [r3, #0]
    550e:	4a63      	ldr	r2, [pc, #396]	; (569c <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    5510:	6812      	ldr	r2, [r2, #0]
    5512:	4610      	mov	r0, r2
    5514:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    5516:	4b62      	ldr	r3, [pc, #392]	; (56a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5518:	681b      	ldr	r3, [r3, #0]
    551a:	691b      	ldr	r3, [r3, #16]
    551c:	4a61      	ldr	r2, [pc, #388]	; (56a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    551e:	6812      	ldr	r2, [r2, #0]
    5520:	6812      	ldr	r2, [r2, #0]
    5522:	4610      	mov	r0, r2
    5524:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    5526:	4b60      	ldr	r3, [pc, #384]	; (56a8 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5528:	681b      	ldr	r3, [r3, #0]
    552a:	68db      	ldr	r3, [r3, #12]
    552c:	4a5f      	ldr	r2, [pc, #380]	; (56ac <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    552e:	6812      	ldr	r2, [r2, #0]
    5530:	6812      	ldr	r2, [r2, #0]
    5532:	4610      	mov	r0, r2
    5534:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    5536:	4b5e      	ldr	r3, [pc, #376]	; (56b0 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5538:	681b      	ldr	r3, [r3, #0]
    553a:	689b      	ldr	r3, [r3, #8]
    553c:	4a5d      	ldr	r2, [pc, #372]	; (56b4 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    553e:	6812      	ldr	r2, [r2, #0]
    5540:	6812      	ldr	r2, [r2, #0]
    5542:	4610      	mov	r0, r2
    5544:	4798      	blx	r3
            }
        }
        break;
    5546:	e090      	b.n	566a <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    5548:	9b00      	ldr	r3, [sp, #0]
    554a:	2b02      	cmp	r3, #2
    554c:	f040 808f 	bne.w	566e <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    5550:	4b4a      	ldr	r3, [pc, #296]	; (567c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5552:	2201      	movs	r2, #1
    5554:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    5556:	4b56      	ldr	r3, [pc, #344]	; (56b0 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5558:	681b      	ldr	r3, [r3, #0]
    555a:	685b      	ldr	r3, [r3, #4]
    555c:	4a55      	ldr	r2, [pc, #340]	; (56b4 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    555e:	6812      	ldr	r2, [r2, #0]
    5560:	4610      	mov	r0, r2
    5562:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    5564:	4b50      	ldr	r3, [pc, #320]	; (56a8 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5566:	681b      	ldr	r3, [r3, #0]
    5568:	691b      	ldr	r3, [r3, #16]
    556a:	4a50      	ldr	r2, [pc, #320]	; (56ac <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    556c:	6812      	ldr	r2, [r2, #0]
    556e:	4610      	mov	r0, r2
    5570:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5572:	4b4d      	ldr	r3, [pc, #308]	; (56a8 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5574:	681b      	ldr	r3, [r3, #0]
    5576:	689b      	ldr	r3, [r3, #8]
    5578:	4a4c      	ldr	r2, [pc, #304]	; (56ac <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    557a:	6812      	ldr	r2, [r2, #0]
    557c:	4610      	mov	r0, r2
    557e:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5580:	4b47      	ldr	r3, [pc, #284]	; (56a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5582:	681b      	ldr	r3, [r3, #0]
    5584:	68db      	ldr	r3, [r3, #12]
    5586:	4a47      	ldr	r2, [pc, #284]	; (56a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5588:	6812      	ldr	r2, [r2, #0]
    558a:	4610      	mov	r0, r2
    558c:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    558e:	4b44      	ldr	r3, [pc, #272]	; (56a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5590:	681b      	ldr	r3, [r3, #0]
    5592:	689b      	ldr	r3, [r3, #8]
    5594:	4a43      	ldr	r2, [pc, #268]	; (56a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5596:	6812      	ldr	r2, [r2, #0]
    5598:	6812      	ldr	r2, [r2, #0]
    559a:	4610      	mov	r0, r2
    559c:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    559e:	4b38      	ldr	r3, [pc, #224]	; (5680 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    55a0:	681b      	ldr	r3, [r3, #0]
    55a2:	685b      	ldr	r3, [r3, #4]
    55a4:	4a44      	ldr	r2, [pc, #272]	; (56b8 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    55a6:	6812      	ldr	r2, [r2, #0]
    55a8:	4610      	mov	r0, r2
    55aa:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    55ac:	4b36      	ldr	r3, [pc, #216]	; (5688 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    55ae:	681b      	ldr	r3, [r3, #0]
    55b0:	681b      	ldr	r3, [r3, #0]
    55b2:	4a42      	ldr	r2, [pc, #264]	; (56bc <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    55b4:	6812      	ldr	r2, [r2, #0]
    55b6:	4610      	mov	r0, r2
    55b8:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    55ba:	4b35      	ldr	r3, [pc, #212]	; (5690 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    55bc:	681b      	ldr	r3, [r3, #0]
    55be:	681b      	ldr	r3, [r3, #0]
    55c0:	4a3f      	ldr	r2, [pc, #252]	; (56c0 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    55c2:	6812      	ldr	r2, [r2, #0]
    55c4:	4610      	mov	r0, r2
    55c6:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    55c8:	4b33      	ldr	r3, [pc, #204]	; (5698 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    55ca:	681b      	ldr	r3, [r3, #0]
    55cc:	681b      	ldr	r3, [r3, #0]
    55ce:	4a3d      	ldr	r2, [pc, #244]	; (56c4 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    55d0:	6812      	ldr	r2, [r2, #0]
    55d2:	4610      	mov	r0, r2
    55d4:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    55d6:	e04a      	b.n	566e <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    55d8:	9b00      	ldr	r3, [sp, #0]
    55da:	2b02      	cmp	r3, #2
    55dc:	d149      	bne.n	5672 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    55de:	4b27      	ldr	r3, [pc, #156]	; (567c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    55e0:	2201      	movs	r2, #1
    55e2:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    55e4:	4b32      	ldr	r3, [pc, #200]	; (56b0 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    55e6:	681b      	ldr	r3, [r3, #0]
    55e8:	685b      	ldr	r3, [r3, #4]
    55ea:	4a32      	ldr	r2, [pc, #200]	; (56b4 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    55ec:	6812      	ldr	r2, [r2, #0]
    55ee:	4610      	mov	r0, r2
    55f0:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    55f2:	4b2d      	ldr	r3, [pc, #180]	; (56a8 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    55f4:	681b      	ldr	r3, [r3, #0]
    55f6:	691b      	ldr	r3, [r3, #16]
    55f8:	4a2c      	ldr	r2, [pc, #176]	; (56ac <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    55fa:	6812      	ldr	r2, [r2, #0]
    55fc:	4610      	mov	r0, r2
    55fe:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5600:	4b29      	ldr	r3, [pc, #164]	; (56a8 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5602:	681b      	ldr	r3, [r3, #0]
    5604:	689b      	ldr	r3, [r3, #8]
    5606:	4a29      	ldr	r2, [pc, #164]	; (56ac <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5608:	6812      	ldr	r2, [r2, #0]
    560a:	4610      	mov	r0, r2
    560c:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    560e:	4b24      	ldr	r3, [pc, #144]	; (56a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5610:	681b      	ldr	r3, [r3, #0]
    5612:	68db      	ldr	r3, [r3, #12]
    5614:	4a23      	ldr	r2, [pc, #140]	; (56a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5616:	6812      	ldr	r2, [r2, #0]
    5618:	4610      	mov	r0, r2
    561a:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    561c:	4b20      	ldr	r3, [pc, #128]	; (56a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    561e:	681b      	ldr	r3, [r3, #0]
    5620:	689b      	ldr	r3, [r3, #8]
    5622:	4a20      	ldr	r2, [pc, #128]	; (56a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5624:	6812      	ldr	r2, [r2, #0]
    5626:	6812      	ldr	r2, [r2, #0]
    5628:	4610      	mov	r0, r2
    562a:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    562c:	4b26      	ldr	r3, [pc, #152]	; (56c8 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    562e:	681b      	ldr	r3, [r3, #0]
    5630:	685b      	ldr	r3, [r3, #4]
    5632:	4a26      	ldr	r2, [pc, #152]	; (56cc <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    5634:	6812      	ldr	r2, [r2, #0]
    5636:	4610      	mov	r0, r2
    5638:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    563a:	4b25      	ldr	r3, [pc, #148]	; (56d0 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    563c:	681b      	ldr	r3, [r3, #0]
    563e:	681b      	ldr	r3, [r3, #0]
    5640:	4a24      	ldr	r2, [pc, #144]	; (56d4 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    5642:	6812      	ldr	r2, [r2, #0]
    5644:	4610      	mov	r0, r2
    5646:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    5648:	4b23      	ldr	r3, [pc, #140]	; (56d8 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    564a:	681b      	ldr	r3, [r3, #0]
    564c:	681b      	ldr	r3, [r3, #0]
    564e:	4a23      	ldr	r2, [pc, #140]	; (56dc <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    5650:	6812      	ldr	r2, [r2, #0]
    5652:	4610      	mov	r0, r2
    5654:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    5656:	4b22      	ldr	r3, [pc, #136]	; (56e0 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    5658:	681b      	ldr	r3, [r3, #0]
    565a:	681b      	ldr	r3, [r3, #0]
    565c:	4a21      	ldr	r2, [pc, #132]	; (56e4 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    565e:	6812      	ldr	r2, [r2, #0]
    5660:	4610      	mov	r0, r2
    5662:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    5664:	e005      	b.n	5672 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    5666:	bf00      	nop
    5668:	e004      	b.n	5674 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    566a:	bf00      	nop
    566c:	e002      	b.n	5674 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    566e:	bf00      	nop
    5670:	e000      	b.n	5674 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5672:	bf00      	nop
    }

}
    5674:	bf00      	nop
    5676:	b003      	add	sp, #12
    5678:	f85d fb04 	ldr.w	pc, [sp], #4
    567c:	1fff8b19 	.word	0x1fff8b19
    5680:	1fff8bb8 	.word	0x1fff8bb8
    5684:	1fff8bd8 	.word	0x1fff8bd8
    5688:	1fff8bbc 	.word	0x1fff8bbc
    568c:	1fff8be0 	.word	0x1fff8be0
    5690:	1fff8bc0 	.word	0x1fff8bc0
    5694:	1fff8be8 	.word	0x1fff8be8
    5698:	1fff8bc4 	.word	0x1fff8bc4
    569c:	1fff8bf0 	.word	0x1fff8bf0
    56a0:	1fff8bac 	.word	0x1fff8bac
    56a4:	1fff8bd0 	.word	0x1fff8bd0
    56a8:	1fff8bb0 	.word	0x1fff8bb0
    56ac:	1fff8bcc 	.word	0x1fff8bcc
    56b0:	1fff8bb4 	.word	0x1fff8bb4
    56b4:	1fff8bc8 	.word	0x1fff8bc8
    56b8:	1fff8bd4 	.word	0x1fff8bd4
    56bc:	1fff8bdc 	.word	0x1fff8bdc
    56c0:	1fff8be4 	.word	0x1fff8be4
    56c4:	1fff8bec 	.word	0x1fff8bec
    56c8:	1fff8bf4 	.word	0x1fff8bf4
    56cc:	1fff8c04 	.word	0x1fff8c04
    56d0:	1fff8bf8 	.word	0x1fff8bf8
    56d4:	1fff8c08 	.word	0x1fff8c08
    56d8:	1fff8bfc 	.word	0x1fff8bfc
    56dc:	1fff8c0c 	.word	0x1fff8c0c
    56e0:	1fff8c00 	.word	0x1fff8c00
    56e4:	1fff8c10 	.word	0x1fff8c10

000056e8 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    56e8:	b500      	push	{lr}
    56ea:	b083      	sub	sp, #12
    56ec:	9001      	str	r0, [sp, #4]
    56ee:	9100      	str	r1, [sp, #0]
    switch(Command)
    56f0:	9b00      	ldr	r3, [sp, #0]
    56f2:	2b04      	cmp	r3, #4
    56f4:	d010      	beq.n	5718 <Clock_Ip_Command+0x30>
    56f6:	9b00      	ldr	r3, [sp, #0]
    56f8:	2b04      	cmp	r3, #4
    56fa:	d811      	bhi.n	5720 <Clock_Ip_Command+0x38>
    56fc:	9b00      	ldr	r3, [sp, #0]
    56fe:	2b01      	cmp	r3, #1
    5700:	d006      	beq.n	5710 <Clock_Ip_Command+0x28>
    5702:	9b00      	ldr	r3, [sp, #0]
    5704:	2b02      	cmp	r3, #2
    5706:	d10b      	bne.n	5720 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    5708:	9801      	ldr	r0, [sp, #4]
    570a:	f7ff fdb3 	bl	5274 <Clock_Ip_ClockInitializeObjects>
            break;
    570e:	e008      	b.n	5722 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    5710:	9801      	ldr	r0, [sp, #4]
    5712:	f7ff f9db 	bl	4acc <Clock_Ip_SpecificPlatformInitClock>
            break;
    5716:	e004      	b.n	5722 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    5718:	9801      	ldr	r0, [sp, #4]
    571a:	f7ff f8ed 	bl	48f8 <DisableSafeClock>
            break;
    571e:	e000      	b.n	5722 <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    5720:	bf00      	nop
    }
}
    5722:	bf00      	nop
    5724:	b003      	add	sp, #12
    5726:	f85d fb04 	ldr.w	pc, [sp], #4
    572a:	bf00      	nop

0000572c <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    572c:	b500      	push	{lr}
    572e:	b085      	sub	sp, #20
    5730:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    5732:	4a20      	ldr	r2, [pc, #128]	; (57b4 <Mcu_Init+0x88>)
    5734:	9b01      	ldr	r3, [sp, #4]
    5736:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5738:	2300      	movs	r3, #0
    573a:	9303      	str	r3, [sp, #12]
    573c:	e010      	b.n	5760 <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    573e:	4b1d      	ldr	r3, [pc, #116]	; (57b4 <Mcu_Init+0x88>)
    5740:	681b      	ldr	r3, [r3, #0]
    5742:	6919      	ldr	r1, [r3, #16]
    5744:	9a03      	ldr	r2, [sp, #12]
    5746:	4613      	mov	r3, r2
    5748:	005b      	lsls	r3, r3, #1
    574a:	4413      	add	r3, r2
    574c:	009b      	lsls	r3, r3, #2
    574e:	440b      	add	r3, r1
    5750:	681b      	ldr	r3, [r3, #0]
    5752:	9a03      	ldr	r2, [sp, #12]
    5754:	b2d1      	uxtb	r1, r2
    5756:	4a18      	ldr	r2, [pc, #96]	; (57b8 <Mcu_Init+0x8c>)
    5758:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    575a:	9b03      	ldr	r3, [sp, #12]
    575c:	3301      	adds	r3, #1
    575e:	9303      	str	r3, [sp, #12]
    5760:	4b14      	ldr	r3, [pc, #80]	; (57b4 <Mcu_Init+0x88>)
    5762:	681b      	ldr	r3, [r3, #0]
    5764:	689b      	ldr	r3, [r3, #8]
    5766:	9a03      	ldr	r2, [sp, #12]
    5768:	429a      	cmp	r2, r3
    576a:	d3e8      	bcc.n	573e <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    576c:	2300      	movs	r3, #0
    576e:	9303      	str	r3, [sp, #12]
    5770:	e010      	b.n	5794 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    5772:	4b10      	ldr	r3, [pc, #64]	; (57b4 <Mcu_Init+0x88>)
    5774:	681b      	ldr	r3, [r3, #0]
    5776:	6959      	ldr	r1, [r3, #20]
    5778:	9a03      	ldr	r2, [sp, #12]
    577a:	4613      	mov	r3, r2
    577c:	01db      	lsls	r3, r3, #7
    577e:	1a9b      	subs	r3, r3, r2
    5780:	00db      	lsls	r3, r3, #3
    5782:	440b      	add	r3, r1
    5784:	681b      	ldr	r3, [r3, #0]
    5786:	9a03      	ldr	r2, [sp, #12]
    5788:	b2d1      	uxtb	r1, r2
    578a:	4a0c      	ldr	r2, [pc, #48]	; (57bc <Mcu_Init+0x90>)
    578c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    578e:	9b03      	ldr	r3, [sp, #12]
    5790:	3301      	adds	r3, #1
    5792:	9303      	str	r3, [sp, #12]
    5794:	4b07      	ldr	r3, [pc, #28]	; (57b4 <Mcu_Init+0x88>)
    5796:	681b      	ldr	r3, [r3, #0]
    5798:	68db      	ldr	r3, [r3, #12]
    579a:	9a03      	ldr	r2, [sp, #12]
    579c:	429a      	cmp	r2, r3
    579e:	d3e8      	bcc.n	5772 <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    57a0:	4b04      	ldr	r3, [pc, #16]	; (57b4 <Mcu_Init+0x88>)
    57a2:	681b      	ldr	r3, [r3, #0]
    57a4:	699b      	ldr	r3, [r3, #24]
    57a6:	4618      	mov	r0, r3
    57a8:	f000 f88a 	bl	58c0 <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    57ac:	bf00      	nop
    57ae:	b005      	add	sp, #20
    57b0:	f85d fb04 	ldr.w	pc, [sp], #4
    57b4:	1fff8cec 	.word	0x1fff8cec
    57b8:	1fff8ce8 	.word	0x1fff8ce8
    57bc:	1fff8ce4 	.word	0x1fff8ce4

000057c0 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    57c0:	b084      	sub	sp, #16
    57c2:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    57c4:	2301      	movs	r3, #1
    57c6:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    57ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    57ce:	4618      	mov	r0, r3
    57d0:	b004      	add	sp, #16
    57d2:	4770      	bx	lr

000057d4 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    57d4:	b500      	push	{lr}
    57d6:	b085      	sub	sp, #20
    57d8:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    57da:	4a0e      	ldr	r2, [pc, #56]	; (5814 <Mcu_InitClock+0x40>)
    57dc:	9b01      	ldr	r3, [sp, #4]
    57de:	4413      	add	r3, r2
    57e0:	781b      	ldrb	r3, [r3, #0]
    57e2:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    57e6:	4b0c      	ldr	r3, [pc, #48]	; (5818 <Mcu_InitClock+0x44>)
    57e8:	681b      	ldr	r3, [r3, #0]
    57ea:	6959      	ldr	r1, [r3, #20]
    57ec:	f89d 200f 	ldrb.w	r2, [sp, #15]
    57f0:	4613      	mov	r3, r2
    57f2:	01db      	lsls	r3, r3, #7
    57f4:	1a9b      	subs	r3, r3, r2
    57f6:	00db      	lsls	r3, r3, #3
    57f8:	440b      	add	r3, r1
    57fa:	4618      	mov	r0, r3
    57fc:	f000 f86a 	bl	58d4 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    5800:	2300      	movs	r3, #0
    5802:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    5806:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    580a:	4618      	mov	r0, r3
    580c:	b005      	add	sp, #20
    580e:	f85d fb04 	ldr.w	pc, [sp], #4
    5812:	bf00      	nop
    5814:	1fff8ce4 	.word	0x1fff8ce4
    5818:	1fff8cec 	.word	0x1fff8cec

0000581c <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    581c:	b500      	push	{lr}
    581e:	b085      	sub	sp, #20
    5820:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    5822:	4a0d      	ldr	r2, [pc, #52]	; (5858 <Mcu_SetMode+0x3c>)
    5824:	9b01      	ldr	r3, [sp, #4]
    5826:	4413      	add	r3, r2
    5828:	781b      	ldrb	r3, [r3, #0]
    582a:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    582e:	f002 fedb 	bl	85e8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    5832:	4b0a      	ldr	r3, [pc, #40]	; (585c <Mcu_SetMode+0x40>)
    5834:	681b      	ldr	r3, [r3, #0]
    5836:	6919      	ldr	r1, [r3, #16]
    5838:	f89d 200f 	ldrb.w	r2, [sp, #15]
    583c:	4613      	mov	r3, r2
    583e:	005b      	lsls	r3, r3, #1
    5840:	4413      	add	r3, r2
    5842:	009b      	lsls	r3, r3, #2
    5844:	440b      	add	r3, r1
    5846:	4618      	mov	r0, r3
    5848:	f000 f84e 	bl	58e8 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    584c:	f002 fef8 	bl	8640 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5850:	bf00      	nop
    5852:	b005      	add	sp, #20
    5854:	f85d fb04 	ldr.w	pc, [sp], #4
    5858:	1fff8ce8 	.word	0x1fff8ce8
    585c:	1fff8cec 	.word	0x1fff8cec

00005860 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    5860:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    5862:	2302      	movs	r3, #2
    5864:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    5866:	9b01      	ldr	r3, [sp, #4]
}
    5868:	4618      	mov	r0, r3
    586a:	b002      	add	sp, #8
    586c:	4770      	bx	lr

0000586e <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    586e:	b500      	push	{lr}
    5870:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    5872:	f000 f843 	bl	58fc <Mcu_Ipw_GetResetReason>
    5876:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    5878:	9b01      	ldr	r3, [sp, #4]
}
    587a:	4618      	mov	r0, r3
    587c:	b003      	add	sp, #12
    587e:	f85d fb04 	ldr.w	pc, [sp], #4

00005882 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    5882:	b500      	push	{lr}
    5884:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    5886:	f000 f83f 	bl	5908 <Mcu_Ipw_GetResetRawValue>
    588a:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    588c:	9b01      	ldr	r3, [sp, #4]
}
    588e:	4618      	mov	r0, r3
    5890:	b003      	add	sp, #12
    5892:	f85d fb04 	ldr.w	pc, [sp], #4

00005896 <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5896:	b500      	push	{lr}
    5898:	b083      	sub	sp, #12
    589a:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    589c:	9801      	ldr	r0, [sp, #4]
    589e:	f000 f839 	bl	5914 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    58a2:	bf00      	nop
    58a4:	b003      	add	sp, #12
    58a6:	f85d fb04 	ldr.w	pc, [sp], #4

000058aa <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    58aa:	b082      	sub	sp, #8
    58ac:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    58ae:	4b03      	ldr	r3, [pc, #12]	; (58bc <Mcu_ClkSrcFailureNotification+0x12>)
    58b0:	681b      	ldr	r3, [r3, #0]
    58b2:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    58b4:	bf00      	nop
    58b6:	b002      	add	sp, #8
    58b8:	4770      	bx	lr
    58ba:	bf00      	nop
    58bc:	1fff8cec 	.word	0x1fff8cec

000058c0 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    58c0:	b500      	push	{lr}
    58c2:	b083      	sub	sp, #12
    58c4:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    58c6:	9801      	ldr	r0, [sp, #4]
    58c8:	f000 f882 	bl	59d0 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    58cc:	bf00      	nop
    58ce:	b003      	add	sp, #12
    58d0:	f85d fb04 	ldr.w	pc, [sp], #4

000058d4 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    58d4:	b500      	push	{lr}
    58d6:	b083      	sub	sp, #12
    58d8:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    58da:	9801      	ldr	r0, [sp, #4]
    58dc:	f7fc fc6a 	bl	21b4 <Clock_Ip_InitClock>
}
    58e0:	bf00      	nop
    58e2:	b003      	add	sp, #12
    58e4:	f85d fb04 	ldr.w	pc, [sp], #4

000058e8 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    58e8:	b500      	push	{lr}
    58ea:	b083      	sub	sp, #12
    58ec:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    58ee:	9801      	ldr	r0, [sp, #4]
    58f0:	f000 f820 	bl	5934 <Power_Ip_SetMode>
}
    58f4:	bf00      	nop
    58f6:	b003      	add	sp, #12
    58f8:	f85d fb04 	ldr.w	pc, [sp], #4

000058fc <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    58fc:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    58fe:	f000 f84f 	bl	59a0 <Power_Ip_GetResetReason>
    5902:	4603      	mov	r3, r0
}
    5904:	4618      	mov	r0, r3
    5906:	bd08      	pop	{r3, pc}

00005908 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    5908:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    590a:	f000 f857 	bl	59bc <Power_Ip_GetResetRawValue>
    590e:	4603      	mov	r3, r0
}
    5910:	4618      	mov	r0, r3
    5912:	bd08      	pop	{r3, pc}

00005914 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5914:	b500      	push	{lr}
    5916:	b083      	sub	sp, #12
    5918:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    591a:	9b01      	ldr	r3, [sp, #4]
    591c:	2b00      	cmp	r3, #0
    591e:	d102      	bne.n	5926 <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    5920:	f000 f86c 	bl	59fc <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    5924:	e001      	b.n	592a <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    5926:	f000 f86e 	bl	5a06 <Power_Ip_EnableSleepOnExit>
}
    592a:	bf00      	nop
    592c:	b003      	add	sp, #12
    592e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005934 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    5934:	b500      	push	{lr}
    5936:	b085      	sub	sp, #20
    5938:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    593a:	9b01      	ldr	r3, [sp, #4]
    593c:	685b      	ldr	r3, [r3, #4]
    593e:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    5940:	9802      	ldr	r0, [sp, #8]
    5942:	f000 f9f5 	bl	5d30 <Power_Ip_SMC_ModeCheckEntry>
    5946:	4603      	mov	r3, r0
    5948:	2b00      	cmp	r3, #0
    594a:	d002      	beq.n	5952 <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    594c:	2301      	movs	r3, #1
    594e:	9303      	str	r3, [sp, #12]
    5950:	e003      	b.n	595a <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    5952:	9801      	ldr	r0, [sp, #4]
    5954:	f000 fa1e 	bl	5d94 <Power_Ip_SMC_ModeConfig>
    5958:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    595a:	9b03      	ldr	r3, [sp, #12]
    595c:	2b01      	cmp	r3, #1
    595e:	d103      	bne.n	5968 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5960:	21ff      	movs	r1, #255	; 0xff
    5962:	2003      	movs	r0, #3
    5964:	f000 f8f4 	bl	5b50 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    5968:	bf00      	nop
    596a:	b005      	add	sp, #20
    596c:	f85d fb04 	ldr.w	pc, [sp], #4

00005970 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    5970:	b084      	sub	sp, #16
    5972:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    5974:	230c      	movs	r3, #12
    5976:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    5978:	4a08      	ldr	r2, [pc, #32]	; (599c <Power_Ip_ConvertIntergeToResetType+0x2c>)
    597a:	9b01      	ldr	r3, [sp, #4]
    597c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5980:	2b0e      	cmp	r3, #14
    5982:	d805      	bhi.n	5990 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    5984:	4a05      	ldr	r2, [pc, #20]	; (599c <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5986:	9b01      	ldr	r3, [sp, #4]
    5988:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    598c:	9303      	str	r3, [sp, #12]
    598e:	e001      	b.n	5994 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    5990:	230c      	movs	r3, #12
    5992:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    5994:	9b03      	ldr	r3, [sp, #12]
}
    5996:	4618      	mov	r0, r3
    5998:	b004      	add	sp, #16
    599a:	4770      	bx	lr
    599c:	0000adec 	.word	0x0000adec

000059a0 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    59a0:	b500      	push	{lr}
    59a2:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    59a4:	f000 f940 	bl	5c28 <Power_Ip_RCM_GetResetReason>
    59a8:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    59aa:	9801      	ldr	r0, [sp, #4]
    59ac:	f7ff ffe0 	bl	5970 <Power_Ip_ConvertIntergeToResetType>
    59b0:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    59b2:	9b00      	ldr	r3, [sp, #0]
}
    59b4:	4618      	mov	r0, r3
    59b6:	b003      	add	sp, #12
    59b8:	f85d fb04 	ldr.w	pc, [sp], #4

000059bc <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    59bc:	b500      	push	{lr}
    59be:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    59c0:	f000 f98a 	bl	5cd8 <Power_Ip_RCM_GetResetRawValue>
    59c4:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    59c6:	9b01      	ldr	r3, [sp, #4]
}
    59c8:	4618      	mov	r0, r3
    59ca:	b003      	add	sp, #12
    59cc:	f85d fb04 	ldr.w	pc, [sp], #4

000059d0 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    59d0:	b500      	push	{lr}
    59d2:	b083      	sub	sp, #12
    59d4:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    59d6:	9b01      	ldr	r3, [sp, #4]
    59d8:	681b      	ldr	r3, [r3, #0]
    59da:	4618      	mov	r0, r3
    59dc:	f000 f90e 	bl	5bfc <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    59e0:	9b01      	ldr	r3, [sp, #4]
    59e2:	685b      	ldr	r3, [r3, #4]
    59e4:	4618      	mov	r0, r3
    59e6:	f000 f86d 	bl	5ac4 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    59ea:	9b01      	ldr	r3, [sp, #4]
    59ec:	689b      	ldr	r3, [r3, #8]
    59ee:	4618      	mov	r0, r3
    59f0:	f000 f990 	bl	5d14 <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    59f4:	bf00      	nop
    59f6:	b003      	add	sp, #12
    59f8:	f85d fb04 	ldr.w	pc, [sp], #4

000059fc <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    59fc:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    59fe:	f000 f811 	bl	5a24 <Power_Ip_CM4_DisableSleepOnExit>
}
    5a02:	bf00      	nop
    5a04:	bd08      	pop	{r3, pc}

00005a06 <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    5a06:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    5a08:	f000 f820 	bl	5a4c <Power_Ip_CM4_EnableSleepOnExit>
}
    5a0c:	bf00      	nop
    5a0e:	bd08      	pop	{r3, pc}

00005a10 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    5a10:	b082      	sub	sp, #8
    5a12:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    5a14:	4a02      	ldr	r2, [pc, #8]	; (5a20 <Power_Ip_InstallNotificationsCallback+0x10>)
    5a16:	9b01      	ldr	r3, [sp, #4]
    5a18:	6013      	str	r3, [r2, #0]
}
    5a1a:	bf00      	nop
    5a1c:	b002      	add	sp, #8
    5a1e:	4770      	bx	lr
    5a20:	1fff8b1c 	.word	0x1fff8b1c

00005a24 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    5a24:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5a26:	2300      	movs	r3, #0
    5a28:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5a2a:	4b07      	ldr	r3, [pc, #28]	; (5a48 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    5a2c:	681b      	ldr	r3, [r3, #0]
    5a2e:	685b      	ldr	r3, [r3, #4]
    5a30:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    5a32:	9b01      	ldr	r3, [sp, #4]
    5a34:	f023 0302 	bic.w	r3, r3, #2
    5a38:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5a3a:	4b03      	ldr	r3, [pc, #12]	; (5a48 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    5a3c:	681b      	ldr	r3, [r3, #0]
    5a3e:	9a01      	ldr	r2, [sp, #4]
    5a40:	605a      	str	r2, [r3, #4]
}
    5a42:	bf00      	nop
    5a44:	b002      	add	sp, #8
    5a46:	4770      	bx	lr
    5a48:	1fff8b20 	.word	0x1fff8b20

00005a4c <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    5a4c:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5a4e:	2300      	movs	r3, #0
    5a50:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5a52:	4b07      	ldr	r3, [pc, #28]	; (5a70 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    5a54:	681b      	ldr	r3, [r3, #0]
    5a56:	685b      	ldr	r3, [r3, #4]
    5a58:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    5a5a:	9b01      	ldr	r3, [sp, #4]
    5a5c:	f043 0302 	orr.w	r3, r3, #2
    5a60:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5a62:	4b03      	ldr	r3, [pc, #12]	; (5a70 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    5a64:	681b      	ldr	r3, [r3, #0]
    5a66:	9a01      	ldr	r2, [sp, #4]
    5a68:	605a      	str	r2, [r3, #4]
}
    5a6a:	bf00      	nop
    5a6c:	b002      	add	sp, #8
    5a6e:	4770      	bx	lr
    5a70:	1fff8b20 	.word	0x1fff8b20

00005a74 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    5a74:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5a76:	2300      	movs	r3, #0
    5a78:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5a7a:	4b07      	ldr	r3, [pc, #28]	; (5a98 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    5a7c:	681b      	ldr	r3, [r3, #0]
    5a7e:	685b      	ldr	r3, [r3, #4]
    5a80:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    5a82:	9b01      	ldr	r3, [sp, #4]
    5a84:	f043 0304 	orr.w	r3, r3, #4
    5a88:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5a8a:	4b03      	ldr	r3, [pc, #12]	; (5a98 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    5a8c:	681b      	ldr	r3, [r3, #0]
    5a8e:	9a01      	ldr	r2, [sp, #4]
    5a90:	605a      	str	r2, [r3, #4]
}
    5a92:	bf00      	nop
    5a94:	b002      	add	sp, #8
    5a96:	4770      	bx	lr
    5a98:	1fff8b20 	.word	0x1fff8b20

00005a9c <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    5a9c:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5a9e:	2300      	movs	r3, #0
    5aa0:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5aa2:	4b07      	ldr	r3, [pc, #28]	; (5ac0 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    5aa4:	681b      	ldr	r3, [r3, #0]
    5aa6:	685b      	ldr	r3, [r3, #4]
    5aa8:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    5aaa:	9b01      	ldr	r3, [sp, #4]
    5aac:	f023 0304 	bic.w	r3, r3, #4
    5ab0:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5ab2:	4b03      	ldr	r3, [pc, #12]	; (5ac0 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    5ab4:	681b      	ldr	r3, [r3, #0]
    5ab6:	9a01      	ldr	r2, [sp, #4]
    5ab8:	605a      	str	r2, [r3, #4]
}
    5aba:	bf00      	nop
    5abc:	b002      	add	sp, #8
    5abe:	4770      	bx	lr
    5ac0:	1fff8b20 	.word	0x1fff8b20

00005ac4 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    5ac4:	b084      	sub	sp, #16
    5ac6:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    5ac8:	4b20      	ldr	r3, [pc, #128]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5aca:	781b      	ldrb	r3, [r3, #0]
    5acc:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    5ad0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5ad4:	f003 030f 	and.w	r3, r3, #15
    5ad8:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    5adc:	9b01      	ldr	r3, [sp, #4]
    5ade:	781a      	ldrb	r2, [r3, #0]
    5ae0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5ae4:	4313      	orrs	r3, r2
    5ae6:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    5aea:	4a18      	ldr	r2, [pc, #96]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5aec:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5af0:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    5af2:	4b16      	ldr	r3, [pc, #88]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5af4:	785b      	ldrb	r3, [r3, #1]
    5af6:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    5afa:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5afe:	f003 031f 	and.w	r3, r3, #31
    5b02:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    5b06:	9b01      	ldr	r3, [sp, #4]
    5b08:	785a      	ldrb	r2, [r3, #1]
    5b0a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5b0e:	4313      	orrs	r3, r2
    5b10:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    5b14:	4a0d      	ldr	r2, [pc, #52]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5b16:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5b1a:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    5b1c:	4b0b      	ldr	r3, [pc, #44]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5b1e:	789b      	ldrb	r3, [r3, #2]
    5b20:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    5b24:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5b28:	f003 0338 	and.w	r3, r3, #56	; 0x38
    5b2c:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    5b30:	9b01      	ldr	r3, [sp, #4]
    5b32:	789a      	ldrb	r2, [r3, #2]
    5b34:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5b38:	4313      	orrs	r3, r2
    5b3a:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    5b3e:	4a03      	ldr	r2, [pc, #12]	; (5b4c <Power_Ip_PMC_PowerInit+0x88>)
    5b40:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5b44:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    5b46:	bf00      	nop
    5b48:	b004      	add	sp, #16
    5b4a:	4770      	bx	lr
    5b4c:	4007d000 	.word	0x4007d000

00005b50 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    5b50:	b500      	push	{lr}
    5b52:	b083      	sub	sp, #12
    5b54:	9001      	str	r0, [sp, #4]
    5b56:	460b      	mov	r3, r1
    5b58:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    5b5c:	4b05      	ldr	r3, [pc, #20]	; (5b74 <Power_Ip_ReportPowerErrors+0x24>)
    5b5e:	681b      	ldr	r3, [r3, #0]
    5b60:	f89d 2003 	ldrb.w	r2, [sp, #3]
    5b64:	4611      	mov	r1, r2
    5b66:	9801      	ldr	r0, [sp, #4]
    5b68:	4798      	blx	r3
}
    5b6a:	bf00      	nop
    5b6c:	b003      	add	sp, #12
    5b6e:	f85d fb04 	ldr.w	pc, [sp], #4
    5b72:	bf00      	nop
    5b74:	1fff8b1c 	.word	0x1fff8b1c

00005b78 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    5b78:	b082      	sub	sp, #8
    5b7a:	9001      	str	r0, [sp, #4]
    5b7c:	460b      	mov	r3, r1
    5b7e:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    5b82:	bf00      	nop
    5b84:	b002      	add	sp, #8
    5b86:	4770      	bx	lr

00005b88 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    5b88:	b500      	push	{lr}
    5b8a:	b085      	sub	sp, #20
    5b8c:	9003      	str	r0, [sp, #12]
    5b8e:	9102      	str	r1, [sp, #8]
    5b90:	9201      	str	r2, [sp, #4]
    5b92:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    5b94:	2000      	movs	r0, #0
    5b96:	f7fc f83d 	bl	1c14 <OsIf_GetCounter>
    5b9a:	4602      	mov	r2, r0
    5b9c:	9b03      	ldr	r3, [sp, #12]
    5b9e:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    5ba0:	9b02      	ldr	r3, [sp, #8]
    5ba2:	2200      	movs	r2, #0
    5ba4:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    5ba6:	2100      	movs	r1, #0
    5ba8:	9800      	ldr	r0, [sp, #0]
    5baa:	f7fc f87f 	bl	1cac <OsIf_MicrosToTicks>
    5bae:	4602      	mov	r2, r0
    5bb0:	9b01      	ldr	r3, [sp, #4]
    5bb2:	601a      	str	r2, [r3, #0]
}
    5bb4:	bf00      	nop
    5bb6:	b005      	add	sp, #20
    5bb8:	f85d fb04 	ldr.w	pc, [sp], #4

00005bbc <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    5bbc:	b500      	push	{lr}
    5bbe:	b087      	sub	sp, #28
    5bc0:	9003      	str	r0, [sp, #12]
    5bc2:	9102      	str	r1, [sp, #8]
    5bc4:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    5bc6:	2300      	movs	r3, #0
    5bc8:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    5bcc:	2100      	movs	r1, #0
    5bce:	9803      	ldr	r0, [sp, #12]
    5bd0:	f7fc f839 	bl	1c46 <OsIf_GetElapsed>
    5bd4:	4602      	mov	r2, r0
    5bd6:	9b02      	ldr	r3, [sp, #8]
    5bd8:	681b      	ldr	r3, [r3, #0]
    5bda:	441a      	add	r2, r3
    5bdc:	9b02      	ldr	r3, [sp, #8]
    5bde:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    5be0:	9b02      	ldr	r3, [sp, #8]
    5be2:	681b      	ldr	r3, [r3, #0]
    5be4:	9a01      	ldr	r2, [sp, #4]
    5be6:	429a      	cmp	r2, r3
    5be8:	d802      	bhi.n	5bf0 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    5bea:	2301      	movs	r3, #1
    5bec:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    5bf0:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5bf4:	4618      	mov	r0, r3
    5bf6:	b007      	add	sp, #28
    5bf8:	f85d fb04 	ldr.w	pc, [sp], #4

00005bfc <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    5bfc:	b082      	sub	sp, #8
    5bfe:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    5c00:	9b01      	ldr	r3, [sp, #4]
    5c02:	681a      	ldr	r2, [r3, #0]
    5c04:	4907      	ldr	r1, [pc, #28]	; (5c24 <Power_Ip_RCM_ResetInit+0x28>)
    5c06:	f641 7307 	movw	r3, #7943	; 0x1f07
    5c0a:	4013      	ands	r3, r2
    5c0c:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    5c0e:	9b01      	ldr	r3, [sp, #4]
    5c10:	685a      	ldr	r2, [r3, #4]
    5c12:	4904      	ldr	r1, [pc, #16]	; (5c24 <Power_Ip_RCM_ResetInit+0x28>)
    5c14:	f642 73ff 	movw	r3, #12287	; 0x2fff
    5c18:	4013      	ands	r3, r2
    5c1a:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    5c1c:	bf00      	nop
    5c1e:	b002      	add	sp, #8
    5c20:	4770      	bx	lr
    5c22:	bf00      	nop
    5c24:	4007f000 	.word	0x4007f000

00005c28 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    5c28:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    5c2a:	230c      	movs	r3, #12
    5c2c:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    5c2e:	2300      	movs	r3, #0
    5c30:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    5c32:	2300      	movs	r3, #0
    5c34:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    5c36:	2300      	movs	r3, #0
    5c38:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    5c3a:	4b25      	ldr	r3, [pc, #148]	; (5cd0 <Power_Ip_RCM_GetResetReason+0xa8>)
    5c3c:	699a      	ldr	r2, [r3, #24]
    5c3e:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5c42:	4013      	ands	r3, r2
    5c44:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    5c46:	9b03      	ldr	r3, [sp, #12]
    5c48:	2b00      	cmp	r3, #0
    5c4a:	d008      	beq.n	5c5e <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5c4c:	4920      	ldr	r1, [pc, #128]	; (5cd0 <Power_Ip_RCM_GetResetReason+0xa8>)
    5c4e:	9a03      	ldr	r2, [sp, #12]
    5c50:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5c54:	4013      	ands	r3, r2
    5c56:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    5c58:	4a1e      	ldr	r2, [pc, #120]	; (5cd4 <Power_Ip_RCM_GetResetReason+0xac>)
    5c5a:	9b03      	ldr	r3, [sp, #12]
    5c5c:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    5c5e:	4b1d      	ldr	r3, [pc, #116]	; (5cd4 <Power_Ip_RCM_GetResetReason+0xac>)
    5c60:	681b      	ldr	r3, [r3, #0]
    5c62:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    5c64:	9a02      	ldr	r2, [sp, #8]
    5c66:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5c6a:	4013      	ands	r3, r2
    5c6c:	2b82      	cmp	r3, #130	; 0x82
    5c6e:	d102      	bne.n	5c76 <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    5c70:	2305      	movs	r3, #5
    5c72:	9307      	str	r3, [sp, #28]
    5c74:	e027      	b.n	5cc6 <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    5c76:	2300      	movs	r3, #0
    5c78:	9306      	str	r3, [sp, #24]
    5c7a:	e021      	b.n	5cc0 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    5c7c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5c80:	9b06      	ldr	r3, [sp, #24]
    5c82:	fa22 f303 	lsr.w	r3, r2, r3
    5c86:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    5c88:	9a01      	ldr	r2, [sp, #4]
    5c8a:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    5c8e:	4013      	ands	r3, r2
    5c90:	2b00      	cmp	r3, #0
    5c92:	d012      	beq.n	5cba <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    5c94:	9a01      	ldr	r2, [sp, #4]
    5c96:	9b02      	ldr	r3, [sp, #8]
    5c98:	4013      	ands	r3, r2
    5c9a:	2b00      	cmp	r3, #0
    5c9c:	d00a      	beq.n	5cb4 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    5c9e:	9b05      	ldr	r3, [sp, #20]
    5ca0:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    5ca2:	9b04      	ldr	r3, [sp, #16]
    5ca4:	3301      	adds	r3, #1
    5ca6:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    5ca8:	9b04      	ldr	r3, [sp, #16]
    5caa:	2b01      	cmp	r3, #1
    5cac:	d902      	bls.n	5cb4 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    5cae:	230d      	movs	r3, #13
    5cb0:	9307      	str	r3, [sp, #28]
                        break;
    5cb2:	e008      	b.n	5cc6 <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    5cb4:	9b05      	ldr	r3, [sp, #20]
    5cb6:	3301      	adds	r3, #1
    5cb8:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    5cba:	9b06      	ldr	r3, [sp, #24]
    5cbc:	3301      	adds	r3, #1
    5cbe:	9306      	str	r3, [sp, #24]
    5cc0:	9b06      	ldr	r3, [sp, #24]
    5cc2:	2b1f      	cmp	r3, #31
    5cc4:	d9da      	bls.n	5c7c <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    5cc6:	9b07      	ldr	r3, [sp, #28]
}
    5cc8:	4618      	mov	r0, r3
    5cca:	b008      	add	sp, #32
    5ccc:	4770      	bx	lr
    5cce:	bf00      	nop
    5cd0:	4007f000 	.word	0x4007f000
    5cd4:	1fff8cf0 	.word	0x1fff8cf0

00005cd8 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    5cd8:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    5cda:	4b0c      	ldr	r3, [pc, #48]	; (5d0c <Power_Ip_RCM_GetResetRawValue+0x34>)
    5cdc:	699a      	ldr	r2, [r3, #24]
    5cde:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5ce2:	4013      	ands	r3, r2
    5ce4:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    5ce6:	9b01      	ldr	r3, [sp, #4]
    5ce8:	2b00      	cmp	r3, #0
    5cea:	d008      	beq.n	5cfe <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5cec:	4907      	ldr	r1, [pc, #28]	; (5d0c <Power_Ip_RCM_GetResetRawValue+0x34>)
    5cee:	9a01      	ldr	r2, [sp, #4]
    5cf0:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5cf4:	4013      	ands	r3, r2
    5cf6:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    5cf8:	4a05      	ldr	r2, [pc, #20]	; (5d10 <Power_Ip_RCM_GetResetRawValue+0x38>)
    5cfa:	9b01      	ldr	r3, [sp, #4]
    5cfc:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    5cfe:	4b04      	ldr	r3, [pc, #16]	; (5d10 <Power_Ip_RCM_GetResetRawValue+0x38>)
    5d00:	681b      	ldr	r3, [r3, #0]
    5d02:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    5d04:	9b00      	ldr	r3, [sp, #0]
}
    5d06:	4618      	mov	r0, r3
    5d08:	b002      	add	sp, #8
    5d0a:	4770      	bx	lr
    5d0c:	4007f000 	.word	0x4007f000
    5d10:	1fff8cf0 	.word	0x1fff8cf0

00005d14 <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    5d14:	b082      	sub	sp, #8
    5d16:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    5d18:	9b01      	ldr	r3, [sp, #4]
    5d1a:	681b      	ldr	r3, [r3, #0]
    5d1c:	4a03      	ldr	r2, [pc, #12]	; (5d2c <Power_Ip_SMC_AllowedModesConfig+0x18>)
    5d1e:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    5d22:	6093      	str	r3, [r2, #8]
}
    5d24:	bf00      	nop
    5d26:	b002      	add	sp, #8
    5d28:	4770      	bx	lr
    5d2a:	bf00      	nop
    5d2c:	4007e000 	.word	0x4007e000

00005d30 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    5d30:	b084      	sub	sp, #16
    5d32:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    5d34:	2301      	movs	r3, #1
    5d36:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    5d38:	4b15      	ldr	r3, [pc, #84]	; (5d90 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    5d3a:	695b      	ldr	r3, [r3, #20]
    5d3c:	b2db      	uxtb	r3, r3
    5d3e:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    5d40:	9b01      	ldr	r3, [sp, #4]
    5d42:	2b02      	cmp	r3, #2
    5d44:	d012      	beq.n	5d6c <Power_Ip_SMC_ModeCheckEntry+0x3c>
    5d46:	9b01      	ldr	r3, [sp, #4]
    5d48:	2b02      	cmp	r3, #2
    5d4a:	d818      	bhi.n	5d7e <Power_Ip_SMC_ModeCheckEntry+0x4e>
    5d4c:	9b01      	ldr	r3, [sp, #4]
    5d4e:	2b00      	cmp	r3, #0
    5d50:	d003      	beq.n	5d5a <Power_Ip_SMC_ModeCheckEntry+0x2a>
    5d52:	9b01      	ldr	r3, [sp, #4]
    5d54:	2b01      	cmp	r3, #1
    5d56:	d003      	beq.n	5d60 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    5d58:	e011      	b.n	5d7e <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    5d5a:	2300      	movs	r3, #0
    5d5c:	9303      	str	r3, [sp, #12]
            break;
    5d5e:	e013      	b.n	5d88 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    5d60:	9b02      	ldr	r3, [sp, #8]
    5d62:	2b01      	cmp	r3, #1
    5d64:	d10d      	bne.n	5d82 <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    5d66:	2300      	movs	r3, #0
    5d68:	9303      	str	r3, [sp, #12]
            break;
    5d6a:	e00a      	b.n	5d82 <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    5d6c:	9b02      	ldr	r3, [sp, #8]
    5d6e:	2b01      	cmp	r3, #1
    5d70:	d002      	beq.n	5d78 <Power_Ip_SMC_ModeCheckEntry+0x48>
    5d72:	9b02      	ldr	r3, [sp, #8]
    5d74:	2b10      	cmp	r3, #16
    5d76:	d106      	bne.n	5d86 <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    5d78:	2300      	movs	r3, #0
    5d7a:	9303      	str	r3, [sp, #12]
            break;
    5d7c:	e003      	b.n	5d86 <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    5d7e:	bf00      	nop
    5d80:	e002      	b.n	5d88 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    5d82:	bf00      	nop
    5d84:	e000      	b.n	5d88 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    5d86:	bf00      	nop
        }
    }

    return PowerModeCheck;
    5d88:	9b03      	ldr	r3, [sp, #12]
}
    5d8a:	4618      	mov	r0, r3
    5d8c:	b004      	add	sp, #16
    5d8e:	4770      	bx	lr
    5d90:	4007e000 	.word	0x4007e000

00005d94 <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    5d94:	b500      	push	{lr}
    5d96:	b08b      	sub	sp, #44	; 0x2c
    5d98:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    5d9a:	2300      	movs	r3, #0
    5d9c:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    5d9e:	2300      	movs	r3, #0
    5da0:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    5da2:	2300      	movs	r3, #0
    5da4:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    5da8:	9b01      	ldr	r3, [sp, #4]
    5daa:	685b      	ldr	r3, [r3, #4]
    5dac:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    5dae:	9b08      	ldr	r3, [sp, #32]
    5db0:	2b02      	cmp	r3, #2
    5db2:	d076      	beq.n	5ea2 <Power_Ip_SMC_ModeConfig+0x10e>
    5db4:	9b08      	ldr	r3, [sp, #32]
    5db6:	2b02      	cmp	r3, #2
    5db8:	f200 80ab 	bhi.w	5f12 <Power_Ip_SMC_ModeConfig+0x17e>
    5dbc:	9b08      	ldr	r3, [sp, #32]
    5dbe:	2b00      	cmp	r3, #0
    5dc0:	d003      	beq.n	5dca <Power_Ip_SMC_ModeConfig+0x36>
    5dc2:	9b08      	ldr	r3, [sp, #32]
    5dc4:	2b01      	cmp	r3, #1
    5dc6:	d034      	beq.n	5e32 <Power_Ip_SMC_ModeConfig+0x9e>
    5dc8:	e0a3      	b.n	5f12 <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    5dca:	4b58      	ldr	r3, [pc, #352]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5dcc:	68db      	ldr	r3, [r3, #12]
    5dce:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    5dd0:	9b06      	ldr	r3, [sp, #24]
    5dd2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    5dd6:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    5dd8:	4a54      	ldr	r2, [pc, #336]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5dda:	9b06      	ldr	r3, [sp, #24]
    5ddc:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5dde:	aa02      	add	r2, sp, #8
    5de0:	a903      	add	r1, sp, #12
    5de2:	a804      	add	r0, sp, #16
    5de4:	f24c 3350 	movw	r3, #50000	; 0xc350
    5de8:	f7ff fece 	bl	5b88 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5dec:	9a02      	ldr	r2, [sp, #8]
    5dee:	a903      	add	r1, sp, #12
    5df0:	ab04      	add	r3, sp, #16
    5df2:	4618      	mov	r0, r3
    5df4:	f7ff fee2 	bl	5bbc <Power_Ip_TimeoutExpired>
    5df8:	4603      	mov	r3, r0
    5dfa:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    5dfe:	4b4b      	ldr	r3, [pc, #300]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5e00:	695b      	ldr	r3, [r3, #20]
    5e02:	f003 0301 	and.w	r3, r3, #1
    5e06:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    5e08:	9b05      	ldr	r3, [sp, #20]
    5e0a:	2b01      	cmp	r3, #1
    5e0c:	d006      	beq.n	5e1c <Power_Ip_SMC_ModeConfig+0x88>
    5e0e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5e12:	f083 0301 	eor.w	r3, r3, #1
    5e16:	b2db      	uxtb	r3, r3
    5e18:	2b00      	cmp	r3, #0
    5e1a:	d1e7      	bne.n	5dec <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    5e1c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5e20:	2b00      	cmp	r3, #0
    5e22:	d079      	beq.n	5f18 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5e24:	2301      	movs	r3, #1
    5e26:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5e28:	21ff      	movs	r1, #255	; 0xff
    5e2a:	2000      	movs	r0, #0
    5e2c:	f7ff fe90 	bl	5b50 <Power_Ip_ReportPowerErrors>
            }

            break;
    5e30:	e072      	b.n	5f18 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    5e32:	4b3e      	ldr	r3, [pc, #248]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5e34:	68db      	ldr	r3, [r3, #12]
    5e36:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    5e38:	9b06      	ldr	r3, [sp, #24]
    5e3a:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    5e3e:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    5e40:	9b06      	ldr	r3, [sp, #24]
    5e42:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    5e46:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    5e48:	4a38      	ldr	r2, [pc, #224]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5e4a:	9b06      	ldr	r3, [sp, #24]
    5e4c:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5e4e:	aa02      	add	r2, sp, #8
    5e50:	a903      	add	r1, sp, #12
    5e52:	a804      	add	r0, sp, #16
    5e54:	f24c 3350 	movw	r3, #50000	; 0xc350
    5e58:	f7ff fe96 	bl	5b88 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5e5c:	9a02      	ldr	r2, [sp, #8]
    5e5e:	a903      	add	r1, sp, #12
    5e60:	ab04      	add	r3, sp, #16
    5e62:	4618      	mov	r0, r3
    5e64:	f7ff feaa 	bl	5bbc <Power_Ip_TimeoutExpired>
    5e68:	4603      	mov	r3, r0
    5e6a:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    5e6e:	4b2f      	ldr	r3, [pc, #188]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5e70:	695b      	ldr	r3, [r3, #20]
    5e72:	f003 0380 	and.w	r3, r3, #128	; 0x80
    5e76:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    5e78:	9b05      	ldr	r3, [sp, #20]
    5e7a:	2b80      	cmp	r3, #128	; 0x80
    5e7c:	d006      	beq.n	5e8c <Power_Ip_SMC_ModeConfig+0xf8>
    5e7e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5e82:	f083 0301 	eor.w	r3, r3, #1
    5e86:	b2db      	uxtb	r3, r3
    5e88:	2b00      	cmp	r3, #0
    5e8a:	d1e7      	bne.n	5e5c <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    5e8c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5e90:	2b00      	cmp	r3, #0
    5e92:	d043      	beq.n	5f1c <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5e94:	2301      	movs	r3, #1
    5e96:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5e98:	21ff      	movs	r1, #255	; 0xff
    5e9a:	2000      	movs	r0, #0
    5e9c:	f7ff fe58 	bl	5b50 <Power_Ip_ReportPowerErrors>
            }

            break;
    5ea0:	e03c      	b.n	5f1c <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    5ea2:	4b22      	ldr	r3, [pc, #136]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5ea4:	68db      	ldr	r3, [r3, #12]
    5ea6:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    5ea8:	9b06      	ldr	r3, [sp, #24]
    5eaa:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    5eae:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    5eb0:	9b06      	ldr	r3, [sp, #24]
    5eb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5eb6:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    5eb8:	4a1c      	ldr	r2, [pc, #112]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5eba:	9b06      	ldr	r3, [sp, #24]
    5ebc:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5ebe:	aa02      	add	r2, sp, #8
    5ec0:	a903      	add	r1, sp, #12
    5ec2:	a804      	add	r0, sp, #16
    5ec4:	f24c 3350 	movw	r3, #50000	; 0xc350
    5ec8:	f7ff fe5e 	bl	5b88 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5ecc:	9a02      	ldr	r2, [sp, #8]
    5ece:	a903      	add	r1, sp, #12
    5ed0:	ab04      	add	r3, sp, #16
    5ed2:	4618      	mov	r0, r3
    5ed4:	f7ff fe72 	bl	5bbc <Power_Ip_TimeoutExpired>
    5ed8:	4603      	mov	r3, r0
    5eda:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    5ede:	4b13      	ldr	r3, [pc, #76]	; (5f2c <Power_Ip_SMC_ModeConfig+0x198>)
    5ee0:	695b      	ldr	r3, [r3, #20]
    5ee2:	f003 0304 	and.w	r3, r3, #4
    5ee6:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    5ee8:	9b05      	ldr	r3, [sp, #20]
    5eea:	2b04      	cmp	r3, #4
    5eec:	d006      	beq.n	5efc <Power_Ip_SMC_ModeConfig+0x168>
    5eee:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5ef2:	f083 0301 	eor.w	r3, r3, #1
    5ef6:	b2db      	uxtb	r3, r3
    5ef8:	2b00      	cmp	r3, #0
    5efa:	d1e7      	bne.n	5ecc <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    5efc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5f00:	2b00      	cmp	r3, #0
    5f02:	d00d      	beq.n	5f20 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5f04:	2301      	movs	r3, #1
    5f06:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5f08:	21ff      	movs	r1, #255	; 0xff
    5f0a:	2000      	movs	r0, #0
    5f0c:	f7ff fe20 	bl	5b50 <Power_Ip_ReportPowerErrors>
            }

            break;
    5f10:	e006      	b.n	5f20 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5f12:	2301      	movs	r3, #1
    5f14:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    5f16:	e004      	b.n	5f22 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5f18:	bf00      	nop
    5f1a:	e002      	b.n	5f22 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5f1c:	bf00      	nop
    5f1e:	e000      	b.n	5f22 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5f20:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    5f22:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5f24:	4618      	mov	r0, r3
    5f26:	b00b      	add	sp, #44	; 0x2c
    5f28:	f85d fb04 	ldr.w	pc, [sp], #4
    5f2c:	4007e000 	.word	0x4007e000

00005f30 <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    5f30:	b500      	push	{lr}
    5f32:	b085      	sub	sp, #20
    5f34:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    5f36:	9b01      	ldr	r3, [sp, #4]
    5f38:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    5f3a:	9803      	ldr	r0, [sp, #12]
    5f3c:	f000 fbc8 	bl	66d0 <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    5f40:	4a03      	ldr	r2, [pc, #12]	; (5f50 <Port_Init+0x20>)
    5f42:	9b03      	ldr	r3, [sp, #12]
    5f44:	6013      	str	r3, [r2, #0]
        }
    }
}
    5f46:	bf00      	nop
    5f48:	b005      	add	sp, #20
    5f4a:	f85d fb04 	ldr.w	pc, [sp], #4
    5f4e:	bf00      	nop
    5f50:	1fff8cf4 	.word	0x1fff8cf4

00005f54 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    5f54:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    5f56:	4b03      	ldr	r3, [pc, #12]	; (5f64 <Port_RefreshPortDirection+0x10>)
    5f58:	681b      	ldr	r3, [r3, #0]
    5f5a:	4618      	mov	r0, r3
    5f5c:	f000 fc10 	bl	6780 <Port_Ipw_RefreshPortDirection>
    }
}
    5f60:	bf00      	nop
    5f62:	bd08      	pop	{r3, pc}
    5f64:	1fff8cf4 	.word	0x1fff8cf4

00005f68 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    5f68:	b086      	sub	sp, #24
    5f6a:	9003      	str	r0, [sp, #12]
    5f6c:	9102      	str	r1, [sp, #8]
    5f6e:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    5f70:	23ff      	movs	r3, #255	; 0xff
    5f72:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    5f74:	9b03      	ldr	r3, [sp, #12]
    5f76:	4a39      	ldr	r2, [pc, #228]	; (605c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    5f78:	4293      	cmp	r3, r2
    5f7a:	d151      	bne.n	6020 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    5f7c:	9b02      	ldr	r3, [sp, #8]
    5f7e:	2b10      	cmp	r3, #16
    5f80:	d867      	bhi.n	6052 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    5f82:	a201      	add	r2, pc, #4	; (adr r2, 5f88 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    5f84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5f88:	00005fcd 	.word	0x00005fcd
    5f8c:	00005fdb 	.word	0x00005fdb
    5f90:	00006053 	.word	0x00006053
    5f94:	00006053 	.word	0x00006053
    5f98:	00006053 	.word	0x00006053
    5f9c:	00006053 	.word	0x00006053
    5fa0:	00006053 	.word	0x00006053
    5fa4:	00006053 	.word	0x00006053
    5fa8:	00006053 	.word	0x00006053
    5fac:	00006053 	.word	0x00006053
    5fb0:	00006053 	.word	0x00006053
    5fb4:	00006053 	.word	0x00006053
    5fb8:	00006053 	.word	0x00006053
    5fbc:	00005fe9 	.word	0x00005fe9
    5fc0:	00005ff7 	.word	0x00005ff7
    5fc4:	00006005 	.word	0x00006005
    5fc8:	00006013 	.word	0x00006013
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    5fcc:	2301      	movs	r3, #1
    5fce:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5fd0:	9a05      	ldr	r2, [sp, #20]
    5fd2:	9b01      	ldr	r3, [sp, #4]
    5fd4:	4313      	orrs	r3, r2
    5fd6:	9305      	str	r3, [sp, #20]
                break;
    5fd8:	e03c      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    5fda:	2302      	movs	r3, #2
    5fdc:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5fde:	9a05      	ldr	r2, [sp, #20]
    5fe0:	9b01      	ldr	r3, [sp, #4]
    5fe2:	4313      	orrs	r3, r2
    5fe4:	9305      	str	r3, [sp, #20]
                break;
    5fe6:	e035      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    5fe8:	2304      	movs	r3, #4
    5fea:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5fec:	9a05      	ldr	r2, [sp, #20]
    5fee:	9b01      	ldr	r3, [sp, #4]
    5ff0:	4313      	orrs	r3, r2
    5ff2:	9305      	str	r3, [sp, #20]
                break;
    5ff4:	e02e      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    5ff6:	2308      	movs	r3, #8
    5ff8:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    5ffa:	9a05      	ldr	r2, [sp, #20]
    5ffc:	9b01      	ldr	r3, [sp, #4]
    5ffe:	4313      	orrs	r3, r2
    6000:	9305      	str	r3, [sp, #20]
                break;
    6002:	e027      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    6004:	230e      	movs	r3, #14
    6006:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6008:	9a05      	ldr	r2, [sp, #20]
    600a:	9b01      	ldr	r3, [sp, #4]
    600c:	4013      	ands	r3, r2
    600e:	9305      	str	r3, [sp, #20]
                break;
    6010:	e020      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    6012:	230d      	movs	r3, #13
    6014:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6016:	9a05      	ldr	r2, [sp, #20]
    6018:	9b01      	ldr	r3, [sp, #4]
    601a:	4013      	ands	r3, r2
    601c:	9305      	str	r3, [sp, #20]
                break;
    601e:	e019      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    6020:	9b03      	ldr	r3, [sp, #12]
    6022:	4a0f      	ldr	r2, [pc, #60]	; (6060 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    6024:	4293      	cmp	r3, r2
    6026:	d115      	bne.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    6028:	9b02      	ldr	r3, [sp, #8]
    602a:	2b00      	cmp	r3, #0
    602c:	d003      	beq.n	6036 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    602e:	9b02      	ldr	r3, [sp, #8]
    6030:	2b01      	cmp	r3, #1
    6032:	d007      	beq.n	6044 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    6034:	e00e      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    6036:	230b      	movs	r3, #11
    6038:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    603a:	9a05      	ldr	r2, [sp, #20]
    603c:	9b01      	ldr	r3, [sp, #4]
    603e:	4013      	ands	r3, r2
    6040:	9305      	str	r3, [sp, #20]
                break;
    6042:	e007      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    6044:	2307      	movs	r3, #7
    6046:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6048:	9a05      	ldr	r2, [sp, #20]
    604a:	9b01      	ldr	r3, [sp, #4]
    604c:	4013      	ands	r3, r2
    604e:	9305      	str	r3, [sp, #20]
                break;
    6050:	e000      	b.n	6054 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    6052:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    6054:	9b05      	ldr	r3, [sp, #20]
}
    6056:	4618      	mov	r0, r3
    6058:	b006      	add	sp, #24
    605a:	4770      	bx	lr
    605c:	4004a000 	.word	0x4004a000
    6060:	4004b000 	.word	0x4004b000

00006064 <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    6064:	b500      	push	{lr}
    6066:	b089      	sub	sp, #36	; 0x24
    6068:	9003      	str	r0, [sp, #12]
    606a:	9102      	str	r1, [sp, #8]
    606c:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    606e:	9b01      	ldr	r3, [sp, #4]
    6070:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    6072:	9b01      	ldr	r3, [sp, #4]
    6074:	2b08      	cmp	r3, #8
    6076:	d121      	bne.n	60bc <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    6078:	4b13      	ldr	r3, [pc, #76]	; (60c8 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    607a:	685b      	ldr	r3, [r3, #4]
    607c:	f003 030f 	and.w	r3, r3, #15
    6080:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    6082:	9a06      	ldr	r2, [sp, #24]
    6084:	9902      	ldr	r1, [sp, #8]
    6086:	9803      	ldr	r0, [sp, #12]
    6088:	f7ff ff6e 	bl	5f68 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    608c:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    608e:	9b05      	ldr	r3, [sp, #20]
    6090:	2bff      	cmp	r3, #255	; 0xff
    6092:	d011      	beq.n	60b8 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    6094:	f002 fd38 	bl	8b08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    6098:	4b0b      	ldr	r3, [pc, #44]	; (60c8 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    609a:	685b      	ldr	r3, [r3, #4]
    609c:	4a0a      	ldr	r2, [pc, #40]	; (60c8 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    609e:	f023 030f 	bic.w	r3, r3, #15
    60a2:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    60a4:	4b08      	ldr	r3, [pc, #32]	; (60c8 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    60a6:	685a      	ldr	r2, [r3, #4]
    60a8:	9b05      	ldr	r3, [sp, #20]
    60aa:	f003 030f 	and.w	r3, r3, #15
    60ae:	4906      	ldr	r1, [pc, #24]	; (60c8 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    60b0:	4313      	orrs	r3, r2
    60b2:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    60b4:	f002 fd54 	bl	8b60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    60b8:	2300      	movs	r3, #0
    60ba:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    60bc:	9b07      	ldr	r3, [sp, #28]
}
    60be:	4618      	mov	r0, r3
    60c0:	b009      	add	sp, #36	; 0x24
    60c2:	f85d fb04 	ldr.w	pc, [sp], #4
    60c6:	bf00      	nop
    60c8:	40048000 	.word	0x40048000

000060cc <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    60cc:	b500      	push	{lr}
    60ce:	b087      	sub	sp, #28
    60d0:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    60d2:	2300      	movs	r3, #0
    60d4:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    60d6:	2300      	movs	r3, #0
    60d8:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    60da:	2300      	movs	r3, #0
    60dc:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    60de:	9b01      	ldr	r3, [sp, #4]
    60e0:	68db      	ldr	r3, [r3, #12]
    60e2:	2b02      	cmp	r3, #2
    60e4:	d00a      	beq.n	60fc <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    60e6:	9b05      	ldr	r3, [sp, #20]
    60e8:	f043 0302 	orr.w	r3, r3, #2
    60ec:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    60ee:	9b01      	ldr	r3, [sp, #4]
    60f0:	68db      	ldr	r3, [r3, #12]
    60f2:	f003 0301 	and.w	r3, r3, #1
    60f6:	9a05      	ldr	r2, [sp, #20]
    60f8:	4313      	orrs	r3, r2
    60fa:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    60fc:	9b01      	ldr	r3, [sp, #4]
    60fe:	699b      	ldr	r3, [r3, #24]
    6100:	019b      	lsls	r3, r3, #6
    6102:	f003 0340 	and.w	r3, r3, #64	; 0x40
    6106:	9a05      	ldr	r2, [sp, #20]
    6108:	4313      	orrs	r3, r2
    610a:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    610c:	9b01      	ldr	r3, [sp, #4]
    610e:	6a1b      	ldr	r3, [r3, #32]
    6110:	03db      	lsls	r3, r3, #15
    6112:	b29b      	uxth	r3, r3
    6114:	9a05      	ldr	r2, [sp, #20]
    6116:	4313      	orrs	r3, r2
    6118:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    611a:	9b01      	ldr	r3, [sp, #4]
    611c:	7f1b      	ldrb	r3, [r3, #28]
    611e:	2b00      	cmp	r3, #0
    6120:	d001      	beq.n	6126 <Port_Ci_Port_Ip_PinInit+0x5a>
    6122:	2310      	movs	r3, #16
    6124:	e000      	b.n	6128 <Port_Ci_Port_Ip_PinInit+0x5c>
    6126:	2300      	movs	r3, #0
    6128:	9a05      	ldr	r2, [sp, #20]
    612a:	4313      	orrs	r3, r2
    612c:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    612e:	9b01      	ldr	r3, [sp, #4]
    6130:	691b      	ldr	r3, [r3, #16]
    6132:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    6134:	9b01      	ldr	r3, [sp, #4]
    6136:	6818      	ldr	r0, [r3, #0]
    6138:	9b01      	ldr	r3, [sp, #4]
    613a:	689b      	ldr	r3, [r3, #8]
    613c:	9a04      	ldr	r2, [sp, #16]
    613e:	4619      	mov	r1, r3
    6140:	f7ff ff90 	bl	6064 <Port_Ci_Port_Ip_ConfigureInterleave>
    6144:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    6146:	9b03      	ldr	r3, [sp, #12]
    6148:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    614a:	9b04      	ldr	r3, [sp, #16]
    614c:	021b      	lsls	r3, r3, #8
    614e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    6152:	9a05      	ldr	r2, [sp, #20]
    6154:	4313      	orrs	r3, r2
    6156:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    6158:	f002 fb3c 	bl	87d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    615c:	9b01      	ldr	r3, [sp, #4]
    615e:	681b      	ldr	r3, [r3, #0]
    6160:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    6164:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    6166:	9b01      	ldr	r3, [sp, #4]
    6168:	689b      	ldr	r3, [r3, #8]
    616a:	2201      	movs	r2, #1
    616c:	fa02 f303 	lsl.w	r3, r2, r3
    6170:	43db      	mvns	r3, r3
    6172:	9a02      	ldr	r2, [sp, #8]
    6174:	4013      	ands	r3, r2
    6176:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    6178:	9b01      	ldr	r3, [sp, #4]
    617a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    617e:	2b00      	cmp	r3, #0
    6180:	d001      	beq.n	6186 <Port_Ci_Port_Ip_PinInit+0xba>
    6182:	2201      	movs	r2, #1
    6184:	e000      	b.n	6188 <Port_Ci_Port_Ip_PinInit+0xbc>
    6186:	2200      	movs	r2, #0
    6188:	9b01      	ldr	r3, [sp, #4]
    618a:	689b      	ldr	r3, [r3, #8]
    618c:	fa02 f303 	lsl.w	r3, r2, r3
    6190:	9a02      	ldr	r2, [sp, #8]
    6192:	4313      	orrs	r3, r2
    6194:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    6196:	9b01      	ldr	r3, [sp, #4]
    6198:	681b      	ldr	r3, [r3, #0]
    619a:	9a02      	ldr	r2, [sp, #8]
    619c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    61a0:	f002 fb44 	bl	882c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    61a4:	9b04      	ldr	r3, [sp, #16]
    61a6:	2b01      	cmp	r3, #1
    61a8:	d16d      	bne.n	6286 <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    61aa:	9b01      	ldr	r3, [sp, #4]
    61ac:	695b      	ldr	r3, [r3, #20]
    61ae:	2b02      	cmp	r3, #2
    61b0:	d138      	bne.n	6224 <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    61b2:	9b01      	ldr	r3, [sp, #4]
    61b4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    61b8:	2b01      	cmp	r3, #1
    61ba:	d10f      	bne.n	61dc <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    61bc:	f002 fb5c 	bl	8878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    61c0:	9b01      	ldr	r3, [sp, #4]
    61c2:	685b      	ldr	r3, [r3, #4]
    61c4:	6859      	ldr	r1, [r3, #4]
    61c6:	9b01      	ldr	r3, [sp, #4]
    61c8:	689b      	ldr	r3, [r3, #8]
    61ca:	2201      	movs	r2, #1
    61cc:	409a      	lsls	r2, r3
    61ce:	9b01      	ldr	r3, [sp, #4]
    61d0:	685b      	ldr	r3, [r3, #4]
    61d2:	430a      	orrs	r2, r1
    61d4:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    61d6:	f002 fb7b 	bl	88d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    61da:	e013      	b.n	6204 <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    61dc:	9b01      	ldr	r3, [sp, #4]
    61de:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    61e2:	2b00      	cmp	r3, #0
    61e4:	d10e      	bne.n	6204 <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    61e6:	f002 fb99 	bl	891c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    61ea:	9b01      	ldr	r3, [sp, #4]
    61ec:	685b      	ldr	r3, [r3, #4]
    61ee:	6899      	ldr	r1, [r3, #8]
    61f0:	9b01      	ldr	r3, [sp, #4]
    61f2:	689b      	ldr	r3, [r3, #8]
    61f4:	2201      	movs	r2, #1
    61f6:	409a      	lsls	r2, r3
    61f8:	9b01      	ldr	r3, [sp, #4]
    61fa:	685b      	ldr	r3, [r3, #4]
    61fc:	430a      	orrs	r2, r1
    61fe:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    6200:	f002 fbb8 	bl	8974 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    6204:	f002 fbdc 	bl	89c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    6208:	9b01      	ldr	r3, [sp, #4]
    620a:	685b      	ldr	r3, [r3, #4]
    620c:	6959      	ldr	r1, [r3, #20]
    620e:	9b01      	ldr	r3, [sp, #4]
    6210:	689b      	ldr	r3, [r3, #8]
    6212:	2201      	movs	r2, #1
    6214:	409a      	lsls	r2, r3
    6216:	9b01      	ldr	r3, [sp, #4]
    6218:	685b      	ldr	r3, [r3, #4]
    621a:	430a      	orrs	r2, r1
    621c:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    621e:	f002 fbfb 	bl	8a18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    6222:	e030      	b.n	6286 <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    6224:	f002 fbcc 	bl	89c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    6228:	9b01      	ldr	r3, [sp, #4]
    622a:	685b      	ldr	r3, [r3, #4]
    622c:	6959      	ldr	r1, [r3, #20]
    622e:	9b01      	ldr	r3, [sp, #4]
    6230:	689b      	ldr	r3, [r3, #8]
    6232:	2201      	movs	r2, #1
    6234:	fa02 f303 	lsl.w	r3, r2, r3
    6238:	43da      	mvns	r2, r3
    623a:	9b01      	ldr	r3, [sp, #4]
    623c:	685b      	ldr	r3, [r3, #4]
    623e:	400a      	ands	r2, r1
    6240:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    6242:	f002 fbe9 	bl	8a18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    6246:	f002 fc0d 	bl	8a64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    624a:	9b01      	ldr	r3, [sp, #4]
    624c:	685b      	ldr	r3, [r3, #4]
    624e:	6999      	ldr	r1, [r3, #24]
    6250:	9b01      	ldr	r3, [sp, #4]
    6252:	689b      	ldr	r3, [r3, #8]
    6254:	2201      	movs	r2, #1
    6256:	fa02 f303 	lsl.w	r3, r2, r3
    625a:	43da      	mvns	r2, r3
    625c:	9b01      	ldr	r3, [sp, #4]
    625e:	685b      	ldr	r3, [r3, #4]
    6260:	400a      	ands	r2, r1
    6262:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    6264:	9b01      	ldr	r3, [sp, #4]
    6266:	695b      	ldr	r3, [r3, #20]
    6268:	2b03      	cmp	r3, #3
    626a:	d10a      	bne.n	6282 <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    626c:	9b01      	ldr	r3, [sp, #4]
    626e:	685b      	ldr	r3, [r3, #4]
    6270:	6999      	ldr	r1, [r3, #24]
    6272:	9b01      	ldr	r3, [sp, #4]
    6274:	689b      	ldr	r3, [r3, #8]
    6276:	2201      	movs	r2, #1
    6278:	409a      	lsls	r2, r3
    627a:	9b01      	ldr	r3, [sp, #4]
    627c:	685b      	ldr	r3, [r3, #4]
    627e:	430a      	orrs	r2, r1
    6280:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    6282:	f002 fc1b 	bl	8abc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    6286:	9b01      	ldr	r3, [sp, #4]
    6288:	681b      	ldr	r3, [r3, #0]
    628a:	9a01      	ldr	r2, [sp, #4]
    628c:	6892      	ldr	r2, [r2, #8]
    628e:	9905      	ldr	r1, [sp, #20]
    6290:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6294:	bf00      	nop
    6296:	b007      	add	sp, #28
    6298:	f85d fb04 	ldr.w	pc, [sp], #4

0000629c <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    629c:	b500      	push	{lr}
    629e:	b085      	sub	sp, #20
    62a0:	9001      	str	r0, [sp, #4]
    62a2:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    62a4:	2300      	movs	r3, #0
    62a6:	9303      	str	r3, [sp, #12]
    62a8:	e00d      	b.n	62c6 <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    62aa:	9a03      	ldr	r2, [sp, #12]
    62ac:	4613      	mov	r3, r2
    62ae:	009b      	lsls	r3, r3, #2
    62b0:	4413      	add	r3, r2
    62b2:	00db      	lsls	r3, r3, #3
    62b4:	461a      	mov	r2, r3
    62b6:	9b00      	ldr	r3, [sp, #0]
    62b8:	4413      	add	r3, r2
    62ba:	4618      	mov	r0, r3
    62bc:	f7ff ff06 	bl	60cc <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    62c0:	9b03      	ldr	r3, [sp, #12]
    62c2:	3301      	adds	r3, #1
    62c4:	9303      	str	r3, [sp, #12]
    62c6:	9a03      	ldr	r2, [sp, #12]
    62c8:	9b01      	ldr	r3, [sp, #4]
    62ca:	429a      	cmp	r2, r3
    62cc:	d3ed      	bcc.n	62aa <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    62ce:	2300      	movs	r3, #0
}
    62d0:	4618      	mov	r0, r3
    62d2:	b005      	add	sp, #20
    62d4:	f85d fb04 	ldr.w	pc, [sp], #4

000062d8 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    62d8:	b500      	push	{lr}
    62da:	b087      	sub	sp, #28
    62dc:	9003      	str	r0, [sp, #12]
    62de:	9102      	str	r1, [sp, #8]
    62e0:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    62e2:	9a01      	ldr	r2, [sp, #4]
    62e4:	9902      	ldr	r1, [sp, #8]
    62e6:	9803      	ldr	r0, [sp, #12]
    62e8:	f7ff febc 	bl	6064 <Port_Ci_Port_Ip_ConfigureInterleave>
    62ec:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    62ee:	f002 fc5d 	bl	8bac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    62f2:	9b03      	ldr	r3, [sp, #12]
    62f4:	9a02      	ldr	r2, [sp, #8]
    62f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    62fa:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    62fc:	9b04      	ldr	r3, [sp, #16]
    62fe:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    6302:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    6304:	9b05      	ldr	r3, [sp, #20]
    6306:	021b      	lsls	r3, r3, #8
    6308:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    630c:	9a04      	ldr	r2, [sp, #16]
    630e:	4313      	orrs	r3, r2
    6310:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    6312:	9b03      	ldr	r3, [sp, #12]
    6314:	9a02      	ldr	r2, [sp, #8]
    6316:	9904      	ldr	r1, [sp, #16]
    6318:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    631c:	f002 fc72 	bl	8c04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    6320:	bf00      	nop
    6322:	b007      	add	sp, #28
    6324:	f85d fb04 	ldr.w	pc, [sp], #4

00006328 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6328:	b500      	push	{lr}
    632a:	b083      	sub	sp, #12
    632c:	9001      	str	r0, [sp, #4]
    632e:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    6330:	f002 fc8e 	bl	8c50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    6334:	9b01      	ldr	r3, [sp, #4]
    6336:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    633a:	2101      	movs	r1, #1
    633c:	9b00      	ldr	r3, [sp, #0]
    633e:	fa01 f303 	lsl.w	r3, r1, r3
    6342:	431a      	orrs	r2, r3
    6344:	9b01      	ldr	r3, [sp, #4]
    6346:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    634a:	f002 fcad 	bl	8ca8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    634e:	bf00      	nop
    6350:	b003      	add	sp, #12
    6352:	f85d fb04 	ldr.w	pc, [sp], #4

00006356 <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6356:	b500      	push	{lr}
    6358:	b083      	sub	sp, #12
    635a:	9001      	str	r0, [sp, #4]
    635c:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    635e:	f002 fcc9 	bl	8cf4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    6362:	9b01      	ldr	r3, [sp, #4]
    6364:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6368:	2101      	movs	r1, #1
    636a:	9b00      	ldr	r3, [sp, #0]
    636c:	fa01 f303 	lsl.w	r3, r1, r3
    6370:	43db      	mvns	r3, r3
    6372:	401a      	ands	r2, r3
    6374:	9b01      	ldr	r3, [sp, #4]
    6376:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    637a:	f002 fce7 	bl	8d4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    637e:	bf00      	nop
    6380:	b003      	add	sp, #12
    6382:	f85d fb04 	ldr.w	pc, [sp], #4

00006386 <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    6386:	b082      	sub	sp, #8
    6388:	9001      	str	r0, [sp, #4]
    638a:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    638c:	9b00      	ldr	r3, [sp, #0]
    638e:	785b      	ldrb	r3, [r3, #1]
    6390:	f003 0201 	and.w	r2, r3, #1
    6394:	9b01      	ldr	r3, [sp, #4]
    6396:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    639a:	9b00      	ldr	r3, [sp, #0]
    639c:	789b      	ldrb	r3, [r3, #2]
    639e:	f003 021f 	and.w	r2, r3, #31
    63a2:	9b01      	ldr	r3, [sp, #4]
    63a4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    63a8:	bf00      	nop
    63aa:	b002      	add	sp, #8
    63ac:	4770      	bx	lr

000063ae <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    63ae:	b086      	sub	sp, #24
    63b0:	9003      	str	r0, [sp, #12]
    63b2:	9301      	str	r3, [sp, #4]
    63b4:	460b      	mov	r3, r1
    63b6:	f8ad 300a 	strh.w	r3, [sp, #10]
    63ba:	4613      	mov	r3, r2
    63bc:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    63c0:	2300      	movs	r3, #0
    63c2:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    63c6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    63ca:	f043 0301 	orr.w	r3, r3, #1
    63ce:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    63d2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    63d6:	f043 0302 	orr.w	r3, r3, #2
    63da:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    63de:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    63e2:	f043 0310 	orr.w	r3, r3, #16
    63e6:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    63ea:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    63ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    63f2:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    63f6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    63fa:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    63fe:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    6402:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6406:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    640a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    640e:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    6412:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6416:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    641a:	4013      	ands	r3, r2
    641c:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    6420:	9b01      	ldr	r3, [sp, #4]
    6422:	2b00      	cmp	r3, #0
    6424:	d003      	beq.n	642e <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    6426:	9b01      	ldr	r3, [sp, #4]
    6428:	2b01      	cmp	r3, #1
    642a:	d00a      	beq.n	6442 <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    642c:	e013      	b.n	6456 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    642e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6432:	041a      	lsls	r2, r3, #16
    6434:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6438:	431a      	orrs	r2, r3
    643a:	9b03      	ldr	r3, [sp, #12]
    643c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    6440:	e009      	b.n	6456 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    6442:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6446:	041a      	lsls	r2, r3, #16
    6448:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    644c:	431a      	orrs	r2, r3
    644e:	9b03      	ldr	r3, [sp, #12]
    6450:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    6454:	bf00      	nop
    }
}
    6456:	bf00      	nop
    6458:	b006      	add	sp, #24
    645a:	4770      	bx	lr

0000645c <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    645c:	b500      	push	{lr}
    645e:	b087      	sub	sp, #28
    6460:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    6462:	9b01      	ldr	r3, [sp, #4]
    6464:	885b      	ldrh	r3, [r3, #2]
    6466:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    646a:	9b01      	ldr	r3, [sp, #4]
    646c:	689b      	ldr	r3, [r3, #8]
    646e:	7a1b      	ldrb	r3, [r3, #8]
    6470:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    6474:	9b01      	ldr	r3, [sp, #4]
    6476:	689b      	ldr	r3, [r3, #8]
    6478:	681b      	ldr	r3, [r3, #0]
    647a:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    647c:	9b01      	ldr	r3, [sp, #4]
    647e:	689b      	ldr	r3, [r3, #8]
    6480:	685b      	ldr	r3, [r3, #4]
    6482:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6484:	2300      	movs	r3, #0
    6486:	f8ad 3016 	strh.w	r3, [sp, #22]
    648a:	e111      	b.n	66b0 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    648c:	9b02      	ldr	r3, [sp, #8]
    648e:	2b02      	cmp	r3, #2
    6490:	d169      	bne.n	6566 <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    6492:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6496:	2b01      	cmp	r3, #1
    6498:	d11a      	bne.n	64d0 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    649a:	9b01      	ldr	r3, [sp, #4]
    649c:	685a      	ldr	r2, [r3, #4]
    649e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    64a2:	005b      	lsls	r3, r3, #1
    64a4:	4413      	add	r3, r2
    64a6:	881b      	ldrh	r3, [r3, #0]
    64a8:	f003 021f 	and.w	r2, r3, #31
    64ac:	9b01      	ldr	r3, [sp, #4]
    64ae:	6859      	ldr	r1, [r3, #4]
    64b0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    64b4:	005b      	lsls	r3, r3, #1
    64b6:	440b      	add	r3, r1
    64b8:	881b      	ldrh	r3, [r3, #0]
    64ba:	095b      	lsrs	r3, r3, #5
    64bc:	b29b      	uxth	r3, r3
    64be:	4619      	mov	r1, r3
    64c0:	4b81      	ldr	r3, [pc, #516]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    64c2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    64c6:	2101      	movs	r1, #1
    64c8:	fa01 f202 	lsl.w	r2, r1, r2
    64cc:	605a      	str	r2, [r3, #4]
    64ce:	e01d      	b.n	650c <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    64d0:	f89d 3013 	ldrb.w	r3, [sp, #19]
    64d4:	2b00      	cmp	r3, #0
    64d6:	d119      	bne.n	650c <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    64d8:	9b01      	ldr	r3, [sp, #4]
    64da:	685a      	ldr	r2, [r3, #4]
    64dc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    64e0:	005b      	lsls	r3, r3, #1
    64e2:	4413      	add	r3, r2
    64e4:	881b      	ldrh	r3, [r3, #0]
    64e6:	f003 021f 	and.w	r2, r3, #31
    64ea:	9b01      	ldr	r3, [sp, #4]
    64ec:	6859      	ldr	r1, [r3, #4]
    64ee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    64f2:	005b      	lsls	r3, r3, #1
    64f4:	440b      	add	r3, r1
    64f6:	881b      	ldrh	r3, [r3, #0]
    64f8:	095b      	lsrs	r3, r3, #5
    64fa:	b29b      	uxth	r3, r3
    64fc:	4619      	mov	r1, r3
    64fe:	4b72      	ldr	r3, [pc, #456]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6500:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6504:	2101      	movs	r1, #1
    6506:	fa01 f202 	lsl.w	r2, r1, r2
    650a:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    650c:	f002 fc44 	bl	8d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6510:	9b01      	ldr	r3, [sp, #4]
    6512:	685a      	ldr	r2, [r3, #4]
    6514:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6518:	005b      	lsls	r3, r3, #1
    651a:	4413      	add	r3, r2
    651c:	881b      	ldrh	r3, [r3, #0]
    651e:	095b      	lsrs	r3, r3, #5
    6520:	b29b      	uxth	r3, r3
    6522:	461a      	mov	r2, r3
    6524:	4b68      	ldr	r3, [pc, #416]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6526:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    652a:	6959      	ldr	r1, [r3, #20]
    652c:	9b01      	ldr	r3, [sp, #4]
    652e:	685a      	ldr	r2, [r3, #4]
    6530:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6534:	005b      	lsls	r3, r3, #1
    6536:	4413      	add	r3, r2
    6538:	881b      	ldrh	r3, [r3, #0]
    653a:	f003 031f 	and.w	r3, r3, #31
    653e:	2201      	movs	r2, #1
    6540:	409a      	lsls	r2, r3
    6542:	9b01      	ldr	r3, [sp, #4]
    6544:	6858      	ldr	r0, [r3, #4]
    6546:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    654a:	005b      	lsls	r3, r3, #1
    654c:	4403      	add	r3, r0
    654e:	881b      	ldrh	r3, [r3, #0]
    6550:	095b      	lsrs	r3, r3, #5
    6552:	b29b      	uxth	r3, r3
    6554:	4618      	mov	r0, r3
    6556:	4b5c      	ldr	r3, [pc, #368]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6558:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    655c:	430a      	orrs	r2, r1
    655e:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6560:	f002 fc46 	bl	8df0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    6564:	e086      	b.n	6674 <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6566:	f002 fc17 	bl	8d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    656a:	9b01      	ldr	r3, [sp, #4]
    656c:	685a      	ldr	r2, [r3, #4]
    656e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6572:	005b      	lsls	r3, r3, #1
    6574:	4413      	add	r3, r2
    6576:	881b      	ldrh	r3, [r3, #0]
    6578:	095b      	lsrs	r3, r3, #5
    657a:	b29b      	uxth	r3, r3
    657c:	461a      	mov	r2, r3
    657e:	4b52      	ldr	r3, [pc, #328]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6580:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6584:	6959      	ldr	r1, [r3, #20]
    6586:	9b01      	ldr	r3, [sp, #4]
    6588:	685a      	ldr	r2, [r3, #4]
    658a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    658e:	005b      	lsls	r3, r3, #1
    6590:	4413      	add	r3, r2
    6592:	881b      	ldrh	r3, [r3, #0]
    6594:	f003 031f 	and.w	r3, r3, #31
    6598:	2201      	movs	r2, #1
    659a:	fa02 f303 	lsl.w	r3, r2, r3
    659e:	43da      	mvns	r2, r3
    65a0:	9b01      	ldr	r3, [sp, #4]
    65a2:	6858      	ldr	r0, [r3, #4]
    65a4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    65a8:	005b      	lsls	r3, r3, #1
    65aa:	4403      	add	r3, r0
    65ac:	881b      	ldrh	r3, [r3, #0]
    65ae:	095b      	lsrs	r3, r3, #5
    65b0:	b29b      	uxth	r3, r3
    65b2:	4618      	mov	r0, r3
    65b4:	4b44      	ldr	r3, [pc, #272]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    65b6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    65ba:	400a      	ands	r2, r1
    65bc:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    65be:	f002 fc17 	bl	8df0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    65c2:	f002 fc3b 	bl	8e3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    65c6:	9b01      	ldr	r3, [sp, #4]
    65c8:	685a      	ldr	r2, [r3, #4]
    65ca:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    65ce:	005b      	lsls	r3, r3, #1
    65d0:	4413      	add	r3, r2
    65d2:	881b      	ldrh	r3, [r3, #0]
    65d4:	095b      	lsrs	r3, r3, #5
    65d6:	b29b      	uxth	r3, r3
    65d8:	461a      	mov	r2, r3
    65da:	4b3b      	ldr	r3, [pc, #236]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    65dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    65e0:	6999      	ldr	r1, [r3, #24]
    65e2:	9b01      	ldr	r3, [sp, #4]
    65e4:	685a      	ldr	r2, [r3, #4]
    65e6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    65ea:	005b      	lsls	r3, r3, #1
    65ec:	4413      	add	r3, r2
    65ee:	881b      	ldrh	r3, [r3, #0]
    65f0:	f003 031f 	and.w	r3, r3, #31
    65f4:	2201      	movs	r2, #1
    65f6:	fa02 f303 	lsl.w	r3, r2, r3
    65fa:	43da      	mvns	r2, r3
    65fc:	9b01      	ldr	r3, [sp, #4]
    65fe:	6858      	ldr	r0, [r3, #4]
    6600:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6604:	005b      	lsls	r3, r3, #1
    6606:	4403      	add	r3, r0
    6608:	881b      	ldrh	r3, [r3, #0]
    660a:	095b      	lsrs	r3, r3, #5
    660c:	b29b      	uxth	r3, r3
    660e:	4618      	mov	r0, r3
    6610:	4b2d      	ldr	r3, [pc, #180]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6612:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6616:	400a      	ands	r2, r1
    6618:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    661a:	9b02      	ldr	r3, [sp, #8]
    661c:	2b03      	cmp	r3, #3
    661e:	d127      	bne.n	6670 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6620:	9b01      	ldr	r3, [sp, #4]
    6622:	685a      	ldr	r2, [r3, #4]
    6624:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6628:	005b      	lsls	r3, r3, #1
    662a:	4413      	add	r3, r2
    662c:	881b      	ldrh	r3, [r3, #0]
    662e:	095b      	lsrs	r3, r3, #5
    6630:	b29b      	uxth	r3, r3
    6632:	461a      	mov	r2, r3
    6634:	4b24      	ldr	r3, [pc, #144]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6636:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    663a:	6999      	ldr	r1, [r3, #24]
    663c:	9b01      	ldr	r3, [sp, #4]
    663e:	685a      	ldr	r2, [r3, #4]
    6640:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6644:	005b      	lsls	r3, r3, #1
    6646:	4413      	add	r3, r2
    6648:	881b      	ldrh	r3, [r3, #0]
    664a:	f003 031f 	and.w	r3, r3, #31
    664e:	2201      	movs	r2, #1
    6650:	409a      	lsls	r2, r3
    6652:	9b01      	ldr	r3, [sp, #4]
    6654:	6858      	ldr	r0, [r3, #4]
    6656:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    665a:	005b      	lsls	r3, r3, #1
    665c:	4403      	add	r3, r0
    665e:	881b      	ldrh	r3, [r3, #0]
    6660:	095b      	lsrs	r3, r3, #5
    6662:	b29b      	uxth	r3, r3
    6664:	4618      	mov	r0, r3
    6666:	4b18      	ldr	r3, [pc, #96]	; (66c8 <Port_Ipw_Init_UnusedPins+0x26c>)
    6668:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    666c:	430a      	orrs	r2, r1
    666e:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    6670:	f002 fc10 	bl	8e94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    6674:	9b01      	ldr	r3, [sp, #4]
    6676:	685a      	ldr	r2, [r3, #4]
    6678:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    667c:	005b      	lsls	r3, r3, #1
    667e:	4413      	add	r3, r2
    6680:	881b      	ldrh	r3, [r3, #0]
    6682:	095b      	lsrs	r3, r3, #5
    6684:	b29b      	uxth	r3, r3
    6686:	461a      	mov	r2, r3
    6688:	4b10      	ldr	r3, [pc, #64]	; (66cc <Port_Ipw_Init_UnusedPins+0x270>)
    668a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    668e:	9a01      	ldr	r2, [sp, #4]
    6690:	6851      	ldr	r1, [r2, #4]
    6692:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6696:	0052      	lsls	r2, r2, #1
    6698:	440a      	add	r2, r1
    669a:	8812      	ldrh	r2, [r2, #0]
    669c:	f002 021f 	and.w	r2, r2, #31
    66a0:	9903      	ldr	r1, [sp, #12]
    66a2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    66a6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    66aa:	3301      	adds	r3, #1
    66ac:	f8ad 3016 	strh.w	r3, [sp, #22]
    66b0:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    66b4:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    66b8:	429a      	cmp	r2, r3
    66ba:	f4ff aee7 	bcc.w	648c <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    66be:	bf00      	nop
    66c0:	bf00      	nop
    66c2:	b007      	add	sp, #28
    66c4:	f85d fb04 	ldr.w	pc, [sp], #4
    66c8:	0000ae3c 	.word	0x0000ae3c
    66cc:	0000ae28 	.word	0x0000ae28

000066d0 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    66d0:	b500      	push	{lr}
    66d2:	b085      	sub	sp, #20
    66d4:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    66d6:	9b01      	ldr	r3, [sp, #4]
    66d8:	7c1b      	ldrb	r3, [r3, #16]
    66da:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    66de:	2300      	movs	r3, #0
    66e0:	f8ad 300e 	strh.w	r3, [sp, #14]
    66e4:	e035      	b.n	6752 <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    66e6:	9b01      	ldr	r3, [sp, #4]
    66e8:	695a      	ldr	r2, [r3, #20]
    66ea:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    66ee:	00db      	lsls	r3, r3, #3
    66f0:	4413      	add	r3, r2
    66f2:	781b      	ldrb	r3, [r3, #0]
    66f4:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    66f8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    66fc:	4a1f      	ldr	r2, [pc, #124]	; (677c <Port_Ipw_Init+0xac>)
    66fe:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6702:	9b01      	ldr	r3, [sp, #4]
    6704:	695a      	ldr	r2, [r3, #20]
    6706:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    670a:	00db      	lsls	r3, r3, #3
    670c:	4413      	add	r3, r2
    670e:	4619      	mov	r1, r3
    6710:	f7ff fe39 	bl	6386 <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    6714:	f002 fd2c 	bl	9170 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    6718:	f89d 300c 	ldrb.w	r3, [sp, #12]
    671c:	4a17      	ldr	r2, [pc, #92]	; (677c <Port_Ipw_Init+0xac>)
    671e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6722:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    6726:	9b01      	ldr	r3, [sp, #4]
    6728:	695a      	ldr	r2, [r3, #20]
    672a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    672e:	00db      	lsls	r3, r3, #3
    6730:	4413      	add	r3, r2
    6732:	685a      	ldr	r2, [r3, #4]
    6734:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6738:	4810      	ldr	r0, [pc, #64]	; (677c <Port_Ipw_Init+0xac>)
    673a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    673e:	430a      	orrs	r2, r1
    6740:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    6744:	f002 fd40 	bl	91c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6748:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    674c:	3301      	adds	r3, #1
    674e:	f8ad 300e 	strh.w	r3, [sp, #14]
    6752:	f89d 300d 	ldrb.w	r3, [sp, #13]
    6756:	b29b      	uxth	r3, r3
    6758:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    675c:	429a      	cmp	r2, r3
    675e:	d3c2      	bcc.n	66e6 <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    6760:	9b01      	ldr	r3, [sp, #4]
    6762:	6a1b      	ldr	r3, [r3, #32]
    6764:	4619      	mov	r1, r3
    6766:	2005      	movs	r0, #5
    6768:	f7ff fd98 	bl	629c <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    676c:	9801      	ldr	r0, [sp, #4]
    676e:	f7ff fe75 	bl	645c <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    6772:	bf00      	nop
    6774:	b005      	add	sp, #20
    6776:	f85d fb04 	ldr.w	pc, [sp], #4
    677a:	bf00      	nop
    677c:	0000ae28 	.word	0x0000ae28

00006780 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    6780:	b500      	push	{lr}
    6782:	b085      	sub	sp, #20
    6784:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    6786:	9b01      	ldr	r3, [sp, #4]
    6788:	881b      	ldrh	r3, [r3, #0]
    678a:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    678e:	2300      	movs	r3, #0
    6790:	f8ad 300e 	strh.w	r3, [sp, #14]
    6794:	e0d2      	b.n	693c <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    6796:	9b01      	ldr	r3, [sp, #4]
    6798:	68d9      	ldr	r1, [r3, #12]
    679a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    679e:	4613      	mov	r3, r2
    67a0:	009b      	lsls	r3, r3, #2
    67a2:	4413      	add	r3, r2
    67a4:	009b      	lsls	r3, r3, #2
    67a6:	440b      	add	r3, r1
    67a8:	7c5b      	ldrb	r3, [r3, #17]
    67aa:	f083 0301 	eor.w	r3, r3, #1
    67ae:	b2db      	uxtb	r3, r3
    67b0:	2b00      	cmp	r3, #0
    67b2:	f000 80be 	beq.w	6932 <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    67b6:	9b01      	ldr	r3, [sp, #4]
    67b8:	68d9      	ldr	r1, [r3, #12]
    67ba:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    67be:	4613      	mov	r3, r2
    67c0:	009b      	lsls	r3, r3, #2
    67c2:	4413      	add	r3, r2
    67c4:	009b      	lsls	r3, r3, #2
    67c6:	440b      	add	r3, r1
    67c8:	7c1b      	ldrb	r3, [r3, #16]
    67ca:	2b00      	cmp	r3, #0
    67cc:	f000 80b1 	beq.w	6932 <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    67d0:	9b01      	ldr	r3, [sp, #4]
    67d2:	68d9      	ldr	r1, [r3, #12]
    67d4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    67d8:	4613      	mov	r3, r2
    67da:	009b      	lsls	r3, r3, #2
    67dc:	4413      	add	r3, r2
    67de:	009b      	lsls	r3, r3, #2
    67e0:	440b      	add	r3, r1
    67e2:	881b      	ldrh	r3, [r3, #0]
    67e4:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    67e8:	9b01      	ldr	r3, [sp, #4]
    67ea:	68d9      	ldr	r1, [r3, #12]
    67ec:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    67f0:	4613      	mov	r3, r2
    67f2:	009b      	lsls	r3, r3, #2
    67f4:	4413      	add	r3, r2
    67f6:	009b      	lsls	r3, r3, #2
    67f8:	440b      	add	r3, r1
    67fa:	68db      	ldr	r3, [r3, #12]
    67fc:	2b02      	cmp	r3, #2
    67fe:	d11d      	bne.n	683c <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    6800:	f002 fdfe 	bl	9400 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6804:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6808:	095b      	lsrs	r3, r3, #5
    680a:	b29b      	uxth	r3, r3
    680c:	461a      	mov	r2, r3
    680e:	4b51      	ldr	r3, [pc, #324]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6810:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6814:	6959      	ldr	r1, [r3, #20]
    6816:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    681a:	f003 031f 	and.w	r3, r3, #31
    681e:	2201      	movs	r2, #1
    6820:	409a      	lsls	r2, r3
    6822:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6826:	095b      	lsrs	r3, r3, #5
    6828:	b29b      	uxth	r3, r3
    682a:	4618      	mov	r0, r3
    682c:	4b49      	ldr	r3, [pc, #292]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    682e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6832:	430a      	orrs	r2, r1
    6834:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    6836:	f002 fe0f 	bl	9458 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    683a:	e07a      	b.n	6932 <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    683c:	9b01      	ldr	r3, [sp, #4]
    683e:	68d9      	ldr	r1, [r3, #12]
    6840:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6844:	4613      	mov	r3, r2
    6846:	009b      	lsls	r3, r3, #2
    6848:	4413      	add	r3, r2
    684a:	009b      	lsls	r3, r3, #2
    684c:	440b      	add	r3, r1
    684e:	68db      	ldr	r3, [r3, #12]
    6850:	2b01      	cmp	r3, #1
    6852:	d00b      	beq.n	686c <Port_Ipw_RefreshPortDirection+0xec>
    6854:	9b01      	ldr	r3, [sp, #4]
    6856:	68d9      	ldr	r1, [r3, #12]
    6858:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    685c:	4613      	mov	r3, r2
    685e:	009b      	lsls	r3, r3, #2
    6860:	4413      	add	r3, r2
    6862:	009b      	lsls	r3, r3, #2
    6864:	440b      	add	r3, r1
    6866:	68db      	ldr	r3, [r3, #12]
    6868:	2b03      	cmp	r3, #3
    686a:	d162      	bne.n	6932 <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    686c:	f002 fdc8 	bl	9400 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    6870:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6874:	095b      	lsrs	r3, r3, #5
    6876:	b29b      	uxth	r3, r3
    6878:	461a      	mov	r2, r3
    687a:	4b36      	ldr	r3, [pc, #216]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    687c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6880:	6959      	ldr	r1, [r3, #20]
    6882:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6886:	f003 031f 	and.w	r3, r3, #31
    688a:	2201      	movs	r2, #1
    688c:	fa02 f303 	lsl.w	r3, r2, r3
    6890:	43da      	mvns	r2, r3
    6892:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6896:	095b      	lsrs	r3, r3, #5
    6898:	b29b      	uxth	r3, r3
    689a:	4618      	mov	r0, r3
    689c:	4b2d      	ldr	r3, [pc, #180]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    689e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    68a2:	400a      	ands	r2, r1
    68a4:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    68a6:	f002 fdd7 	bl	9458 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    68aa:	f002 fdfb 	bl	94a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    68ae:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    68b2:	095b      	lsrs	r3, r3, #5
    68b4:	b29b      	uxth	r3, r3
    68b6:	461a      	mov	r2, r3
    68b8:	4b26      	ldr	r3, [pc, #152]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    68ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    68be:	6999      	ldr	r1, [r3, #24]
    68c0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    68c4:	f003 031f 	and.w	r3, r3, #31
    68c8:	2201      	movs	r2, #1
    68ca:	fa02 f303 	lsl.w	r3, r2, r3
    68ce:	43da      	mvns	r2, r3
    68d0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    68d4:	095b      	lsrs	r3, r3, #5
    68d6:	b29b      	uxth	r3, r3
    68d8:	4618      	mov	r0, r3
    68da:	4b1e      	ldr	r3, [pc, #120]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    68dc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    68e0:	400a      	ands	r2, r1
    68e2:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    68e4:	9b01      	ldr	r3, [sp, #4]
    68e6:	68d9      	ldr	r1, [r3, #12]
    68e8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    68ec:	4613      	mov	r3, r2
    68ee:	009b      	lsls	r3, r3, #2
    68f0:	4413      	add	r3, r2
    68f2:	009b      	lsls	r3, r3, #2
    68f4:	440b      	add	r3, r1
    68f6:	68db      	ldr	r3, [r3, #12]
    68f8:	2b03      	cmp	r3, #3
    68fa:	d118      	bne.n	692e <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    68fc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6900:	095b      	lsrs	r3, r3, #5
    6902:	b29b      	uxth	r3, r3
    6904:	461a      	mov	r2, r3
    6906:	4b13      	ldr	r3, [pc, #76]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6908:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    690c:	6999      	ldr	r1, [r3, #24]
    690e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6912:	f003 031f 	and.w	r3, r3, #31
    6916:	2201      	movs	r2, #1
    6918:	409a      	lsls	r2, r3
    691a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    691e:	095b      	lsrs	r3, r3, #5
    6920:	b29b      	uxth	r3, r3
    6922:	4618      	mov	r0, r3
    6924:	4b0b      	ldr	r3, [pc, #44]	; (6954 <Port_Ipw_RefreshPortDirection+0x1d4>)
    6926:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    692a:	430a      	orrs	r2, r1
    692c:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    692e:	f002 fde5 	bl	94fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    6932:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6936:	3301      	adds	r3, #1
    6938:	f8ad 300e 	strh.w	r3, [sp, #14]
    693c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6940:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    6944:	429a      	cmp	r2, r3
    6946:	f4ff af26 	bcc.w	6796 <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    694a:	bf00      	nop
    694c:	bf00      	nop
    694e:	b005      	add	sp, #20
    6950:	f85d fb04 	ldr.w	pc, [sp], #4
    6954:	0000ae3c 	.word	0x0000ae3c

00006958 <Lpspi_Ip_ChannelFinished>:
* @param[in]     Instance            Index of the hardware instance.
* @param[in]     ErrorFlag           Save the status of transfer error flags
* @return void
*/
static void Lpspi_Ip_ChannelFinished(uint8 Instance, boolean ErrorFlag)
{
    6958:	b500      	push	{lr}
    695a:	b085      	sub	sp, #20
    695c:	4603      	mov	r3, r0
    695e:	460a      	mov	r2, r1
    6960:	f88d 3007 	strb.w	r3, [sp, #7]
    6964:	4613      	mov	r3, r2
    6966:	f88d 3006 	strb.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    696a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    696e:	4a12      	ldr	r2, [pc, #72]	; (69b8 <Lpspi_Ip_ChannelFinished+0x60>)
    6970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6974:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_EventType EventState = LPSPI_IP_EVENT_FAULT;
    6976:	2301      	movs	r3, #1
    6978:	9303      	str	r3, [sp, #12]
    
    if(TRUE == ErrorFlag)
    697a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    697e:	2b00      	cmp	r3, #0
    6980:	d005      	beq.n	698e <Lpspi_Ip_ChannelFinished+0x36>
    {
        State->Status = LPSPI_IP_FAULT;
    6982:	9b02      	ldr	r3, [sp, #8]
    6984:	2203      	movs	r2, #3
    6986:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_FAULT;
    6988:	2301      	movs	r3, #1
    698a:	9303      	str	r3, [sp, #12]
    698c:	e004      	b.n	6998 <Lpspi_Ip_ChannelFinished+0x40>
    }
    else
    {
        State->Status = LPSPI_IP_IDLE;
    698e:	9b02      	ldr	r3, [sp, #8]
    6990:	2201      	movs	r2, #1
    6992:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_END_TRANSFER;
    6994:	2300      	movs	r3, #0
    6996:	9303      	str	r3, [sp, #12]
    }

    if (NULL_PTR != State->Callback)
    6998:	9b02      	ldr	r3, [sp, #8]
    699a:	691b      	ldr	r3, [r3, #16]
    699c:	2b00      	cmp	r3, #0
    699e:	d006      	beq.n	69ae <Lpspi_Ip_ChannelFinished+0x56>
    {
        State->Callback(Instance, EventState);
    69a0:	9b02      	ldr	r3, [sp, #8]
    69a2:	691b      	ldr	r3, [r3, #16]
    69a4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    69a8:	9903      	ldr	r1, [sp, #12]
    69aa:	4610      	mov	r0, r2
    69ac:	4798      	blx	r3
    }
}
    69ae:	bf00      	nop
    69b0:	b005      	add	sp, #20
    69b2:	f85d fb04 	ldr.w	pc, [sp], #4
    69b6:	bf00      	nop
    69b8:	1fff8d38 	.word	0x1fff8d38

000069bc <Lpspi_Ip_TransferProcess>:
*
* @param[in]     Instance      Index of the hardware instance.
* @return void
*/
static void Lpspi_Ip_TransferProcess(uint8 Instance)
{
    69bc:	b510      	push	{r4, lr}
    69be:	b092      	sub	sp, #72	; 0x48
    69c0:	4603      	mov	r3, r0
    69c2:	f88d 300f 	strb.w	r3, [sp, #15]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    69c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    69ca:	4aad      	ldr	r2, [pc, #692]	; (6c80 <Lpspi_Ip_TransferProcess+0x2c4>)
    69cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69d0:	9310      	str	r3, [sp, #64]	; 0x40
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    69d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    69d6:	4aab      	ldr	r2, [pc, #684]	; (6c84 <Lpspi_Ip_TransferProcess+0x2c8>)
    69d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69dc:	930f      	str	r3, [sp, #60]	; 0x3c
    uint32 SrStatusRegister;
    uint8 NumberOfWrites = 0u;
    69de:	2300      	movs	r3, #0
    69e0:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    uint8 NumberOfReads = 0u;
    69e4:	2300      	movs	r3, #0
    69e6:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
    boolean ErrorFlag = FALSE;
    69ea:	2300      	movs	r3, #0
    69ec:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45

    if (LPSPI_IP_BUSY == State->Status)
    69f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    69f2:	685b      	ldr	r3, [r3, #4]
    69f4:	2b02      	cmp	r3, #2
    69f6:	f040 821e 	bne.w	6e36 <Lpspi_Ip_TransferProcess+0x47a>
    {
        /* Read Status and clear all flags. */
        SrStatusRegister = Base->SR;
    69fa:	9b10      	ldr	r3, [sp, #64]	; 0x40
    69fc:	695b      	ldr	r3, [r3, #20]
    69fe:	930e      	str	r3, [sp, #56]	; 0x38
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    6a00:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6a02:	695b      	ldr	r3, [r3, #20]
    6a04:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    6a08:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6a0a:	615a      	str	r2, [r3, #20]
        
        if ((SrStatusRegister & (LPSPI_SR_REF_MASK | LPSPI_SR_TEF_MASK)) != 0u)
    6a0c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6a0e:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
    6a12:	2b00      	cmp	r3, #0
    6a14:	d003      	beq.n	6a1e <Lpspi_Ip_TransferProcess+0x62>
        {
            /* mark error flag */
            ErrorFlag = TRUE;
    6a16:	2301      	movs	r3, #1
    6a18:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    6a1c:	e1f6      	b.n	6e0c <Lpspi_Ip_TransferProcess+0x450>
        }
        else
        {
            /* RECEIVE */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    6a1e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6a20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    6a22:	0c1b      	lsrs	r3, r3, #16
    6a24:	b2db      	uxtb	r3, r3
    6a26:	f003 0307 	and.w	r3, r3, #7
    6a2a:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
            if (NumberOfReads != 0u)
    6a2e:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    6a32:	2b00      	cmp	r3, #0
    6a34:	f000 80cb 	beq.w	6bce <Lpspi_Ip_TransferProcess+0x212>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    6a38:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
    6a3c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a3e:	8b1b      	ldrh	r3, [r3, #24]
    6a40:	4619      	mov	r1, r3
    6a42:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a44:	8a9b      	ldrh	r3, [r3, #20]
    6a46:	1acb      	subs	r3, r1, r3
    6a48:	429a      	cmp	r2, r3
    6a4a:	dd08      	ble.n	6a5e <Lpspi_Ip_TransferProcess+0xa2>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    6a4c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a4e:	8b1b      	ldrh	r3, [r3, #24]
    6a50:	b2da      	uxtb	r2, r3
    6a52:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a54:	8a9b      	ldrh	r3, [r3, #20]
    6a56:	b2db      	uxtb	r3, r3
    6a58:	1ad3      	subs	r3, r2, r3
    6a5a:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out and
                  CurrentTxFifoSlot was minus 1 when prepare TX channel */
                if (0u == State->RxIndex)
    6a5e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a60:	8a9b      	ldrh	r3, [r3, #20]
    6a62:	2b00      	cmp	r3, #0
    6a64:	d107      	bne.n	6a76 <Lpspi_Ip_TransferProcess+0xba>
                {
                    State->CurrentTxFifoSlot += 1u;
    6a66:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a68:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6a6c:	3301      	adds	r3, #1
    6a6e:	b2da      	uxtb	r2, r3
    6a70:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a72:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    6a76:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6a7a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    6a7e:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    6a82:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    6a86:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    6a8a:	4a7d      	ldr	r2, [pc, #500]	; (6c80 <Lpspi_Ip_TransferProcess+0x2c4>)
    6a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a90:	930c      	str	r3, [sp, #48]	; 0x30
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6a92:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    6a96:	4a7b      	ldr	r2, [pc, #492]	; (6c84 <Lpspi_Ip_TransferProcess+0x2c8>)
    6a98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a9c:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 Data = 0u;
    6a9e:	2300      	movs	r3, #0
    6aa0:	930a      	str	r3, [sp, #40]	; 0x28
    uint8 Index = 0u;
    6aa2:	2300      	movs	r3, #0
    6aa4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    if (NULL_PTR != State->RxBuffer)
    6aa8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6aaa:	689b      	ldr	r3, [r3, #8]
    6aac:	2b00      	cmp	r3, #0
    6aae:	d069      	beq.n	6b84 <Lpspi_Ip_TransferProcess+0x1c8>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    6ab0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6ab2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6ab4:	68db      	ldr	r3, [r3, #12]
    6ab6:	881b      	ldrh	r3, [r3, #0]
    6ab8:	2b08      	cmp	r3, #8
    6aba:	d81e      	bhi.n	6afa <Lpspi_Ip_TransferProcess+0x13e>
            for (Index = 0; Index < NumberOfReads; Index++)
    6abc:	2300      	movs	r3, #0
    6abe:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6ac2:	e013      	b.n	6aec <Lpspi_Ip_TransferProcess+0x130>
                Data = Base->RDR;
    6ac4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6ac6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    6ac8:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    6aca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6acc:	689b      	ldr	r3, [r3, #8]
    6ace:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    6ad0:	8a92      	ldrh	r2, [r2, #20]
    6ad2:	4611      	mov	r1, r2
    6ad4:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    6ad8:	440a      	add	r2, r1
    6ada:	4413      	add	r3, r2
    6adc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6ade:	b2d2      	uxtb	r2, r2
    6ae0:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    6ae2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6ae6:	3301      	adds	r3, #1
    6ae8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6aec:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    6af0:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6af4:	429a      	cmp	r2, r3
    6af6:	d8e5      	bhi.n	6ac4 <Lpspi_Ip_TransferProcess+0x108>
    6af8:	e055      	b.n	6ba6 <Lpspi_Ip_TransferProcess+0x1ea>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    6afa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6afc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6afe:	68db      	ldr	r3, [r3, #12]
    6b00:	881b      	ldrh	r3, [r3, #0]
    6b02:	2b10      	cmp	r3, #16
    6b04:	d81f      	bhi.n	6b46 <Lpspi_Ip_TransferProcess+0x18a>
            for (Index = 0; Index < NumberOfReads; Index++)
    6b06:	2300      	movs	r3, #0
    6b08:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b0c:	e014      	b.n	6b38 <Lpspi_Ip_TransferProcess+0x17c>
                Data = Base->RDR;
    6b0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6b10:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    6b12:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    6b14:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6b16:	689a      	ldr	r2, [r3, #8]
    6b18:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6b1a:	8a9b      	ldrh	r3, [r3, #20]
    6b1c:	4619      	mov	r1, r3
    6b1e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b22:	440b      	add	r3, r1
    6b24:	005b      	lsls	r3, r3, #1
    6b26:	4413      	add	r3, r2
    6b28:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6b2a:	b292      	uxth	r2, r2
    6b2c:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    6b2e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b32:	3301      	adds	r3, #1
    6b34:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b38:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    6b3c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b40:	429a      	cmp	r2, r3
    6b42:	d8e4      	bhi.n	6b0e <Lpspi_Ip_TransferProcess+0x152>
    6b44:	e02f      	b.n	6ba6 <Lpspi_Ip_TransferProcess+0x1ea>
            for (Index = 0; Index < NumberOfReads; Index++)
    6b46:	2300      	movs	r3, #0
    6b48:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b4c:	e013      	b.n	6b76 <Lpspi_Ip_TransferProcess+0x1ba>
                Data = Base->RDR;
    6b4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6b50:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    6b52:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    6b54:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6b56:	689a      	ldr	r2, [r3, #8]
    6b58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6b5a:	8a9b      	ldrh	r3, [r3, #20]
    6b5c:	4619      	mov	r1, r3
    6b5e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b62:	440b      	add	r3, r1
    6b64:	009b      	lsls	r3, r3, #2
    6b66:	4413      	add	r3, r2
    6b68:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6b6a:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    6b6c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b70:	3301      	adds	r3, #1
    6b72:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b76:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    6b7a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b7e:	429a      	cmp	r2, r3
    6b80:	d8e5      	bhi.n	6b4e <Lpspi_Ip_TransferProcess+0x192>
    6b82:	e010      	b.n	6ba6 <Lpspi_Ip_TransferProcess+0x1ea>
        for (Index = 0; Index < NumberOfReads; Index++)
    6b84:	2300      	movs	r3, #0
    6b86:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b8a:	e006      	b.n	6b9a <Lpspi_Ip_TransferProcess+0x1de>
            (void)Base->RDR;
    6b8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6b8e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    6b90:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6b94:	3301      	adds	r3, #1
    6b96:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6b9a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    6b9e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6ba2:	429a      	cmp	r2, r3
    6ba4:	d8f2      	bhi.n	6b8c <Lpspi_Ip_TransferProcess+0x1d0>
    State->RxIndex += NumberOfReads;
    6ba6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6ba8:	8a9a      	ldrh	r2, [r3, #20]
    6baa:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    6bae:	b29b      	uxth	r3, r3
    6bb0:	4413      	add	r3, r2
    6bb2:	b29a      	uxth	r2, r3
    6bb4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6bb6:	829a      	strh	r2, [r3, #20]
}
    6bb8:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    6bba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bbc:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    6bc0:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    6bc4:	4413      	add	r3, r2
    6bc6:	b2da      	uxtb	r2, r3
    6bc8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            to fill TX FIFO. At that time, another interrupt occurred and preemptive current interrupt, and the time to process that interrupt is longer than the time to transfer all frames 
            in TX FIFO. So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from that interrupt and fill TX FIFO until full and exist SPI interrupt function. 
            And if there is a interrupt occurred with higher priority of SPI interrupt and the time to process that interrupt is longer than the time to transfer all frames in TX FIFO. 
            So, RX FIFO can be overflow due to SPI interrupt function is not serviced to read RX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (State->TxDoneFlag != TRUE))
    6bce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bd0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6bd4:	2b00      	cmp	r3, #0
    6bd6:	f000 8119 	beq.w	6e0c <Lpspi_Ip_TransferProcess+0x450>
    6bda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bdc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
    6be0:	f083 0301 	eor.w	r3, r3, #1
    6be4:	b2db      	uxtb	r3, r3
    6be6:	2b00      	cmp	r3, #0
    6be8:	f000 8110 	beq.w	6e0c <Lpspi_Ip_TransferProcess+0x450>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    6bec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bee:	8b5a      	ldrh	r2, [r3, #26]
    6bf0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bf2:	8adb      	ldrh	r3, [r3, #22]
    6bf4:	429a      	cmp	r2, r3
    6bf6:	f000 80ca 	beq.w	6d8e <Lpspi_Ip_TransferProcess+0x3d2>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    6bfa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6bfc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    6c00:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    6c04:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
    6c08:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6c0a:	8b5b      	ldrh	r3, [r3, #26]
    6c0c:	4619      	mov	r1, r3
    6c0e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6c10:	8adb      	ldrh	r3, [r3, #22]
    6c12:	1acb      	subs	r3, r1, r3
    6c14:	429a      	cmp	r2, r3
    6c16:	dd08      	ble.n	6c2a <Lpspi_Ip_TransferProcess+0x26e>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    6c18:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6c1a:	8b5b      	ldrh	r3, [r3, #26]
    6c1c:	b2da      	uxtb	r2, r3
    6c1e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6c20:	8adb      	ldrh	r3, [r3, #22]
    6c22:	b2db      	uxtb	r3, r3
    6c24:	1ad3      	subs	r3, r2, r3
    6c26:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    6c2a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6c2e:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    6c32:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    6c36:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    6c3a:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    6c3e:	4a10      	ldr	r2, [pc, #64]	; (6c80 <Lpspi_Ip_TransferProcess+0x2c4>)
    6c40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c44:	9308      	str	r3, [sp, #32]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    6c46:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    6c4a:	4a0e      	ldr	r2, [pc, #56]	; (6c84 <Lpspi_Ip_TransferProcess+0x2c8>)
    6c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c50:	9307      	str	r3, [sp, #28]
    uint32 Data = 0u;
    6c52:	2300      	movs	r3, #0
    6c54:	9306      	str	r3, [sp, #24]
    uint8 Index = 0u;
    6c56:	2300      	movs	r3, #0
    6c58:	f88d 3017 	strb.w	r3, [sp, #23]
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    6c5c:	9b07      	ldr	r3, [sp, #28]
    6c5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6c60:	68db      	ldr	r3, [r3, #12]
    6c62:	685b      	ldr	r3, [r3, #4]
    6c64:	9306      	str	r3, [sp, #24]
    if (NULL_PTR != State->TxBuffer)
    6c66:	9b07      	ldr	r3, [sp, #28]
    6c68:	68db      	ldr	r3, [r3, #12]
    6c6a:	2b00      	cmp	r3, #0
    6c6c:	d068      	beq.n	6d40 <Lpspi_Ip_TransferProcess+0x384>
        if (State->TxFrameSize < 9u)
    6c6e:	9b07      	ldr	r3, [sp, #28]
    6c70:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    6c72:	2b08      	cmp	r3, #8
    6c74:	d822      	bhi.n	6cbc <Lpspi_Ip_TransferProcess+0x300>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6c76:	2300      	movs	r3, #0
    6c78:	f88d 3017 	strb.w	r3, [sp, #23]
    6c7c:	e017      	b.n	6cae <Lpspi_Ip_TransferProcess+0x2f2>
    6c7e:	bf00      	nop
    6c80:	0000ae50 	.word	0x0000ae50
    6c84:	1fff8d38 	.word	0x1fff8d38
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    6c88:	9b07      	ldr	r3, [sp, #28]
    6c8a:	68db      	ldr	r3, [r3, #12]
    6c8c:	9a07      	ldr	r2, [sp, #28]
    6c8e:	8ad2      	ldrh	r2, [r2, #22]
    6c90:	4611      	mov	r1, r2
    6c92:	f89d 2017 	ldrb.w	r2, [sp, #23]
    6c96:	440a      	add	r2, r1
    6c98:	4413      	add	r3, r2
    6c9a:	781b      	ldrb	r3, [r3, #0]
    6c9c:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    6c9e:	9b08      	ldr	r3, [sp, #32]
    6ca0:	9a06      	ldr	r2, [sp, #24]
    6ca2:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    6ca4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6ca8:	3301      	adds	r3, #1
    6caa:	f88d 3017 	strb.w	r3, [sp, #23]
    6cae:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    6cb2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6cb6:	429a      	cmp	r2, r3
    6cb8:	d8e6      	bhi.n	6c88 <Lpspi_Ip_TransferProcess+0x2cc>
    6cba:	e053      	b.n	6d64 <Lpspi_Ip_TransferProcess+0x3a8>
        else if (State->TxFrameSize < 17u)
    6cbc:	9b07      	ldr	r3, [sp, #28]
    6cbe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    6cc0:	2b10      	cmp	r3, #16
    6cc2:	d81e      	bhi.n	6d02 <Lpspi_Ip_TransferProcess+0x346>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6cc4:	2300      	movs	r3, #0
    6cc6:	f88d 3017 	strb.w	r3, [sp, #23]
    6cca:	e013      	b.n	6cf4 <Lpspi_Ip_TransferProcess+0x338>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    6ccc:	9b07      	ldr	r3, [sp, #28]
    6cce:	68da      	ldr	r2, [r3, #12]
    6cd0:	9b07      	ldr	r3, [sp, #28]
    6cd2:	8adb      	ldrh	r3, [r3, #22]
    6cd4:	4619      	mov	r1, r3
    6cd6:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6cda:	440b      	add	r3, r1
    6cdc:	005b      	lsls	r3, r3, #1
    6cde:	4413      	add	r3, r2
    6ce0:	881b      	ldrh	r3, [r3, #0]
    6ce2:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    6ce4:	9b08      	ldr	r3, [sp, #32]
    6ce6:	9a06      	ldr	r2, [sp, #24]
    6ce8:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    6cea:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6cee:	3301      	adds	r3, #1
    6cf0:	f88d 3017 	strb.w	r3, [sp, #23]
    6cf4:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    6cf8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6cfc:	429a      	cmp	r2, r3
    6cfe:	d8e5      	bhi.n	6ccc <Lpspi_Ip_TransferProcess+0x310>
    6d00:	e030      	b.n	6d64 <Lpspi_Ip_TransferProcess+0x3a8>
            for (Index = 0; Index < NumberOfWrites; Index++)
    6d02:	2300      	movs	r3, #0
    6d04:	f88d 3017 	strb.w	r3, [sp, #23]
    6d08:	e013      	b.n	6d32 <Lpspi_Ip_TransferProcess+0x376>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    6d0a:	9b07      	ldr	r3, [sp, #28]
    6d0c:	68da      	ldr	r2, [r3, #12]
    6d0e:	9b07      	ldr	r3, [sp, #28]
    6d10:	8adb      	ldrh	r3, [r3, #22]
    6d12:	4619      	mov	r1, r3
    6d14:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6d18:	440b      	add	r3, r1
    6d1a:	009b      	lsls	r3, r3, #2
    6d1c:	4413      	add	r3, r2
    6d1e:	681b      	ldr	r3, [r3, #0]
    6d20:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    6d22:	9b08      	ldr	r3, [sp, #32]
    6d24:	9a06      	ldr	r2, [sp, #24]
    6d26:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    6d28:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6d2c:	3301      	adds	r3, #1
    6d2e:	f88d 3017 	strb.w	r3, [sp, #23]
    6d32:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    6d36:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6d3a:	429a      	cmp	r2, r3
    6d3c:	d8e5      	bhi.n	6d0a <Lpspi_Ip_TransferProcess+0x34e>
    6d3e:	e011      	b.n	6d64 <Lpspi_Ip_TransferProcess+0x3a8>
        for (Index = 0; Index < NumberOfWrites; Index++)
    6d40:	2300      	movs	r3, #0
    6d42:	f88d 3017 	strb.w	r3, [sp, #23]
    6d46:	e007      	b.n	6d58 <Lpspi_Ip_TransferProcess+0x39c>
            Base->TDR = Data;
    6d48:	9b08      	ldr	r3, [sp, #32]
    6d4a:	9a06      	ldr	r2, [sp, #24]
    6d4c:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    6d4e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6d52:	3301      	adds	r3, #1
    6d54:	f88d 3017 	strb.w	r3, [sp, #23]
    6d58:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    6d5c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6d60:	429a      	cmp	r2, r3
    6d62:	d8f1      	bhi.n	6d48 <Lpspi_Ip_TransferProcess+0x38c>
    State->TxIndex += NumberOfWrites;
    6d64:	9b07      	ldr	r3, [sp, #28]
    6d66:	8ada      	ldrh	r2, [r3, #22]
    6d68:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    6d6c:	b29b      	uxth	r3, r3
    6d6e:	4413      	add	r3, r2
    6d70:	b29a      	uxth	r2, r3
    6d72:	9b07      	ldr	r3, [sp, #28]
    6d74:	82da      	strh	r2, [r3, #22]
}
    6d76:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    6d78:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6d7a:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    6d7e:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    6d82:	1ad3      	subs	r3, r2, r3
    6d84:	b2da      	uxtb	r2, r3
    6d86:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6d88:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    6d8c:	e03e      	b.n	6e0c <Lpspi_Ip_TransferProcess+0x450>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    6d8e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6d90:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    6d94:	2b00      	cmp	r3, #0
    6d96:	d01c      	beq.n	6dd2 <Lpspi_Ip_TransferProcess+0x416>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    6d98:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6d9a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6d9c:	68db      	ldr	r3, [r3, #12]
    6d9e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    6da0:	6b52      	ldr	r2, [r2, #52]	; 0x34
    6da2:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    6da4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6da6:	2200      	movs	r2, #0
    6da8:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    6daa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6dac:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    6dae:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6db0:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    6db2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6db4:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    6db8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6dba:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    6dbc:	f89d 000f 	ldrb.w	r0, [sp, #15]
    6dc0:	9300      	str	r3, [sp, #0]
    6dc2:	4623      	mov	r3, r4
    6dc4:	f000 fb7a 	bl	74bc <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    6dc8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6dca:	2200      	movs	r2, #0
    6dcc:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    6dd0:	e01c      	b.n	6e0c <Lpspi_Ip_TransferProcess+0x450>
                    }
                    else
                    {
                        State->TxDoneFlag = TRUE;
    6dd2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6dd4:	2201      	movs	r2, #1
    6dd6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
                        /* Disable TX interrupt */
                        Base->IER &= ~LPSPI_IER_TDIE_MASK;
    6dda:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6ddc:	699b      	ldr	r3, [r3, #24]
    6dde:	f023 0201 	bic.w	r2, r3, #1
    6de2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6de4:	619a      	str	r2, [r3, #24]
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    6de6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6de8:	7f1b      	ldrb	r3, [r3, #28]
    6dea:	f083 0301 	eor.w	r3, r3, #1
    6dee:	b2db      	uxtb	r3, r3
    6df0:	2b00      	cmp	r3, #0
    6df2:	d00b      	beq.n	6e0c <Lpspi_Ip_TransferProcess+0x450>
    6df4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6df6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6df8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    6dfc:	2b00      	cmp	r3, #0
    6dfe:	d005      	beq.n	6e0c <Lpspi_Ip_TransferProcess+0x450>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    6e00:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6e02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6e04:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    6e08:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6e0a:	661a      	str	r2, [r3, #96]	; 0x60
                }
            }
        }
        
        /* End of transfer */
        if((State->RxIndex == State->ExpectedFifoReads) || (TRUE == ErrorFlag))
    6e0c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6e0e:	8a9a      	ldrh	r2, [r3, #20]
    6e10:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6e12:	8b1b      	ldrh	r3, [r3, #24]
    6e14:	429a      	cmp	r2, r3
    6e16:	d003      	beq.n	6e20 <Lpspi_Ip_TransferProcess+0x464>
    6e18:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    6e1c:	2b00      	cmp	r3, #0
    6e1e:	d00a      	beq.n	6e36 <Lpspi_Ip_TransferProcess+0x47a>
                Base->TCR |= LPSPI_TCR_RXMSK(1);
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12();
            }
            #endif
            /* Disable interrupts */
            Base->IER = 0u;
    6e20:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6e22:	2200      	movs	r2, #0
    6e24:	619a      	str	r2, [r3, #24]
            Lpspi_Ip_ChannelFinished(Instance, ErrorFlag);
    6e26:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    6e2a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6e2e:	4611      	mov	r1, r2
    6e30:	4618      	mov	r0, r3
    6e32:	f7ff fd91 	bl	6958 <Lpspi_Ip_ChannelFinished>
        }
    }
}
    6e36:	bf00      	nop
    6e38:	b012      	add	sp, #72	; 0x48
    6e3a:	bd10      	pop	{r4, pc}

00006e3c <Lpspi_Ip_Init>:
    OsIf_Trusted_Call1param(Lpspi_Ip_SetUserAccess, Instance);
}
#endif /* LPSPI_IP_ENABLE_USER_MODE_SUPPORT */
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_Init(const Lpspi_Ip_ConfigType *PhyUnitConfigPtr)
{
    6e3c:	b500      	push	{lr}
    6e3e:	b087      	sub	sp, #28
    6e40:	9001      	str	r0, [sp, #4]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6e42:	2300      	movs	r3, #0
    6e44:	9305      	str	r3, [sp, #20]
    uint8 Instance = 0u;
    6e46:	2300      	movs	r3, #0
    6e48:	f88d 3013 	strb.w	r3, [sp, #19]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(PhyUnitConfigPtr != NULL_PTR);
    #endif
    Instance = PhyUnitConfigPtr->Instance;
    6e4c:	9b01      	ldr	r3, [sp, #4]
    6e4e:	781b      	ldrb	r3, [r3, #0]
    6e50:	f88d 3013 	strb.w	r3, [sp, #19]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6e54:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6e58:	4a23      	ldr	r2, [pc, #140]	; (6ee8 <Lpspi_Ip_Init+0xac>)
    6e5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e5e:	9303      	str	r3, [sp, #12]
    Base = Lpspi_Ip_apxBases[Instance];
    6e60:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6e64:	4a21      	ldr	r2, [pc, #132]	; (6eec <Lpspi_Ip_Init+0xb0>)
    6e66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e6a:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State == NULL_PTR);
    #endif
    Lpspi_Ip_apxStateStructureArray[Instance] = &Lpspi_Ip_axStateStructure[PhyUnitConfigPtr->StateIndex];
    6e6c:	9b01      	ldr	r3, [sp, #4]
    6e6e:	7c1b      	ldrb	r3, [r3, #16]
    6e70:	461a      	mov	r2, r3
    6e72:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6e76:	0192      	lsls	r2, r2, #6
    6e78:	491d      	ldr	r1, [pc, #116]	; (6ef0 <Lpspi_Ip_Init+0xb4>)
    6e7a:	440a      	add	r2, r1
    6e7c:	491a      	ldr	r1, [pc, #104]	; (6ee8 <Lpspi_Ip_Init+0xac>)
    6e7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6e82:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6e86:	4a18      	ldr	r2, [pc, #96]	; (6ee8 <Lpspi_Ip_Init+0xac>)
    6e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e8c:	9303      	str	r3, [sp, #12]
    State->PhyUnitConfig = PhyUnitConfigPtr;
    6e8e:	9b03      	ldr	r3, [sp, #12]
    6e90:	9a01      	ldr	r2, [sp, #4]
    6e92:	621a      	str	r2, [r3, #32]
    /* enable in debug mode to ensure CS will be kept when CPU halts at breakpoint */
    Base->CR = PhyUnitConfigPtr->Cr | LPSPI_CR_DBGEN_MASK;
    6e94:	9b01      	ldr	r3, [sp, #4]
    6e96:	685b      	ldr	r3, [r3, #4]
    6e98:	f043 0208 	orr.w	r2, r3, #8
    6e9c:	9b02      	ldr	r3, [sp, #8]
    6e9e:	611a      	str	r2, [r3, #16]
    Base->CFGR1 = PhyUnitConfigPtr->Cfgr1;
    6ea0:	9b01      	ldr	r3, [sp, #4]
    6ea2:	689a      	ldr	r2, [r3, #8]
    6ea4:	9b02      	ldr	r3, [sp, #8]
    6ea6:	625a      	str	r2, [r3, #36]	; 0x24
    /* Set TX WATER. it will be set again in DMA mode */
    Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    6ea8:	9b02      	ldr	r3, [sp, #8]
    6eaa:	2203      	movs	r2, #3
    6eac:	659a      	str	r2, [r3, #88]	; 0x58
    #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    State->ClockMode = LPSPI_IP_NORMAL_CLOCK;
    #endif
    State->KeepCs = FALSE;
    6eae:	9b03      	ldr	r3, [sp, #12]
    6eb0:	2200      	movs	r2, #0
    6eb2:	771a      	strb	r2, [r3, #28]
    State->FirstCmd = TRUE;
    6eb4:	9b03      	ldr	r3, [sp, #12]
    6eb6:	2201      	movs	r2, #1
    6eb8:	775a      	strb	r2, [r3, #29]
    #if ((STD_ON == LPSPI_IP_DMA_USED) && (STD_ON == LPSPI_IP_ENABLE_DMAFASTTRANSFER_SUPPORT))
    Lpspi_Ip_TxDmaTcdSGInit(Instance);
    Lpspi_Ip_RxDmaTcdSGInit(Instance);
    #endif
    /* set State to idle */
    State->Status = LPSPI_IP_IDLE;
    6eba:	9b03      	ldr	r3, [sp, #12]
    6ebc:	2201      	movs	r2, #1
    6ebe:	605a      	str	r2, [r3, #4]
    (void)Lpspi_Ip_UpdateTransferMode(Instance, PhyUnitConfigPtr->TransferMode);
    6ec0:	9b01      	ldr	r3, [sp, #4]
    6ec2:	68da      	ldr	r2, [r3, #12]
    6ec4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6ec8:	4611      	mov	r1, r2
    6eca:	4618      	mov	r0, r3
    6ecc:	f000 fd10 	bl	78f0 <Lpspi_Ip_UpdateTransferMode>
    
    /* Enable SPI module */
    Base->CR |= LPSPI_CR_MEN_MASK;
    6ed0:	9b02      	ldr	r3, [sp, #8]
    6ed2:	691b      	ldr	r3, [r3, #16]
    6ed4:	f043 0201 	orr.w	r2, r3, #1
    6ed8:	9b02      	ldr	r3, [sp, #8]
    6eda:	611a      	str	r2, [r3, #16]
    return Status;
    6edc:	9b05      	ldr	r3, [sp, #20]
}
    6ede:	4618      	mov	r0, r3
    6ee0:	b007      	add	sp, #28
    6ee2:	f85d fb04 	ldr.w	pc, [sp], #4
    6ee6:	bf00      	nop
    6ee8:	1fff8d38 	.word	0x1fff8d38
    6eec:	0000ae50 	.word	0x0000ae50
    6ef0:	1fff8cf8 	.word	0x1fff8cf8

00006ef4 <Lpspi_Ip_DeInit>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_DeInit(uint8 Instance)
{
    6ef4:	b086      	sub	sp, #24
    6ef6:	4603      	mov	r3, r0
    6ef8:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6efc:	2300      	movs	r3, #0
    6efe:	9305      	str	r3, [sp, #20]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    6f00:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6f04:	4a11      	ldr	r2, [pc, #68]	; (6f4c <Lpspi_Ip_DeInit+0x58>)
    6f06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f0a:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6f0c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6f10:	4a0f      	ldr	r2, [pc, #60]	; (6f50 <Lpspi_Ip_DeInit+0x5c>)
    6f12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f16:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_BUSY == State->Status)
    6f18:	9b03      	ldr	r3, [sp, #12]
    6f1a:	685b      	ldr	r3, [r3, #4]
    6f1c:	2b02      	cmp	r3, #2
    6f1e:	d102      	bne.n	6f26 <Lpspi_Ip_DeInit+0x32>
    {
        Status = LPSPI_IP_STATUS_FAIL;
    6f20:	2301      	movs	r3, #1
    6f22:	9305      	str	r3, [sp, #20]
    6f24:	e00e      	b.n	6f44 <Lpspi_Ip_DeInit+0x50>
    }
    else
    {
        /* Use reset hardware feature. */
        Base->CR |= LPSPI_CR_RST(1u);
    6f26:	9b04      	ldr	r3, [sp, #16]
    6f28:	691b      	ldr	r3, [r3, #16]
    6f2a:	f043 0202 	orr.w	r2, r3, #2
    6f2e:	9b04      	ldr	r3, [sp, #16]
    6f30:	611a      	str	r2, [r3, #16]
        Base->CR = 0;
    6f32:	9b04      	ldr	r3, [sp, #16]
    6f34:	2200      	movs	r2, #0
    6f36:	611a      	str	r2, [r3, #16]

        Lpspi_Ip_apxStateStructureArray[Instance] = NULL_PTR;
    6f38:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6f3c:	4a04      	ldr	r2, [pc, #16]	; (6f50 <Lpspi_Ip_DeInit+0x5c>)
    6f3e:	2100      	movs	r1, #0
    6f40:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    }
    return Status;
    6f44:	9b05      	ldr	r3, [sp, #20]
}
    6f46:	4618      	mov	r0, r3
    6f48:	b006      	add	sp, #24
    6f4a:	4770      	bx	lr
    6f4c:	0000ae50 	.word	0x0000ae50
    6f50:	1fff8d38 	.word	0x1fff8d38

00006f54 <Lpspi_Ip_SyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            uint32 TimeOut
                                         )
{
    6f54:	b510      	push	{r4, lr}
    6f56:	b09a      	sub	sp, #104	; 0x68
    6f58:	9005      	str	r0, [sp, #20]
    6f5a:	9104      	str	r1, [sp, #16]
    6f5c:	9203      	str	r2, [sp, #12]
    6f5e:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type *Base;
    Lpspi_Ip_StateStructureType *State;
    uint8 NumberOfWrites, NumberOfReads;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    6f62:	2300      	movs	r3, #0
    6f64:	9318      	str	r3, [sp, #96]	; 0x60
    uint32 TimeoutTicks = OsIf_MicrosToTicks(TimeOut, LPSPI_IP_TIMEOUT_METHOD);
    6f66:	2100      	movs	r1, #0
    6f68:	981c      	ldr	r0, [sp, #112]	; 0x70
    6f6a:	f7fa fe9f 	bl	1cac <OsIf_MicrosToTicks>
    6f6e:	9015      	str	r0, [sp, #84]	; 0x54
    uint32 CurrentTicks = 0u; /* initialize current counter */
    6f70:	2300      	movs	r3, #0
    6f72:	9307      	str	r3, [sp, #28]
    uint32 ElapsedTicks = 0u; /* elapsed will give timeout */
    6f74:	2300      	movs	r3, #0
    6f76:	9317      	str	r3, [sp, #92]	; 0x5c
    uint8 Instance = 0u;
    6f78:	2300      	movs	r3, #0
    6f7a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    uint32 Cfgr1 = 0u;
    6f7e:	2300      	movs	r3, #0
    6f80:	9313      	str	r3, [sp, #76]	; 0x4c
    boolean TxDoneFlag = FALSE;
    6f82:	2300      	movs	r3, #0
    6f84:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    DevAssert(0u != TimeOut);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    6f88:	9b05      	ldr	r3, [sp, #20]
    6f8a:	781b      	ldrb	r3, [r3, #0]
    6f8c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    6f90:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    6f94:	4a92      	ldr	r2, [pc, #584]	; (71e0 <Lpspi_Ip_SyncTransmit+0x28c>)
    6f96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f9a:	9312      	str	r3, [sp, #72]	; 0x48
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];    
    6f9c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    6fa0:	4a90      	ldr	r2, [pc, #576]	; (71e4 <Lpspi_Ip_SyncTransmit+0x290>)
    6fa2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fa6:	9311      	str	r3, [sp, #68]	; 0x44
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08();
    6fa8:	f002 ff9c 	bl	9ee4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>
    if (LPSPI_IP_BUSY == State->Status)
    6fac:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fae:	685b      	ldr	r3, [r3, #4]
    6fb0:	2b02      	cmp	r3, #2
    6fb2:	d104      	bne.n	6fbe <Lpspi_Ip_SyncTransmit+0x6a>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    6fb4:	f002 ffc2 	bl	9f3c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        Status = LPSPI_IP_STATUS_FAIL;
    6fb8:	2301      	movs	r3, #1
    6fba:	9318      	str	r3, [sp, #96]	; 0x60
    6fbc:	e276      	b.n	74ac <Lpspi_Ip_SyncTransmit+0x558>
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    6fbe:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fc0:	2202      	movs	r2, #2
    6fc2:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    6fc4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fc6:	9a05      	ldr	r2, [sp, #20]
    6fc8:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    6fca:	f002 ffb7 	bl	9f3c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        
        /* Disable DMA requests and all interrupts */
        Base->DER = 0u;
    6fce:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6fd0:	2200      	movs	r2, #0
    6fd2:	61da      	str	r2, [r3, #28]
        Base->IER = 0u;
    6fd4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6fd6:	2200      	movs	r2, #0
    6fd8:	619a      	str	r2, [r3, #24]
        
        /* Update State structure. */
        State->NextTransferConfigAvailable = State->KeepCs;
    6fda:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fdc:	7f1a      	ldrb	r2, [r3, #28]
    6fde:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fe0:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    6fe4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6fe6:	7f5b      	ldrb	r3, [r3, #29]
    6fe8:	2b00      	cmp	r3, #0
    6fea:	d030      	beq.n	704e <Lpspi_Ip_SyncTransmit+0xfa>
            /* Makes sure that FIFOs will be empty before start new transfer session. 
            There is maybe a frame in RX shifter register (previous transfer is broken and CS did not de-assert).
            So use reset FIFO do not prevent the potential issue. So reset module by software reset bit should be used here */
            /* Reset FIFOs using CR[RST] bit */
            /* store CFGR1 and restore after all registers are reset */
            Cfgr1 = Base->CFGR1;
    6fec:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6fee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6ff0:	9313      	str	r3, [sp, #76]	; 0x4c
            Base->CR |= LPSPI_CR_RST_MASK;
    6ff2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6ff4:	691b      	ldr	r3, [r3, #16]
    6ff6:	f043 0202 	orr.w	r2, r3, #2
    6ffa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6ffc:	611a      	str	r2, [r3, #16]
            Base->CR &= ~LPSPI_CR_RST_MASK;
    6ffe:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7000:	691b      	ldr	r3, [r3, #16]
    7002:	f023 0202 	bic.w	r2, r3, #2
    7006:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7008:	611a      	str	r2, [r3, #16]
            /* restore CFGR1 */
            Base->CFGR1 = Cfgr1;
    700a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    700c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    700e:	625a      	str	r2, [r3, #36]	; 0x24
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    7010:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7012:	695b      	ldr	r3, [r3, #20]
    7014:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    7018:	9b11      	ldr	r3, [sp, #68]	; 0x44
    701a:	615a      	str	r2, [r3, #20]

            #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
            Base->CCR = ExternalDevice->Ccr[State->ClockMode];
            #else
            Base->CCR = ExternalDevice->Ccr;
    701c:	9b05      	ldr	r3, [sp, #20]
    701e:	685a      	ldr	r2, [r3, #4]
    7020:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7022:	641a      	str	r2, [r3, #64]	; 0x40
            #endif
                /* Reset current FIFO slots are available to fill at beginning of job (HLD).*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    7024:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7026:	2204      	movs	r2, #4
    7028:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    702c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    702e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7030:	68db      	ldr	r3, [r3, #12]
    7032:	881a      	ldrh	r2, [r3, #0]
    7034:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7036:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7038:	68db      	ldr	r3, [r3, #12]
    703a:	7899      	ldrb	r1, [r3, #2]
    703c:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    7040:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7044:	9300      	str	r3, [sp, #0]
    7046:	460b      	mov	r3, r1
    7048:	9904      	ldr	r1, [sp, #16]
    704a:	f000 fa37 	bl	74bc <Lpspi_TransmitTxInit>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    704e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7050:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7052:	68db      	ldr	r3, [r3, #12]
    7054:	881a      	ldrh	r2, [r3, #0]
    7056:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    705a:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    705e:	9903      	ldr	r1, [sp, #12]
    7060:	f000 facc 	bl	75fc <Lpspi_TransmitRxInit>
        /* initialize current counter */
        CurrentTicks = OsIf_GetCounter(LPSPI_IP_TIMEOUT_METHOD);
    7064:	2000      	movs	r0, #0
    7066:	f7fa fdd5 	bl	1c14 <OsIf_GetCounter>
    706a:	4603      	mov	r3, r0
    706c:	9307      	str	r3, [sp, #28]
        while(State->RxIndex != State->ExpectedFifoReads)
    706e:	e202      	b.n	7476 <Lpspi_Ip_SyncTransmit+0x522>
        {
            /* RECEIVE DATA */
            /* The receiving should be performed first because maybe have a last frame in RX FIFO from previous channel
                , it should be read to clear RXFIFO before start a new write to TXFIFO */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    7070:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7072:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    7074:	0c1b      	lsrs	r3, r3, #16
    7076:	b2db      	uxtb	r3, r3
    7078:	f003 0307 	and.w	r3, r3, #7
    707c:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
            /* Limits to remaining frames. */
            
            if (NumberOfReads != 0u)
    7080:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    7084:	2b00      	cmp	r3, #0
    7086:	f000 80d2 	beq.w	722e <Lpspi_Ip_SyncTransmit+0x2da>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    708a:	f89d 2066 	ldrb.w	r2, [sp, #102]	; 0x66
    708e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7090:	8b1b      	ldrh	r3, [r3, #24]
    7092:	4619      	mov	r1, r3
    7094:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7096:	8a9b      	ldrh	r3, [r3, #20]
    7098:	1acb      	subs	r3, r1, r3
    709a:	429a      	cmp	r2, r3
    709c:	dd08      	ble.n	70b0 <Lpspi_Ip_SyncTransmit+0x15c>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    709e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    70a0:	8b1b      	ldrh	r3, [r3, #24]
    70a2:	b2da      	uxtb	r2, r3
    70a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    70a6:	8a9b      	ldrh	r3, [r3, #20]
    70a8:	b2db      	uxtb	r3, r3
    70aa:	1ad3      	subs	r3, r2, r3
    70ac:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out */
                if (0u == State->RxIndex)
    70b0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    70b2:	8a9b      	ldrh	r3, [r3, #20]
    70b4:	2b00      	cmp	r3, #0
    70b6:	d107      	bne.n	70c8 <Lpspi_Ip_SyncTransmit+0x174>
                {
                    State->CurrentTxFifoSlot += 1u;
    70b8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    70ba:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    70be:	3301      	adds	r3, #1
    70c0:	b2da      	uxtb	r2, r3
    70c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    70c4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    70c8:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    70cc:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    70d0:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    70d4:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    70d8:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    70dc:	4a41      	ldr	r2, [pc, #260]	; (71e4 <Lpspi_Ip_SyncTransmit+0x290>)
    70de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70e2:	930f      	str	r3, [sp, #60]	; 0x3c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    70e4:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    70e8:	4a3d      	ldr	r2, [pc, #244]	; (71e0 <Lpspi_Ip_SyncTransmit+0x28c>)
    70ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70ee:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 Data = 0u;
    70f0:	2300      	movs	r3, #0
    70f2:	930d      	str	r3, [sp, #52]	; 0x34
    uint8 Index = 0u;
    70f4:	2300      	movs	r3, #0
    70f6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    if (NULL_PTR != State->RxBuffer)
    70fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    70fc:	689b      	ldr	r3, [r3, #8]
    70fe:	2b00      	cmp	r3, #0
    7100:	d069      	beq.n	71d6 <Lpspi_Ip_SyncTransmit+0x282>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    7102:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7104:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7106:	68db      	ldr	r3, [r3, #12]
    7108:	881b      	ldrh	r3, [r3, #0]
    710a:	2b08      	cmp	r3, #8
    710c:	d81e      	bhi.n	714c <Lpspi_Ip_SyncTransmit+0x1f8>
            for (Index = 0; Index < NumberOfReads; Index++)
    710e:	2300      	movs	r3, #0
    7110:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    7114:	e013      	b.n	713e <Lpspi_Ip_SyncTransmit+0x1ea>
                Data = Base->RDR;
    7116:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7118:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    711a:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    711c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    711e:	689b      	ldr	r3, [r3, #8]
    7120:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    7122:	8a92      	ldrh	r2, [r2, #20]
    7124:	4611      	mov	r1, r2
    7126:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
    712a:	440a      	add	r2, r1
    712c:	4413      	add	r3, r2
    712e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    7130:	b2d2      	uxtb	r2, r2
    7132:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    7134:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    7138:	3301      	adds	r3, #1
    713a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    713e:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    7142:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    7146:	429a      	cmp	r2, r3
    7148:	d8e5      	bhi.n	7116 <Lpspi_Ip_SyncTransmit+0x1c2>
    714a:	e05a      	b.n	7202 <Lpspi_Ip_SyncTransmit+0x2ae>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    714c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    714e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7150:	68db      	ldr	r3, [r3, #12]
    7152:	881b      	ldrh	r3, [r3, #0]
    7154:	2b10      	cmp	r3, #16
    7156:	d81f      	bhi.n	7198 <Lpspi_Ip_SyncTransmit+0x244>
            for (Index = 0; Index < NumberOfReads; Index++)
    7158:	2300      	movs	r3, #0
    715a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    715e:	e014      	b.n	718a <Lpspi_Ip_SyncTransmit+0x236>
                Data = Base->RDR;
    7160:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7162:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7164:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    7166:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7168:	689a      	ldr	r2, [r3, #8]
    716a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    716c:	8a9b      	ldrh	r3, [r3, #20]
    716e:	4619      	mov	r1, r3
    7170:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    7174:	440b      	add	r3, r1
    7176:	005b      	lsls	r3, r3, #1
    7178:	4413      	add	r3, r2
    717a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    717c:	b292      	uxth	r2, r2
    717e:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    7180:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    7184:	3301      	adds	r3, #1
    7186:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    718a:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    718e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    7192:	429a      	cmp	r2, r3
    7194:	d8e4      	bhi.n	7160 <Lpspi_Ip_SyncTransmit+0x20c>
    7196:	e034      	b.n	7202 <Lpspi_Ip_SyncTransmit+0x2ae>
            for (Index = 0; Index < NumberOfReads; Index++)
    7198:	2300      	movs	r3, #0
    719a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    719e:	e013      	b.n	71c8 <Lpspi_Ip_SyncTransmit+0x274>
                Data = Base->RDR;
    71a0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    71a2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    71a4:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    71a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    71a8:	689a      	ldr	r2, [r3, #8]
    71aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    71ac:	8a9b      	ldrh	r3, [r3, #20]
    71ae:	4619      	mov	r1, r3
    71b0:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    71b4:	440b      	add	r3, r1
    71b6:	009b      	lsls	r3, r3, #2
    71b8:	4413      	add	r3, r2
    71ba:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    71bc:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    71be:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    71c2:	3301      	adds	r3, #1
    71c4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    71c8:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    71cc:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    71d0:	429a      	cmp	r2, r3
    71d2:	d8e5      	bhi.n	71a0 <Lpspi_Ip_SyncTransmit+0x24c>
    71d4:	e015      	b.n	7202 <Lpspi_Ip_SyncTransmit+0x2ae>
        for (Index = 0; Index < NumberOfReads; Index++)
    71d6:	2300      	movs	r3, #0
    71d8:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    71dc:	e00b      	b.n	71f6 <Lpspi_Ip_SyncTransmit+0x2a2>
    71de:	bf00      	nop
    71e0:	1fff8d38 	.word	0x1fff8d38
    71e4:	0000ae50 	.word	0x0000ae50
            (void)Base->RDR;
    71e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    71ea:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    71ec:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    71f0:	3301      	adds	r3, #1
    71f2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    71f6:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    71fa:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    71fe:	429a      	cmp	r2, r3
    7200:	d8f2      	bhi.n	71e8 <Lpspi_Ip_SyncTransmit+0x294>
    State->RxIndex += NumberOfReads;
    7202:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7204:	8a9a      	ldrh	r2, [r3, #20]
    7206:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
    720a:	b29b      	uxth	r3, r3
    720c:	4413      	add	r3, r2
    720e:	b29a      	uxth	r2, r3
    7210:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7212:	829a      	strh	r2, [r3, #20]
}
    7214:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    7216:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7218:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    721c:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    7220:	4413      	add	r3, r2
    7222:	b2da      	uxtb	r2, r3
    7224:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7226:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                ElapsedTicks = 0u;
    722a:	2300      	movs	r3, #0
    722c:	9317      	str	r3, [sp, #92]	; 0x5c
            /* After driver code read all frames in RX FIFO, if there are still some frames in TX FIFO, at the time before driver code check number of frames available in TX FIFO 
            to prepare to fill TX FIFO. At that time, interrupt occurred, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO. 
            So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from interrupt and fill TX FIFO until full. 
            And there is a interrupt occurred after that before read all frames in RX FIFO, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (TxDoneFlag != TRUE))
    722e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7230:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    7234:	2b00      	cmp	r3, #0
    7236:	f000 810e 	beq.w	7456 <Lpspi_Ip_SyncTransmit+0x502>
    723a:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
    723e:	f083 0301 	eor.w	r3, r3, #1
    7242:	b2db      	uxtb	r3, r3
    7244:	2b00      	cmp	r3, #0
    7246:	f000 8106 	beq.w	7456 <Lpspi_Ip_SyncTransmit+0x502>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    724a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    724c:	8b5a      	ldrh	r2, [r3, #26]
    724e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7250:	8adb      	ldrh	r3, [r3, #22]
    7252:	429a      	cmp	r2, r3
    7254:	f000 80c7 	beq.w	73e6 <Lpspi_Ip_SyncTransmit+0x492>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    7258:	9b12      	ldr	r3, [sp, #72]	; 0x48
    725a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    725e:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    7262:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
    7266:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7268:	8b5b      	ldrh	r3, [r3, #26]
    726a:	4619      	mov	r1, r3
    726c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    726e:	8adb      	ldrh	r3, [r3, #22]
    7270:	1acb      	subs	r3, r1, r3
    7272:	429a      	cmp	r2, r3
    7274:	dd08      	ble.n	7288 <Lpspi_Ip_SyncTransmit+0x334>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    7276:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7278:	8b5b      	ldrh	r3, [r3, #26]
    727a:	b2da      	uxtb	r2, r3
    727c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    727e:	8adb      	ldrh	r3, [r3, #22]
    7280:	b2db      	uxtb	r3, r3
    7282:	1ad3      	subs	r3, r2, r3
    7284:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    7288:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    728c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    7290:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    7294:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    7298:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    729c:	4a85      	ldr	r2, [pc, #532]	; (74b4 <Lpspi_Ip_SyncTransmit+0x560>)
    729e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72a2:	930b      	str	r3, [sp, #44]	; 0x2c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    72a4:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    72a8:	4a83      	ldr	r2, [pc, #524]	; (74b8 <Lpspi_Ip_SyncTransmit+0x564>)
    72aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72ae:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 Data = 0u;
    72b0:	2300      	movs	r3, #0
    72b2:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Index = 0u;
    72b4:	2300      	movs	r3, #0
    72b6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    72ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    72be:	68db      	ldr	r3, [r3, #12]
    72c0:	685b      	ldr	r3, [r3, #4]
    72c2:	9309      	str	r3, [sp, #36]	; 0x24
    if (NULL_PTR != State->TxBuffer)
    72c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72c6:	68db      	ldr	r3, [r3, #12]
    72c8:	2b00      	cmp	r3, #0
    72ca:	d063      	beq.n	7394 <Lpspi_Ip_SyncTransmit+0x440>
        if (State->TxFrameSize < 9u)
    72cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72ce:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    72d0:	2b08      	cmp	r3, #8
    72d2:	d81d      	bhi.n	7310 <Lpspi_Ip_SyncTransmit+0x3bc>
            for (Index = 0; Index < NumberOfWrites; Index++)
    72d4:	2300      	movs	r3, #0
    72d6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    72da:	e012      	b.n	7302 <Lpspi_Ip_SyncTransmit+0x3ae>
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    72dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72de:	68db      	ldr	r3, [r3, #12]
    72e0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    72e2:	8ad2      	ldrh	r2, [r2, #22]
    72e4:	4611      	mov	r1, r2
    72e6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    72ea:	440a      	add	r2, r1
    72ec:	4413      	add	r3, r2
    72ee:	781b      	ldrb	r3, [r3, #0]
    72f0:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    72f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    72f4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    72f6:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    72f8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    72fc:	3301      	adds	r3, #1
    72fe:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    7302:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    7306:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    730a:	429a      	cmp	r2, r3
    730c:	d8e6      	bhi.n	72dc <Lpspi_Ip_SyncTransmit+0x388>
    730e:	e053      	b.n	73b8 <Lpspi_Ip_SyncTransmit+0x464>
        else if (State->TxFrameSize < 17u)
    7310:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7312:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    7314:	2b10      	cmp	r3, #16
    7316:	d81e      	bhi.n	7356 <Lpspi_Ip_SyncTransmit+0x402>
            for (Index = 0; Index < NumberOfWrites; Index++)
    7318:	2300      	movs	r3, #0
    731a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    731e:	e013      	b.n	7348 <Lpspi_Ip_SyncTransmit+0x3f4>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    7320:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7322:	68da      	ldr	r2, [r3, #12]
    7324:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7326:	8adb      	ldrh	r3, [r3, #22]
    7328:	4619      	mov	r1, r3
    732a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    732e:	440b      	add	r3, r1
    7330:	005b      	lsls	r3, r3, #1
    7332:	4413      	add	r3, r2
    7334:	881b      	ldrh	r3, [r3, #0]
    7336:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    7338:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    733a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    733c:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    733e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7342:	3301      	adds	r3, #1
    7344:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    7348:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    734c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7350:	429a      	cmp	r2, r3
    7352:	d8e5      	bhi.n	7320 <Lpspi_Ip_SyncTransmit+0x3cc>
    7354:	e030      	b.n	73b8 <Lpspi_Ip_SyncTransmit+0x464>
            for (Index = 0; Index < NumberOfWrites; Index++)
    7356:	2300      	movs	r3, #0
    7358:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    735c:	e013      	b.n	7386 <Lpspi_Ip_SyncTransmit+0x432>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    735e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7360:	68da      	ldr	r2, [r3, #12]
    7362:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7364:	8adb      	ldrh	r3, [r3, #22]
    7366:	4619      	mov	r1, r3
    7368:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    736c:	440b      	add	r3, r1
    736e:	009b      	lsls	r3, r3, #2
    7370:	4413      	add	r3, r2
    7372:	681b      	ldr	r3, [r3, #0]
    7374:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    7376:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7378:	9a09      	ldr	r2, [sp, #36]	; 0x24
    737a:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    737c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7380:	3301      	adds	r3, #1
    7382:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    7386:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    738a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    738e:	429a      	cmp	r2, r3
    7390:	d8e5      	bhi.n	735e <Lpspi_Ip_SyncTransmit+0x40a>
    7392:	e011      	b.n	73b8 <Lpspi_Ip_SyncTransmit+0x464>
        for (Index = 0; Index < NumberOfWrites; Index++)
    7394:	2300      	movs	r3, #0
    7396:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    739a:	e007      	b.n	73ac <Lpspi_Ip_SyncTransmit+0x458>
            Base->TDR = Data;
    739c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    739e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    73a0:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    73a2:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    73a6:	3301      	adds	r3, #1
    73a8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    73ac:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    73b0:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    73b4:	429a      	cmp	r2, r3
    73b6:	d8f1      	bhi.n	739c <Lpspi_Ip_SyncTransmit+0x448>
    State->TxIndex += NumberOfWrites;
    73b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    73ba:	8ada      	ldrh	r2, [r3, #22]
    73bc:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    73c0:	b29b      	uxth	r3, r3
    73c2:	4413      	add	r3, r2
    73c4:	b29a      	uxth	r2, r3
    73c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    73c8:	82da      	strh	r2, [r3, #22]
}
    73ca:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    73cc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    73ce:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    73d2:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    73d6:	1ad3      	subs	r3, r2, r3
    73d8:	b2da      	uxtb	r2, r3
    73da:	9b12      	ldr	r3, [sp, #72]	; 0x48
    73dc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                    ElapsedTicks = 0u;
    73e0:	2300      	movs	r3, #0
    73e2:	9317      	str	r3, [sp, #92]	; 0x5c
    73e4:	e037      	b.n	7456 <Lpspi_Ip_SyncTransmit+0x502>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    73e6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    73e8:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    73ec:	2b00      	cmp	r3, #0
    73ee:	d01c      	beq.n	742a <Lpspi_Ip_SyncTransmit+0x4d6>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    73f0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    73f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    73f4:	68db      	ldr	r3, [r3, #12]
    73f6:	9a12      	ldr	r2, [sp, #72]	; 0x48
    73f8:	6b52      	ldr	r2, [r2, #52]	; 0x34
    73fa:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    73fc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    73fe:	2200      	movs	r2, #0
    7400:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    7402:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7404:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    7406:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7408:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    740a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    740c:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    7410:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7412:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    7414:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    7418:	9300      	str	r3, [sp, #0]
    741a:	4623      	mov	r3, r4
    741c:	f000 f84e 	bl	74bc <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    7420:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7422:	2200      	movs	r2, #0
    7424:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    7428:	e015      	b.n	7456 <Lpspi_Ip_SyncTransmit+0x502>
                    }
                    else
                    {
                        TxDoneFlag = TRUE;
    742a:	2301      	movs	r3, #1
    742c:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    7430:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7432:	7f1b      	ldrb	r3, [r3, #28]
    7434:	f083 0301 	eor.w	r3, r3, #1
    7438:	b2db      	uxtb	r3, r3
    743a:	2b00      	cmp	r3, #0
    743c:	d00b      	beq.n	7456 <Lpspi_Ip_SyncTransmit+0x502>
    743e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7440:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7442:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    7446:	2b00      	cmp	r3, #0
    7448:	d005      	beq.n	7456 <Lpspi_Ip_SyncTransmit+0x502>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    744a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    744c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    744e:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    7452:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7454:	661a      	str	r2, [r3, #96]	; 0x60
                        }
                    }
                }
            }
            ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, LPSPI_IP_TIMEOUT_METHOD);
    7456:	ab07      	add	r3, sp, #28
    7458:	2100      	movs	r1, #0
    745a:	4618      	mov	r0, r3
    745c:	f7fa fbf3 	bl	1c46 <OsIf_GetElapsed>
    7460:	4602      	mov	r2, r0
    7462:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    7464:	4413      	add	r3, r2
    7466:	9317      	str	r3, [sp, #92]	; 0x5c
            if (ElapsedTicks >= TimeoutTicks)
    7468:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    746a:	9b15      	ldr	r3, [sp, #84]	; 0x54
    746c:	429a      	cmp	r2, r3
    746e:	d302      	bcc.n	7476 <Lpspi_Ip_SyncTransmit+0x522>
            {
                Status = LPSPI_IP_TIMEOUT;
    7470:	2303      	movs	r3, #3
    7472:	9318      	str	r3, [sp, #96]	; 0x60
                break;
    7474:	e006      	b.n	7484 <Lpspi_Ip_SyncTransmit+0x530>
        while(State->RxIndex != State->ExpectedFifoReads)
    7476:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7478:	8a9a      	ldrh	r2, [r3, #20]
    747a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    747c:	8b1b      	ldrh	r3, [r3, #24]
    747e:	429a      	cmp	r2, r3
    7480:	f47f adf6 	bne.w	7070 <Lpspi_Ip_SyncTransmit+0x11c>
            }
        }
        if ((LPSPI_IP_STATUS_SUCCESS != Status) || (0u == Length))
    7484:	9b18      	ldr	r3, [sp, #96]	; 0x60
    7486:	2b00      	cmp	r3, #0
    7488:	d103      	bne.n	7492 <Lpspi_Ip_SyncTransmit+0x53e>
    748a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    748e:	2b00      	cmp	r3, #0
    7490:	d109      	bne.n	74a6 <Lpspi_Ip_SyncTransmit+0x552>
        {
#if (STD_OFF == LPSPI_IP_DEV_ERROR_DETECT)
            /* Return Fail status if length is 0. Error Detect is enabled, nothing need to be done here */
            if (0u == Length)
    7492:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7496:	2b00      	cmp	r3, #0
    7498:	d101      	bne.n	749e <Lpspi_Ip_SyncTransmit+0x54a>
            {
                Status = LPSPI_IP_STATUS_FAIL;
    749a:	2301      	movs	r3, #1
    749c:	9318      	str	r3, [sp, #96]	; 0x60
            }
#endif
            State->Status = LPSPI_IP_FAULT;
    749e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    74a0:	2203      	movs	r2, #3
    74a2:	605a      	str	r2, [r3, #4]
    74a4:	e002      	b.n	74ac <Lpspi_Ip_SyncTransmit+0x558>
        }
        else
        {
            State->Status = LPSPI_IP_IDLE;
    74a6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    74a8:	2201      	movs	r2, #1
    74aa:	605a      	str	r2, [r3, #4]
        }
    }
    return Status;
    74ac:	9b18      	ldr	r3, [sp, #96]	; 0x60
}
    74ae:	4618      	mov	r0, r3
    74b0:	b01a      	add	sp, #104	; 0x68
    74b2:	bd10      	pop	{r4, pc}
    74b4:	0000ae50 	.word	0x0000ae50
    74b8:	1fff8d38 	.word	0x1fff8d38

000074bc <Lpspi_TransmitTxInit>:
                                 const uint8* TxBuffer,
                                 uint16 TxFrameSize,
                                 boolean TxLsb,
                                 uint16 BufLen
                                )
{
    74bc:	b088      	sub	sp, #32
    74be:	9100      	str	r1, [sp, #0]
    74c0:	4611      	mov	r1, r2
    74c2:	461a      	mov	r2, r3
    74c4:	4603      	mov	r3, r0
    74c6:	f88d 3007 	strb.w	r3, [sp, #7]
    74ca:	460b      	mov	r3, r1
    74cc:	f8ad 3004 	strh.w	r3, [sp, #4]
    74d0:	4613      	mov	r3, r2
    74d2:	f88d 3006 	strb.w	r3, [sp, #6]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    74d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    74da:	4a46      	ldr	r2, [pc, #280]	; (75f4 <Lpspi_TransmitTxInit+0x138>)
    74dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74e0:	9307      	str	r3, [sp, #28]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    74e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    74e6:	4a44      	ldr	r2, [pc, #272]	; (75f8 <Lpspi_TransmitTxInit+0x13c>)
    74e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74ec:	9306      	str	r3, [sp, #24]
    uint32 TransferCommand = 0u;
    74ee:	2300      	movs	r3, #0
    74f0:	9305      	str	r3, [sp, #20]
    uint8 LsbWriteValue = TxLsb ? 1U : 0U;
    74f2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    74f6:	2b00      	cmp	r3, #0
    74f8:	d001      	beq.n	74fe <Lpspi_TransmitTxInit+0x42>
    74fa:	2301      	movs	r3, #1
    74fc:	e000      	b.n	7500 <Lpspi_TransmitTxInit+0x44>
    74fe:	2300      	movs	r3, #0
    7500:	f88d 3013 	strb.w	r3, [sp, #19]

    State->TxFrameSize = TxFrameSize;
    7504:	9b06      	ldr	r3, [sp, #24]
    7506:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    750a:	851a      	strh	r2, [r3, #40]	; 0x28
    State->TxLsb = TxLsb;
    750c:	9b06      	ldr	r3, [sp, #24]
    750e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    7512:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    /* Get transfer command */
#if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    TransferCommand = State->ExternalDevice->Tcr[State->ClockMode] | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
#else
    TransferCommand = State->ExternalDevice->Tcr | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
    7516:	9b06      	ldr	r3, [sp, #24]
    7518:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    751a:	689a      	ldr	r2, [r3, #8]
    751c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    7520:	3b01      	subs	r3, #1
    7522:	f3c3 030b 	ubfx	r3, r3, #0, #12
    7526:	431a      	orrs	r2, r3
    7528:	f89d 3013 	ldrb.w	r3, [sp, #19]
    752c:	05db      	lsls	r3, r3, #23
    752e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
    7532:	4313      	orrs	r3, r2
    7534:	9305      	str	r3, [sp, #20]
        {
            TransferCommand &= ~LPSPI_TCR_CONT_MASK;
        }
        #endif
        
        if(TRUE == State->FirstCmd)
    7536:	9b06      	ldr	r3, [sp, #24]
    7538:	7f5b      	ldrb	r3, [r3, #29]
    753a:	2b00      	cmp	r3, #0
    753c:	d003      	beq.n	7546 <Lpspi_TransmitTxInit+0x8a>
        {
            /* Set transfer command */
            Base->TCR = TransferCommand;
    753e:	9b07      	ldr	r3, [sp, #28]
    7540:	9a05      	ldr	r2, [sp, #20]
    7542:	661a      	str	r2, [r3, #96]	; 0x60
    7544:	e00d      	b.n	7562 <Lpspi_TransmitTxInit+0xa6>
        }
        else
        {
            if (0u != (TransferCommand & LPSPI_TCR_CONT_MASK))
    7546:	9b05      	ldr	r3, [sp, #20]
    7548:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    754c:	2b00      	cmp	r3, #0
    754e:	d005      	beq.n	755c <Lpspi_TransmitTxInit+0xa0>
            {
                Base->TCR = TransferCommand | LPSPI_TCR_CONTC_MASK;
    7550:	9b05      	ldr	r3, [sp, #20]
    7552:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    7556:	9b07      	ldr	r3, [sp, #28]
    7558:	661a      	str	r2, [r3, #96]	; 0x60
    755a:	e002      	b.n	7562 <Lpspi_TransmitTxInit+0xa6>
            }
            else
            {
                Base->TCR = TransferCommand;
    755c:	9b07      	ldr	r3, [sp, #28]
    755e:	9a05      	ldr	r2, [sp, #20]
    7560:	661a      	str	r2, [r3, #96]	; 0x60
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        if (LPSPI_IP_FULL_DUPLEX == State->ExternalDevice->DeviceParams->TransferType)
        #endif
        {
            /* CMD will take 1 slot in TXFIFO, update current TX FIFO slot. it will be plus 1 when the first frames of channel have recieved */
            State->CurrentTxFifoSlot -= 1u;
    7562:	9b06      	ldr	r3, [sp, #24]
    7564:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    7568:	3b01      	subs	r3, #1
    756a:	b2da      	uxtb	r2, r3
    756c:	9b06      	ldr	r3, [sp, #24]
    756e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        }
    }
    
    /* Update State structure. */
    State->TxIndex = 0u;
    7572:	9b06      	ldr	r3, [sp, #24]
    7574:	2200      	movs	r2, #0
    7576:	82da      	strh	r2, [r3, #22]
        (void)TxBuffer;
    }
    else
    #endif
    {
        State->TxBuffer = TxBuffer;
    7578:	9b06      	ldr	r3, [sp, #24]
    757a:	9a00      	ldr	r2, [sp, #0]
    757c:	60da      	str	r2, [r3, #12]
    757e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    7582:	f8ad 3010 	strh.w	r3, [sp, #16]
    7586:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    758a:	f8ad 300e 	strh.w	r3, [sp, #14]
    if (FrameSize < 9u)
    758e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7592:	2b08      	cmp	r3, #8
    7594:	d804      	bhi.n	75a0 <Lpspi_TransmitTxInit+0xe4>
        Ret = Length;
    7596:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    759a:	f8ad 300c 	strh.w	r3, [sp, #12]
    759e:	e022      	b.n	75e6 <Lpspi_TransmitTxInit+0x12a>
    else if (FrameSize < 17u)
    75a0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    75a4:	2b10      	cmp	r3, #16
    75a6:	d80c      	bhi.n	75c2 <Lpspi_TransmitTxInit+0x106>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    75a8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    75ac:	085b      	lsrs	r3, r3, #1
    75ae:	b29a      	uxth	r2, r3
    75b0:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    75b4:	f003 0301 	and.w	r3, r3, #1
    75b8:	b29b      	uxth	r3, r3
    75ba:	4413      	add	r3, r2
    75bc:	f8ad 300c 	strh.w	r3, [sp, #12]
    75c0:	e011      	b.n	75e6 <Lpspi_TransmitTxInit+0x12a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    75c2:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    75c6:	089b      	lsrs	r3, r3, #2
    75c8:	b29a      	uxth	r2, r3
    75ca:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    75ce:	f003 0303 	and.w	r3, r3, #3
    75d2:	b29b      	uxth	r3, r3
    75d4:	2b00      	cmp	r3, #0
    75d6:	bf14      	ite	ne
    75d8:	2301      	movne	r3, #1
    75da:	2300      	moveq	r3, #0
    75dc:	b2db      	uxtb	r3, r3
    75de:	b29b      	uxth	r3, r3
    75e0:	4413      	add	r3, r2
    75e2:	f8ad 300c 	strh.w	r3, [sp, #12]
    return Ret;
    75e6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    }

    State->ExpectedFifoWrites = Lpspi_Ip_GetWordsFromLength(BufLen, TxFrameSize);
    75ea:	9b06      	ldr	r3, [sp, #24]
    75ec:	835a      	strh	r2, [r3, #26]
}
    75ee:	bf00      	nop
    75f0:	b008      	add	sp, #32
    75f2:	4770      	bx	lr
    75f4:	0000ae50 	.word	0x0000ae50
    75f8:	1fff8d38 	.word	0x1fff8d38

000075fc <Lpspi_TransmitRxInit>:
static void Lpspi_TransmitRxInit(uint8 Instance,
                                      uint8* RxBuffer,
                                      uint16 RxFrameSize,
                                      uint16 BufLen
                                     )
{
    75fc:	b088      	sub	sp, #32
    75fe:	9102      	str	r1, [sp, #8]
    7600:	4611      	mov	r1, r2
    7602:	461a      	mov	r2, r3
    7604:	4603      	mov	r3, r0
    7606:	f88d 300f 	strb.w	r3, [sp, #15]
    760a:	460b      	mov	r3, r1
    760c:	f8ad 300c 	strh.w	r3, [sp, #12]
    7610:	4613      	mov	r3, r2
    7612:	f8ad 3006 	strh.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    7616:	f89d 300f 	ldrb.w	r3, [sp, #15]
    761a:	4a22      	ldr	r2, [pc, #136]	; (76a4 <Lpspi_TransmitRxInit+0xa8>)
    761c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7620:	9307      	str	r3, [sp, #28]
    
    /* Update State structure. */
    State->RxIndex = 0u;
    7622:	9b07      	ldr	r3, [sp, #28]
    7624:	2200      	movs	r2, #0
    7626:	829a      	strh	r2, [r3, #20]
        (void)RxBuffer; 
    }
    else
    #endif        
    {
        State->RxBuffer = RxBuffer; 
    7628:	9b07      	ldr	r3, [sp, #28]
    762a:	9a02      	ldr	r2, [sp, #8]
    762c:	609a      	str	r2, [r3, #8]
    762e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    7632:	f8ad 301a 	strh.w	r3, [sp, #26]
    7636:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    763a:	f8ad 3018 	strh.w	r3, [sp, #24]
    if (FrameSize < 9u)
    763e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    7642:	2b08      	cmp	r3, #8
    7644:	d804      	bhi.n	7650 <Lpspi_TransmitRxInit+0x54>
        Ret = Length;
    7646:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    764a:	f8ad 3016 	strh.w	r3, [sp, #22]
    764e:	e022      	b.n	7696 <Lpspi_TransmitRxInit+0x9a>
    else if (FrameSize < 17u)
    7650:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    7654:	2b10      	cmp	r3, #16
    7656:	d80c      	bhi.n	7672 <Lpspi_TransmitRxInit+0x76>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    7658:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    765c:	085b      	lsrs	r3, r3, #1
    765e:	b29a      	uxth	r2, r3
    7660:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    7664:	f003 0301 	and.w	r3, r3, #1
    7668:	b29b      	uxth	r3, r3
    766a:	4413      	add	r3, r2
    766c:	f8ad 3016 	strh.w	r3, [sp, #22]
    7670:	e011      	b.n	7696 <Lpspi_TransmitRxInit+0x9a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    7672:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    7676:	089b      	lsrs	r3, r3, #2
    7678:	b29a      	uxth	r2, r3
    767a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    767e:	f003 0303 	and.w	r3, r3, #3
    7682:	b29b      	uxth	r3, r3
    7684:	2b00      	cmp	r3, #0
    7686:	bf14      	ite	ne
    7688:	2301      	movne	r3, #1
    768a:	2300      	moveq	r3, #0
    768c:	b2db      	uxtb	r3, r3
    768e:	b29b      	uxth	r3, r3
    7690:	4413      	add	r3, r2
    7692:	f8ad 3016 	strh.w	r3, [sp, #22]
    return Ret;
    7696:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    }

    State->ExpectedFifoReads = Lpspi_Ip_GetWordsFromLength(BufLen, RxFrameSize);
    769a:	9b07      	ldr	r3, [sp, #28]
    769c:	831a      	strh	r2, [r3, #24]
}
    769e:	bf00      	nop
    76a0:	b008      	add	sp, #32
    76a2:	4770      	bx	lr
    76a4:	1fff8d38 	.word	0x1fff8d38

000076a8 <Lpspi_Ip_AsyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            Lpspi_Ip_CallbackType EndCallback
                                          )
{
    76a8:	b500      	push	{lr}
    76aa:	b08b      	sub	sp, #44	; 0x2c
    76ac:	9005      	str	r0, [sp, #20]
    76ae:	9104      	str	r1, [sp, #16]
    76b0:	9203      	str	r2, [sp, #12]
    76b2:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    76b6:	2300      	movs	r3, #0
    76b8:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Instance = 0u;
    76ba:	2300      	movs	r3, #0
    76bc:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    76c0:	9b05      	ldr	r3, [sp, #20]
    76c2:	781b      	ldrb	r3, [r3, #0]
    76c4:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    76c8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    76cc:	4a3d      	ldr	r2, [pc, #244]	; (77c4 <Lpspi_Ip_AsyncTransmit+0x11c>)
    76ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76d2:	9307      	str	r3, [sp, #28]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];
    76d4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    76d8:	4a3b      	ldr	r2, [pc, #236]	; (77c8 <Lpspi_Ip_AsyncTransmit+0x120>)
    76da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76de:	9306      	str	r3, [sp, #24]
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09();
    76e0:	f002 fc52 	bl	9f88 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>
    if (LPSPI_IP_BUSY == State->Status)
    76e4:	9b07      	ldr	r3, [sp, #28]
    76e6:	685b      	ldr	r3, [r3, #4]
    76e8:	2b02      	cmp	r3, #2
    76ea:	d104      	bne.n	76f6 <Lpspi_Ip_AsyncTransmit+0x4e>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    76ec:	f002 fc78 	bl	9fe0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        Status = LPSPI_IP_STATUS_FAIL;
    76f0:	2301      	movs	r3, #1
    76f2:	9309      	str	r3, [sp, #36]	; 0x24
    76f4:	e061      	b.n	77ba <Lpspi_Ip_AsyncTransmit+0x112>
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    76f6:	9b07      	ldr	r3, [sp, #28]
    76f8:	2202      	movs	r2, #2
    76fa:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    76fc:	9b07      	ldr	r3, [sp, #28]
    76fe:	9a05      	ldr	r2, [sp, #20]
    7700:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    7702:	f002 fc6d 	bl	9fe0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        
        /* Update State structure. */
        State->Callback = EndCallback;
    7706:	9b07      	ldr	r3, [sp, #28]
    7708:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    770a:	611a      	str	r2, [r3, #16]
        State->NextTransferConfigAvailable = State->KeepCs;
    770c:	9b07      	ldr	r3, [sp, #28]
    770e:	7f1a      	ldrb	r2, [r3, #28]
    7710:	9b07      	ldr	r3, [sp, #28]
    7712:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Reset TX done flag */
        State->TxDoneFlag = FALSE;
    7716:	9b07      	ldr	r3, [sp, #28]
    7718:	2200      	movs	r2, #0
    771a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    771e:	9b07      	ldr	r3, [sp, #28]
    7720:	7f5b      	ldrb	r3, [r3, #29]
    7722:	2b00      	cmp	r3, #0
    7724:	d028      	beq.n	7778 <Lpspi_Ip_AsyncTransmit+0xd0>
        {
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11();
    7726:	f002 fcd3 	bl	a0d0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>
            /* Make sure that FIFOs will be empty before start new transfer session */
            Base->CR |= LPSPI_CR_RTF_MASK|LPSPI_CR_RRF_MASK;
    772a:	9b06      	ldr	r3, [sp, #24]
    772c:	691b      	ldr	r3, [r3, #16]
    772e:	f443 7240 	orr.w	r2, r3, #768	; 0x300
    7732:	9b06      	ldr	r3, [sp, #24]
    7734:	611a      	str	r2, [r3, #16]
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    7736:	9b06      	ldr	r3, [sp, #24]
    7738:	695b      	ldr	r3, [r3, #20]
    773a:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    773e:	9b06      	ldr	r3, [sp, #24]
    7740:	615a      	str	r2, [r3, #20]
            #endif
            {
                #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
                Base->CCR = ExternalDevice->Ccr[State->ClockMode];
                #else
                Base->CCR = ExternalDevice->Ccr;
    7742:	9b05      	ldr	r3, [sp, #20]
    7744:	685a      	ldr	r2, [r3, #4]
    7746:	9b06      	ldr	r3, [sp, #24]
    7748:	641a      	str	r2, [r3, #64]	; 0x40
                #endif
            }
            /* Update current FIFO slots are available to fill .*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    774a:	9b07      	ldr	r3, [sp, #28]
    774c:	2204      	movs	r2, #4
    774e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            /* In setting up Transmit command register, the RXMSK is also cleared */
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    7752:	9b07      	ldr	r3, [sp, #28]
    7754:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7756:	68db      	ldr	r3, [r3, #12]
    7758:	881a      	ldrh	r2, [r3, #0]
    775a:	9b07      	ldr	r3, [sp, #28]
    775c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    775e:	68db      	ldr	r3, [r3, #12]
    7760:	7899      	ldrb	r1, [r3, #2]
    7762:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    7766:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    776a:	9300      	str	r3, [sp, #0]
    776c:	460b      	mov	r3, r1
    776e:	9904      	ldr	r1, [sp, #16]
    7770:	f7ff fea4 	bl	74bc <Lpspi_TransmitTxInit>
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11();
    7774:	f002 fcd8 	bl	a128 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    7778:	9b07      	ldr	r3, [sp, #28]
    777a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    777c:	68db      	ldr	r3, [r3, #12]
    777e:	881a      	ldrh	r2, [r3, #0]
    7780:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7784:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    7788:	9903      	ldr	r1, [sp, #12]
    778a:	f7ff ff37 	bl	75fc <Lpspi_TransmitRxInit>
            }
            else
            #endif
            {
                /* Set TX water */
                Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    778e:	9b06      	ldr	r3, [sp, #24]
    7790:	2203      	movs	r2, #3
    7792:	659a      	str	r2, [r3, #88]	; 0x58
            }
            
            /* Disable DMA requests */
            Base->DER = 0u;
    7794:	9b06      	ldr	r3, [sp, #24]
    7796:	2200      	movs	r2, #0
    7798:	61da      	str	r2, [r3, #28]
            switch (State->TransferMode)
    779a:	9b07      	ldr	r3, [sp, #28]
    779c:	681b      	ldr	r3, [r3, #0]
    779e:	2b00      	cmp	r3, #0
    77a0:	d002      	beq.n	77a8 <Lpspi_Ip_AsyncTransmit+0x100>
    77a2:	2b01      	cmp	r3, #1
    77a4:	d004      	beq.n	77b0 <Lpspi_Ip_AsyncTransmit+0x108>
                case LPSPI_IP_INTERRUPT:
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
                    break;
                default:
                    /* Nothing to do */
                    break;
    77a6:	e008      	b.n	77ba <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = 0u;
    77a8:	9b06      	ldr	r3, [sp, #24]
    77aa:	2200      	movs	r2, #0
    77ac:	619a      	str	r2, [r3, #24]
                    break;
    77ae:	e004      	b.n	77ba <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
    77b0:	9b06      	ldr	r3, [sp, #24]
    77b2:	f641 0203 	movw	r2, #6147	; 0x1803
    77b6:	619a      	str	r2, [r3, #24]
                    break;
    77b8:	bf00      	nop
            /* Enable DMA request. */
            Base->DER = LPSPI_DER_RDDE_MASK | LPSPI_DER_TDDE_MASK;
        }
        #endif
    }
    return Status;
    77ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    77bc:	4618      	mov	r0, r3
    77be:	b00b      	add	sp, #44	; 0x2c
    77c0:	f85d fb04 	ldr.w	pc, [sp], #4
    77c4:	1fff8d38 	.word	0x1fff8d38
    77c8:	0000ae50 	.word	0x0000ae50

000077cc <Lpspi_Ip_ManageBuffers>:
}
#endif
#endif

void Lpspi_Ip_ManageBuffers(uint8 Instance)
{
    77cc:	b500      	push	{lr}
    77ce:	b085      	sub	sp, #20
    77d0:	4603      	mov	r3, r0
    77d2:	f88d 3007 	strb.w	r3, [sp, #7]
    #endif

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    77d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77da:	4a14      	ldr	r2, [pc, #80]	; (782c <Lpspi_Ip_ManageBuffers+0x60>)
    77dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77e0:	9303      	str	r3, [sp, #12]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    77e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    77e6:	4a12      	ldr	r2, [pc, #72]	; (7830 <Lpspi_Ip_ManageBuffers+0x64>)
    77e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77ec:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_POLLING == State->TransferMode)
    77ee:	9b02      	ldr	r3, [sp, #8]
    77f0:	681b      	ldr	r3, [r3, #0]
    77f2:	2b00      	cmp	r3, #0
    77f4:	d115      	bne.n	7822 <Lpspi_Ip_ManageBuffers+0x56>
                - Receive: Both TDF (push CDM) and DRF (receive data) are set.
               In half duplex Slave mode:
                - Transmit: TDF is set only, RDF will never be set by RX FIFO have masked.
                - Receive: Both TDF and RDF are set. But only process for RDF to receive data. In this case, State->CurrentTxFifoSlot will be set to 0 */
            if(
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    77f6:	9b03      	ldr	r3, [sp, #12]
    77f8:	695b      	ldr	r3, [r3, #20]
    77fa:	f003 0302 	and.w	r3, r3, #2
            if(
    77fe:	2b00      	cmp	r3, #0
    7800:	d10a      	bne.n	7818 <Lpspi_Ip_ManageBuffers+0x4c>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    7802:	9b03      	ldr	r3, [sp, #12]
    7804:	695b      	ldr	r3, [r3, #20]
    7806:	f003 0301 	and.w	r3, r3, #1
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    780a:	2b00      	cmp	r3, #0
    780c:	d009      	beq.n	7822 <Lpspi_Ip_ManageBuffers+0x56>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    780e:	9b02      	ldr	r3, [sp, #8]
    7810:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    7814:	2b00      	cmp	r3, #0
    7816:	d004      	beq.n	7822 <Lpspi_Ip_ManageBuffers+0x56>
                    Lpspi_Ip_TransferProcessHalfDuplex(Instance);
                }
                else
                #endif
                {
                    Lpspi_Ip_TransferProcess(Instance); 
    7818:	f89d 3007 	ldrb.w	r3, [sp, #7]
    781c:	4618      	mov	r0, r3
    781e:	f7ff f8cd 	bl	69bc <Lpspi_Ip_TransferProcess>
                Lpspi_Ip_IrqTxDmaHandler(Instance);
            }
        }
        #endif
    }
}
    7822:	bf00      	nop
    7824:	b005      	add	sp, #20
    7826:	f85d fb04 	ldr.w	pc, [sp], #4
    782a:	bf00      	nop
    782c:	0000ae50 	.word	0x0000ae50
    7830:	1fff8d38 	.word	0x1fff8d38

00007834 <Lpspi_Ip_UpdateFrameSize>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_UpdateFrameSize(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint16 FrameSize)
{
    7834:	b084      	sub	sp, #16
    7836:	9001      	str	r0, [sp, #4]
    7838:	460b      	mov	r3, r1
    783a:	f8ad 3002 	strh.w	r3, [sp, #2]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    783e:	2300      	movs	r3, #0
    7840:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    DevAssert(LPSPI_IP_FRAMESIZE_MAX_U16 >= FrameSize);
    DevAssert(LPSPI_IP_FRAMESIZE_MIN_U16 <= FrameSize);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    7842:	9b01      	ldr	r3, [sp, #4]
    7844:	781b      	ldrb	r3, [r3, #0]
    7846:	461a      	mov	r2, r3
    7848:	4b09      	ldr	r3, [pc, #36]	; (7870 <Lpspi_Ip_UpdateFrameSize+0x3c>)
    784a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    784e:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Frame size can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    7850:	9b02      	ldr	r3, [sp, #8]
    7852:	685b      	ldr	r3, [r3, #4]
    7854:	2b02      	cmp	r3, #2
    7856:	d005      	beq.n	7864 <Lpspi_Ip_UpdateFrameSize+0x30>
    {
        ExternalDevice->DeviceParams->FrameSize = FrameSize;
    7858:	9b01      	ldr	r3, [sp, #4]
    785a:	68db      	ldr	r3, [r3, #12]
    785c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    7860:	801a      	strh	r2, [r3, #0]
    7862:	e001      	b.n	7868 <Lpspi_Ip_UpdateFrameSize+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    7864:	2301      	movs	r3, #1
    7866:	9303      	str	r3, [sp, #12]
    }
    return Status;
    7868:	9b03      	ldr	r3, [sp, #12]
}
    786a:	4618      	mov	r0, r3
    786c:	b004      	add	sp, #16
    786e:	4770      	bx	lr
    7870:	1fff8d38 	.word	0x1fff8d38

00007874 <Lpspi_Ip_UpdateLsb>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateLsb(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, boolean Lsb)
{
    7874:	b084      	sub	sp, #16
    7876:	9001      	str	r0, [sp, #4]
    7878:	460b      	mov	r3, r1
    787a:	f88d 3003 	strb.w	r3, [sp, #3]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    787e:	2300      	movs	r3, #0
    7880:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    7882:	9b01      	ldr	r3, [sp, #4]
    7884:	781b      	ldrb	r3, [r3, #0]
    7886:	461a      	mov	r2, r3
    7888:	4b09      	ldr	r3, [pc, #36]	; (78b0 <Lpspi_Ip_UpdateLsb+0x3c>)
    788a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    788e:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    7890:	9b02      	ldr	r3, [sp, #8]
    7892:	685b      	ldr	r3, [r3, #4]
    7894:	2b02      	cmp	r3, #2
    7896:	d005      	beq.n	78a4 <Lpspi_Ip_UpdateLsb+0x30>
    {
        ExternalDevice->DeviceParams->Lsb = Lsb;
    7898:	9b01      	ldr	r3, [sp, #4]
    789a:	68db      	ldr	r3, [r3, #12]
    789c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    78a0:	709a      	strb	r2, [r3, #2]
    78a2:	e001      	b.n	78a8 <Lpspi_Ip_UpdateLsb+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    78a4:	2301      	movs	r3, #1
    78a6:	9303      	str	r3, [sp, #12]
    }
    return Status;
    78a8:	9b03      	ldr	r3, [sp, #12]
}
    78aa:	4618      	mov	r0, r3
    78ac:	b004      	add	sp, #16
    78ae:	4770      	bx	lr
    78b0:	1fff8d38 	.word	0x1fff8d38

000078b4 <Lpspi_Ip_UpdateDefaultTransmitData>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateDefaultTransmitData(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint32 DefaultData)
{
    78b4:	b084      	sub	sp, #16
    78b6:	9001      	str	r0, [sp, #4]
    78b8:	9100      	str	r1, [sp, #0]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    78ba:	2300      	movs	r3, #0
    78bc:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    78be:	9b01      	ldr	r3, [sp, #4]
    78c0:	781b      	ldrb	r3, [r3, #0]
    78c2:	461a      	mov	r2, r3
    78c4:	4b09      	ldr	r3, [pc, #36]	; (78ec <Lpspi_Ip_UpdateDefaultTransmitData+0x38>)
    78c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    78ca:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    78cc:	9b02      	ldr	r3, [sp, #8]
    78ce:	685b      	ldr	r3, [r3, #4]
    78d0:	2b02      	cmp	r3, #2
    78d2:	d004      	beq.n	78de <Lpspi_Ip_UpdateDefaultTransmitData+0x2a>
    {
        ExternalDevice->DeviceParams->DefaultData = DefaultData;
    78d4:	9b01      	ldr	r3, [sp, #4]
    78d6:	68db      	ldr	r3, [r3, #12]
    78d8:	9a00      	ldr	r2, [sp, #0]
    78da:	605a      	str	r2, [r3, #4]
    78dc:	e001      	b.n	78e2 <Lpspi_Ip_UpdateDefaultTransmitData+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    78de:	2301      	movs	r3, #1
    78e0:	9303      	str	r3, [sp, #12]
    }
    return Status;
    78e2:	9b03      	ldr	r3, [sp, #12]
}
    78e4:	4618      	mov	r0, r3
    78e6:	b004      	add	sp, #16
    78e8:	4770      	bx	lr
    78ea:	bf00      	nop
    78ec:	1fff8d38 	.word	0x1fff8d38

000078f0 <Lpspi_Ip_UpdateTransferMode>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateTransferMode(uint8 Instance, Lpspi_Ip_ModeType Mode)
{
    78f0:	b084      	sub	sp, #16
    78f2:	4603      	mov	r3, r0
    78f4:	9100      	str	r1, [sp, #0]
    78f6:	f88d 3007 	strb.w	r3, [sp, #7]
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    78fa:	2300      	movs	r3, #0
    78fc:	9303      	str	r3, [sp, #12]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    78fe:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7902:	4a09      	ldr	r2, [pc, #36]	; (7928 <Lpspi_Ip_UpdateTransferMode+0x38>)
    7904:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7908:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Transfer mode can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    790a:	9b02      	ldr	r3, [sp, #8]
    790c:	685b      	ldr	r3, [r3, #4]
    790e:	2b02      	cmp	r3, #2
    7910:	d003      	beq.n	791a <Lpspi_Ip_UpdateTransferMode+0x2a>
    {
        State->TransferMode = Mode;
    7912:	9b02      	ldr	r3, [sp, #8]
    7914:	9a00      	ldr	r2, [sp, #0]
    7916:	601a      	str	r2, [r3, #0]
    7918:	e001      	b.n	791e <Lpspi_Ip_UpdateTransferMode+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    791a:	2301      	movs	r3, #1
    791c:	9303      	str	r3, [sp, #12]
    }
    return Status;
    791e:	9b03      	ldr	r3, [sp, #12]
}
    7920:	4618      	mov	r0, r3
    7922:	b004      	add	sp, #16
    7924:	4770      	bx	lr
    7926:	bf00      	nop
    7928:	1fff8d38 	.word	0x1fff8d38

0000792c <Lpspi_Ip_Cancel>:

void Lpspi_Ip_Cancel(uint8 Instance)
{
    792c:	b500      	push	{lr}
    792e:	b087      	sub	sp, #28
    7930:	4603      	mov	r3, r0
    7932:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    uint32 Cfgr1 = 0u;
    7936:	2300      	movs	r3, #0
    7938:	9305      	str	r3, [sp, #20]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    793a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    793e:	4a18      	ldr	r2, [pc, #96]	; (79a0 <Lpspi_Ip_Cancel+0x74>)
    7940:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7944:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    7946:	f89d 3007 	ldrb.w	r3, [sp, #7]
    794a:	4a16      	ldr	r2, [pc, #88]	; (79a4 <Lpspi_Ip_Cancel+0x78>)
    794c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7950:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10();
    7952:	f002 fb6b 	bl	a02c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>
    if (LPSPI_IP_BUSY == State->Status)
    7956:	9b03      	ldr	r3, [sp, #12]
    7958:	685b      	ldr	r3, [r3, #4]
    795a:	2b02      	cmp	r3, #2
    795c:	d11a      	bne.n	7994 <Lpspi_Ip_Cancel+0x68>
    {
        /* Mask Rx to discard received data */
        Base->TCR |= LPSPI_TCR_RXMSK(1);
    795e:	9b04      	ldr	r3, [sp, #16]
    7960:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7962:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
    7966:	9b04      	ldr	r3, [sp, #16]
    7968:	661a      	str	r2, [r3, #96]	; 0x60
        /* store CFGR1 and restore after all registers are reset */
        Cfgr1 = Base->CFGR1;
    796a:	9b04      	ldr	r3, [sp, #16]
    796c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    796e:	9305      	str	r3, [sp, #20]
        /* Disable interrupts and DMA requests. */
        /* Clear FIFO */
        /* RTF and RRF will not clear shifter, so RST must be used to ensure old Data in shifter will also be cleared. */
        Base->CR |= LPSPI_CR_RST_MASK;
    7970:	9b04      	ldr	r3, [sp, #16]
    7972:	691b      	ldr	r3, [r3, #16]
    7974:	f043 0202 	orr.w	r2, r3, #2
    7978:	9b04      	ldr	r3, [sp, #16]
    797a:	611a      	str	r2, [r3, #16]
        Base->CR &= ~LPSPI_CR_RST_MASK;
    797c:	9b04      	ldr	r3, [sp, #16]
    797e:	691b      	ldr	r3, [r3, #16]
    7980:	f023 0202 	bic.w	r2, r3, #2
    7984:	9b04      	ldr	r3, [sp, #16]
    7986:	611a      	str	r2, [r3, #16]
        /* restore CFGR1 */
        Base->CFGR1 = Cfgr1;
    7988:	9b04      	ldr	r3, [sp, #16]
    798a:	9a05      	ldr	r2, [sp, #20]
    798c:	625a      	str	r2, [r3, #36]	; 0x24
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->RxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->TxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
        }
        #endif
        /* set State to idle */
        State->Status = LPSPI_IP_IDLE;
    798e:	9b03      	ldr	r3, [sp, #12]
    7990:	2201      	movs	r2, #1
    7992:	605a      	str	r2, [r3, #4]
    }
    SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10();
    7994:	f002 fb76 	bl	a084 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>
}
    7998:	bf00      	nop
    799a:	b007      	add	sp, #28
    799c:	f85d fb04 	ldr.w	pc, [sp], #4
    79a0:	0000ae50 	.word	0x0000ae50
    79a4:	1fff8d38 	.word	0x1fff8d38

000079a8 <Lpspi_Ip_IrqHandler>:
* @param[in]     Instance            Instance of the hardware unit.
*
* @implements Lpspi_Ip_IrqHandler_Activity
*/
void Lpspi_Ip_IrqHandler(uint8 Instance)
{
    79a8:	b500      	push	{lr}
    79aa:	b087      	sub	sp, #28
    79ac:	4603      	mov	r3, r0
    79ae:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    79b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    79b6:	4a18      	ldr	r2, [pc, #96]	; (7a18 <Lpspi_Ip_IrqHandler+0x70>)
    79b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79bc:	9305      	str	r3, [sp, #20]
    const Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    79be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    79c2:	4a16      	ldr	r2, [pc, #88]	; (7a1c <Lpspi_Ip_IrqHandler+0x74>)
    79c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79c8:	9304      	str	r3, [sp, #16]
    uint32 IrqFlags = 0u;
    79ca:	2300      	movs	r3, #0
    79cc:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != State)
    79ce:	9b04      	ldr	r3, [sp, #16]
    79d0:	2b00      	cmp	r3, #0
    79d2:	d016      	beq.n	7a02 <Lpspi_Ip_IrqHandler+0x5a>
    {
        /* the driver has been initialized */
        IrqFlags = Base->SR & (LPSPI_SR_TDF_MASK | LPSPI_SR_RDF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK);
    79d4:	9b05      	ldr	r3, [sp, #20]
    79d6:	695a      	ldr	r2, [r3, #20]
    79d8:	f641 0303 	movw	r3, #6147	; 0x1803
    79dc:	4013      	ands	r3, r2
    79de:	9303      	str	r3, [sp, #12]
        IrqFlags &= Base->IER & (LPSPI_IER_TDIE_MASK | LPSPI_IER_RDIE_MASK | LPSPI_IER_TEIE_MASK | LPSPI_IER_REIE_MASK);
    79e0:	9b05      	ldr	r3, [sp, #20]
    79e2:	699a      	ldr	r2, [r3, #24]
    79e4:	f641 0303 	movw	r3, #6147	; 0x1803
    79e8:	4013      	ands	r3, r2
    79ea:	9a03      	ldr	r2, [sp, #12]
    79ec:	4013      	ands	r3, r2
    79ee:	9303      	str	r3, [sp, #12]
        if (0u != IrqFlags)
    79f0:	9b03      	ldr	r3, [sp, #12]
    79f2:	2b00      	cmp	r3, #0
    79f4:	d00b      	beq.n	7a0e <Lpspi_Ip_IrqHandler+0x66>
                Lpspi_Ip_TransferProcessHalfDuplex(Instance);    
            }
            else
            #endif
            {
                Lpspi_Ip_TransferProcess(Instance); 
    79f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    79fa:	4618      	mov	r0, r3
    79fc:	f7fe ffde 	bl	69bc <Lpspi_Ip_TransferProcess>
    {
        /* the driver has not been initialized */
        /* clear all flags */
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    }
}
    7a00:	e005      	b.n	7a0e <Lpspi_Ip_IrqHandler+0x66>
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    7a02:	9b05      	ldr	r3, [sp, #20]
    7a04:	695b      	ldr	r3, [r3, #20]
    7a06:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    7a0a:	9b05      	ldr	r3, [sp, #20]
    7a0c:	615a      	str	r2, [r3, #20]
}
    7a0e:	bf00      	nop
    7a10:	b007      	add	sp, #28
    7a12:	f85d fb04 	ldr.w	pc, [sp], #4
    7a16:	bf00      	nop
    7a18:	0000ae50 	.word	0x0000ae50
    7a1c:	1fff8d38 	.word	0x1fff8d38

00007a20 <Lpspi_Ip_GetStatus>:
* @param[in]        Instance - SPI peripheral instance number.
*
* @return           Lpspi_Ip_HwStatusType
*/
Lpspi_Ip_HwStatusType Lpspi_Ip_GetStatus(uint8 Instance)
{
    7a20:	b084      	sub	sp, #16
    7a22:	4603      	mov	r3, r0
    7a24:	f88d 3007 	strb.w	r3, [sp, #7]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_HwStatusType Status = LPSPI_IP_UNINIT;
    7a28:	2300      	movs	r3, #0
    7a2a:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    7a2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7a30:	4a06      	ldr	r2, [pc, #24]	; (7a4c <Lpspi_Ip_GetStatus+0x2c>)
    7a32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a36:	9302      	str	r3, [sp, #8]
    if (State != NULL_PTR)
    7a38:	9b02      	ldr	r3, [sp, #8]
    7a3a:	2b00      	cmp	r3, #0
    7a3c:	d002      	beq.n	7a44 <Lpspi_Ip_GetStatus+0x24>
    {
        Status = State->Status;
    7a3e:	9b02      	ldr	r3, [sp, #8]
    7a40:	685b      	ldr	r3, [r3, #4]
    7a42:	9303      	str	r3, [sp, #12]
    }
    
    return Status;
    7a44:	9b03      	ldr	r3, [sp, #12]
}
    7a46:	4618      	mov	r0, r3
    7a48:	b004      	add	sp, #16
    7a4a:	4770      	bx	lr
    7a4c:	1fff8d38 	.word	0x1fff8d38

00007a50 <Spi_CheckInit>:
static inline Std_ReturnType Spi_CheckInit
    ( 
        const Spi_ConfigType *ConfigPtr,
        uint32 SpiCoreID
    )
{
    7a50:	b086      	sub	sp, #24
    7a52:	9001      	str	r0, [sp, #4]
    7a54:	9100      	str	r1, [sp, #0]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    7a56:	2300      	movs	r3, #0
    7a58:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 Sequence;
#endif

#if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
    /* Configuration sizes must be checked for Post Build & Link Time configurations */
    Channel  = (uint32)(ConfigPtr->SpiMaxChannel);
    7a5c:	9b01      	ldr	r3, [sp, #4]
    7a5e:	789b      	ldrb	r3, [r3, #2]
    7a60:	9304      	str	r3, [sp, #16]
    Job      = (uint32)(ConfigPtr->SpiMaxJob);
    7a62:	9b01      	ldr	r3, [sp, #4]
    7a64:	889b      	ldrh	r3, [r3, #4]
    7a66:	9303      	str	r3, [sp, #12]
    Sequence = (uint32)(ConfigPtr->SpiMaxSequence);
    7a68:	9b01      	ldr	r3, [sp, #4]
    7a6a:	799b      	ldrb	r3, [r3, #6]
    7a6c:	9302      	str	r3, [sp, #8]

    if ((Channel >= SPI_MAX_CHANNEL) || (Job >= SPI_MAX_JOB) || (Sequence >= SPI_MAX_SEQUENCE))
    7a6e:	9b04      	ldr	r3, [sp, #16]
    7a70:	2b03      	cmp	r3, #3
    7a72:	d805      	bhi.n	7a80 <Spi_CheckInit+0x30>
    7a74:	9b03      	ldr	r3, [sp, #12]
    7a76:	2b01      	cmp	r3, #1
    7a78:	d802      	bhi.n	7a80 <Spi_CheckInit+0x30>
    7a7a:	9b02      	ldr	r3, [sp, #8]
    7a7c:	2b01      	cmp	r3, #1
    7a7e:	d902      	bls.n	7a86 <Spi_CheckInit+0x36>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    7a80:	2301      	movs	r3, #1
    7a82:	f88d 3017 	strb.w	r3, [sp, #23]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_CONFIG_OUT_OF_RANGE);
#endif
    }
    if (SpiCoreID != ConfigPtr->SpiCoreUse)
    7a86:	9b01      	ldr	r3, [sp, #4]
    7a88:	689b      	ldr	r3, [r3, #8]
    7a8a:	9a00      	ldr	r2, [sp, #0]
    7a8c:	429a      	cmp	r2, r3
    7a8e:	d002      	beq.n	7a96 <Spi_CheckInit+0x46>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    7a90:	2301      	movs	r3, #1
    7a92:	f88d 3017 	strb.w	r3, [sp, #23]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_INVALID_POINTER);
#endif
    }
#endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */

    return CheckStatus;
    7a96:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    7a9a:	4618      	mov	r0, r3
    7a9c:	b006      	add	sp, #24
    7a9e:	4770      	bx	lr

00007aa0 <Spi_SyncJobsTranfer>:
static Std_ReturnType Spi_SyncJobsTranfer
    (
        const Spi_SequenceConfigType *SequenceConfig,
        uint32 SpiCoreID
    )
{
    7aa0:	b500      	push	{lr}
    7aa2:	b089      	sub	sp, #36	; 0x24
    7aa4:	9001      	str	r0, [sp, #4]
    7aa6:	9100      	str	r1, [sp, #0]
    Spi_JobType JobsCount;
    const Spi_JobType *JobIndexList;
    Spi_JobType Job;
    Spi_JobStateType *JobState;
    const Spi_JobConfigType *JobConfig;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    7aa8:	2300      	movs	r3, #0
    7aaa:	f88d 3017 	strb.w	r3, [sp, #23]
    
    /* Get the number of jobs in the sequence */
    JobsCount = SequenceConfig->NumJobs;
    7aae:	9b01      	ldr	r3, [sp, #4]
    7ab0:	881b      	ldrh	r3, [r3, #0]
    7ab2:	f8ad 301e 	strh.w	r3, [sp, #30]
    JobIndexList = SequenceConfig->JobIndexList;
    7ab6:	9b01      	ldr	r3, [sp, #4]
    7ab8:	689b      	ldr	r3, [r3, #8]
    7aba:	9306      	str	r3, [sp, #24]
    while (0u < JobsCount)
    7abc:	e072      	b.n	7ba4 <Spi_SyncJobsTranfer+0x104>
    {
        /* Get the job id */
        Job = *JobIndexList;
    7abe:	9b06      	ldr	r3, [sp, #24]
    7ac0:	881b      	ldrh	r3, [r3, #0]
    7ac2:	f8ad 3014 	strh.w	r3, [sp, #20]
        /* Set the job status as pending */
        JobState = &Spi_axSpiJobState[Job];
    7ac6:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7aca:	009b      	lsls	r3, r3, #2
    7acc:	4a3a      	ldr	r2, [pc, #232]	; (7bb8 <Spi_SyncJobsTranfer+0x118>)
    7ace:	4413      	add	r3, r2
    7ad0:	9304      	str	r3, [sp, #16]
        JobState->Result = SPI_JOB_PENDING;
    7ad2:	9b04      	ldr	r3, [sp, #16]
    7ad4:	2201      	movs	r2, #1
    7ad6:	601a      	str	r2, [r3, #0]
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    7ad8:	4a38      	ldr	r2, [pc, #224]	; (7bbc <Spi_SyncJobsTranfer+0x11c>)
    7ada:	9b00      	ldr	r3, [sp, #0]
    7adc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ae0:	691a      	ldr	r2, [r3, #16]
    7ae2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7ae6:	009b      	lsls	r3, r3, #2
    7ae8:	4413      	add	r3, r2
    7aea:	681b      	ldr	r3, [r3, #0]
    7aec:	9303      	str	r3, [sp, #12]
        
        /* start job notification to assert the non-cs pin,
        when non-cs pin is used as chipselect*/
        if (NULL_PTR != JobConfig->StartNotification)
    7aee:	9b03      	ldr	r3, [sp, #12]
    7af0:	68db      	ldr	r3, [r3, #12]
    7af2:	2b00      	cmp	r3, #0
    7af4:	d002      	beq.n	7afc <Spi_SyncJobsTranfer+0x5c>
        {
            JobConfig->StartNotification();
    7af6:	9b03      	ldr	r3, [sp, #12]
    7af8:	68db      	ldr	r3, [r3, #12]
    7afa:	4798      	blx	r3
        else
        {
            /* Do nothing */
        }
        /* Mark HWUnit as busy */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_BUSY;
    7afc:	9b03      	ldr	r3, [sp, #12]
    7afe:	7f1b      	ldrb	r3, [r3, #28]
    7b00:	4619      	mov	r1, r3
    7b02:	4b2f      	ldr	r3, [pc, #188]	; (7bc0 <Spi_SyncJobsTranfer+0x120>)
    7b04:	2202      	movs	r2, #2
    7b06:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        Status = Spi_Ipw_SyncTransmit(JobConfig, SpiCoreID);
    7b0a:	9900      	ldr	r1, [sp, #0]
    7b0c:	9803      	ldr	r0, [sp, #12]
    7b0e:	f000 fc5f 	bl	83d0 <Spi_Ipw_SyncTransmit>
    7b12:	4603      	mov	r3, r0
    7b14:	f88d 3017 	strb.w	r3, [sp, #23]
        
        /* release HWUnit */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_IDLE;
    7b18:	9b03      	ldr	r3, [sp, #12]
    7b1a:	7f1b      	ldrb	r3, [r3, #28]
    7b1c:	4619      	mov	r1, r3
    7b1e:	4b28      	ldr	r3, [pc, #160]	; (7bc0 <Spi_SyncJobsTranfer+0x120>)
    7b20:	2201      	movs	r2, #1
    7b22:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        if ((Std_ReturnType)E_OK == Status)
    7b26:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7b2a:	2b00      	cmp	r3, #0
    7b2c:	d10a      	bne.n	7b44 <Spi_SyncJobsTranfer+0xa4>
        {
            /* Job is done set the status as OK */
            JobState->Result = SPI_JOB_OK;
    7b2e:	9b04      	ldr	r3, [sp, #16]
    7b30:	2200      	movs	r2, #0
    7b32:	601a      	str	r2, [r3, #0]
            /* Perform job EndNotification (if there is one) */
            if (NULL_PTR != JobConfig->EndNotification)
    7b34:	9b03      	ldr	r3, [sp, #12]
    7b36:	689b      	ldr	r3, [r3, #8]
    7b38:	2b00      	cmp	r3, #0
    7b3a:	d02b      	beq.n	7b94 <Spi_SyncJobsTranfer+0xf4>
            {
                JobConfig->EndNotification();
    7b3c:	9b03      	ldr	r3, [sp, #12]
    7b3e:	689b      	ldr	r3, [r3, #8]
    7b40:	4798      	blx	r3
    7b42:	e027      	b.n	7b94 <Spi_SyncJobsTranfer+0xf4>
            /* transmission failed */
            /* set the remaining job status (including the current one) as FAILED */
            do
            {
                /* Set the job status as FAILED */
                Spi_axSpiJobState[*JobIndexList].Result = SPI_JOB_FAILED;
    7b44:	9b06      	ldr	r3, [sp, #24]
    7b46:	881b      	ldrh	r3, [r3, #0]
    7b48:	4619      	mov	r1, r3
    7b4a:	4b1b      	ldr	r3, [pc, #108]	; (7bb8 <Spi_SyncJobsTranfer+0x118>)
    7b4c:	2202      	movs	r2, #2
    7b4e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
                /* Update pointer position for JobConfig */
                JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[*JobIndexList].JobCfg;
    7b52:	4a1a      	ldr	r2, [pc, #104]	; (7bbc <Spi_SyncJobsTranfer+0x11c>)
    7b54:	9b00      	ldr	r3, [sp, #0]
    7b56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b5a:	691a      	ldr	r2, [r3, #16]
    7b5c:	9b06      	ldr	r3, [sp, #24]
    7b5e:	881b      	ldrh	r3, [r3, #0]
    7b60:	009b      	lsls	r3, r3, #2
    7b62:	4413      	add	r3, r2
    7b64:	681b      	ldr	r3, [r3, #0]
    7b66:	9303      	str	r3, [sp, #12]
                /* Perform job EndNotification (if there is one) */
                if (NULL_PTR != JobConfig->EndNotification)
    7b68:	9b03      	ldr	r3, [sp, #12]
    7b6a:	689b      	ldr	r3, [r3, #8]
    7b6c:	2b00      	cmp	r3, #0
    7b6e:	d002      	beq.n	7b76 <Spi_SyncJobsTranfer+0xd6>
                {
                    JobConfig->EndNotification();
    7b70:	9b03      	ldr	r3, [sp, #12]
    7b72:	689b      	ldr	r3, [r3, #8]
    7b74:	4798      	blx	r3
                }
                else
                {
                    /* Do nothing */
                }
                JobIndexList++;
    7b76:	9b06      	ldr	r3, [sp, #24]
    7b78:	3302      	adds	r3, #2
    7b7a:	9306      	str	r3, [sp, #24]
                JobsCount--;
    7b7c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    7b80:	3b01      	subs	r3, #1
    7b82:	f8ad 301e 	strh.w	r3, [sp, #30]
            } while (0u < JobsCount);
    7b86:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    7b8a:	2b00      	cmp	r3, #0
    7b8c:	d1da      	bne.n	7b44 <Spi_SyncJobsTranfer+0xa4>
            JobsCount = 1u;  /* needed to end correctly the outer loop */
    7b8e:	2301      	movs	r3, #1
    7b90:	f8ad 301e 	strh.w	r3, [sp, #30]
        }
        /* iterate to next job in sequence */
        JobIndexList++;
    7b94:	9b06      	ldr	r3, [sp, #24]
    7b96:	3302      	adds	r3, #2
    7b98:	9306      	str	r3, [sp, #24]
        JobsCount--;
    7b9a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    7b9e:	3b01      	subs	r3, #1
    7ba0:	f8ad 301e 	strh.w	r3, [sp, #30]
    while (0u < JobsCount)
    7ba4:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    7ba8:	2b00      	cmp	r3, #0
    7baa:	d188      	bne.n	7abe <Spi_SyncJobsTranfer+0x1e>
    } /* while (JobsCount > 0u) */
    return Status;
    7bac:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    7bb0:	4618      	mov	r0, r3
    7bb2:	b009      	add	sp, #36	; 0x24
    7bb4:	f85d fb04 	ldr.w	pc, [sp], #4
    7bb8:	1fff8d58 	.word	0x1fff8d58
    7bbc:	1fff8d4c 	.word	0x1fff8d4c
    7bc0:	1fff8d44 	.word	0x1fff8d44

00007bc4 <Spi_InitChannelsJobsSeqsState>:
*/
static void Spi_InitChannelsJobsSeqsState
    (
        uint32 SpiCoreID      
    )
{
    7bc4:	b088      	sub	sp, #32
    7bc6:	9001      	str	r0, [sp, #4]
#endif
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_JobConfigType *JobConfig;
    const Spi_SequenceConfigType *SequenceConfig;
    
    for (Channel = 0u;
    7bc8:	2300      	movs	r3, #0
    7bca:	9307      	str	r3, [sp, #28]
    7bcc:	e034      	b.n	7c38 <Spi_InitChannelsJobsSeqsState+0x74>
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
        Channel++)
    {
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    7bce:	4a4a      	ldr	r2, [pc, #296]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7bd0:	9b01      	ldr	r3, [sp, #4]
    7bd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bd6:	68da      	ldr	r2, [r3, #12]
    7bd8:	9b07      	ldr	r3, [sp, #28]
    7bda:	009b      	lsls	r3, r3, #2
    7bdc:	4413      	add	r3, r2
    7bde:	681b      	ldr	r3, [r3, #0]
    7be0:	9302      	str	r3, [sp, #8]
        /* Check which channel has assigned for current core */
        if((NULL_PTR != ChannelConfig) && (SpiCoreID == ChannelConfig->SpiCoreUse))
    7be2:	9b02      	ldr	r3, [sp, #8]
    7be4:	2b00      	cmp	r3, #0
    7be6:	d024      	beq.n	7c32 <Spi_InitChannelsJobsSeqsState+0x6e>
    7be8:	9b02      	ldr	r3, [sp, #8]
    7bea:	695b      	ldr	r3, [r3, #20]
    7bec:	9a01      	ldr	r2, [sp, #4]
    7bee:	429a      	cmp	r2, r3
    7bf0:	d11f      	bne.n	7c32 <Spi_InitChannelsJobsSeqsState+0x6e>
        {
            /* Check if configured buffers are External (EB) */
            if (EB == ChannelConfig->BufferType)
    7bf2:	9b02      	ldr	r3, [sp, #8]
    7bf4:	681b      	ldr	r3, [r3, #0]
    7bf6:	2b01      	cmp	r3, #1
    7bf8:	d10e      	bne.n	7c18 <Spi_InitChannelsJobsSeqsState+0x54>
            {
                /* Initialize all buffers */
                ChannelConfig->BufferDescriptor->ExternalBufferTX = NULL_PTR;
    7bfa:	9b02      	ldr	r3, [sp, #8]
    7bfc:	691b      	ldr	r3, [r3, #16]
    7bfe:	2200      	movs	r2, #0
    7c00:	601a      	str	r2, [r3, #0]
                ChannelConfig->BufferDescriptor->BufferRX = NULL_PTR;
    7c02:	9b02      	ldr	r3, [sp, #8]
    7c04:	691b      	ldr	r3, [r3, #16]
    7c06:	2200      	movs	r2, #0
    7c08:	609a      	str	r2, [r3, #8]
    
                /* Channel length is zero for unconfigured external buffers */
                Spi_axSpiChannelState[Channel].Length = (Spi_NumberOfDataType) 0;
    7c0a:	4a3c      	ldr	r2, [pc, #240]	; (7cfc <Spi_InitChannelsJobsSeqsState+0x138>)
    7c0c:	9b07      	ldr	r3, [sp, #28]
    7c0e:	009b      	lsls	r3, r3, #2
    7c10:	4413      	add	r3, r2
    7c12:	2200      	movs	r2, #0
    7c14:	805a      	strh	r2, [r3, #2]
    7c16:	e007      	b.n	7c28 <Spi_InitChannelsJobsSeqsState+0x64>
            }
            else
            {
                /* Setup channel length according to configuration */
                Spi_axSpiChannelState[Channel].Length = ChannelConfig->Length;
    7c18:	9b02      	ldr	r3, [sp, #8]
    7c1a:	8999      	ldrh	r1, [r3, #12]
    7c1c:	4a37      	ldr	r2, [pc, #220]	; (7cfc <Spi_InitChannelsJobsSeqsState+0x138>)
    7c1e:	9b07      	ldr	r3, [sp, #28]
    7c20:	009b      	lsls	r3, r3, #2
    7c22:	4413      	add	r3, r2
    7c24:	460a      	mov	r2, r1
    7c26:	805a      	strh	r2, [r3, #2]
            }
            Spi_axSpiChannelState[Channel].Flags = SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    7c28:	4a34      	ldr	r2, [pc, #208]	; (7cfc <Spi_InitChannelsJobsSeqsState+0x138>)
    7c2a:	9b07      	ldr	r3, [sp, #28]
    7c2c:	2101      	movs	r1, #1
    7c2e:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
        Channel++)
    7c32:	9b07      	ldr	r3, [sp, #28]
    7c34:	3301      	adds	r3, #1
    7c36:	9307      	str	r3, [sp, #28]
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
    7c38:	4a2f      	ldr	r2, [pc, #188]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7c3a:	9b01      	ldr	r3, [sp, #4]
    7c3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c40:	789b      	ldrb	r3, [r3, #2]
    7c42:	461a      	mov	r2, r3
    for (Channel = 0u;
    7c44:	9b07      	ldr	r3, [sp, #28]
    7c46:	4293      	cmp	r3, r2
    7c48:	d9c1      	bls.n	7bce <Spi_InitChannelsJobsSeqsState+0xa>
        }
    }
    
    /* initialize job results */
    for (Job = 0u;
    7c4a:	2300      	movs	r3, #0
    7c4c:	9306      	str	r3, [sp, #24]
    7c4e:	e019      	b.n	7c84 <Spi_InitChannelsJobsSeqsState+0xc0>
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
        Job++)
    {
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    7c50:	4a29      	ldr	r2, [pc, #164]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7c52:	9b01      	ldr	r3, [sp, #4]
    7c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c58:	691a      	ldr	r2, [r3, #16]
    7c5a:	9b06      	ldr	r3, [sp, #24]
    7c5c:	009b      	lsls	r3, r3, #2
    7c5e:	4413      	add	r3, r2
    7c60:	681b      	ldr	r3, [r3, #0]
    7c62:	9303      	str	r3, [sp, #12]
        if((NULL_PTR != JobConfig) && (SpiCoreID == JobConfig->SpiCoreUse))
    7c64:	9b03      	ldr	r3, [sp, #12]
    7c66:	2b00      	cmp	r3, #0
    7c68:	d009      	beq.n	7c7e <Spi_InitChannelsJobsSeqsState+0xba>
    7c6a:	9b03      	ldr	r3, [sp, #12]
    7c6c:	695b      	ldr	r3, [r3, #20]
    7c6e:	9a01      	ldr	r2, [sp, #4]
    7c70:	429a      	cmp	r2, r3
    7c72:	d104      	bne.n	7c7e <Spi_InitChannelsJobsSeqsState+0xba>
        {
            Spi_axSpiJobState[Job].Result = SPI_JOB_OK;
    7c74:	4a22      	ldr	r2, [pc, #136]	; (7d00 <Spi_InitChannelsJobsSeqsState+0x13c>)
    7c76:	9b06      	ldr	r3, [sp, #24]
    7c78:	2100      	movs	r1, #0
    7c7a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Job++)
    7c7e:	9b06      	ldr	r3, [sp, #24]
    7c80:	3301      	adds	r3, #1
    7c82:	9306      	str	r3, [sp, #24]
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
    7c84:	4a1c      	ldr	r2, [pc, #112]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7c86:	9b01      	ldr	r3, [sp, #4]
    7c88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c8c:	889b      	ldrh	r3, [r3, #4]
    7c8e:	461a      	mov	r2, r3
    for (Job = 0u;
    7c90:	9b06      	ldr	r3, [sp, #24]
    7c92:	4293      	cmp	r3, r2
    7c94:	d9dc      	bls.n	7c50 <Spi_InitChannelsJobsSeqsState+0x8c>
            Spi_axSpiJobState[Job].AsyncCrtSequenceState = NULL_PTR;
        #endif
        }
    }
    
    for (Sequence = 0u;
    7c96:	2300      	movs	r3, #0
    7c98:	9305      	str	r3, [sp, #20]
    7c9a:	e01f      	b.n	7cdc <Spi_InitChannelsJobsSeqsState+0x118>
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
        Sequence++)
    {
        SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    7c9c:	4a16      	ldr	r2, [pc, #88]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7c9e:	9b01      	ldr	r3, [sp, #4]
    7ca0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ca4:	695a      	ldr	r2, [r3, #20]
    7ca6:	9b05      	ldr	r3, [sp, #20]
    7ca8:	009b      	lsls	r3, r3, #2
    7caa:	4413      	add	r3, r2
    7cac:	681b      	ldr	r3, [r3, #0]
    7cae:	9304      	str	r3, [sp, #16]
        if ((NULL_PTR != SequenceConfig) && (SpiCoreID == SequenceConfig->SpiCoreUse))
    7cb0:	9b04      	ldr	r3, [sp, #16]
    7cb2:	2b00      	cmp	r3, #0
    7cb4:	d00f      	beq.n	7cd6 <Spi_InitChannelsJobsSeqsState+0x112>
    7cb6:	9b04      	ldr	r3, [sp, #16]
    7cb8:	685b      	ldr	r3, [r3, #4]
    7cba:	9a01      	ldr	r2, [sp, #4]
    7cbc:	429a      	cmp	r2, r3
    7cbe:	d10a      	bne.n	7cd6 <Spi_InitChannelsJobsSeqsState+0x112>
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
            Spi_axSpiSequenceState[Sequence].Sequence = SequenceConfig;
            #endif
    
            /* initialize sequence results */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_OK;
    7cc0:	4a10      	ldr	r2, [pc, #64]	; (7d04 <Spi_InitChannelsJobsSeqsState+0x140>)
    7cc2:	9b05      	ldr	r3, [sp, #20]
    7cc4:	2100      	movs	r1, #0
    7cc6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* SPI135: Spi_SyncTransmit() must fail if an other sync transmission
                    is ongoing.*/
            /* mark all HW units as used by the sync transmission, in order to
                force the mutual exclusion of Spi_SyncTransmit() calls */
    
            Spi_au32SpiSeqUsedHWUnits[Sequence] = 0xFFFFFFFFU;
    7cca:	4a0f      	ldr	r2, [pc, #60]	; (7d08 <Spi_InitChannelsJobsSeqsState+0x144>)
    7ccc:	9b05      	ldr	r3, [sp, #20]
    7cce:	f04f 31ff 	mov.w	r1, #4294967295
    7cd2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Sequence++)
    7cd6:	9b05      	ldr	r3, [sp, #20]
    7cd8:	3301      	adds	r3, #1
    7cda:	9305      	str	r3, [sp, #20]
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
    7cdc:	4a06      	ldr	r2, [pc, #24]	; (7cf8 <Spi_InitChannelsJobsSeqsState+0x134>)
    7cde:	9b01      	ldr	r3, [sp, #4]
    7ce0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ce4:	799b      	ldrb	r3, [r3, #6]
    7ce6:	461a      	mov	r2, r3
    for (Sequence = 0u;
    7ce8:	9b05      	ldr	r3, [sp, #20]
    7cea:	4293      	cmp	r3, r2
    7cec:	d9d6      	bls.n	7c9c <Spi_InitChannelsJobsSeqsState+0xd8>
        else
        {
            /* Do nothing */
        }
    }
}
    7cee:	bf00      	nop
    7cf0:	bf00      	nop
    7cf2:	b008      	add	sp, #32
    7cf4:	4770      	bx	lr
    7cf6:	bf00      	nop
    7cf8:	1fff8d4c 	.word	0x1fff8d4c
    7cfc:	1fff8d60 	.word	0x1fff8d60
    7d00:	1fff8d58 	.word	0x1fff8d58
    7d04:	1fff8d50 	.word	0x1fff8d50
    7d08:	1fff8d70 	.word	0x1fff8d70

00007d0c <Spi_GetStatusAsyncCheckHwBusy>:
*/
static Spi_StatusType Spi_GetStatusAsyncCheckHwBusy
    (
        uint32 SpiCoreID
    )
{
    7d0c:	b084      	sub	sp, #16
    7d0e:	9001      	str	r0, [sp, #4]
    Spi_StatusType StatusFlag = SPI_IDLE;
    7d10:	2301      	movs	r3, #1
    7d12:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    7d14:	2300      	movs	r3, #0
    7d16:	f88d 300b 	strb.w	r3, [sp, #11]
    7d1a:	e028      	b.n	7d6e <Spi_GetStatusAsyncCheckHwBusy+0x62>
    {
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7d1c:	4a18      	ldr	r2, [pc, #96]	; (7d80 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    7d1e:	9b01      	ldr	r3, [sp, #4]
    7d20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d24:	69da      	ldr	r2, [r3, #28]
    7d26:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7d2a:	009b      	lsls	r3, r3, #2
    7d2c:	4413      	add	r3, r2
    7d2e:	681b      	ldr	r3, [r3, #0]
    7d30:	2b00      	cmp	r3, #0
    7d32:	d017      	beq.n	7d64 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    7d34:	4a12      	ldr	r2, [pc, #72]	; (7d80 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    7d36:	9b01      	ldr	r3, [sp, #4]
    7d38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d3c:	69da      	ldr	r2, [r3, #28]
    7d3e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7d42:	009b      	lsls	r3, r3, #2
    7d44:	4413      	add	r3, r2
    7d46:	681b      	ldr	r3, [r3, #0]
    7d48:	689b      	ldr	r3, [r3, #8]
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7d4a:	9a01      	ldr	r2, [sp, #4]
    7d4c:	429a      	cmp	r2, r3
    7d4e:	d109      	bne.n	7d64 <Spi_GetStatusAsyncCheckHwBusy+0x58>
           )
        {
            if (SPI_BUSY == Spi_axSpiHwUnitQueueArray[HWUnit].Status)
    7d50:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7d54:	4a0b      	ldr	r2, [pc, #44]	; (7d84 <Spi_GetStatusAsyncCheckHwBusy+0x78>)
    7d56:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    7d5a:	2b02      	cmp	r3, #2
    7d5c:	d102      	bne.n	7d64 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            {
                StatusFlag = SPI_BUSY;
    7d5e:	2302      	movs	r3, #2
    7d60:	9303      	str	r3, [sp, #12]
                break;
    7d62:	e008      	b.n	7d76 <Spi_GetStatusAsyncCheckHwBusy+0x6a>
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    7d64:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7d68:	3301      	adds	r3, #1
    7d6a:	f88d 300b 	strb.w	r3, [sp, #11]
    7d6e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7d72:	2b00      	cmp	r3, #0
    7d74:	d0d2      	beq.n	7d1c <Spi_GetStatusAsyncCheckHwBusy+0x10>
        else
        {
            /* Do nothing */
        }
    }
    return StatusFlag;
    7d76:	9b03      	ldr	r3, [sp, #12]
}
    7d78:	4618      	mov	r0, r3
    7d7a:	b004      	add	sp, #16
    7d7c:	4770      	bx	lr
    7d7e:	bf00      	nop
    7d80:	1fff8d4c 	.word	0x1fff8d4c
    7d84:	1fff8d44 	.word	0x1fff8d44

00007d88 <Spi_GetVersionInfo>:
/** @implements Spi_GetVersionInfo_Activity */
void Spi_GetVersionInfo 
    (
        Std_VersionInfoType *versioninfo
    )
{
    7d88:	b082      	sub	sp, #8
    7d8a:	9001      	str	r0, [sp, #4]
        (void)Det_ReportError((uint16)SPI_MODULE_ID,(uint8)0,SPI_GETVERSIONINFO_ID,SPI_E_PARAM_POINTER);
    }
    else
    {
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
    versioninfo->vendorID = (uint16)SPI_VENDOR_ID;
    7d8c:	9b01      	ldr	r3, [sp, #4]
    7d8e:	222b      	movs	r2, #43	; 0x2b
    7d90:	801a      	strh	r2, [r3, #0]
    versioninfo->moduleID = (uint8)SPI_MODULE_ID;
    7d92:	9b01      	ldr	r3, [sp, #4]
    7d94:	2253      	movs	r2, #83	; 0x53
    7d96:	805a      	strh	r2, [r3, #2]
    versioninfo->sw_major_version = (uint8)SPI_SW_MAJOR_VERSION;
    7d98:	9b01      	ldr	r3, [sp, #4]
    7d9a:	2202      	movs	r2, #2
    7d9c:	711a      	strb	r2, [r3, #4]
    versioninfo->sw_minor_version = (uint8)SPI_SW_MINOR_VERSION;
    7d9e:	9b01      	ldr	r3, [sp, #4]
    7da0:	2200      	movs	r2, #0
    7da2:	715a      	strb	r2, [r3, #5]
    versioninfo->sw_patch_version = (uint8)SPI_SW_PATCH_VERSION;
    7da4:	9b01      	ldr	r3, [sp, #4]
    7da6:	2200      	movs	r2, #0
    7da8:	719a      	strb	r2, [r3, #6]
#if(SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
}
    7daa:	bf00      	nop
    7dac:	b002      	add	sp, #8
    7dae:	4770      	bx	lr

00007db0 <Spi_Init>:
/** @implements Spi_Init_Activity */
void Spi_Init
    (
        const Spi_ConfigType *ConfigPtr
    )
{
    7db0:	b500      	push	{lr}
    7db2:	b085      	sub	sp, #20
    7db4:	9001      	str	r0, [sp, #4]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    7db6:	2300      	movs	r3, #0
    7db8:	f88d 300e 	strb.w	r3, [sp, #14]

    SpiCoreID = Spi_GetCoreID;
    7dbc:	2300      	movs	r3, #0
    7dbe:	9302      	str	r3, [sp, #8]
    CheckStatus = Spi_InitCheckDemError(SpiCoreID, ConfigPtr);
    if ((Std_ReturnType)E_OK == CheckStatus) 
    {
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/

    CheckStatus = Spi_CheckInit(ConfigPtr, SpiCoreID);
    7dc0:	9902      	ldr	r1, [sp, #8]
    7dc2:	9801      	ldr	r0, [sp, #4]
    7dc4:	f7ff fe44 	bl	7a50 <Spi_CheckInit>
    7dc8:	4603      	mov	r3, r0
    7dca:	f88d 300e 	strb.w	r3, [sp, #14]

    if((Std_ReturnType)E_OK == CheckStatus )
    7dce:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7dd2:	2b00      	cmp	r3, #0
    7dd4:	d144      	bne.n	7e60 <Spi_Init+0xb0>
    {
    #if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
        Spi_apxSpiConfigPtr[SpiCoreID] = ConfigPtr;
    7dd6:	4924      	ldr	r1, [pc, #144]	; (7e68 <Spi_Init+0xb8>)
    7dd8:	9b02      	ldr	r3, [sp, #8]
    7dda:	9a01      	ldr	r2, [sp, #4]
    7ddc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    #else /* (SPI_CONFIG_VARIANT == SPI_VARIANT_PRECOMPILE) */
        Spi_apxSpiConfigPtr[SpiCoreID] = Spi_PBCfgVariantPredefined[SpiCoreID];
    #endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */
    /* Initiate Channels, Jobs, Sequences state */
    Spi_InitChannelsJobsSeqsState(SpiCoreID);
    7de0:	9802      	ldr	r0, [sp, #8]
    7de2:	f7ff feef 	bl	7bc4 <Spi_InitChannelsJobsSeqsState>
        
        /* initialize all physical HWUnits */
        for (HWUnit = (Spi_HWUnitType) 0;
    7de6:	2300      	movs	r3, #0
    7de8:	f88d 300f 	strb.w	r3, [sp, #15]
    7dec:	e034      	b.n	7e58 <Spi_Init+0xa8>
            HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
            HWUnit++)
        {
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7dee:	4a1e      	ldr	r2, [pc, #120]	; (7e68 <Spi_Init+0xb8>)
    7df0:	9b02      	ldr	r3, [sp, #8]
    7df2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7df6:	69da      	ldr	r2, [r3, #28]
    7df8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7dfc:	009b      	lsls	r3, r3, #2
    7dfe:	4413      	add	r3, r2
    7e00:	681b      	ldr	r3, [r3, #0]
    7e02:	2b00      	cmp	r3, #0
    7e04:	d023      	beq.n	7e4e <Spi_Init+0x9e>
               (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    7e06:	4a18      	ldr	r2, [pc, #96]	; (7e68 <Spi_Init+0xb8>)
    7e08:	9b02      	ldr	r3, [sp, #8]
    7e0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e0e:	69da      	ldr	r2, [r3, #28]
    7e10:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e14:	009b      	lsls	r3, r3, #2
    7e16:	4413      	add	r3, r2
    7e18:	681b      	ldr	r3, [r3, #0]
    7e1a:	689b      	ldr	r3, [r3, #8]
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7e1c:	9a02      	ldr	r2, [sp, #8]
    7e1e:	429a      	cmp	r2, r3
    7e20:	d115      	bne.n	7e4e <Spi_Init+0x9e>
              )
            {
                Spi_Ipw_Init(HWUnit, Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig);
    7e22:	4a11      	ldr	r2, [pc, #68]	; (7e68 <Spi_Init+0xb8>)
    7e24:	9b02      	ldr	r3, [sp, #8]
    7e26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e2a:	69da      	ldr	r2, [r3, #28]
    7e2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e30:	009b      	lsls	r3, r3, #2
    7e32:	4413      	add	r3, r2
    7e34:	681a      	ldr	r2, [r3, #0]
    7e36:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e3a:	4611      	mov	r1, r2
    7e3c:	4618      	mov	r0, r3
    7e3e:	f000 fa8c 	bl	835a <Spi_Ipw_Init>

#if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
                /* initialize the Job lists => no scheduled job for the unit */
                Spi_InitJobsList(HWUnit);
#endif
                Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_IDLE;
    7e42:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e46:	4a09      	ldr	r2, [pc, #36]	; (7e6c <Spi_Init+0xbc>)
    7e48:	2101      	movs	r1, #1
    7e4a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
            HWUnit++)
    7e4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e52:	3301      	adds	r3, #1
    7e54:	f88d 300f 	strb.w	r3, [sp, #15]
        for (HWUnit = (Spi_HWUnitType) 0;
    7e58:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7e5c:	2b00      	cmp	r3, #0
    7e5e:	d0c6      	beq.n	7dee <Spi_Init+0x3e>
    }

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/
}
    7e60:	bf00      	nop
    7e62:	b005      	add	sp, #20
    7e64:	f85d fb04 	ldr.w	pc, [sp], #4
    7e68:	1fff8d4c 	.word	0x1fff8d4c
    7e6c:	1fff8d44 	.word	0x1fff8d44

00007e70 <Spi_DeInit>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_DeInit_Activity
*/
Std_ReturnType Spi_DeInit(void)
{
    7e70:	b500      	push	{lr}
    7e72:	b083      	sub	sp, #12
    Std_ReturnType TempExit = (Std_ReturnType)E_OK;
    7e74:	2300      	movs	r3, #0
    7e76:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;

    SpiCoreID = Spi_GetCoreID;
    7e7a:	2300      	movs	r3, #0
    7e7c:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Check if Spi Status is Busy */
        if (SPI_BUSY == Spi_GetStatus())
    7e7e:	f000 f8b1 	bl	7fe4 <Spi_GetStatus>
    7e82:	4603      	mov	r3, r0
    7e84:	2b02      	cmp	r3, #2
    7e86:	d103      	bne.n	7e90 <Spi_DeInit+0x20>
        {
            TempExit = E_NOT_OK;
    7e88:	2301      	movs	r3, #1
    7e8a:	f88d 3007 	strb.w	r3, [sp, #7]
    7e8e:	e037      	b.n	7f00 <Spi_DeInit+0x90>
        }
        else
        {
            /* De-initialize all physical HWUnits */
            for (HWUnit = (Spi_HWUnitType) 0;
    7e90:	2300      	movs	r3, #0
    7e92:	f88d 3006 	strb.w	r3, [sp, #6]
    7e96:	e02a      	b.n	7eee <Spi_DeInit+0x7e>
                 HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
                 HWUnit++)
            {
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7e98:	4a1c      	ldr	r2, [pc, #112]	; (7f0c <Spi_DeInit+0x9c>)
    7e9a:	9b00      	ldr	r3, [sp, #0]
    7e9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ea0:	69da      	ldr	r2, [r3, #28]
    7ea2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ea6:	009b      	lsls	r3, r3, #2
    7ea8:	4413      	add	r3, r2
    7eaa:	681b      	ldr	r3, [r3, #0]
    7eac:	2b00      	cmp	r3, #0
    7eae:	d019      	beq.n	7ee4 <Spi_DeInit+0x74>
                    (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    7eb0:	4a16      	ldr	r2, [pc, #88]	; (7f0c <Spi_DeInit+0x9c>)
    7eb2:	9b00      	ldr	r3, [sp, #0]
    7eb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7eb8:	69da      	ldr	r2, [r3, #28]
    7eba:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ebe:	009b      	lsls	r3, r3, #2
    7ec0:	4413      	add	r3, r2
    7ec2:	681b      	ldr	r3, [r3, #0]
    7ec4:	689b      	ldr	r3, [r3, #8]
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    7ec6:	9a00      	ldr	r2, [sp, #0]
    7ec8:	429a      	cmp	r2, r3
    7eca:	d10b      	bne.n	7ee4 <Spi_DeInit+0x74>
                   )
                {
                    Spi_Ipw_DeInit(HWUnit, SpiCoreID);
    7ecc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ed0:	9900      	ldr	r1, [sp, #0]
    7ed2:	4618      	mov	r0, r3
    7ed4:	f000 fa54 	bl	8380 <Spi_Ipw_DeInit>
    
                    Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_UNINIT;
    7ed8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7edc:	4a0c      	ldr	r2, [pc, #48]	; (7f10 <Spi_DeInit+0xa0>)
    7ede:	2100      	movs	r1, #0
    7ee0:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
                 HWUnit++)
    7ee4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ee8:	3301      	adds	r3, #1
    7eea:	f88d 3006 	strb.w	r3, [sp, #6]
            for (HWUnit = (Spi_HWUnitType) 0;
    7eee:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ef2:	2b00      	cmp	r3, #0
    7ef4:	d0d0      	beq.n	7e98 <Spi_DeInit+0x28>
                {
                    /* Do nothing */
                }
            }
            /* Reset configuration pointer */
            Spi_apxSpiConfigPtr[SpiCoreID] = NULL_PTR;
    7ef6:	4a05      	ldr	r2, [pc, #20]	; (7f0c <Spi_DeInit+0x9c>)
    7ef8:	9b00      	ldr	r3, [sp, #0]
    7efa:	2100      	movs	r1, #0
    7efc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return TempExit;
    7f00:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    7f04:	4618      	mov	r0, r3
    7f06:	b003      	add	sp, #12
    7f08:	f85d fb04 	ldr.w	pc, [sp], #4
    7f0c:	1fff8d4c 	.word	0x1fff8d4c
    7f10:	1fff8d44 	.word	0x1fff8d44

00007f14 <Spi_SetupEB>:
        Spi_ChannelType Channel,
        const Spi_DataBufferType  *SrcDataBufferPtr,
        Spi_DataBufferType *DesDataBufferPtr,
        Spi_NumberOfDataType Length
    )
{
    7f14:	b500      	push	{lr}
    7f16:	b089      	sub	sp, #36	; 0x24
    7f18:	9102      	str	r1, [sp, #8]
    7f1a:	9201      	str	r2, [sp, #4]
    7f1c:	461a      	mov	r2, r3
    7f1e:	4603      	mov	r3, r0
    7f20:	f88d 300f 	strb.w	r3, [sp, #15]
    7f24:	4613      	mov	r3, r2
    7f26:	f8ad 300c 	strh.w	r3, [sp, #12]
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    7f2a:	2300      	movs	r3, #0
    7f2c:	f88d 301f 	strb.w	r3, [sp, #31]
    Spi_ChannelStateType *ChannelState;
    const Spi_ChannelConfigType *ChannelConfig;
    uint32 SpiCoreID;

    /* get current coreID */
    SpiCoreID = Spi_GetCoreID;
    7f30:	2300      	movs	r3, #0
    7f32:	9306      	str	r3, [sp, #24]
        Status = (Std_ReturnType)E_NOT_OK;
    }
    else
    {
#endif
        ChannelState = &Spi_axSpiChannelState[Channel];
    7f34:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7f38:	009b      	lsls	r3, r3, #2
    7f3a:	4a28      	ldr	r2, [pc, #160]	; (7fdc <Spi_SetupEB+0xc8>)
    7f3c:	4413      	add	r3, r2
    7f3e:	9305      	str	r3, [sp, #20]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    7f40:	4a27      	ldr	r2, [pc, #156]	; (7fe0 <Spi_SetupEB+0xcc>)
    7f42:	9b06      	ldr	r3, [sp, #24]
    7f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f48:	68da      	ldr	r2, [r3, #12]
    7f4a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7f4e:	009b      	lsls	r3, r3, #2
    7f50:	4413      	add	r3, r2
    7f52:	681b      	ldr	r3, [r3, #0]
    7f54:	9304      	str	r3, [sp, #16]
        /* exit early if this is the wrong buffer type */
        if (IB == ChannelConfig->BufferType)
    7f56:	9b04      	ldr	r3, [sp, #16]
    7f58:	681b      	ldr	r3, [r3, #0]
    7f5a:	2b00      	cmp	r3, #0
    7f5c:	d103      	bne.n	7f66 <Spi_SetupEB+0x52>
        {
            /* Call Det_ReportError */
#if (SPI_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_SETUPEB_ID,SPI_E_PARAM_CHANNEL);
#endif
            Status = (Std_ReturnType)E_NOT_OK;
    7f5e:	2301      	movs	r3, #1
    7f60:	f88d 301f 	strb.w	r3, [sp, #31]
    7f64:	e033      	b.n	7fce <Spi_SetupEB+0xba>
            /* Length and Framesize - aren't compatible */
            /* If 8 < Framesize =< 16: Length must be divisible by 2 */
            /* If 16 < Framesize =< 32: Length must be divisible by 4 */
            Status = Spi_SetupEbCheckLength(ChannelConfig, Length);
#endif
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05();
    7f66:	f001 fec7 	bl	9cf8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>
            /* save the new parameters */
            ChannelConfig->BufferDescriptor->ExternalBufferTX = SrcDataBufferPtr;
    7f6a:	9b04      	ldr	r3, [sp, #16]
    7f6c:	691b      	ldr	r3, [r3, #16]
    7f6e:	9a02      	ldr	r2, [sp, #8]
    7f70:	601a      	str	r2, [r3, #0]
            ChannelConfig->BufferDescriptor->BufferRX = DesDataBufferPtr;
    7f72:	9b04      	ldr	r3, [sp, #16]
    7f74:	691b      	ldr	r3, [r3, #16]
    7f76:	9a01      	ldr	r2, [sp, #4]
    7f78:	609a      	str	r2, [r3, #8]

            ChannelState->Length = Length;
    7f7a:	9b05      	ldr	r3, [sp, #20]
    7f7c:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    7f80:	805a      	strh	r2, [r3, #2]

            /* if source data pointer is zero, transmit default value */
            if (NULL_PTR == SrcDataBufferPtr)
    7f82:	9b02      	ldr	r3, [sp, #8]
    7f84:	2b00      	cmp	r3, #0
    7f86:	d107      	bne.n	7f98 <Spi_SetupEB+0x84>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    7f88:	9b05      	ldr	r3, [sp, #20]
    7f8a:	781b      	ldrb	r3, [r3, #0]
    7f8c:	f043 0301 	orr.w	r3, r3, #1
    7f90:	b2da      	uxtb	r2, r3
    7f92:	9b05      	ldr	r3, [sp, #20]
    7f94:	701a      	strb	r2, [r3, #0]
    7f96:	e006      	b.n	7fa6 <Spi_SetupEB+0x92>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_TX_DEFAULT_U8);
    7f98:	9b05      	ldr	r3, [sp, #20]
    7f9a:	781b      	ldrb	r3, [r3, #0]
    7f9c:	f023 0301 	bic.w	r3, r3, #1
    7fa0:	b2da      	uxtb	r2, r3
    7fa2:	9b05      	ldr	r3, [sp, #20]
    7fa4:	701a      	strb	r2, [r3, #0]
            }

            /* if destination data pointer is zero, discard receiving data */
            if (NULL_PTR == DesDataBufferPtr)
    7fa6:	9b01      	ldr	r3, [sp, #4]
    7fa8:	2b00      	cmp	r3, #0
    7faa:	d107      	bne.n	7fbc <Spi_SetupEB+0xa8>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_RX_DISCARD_U8;
    7fac:	9b05      	ldr	r3, [sp, #20]
    7fae:	781b      	ldrb	r3, [r3, #0]
    7fb0:	f043 0302 	orr.w	r3, r3, #2
    7fb4:	b2da      	uxtb	r2, r3
    7fb6:	9b05      	ldr	r3, [sp, #20]
    7fb8:	701a      	strb	r2, [r3, #0]
    7fba:	e006      	b.n	7fca <Spi_SetupEB+0xb6>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_RX_DISCARD_U8);
    7fbc:	9b05      	ldr	r3, [sp, #20]
    7fbe:	781b      	ldrb	r3, [r3, #0]
    7fc0:	f023 0302 	bic.w	r3, r3, #2
    7fc4:	b2da      	uxtb	r2, r3
    7fc6:	9b05      	ldr	r3, [sp, #20]
    7fc8:	701a      	strb	r2, [r3, #0]
            }
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05();
    7fca:	f001 fec1 	bl	9d50 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>
        }
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return Status;
    7fce:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    7fd2:	4618      	mov	r0, r3
    7fd4:	b009      	add	sp, #36	; 0x24
    7fd6:	f85d fb04 	ldr.w	pc, [sp], #4
    7fda:	bf00      	nop
    7fdc:	1fff8d60 	.word	0x1fff8d60
    7fe0:	1fff8d4c 	.word	0x1fff8d4c

00007fe4 <Spi_GetStatus>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_GetStatus_Activity
*/
Spi_StatusType Spi_GetStatus(void)
{
    7fe4:	b500      	push	{lr}
    7fe6:	b085      	sub	sp, #20
    Spi_StatusType StatusFlag = SPI_IDLE;
    7fe8:	2301      	movs	r3, #1
    7fea:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    
    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    7fec:	2300      	movs	r3, #0
    7fee:	9301      	str	r3, [sp, #4]

    if (NULL_PTR == Spi_apxSpiConfigPtr[SpiCoreID])
    7ff0:	4a22      	ldr	r2, [pc, #136]	; (807c <Spi_GetStatus+0x98>)
    7ff2:	9b01      	ldr	r3, [sp, #4]
    7ff4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ff8:	2b00      	cmp	r3, #0
    7ffa:	d102      	bne.n	8002 <Spi_GetStatus+0x1e>
        /* If Development Error Detection is enabled, report error if not */
        /* initialized */
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSTATUS_ID,SPI_E_UNINIT);
#endif
        StatusFlag = SPI_UNINIT;
    7ffc:	2300      	movs	r3, #0
    7ffe:	9303      	str	r3, [sp, #12]
    8000:	e037      	b.n	8072 <Spi_GetStatus+0x8e>
    }
    else
    {
        /* The SPI Handler Driver software module shall be busy when any
           HWUnit is busy */
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    8002:	2300      	movs	r3, #0
    8004:	f88d 300b 	strb.w	r3, [sp, #11]
    8008:	e028      	b.n	805c <Spi_GetStatus+0x78>
        {
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    800a:	4a1c      	ldr	r2, [pc, #112]	; (807c <Spi_GetStatus+0x98>)
    800c:	9b01      	ldr	r3, [sp, #4]
    800e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8012:	69da      	ldr	r2, [r3, #28]
    8014:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8018:	009b      	lsls	r3, r3, #2
    801a:	4413      	add	r3, r2
    801c:	681b      	ldr	r3, [r3, #0]
    801e:	2b00      	cmp	r3, #0
    8020:	d017      	beq.n	8052 <Spi_GetStatus+0x6e>
                (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    8022:	4a16      	ldr	r2, [pc, #88]	; (807c <Spi_GetStatus+0x98>)
    8024:	9b01      	ldr	r3, [sp, #4]
    8026:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    802a:	69da      	ldr	r2, [r3, #28]
    802c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8030:	009b      	lsls	r3, r3, #2
    8032:	4413      	add	r3, r2
    8034:	681b      	ldr	r3, [r3, #0]
    8036:	689b      	ldr	r3, [r3, #8]
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    8038:	9a01      	ldr	r2, [sp, #4]
    803a:	429a      	cmp	r2, r3
    803c:	d109      	bne.n	8052 <Spi_GetStatus+0x6e>
               )
            {
                if (1u == Spi_au32SpiBusySyncHWUnitsStatus[HWUnit])
    803e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8042:	4a0f      	ldr	r2, [pc, #60]	; (8080 <Spi_GetStatus+0x9c>)
    8044:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8048:	2b01      	cmp	r3, #1
    804a:	d102      	bne.n	8052 <Spi_GetStatus+0x6e>
                {
                    StatusFlag = SPI_BUSY;
    804c:	2302      	movs	r3, #2
    804e:	9303      	str	r3, [sp, #12]
                    break;
    8050:	e008      	b.n	8064 <Spi_GetStatus+0x80>
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    8052:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8056:	3301      	adds	r3, #1
    8058:	f88d 300b 	strb.w	r3, [sp, #11]
    805c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8060:	2b00      	cmp	r3, #0
    8062:	d0d2      	beq.n	800a <Spi_GetStatus+0x26>
            {
                /* Do nothing */
            }
        }
        /* check for busy HWUnit in async transmissions */
        if (SPI_BUSY != StatusFlag)
    8064:	9b03      	ldr	r3, [sp, #12]
    8066:	2b02      	cmp	r3, #2
    8068:	d003      	beq.n	8072 <Spi_GetStatus+0x8e>
        {
            /* Note: Checking for IsSync attribute for HWUnit is not really needed
                 It is preferable to skip this check in order to have a more compact code
            */
            StatusFlag = Spi_GetStatusAsyncCheckHwBusy(SpiCoreID);
    806a:	9801      	ldr	r0, [sp, #4]
    806c:	f7ff fe4e 	bl	7d0c <Spi_GetStatusAsyncCheckHwBusy>
    8070:	9003      	str	r0, [sp, #12]
        else
        {
            /* Do notthing */
        }
    }
    return StatusFlag;
    8072:	9b03      	ldr	r3, [sp, #12]
}
    8074:	4618      	mov	r0, r3
    8076:	b005      	add	sp, #20
    8078:	f85d fb04 	ldr.w	pc, [sp], #4
    807c:	1fff8d4c 	.word	0x1fff8d4c
    8080:	1fff8d78 	.word	0x1fff8d78

00008084 <Spi_GetJobResult>:
/** @implements Spi_GetJobResult_Activity */
Spi_JobResultType Spi_GetJobResult
    (
        Spi_JobType Job
    )
{
    8084:	b084      	sub	sp, #16
    8086:	4603      	mov	r3, r0
    8088:	f8ad 3006 	strh.w	r3, [sp, #6]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETJOBRESULT_ID,SPI_E_PARAM_CONFIG);
    }
    else
    {
#endif
        JobResult = Spi_axSpiJobState[Job].Result;
    808c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    8090:	4a03      	ldr	r2, [pc, #12]	; (80a0 <Spi_GetJobResult+0x1c>)
    8092:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8096:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return JobResult;
    8098:	9b03      	ldr	r3, [sp, #12]
}
    809a:	4618      	mov	r0, r3
    809c:	b004      	add	sp, #16
    809e:	4770      	bx	lr
    80a0:	1fff8d58 	.word	0x1fff8d58

000080a4 <Spi_GetSequenceResult>:
/** @implements Spi_GetSequenceResult_Activity */
Spi_SeqResultType Spi_GetSequenceResult
    (
        Spi_SequenceType Sequence
    )
{
    80a4:	b084      	sub	sp, #16
    80a6:	4603      	mov	r3, r0
    80a8:	f88d 3007 	strb.w	r3, [sp, #7]
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSEQUENCERESULT_ID,SPI_E_PARAM_CONFIG);
        }
        else
        {
#endif
           SequenceResult = Spi_axSpiSequenceState[Sequence].Result;
    80ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
    80b0:	4a03      	ldr	r2, [pc, #12]	; (80c0 <Spi_GetSequenceResult+0x1c>)
    80b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80b6:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif

    return SequenceResult;
    80b8:	9b03      	ldr	r3, [sp, #12]
}
    80ba:	4618      	mov	r0, r3
    80bc:	b004      	add	sp, #16
    80be:	4770      	bx	lr
    80c0:	1fff8d50 	.word	0x1fff8d50

000080c4 <Spi_SyncTransmit>:
/** @implements Spi_SyncTransmit_Activity */
Std_ReturnType Spi_SyncTransmit
    (
        Spi_SequenceType Sequence
    )
{
    80c4:	b500      	push	{lr}
    80c6:	b08b      	sub	sp, #44	; 0x2c
    80c8:	4603      	mov	r3, r0
    80ca:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_SequenceStateType *SequenceState;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    80ce:	2300      	movs	r3, #0
    80d0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Spi_JobType Job;
    const Spi_JobConfigType *JobConfig;
    uint32 SpiCoreID;

    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    80d4:	2300      	movs	r3, #0
    80d6:	9308      	str	r3, [sp, #32]
        Status = Spi_SynctransmitCheckJobsIsValid(SequenceConfig, SpiCoreID);

        if ((Std_ReturnType)E_NOT_OK != Status)
        {
#endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    80d8:	4a60      	ldr	r2, [pc, #384]	; (825c <Spi_SyncTransmit+0x198>)
    80da:	9b08      	ldr	r3, [sp, #32]
    80dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80e0:	695a      	ldr	r2, [r3, #20]
    80e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    80e6:	009b      	lsls	r3, r3, #2
    80e8:	4413      	add	r3, r2
    80ea:	681b      	ldr	r3, [r3, #0]
    80ec:	9307      	str	r3, [sp, #28]
            /* Get the number of jobs in the sequence */
            NumJobsInSequence = SequenceConfig->NumJobs;
    80ee:	9b07      	ldr	r3, [sp, #28]
    80f0:	881b      	ldrh	r3, [r3, #0]
    80f2:	f8ad 301a 	strh.w	r3, [sp, #26]

            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06();
    80f6:	f001 fe51 	bl	9d9c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>
            /* check if there are HW units already running */
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    80fa:	2300      	movs	r3, #0
    80fc:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    8100:	e017      	b.n	8132 <Spi_SyncTransmit+0x6e>
            {
                if (0u != ((Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] << HWUnit) & Spi_au32SpiSeqUsedHWUnits[Sequence]))
    8102:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8106:	4a56      	ldr	r2, [pc, #344]	; (8260 <Spi_SyncTransmit+0x19c>)
    8108:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    810c:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8110:	409a      	lsls	r2, r3
    8112:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8116:	4953      	ldr	r1, [pc, #332]	; (8264 <Spi_SyncTransmit+0x1a0>)
    8118:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    811c:	4013      	ands	r3, r2
    811e:	2b00      	cmp	r3, #0
    8120:	d002      	beq.n	8128 <Spi_SyncTransmit+0x64>
                {
                    Status = (Std_ReturnType)E_NOT_OK;
    8122:	2301      	movs	r3, #1
    8124:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    8128:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    812c:	3301      	adds	r3, #1
    812e:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    8132:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8136:	2b00      	cmp	r3, #0
    8138:	d0e3      	beq.n	8102 <Spi_SyncTransmit+0x3e>
                {
                    /* Do notthing */
                }
            }
            
            if ((Std_ReturnType)E_NOT_OK != Status)
    813a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    813e:	2b01      	cmp	r3, #1
    8140:	f000 8083 	beq.w	824a <Spi_SyncTransmit+0x186>
            {
                /* Set the sequence as pending */
                SequenceState = &Spi_axSpiSequenceState[Sequence];
    8144:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8148:	009b      	lsls	r3, r3, #2
    814a:	4a47      	ldr	r2, [pc, #284]	; (8268 <Spi_SyncTransmit+0x1a4>)
    814c:	4413      	add	r3, r2
    814e:	9305      	str	r3, [sp, #20]
                SequenceState->Result = SPI_SEQ_PENDING;
    8150:	9b05      	ldr	r3, [sp, #20]
    8152:	2201      	movs	r2, #1
    8154:	601a      	str	r2, [r3, #0]
                /* set used HW units as busy */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    8156:	2300      	movs	r3, #0
    8158:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    815c:	e022      	b.n	81a4 <Spi_SyncTransmit+0xe0>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    815e:	9b07      	ldr	r3, [sp, #28]
    8160:	689a      	ldr	r2, [r3, #8]
    8162:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    8166:	005b      	lsls	r3, r3, #1
    8168:	4413      	add	r3, r2
    816a:	881b      	ldrh	r3, [r3, #0]
    816c:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    8170:	4a3a      	ldr	r2, [pc, #232]	; (825c <Spi_SyncTransmit+0x198>)
    8172:	9b08      	ldr	r3, [sp, #32]
    8174:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8178:	691a      	ldr	r2, [r3, #16]
    817a:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    817e:	009b      	lsls	r3, r3, #2
    8180:	4413      	add	r3, r2
    8182:	681b      	ldr	r3, [r3, #0]
    8184:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    8186:	9b03      	ldr	r3, [sp, #12]
    8188:	7f1b      	ldrb	r3, [r3, #28]
    818a:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 1u;
    818e:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8192:	4a33      	ldr	r2, [pc, #204]	; (8260 <Spi_SyncTransmit+0x19c>)
    8194:	2101      	movs	r1, #1
    8196:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    819a:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    819e:	3301      	adds	r3, #1
    81a0:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    81a4:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    81a8:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    81ac:	429a      	cmp	r2, r3
    81ae:	d3d6      	bcc.n	815e <Spi_SyncTransmit+0x9a>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    81b0:	f001 fe20 	bl	9df4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
                /* Transmit Jobs */
                Status = Spi_SyncJobsTranfer(SequenceConfig, SpiCoreID);
    81b4:	9908      	ldr	r1, [sp, #32]
    81b6:	9807      	ldr	r0, [sp, #28]
    81b8:	f7ff fc72 	bl	7aa0 <Spi_SyncJobsTranfer>
    81bc:	4603      	mov	r3, r0
    81be:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                
                if ((Std_ReturnType)E_OK == Status)
    81c2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    81c6:	2b00      	cmp	r3, #0
    81c8:	d103      	bne.n	81d2 <Spi_SyncTransmit+0x10e>
                {
                    /* Set the sequence as OK */
                    SequenceState->Result = SPI_SEQ_OK;
    81ca:	9b05      	ldr	r3, [sp, #20]
    81cc:	2200      	movs	r2, #0
    81ce:	601a      	str	r2, [r3, #0]
    81d0:	e002      	b.n	81d8 <Spi_SyncTransmit+0x114>
#endif
                }
                else
                {
                    /* Set the sequence as FAILED */
                    SequenceState->Result = SPI_SEQ_FAILED;
    81d2:	9b05      	ldr	r3, [sp, #20]
    81d4:	2202      	movs	r2, #2
    81d6:	601a      	str	r2, [r3, #0]
                    /* Report to DEM */
                    Spi_DemReportStatus(SpiCoreID, DEM_EVENT_STATUS_FAILED);
#endif
                }
                
                SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07();
    81d8:	f001 fe32 	bl	9e40 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>
                /* set used HW units as idle */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    81dc:	2300      	movs	r3, #0
    81de:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    81e2:	e022      	b.n	822a <Spi_SyncTransmit+0x166>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    81e4:	9b07      	ldr	r3, [sp, #28]
    81e6:	689a      	ldr	r2, [r3, #8]
    81e8:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    81ec:	005b      	lsls	r3, r3, #1
    81ee:	4413      	add	r3, r2
    81f0:	881b      	ldrh	r3, [r3, #0]
    81f2:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    81f6:	4a19      	ldr	r2, [pc, #100]	; (825c <Spi_SyncTransmit+0x198>)
    81f8:	9b08      	ldr	r3, [sp, #32]
    81fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81fe:	691a      	ldr	r2, [r3, #16]
    8200:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    8204:	009b      	lsls	r3, r3, #2
    8206:	4413      	add	r3, r2
    8208:	681b      	ldr	r3, [r3, #0]
    820a:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    820c:	9b03      	ldr	r3, [sp, #12]
    820e:	7f1b      	ldrb	r3, [r3, #28]
    8210:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 0u;
    8214:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8218:	4a11      	ldr	r2, [pc, #68]	; (8260 <Spi_SyncTransmit+0x19c>)
    821a:	2100      	movs	r1, #0
    821c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    8220:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    8224:	3301      	adds	r3, #1
    8226:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    822a:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    822e:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    8232:	429a      	cmp	r2, r3
    8234:	d3d6      	bcc.n	81e4 <Spi_SyncTransmit+0x120>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07();
    8236:	f001 fe2f 	bl	9e98 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>
                
                /* End Sequence Notification */
                if (NULL_PTR != SequenceConfig->EndNotification)
    823a:	9b07      	ldr	r3, [sp, #28]
    823c:	68db      	ldr	r3, [r3, #12]
    823e:	2b00      	cmp	r3, #0
    8240:	d005      	beq.n	824e <Spi_SyncTransmit+0x18a>
                {
                    SequenceConfig->EndNotification();
    8242:	9b07      	ldr	r3, [sp, #28]
    8244:	68db      	ldr	r3, [r3, #12]
    8246:	4798      	blx	r3
    8248:	e001      	b.n	824e <Spi_SyncTransmit+0x18a>
                    /* Do nothing */
                }
            }
            else
            {
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    824a:	f001 fdd3 	bl	9df4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
            /* Do nothing */
        }
    }
#endif

    return Status;
    824e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    8252:	4618      	mov	r0, r3
    8254:	b00b      	add	sp, #44	; 0x2c
    8256:	f85d fb04 	ldr.w	pc, [sp], #4
    825a:	bf00      	nop
    825c:	1fff8d4c 	.word	0x1fff8d4c
    8260:	1fff8d78 	.word	0x1fff8d78
    8264:	1fff8d70 	.word	0x1fff8d70
    8268:	1fff8d50 	.word	0x1fff8d50

0000826c <Spi_GetHWUnitStatus>:
/** @implements Spi_GetHWUnitStatus_Activity */
Spi_StatusType Spi_GetHWUnitStatus
    (
        Spi_HWUnitType HWUnit
    )
{
    826c:	b084      	sub	sp, #16
    826e:	4603      	mov	r3, r0
    8270:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_StatusType Status = SPI_UNINIT;
    8274:	2300      	movs	r3, #0
    8276:	9303      	str	r3, [sp, #12]
        /* Do nothing */
    }
    else
    {
#endif
        Status = Spi_axSpiHwUnitQueueArray[HWUnit].Status;
    8278:	f89d 3007 	ldrb.w	r3, [sp, #7]
    827c:	4a03      	ldr	r2, [pc, #12]	; (828c <Spi_GetHWUnitStatus+0x20>)
    827e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    8282:	9303      	str	r3, [sp, #12]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return Status;
    8284:	9b03      	ldr	r3, [sp, #12]
}
    8286:	4618      	mov	r0, r3
    8288:	b004      	add	sp, #16
    828a:	4770      	bx	lr
    828c:	1fff8d44 	.word	0x1fff8d44

00008290 <Spi_Cancel>:
*       undefined state due to cancelling a sequence transmission.
*
*/
/**  @implements Spi_Cancel_Activity */
void Spi_Cancel(Spi_SequenceType Sequence)
{
    8290:	b082      	sub	sp, #8
    8292:	4603      	mov	r3, r0
    8294:	f88d 3007 	strb.w	r3, [sp, #7]
        }
        else
        {
#endif
            /* Set sequence state to Cancel */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_CANCELLED;
    8298:	f89d 3007 	ldrb.w	r3, [sp, #7]
    829c:	4a03      	ldr	r2, [pc, #12]	; (82ac <Spi_Cancel+0x1c>)
    829e:	2103      	movs	r1, #3
    82a0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            #endif
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif
}
    82a4:	bf00      	nop
    82a6:	b002      	add	sp, #8
    82a8:	4770      	bx	lr
    82aa:	bf00      	nop
    82ac:	1fff8d50 	.word	0x1fff8d50

000082b0 <Spi_MainFunction_Handling>:
                /*Do nothing */
            }
        }
    }
#endif /* #if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2) ) */
}
    82b0:	bf00      	nop
    82b2:	4770      	bx	lr

000082b4 <Spi_Ipw_SyncTransmitProcess>:
        const Spi_JobConfigType *JobConfig,
        const Spi_ChannelConfigType *ChannelConfig,
        Spi_DataBufferType *RxBuffer,
        const Spi_DataBufferType *TxBuffer
    )
{
    82b4:	b500      	push	{lr}
    82b6:	b08d      	sub	sp, #52	; 0x34
    82b8:	9005      	str	r0, [sp, #20]
    82ba:	9104      	str	r1, [sp, #16]
    82bc:	9203      	str	r2, [sp, #12]
    82be:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_StatusType Lpspi_spiStatus = LPSPI_IP_STATUS_SUCCESS;
    82c0:	2300      	movs	r3, #0
    82c2:	930b      	str	r3, [sp, #44]	; 0x2c
    const Lpspi_Ip_ExternalDeviceType* LpspiExternalDevice;
#if (SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)
    Flexio_Spi_Ip_StatusType Flexio_spiStatus = FLEXIO_SPI_IP_STATUS_SUCCESS;
    const Flexio_Spi_Ip_ExternalDeviceType* Flexio_SpiExternalDevice;
#endif
    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    82c4:	2300      	movs	r3, #0
    82c6:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    Spi_NumberOfDataType NumberOfBytes;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    82ca:	9b05      	ldr	r3, [sp, #20]
    82cc:	6a1b      	ldr	r3, [r3, #32]
    82ce:	681b      	ldr	r3, [r3, #0]
    82d0:	681b      	ldr	r3, [r3, #0]
    82d2:	9309      	str	r3, [sp, #36]	; 0x24
        HalfDuplexMode = LPSPI_IP_FULL_DUPLEX;
        HalfDuplexModeSupport = FALSE;
    }
#endif
    
    NumberOfBytes = ChannelConfig->ChannelState->Length;
    82d4:	9b04      	ldr	r3, [sp, #16]
    82d6:	699b      	ldr	r3, [r3, #24]
    82d8:	885b      	ldrh	r3, [r3, #2]
    82da:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    if (SPI_OVER_LPSPI == IpType)
    82de:	9b09      	ldr	r3, [sp, #36]	; 0x24
    82e0:	2b00      	cmp	r3, #0
    82e2:	d12e      	bne.n	8342 <Spi_Ipw_SyncTransmitProcess+0x8e>
    {
        LpspiExternalDevice = JobConfig->ExternalDeviceConfig->ExDeviceConfig->ExternalDeviceConfig.LpspiExternalDeviceConfig;
    82e4:	9b05      	ldr	r3, [sp, #20]
    82e6:	6a1b      	ldr	r3, [r3, #32]
    82e8:	681b      	ldr	r3, [r3, #0]
    82ea:	689b      	ldr	r3, [r3, #8]
    82ec:	9307      	str	r3, [sp, #28]
        Lpspi_spiStatus = Lpspi_Ip_UpdateDefaultTransmitData(LpspiExternalDevice, ChannelConfig->DefaultTransmitValue);
    82ee:	9b04      	ldr	r3, [sp, #16]
    82f0:	689b      	ldr	r3, [r3, #8]
    82f2:	4619      	mov	r1, r3
    82f4:	9807      	ldr	r0, [sp, #28]
    82f6:	f7ff fadd 	bl	78b4 <Lpspi_Ip_UpdateDefaultTransmitData>
    82fa:	900b      	str	r0, [sp, #44]	; 0x2c
        if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    82fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    82fe:	2b00      	cmp	r3, #0
    8300:	d11f      	bne.n	8342 <Spi_Ipw_SyncTransmitProcess+0x8e>
        {
            Lpspi_spiStatus = Lpspi_Ip_UpdateFrameSize(LpspiExternalDevice, ChannelConfig->FrameSize);
    8302:	9b04      	ldr	r3, [sp, #16]
    8304:	791b      	ldrb	r3, [r3, #4]
    8306:	b29b      	uxth	r3, r3
    8308:	4619      	mov	r1, r3
    830a:	9807      	ldr	r0, [sp, #28]
    830c:	f7ff fa92 	bl	7834 <Lpspi_Ip_UpdateFrameSize>
    8310:	900b      	str	r0, [sp, #44]	; 0x2c
            if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    8312:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8314:	2b00      	cmp	r3, #0
    8316:	d114      	bne.n	8342 <Spi_Ipw_SyncTransmitProcess+0x8e>
            {
                Lpspi_spiStatus = Lpspi_Ip_UpdateLsb(LpspiExternalDevice, ChannelConfig->Lsb);
    8318:	9b04      	ldr	r3, [sp, #16]
    831a:	795b      	ldrb	r3, [r3, #5]
    831c:	4619      	mov	r1, r3
    831e:	9807      	ldr	r0, [sp, #28]
    8320:	f7ff faa8 	bl	7874 <Lpspi_Ip_UpdateLsb>
    8324:	900b      	str	r0, [sp, #44]	; 0x2c
                if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    8326:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8328:	2b00      	cmp	r3, #0
    832a:	d10a      	bne.n	8342 <Spi_Ipw_SyncTransmitProcess+0x8e>
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmitHalfDuplex(LpspiExternalDevice, Buffer, NumberOfBytes, HalfDuplexMode, SPI_TIMEOUT_COUNTER_U32);
                    }
                    else
                    #endif
                    {
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmit(LpspiExternalDevice, (const uint8*)TxBuffer, RxBuffer, NumberOfBytes, SPI_TIMEOUT_COUNTER_U32);
    832c:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
    8330:	f24c 3250 	movw	r2, #50000	; 0xc350
    8334:	9200      	str	r2, [sp, #0]
    8336:	9a03      	ldr	r2, [sp, #12]
    8338:	9902      	ldr	r1, [sp, #8]
    833a:	9807      	ldr	r0, [sp, #28]
    833c:	f7fe fe0a 	bl	6f54 <Lpspi_Ip_SyncTransmit>
    8340:	900b      	str	r0, [sp, #44]	; 0x2c
            }
        }
    }
    if( (LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus) || (FLEXIO_SPI_IP_STATUS_SUCCESS != Flexio_spiStatus))
#else
    if(LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus)
    8342:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8344:	2b00      	cmp	r3, #0
    8346:	d002      	beq.n	834e <Spi_Ipw_SyncTransmitProcess+0x9a>
#endif /*(SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)*/
    {
        Ipw_Status = (Std_ReturnType)E_NOT_OK;
    8348:	2301      	movs	r3, #1
    834a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    }
    return Ipw_Status;
    834e:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
}
    8352:	4618      	mov	r0, r3
    8354:	b00d      	add	sp, #52	; 0x34
    8356:	f85d fb04 	ldr.w	pc, [sp], #4

0000835a <Spi_Ipw_Init>:
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
/* Spi_Ipw_Init */
void Spi_Ipw_Init(const Spi_HWUnitType HWUnitId, const Spi_HWUnitConfigType *HWUnit)
{
    835a:	b500      	push	{lr}
    835c:	b083      	sub	sp, #12
    835e:	4603      	mov	r3, r0
    8360:	9100      	str	r1, [sp, #0]
    8362:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == HWUnit->IpType)
    8366:	9b00      	ldr	r3, [sp, #0]
    8368:	681b      	ldr	r3, [r3, #0]
    836a:	2b00      	cmp	r3, #0
    836c:	d104      	bne.n	8378 <Spi_Ipw_Init+0x1e>
    #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
        Spi_Ipw_au8LpspiHWUnitMapping[HWUnit->Instance] = HWUnitId;
    #else
        (void)HWUnitId;
    #endif
        (void)Lpspi_Ip_Init(HWUnit->IpConfig.LpspiIpConfig);
    836e:	9b00      	ldr	r3, [sp, #0]
    8370:	68db      	ldr	r3, [r3, #12]
    8372:	4618      	mov	r0, r3
    8374:	f7fe fd62 	bl	6e3c <Lpspi_Ip_Init>
        (void)HWUnitId;
    #endif
        (void)Flexio_Spi_Ip_Init(HWUnit->IpConfig.FlexioSpiIpConfig);
    }
#endif
}
    8378:	bf00      	nop
    837a:	b003      	add	sp, #12
    837c:	f85d fb04 	ldr.w	pc, [sp], #4

00008380 <Spi_Ipw_DeInit>:

/* Spi_Ipw_DeInit */
void Spi_Ipw_DeInit(Spi_HWUnitType HWUnit, uint32 SpiCoreID)
{
    8380:	b500      	push	{lr}
    8382:	b083      	sub	sp, #12
    8384:	4603      	mov	r3, r0
    8386:	9100      	str	r1, [sp, #0]
    8388:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->IpType)
    838c:	4a0f      	ldr	r2, [pc, #60]	; (83cc <Spi_Ipw_DeInit+0x4c>)
    838e:	9b00      	ldr	r3, [sp, #0]
    8390:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8394:	69da      	ldr	r2, [r3, #28]
    8396:	f89d 3007 	ldrb.w	r3, [sp, #7]
    839a:	009b      	lsls	r3, r3, #2
    839c:	4413      	add	r3, r2
    839e:	681b      	ldr	r3, [r3, #0]
    83a0:	681b      	ldr	r3, [r3, #0]
    83a2:	2b00      	cmp	r3, #0
    83a4:	d10d      	bne.n	83c2 <Spi_Ipw_DeInit+0x42>
    {
        (void)Lpspi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    83a6:	4a09      	ldr	r2, [pc, #36]	; (83cc <Spi_Ipw_DeInit+0x4c>)
    83a8:	9b00      	ldr	r3, [sp, #0]
    83aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83ae:	69da      	ldr	r2, [r3, #28]
    83b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    83b4:	009b      	lsls	r3, r3, #2
    83b6:	4413      	add	r3, r2
    83b8:	681b      	ldr	r3, [r3, #0]
    83ba:	791b      	ldrb	r3, [r3, #4]
    83bc:	4618      	mov	r0, r3
    83be:	f7fe fd99 	bl	6ef4 <Lpspi_Ip_DeInit>
    else
    {
        (void)Flexio_Spi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    }
#endif
}
    83c2:	bf00      	nop
    83c4:	b003      	add	sp, #12
    83c6:	f85d fb04 	ldr.w	pc, [sp], #4
    83ca:	bf00      	nop
    83cc:	1fff8d4c 	.word	0x1fff8d4c

000083d0 <Spi_Ipw_SyncTransmit>:

/* Spi_Ipw_SyncTransmit */
#if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL2) || (SPI_LEVEL_DELIVERED == SPI_LEVEL0) )
Std_ReturnType Spi_Ipw_SyncTransmit(const Spi_JobConfigType *JobConfig, uint32 SpiCoreID)
{
    83d0:	b500      	push	{lr}
    83d2:	b08b      	sub	sp, #44	; 0x2c
    83d4:	9001      	str	r0, [sp, #4]
    83d6:	9100      	str	r1, [sp, #0]

    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    83d8:	2300      	movs	r3, #0
    83da:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_ChannelConfigType *NextChannelConfig;
    Spi_ChannelType ChannelID;
    Spi_ChannelType NumChannelsInJob;
    Spi_ChannelType ChannelIndex;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    83de:	9b01      	ldr	r3, [sp, #4]
    83e0:	6a1b      	ldr	r3, [r3, #32]
    83e2:	681b      	ldr	r3, [r3, #0]
    83e4:	681b      	ldr	r3, [r3, #0]
    83e6:	9306      	str	r3, [sp, #24]
    
    NumChannelsInJob = JobConfig->NumChannels;
    83e8:	9b01      	ldr	r3, [sp, #4]
    83ea:	781b      	ldrb	r3, [r3, #0]
    83ec:	f88d 3017 	strb.w	r3, [sp, #23]
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    83f0:	2300      	movs	r3, #0
    83f2:	f88d 301f 	strb.w	r3, [sp, #31]
    83f6:	e0e6      	b.n	85c6 <Spi_Ipw_SyncTransmit+0x1f6>
    {
        ChannelID = JobConfig->ChannelIndexList[ChannelIndex];
    83f8:	9b01      	ldr	r3, [sp, #4]
    83fa:	685a      	ldr	r2, [r3, #4]
    83fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    8400:	4413      	add	r3, r2
    8402:	781b      	ldrb	r3, [r3, #0]
    8404:	f88d 3016 	strb.w	r3, [sp, #22]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[ChannelID].ChannelCfg;
    8408:	4a75      	ldr	r2, [pc, #468]	; (85e0 <Spi_Ipw_SyncTransmit+0x210>)
    840a:	9b00      	ldr	r3, [sp, #0]
    840c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8410:	68da      	ldr	r2, [r3, #12]
    8412:	f89d 3016 	ldrb.w	r3, [sp, #22]
    8416:	009b      	lsls	r3, r3, #2
    8418:	4413      	add	r3, r2
    841a:	681b      	ldr	r3, [r3, #0]
    841c:	9304      	str	r3, [sp, #16]
        RxBuffer = ChannelConfig->BufferDescriptor->BufferRX;
    841e:	9b04      	ldr	r3, [sp, #16]
    8420:	691b      	ldr	r3, [r3, #16]
    8422:	689b      	ldr	r3, [r3, #8]
    8424:	9303      	str	r3, [sp, #12]
        if(0u != (ChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    8426:	9b04      	ldr	r3, [sp, #16]
    8428:	699b      	ldr	r3, [r3, #24]
    842a:	781b      	ldrb	r3, [r3, #0]
    842c:	f003 0301 	and.w	r3, r3, #1
    8430:	2b00      	cmp	r3, #0
    8432:	d002      	beq.n	843a <Spi_Ipw_SyncTransmit+0x6a>
        {
            TxBuffer = NULL_PTR;
    8434:	2300      	movs	r3, #0
    8436:	9308      	str	r3, [sp, #32]
    8438:	e00c      	b.n	8454 <Spi_Ipw_SyncTransmit+0x84>
        }
        else
        {
            if(EB == ChannelConfig->BufferType)
    843a:	9b04      	ldr	r3, [sp, #16]
    843c:	681b      	ldr	r3, [r3, #0]
    843e:	2b01      	cmp	r3, #1
    8440:	d104      	bne.n	844c <Spi_Ipw_SyncTransmit+0x7c>
            {
                TxBuffer = ChannelConfig->BufferDescriptor->ExternalBufferTX;
    8442:	9b04      	ldr	r3, [sp, #16]
    8444:	691b      	ldr	r3, [r3, #16]
    8446:	681b      	ldr	r3, [r3, #0]
    8448:	9308      	str	r3, [sp, #32]
    844a:	e003      	b.n	8454 <Spi_Ipw_SyncTransmit+0x84>
            }
            else
            {
                TxBuffer = (const uint8*)(ChannelConfig->BufferDescriptor->InternalBufferTX);
    844c:	9b04      	ldr	r3, [sp, #16]
    844e:	691b      	ldr	r3, [r3, #16]
    8450:	685b      	ldr	r3, [r3, #4]
    8452:	9308      	str	r3, [sp, #32]
            }
        }
        
        if (SPI_OVER_LPSPI == IpType)
    8454:	9b06      	ldr	r3, [sp, #24]
    8456:	2b00      	cmp	r3, #0
    8458:	f040 80a7 	bne.w	85aa <Spi_Ipw_SyncTransmit+0x1da>
        {
            if(ChannelIndex == (NumChannelsInJob - 1u))
    845c:	f89d 201f 	ldrb.w	r2, [sp, #31]
    8460:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8464:	3b01      	subs	r3, #1
    8466:	429a      	cmp	r2, r3
    8468:	d10a      	bne.n	8480 <Spi_Ipw_SyncTransmit+0xb0>
            {
                /* Clear CS after current channel */
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = FALSE;
    846a:	9b01      	ldr	r3, [sp, #4]
    846c:	6a1b      	ldr	r3, [r3, #32]
    846e:	681b      	ldr	r3, [r3, #0]
    8470:	791b      	ldrb	r3, [r3, #4]
    8472:	461a      	mov	r2, r3
    8474:	4b5b      	ldr	r3, [pc, #364]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    8476:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    847a:	2200      	movs	r2, #0
    847c:	771a      	strb	r2, [r3, #28]
    847e:	e07b      	b.n	8578 <Spi_Ipw_SyncTransmit+0x1a8>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = TRUE;
    8480:	9b01      	ldr	r3, [sp, #4]
    8482:	6a1b      	ldr	r3, [r3, #32]
    8484:	681b      	ldr	r3, [r3, #0]
    8486:	791b      	ldrb	r3, [r3, #4]
    8488:	461a      	mov	r2, r3
    848a:	4b56      	ldr	r3, [pc, #344]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    848c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8490:	2201      	movs	r2, #1
    8492:	771a      	strb	r2, [r3, #28]
                MCAL_DATA_SYNC_BARRIER();
    8494:	f3bf 8f4f 	dsb	sy
                /* update data for next transfer */
                NextChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[JobConfig->ChannelIndexList[ChannelIndex + 1u]].ChannelCfg;
    8498:	4a51      	ldr	r2, [pc, #324]	; (85e0 <Spi_Ipw_SyncTransmit+0x210>)
    849a:	9b00      	ldr	r3, [sp, #0]
    849c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84a0:	68da      	ldr	r2, [r3, #12]
    84a2:	9b01      	ldr	r3, [sp, #4]
    84a4:	6859      	ldr	r1, [r3, #4]
    84a6:	f89d 301f 	ldrb.w	r3, [sp, #31]
    84aa:	3301      	adds	r3, #1
    84ac:	440b      	add	r3, r1
    84ae:	781b      	ldrb	r3, [r3, #0]
    84b0:	009b      	lsls	r3, r3, #2
    84b2:	4413      	add	r3, r2
    84b4:	681b      	ldr	r3, [r3, #0]
    84b6:	9302      	str	r3, [sp, #8]
                MCAL_DATA_SYNC_BARRIER();
    84b8:	f3bf 8f4f 	dsb	sy
                if(0u != (NextChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    84bc:	9b02      	ldr	r3, [sp, #8]
    84be:	699b      	ldr	r3, [r3, #24]
    84c0:	781b      	ldrb	r3, [r3, #0]
    84c2:	f003 0301 	and.w	r3, r3, #1
    84c6:	2b00      	cmp	r3, #0
    84c8:	d00a      	beq.n	84e0 <Spi_Ipw_SyncTransmit+0x110>
                {
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NULL_PTR;
    84ca:	9b01      	ldr	r3, [sp, #4]
    84cc:	6a1b      	ldr	r3, [r3, #32]
    84ce:	681b      	ldr	r3, [r3, #0]
    84d0:	791b      	ldrb	r3, [r3, #4]
    84d2:	461a      	mov	r2, r3
    84d4:	4b43      	ldr	r3, [pc, #268]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    84d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    84da:	2200      	movs	r2, #0
    84dc:	62da      	str	r2, [r3, #44]	; 0x2c
    84de:	e01c      	b.n	851a <Spi_Ipw_SyncTransmit+0x14a>
                }
                else
                {
                    if(EB == NextChannelConfig->BufferType)
    84e0:	9b02      	ldr	r3, [sp, #8]
    84e2:	681b      	ldr	r3, [r3, #0]
    84e4:	2b01      	cmp	r3, #1
    84e6:	d10c      	bne.n	8502 <Spi_Ipw_SyncTransmit+0x132>
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->ExternalBufferTX;
    84e8:	9b02      	ldr	r3, [sp, #8]
    84ea:	691a      	ldr	r2, [r3, #16]
    84ec:	9b01      	ldr	r3, [sp, #4]
    84ee:	6a1b      	ldr	r3, [r3, #32]
    84f0:	681b      	ldr	r3, [r3, #0]
    84f2:	791b      	ldrb	r3, [r3, #4]
    84f4:	4619      	mov	r1, r3
    84f6:	4b3b      	ldr	r3, [pc, #236]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    84f8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    84fc:	6812      	ldr	r2, [r2, #0]
    84fe:	62da      	str	r2, [r3, #44]	; 0x2c
    8500:	e00b      	b.n	851a <Spi_Ipw_SyncTransmit+0x14a>
                    }
                    else
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->InternalBufferTX;
    8502:	9b02      	ldr	r3, [sp, #8]
    8504:	691a      	ldr	r2, [r3, #16]
    8506:	9b01      	ldr	r3, [sp, #4]
    8508:	6a1b      	ldr	r3, [r3, #32]
    850a:	681b      	ldr	r3, [r3, #0]
    850c:	791b      	ldrb	r3, [r3, #4]
    850e:	4619      	mov	r1, r3
    8510:	4b34      	ldr	r3, [pc, #208]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    8512:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    8516:	6852      	ldr	r2, [r2, #4]
    8518:	62da      	str	r2, [r3, #44]	; 0x2c
                    }
                }
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FrameSizeNext = NextChannelConfig->FrameSize;
    851a:	9b02      	ldr	r3, [sp, #8]
    851c:	791a      	ldrb	r2, [r3, #4]
    851e:	9b01      	ldr	r3, [sp, #4]
    8520:	6a1b      	ldr	r3, [r3, #32]
    8522:	681b      	ldr	r3, [r3, #0]
    8524:	791b      	ldrb	r3, [r3, #4]
    8526:	4619      	mov	r1, r3
    8528:	4b2e      	ldr	r3, [pc, #184]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    852a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    852e:	b292      	uxth	r2, r2
    8530:	861a      	strh	r2, [r3, #48]	; 0x30
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LsbNext = NextChannelConfig->Lsb;
    8532:	9b01      	ldr	r3, [sp, #4]
    8534:	6a1b      	ldr	r3, [r3, #32]
    8536:	681b      	ldr	r3, [r3, #0]
    8538:	791b      	ldrb	r3, [r3, #4]
    853a:	461a      	mov	r2, r3
    853c:	4b29      	ldr	r3, [pc, #164]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    853e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8542:	9a02      	ldr	r2, [sp, #8]
    8544:	7952      	ldrb	r2, [r2, #5]
    8546:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->DefaultDataNext = NextChannelConfig->DefaultTransmitValue;
    854a:	9b01      	ldr	r3, [sp, #4]
    854c:	6a1b      	ldr	r3, [r3, #32]
    854e:	681b      	ldr	r3, [r3, #0]
    8550:	791b      	ldrb	r3, [r3, #4]
    8552:	461a      	mov	r2, r3
    8554:	4b23      	ldr	r3, [pc, #140]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    8556:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    855a:	9a02      	ldr	r2, [sp, #8]
    855c:	6892      	ldr	r2, [r2, #8]
    855e:	635a      	str	r2, [r3, #52]	; 0x34
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LengthNext = NextChannelConfig->ChannelState->Length;
    8560:	9b02      	ldr	r3, [sp, #8]
    8562:	699a      	ldr	r2, [r3, #24]
    8564:	9b01      	ldr	r3, [sp, #4]
    8566:	6a1b      	ldr	r3, [r3, #32]
    8568:	681b      	ldr	r3, [r3, #0]
    856a:	791b      	ldrb	r3, [r3, #4]
    856c:	4619      	mov	r1, r3
    856e:	4b1d      	ldr	r3, [pc, #116]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    8570:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    8574:	8852      	ldrh	r2, [r2, #2]
    8576:	871a      	strh	r2, [r3, #56]	; 0x38
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->NextChannelIsRX = FALSE;
                }
                #endif
            }
            
            if(0u == ChannelIndex)
    8578:	f89d 301f 	ldrb.w	r3, [sp, #31]
    857c:	2b00      	cmp	r3, #0
    857e:	d10a      	bne.n	8596 <Spi_Ipw_SyncTransmit+0x1c6>
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = TRUE;
    8580:	9b01      	ldr	r3, [sp, #4]
    8582:	6a1b      	ldr	r3, [r3, #32]
    8584:	681b      	ldr	r3, [r3, #0]
    8586:	791b      	ldrb	r3, [r3, #4]
    8588:	461a      	mov	r2, r3
    858a:	4b16      	ldr	r3, [pc, #88]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    858c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8590:	2201      	movs	r2, #1
    8592:	775a      	strb	r2, [r3, #29]
    8594:	e009      	b.n	85aa <Spi_Ipw_SyncTransmit+0x1da>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = FALSE;
    8596:	9b01      	ldr	r3, [sp, #4]
    8598:	6a1b      	ldr	r3, [r3, #32]
    859a:	681b      	ldr	r3, [r3, #0]
    859c:	791b      	ldrb	r3, [r3, #4]
    859e:	461a      	mov	r2, r3
    85a0:	4b10      	ldr	r3, [pc, #64]	; (85e4 <Spi_Ipw_SyncTransmit+0x214>)
    85a2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    85a6:	2200      	movs	r2, #0
    85a8:	775a      	strb	r2, [r3, #29]
            }
        }
        Ipw_Status = Spi_Ipw_SyncTransmitProcess(JobConfig, ChannelConfig, RxBuffer, (const uint8*)TxBuffer);
    85aa:	9b08      	ldr	r3, [sp, #32]
    85ac:	9a03      	ldr	r2, [sp, #12]
    85ae:	9904      	ldr	r1, [sp, #16]
    85b0:	9801      	ldr	r0, [sp, #4]
    85b2:	f7ff fe7f 	bl	82b4 <Spi_Ipw_SyncTransmitProcess>
    85b6:	4603      	mov	r3, r0
    85b8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    85bc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    85c0:	3301      	adds	r3, #1
    85c2:	f88d 301f 	strb.w	r3, [sp, #31]
    85c6:	f89d 201f 	ldrb.w	r2, [sp, #31]
    85ca:	f89d 3017 	ldrb.w	r3, [sp, #23]
    85ce:	429a      	cmp	r2, r3
    85d0:	f4ff af12 	bcc.w	83f8 <Spi_Ipw_SyncTransmit+0x28>
    }
    return Ipw_Status;
    85d4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    85d8:	4618      	mov	r0, r3
    85da:	b00b      	add	sp, #44	; 0x2c
    85dc:	f85d fb04 	ldr.w	pc, [sp], #4
    85e0:	1fff8d4c 	.word	0x1fff8d4c
    85e4:	1fff8d38 	.word	0x1fff8d38

000085e8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    85e8:	b500      	push	{lr}
    85ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    85ec:	f7f8 fb52 	bl	c94 <Sys_GetCoreID>
    85f0:	4603      	mov	r3, r0
    85f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    85f4:	4a10      	ldr	r2, [pc, #64]	; (8638 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    85f6:	9b01      	ldr	r3, [sp, #4]
    85f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85fc:	2b00      	cmp	r3, #0
    85fe:	d10d      	bne.n	861c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8600:	f7f8 fa66 	bl	ad0 <Mcu_schm_read_msr>
    8604:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8606:	9b00      	ldr	r3, [sp, #0]
    8608:	f003 0301 	and.w	r3, r3, #1
    860c:	2b00      	cmp	r3, #0
    860e:	d100      	bne.n	8612 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8610:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    8612:	490a      	ldr	r1, [pc, #40]	; (863c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    8614:	9b01      	ldr	r3, [sp, #4]
    8616:	9a00      	ldr	r2, [sp, #0]
    8618:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    861c:	4a06      	ldr	r2, [pc, #24]	; (8638 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    861e:	9b01      	ldr	r3, [sp, #4]
    8620:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8624:	1c5a      	adds	r2, r3, #1
    8626:	4904      	ldr	r1, [pc, #16]	; (8638 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    8628:	9b01      	ldr	r3, [sp, #4]
    862a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    862e:	bf00      	nop
    8630:	b003      	add	sp, #12
    8632:	f85d fb04 	ldr.w	pc, [sp], #4
    8636:	bf00      	nop
    8638:	1fff8d80 	.word	0x1fff8d80
    863c:	1fff8d7c 	.word	0x1fff8d7c

00008640 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    8640:	b500      	push	{lr}
    8642:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8644:	f7f8 fb26 	bl	c94 <Sys_GetCoreID>
    8648:	4603      	mov	r3, r0
    864a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    864c:	4a0d      	ldr	r2, [pc, #52]	; (8684 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    864e:	9b01      	ldr	r3, [sp, #4]
    8650:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8654:	1e5a      	subs	r2, r3, #1
    8656:	490b      	ldr	r1, [pc, #44]	; (8684 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    8658:	9b01      	ldr	r3, [sp, #4]
    865a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    865e:	4a0a      	ldr	r2, [pc, #40]	; (8688 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    8660:	9b01      	ldr	r3, [sp, #4]
    8662:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8666:	f003 0301 	and.w	r3, r3, #1
    866a:	2b00      	cmp	r3, #0
    866c:	d106      	bne.n	867c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    866e:	4a05      	ldr	r2, [pc, #20]	; (8684 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    8670:	9b01      	ldr	r3, [sp, #4]
    8672:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8676:	2b00      	cmp	r3, #0
    8678:	d100      	bne.n	867c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    867a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    867c:	bf00      	nop
    867e:	b003      	add	sp, #12
    8680:	f85d fb04 	ldr.w	pc, [sp], #4
    8684:	1fff8d80 	.word	0x1fff8d80
    8688:	1fff8d7c 	.word	0x1fff8d7c

0000868c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    868c:	b500      	push	{lr}
    868e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8690:	f7f8 fb00 	bl	c94 <Sys_GetCoreID>
    8694:	4603      	mov	r3, r0
    8696:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    8698:	4a10      	ldr	r2, [pc, #64]	; (86dc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    869a:	9b01      	ldr	r3, [sp, #4]
    869c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86a0:	2b00      	cmp	r3, #0
    86a2:	d10d      	bne.n	86c0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    86a4:	f7f8 fa14 	bl	ad0 <Mcu_schm_read_msr>
    86a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    86aa:	9b00      	ldr	r3, [sp, #0]
    86ac:	f003 0301 	and.w	r3, r3, #1
    86b0:	2b00      	cmp	r3, #0
    86b2:	d100      	bne.n	86b6 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    86b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    86b6:	490a      	ldr	r1, [pc, #40]	; (86e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    86b8:	9b01      	ldr	r3, [sp, #4]
    86ba:	9a00      	ldr	r2, [sp, #0]
    86bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    86c0:	4a06      	ldr	r2, [pc, #24]	; (86dc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    86c2:	9b01      	ldr	r3, [sp, #4]
    86c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86c8:	1c5a      	adds	r2, r3, #1
    86ca:	4904      	ldr	r1, [pc, #16]	; (86dc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    86cc:	9b01      	ldr	r3, [sp, #4]
    86ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    86d2:	bf00      	nop
    86d4:	b003      	add	sp, #12
    86d6:	f85d fb04 	ldr.w	pc, [sp], #4
    86da:	bf00      	nop
    86dc:	1fff8d88 	.word	0x1fff8d88
    86e0:	1fff8d84 	.word	0x1fff8d84

000086e4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    86e4:	b500      	push	{lr}
    86e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    86e8:	f7f8 fad4 	bl	c94 <Sys_GetCoreID>
    86ec:	4603      	mov	r3, r0
    86ee:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    86f0:	4a0d      	ldr	r2, [pc, #52]	; (8728 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    86f2:	9b01      	ldr	r3, [sp, #4]
    86f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86f8:	1e5a      	subs	r2, r3, #1
    86fa:	490b      	ldr	r1, [pc, #44]	; (8728 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    86fc:	9b01      	ldr	r3, [sp, #4]
    86fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    8702:	4a0a      	ldr	r2, [pc, #40]	; (872c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    8704:	9b01      	ldr	r3, [sp, #4]
    8706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    870a:	f003 0301 	and.w	r3, r3, #1
    870e:	2b00      	cmp	r3, #0
    8710:	d106      	bne.n	8720 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    8712:	4a05      	ldr	r2, [pc, #20]	; (8728 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    8714:	9b01      	ldr	r3, [sp, #4]
    8716:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    871a:	2b00      	cmp	r3, #0
    871c:	d100      	bne.n	8720 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    871e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8720:	bf00      	nop
    8722:	b003      	add	sp, #12
    8724:	f85d fb04 	ldr.w	pc, [sp], #4
    8728:	1fff8d88 	.word	0x1fff8d88
    872c:	1fff8d84 	.word	0x1fff8d84

00008730 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    8730:	b500      	push	{lr}
    8732:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8734:	f7f8 faae 	bl	c94 <Sys_GetCoreID>
    8738:	4603      	mov	r3, r0
    873a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    873c:	4a10      	ldr	r2, [pc, #64]	; (8780 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    873e:	9b01      	ldr	r3, [sp, #4]
    8740:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8744:	2b00      	cmp	r3, #0
    8746:	d10d      	bne.n	8764 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8748:	f7f8 f9c2 	bl	ad0 <Mcu_schm_read_msr>
    874c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    874e:	9b00      	ldr	r3, [sp, #0]
    8750:	f003 0301 	and.w	r3, r3, #1
    8754:	2b00      	cmp	r3, #0
    8756:	d100      	bne.n	875a <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8758:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    875a:	490a      	ldr	r1, [pc, #40]	; (8784 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    875c:	9b01      	ldr	r3, [sp, #4]
    875e:	9a00      	ldr	r2, [sp, #0]
    8760:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    8764:	4a06      	ldr	r2, [pc, #24]	; (8780 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    8766:	9b01      	ldr	r3, [sp, #4]
    8768:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    876c:	1c5a      	adds	r2, r3, #1
    876e:	4904      	ldr	r1, [pc, #16]	; (8780 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    8770:	9b01      	ldr	r3, [sp, #4]
    8772:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8776:	bf00      	nop
    8778:	b003      	add	sp, #12
    877a:	f85d fb04 	ldr.w	pc, [sp], #4
    877e:	bf00      	nop
    8780:	1fff8d90 	.word	0x1fff8d90
    8784:	1fff8d8c 	.word	0x1fff8d8c

00008788 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    8788:	b500      	push	{lr}
    878a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    878c:	f7f8 fa82 	bl	c94 <Sys_GetCoreID>
    8790:	4603      	mov	r3, r0
    8792:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    8794:	4a0d      	ldr	r2, [pc, #52]	; (87cc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    8796:	9b01      	ldr	r3, [sp, #4]
    8798:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    879c:	1e5a      	subs	r2, r3, #1
    879e:	490b      	ldr	r1, [pc, #44]	; (87cc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    87a0:	9b01      	ldr	r3, [sp, #4]
    87a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    87a6:	4a0a      	ldr	r2, [pc, #40]	; (87d0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    87a8:	9b01      	ldr	r3, [sp, #4]
    87aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87ae:	f003 0301 	and.w	r3, r3, #1
    87b2:	2b00      	cmp	r3, #0
    87b4:	d106      	bne.n	87c4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    87b6:	4a05      	ldr	r2, [pc, #20]	; (87cc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    87b8:	9b01      	ldr	r3, [sp, #4]
    87ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87be:	2b00      	cmp	r3, #0
    87c0:	d100      	bne.n	87c4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    87c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    87c4:	bf00      	nop
    87c6:	b003      	add	sp, #12
    87c8:	f85d fb04 	ldr.w	pc, [sp], #4
    87cc:	1fff8d90 	.word	0x1fff8d90
    87d0:	1fff8d8c 	.word	0x1fff8d8c

000087d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    87d4:	b500      	push	{lr}
    87d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87d8:	f7f8 fa5c 	bl	c94 <Sys_GetCoreID>
    87dc:	4603      	mov	r3, r0
    87de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    87e0:	4a10      	ldr	r2, [pc, #64]	; (8824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    87e2:	9b01      	ldr	r3, [sp, #4]
    87e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87e8:	2b00      	cmp	r3, #0
    87ea:	d10d      	bne.n	8808 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    87ec:	f7f8 f979 	bl	ae2 <Port_schm_read_msr>
    87f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    87f2:	9b00      	ldr	r3, [sp, #0]
    87f4:	f003 0301 	and.w	r3, r3, #1
    87f8:	2b00      	cmp	r3, #0
    87fa:	d100      	bne.n	87fe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    87fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    87fe:	490a      	ldr	r1, [pc, #40]	; (8828 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    8800:	9b01      	ldr	r3, [sp, #4]
    8802:	9a00      	ldr	r2, [sp, #0]
    8804:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    8808:	4a06      	ldr	r2, [pc, #24]	; (8824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    880a:	9b01      	ldr	r3, [sp, #4]
    880c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8810:	1c5a      	adds	r2, r3, #1
    8812:	4904      	ldr	r1, [pc, #16]	; (8824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    8814:	9b01      	ldr	r3, [sp, #4]
    8816:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    881a:	bf00      	nop
    881c:	b003      	add	sp, #12
    881e:	f85d fb04 	ldr.w	pc, [sp], #4
    8822:	bf00      	nop
    8824:	1fff8d98 	.word	0x1fff8d98
    8828:	1fff8d94 	.word	0x1fff8d94

0000882c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    882c:	b500      	push	{lr}
    882e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8830:	f7f8 fa30 	bl	c94 <Sys_GetCoreID>
    8834:	4603      	mov	r3, r0
    8836:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    8838:	4a0d      	ldr	r2, [pc, #52]	; (8870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    883a:	9b01      	ldr	r3, [sp, #4]
    883c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8840:	1e5a      	subs	r2, r3, #1
    8842:	490b      	ldr	r1, [pc, #44]	; (8870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    8844:	9b01      	ldr	r3, [sp, #4]
    8846:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    884a:	4a0a      	ldr	r2, [pc, #40]	; (8874 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    884c:	9b01      	ldr	r3, [sp, #4]
    884e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8852:	f003 0301 	and.w	r3, r3, #1
    8856:	2b00      	cmp	r3, #0
    8858:	d106      	bne.n	8868 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    885a:	4a05      	ldr	r2, [pc, #20]	; (8870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    885c:	9b01      	ldr	r3, [sp, #4]
    885e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8862:	2b00      	cmp	r3, #0
    8864:	d100      	bne.n	8868 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8866:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8868:	bf00      	nop
    886a:	b003      	add	sp, #12
    886c:	f85d fb04 	ldr.w	pc, [sp], #4
    8870:	1fff8d98 	.word	0x1fff8d98
    8874:	1fff8d94 	.word	0x1fff8d94

00008878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    8878:	b500      	push	{lr}
    887a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    887c:	f7f8 fa0a 	bl	c94 <Sys_GetCoreID>
    8880:	4603      	mov	r3, r0
    8882:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    8884:	4a10      	ldr	r2, [pc, #64]	; (88c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    8886:	9b01      	ldr	r3, [sp, #4]
    8888:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    888c:	2b00      	cmp	r3, #0
    888e:	d10d      	bne.n	88ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8890:	f7f8 f927 	bl	ae2 <Port_schm_read_msr>
    8894:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8896:	9b00      	ldr	r3, [sp, #0]
    8898:	f003 0301 	and.w	r3, r3, #1
    889c:	2b00      	cmp	r3, #0
    889e:	d100      	bne.n	88a2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    88a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    88a2:	490a      	ldr	r1, [pc, #40]	; (88cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    88a4:	9b01      	ldr	r3, [sp, #4]
    88a6:	9a00      	ldr	r2, [sp, #0]
    88a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    88ac:	4a06      	ldr	r2, [pc, #24]	; (88c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    88ae:	9b01      	ldr	r3, [sp, #4]
    88b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88b4:	1c5a      	adds	r2, r3, #1
    88b6:	4904      	ldr	r1, [pc, #16]	; (88c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    88b8:	9b01      	ldr	r3, [sp, #4]
    88ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    88be:	bf00      	nop
    88c0:	b003      	add	sp, #12
    88c2:	f85d fb04 	ldr.w	pc, [sp], #4
    88c6:	bf00      	nop
    88c8:	1fff8da0 	.word	0x1fff8da0
    88cc:	1fff8d9c 	.word	0x1fff8d9c

000088d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    88d0:	b500      	push	{lr}
    88d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    88d4:	f7f8 f9de 	bl	c94 <Sys_GetCoreID>
    88d8:	4603      	mov	r3, r0
    88da:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    88dc:	4a0d      	ldr	r2, [pc, #52]	; (8914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    88de:	9b01      	ldr	r3, [sp, #4]
    88e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88e4:	1e5a      	subs	r2, r3, #1
    88e6:	490b      	ldr	r1, [pc, #44]	; (8914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    88e8:	9b01      	ldr	r3, [sp, #4]
    88ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    88ee:	4a0a      	ldr	r2, [pc, #40]	; (8918 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    88f0:	9b01      	ldr	r3, [sp, #4]
    88f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88f6:	f003 0301 	and.w	r3, r3, #1
    88fa:	2b00      	cmp	r3, #0
    88fc:	d106      	bne.n	890c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    88fe:	4a05      	ldr	r2, [pc, #20]	; (8914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    8900:	9b01      	ldr	r3, [sp, #4]
    8902:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8906:	2b00      	cmp	r3, #0
    8908:	d100      	bne.n	890c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    890a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    890c:	bf00      	nop
    890e:	b003      	add	sp, #12
    8910:	f85d fb04 	ldr.w	pc, [sp], #4
    8914:	1fff8da0 	.word	0x1fff8da0
    8918:	1fff8d9c 	.word	0x1fff8d9c

0000891c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    891c:	b500      	push	{lr}
    891e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8920:	f7f8 f9b8 	bl	c94 <Sys_GetCoreID>
    8924:	4603      	mov	r3, r0
    8926:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    8928:	4a10      	ldr	r2, [pc, #64]	; (896c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    892a:	9b01      	ldr	r3, [sp, #4]
    892c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8930:	2b00      	cmp	r3, #0
    8932:	d10d      	bne.n	8950 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8934:	f7f8 f8d5 	bl	ae2 <Port_schm_read_msr>
    8938:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    893a:	9b00      	ldr	r3, [sp, #0]
    893c:	f003 0301 	and.w	r3, r3, #1
    8940:	2b00      	cmp	r3, #0
    8942:	d100      	bne.n	8946 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8944:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    8946:	490a      	ldr	r1, [pc, #40]	; (8970 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    8948:	9b01      	ldr	r3, [sp, #4]
    894a:	9a00      	ldr	r2, [sp, #0]
    894c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    8950:	4a06      	ldr	r2, [pc, #24]	; (896c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    8952:	9b01      	ldr	r3, [sp, #4]
    8954:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8958:	1c5a      	adds	r2, r3, #1
    895a:	4904      	ldr	r1, [pc, #16]	; (896c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    895c:	9b01      	ldr	r3, [sp, #4]
    895e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8962:	bf00      	nop
    8964:	b003      	add	sp, #12
    8966:	f85d fb04 	ldr.w	pc, [sp], #4
    896a:	bf00      	nop
    896c:	1fff8da8 	.word	0x1fff8da8
    8970:	1fff8da4 	.word	0x1fff8da4

00008974 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    8974:	b500      	push	{lr}
    8976:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8978:	f7f8 f98c 	bl	c94 <Sys_GetCoreID>
    897c:	4603      	mov	r3, r0
    897e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    8980:	4a0d      	ldr	r2, [pc, #52]	; (89b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    8982:	9b01      	ldr	r3, [sp, #4]
    8984:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8988:	1e5a      	subs	r2, r3, #1
    898a:	490b      	ldr	r1, [pc, #44]	; (89b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    898c:	9b01      	ldr	r3, [sp, #4]
    898e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    8992:	4a0a      	ldr	r2, [pc, #40]	; (89bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    8994:	9b01      	ldr	r3, [sp, #4]
    8996:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    899a:	f003 0301 	and.w	r3, r3, #1
    899e:	2b00      	cmp	r3, #0
    89a0:	d106      	bne.n	89b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    89a2:	4a05      	ldr	r2, [pc, #20]	; (89b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    89a4:	9b01      	ldr	r3, [sp, #4]
    89a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89aa:	2b00      	cmp	r3, #0
    89ac:	d100      	bne.n	89b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    89ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    89b0:	bf00      	nop
    89b2:	b003      	add	sp, #12
    89b4:	f85d fb04 	ldr.w	pc, [sp], #4
    89b8:	1fff8da8 	.word	0x1fff8da8
    89bc:	1fff8da4 	.word	0x1fff8da4

000089c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    89c0:	b500      	push	{lr}
    89c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    89c4:	f7f8 f966 	bl	c94 <Sys_GetCoreID>
    89c8:	4603      	mov	r3, r0
    89ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    89cc:	4a10      	ldr	r2, [pc, #64]	; (8a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    89ce:	9b01      	ldr	r3, [sp, #4]
    89d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89d4:	2b00      	cmp	r3, #0
    89d6:	d10d      	bne.n	89f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    89d8:	f7f8 f883 	bl	ae2 <Port_schm_read_msr>
    89dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    89de:	9b00      	ldr	r3, [sp, #0]
    89e0:	f003 0301 	and.w	r3, r3, #1
    89e4:	2b00      	cmp	r3, #0
    89e6:	d100      	bne.n	89ea <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    89e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    89ea:	490a      	ldr	r1, [pc, #40]	; (8a14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    89ec:	9b01      	ldr	r3, [sp, #4]
    89ee:	9a00      	ldr	r2, [sp, #0]
    89f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    89f4:	4a06      	ldr	r2, [pc, #24]	; (8a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    89f6:	9b01      	ldr	r3, [sp, #4]
    89f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89fc:	1c5a      	adds	r2, r3, #1
    89fe:	4904      	ldr	r1, [pc, #16]	; (8a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    8a00:	9b01      	ldr	r3, [sp, #4]
    8a02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8a06:	bf00      	nop
    8a08:	b003      	add	sp, #12
    8a0a:	f85d fb04 	ldr.w	pc, [sp], #4
    8a0e:	bf00      	nop
    8a10:	1fff8db0 	.word	0x1fff8db0
    8a14:	1fff8dac 	.word	0x1fff8dac

00008a18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    8a18:	b500      	push	{lr}
    8a1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a1c:	f7f8 f93a 	bl	c94 <Sys_GetCoreID>
    8a20:	4603      	mov	r3, r0
    8a22:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    8a24:	4a0d      	ldr	r2, [pc, #52]	; (8a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    8a26:	9b01      	ldr	r3, [sp, #4]
    8a28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a2c:	1e5a      	subs	r2, r3, #1
    8a2e:	490b      	ldr	r1, [pc, #44]	; (8a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    8a30:	9b01      	ldr	r3, [sp, #4]
    8a32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    8a36:	4a0a      	ldr	r2, [pc, #40]	; (8a60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    8a38:	9b01      	ldr	r3, [sp, #4]
    8a3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a3e:	f003 0301 	and.w	r3, r3, #1
    8a42:	2b00      	cmp	r3, #0
    8a44:	d106      	bne.n	8a54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    8a46:	4a05      	ldr	r2, [pc, #20]	; (8a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    8a48:	9b01      	ldr	r3, [sp, #4]
    8a4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a4e:	2b00      	cmp	r3, #0
    8a50:	d100      	bne.n	8a54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8a52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8a54:	bf00      	nop
    8a56:	b003      	add	sp, #12
    8a58:	f85d fb04 	ldr.w	pc, [sp], #4
    8a5c:	1fff8db0 	.word	0x1fff8db0
    8a60:	1fff8dac 	.word	0x1fff8dac

00008a64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    8a64:	b500      	push	{lr}
    8a66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a68:	f7f8 f914 	bl	c94 <Sys_GetCoreID>
    8a6c:	4603      	mov	r3, r0
    8a6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    8a70:	4a10      	ldr	r2, [pc, #64]	; (8ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    8a72:	9b01      	ldr	r3, [sp, #4]
    8a74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a78:	2b00      	cmp	r3, #0
    8a7a:	d10d      	bne.n	8a98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8a7c:	f7f8 f831 	bl	ae2 <Port_schm_read_msr>
    8a80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8a82:	9b00      	ldr	r3, [sp, #0]
    8a84:	f003 0301 	and.w	r3, r3, #1
    8a88:	2b00      	cmp	r3, #0
    8a8a:	d100      	bne.n	8a8e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8a8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    8a8e:	490a      	ldr	r1, [pc, #40]	; (8ab8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    8a90:	9b01      	ldr	r3, [sp, #4]
    8a92:	9a00      	ldr	r2, [sp, #0]
    8a94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    8a98:	4a06      	ldr	r2, [pc, #24]	; (8ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    8a9a:	9b01      	ldr	r3, [sp, #4]
    8a9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aa0:	1c5a      	adds	r2, r3, #1
    8aa2:	4904      	ldr	r1, [pc, #16]	; (8ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    8aa4:	9b01      	ldr	r3, [sp, #4]
    8aa6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8aaa:	bf00      	nop
    8aac:	b003      	add	sp, #12
    8aae:	f85d fb04 	ldr.w	pc, [sp], #4
    8ab2:	bf00      	nop
    8ab4:	1fff8db8 	.word	0x1fff8db8
    8ab8:	1fff8db4 	.word	0x1fff8db4

00008abc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    8abc:	b500      	push	{lr}
    8abe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ac0:	f7f8 f8e8 	bl	c94 <Sys_GetCoreID>
    8ac4:	4603      	mov	r3, r0
    8ac6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    8ac8:	4a0d      	ldr	r2, [pc, #52]	; (8b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    8aca:	9b01      	ldr	r3, [sp, #4]
    8acc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ad0:	1e5a      	subs	r2, r3, #1
    8ad2:	490b      	ldr	r1, [pc, #44]	; (8b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    8ad4:	9b01      	ldr	r3, [sp, #4]
    8ad6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    8ada:	4a0a      	ldr	r2, [pc, #40]	; (8b04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    8adc:	9b01      	ldr	r3, [sp, #4]
    8ade:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ae2:	f003 0301 	and.w	r3, r3, #1
    8ae6:	2b00      	cmp	r3, #0
    8ae8:	d106      	bne.n	8af8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    8aea:	4a05      	ldr	r2, [pc, #20]	; (8b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    8aec:	9b01      	ldr	r3, [sp, #4]
    8aee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8af2:	2b00      	cmp	r3, #0
    8af4:	d100      	bne.n	8af8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8af6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8af8:	bf00      	nop
    8afa:	b003      	add	sp, #12
    8afc:	f85d fb04 	ldr.w	pc, [sp], #4
    8b00:	1fff8db8 	.word	0x1fff8db8
    8b04:	1fff8db4 	.word	0x1fff8db4

00008b08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    8b08:	b500      	push	{lr}
    8b0a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b0c:	f7f8 f8c2 	bl	c94 <Sys_GetCoreID>
    8b10:	4603      	mov	r3, r0
    8b12:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    8b14:	4a10      	ldr	r2, [pc, #64]	; (8b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    8b16:	9b01      	ldr	r3, [sp, #4]
    8b18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b1c:	2b00      	cmp	r3, #0
    8b1e:	d10d      	bne.n	8b3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8b20:	f7f7 ffdf 	bl	ae2 <Port_schm_read_msr>
    8b24:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8b26:	9b00      	ldr	r3, [sp, #0]
    8b28:	f003 0301 	and.w	r3, r3, #1
    8b2c:	2b00      	cmp	r3, #0
    8b2e:	d100      	bne.n	8b32 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8b30:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    8b32:	490a      	ldr	r1, [pc, #40]	; (8b5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    8b34:	9b01      	ldr	r3, [sp, #4]
    8b36:	9a00      	ldr	r2, [sp, #0]
    8b38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    8b3c:	4a06      	ldr	r2, [pc, #24]	; (8b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    8b3e:	9b01      	ldr	r3, [sp, #4]
    8b40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b44:	1c5a      	adds	r2, r3, #1
    8b46:	4904      	ldr	r1, [pc, #16]	; (8b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    8b48:	9b01      	ldr	r3, [sp, #4]
    8b4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8b4e:	bf00      	nop
    8b50:	b003      	add	sp, #12
    8b52:	f85d fb04 	ldr.w	pc, [sp], #4
    8b56:	bf00      	nop
    8b58:	1fff8dc0 	.word	0x1fff8dc0
    8b5c:	1fff8dbc 	.word	0x1fff8dbc

00008b60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    8b60:	b500      	push	{lr}
    8b62:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b64:	f7f8 f896 	bl	c94 <Sys_GetCoreID>
    8b68:	4603      	mov	r3, r0
    8b6a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    8b6c:	4a0d      	ldr	r2, [pc, #52]	; (8ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    8b6e:	9b01      	ldr	r3, [sp, #4]
    8b70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b74:	1e5a      	subs	r2, r3, #1
    8b76:	490b      	ldr	r1, [pc, #44]	; (8ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    8b78:	9b01      	ldr	r3, [sp, #4]
    8b7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    8b7e:	4a0a      	ldr	r2, [pc, #40]	; (8ba8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    8b80:	9b01      	ldr	r3, [sp, #4]
    8b82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b86:	f003 0301 	and.w	r3, r3, #1
    8b8a:	2b00      	cmp	r3, #0
    8b8c:	d106      	bne.n	8b9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    8b8e:	4a05      	ldr	r2, [pc, #20]	; (8ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    8b90:	9b01      	ldr	r3, [sp, #4]
    8b92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b96:	2b00      	cmp	r3, #0
    8b98:	d100      	bne.n	8b9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8b9a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8b9c:	bf00      	nop
    8b9e:	b003      	add	sp, #12
    8ba0:	f85d fb04 	ldr.w	pc, [sp], #4
    8ba4:	1fff8dc0 	.word	0x1fff8dc0
    8ba8:	1fff8dbc 	.word	0x1fff8dbc

00008bac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    8bac:	b500      	push	{lr}
    8bae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8bb0:	f7f8 f870 	bl	c94 <Sys_GetCoreID>
    8bb4:	4603      	mov	r3, r0
    8bb6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    8bb8:	4a10      	ldr	r2, [pc, #64]	; (8bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    8bba:	9b01      	ldr	r3, [sp, #4]
    8bbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bc0:	2b00      	cmp	r3, #0
    8bc2:	d10d      	bne.n	8be0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8bc4:	f7f7 ff8d 	bl	ae2 <Port_schm_read_msr>
    8bc8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8bca:	9b00      	ldr	r3, [sp, #0]
    8bcc:	f003 0301 	and.w	r3, r3, #1
    8bd0:	2b00      	cmp	r3, #0
    8bd2:	d100      	bne.n	8bd6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8bd4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    8bd6:	490a      	ldr	r1, [pc, #40]	; (8c00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    8bd8:	9b01      	ldr	r3, [sp, #4]
    8bda:	9a00      	ldr	r2, [sp, #0]
    8bdc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    8be0:	4a06      	ldr	r2, [pc, #24]	; (8bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    8be2:	9b01      	ldr	r3, [sp, #4]
    8be4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8be8:	1c5a      	adds	r2, r3, #1
    8bea:	4904      	ldr	r1, [pc, #16]	; (8bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    8bec:	9b01      	ldr	r3, [sp, #4]
    8bee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8bf2:	bf00      	nop
    8bf4:	b003      	add	sp, #12
    8bf6:	f85d fb04 	ldr.w	pc, [sp], #4
    8bfa:	bf00      	nop
    8bfc:	1fff8dc8 	.word	0x1fff8dc8
    8c00:	1fff8dc4 	.word	0x1fff8dc4

00008c04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    8c04:	b500      	push	{lr}
    8c06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c08:	f7f8 f844 	bl	c94 <Sys_GetCoreID>
    8c0c:	4603      	mov	r3, r0
    8c0e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    8c10:	4a0d      	ldr	r2, [pc, #52]	; (8c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8c12:	9b01      	ldr	r3, [sp, #4]
    8c14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c18:	1e5a      	subs	r2, r3, #1
    8c1a:	490b      	ldr	r1, [pc, #44]	; (8c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8c1c:	9b01      	ldr	r3, [sp, #4]
    8c1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    8c22:	4a0a      	ldr	r2, [pc, #40]	; (8c4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    8c24:	9b01      	ldr	r3, [sp, #4]
    8c26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c2a:	f003 0301 	and.w	r3, r3, #1
    8c2e:	2b00      	cmp	r3, #0
    8c30:	d106      	bne.n	8c40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    8c32:	4a05      	ldr	r2, [pc, #20]	; (8c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    8c34:	9b01      	ldr	r3, [sp, #4]
    8c36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c3a:	2b00      	cmp	r3, #0
    8c3c:	d100      	bne.n	8c40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8c3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8c40:	bf00      	nop
    8c42:	b003      	add	sp, #12
    8c44:	f85d fb04 	ldr.w	pc, [sp], #4
    8c48:	1fff8dc8 	.word	0x1fff8dc8
    8c4c:	1fff8dc4 	.word	0x1fff8dc4

00008c50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    8c50:	b500      	push	{lr}
    8c52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c54:	f7f8 f81e 	bl	c94 <Sys_GetCoreID>
    8c58:	4603      	mov	r3, r0
    8c5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    8c5c:	4a10      	ldr	r2, [pc, #64]	; (8ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    8c5e:	9b01      	ldr	r3, [sp, #4]
    8c60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c64:	2b00      	cmp	r3, #0
    8c66:	d10d      	bne.n	8c84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8c68:	f7f7 ff3b 	bl	ae2 <Port_schm_read_msr>
    8c6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8c6e:	9b00      	ldr	r3, [sp, #0]
    8c70:	f003 0301 	and.w	r3, r3, #1
    8c74:	2b00      	cmp	r3, #0
    8c76:	d100      	bne.n	8c7a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8c78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    8c7a:	490a      	ldr	r1, [pc, #40]	; (8ca4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    8c7c:	9b01      	ldr	r3, [sp, #4]
    8c7e:	9a00      	ldr	r2, [sp, #0]
    8c80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    8c84:	4a06      	ldr	r2, [pc, #24]	; (8ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    8c86:	9b01      	ldr	r3, [sp, #4]
    8c88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c8c:	1c5a      	adds	r2, r3, #1
    8c8e:	4904      	ldr	r1, [pc, #16]	; (8ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    8c90:	9b01      	ldr	r3, [sp, #4]
    8c92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8c96:	bf00      	nop
    8c98:	b003      	add	sp, #12
    8c9a:	f85d fb04 	ldr.w	pc, [sp], #4
    8c9e:	bf00      	nop
    8ca0:	1fff8dd0 	.word	0x1fff8dd0
    8ca4:	1fff8dcc 	.word	0x1fff8dcc

00008ca8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    8ca8:	b500      	push	{lr}
    8caa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8cac:	f7f7 fff2 	bl	c94 <Sys_GetCoreID>
    8cb0:	4603      	mov	r3, r0
    8cb2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    8cb4:	4a0d      	ldr	r2, [pc, #52]	; (8cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    8cb6:	9b01      	ldr	r3, [sp, #4]
    8cb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cbc:	1e5a      	subs	r2, r3, #1
    8cbe:	490b      	ldr	r1, [pc, #44]	; (8cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    8cc0:	9b01      	ldr	r3, [sp, #4]
    8cc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    8cc6:	4a0a      	ldr	r2, [pc, #40]	; (8cf0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    8cc8:	9b01      	ldr	r3, [sp, #4]
    8cca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cce:	f003 0301 	and.w	r3, r3, #1
    8cd2:	2b00      	cmp	r3, #0
    8cd4:	d106      	bne.n	8ce4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    8cd6:	4a05      	ldr	r2, [pc, #20]	; (8cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    8cd8:	9b01      	ldr	r3, [sp, #4]
    8cda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cde:	2b00      	cmp	r3, #0
    8ce0:	d100      	bne.n	8ce4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8ce2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8ce4:	bf00      	nop
    8ce6:	b003      	add	sp, #12
    8ce8:	f85d fb04 	ldr.w	pc, [sp], #4
    8cec:	1fff8dd0 	.word	0x1fff8dd0
    8cf0:	1fff8dcc 	.word	0x1fff8dcc

00008cf4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    8cf4:	b500      	push	{lr}
    8cf6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8cf8:	f7f7 ffcc 	bl	c94 <Sys_GetCoreID>
    8cfc:	4603      	mov	r3, r0
    8cfe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    8d00:	4a10      	ldr	r2, [pc, #64]	; (8d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    8d02:	9b01      	ldr	r3, [sp, #4]
    8d04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d08:	2b00      	cmp	r3, #0
    8d0a:	d10d      	bne.n	8d28 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8d0c:	f7f7 fee9 	bl	ae2 <Port_schm_read_msr>
    8d10:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8d12:	9b00      	ldr	r3, [sp, #0]
    8d14:	f003 0301 	and.w	r3, r3, #1
    8d18:	2b00      	cmp	r3, #0
    8d1a:	d100      	bne.n	8d1e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8d1c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    8d1e:	490a      	ldr	r1, [pc, #40]	; (8d48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    8d20:	9b01      	ldr	r3, [sp, #4]
    8d22:	9a00      	ldr	r2, [sp, #0]
    8d24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    8d28:	4a06      	ldr	r2, [pc, #24]	; (8d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    8d2a:	9b01      	ldr	r3, [sp, #4]
    8d2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d30:	1c5a      	adds	r2, r3, #1
    8d32:	4904      	ldr	r1, [pc, #16]	; (8d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    8d34:	9b01      	ldr	r3, [sp, #4]
    8d36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8d3a:	bf00      	nop
    8d3c:	b003      	add	sp, #12
    8d3e:	f85d fb04 	ldr.w	pc, [sp], #4
    8d42:	bf00      	nop
    8d44:	1fff8dd8 	.word	0x1fff8dd8
    8d48:	1fff8dd4 	.word	0x1fff8dd4

00008d4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    8d4c:	b500      	push	{lr}
    8d4e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d50:	f7f7 ffa0 	bl	c94 <Sys_GetCoreID>
    8d54:	4603      	mov	r3, r0
    8d56:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    8d58:	4a0d      	ldr	r2, [pc, #52]	; (8d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    8d5a:	9b01      	ldr	r3, [sp, #4]
    8d5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d60:	1e5a      	subs	r2, r3, #1
    8d62:	490b      	ldr	r1, [pc, #44]	; (8d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    8d64:	9b01      	ldr	r3, [sp, #4]
    8d66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    8d6a:	4a0a      	ldr	r2, [pc, #40]	; (8d94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    8d6c:	9b01      	ldr	r3, [sp, #4]
    8d6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d72:	f003 0301 	and.w	r3, r3, #1
    8d76:	2b00      	cmp	r3, #0
    8d78:	d106      	bne.n	8d88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    8d7a:	4a05      	ldr	r2, [pc, #20]	; (8d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    8d7c:	9b01      	ldr	r3, [sp, #4]
    8d7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d82:	2b00      	cmp	r3, #0
    8d84:	d100      	bne.n	8d88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8d86:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8d88:	bf00      	nop
    8d8a:	b003      	add	sp, #12
    8d8c:	f85d fb04 	ldr.w	pc, [sp], #4
    8d90:	1fff8dd8 	.word	0x1fff8dd8
    8d94:	1fff8dd4 	.word	0x1fff8dd4

00008d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    8d98:	b500      	push	{lr}
    8d9a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d9c:	f7f7 ff7a 	bl	c94 <Sys_GetCoreID>
    8da0:	4603      	mov	r3, r0
    8da2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    8da4:	4a10      	ldr	r2, [pc, #64]	; (8de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    8da6:	9b01      	ldr	r3, [sp, #4]
    8da8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dac:	2b00      	cmp	r3, #0
    8dae:	d10d      	bne.n	8dcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8db0:	f7f7 fe97 	bl	ae2 <Port_schm_read_msr>
    8db4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8db6:	9b00      	ldr	r3, [sp, #0]
    8db8:	f003 0301 	and.w	r3, r3, #1
    8dbc:	2b00      	cmp	r3, #0
    8dbe:	d100      	bne.n	8dc2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8dc0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    8dc2:	490a      	ldr	r1, [pc, #40]	; (8dec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    8dc4:	9b01      	ldr	r3, [sp, #4]
    8dc6:	9a00      	ldr	r2, [sp, #0]
    8dc8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    8dcc:	4a06      	ldr	r2, [pc, #24]	; (8de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    8dce:	9b01      	ldr	r3, [sp, #4]
    8dd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dd4:	1c5a      	adds	r2, r3, #1
    8dd6:	4904      	ldr	r1, [pc, #16]	; (8de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    8dd8:	9b01      	ldr	r3, [sp, #4]
    8dda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8dde:	bf00      	nop
    8de0:	b003      	add	sp, #12
    8de2:	f85d fb04 	ldr.w	pc, [sp], #4
    8de6:	bf00      	nop
    8de8:	1fff8de0 	.word	0x1fff8de0
    8dec:	1fff8ddc 	.word	0x1fff8ddc

00008df0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    8df0:	b500      	push	{lr}
    8df2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8df4:	f7f7 ff4e 	bl	c94 <Sys_GetCoreID>
    8df8:	4603      	mov	r3, r0
    8dfa:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    8dfc:	4a0d      	ldr	r2, [pc, #52]	; (8e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    8dfe:	9b01      	ldr	r3, [sp, #4]
    8e00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e04:	1e5a      	subs	r2, r3, #1
    8e06:	490b      	ldr	r1, [pc, #44]	; (8e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    8e08:	9b01      	ldr	r3, [sp, #4]
    8e0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    8e0e:	4a0a      	ldr	r2, [pc, #40]	; (8e38 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    8e10:	9b01      	ldr	r3, [sp, #4]
    8e12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e16:	f003 0301 	and.w	r3, r3, #1
    8e1a:	2b00      	cmp	r3, #0
    8e1c:	d106      	bne.n	8e2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    8e1e:	4a05      	ldr	r2, [pc, #20]	; (8e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    8e20:	9b01      	ldr	r3, [sp, #4]
    8e22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e26:	2b00      	cmp	r3, #0
    8e28:	d100      	bne.n	8e2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8e2a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8e2c:	bf00      	nop
    8e2e:	b003      	add	sp, #12
    8e30:	f85d fb04 	ldr.w	pc, [sp], #4
    8e34:	1fff8de0 	.word	0x1fff8de0
    8e38:	1fff8ddc 	.word	0x1fff8ddc

00008e3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    8e3c:	b500      	push	{lr}
    8e3e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e40:	f7f7 ff28 	bl	c94 <Sys_GetCoreID>
    8e44:	4603      	mov	r3, r0
    8e46:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    8e48:	4a10      	ldr	r2, [pc, #64]	; (8e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    8e4a:	9b01      	ldr	r3, [sp, #4]
    8e4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e50:	2b00      	cmp	r3, #0
    8e52:	d10d      	bne.n	8e70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8e54:	f7f7 fe45 	bl	ae2 <Port_schm_read_msr>
    8e58:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8e5a:	9b00      	ldr	r3, [sp, #0]
    8e5c:	f003 0301 	and.w	r3, r3, #1
    8e60:	2b00      	cmp	r3, #0
    8e62:	d100      	bne.n	8e66 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8e64:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    8e66:	490a      	ldr	r1, [pc, #40]	; (8e90 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    8e68:	9b01      	ldr	r3, [sp, #4]
    8e6a:	9a00      	ldr	r2, [sp, #0]
    8e6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    8e70:	4a06      	ldr	r2, [pc, #24]	; (8e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    8e72:	9b01      	ldr	r3, [sp, #4]
    8e74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e78:	1c5a      	adds	r2, r3, #1
    8e7a:	4904      	ldr	r1, [pc, #16]	; (8e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    8e7c:	9b01      	ldr	r3, [sp, #4]
    8e7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8e82:	bf00      	nop
    8e84:	b003      	add	sp, #12
    8e86:	f85d fb04 	ldr.w	pc, [sp], #4
    8e8a:	bf00      	nop
    8e8c:	1fff8de8 	.word	0x1fff8de8
    8e90:	1fff8de4 	.word	0x1fff8de4

00008e94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    8e94:	b500      	push	{lr}
    8e96:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e98:	f7f7 fefc 	bl	c94 <Sys_GetCoreID>
    8e9c:	4603      	mov	r3, r0
    8e9e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    8ea0:	4a0d      	ldr	r2, [pc, #52]	; (8ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    8ea2:	9b01      	ldr	r3, [sp, #4]
    8ea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ea8:	1e5a      	subs	r2, r3, #1
    8eaa:	490b      	ldr	r1, [pc, #44]	; (8ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    8eac:	9b01      	ldr	r3, [sp, #4]
    8eae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    8eb2:	4a0a      	ldr	r2, [pc, #40]	; (8edc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    8eb4:	9b01      	ldr	r3, [sp, #4]
    8eb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8eba:	f003 0301 	and.w	r3, r3, #1
    8ebe:	2b00      	cmp	r3, #0
    8ec0:	d106      	bne.n	8ed0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    8ec2:	4a05      	ldr	r2, [pc, #20]	; (8ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    8ec4:	9b01      	ldr	r3, [sp, #4]
    8ec6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8eca:	2b00      	cmp	r3, #0
    8ecc:	d100      	bne.n	8ed0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8ece:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8ed0:	bf00      	nop
    8ed2:	b003      	add	sp, #12
    8ed4:	f85d fb04 	ldr.w	pc, [sp], #4
    8ed8:	1fff8de8 	.word	0x1fff8de8
    8edc:	1fff8de4 	.word	0x1fff8de4

00008ee0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    8ee0:	b500      	push	{lr}
    8ee2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ee4:	f7f7 fed6 	bl	c94 <Sys_GetCoreID>
    8ee8:	4603      	mov	r3, r0
    8eea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    8eec:	4a10      	ldr	r2, [pc, #64]	; (8f30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    8eee:	9b01      	ldr	r3, [sp, #4]
    8ef0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ef4:	2b00      	cmp	r3, #0
    8ef6:	d10d      	bne.n	8f14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8ef8:	f7f7 fdf3 	bl	ae2 <Port_schm_read_msr>
    8efc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8efe:	9b00      	ldr	r3, [sp, #0]
    8f00:	f003 0301 	and.w	r3, r3, #1
    8f04:	2b00      	cmp	r3, #0
    8f06:	d100      	bne.n	8f0a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8f08:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    8f0a:	490a      	ldr	r1, [pc, #40]	; (8f34 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    8f0c:	9b01      	ldr	r3, [sp, #4]
    8f0e:	9a00      	ldr	r2, [sp, #0]
    8f10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    8f14:	4a06      	ldr	r2, [pc, #24]	; (8f30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    8f16:	9b01      	ldr	r3, [sp, #4]
    8f18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f1c:	1c5a      	adds	r2, r3, #1
    8f1e:	4904      	ldr	r1, [pc, #16]	; (8f30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    8f20:	9b01      	ldr	r3, [sp, #4]
    8f22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8f26:	bf00      	nop
    8f28:	b003      	add	sp, #12
    8f2a:	f85d fb04 	ldr.w	pc, [sp], #4
    8f2e:	bf00      	nop
    8f30:	1fff8df0 	.word	0x1fff8df0
    8f34:	1fff8dec 	.word	0x1fff8dec

00008f38 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    8f38:	b500      	push	{lr}
    8f3a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f3c:	f7f7 feaa 	bl	c94 <Sys_GetCoreID>
    8f40:	4603      	mov	r3, r0
    8f42:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    8f44:	4a0d      	ldr	r2, [pc, #52]	; (8f7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    8f46:	9b01      	ldr	r3, [sp, #4]
    8f48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f4c:	1e5a      	subs	r2, r3, #1
    8f4e:	490b      	ldr	r1, [pc, #44]	; (8f7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    8f50:	9b01      	ldr	r3, [sp, #4]
    8f52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    8f56:	4a0a      	ldr	r2, [pc, #40]	; (8f80 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    8f58:	9b01      	ldr	r3, [sp, #4]
    8f5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f5e:	f003 0301 	and.w	r3, r3, #1
    8f62:	2b00      	cmp	r3, #0
    8f64:	d106      	bne.n	8f74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    8f66:	4a05      	ldr	r2, [pc, #20]	; (8f7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    8f68:	9b01      	ldr	r3, [sp, #4]
    8f6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f6e:	2b00      	cmp	r3, #0
    8f70:	d100      	bne.n	8f74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8f72:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8f74:	bf00      	nop
    8f76:	b003      	add	sp, #12
    8f78:	f85d fb04 	ldr.w	pc, [sp], #4
    8f7c:	1fff8df0 	.word	0x1fff8df0
    8f80:	1fff8dec 	.word	0x1fff8dec

00008f84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    8f84:	b500      	push	{lr}
    8f86:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f88:	f7f7 fe84 	bl	c94 <Sys_GetCoreID>
    8f8c:	4603      	mov	r3, r0
    8f8e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    8f90:	4a10      	ldr	r2, [pc, #64]	; (8fd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    8f92:	9b01      	ldr	r3, [sp, #4]
    8f94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f98:	2b00      	cmp	r3, #0
    8f9a:	d10d      	bne.n	8fb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8f9c:	f7f7 fda1 	bl	ae2 <Port_schm_read_msr>
    8fa0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8fa2:	9b00      	ldr	r3, [sp, #0]
    8fa4:	f003 0301 	and.w	r3, r3, #1
    8fa8:	2b00      	cmp	r3, #0
    8faa:	d100      	bne.n	8fae <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8fac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    8fae:	490a      	ldr	r1, [pc, #40]	; (8fd8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    8fb0:	9b01      	ldr	r3, [sp, #4]
    8fb2:	9a00      	ldr	r2, [sp, #0]
    8fb4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    8fb8:	4a06      	ldr	r2, [pc, #24]	; (8fd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    8fba:	9b01      	ldr	r3, [sp, #4]
    8fbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fc0:	1c5a      	adds	r2, r3, #1
    8fc2:	4904      	ldr	r1, [pc, #16]	; (8fd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    8fc4:	9b01      	ldr	r3, [sp, #4]
    8fc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8fca:	bf00      	nop
    8fcc:	b003      	add	sp, #12
    8fce:	f85d fb04 	ldr.w	pc, [sp], #4
    8fd2:	bf00      	nop
    8fd4:	1fff8df8 	.word	0x1fff8df8
    8fd8:	1fff8df4 	.word	0x1fff8df4

00008fdc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    8fdc:	b500      	push	{lr}
    8fde:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8fe0:	f7f7 fe58 	bl	c94 <Sys_GetCoreID>
    8fe4:	4603      	mov	r3, r0
    8fe6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    8fe8:	4a0d      	ldr	r2, [pc, #52]	; (9020 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    8fea:	9b01      	ldr	r3, [sp, #4]
    8fec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ff0:	1e5a      	subs	r2, r3, #1
    8ff2:	490b      	ldr	r1, [pc, #44]	; (9020 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    8ff4:	9b01      	ldr	r3, [sp, #4]
    8ff6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    8ffa:	4a0a      	ldr	r2, [pc, #40]	; (9024 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    8ffc:	9b01      	ldr	r3, [sp, #4]
    8ffe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9002:	f003 0301 	and.w	r3, r3, #1
    9006:	2b00      	cmp	r3, #0
    9008:	d106      	bne.n	9018 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    900a:	4a05      	ldr	r2, [pc, #20]	; (9020 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    900c:	9b01      	ldr	r3, [sp, #4]
    900e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9012:	2b00      	cmp	r3, #0
    9014:	d100      	bne.n	9018 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9016:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9018:	bf00      	nop
    901a:	b003      	add	sp, #12
    901c:	f85d fb04 	ldr.w	pc, [sp], #4
    9020:	1fff8df8 	.word	0x1fff8df8
    9024:	1fff8df4 	.word	0x1fff8df4

00009028 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    9028:	b500      	push	{lr}
    902a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    902c:	f7f7 fe32 	bl	c94 <Sys_GetCoreID>
    9030:	4603      	mov	r3, r0
    9032:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    9034:	4a10      	ldr	r2, [pc, #64]	; (9078 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    9036:	9b01      	ldr	r3, [sp, #4]
    9038:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    903c:	2b00      	cmp	r3, #0
    903e:	d10d      	bne.n	905c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9040:	f7f7 fd4f 	bl	ae2 <Port_schm_read_msr>
    9044:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9046:	9b00      	ldr	r3, [sp, #0]
    9048:	f003 0301 	and.w	r3, r3, #1
    904c:	2b00      	cmp	r3, #0
    904e:	d100      	bne.n	9052 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9050:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    9052:	490a      	ldr	r1, [pc, #40]	; (907c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    9054:	9b01      	ldr	r3, [sp, #4]
    9056:	9a00      	ldr	r2, [sp, #0]
    9058:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    905c:	4a06      	ldr	r2, [pc, #24]	; (9078 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    905e:	9b01      	ldr	r3, [sp, #4]
    9060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9064:	1c5a      	adds	r2, r3, #1
    9066:	4904      	ldr	r1, [pc, #16]	; (9078 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    9068:	9b01      	ldr	r3, [sp, #4]
    906a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    906e:	bf00      	nop
    9070:	b003      	add	sp, #12
    9072:	f85d fb04 	ldr.w	pc, [sp], #4
    9076:	bf00      	nop
    9078:	1fff8e00 	.word	0x1fff8e00
    907c:	1fff8dfc 	.word	0x1fff8dfc

00009080 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    9080:	b500      	push	{lr}
    9082:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9084:	f7f7 fe06 	bl	c94 <Sys_GetCoreID>
    9088:	4603      	mov	r3, r0
    908a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    908c:	4a0d      	ldr	r2, [pc, #52]	; (90c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    908e:	9b01      	ldr	r3, [sp, #4]
    9090:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9094:	1e5a      	subs	r2, r3, #1
    9096:	490b      	ldr	r1, [pc, #44]	; (90c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    9098:	9b01      	ldr	r3, [sp, #4]
    909a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    909e:	4a0a      	ldr	r2, [pc, #40]	; (90c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    90a0:	9b01      	ldr	r3, [sp, #4]
    90a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90a6:	f003 0301 	and.w	r3, r3, #1
    90aa:	2b00      	cmp	r3, #0
    90ac:	d106      	bne.n	90bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    90ae:	4a05      	ldr	r2, [pc, #20]	; (90c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    90b0:	9b01      	ldr	r3, [sp, #4]
    90b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90b6:	2b00      	cmp	r3, #0
    90b8:	d100      	bne.n	90bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    90ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    90bc:	bf00      	nop
    90be:	b003      	add	sp, #12
    90c0:	f85d fb04 	ldr.w	pc, [sp], #4
    90c4:	1fff8e00 	.word	0x1fff8e00
    90c8:	1fff8dfc 	.word	0x1fff8dfc

000090cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    90cc:	b500      	push	{lr}
    90ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    90d0:	f7f7 fde0 	bl	c94 <Sys_GetCoreID>
    90d4:	4603      	mov	r3, r0
    90d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    90d8:	4a10      	ldr	r2, [pc, #64]	; (911c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    90da:	9b01      	ldr	r3, [sp, #4]
    90dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90e0:	2b00      	cmp	r3, #0
    90e2:	d10d      	bne.n	9100 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    90e4:	f7f7 fcfd 	bl	ae2 <Port_schm_read_msr>
    90e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    90ea:	9b00      	ldr	r3, [sp, #0]
    90ec:	f003 0301 	and.w	r3, r3, #1
    90f0:	2b00      	cmp	r3, #0
    90f2:	d100      	bne.n	90f6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    90f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    90f6:	490a      	ldr	r1, [pc, #40]	; (9120 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    90f8:	9b01      	ldr	r3, [sp, #4]
    90fa:	9a00      	ldr	r2, [sp, #0]
    90fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    9100:	4a06      	ldr	r2, [pc, #24]	; (911c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    9102:	9b01      	ldr	r3, [sp, #4]
    9104:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9108:	1c5a      	adds	r2, r3, #1
    910a:	4904      	ldr	r1, [pc, #16]	; (911c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    910c:	9b01      	ldr	r3, [sp, #4]
    910e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9112:	bf00      	nop
    9114:	b003      	add	sp, #12
    9116:	f85d fb04 	ldr.w	pc, [sp], #4
    911a:	bf00      	nop
    911c:	1fff8e08 	.word	0x1fff8e08
    9120:	1fff8e04 	.word	0x1fff8e04

00009124 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    9124:	b500      	push	{lr}
    9126:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9128:	f7f7 fdb4 	bl	c94 <Sys_GetCoreID>
    912c:	4603      	mov	r3, r0
    912e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    9130:	4a0d      	ldr	r2, [pc, #52]	; (9168 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    9132:	9b01      	ldr	r3, [sp, #4]
    9134:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9138:	1e5a      	subs	r2, r3, #1
    913a:	490b      	ldr	r1, [pc, #44]	; (9168 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    913c:	9b01      	ldr	r3, [sp, #4]
    913e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    9142:	4a0a      	ldr	r2, [pc, #40]	; (916c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    9144:	9b01      	ldr	r3, [sp, #4]
    9146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    914a:	f003 0301 	and.w	r3, r3, #1
    914e:	2b00      	cmp	r3, #0
    9150:	d106      	bne.n	9160 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    9152:	4a05      	ldr	r2, [pc, #20]	; (9168 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    9154:	9b01      	ldr	r3, [sp, #4]
    9156:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    915a:	2b00      	cmp	r3, #0
    915c:	d100      	bne.n	9160 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    915e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9160:	bf00      	nop
    9162:	b003      	add	sp, #12
    9164:	f85d fb04 	ldr.w	pc, [sp], #4
    9168:	1fff8e08 	.word	0x1fff8e08
    916c:	1fff8e04 	.word	0x1fff8e04

00009170 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    9170:	b500      	push	{lr}
    9172:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9174:	f7f7 fd8e 	bl	c94 <Sys_GetCoreID>
    9178:	4603      	mov	r3, r0
    917a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    917c:	4a10      	ldr	r2, [pc, #64]	; (91c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    917e:	9b01      	ldr	r3, [sp, #4]
    9180:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9184:	2b00      	cmp	r3, #0
    9186:	d10d      	bne.n	91a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9188:	f7f7 fcab 	bl	ae2 <Port_schm_read_msr>
    918c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    918e:	9b00      	ldr	r3, [sp, #0]
    9190:	f003 0301 	and.w	r3, r3, #1
    9194:	2b00      	cmp	r3, #0
    9196:	d100      	bne.n	919a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9198:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    919a:	490a      	ldr	r1, [pc, #40]	; (91c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    919c:	9b01      	ldr	r3, [sp, #4]
    919e:	9a00      	ldr	r2, [sp, #0]
    91a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    91a4:	4a06      	ldr	r2, [pc, #24]	; (91c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    91a6:	9b01      	ldr	r3, [sp, #4]
    91a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91ac:	1c5a      	adds	r2, r3, #1
    91ae:	4904      	ldr	r1, [pc, #16]	; (91c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    91b0:	9b01      	ldr	r3, [sp, #4]
    91b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    91b6:	bf00      	nop
    91b8:	b003      	add	sp, #12
    91ba:	f85d fb04 	ldr.w	pc, [sp], #4
    91be:	bf00      	nop
    91c0:	1fff8e10 	.word	0x1fff8e10
    91c4:	1fff8e0c 	.word	0x1fff8e0c

000091c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    91c8:	b500      	push	{lr}
    91ca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    91cc:	f7f7 fd62 	bl	c94 <Sys_GetCoreID>
    91d0:	4603      	mov	r3, r0
    91d2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    91d4:	4a0d      	ldr	r2, [pc, #52]	; (920c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    91d6:	9b01      	ldr	r3, [sp, #4]
    91d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91dc:	1e5a      	subs	r2, r3, #1
    91de:	490b      	ldr	r1, [pc, #44]	; (920c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    91e0:	9b01      	ldr	r3, [sp, #4]
    91e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    91e6:	4a0a      	ldr	r2, [pc, #40]	; (9210 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    91e8:	9b01      	ldr	r3, [sp, #4]
    91ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91ee:	f003 0301 	and.w	r3, r3, #1
    91f2:	2b00      	cmp	r3, #0
    91f4:	d106      	bne.n	9204 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    91f6:	4a05      	ldr	r2, [pc, #20]	; (920c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    91f8:	9b01      	ldr	r3, [sp, #4]
    91fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91fe:	2b00      	cmp	r3, #0
    9200:	d100      	bne.n	9204 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9202:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9204:	bf00      	nop
    9206:	b003      	add	sp, #12
    9208:	f85d fb04 	ldr.w	pc, [sp], #4
    920c:	1fff8e10 	.word	0x1fff8e10
    9210:	1fff8e0c 	.word	0x1fff8e0c

00009214 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    9214:	b500      	push	{lr}
    9216:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9218:	f7f7 fd3c 	bl	c94 <Sys_GetCoreID>
    921c:	4603      	mov	r3, r0
    921e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    9220:	4a10      	ldr	r2, [pc, #64]	; (9264 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    9222:	9b01      	ldr	r3, [sp, #4]
    9224:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9228:	2b00      	cmp	r3, #0
    922a:	d10d      	bne.n	9248 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    922c:	f7f7 fc59 	bl	ae2 <Port_schm_read_msr>
    9230:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9232:	9b00      	ldr	r3, [sp, #0]
    9234:	f003 0301 	and.w	r3, r3, #1
    9238:	2b00      	cmp	r3, #0
    923a:	d100      	bne.n	923e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    923c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    923e:	490a      	ldr	r1, [pc, #40]	; (9268 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    9240:	9b01      	ldr	r3, [sp, #4]
    9242:	9a00      	ldr	r2, [sp, #0]
    9244:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    9248:	4a06      	ldr	r2, [pc, #24]	; (9264 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    924a:	9b01      	ldr	r3, [sp, #4]
    924c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9250:	1c5a      	adds	r2, r3, #1
    9252:	4904      	ldr	r1, [pc, #16]	; (9264 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    9254:	9b01      	ldr	r3, [sp, #4]
    9256:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    925a:	bf00      	nop
    925c:	b003      	add	sp, #12
    925e:	f85d fb04 	ldr.w	pc, [sp], #4
    9262:	bf00      	nop
    9264:	1fff8e18 	.word	0x1fff8e18
    9268:	1fff8e14 	.word	0x1fff8e14

0000926c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    926c:	b500      	push	{lr}
    926e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9270:	f7f7 fd10 	bl	c94 <Sys_GetCoreID>
    9274:	4603      	mov	r3, r0
    9276:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    9278:	4a0d      	ldr	r2, [pc, #52]	; (92b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    927a:	9b01      	ldr	r3, [sp, #4]
    927c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9280:	1e5a      	subs	r2, r3, #1
    9282:	490b      	ldr	r1, [pc, #44]	; (92b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    9284:	9b01      	ldr	r3, [sp, #4]
    9286:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    928a:	4a0a      	ldr	r2, [pc, #40]	; (92b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    928c:	9b01      	ldr	r3, [sp, #4]
    928e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9292:	f003 0301 	and.w	r3, r3, #1
    9296:	2b00      	cmp	r3, #0
    9298:	d106      	bne.n	92a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    929a:	4a05      	ldr	r2, [pc, #20]	; (92b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    929c:	9b01      	ldr	r3, [sp, #4]
    929e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92a2:	2b00      	cmp	r3, #0
    92a4:	d100      	bne.n	92a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    92a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    92a8:	bf00      	nop
    92aa:	b003      	add	sp, #12
    92ac:	f85d fb04 	ldr.w	pc, [sp], #4
    92b0:	1fff8e18 	.word	0x1fff8e18
    92b4:	1fff8e14 	.word	0x1fff8e14

000092b8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    92b8:	b500      	push	{lr}
    92ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    92bc:	f7f7 fcea 	bl	c94 <Sys_GetCoreID>
    92c0:	4603      	mov	r3, r0
    92c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    92c4:	4a10      	ldr	r2, [pc, #64]	; (9308 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    92c6:	9b01      	ldr	r3, [sp, #4]
    92c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92cc:	2b00      	cmp	r3, #0
    92ce:	d10d      	bne.n	92ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    92d0:	f7f7 fc07 	bl	ae2 <Port_schm_read_msr>
    92d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    92d6:	9b00      	ldr	r3, [sp, #0]
    92d8:	f003 0301 	and.w	r3, r3, #1
    92dc:	2b00      	cmp	r3, #0
    92de:	d100      	bne.n	92e2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    92e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    92e2:	490a      	ldr	r1, [pc, #40]	; (930c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    92e4:	9b01      	ldr	r3, [sp, #4]
    92e6:	9a00      	ldr	r2, [sp, #0]
    92e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    92ec:	4a06      	ldr	r2, [pc, #24]	; (9308 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    92ee:	9b01      	ldr	r3, [sp, #4]
    92f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92f4:	1c5a      	adds	r2, r3, #1
    92f6:	4904      	ldr	r1, [pc, #16]	; (9308 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    92f8:	9b01      	ldr	r3, [sp, #4]
    92fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    92fe:	bf00      	nop
    9300:	b003      	add	sp, #12
    9302:	f85d fb04 	ldr.w	pc, [sp], #4
    9306:	bf00      	nop
    9308:	1fff8e20 	.word	0x1fff8e20
    930c:	1fff8e1c 	.word	0x1fff8e1c

00009310 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    9310:	b500      	push	{lr}
    9312:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9314:	f7f7 fcbe 	bl	c94 <Sys_GetCoreID>
    9318:	4603      	mov	r3, r0
    931a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    931c:	4a0d      	ldr	r2, [pc, #52]	; (9354 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    931e:	9b01      	ldr	r3, [sp, #4]
    9320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9324:	1e5a      	subs	r2, r3, #1
    9326:	490b      	ldr	r1, [pc, #44]	; (9354 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    9328:	9b01      	ldr	r3, [sp, #4]
    932a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    932e:	4a0a      	ldr	r2, [pc, #40]	; (9358 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    9330:	9b01      	ldr	r3, [sp, #4]
    9332:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9336:	f003 0301 	and.w	r3, r3, #1
    933a:	2b00      	cmp	r3, #0
    933c:	d106      	bne.n	934c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    933e:	4a05      	ldr	r2, [pc, #20]	; (9354 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    9340:	9b01      	ldr	r3, [sp, #4]
    9342:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9346:	2b00      	cmp	r3, #0
    9348:	d100      	bne.n	934c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    934a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    934c:	bf00      	nop
    934e:	b003      	add	sp, #12
    9350:	f85d fb04 	ldr.w	pc, [sp], #4
    9354:	1fff8e20 	.word	0x1fff8e20
    9358:	1fff8e1c 	.word	0x1fff8e1c

0000935c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    935c:	b500      	push	{lr}
    935e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9360:	f7f7 fc98 	bl	c94 <Sys_GetCoreID>
    9364:	4603      	mov	r3, r0
    9366:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    9368:	4a10      	ldr	r2, [pc, #64]	; (93ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    936a:	9b01      	ldr	r3, [sp, #4]
    936c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9370:	2b00      	cmp	r3, #0
    9372:	d10d      	bne.n	9390 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9374:	f7f7 fbb5 	bl	ae2 <Port_schm_read_msr>
    9378:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    937a:	9b00      	ldr	r3, [sp, #0]
    937c:	f003 0301 	and.w	r3, r3, #1
    9380:	2b00      	cmp	r3, #0
    9382:	d100      	bne.n	9386 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9384:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    9386:	490a      	ldr	r1, [pc, #40]	; (93b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    9388:	9b01      	ldr	r3, [sp, #4]
    938a:	9a00      	ldr	r2, [sp, #0]
    938c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    9390:	4a06      	ldr	r2, [pc, #24]	; (93ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    9392:	9b01      	ldr	r3, [sp, #4]
    9394:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9398:	1c5a      	adds	r2, r3, #1
    939a:	4904      	ldr	r1, [pc, #16]	; (93ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    939c:	9b01      	ldr	r3, [sp, #4]
    939e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    93a2:	bf00      	nop
    93a4:	b003      	add	sp, #12
    93a6:	f85d fb04 	ldr.w	pc, [sp], #4
    93aa:	bf00      	nop
    93ac:	1fff8e28 	.word	0x1fff8e28
    93b0:	1fff8e24 	.word	0x1fff8e24

000093b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    93b4:	b500      	push	{lr}
    93b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    93b8:	f7f7 fc6c 	bl	c94 <Sys_GetCoreID>
    93bc:	4603      	mov	r3, r0
    93be:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    93c0:	4a0d      	ldr	r2, [pc, #52]	; (93f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    93c2:	9b01      	ldr	r3, [sp, #4]
    93c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93c8:	1e5a      	subs	r2, r3, #1
    93ca:	490b      	ldr	r1, [pc, #44]	; (93f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    93cc:	9b01      	ldr	r3, [sp, #4]
    93ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    93d2:	4a0a      	ldr	r2, [pc, #40]	; (93fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    93d4:	9b01      	ldr	r3, [sp, #4]
    93d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93da:	f003 0301 	and.w	r3, r3, #1
    93de:	2b00      	cmp	r3, #0
    93e0:	d106      	bne.n	93f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    93e2:	4a05      	ldr	r2, [pc, #20]	; (93f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    93e4:	9b01      	ldr	r3, [sp, #4]
    93e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93ea:	2b00      	cmp	r3, #0
    93ec:	d100      	bne.n	93f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    93ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    93f0:	bf00      	nop
    93f2:	b003      	add	sp, #12
    93f4:	f85d fb04 	ldr.w	pc, [sp], #4
    93f8:	1fff8e28 	.word	0x1fff8e28
    93fc:	1fff8e24 	.word	0x1fff8e24

00009400 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    9400:	b500      	push	{lr}
    9402:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9404:	f7f7 fc46 	bl	c94 <Sys_GetCoreID>
    9408:	4603      	mov	r3, r0
    940a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    940c:	4a10      	ldr	r2, [pc, #64]	; (9450 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    940e:	9b01      	ldr	r3, [sp, #4]
    9410:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9414:	2b00      	cmp	r3, #0
    9416:	d10d      	bne.n	9434 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9418:	f7f7 fb63 	bl	ae2 <Port_schm_read_msr>
    941c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    941e:	9b00      	ldr	r3, [sp, #0]
    9420:	f003 0301 	and.w	r3, r3, #1
    9424:	2b00      	cmp	r3, #0
    9426:	d100      	bne.n	942a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9428:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    942a:	490a      	ldr	r1, [pc, #40]	; (9454 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    942c:	9b01      	ldr	r3, [sp, #4]
    942e:	9a00      	ldr	r2, [sp, #0]
    9430:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    9434:	4a06      	ldr	r2, [pc, #24]	; (9450 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    9436:	9b01      	ldr	r3, [sp, #4]
    9438:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    943c:	1c5a      	adds	r2, r3, #1
    943e:	4904      	ldr	r1, [pc, #16]	; (9450 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    9440:	9b01      	ldr	r3, [sp, #4]
    9442:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9446:	bf00      	nop
    9448:	b003      	add	sp, #12
    944a:	f85d fb04 	ldr.w	pc, [sp], #4
    944e:	bf00      	nop
    9450:	1fff8e30 	.word	0x1fff8e30
    9454:	1fff8e2c 	.word	0x1fff8e2c

00009458 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    9458:	b500      	push	{lr}
    945a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    945c:	f7f7 fc1a 	bl	c94 <Sys_GetCoreID>
    9460:	4603      	mov	r3, r0
    9462:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    9464:	4a0d      	ldr	r2, [pc, #52]	; (949c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    9466:	9b01      	ldr	r3, [sp, #4]
    9468:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    946c:	1e5a      	subs	r2, r3, #1
    946e:	490b      	ldr	r1, [pc, #44]	; (949c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    9470:	9b01      	ldr	r3, [sp, #4]
    9472:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    9476:	4a0a      	ldr	r2, [pc, #40]	; (94a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    9478:	9b01      	ldr	r3, [sp, #4]
    947a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    947e:	f003 0301 	and.w	r3, r3, #1
    9482:	2b00      	cmp	r3, #0
    9484:	d106      	bne.n	9494 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    9486:	4a05      	ldr	r2, [pc, #20]	; (949c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    9488:	9b01      	ldr	r3, [sp, #4]
    948a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    948e:	2b00      	cmp	r3, #0
    9490:	d100      	bne.n	9494 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9492:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9494:	bf00      	nop
    9496:	b003      	add	sp, #12
    9498:	f85d fb04 	ldr.w	pc, [sp], #4
    949c:	1fff8e30 	.word	0x1fff8e30
    94a0:	1fff8e2c 	.word	0x1fff8e2c

000094a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    94a4:	b500      	push	{lr}
    94a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    94a8:	f7f7 fbf4 	bl	c94 <Sys_GetCoreID>
    94ac:	4603      	mov	r3, r0
    94ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    94b0:	4a10      	ldr	r2, [pc, #64]	; (94f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    94b2:	9b01      	ldr	r3, [sp, #4]
    94b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94b8:	2b00      	cmp	r3, #0
    94ba:	d10d      	bne.n	94d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    94bc:	f7f7 fb11 	bl	ae2 <Port_schm_read_msr>
    94c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    94c2:	9b00      	ldr	r3, [sp, #0]
    94c4:	f003 0301 	and.w	r3, r3, #1
    94c8:	2b00      	cmp	r3, #0
    94ca:	d100      	bne.n	94ce <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    94cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    94ce:	490a      	ldr	r1, [pc, #40]	; (94f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    94d0:	9b01      	ldr	r3, [sp, #4]
    94d2:	9a00      	ldr	r2, [sp, #0]
    94d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    94d8:	4a06      	ldr	r2, [pc, #24]	; (94f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    94da:	9b01      	ldr	r3, [sp, #4]
    94dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94e0:	1c5a      	adds	r2, r3, #1
    94e2:	4904      	ldr	r1, [pc, #16]	; (94f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    94e4:	9b01      	ldr	r3, [sp, #4]
    94e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    94ea:	bf00      	nop
    94ec:	b003      	add	sp, #12
    94ee:	f85d fb04 	ldr.w	pc, [sp], #4
    94f2:	bf00      	nop
    94f4:	1fff8e38 	.word	0x1fff8e38
    94f8:	1fff8e34 	.word	0x1fff8e34

000094fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    94fc:	b500      	push	{lr}
    94fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9500:	f7f7 fbc8 	bl	c94 <Sys_GetCoreID>
    9504:	4603      	mov	r3, r0
    9506:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    9508:	4a0d      	ldr	r2, [pc, #52]	; (9540 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    950a:	9b01      	ldr	r3, [sp, #4]
    950c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9510:	1e5a      	subs	r2, r3, #1
    9512:	490b      	ldr	r1, [pc, #44]	; (9540 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    9514:	9b01      	ldr	r3, [sp, #4]
    9516:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    951a:	4a0a      	ldr	r2, [pc, #40]	; (9544 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    951c:	9b01      	ldr	r3, [sp, #4]
    951e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9522:	f003 0301 	and.w	r3, r3, #1
    9526:	2b00      	cmp	r3, #0
    9528:	d106      	bne.n	9538 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    952a:	4a05      	ldr	r2, [pc, #20]	; (9540 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    952c:	9b01      	ldr	r3, [sp, #4]
    952e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9532:	2b00      	cmp	r3, #0
    9534:	d100      	bne.n	9538 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9536:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9538:	bf00      	nop
    953a:	b003      	add	sp, #12
    953c:	f85d fb04 	ldr.w	pc, [sp], #4
    9540:	1fff8e38 	.word	0x1fff8e38
    9544:	1fff8e34 	.word	0x1fff8e34

00009548 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    9548:	b500      	push	{lr}
    954a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    954c:	f7f7 fba2 	bl	c94 <Sys_GetCoreID>
    9550:	4603      	mov	r3, r0
    9552:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    9554:	4a10      	ldr	r2, [pc, #64]	; (9598 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    9556:	9b01      	ldr	r3, [sp, #4]
    9558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    955c:	2b00      	cmp	r3, #0
    955e:	d10d      	bne.n	957c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9560:	f7f7 fabf 	bl	ae2 <Port_schm_read_msr>
    9564:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9566:	9b00      	ldr	r3, [sp, #0]
    9568:	f003 0301 	and.w	r3, r3, #1
    956c:	2b00      	cmp	r3, #0
    956e:	d100      	bne.n	9572 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9570:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    9572:	490a      	ldr	r1, [pc, #40]	; (959c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    9574:	9b01      	ldr	r3, [sp, #4]
    9576:	9a00      	ldr	r2, [sp, #0]
    9578:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    957c:	4a06      	ldr	r2, [pc, #24]	; (9598 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    957e:	9b01      	ldr	r3, [sp, #4]
    9580:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9584:	1c5a      	adds	r2, r3, #1
    9586:	4904      	ldr	r1, [pc, #16]	; (9598 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    9588:	9b01      	ldr	r3, [sp, #4]
    958a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    958e:	bf00      	nop
    9590:	b003      	add	sp, #12
    9592:	f85d fb04 	ldr.w	pc, [sp], #4
    9596:	bf00      	nop
    9598:	1fff8e40 	.word	0x1fff8e40
    959c:	1fff8e3c 	.word	0x1fff8e3c

000095a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    95a0:	b500      	push	{lr}
    95a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    95a4:	f7f7 fb76 	bl	c94 <Sys_GetCoreID>
    95a8:	4603      	mov	r3, r0
    95aa:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    95ac:	4a0d      	ldr	r2, [pc, #52]	; (95e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    95ae:	9b01      	ldr	r3, [sp, #4]
    95b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95b4:	1e5a      	subs	r2, r3, #1
    95b6:	490b      	ldr	r1, [pc, #44]	; (95e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    95b8:	9b01      	ldr	r3, [sp, #4]
    95ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    95be:	4a0a      	ldr	r2, [pc, #40]	; (95e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    95c0:	9b01      	ldr	r3, [sp, #4]
    95c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95c6:	f003 0301 	and.w	r3, r3, #1
    95ca:	2b00      	cmp	r3, #0
    95cc:	d106      	bne.n	95dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    95ce:	4a05      	ldr	r2, [pc, #20]	; (95e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    95d0:	9b01      	ldr	r3, [sp, #4]
    95d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95d6:	2b00      	cmp	r3, #0
    95d8:	d100      	bne.n	95dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    95da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    95dc:	bf00      	nop
    95de:	b003      	add	sp, #12
    95e0:	f85d fb04 	ldr.w	pc, [sp], #4
    95e4:	1fff8e40 	.word	0x1fff8e40
    95e8:	1fff8e3c 	.word	0x1fff8e3c

000095ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    95ec:	b500      	push	{lr}
    95ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    95f0:	f7f7 fb50 	bl	c94 <Sys_GetCoreID>
    95f4:	4603      	mov	r3, r0
    95f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    95f8:	4a10      	ldr	r2, [pc, #64]	; (963c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    95fa:	9b01      	ldr	r3, [sp, #4]
    95fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9600:	2b00      	cmp	r3, #0
    9602:	d10d      	bne.n	9620 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9604:	f7f7 fa6d 	bl	ae2 <Port_schm_read_msr>
    9608:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    960a:	9b00      	ldr	r3, [sp, #0]
    960c:	f003 0301 	and.w	r3, r3, #1
    9610:	2b00      	cmp	r3, #0
    9612:	d100      	bne.n	9616 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9614:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    9616:	490a      	ldr	r1, [pc, #40]	; (9640 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    9618:	9b01      	ldr	r3, [sp, #4]
    961a:	9a00      	ldr	r2, [sp, #0]
    961c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    9620:	4a06      	ldr	r2, [pc, #24]	; (963c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    9622:	9b01      	ldr	r3, [sp, #4]
    9624:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9628:	1c5a      	adds	r2, r3, #1
    962a:	4904      	ldr	r1, [pc, #16]	; (963c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    962c:	9b01      	ldr	r3, [sp, #4]
    962e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9632:	bf00      	nop
    9634:	b003      	add	sp, #12
    9636:	f85d fb04 	ldr.w	pc, [sp], #4
    963a:	bf00      	nop
    963c:	1fff8e48 	.word	0x1fff8e48
    9640:	1fff8e44 	.word	0x1fff8e44

00009644 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    9644:	b500      	push	{lr}
    9646:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9648:	f7f7 fb24 	bl	c94 <Sys_GetCoreID>
    964c:	4603      	mov	r3, r0
    964e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    9650:	4a0d      	ldr	r2, [pc, #52]	; (9688 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    9652:	9b01      	ldr	r3, [sp, #4]
    9654:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9658:	1e5a      	subs	r2, r3, #1
    965a:	490b      	ldr	r1, [pc, #44]	; (9688 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    965c:	9b01      	ldr	r3, [sp, #4]
    965e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    9662:	4a0a      	ldr	r2, [pc, #40]	; (968c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    9664:	9b01      	ldr	r3, [sp, #4]
    9666:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    966a:	f003 0301 	and.w	r3, r3, #1
    966e:	2b00      	cmp	r3, #0
    9670:	d106      	bne.n	9680 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    9672:	4a05      	ldr	r2, [pc, #20]	; (9688 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    9674:	9b01      	ldr	r3, [sp, #4]
    9676:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    967a:	2b00      	cmp	r3, #0
    967c:	d100      	bne.n	9680 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    967e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9680:	bf00      	nop
    9682:	b003      	add	sp, #12
    9684:	f85d fb04 	ldr.w	pc, [sp], #4
    9688:	1fff8e48 	.word	0x1fff8e48
    968c:	1fff8e44 	.word	0x1fff8e44

00009690 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    9690:	b500      	push	{lr}
    9692:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9694:	f7f7 fafe 	bl	c94 <Sys_GetCoreID>
    9698:	4603      	mov	r3, r0
    969a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    969c:	4a10      	ldr	r2, [pc, #64]	; (96e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    969e:	9b01      	ldr	r3, [sp, #4]
    96a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96a4:	2b00      	cmp	r3, #0
    96a6:	d10d      	bne.n	96c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    96a8:	f7f7 fa1b 	bl	ae2 <Port_schm_read_msr>
    96ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    96ae:	9b00      	ldr	r3, [sp, #0]
    96b0:	f003 0301 	and.w	r3, r3, #1
    96b4:	2b00      	cmp	r3, #0
    96b6:	d100      	bne.n	96ba <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    96b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    96ba:	490a      	ldr	r1, [pc, #40]	; (96e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    96bc:	9b01      	ldr	r3, [sp, #4]
    96be:	9a00      	ldr	r2, [sp, #0]
    96c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    96c4:	4a06      	ldr	r2, [pc, #24]	; (96e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    96c6:	9b01      	ldr	r3, [sp, #4]
    96c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96cc:	1c5a      	adds	r2, r3, #1
    96ce:	4904      	ldr	r1, [pc, #16]	; (96e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    96d0:	9b01      	ldr	r3, [sp, #4]
    96d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    96d6:	bf00      	nop
    96d8:	b003      	add	sp, #12
    96da:	f85d fb04 	ldr.w	pc, [sp], #4
    96de:	bf00      	nop
    96e0:	1fff8e50 	.word	0x1fff8e50
    96e4:	1fff8e4c 	.word	0x1fff8e4c

000096e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    96e8:	b500      	push	{lr}
    96ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    96ec:	f7f7 fad2 	bl	c94 <Sys_GetCoreID>
    96f0:	4603      	mov	r3, r0
    96f2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    96f4:	4a0d      	ldr	r2, [pc, #52]	; (972c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    96f6:	9b01      	ldr	r3, [sp, #4]
    96f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96fc:	1e5a      	subs	r2, r3, #1
    96fe:	490b      	ldr	r1, [pc, #44]	; (972c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    9700:	9b01      	ldr	r3, [sp, #4]
    9702:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    9706:	4a0a      	ldr	r2, [pc, #40]	; (9730 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    9708:	9b01      	ldr	r3, [sp, #4]
    970a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    970e:	f003 0301 	and.w	r3, r3, #1
    9712:	2b00      	cmp	r3, #0
    9714:	d106      	bne.n	9724 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    9716:	4a05      	ldr	r2, [pc, #20]	; (972c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    9718:	9b01      	ldr	r3, [sp, #4]
    971a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    971e:	2b00      	cmp	r3, #0
    9720:	d100      	bne.n	9724 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9722:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9724:	bf00      	nop
    9726:	b003      	add	sp, #12
    9728:	f85d fb04 	ldr.w	pc, [sp], #4
    972c:	1fff8e50 	.word	0x1fff8e50
    9730:	1fff8e4c 	.word	0x1fff8e4c

00009734 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    9734:	b500      	push	{lr}
    9736:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9738:	f7f7 faac 	bl	c94 <Sys_GetCoreID>
    973c:	4603      	mov	r3, r0
    973e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    9740:	4a10      	ldr	r2, [pc, #64]	; (9784 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    9742:	9b01      	ldr	r3, [sp, #4]
    9744:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9748:	2b00      	cmp	r3, #0
    974a:	d10d      	bne.n	9768 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    974c:	f7f7 f9c9 	bl	ae2 <Port_schm_read_msr>
    9750:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9752:	9b00      	ldr	r3, [sp, #0]
    9754:	f003 0301 	and.w	r3, r3, #1
    9758:	2b00      	cmp	r3, #0
    975a:	d100      	bne.n	975e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    975c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    975e:	490a      	ldr	r1, [pc, #40]	; (9788 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    9760:	9b01      	ldr	r3, [sp, #4]
    9762:	9a00      	ldr	r2, [sp, #0]
    9764:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    9768:	4a06      	ldr	r2, [pc, #24]	; (9784 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    976a:	9b01      	ldr	r3, [sp, #4]
    976c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9770:	1c5a      	adds	r2, r3, #1
    9772:	4904      	ldr	r1, [pc, #16]	; (9784 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    9774:	9b01      	ldr	r3, [sp, #4]
    9776:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    977a:	bf00      	nop
    977c:	b003      	add	sp, #12
    977e:	f85d fb04 	ldr.w	pc, [sp], #4
    9782:	bf00      	nop
    9784:	1fff8e58 	.word	0x1fff8e58
    9788:	1fff8e54 	.word	0x1fff8e54

0000978c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    978c:	b500      	push	{lr}
    978e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9790:	f7f7 fa80 	bl	c94 <Sys_GetCoreID>
    9794:	4603      	mov	r3, r0
    9796:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    9798:	4a0d      	ldr	r2, [pc, #52]	; (97d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    979a:	9b01      	ldr	r3, [sp, #4]
    979c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97a0:	1e5a      	subs	r2, r3, #1
    97a2:	490b      	ldr	r1, [pc, #44]	; (97d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    97a4:	9b01      	ldr	r3, [sp, #4]
    97a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    97aa:	4a0a      	ldr	r2, [pc, #40]	; (97d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    97ac:	9b01      	ldr	r3, [sp, #4]
    97ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97b2:	f003 0301 	and.w	r3, r3, #1
    97b6:	2b00      	cmp	r3, #0
    97b8:	d106      	bne.n	97c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    97ba:	4a05      	ldr	r2, [pc, #20]	; (97d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    97bc:	9b01      	ldr	r3, [sp, #4]
    97be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97c2:	2b00      	cmp	r3, #0
    97c4:	d100      	bne.n	97c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    97c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    97c8:	bf00      	nop
    97ca:	b003      	add	sp, #12
    97cc:	f85d fb04 	ldr.w	pc, [sp], #4
    97d0:	1fff8e58 	.word	0x1fff8e58
    97d4:	1fff8e54 	.word	0x1fff8e54

000097d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    97d8:	b500      	push	{lr}
    97da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    97dc:	f7f7 fa5a 	bl	c94 <Sys_GetCoreID>
    97e0:	4603      	mov	r3, r0
    97e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    97e4:	4a10      	ldr	r2, [pc, #64]	; (9828 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    97e6:	9b01      	ldr	r3, [sp, #4]
    97e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97ec:	2b00      	cmp	r3, #0
    97ee:	d10d      	bne.n	980c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    97f0:	f7f7 f977 	bl	ae2 <Port_schm_read_msr>
    97f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    97f6:	9b00      	ldr	r3, [sp, #0]
    97f8:	f003 0301 	and.w	r3, r3, #1
    97fc:	2b00      	cmp	r3, #0
    97fe:	d100      	bne.n	9802 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9800:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    9802:	490a      	ldr	r1, [pc, #40]	; (982c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    9804:	9b01      	ldr	r3, [sp, #4]
    9806:	9a00      	ldr	r2, [sp, #0]
    9808:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    980c:	4a06      	ldr	r2, [pc, #24]	; (9828 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    980e:	9b01      	ldr	r3, [sp, #4]
    9810:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9814:	1c5a      	adds	r2, r3, #1
    9816:	4904      	ldr	r1, [pc, #16]	; (9828 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    9818:	9b01      	ldr	r3, [sp, #4]
    981a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    981e:	bf00      	nop
    9820:	b003      	add	sp, #12
    9822:	f85d fb04 	ldr.w	pc, [sp], #4
    9826:	bf00      	nop
    9828:	1fff8e60 	.word	0x1fff8e60
    982c:	1fff8e5c 	.word	0x1fff8e5c

00009830 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    9830:	b500      	push	{lr}
    9832:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9834:	f7f7 fa2e 	bl	c94 <Sys_GetCoreID>
    9838:	4603      	mov	r3, r0
    983a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    983c:	4a0d      	ldr	r2, [pc, #52]	; (9874 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    983e:	9b01      	ldr	r3, [sp, #4]
    9840:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9844:	1e5a      	subs	r2, r3, #1
    9846:	490b      	ldr	r1, [pc, #44]	; (9874 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    9848:	9b01      	ldr	r3, [sp, #4]
    984a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    984e:	4a0a      	ldr	r2, [pc, #40]	; (9878 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    9850:	9b01      	ldr	r3, [sp, #4]
    9852:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9856:	f003 0301 	and.w	r3, r3, #1
    985a:	2b00      	cmp	r3, #0
    985c:	d106      	bne.n	986c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    985e:	4a05      	ldr	r2, [pc, #20]	; (9874 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    9860:	9b01      	ldr	r3, [sp, #4]
    9862:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9866:	2b00      	cmp	r3, #0
    9868:	d100      	bne.n	986c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    986a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    986c:	bf00      	nop
    986e:	b003      	add	sp, #12
    9870:	f85d fb04 	ldr.w	pc, [sp], #4
    9874:	1fff8e60 	.word	0x1fff8e60
    9878:	1fff8e5c 	.word	0x1fff8e5c

0000987c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    987c:	b500      	push	{lr}
    987e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9880:	f7f7 fa08 	bl	c94 <Sys_GetCoreID>
    9884:	4603      	mov	r3, r0
    9886:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    9888:	4a10      	ldr	r2, [pc, #64]	; (98cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    988a:	9b01      	ldr	r3, [sp, #4]
    988c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9890:	2b00      	cmp	r3, #0
    9892:	d10d      	bne.n	98b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9894:	f7f7 f925 	bl	ae2 <Port_schm_read_msr>
    9898:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    989a:	9b00      	ldr	r3, [sp, #0]
    989c:	f003 0301 	and.w	r3, r3, #1
    98a0:	2b00      	cmp	r3, #0
    98a2:	d100      	bne.n	98a6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    98a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    98a6:	490a      	ldr	r1, [pc, #40]	; (98d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    98a8:	9b01      	ldr	r3, [sp, #4]
    98aa:	9a00      	ldr	r2, [sp, #0]
    98ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    98b0:	4a06      	ldr	r2, [pc, #24]	; (98cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    98b2:	9b01      	ldr	r3, [sp, #4]
    98b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98b8:	1c5a      	adds	r2, r3, #1
    98ba:	4904      	ldr	r1, [pc, #16]	; (98cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    98bc:	9b01      	ldr	r3, [sp, #4]
    98be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    98c2:	bf00      	nop
    98c4:	b003      	add	sp, #12
    98c6:	f85d fb04 	ldr.w	pc, [sp], #4
    98ca:	bf00      	nop
    98cc:	1fff8e68 	.word	0x1fff8e68
    98d0:	1fff8e64 	.word	0x1fff8e64

000098d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    98d4:	b500      	push	{lr}
    98d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    98d8:	f7f7 f9dc 	bl	c94 <Sys_GetCoreID>
    98dc:	4603      	mov	r3, r0
    98de:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    98e0:	4a0d      	ldr	r2, [pc, #52]	; (9918 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    98e2:	9b01      	ldr	r3, [sp, #4]
    98e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98e8:	1e5a      	subs	r2, r3, #1
    98ea:	490b      	ldr	r1, [pc, #44]	; (9918 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    98ec:	9b01      	ldr	r3, [sp, #4]
    98ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    98f2:	4a0a      	ldr	r2, [pc, #40]	; (991c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    98f4:	9b01      	ldr	r3, [sp, #4]
    98f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98fa:	f003 0301 	and.w	r3, r3, #1
    98fe:	2b00      	cmp	r3, #0
    9900:	d106      	bne.n	9910 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    9902:	4a05      	ldr	r2, [pc, #20]	; (9918 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    9904:	9b01      	ldr	r3, [sp, #4]
    9906:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    990a:	2b00      	cmp	r3, #0
    990c:	d100      	bne.n	9910 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    990e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9910:	bf00      	nop
    9912:	b003      	add	sp, #12
    9914:	f85d fb04 	ldr.w	pc, [sp], #4
    9918:	1fff8e68 	.word	0x1fff8e68
    991c:	1fff8e64 	.word	0x1fff8e64

00009920 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    9920:	b500      	push	{lr}
    9922:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9924:	f7f7 f9b6 	bl	c94 <Sys_GetCoreID>
    9928:	4603      	mov	r3, r0
    992a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    992c:	4a10      	ldr	r2, [pc, #64]	; (9970 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    992e:	9b01      	ldr	r3, [sp, #4]
    9930:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9934:	2b00      	cmp	r3, #0
    9936:	d10d      	bne.n	9954 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9938:	f7f7 f8d3 	bl	ae2 <Port_schm_read_msr>
    993c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    993e:	9b00      	ldr	r3, [sp, #0]
    9940:	f003 0301 	and.w	r3, r3, #1
    9944:	2b00      	cmp	r3, #0
    9946:	d100      	bne.n	994a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9948:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    994a:	490a      	ldr	r1, [pc, #40]	; (9974 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    994c:	9b01      	ldr	r3, [sp, #4]
    994e:	9a00      	ldr	r2, [sp, #0]
    9950:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    9954:	4a06      	ldr	r2, [pc, #24]	; (9970 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    9956:	9b01      	ldr	r3, [sp, #4]
    9958:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    995c:	1c5a      	adds	r2, r3, #1
    995e:	4904      	ldr	r1, [pc, #16]	; (9970 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    9960:	9b01      	ldr	r3, [sp, #4]
    9962:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9966:	bf00      	nop
    9968:	b003      	add	sp, #12
    996a:	f85d fb04 	ldr.w	pc, [sp], #4
    996e:	bf00      	nop
    9970:	1fff8e70 	.word	0x1fff8e70
    9974:	1fff8e6c 	.word	0x1fff8e6c

00009978 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    9978:	b500      	push	{lr}
    997a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    997c:	f7f7 f98a 	bl	c94 <Sys_GetCoreID>
    9980:	4603      	mov	r3, r0
    9982:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    9984:	4a0d      	ldr	r2, [pc, #52]	; (99bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    9986:	9b01      	ldr	r3, [sp, #4]
    9988:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    998c:	1e5a      	subs	r2, r3, #1
    998e:	490b      	ldr	r1, [pc, #44]	; (99bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    9990:	9b01      	ldr	r3, [sp, #4]
    9992:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    9996:	4a0a      	ldr	r2, [pc, #40]	; (99c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    9998:	9b01      	ldr	r3, [sp, #4]
    999a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    999e:	f003 0301 	and.w	r3, r3, #1
    99a2:	2b00      	cmp	r3, #0
    99a4:	d106      	bne.n	99b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    99a6:	4a05      	ldr	r2, [pc, #20]	; (99bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    99a8:	9b01      	ldr	r3, [sp, #4]
    99aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99ae:	2b00      	cmp	r3, #0
    99b0:	d100      	bne.n	99b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    99b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    99b4:	bf00      	nop
    99b6:	b003      	add	sp, #12
    99b8:	f85d fb04 	ldr.w	pc, [sp], #4
    99bc:	1fff8e70 	.word	0x1fff8e70
    99c0:	1fff8e6c 	.word	0x1fff8e6c

000099c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
    99c4:	b500      	push	{lr}
    99c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    99c8:	f7f7 f964 	bl	c94 <Sys_GetCoreID>
    99cc:	4603      	mov	r3, r0
    99ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId])
    99d0:	4a10      	ldr	r2, [pc, #64]	; (9a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    99d2:	9b01      	ldr	r3, [sp, #4]
    99d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99d8:	2b00      	cmp	r3, #0
    99da:	d10d      	bne.n	99f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    99dc:	f7f7 f88a 	bl	af4 <Spi_schm_read_msr>
    99e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    99e2:	9b00      	ldr	r3, [sp, #0]
    99e4:	f003 0301 	and.w	r3, r3, #1
    99e8:	2b00      	cmp	r3, #0
    99ea:	d100      	bne.n	99ee <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    99ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    99ee:	490a      	ldr	r1, [pc, #40]	; (9a18 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x54>)
    99f0:	9b01      	ldr	r3, [sp, #4]
    99f2:	9a00      	ldr	r2, [sp, #0]
    99f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]++;
    99f8:	4a06      	ldr	r2, [pc, #24]	; (9a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    99fa:	9b01      	ldr	r3, [sp, #4]
    99fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a00:	1c5a      	adds	r2, r3, #1
    9a02:	4904      	ldr	r1, [pc, #16]	; (9a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
    9a04:	9b01      	ldr	r3, [sp, #4]
    9a06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9a0a:	bf00      	nop
    9a0c:	b003      	add	sp, #12
    9a0e:	f85d fb04 	ldr.w	pc, [sp], #4
    9a12:	bf00      	nop
    9a14:	1fff8e78 	.word	0x1fff8e78
    9a18:	1fff8e74 	.word	0x1fff8e74

00009a1c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
    9a1c:	b500      	push	{lr}
    9a1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a20:	f7f7 f938 	bl	c94 <Sys_GetCoreID>
    9a24:	4603      	mov	r3, r0
    9a26:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]--;
    9a28:	4a0d      	ldr	r2, [pc, #52]	; (9a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    9a2a:	9b01      	ldr	r3, [sp, #4]
    9a2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a30:	1e5a      	subs	r2, r3, #1
    9a32:	490b      	ldr	r1, [pc, #44]	; (9a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    9a34:	9b01      	ldr	r3, [sp, #4]
    9a36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    9a3a:	4a0a      	ldr	r2, [pc, #40]	; (9a64 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x48>)
    9a3c:	9b01      	ldr	r3, [sp, #4]
    9a3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a42:	f003 0301 	and.w	r3, r3, #1
    9a46:	2b00      	cmp	r3, #0
    9a48:	d106      	bne.n	9a58 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
    9a4a:	4a05      	ldr	r2, [pc, #20]	; (9a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
    9a4c:	9b01      	ldr	r3, [sp, #4]
    9a4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a52:	2b00      	cmp	r3, #0
    9a54:	d100      	bne.n	9a58 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9a56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9a58:	bf00      	nop
    9a5a:	b003      	add	sp, #12
    9a5c:	f85d fb04 	ldr.w	pc, [sp], #4
    9a60:	1fff8e78 	.word	0x1fff8e78
    9a64:	1fff8e74 	.word	0x1fff8e74

00009a68 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
    9a68:	b500      	push	{lr}
    9a6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a6c:	f7f7 f912 	bl	c94 <Sys_GetCoreID>
    9a70:	4603      	mov	r3, r0
    9a72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId])
    9a74:	4a10      	ldr	r2, [pc, #64]	; (9ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    9a76:	9b01      	ldr	r3, [sp, #4]
    9a78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a7c:	2b00      	cmp	r3, #0
    9a7e:	d10d      	bne.n	9a9c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9a80:	f7f7 f838 	bl	af4 <Spi_schm_read_msr>
    9a84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9a86:	9b00      	ldr	r3, [sp, #0]
    9a88:	f003 0301 	and.w	r3, r3, #1
    9a8c:	2b00      	cmp	r3, #0
    9a8e:	d100      	bne.n	9a92 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9a90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    9a92:	490a      	ldr	r1, [pc, #40]	; (9abc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x54>)
    9a94:	9b01      	ldr	r3, [sp, #4]
    9a96:	9a00      	ldr	r2, [sp, #0]
    9a98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]++;
    9a9c:	4a06      	ldr	r2, [pc, #24]	; (9ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    9a9e:	9b01      	ldr	r3, [sp, #4]
    9aa0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9aa4:	1c5a      	adds	r2, r3, #1
    9aa6:	4904      	ldr	r1, [pc, #16]	; (9ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
    9aa8:	9b01      	ldr	r3, [sp, #4]
    9aaa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9aae:	bf00      	nop
    9ab0:	b003      	add	sp, #12
    9ab2:	f85d fb04 	ldr.w	pc, [sp], #4
    9ab6:	bf00      	nop
    9ab8:	1fff8e80 	.word	0x1fff8e80
    9abc:	1fff8e7c 	.word	0x1fff8e7c

00009ac0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
    9ac0:	b500      	push	{lr}
    9ac2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ac4:	f7f7 f8e6 	bl	c94 <Sys_GetCoreID>
    9ac8:	4603      	mov	r3, r0
    9aca:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]--;
    9acc:	4a0d      	ldr	r2, [pc, #52]	; (9b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    9ace:	9b01      	ldr	r3, [sp, #4]
    9ad0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ad4:	1e5a      	subs	r2, r3, #1
    9ad6:	490b      	ldr	r1, [pc, #44]	; (9b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    9ad8:	9b01      	ldr	r3, [sp, #4]
    9ada:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    9ade:	4a0a      	ldr	r2, [pc, #40]	; (9b08 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x48>)
    9ae0:	9b01      	ldr	r3, [sp, #4]
    9ae2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ae6:	f003 0301 	and.w	r3, r3, #1
    9aea:	2b00      	cmp	r3, #0
    9aec:	d106      	bne.n	9afc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
    9aee:	4a05      	ldr	r2, [pc, #20]	; (9b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
    9af0:	9b01      	ldr	r3, [sp, #4]
    9af2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9af6:	2b00      	cmp	r3, #0
    9af8:	d100      	bne.n	9afc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9afa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9afc:	bf00      	nop
    9afe:	b003      	add	sp, #12
    9b00:	f85d fb04 	ldr.w	pc, [sp], #4
    9b04:	1fff8e80 	.word	0x1fff8e80
    9b08:	1fff8e7c 	.word	0x1fff8e7c

00009b0c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
    9b0c:	b500      	push	{lr}
    9b0e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9b10:	f7f7 f8c0 	bl	c94 <Sys_GetCoreID>
    9b14:	4603      	mov	r3, r0
    9b16:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId])
    9b18:	4a10      	ldr	r2, [pc, #64]	; (9b5c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    9b1a:	9b01      	ldr	r3, [sp, #4]
    9b1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b20:	2b00      	cmp	r3, #0
    9b22:	d10d      	bne.n	9b40 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9b24:	f7f6 ffe6 	bl	af4 <Spi_schm_read_msr>
    9b28:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9b2a:	9b00      	ldr	r3, [sp, #0]
    9b2c:	f003 0301 	and.w	r3, r3, #1
    9b30:	2b00      	cmp	r3, #0
    9b32:	d100      	bne.n	9b36 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9b34:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    9b36:	490a      	ldr	r1, [pc, #40]	; (9b60 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x54>)
    9b38:	9b01      	ldr	r3, [sp, #4]
    9b3a:	9a00      	ldr	r2, [sp, #0]
    9b3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]++;
    9b40:	4a06      	ldr	r2, [pc, #24]	; (9b5c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    9b42:	9b01      	ldr	r3, [sp, #4]
    9b44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b48:	1c5a      	adds	r2, r3, #1
    9b4a:	4904      	ldr	r1, [pc, #16]	; (9b5c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
    9b4c:	9b01      	ldr	r3, [sp, #4]
    9b4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9b52:	bf00      	nop
    9b54:	b003      	add	sp, #12
    9b56:	f85d fb04 	ldr.w	pc, [sp], #4
    9b5a:	bf00      	nop
    9b5c:	1fff8e88 	.word	0x1fff8e88
    9b60:	1fff8e84 	.word	0x1fff8e84

00009b64 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
    9b64:	b500      	push	{lr}
    9b66:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9b68:	f7f7 f894 	bl	c94 <Sys_GetCoreID>
    9b6c:	4603      	mov	r3, r0
    9b6e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]--;
    9b70:	4a0d      	ldr	r2, [pc, #52]	; (9ba8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    9b72:	9b01      	ldr	r3, [sp, #4]
    9b74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b78:	1e5a      	subs	r2, r3, #1
    9b7a:	490b      	ldr	r1, [pc, #44]	; (9ba8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    9b7c:	9b01      	ldr	r3, [sp, #4]
    9b7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    9b82:	4a0a      	ldr	r2, [pc, #40]	; (9bac <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x48>)
    9b84:	9b01      	ldr	r3, [sp, #4]
    9b86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b8a:	f003 0301 	and.w	r3, r3, #1
    9b8e:	2b00      	cmp	r3, #0
    9b90:	d106      	bne.n	9ba0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
    9b92:	4a05      	ldr	r2, [pc, #20]	; (9ba8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
    9b94:	9b01      	ldr	r3, [sp, #4]
    9b96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b9a:	2b00      	cmp	r3, #0
    9b9c:	d100      	bne.n	9ba0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9b9e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ba0:	bf00      	nop
    9ba2:	b003      	add	sp, #12
    9ba4:	f85d fb04 	ldr.w	pc, [sp], #4
    9ba8:	1fff8e88 	.word	0x1fff8e88
    9bac:	1fff8e84 	.word	0x1fff8e84

00009bb0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
    9bb0:	b500      	push	{lr}
    9bb2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9bb4:	f7f7 f86e 	bl	c94 <Sys_GetCoreID>
    9bb8:	4603      	mov	r3, r0
    9bba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId])
    9bbc:	4a10      	ldr	r2, [pc, #64]	; (9c00 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    9bbe:	9b01      	ldr	r3, [sp, #4]
    9bc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bc4:	2b00      	cmp	r3, #0
    9bc6:	d10d      	bne.n	9be4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9bc8:	f7f6 ff94 	bl	af4 <Spi_schm_read_msr>
    9bcc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9bce:	9b00      	ldr	r3, [sp, #0]
    9bd0:	f003 0301 	and.w	r3, r3, #1
    9bd4:	2b00      	cmp	r3, #0
    9bd6:	d100      	bne.n	9bda <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9bd8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    9bda:	490a      	ldr	r1, [pc, #40]	; (9c04 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x54>)
    9bdc:	9b01      	ldr	r3, [sp, #4]
    9bde:	9a00      	ldr	r2, [sp, #0]
    9be0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]++;
    9be4:	4a06      	ldr	r2, [pc, #24]	; (9c00 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    9be6:	9b01      	ldr	r3, [sp, #4]
    9be8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bec:	1c5a      	adds	r2, r3, #1
    9bee:	4904      	ldr	r1, [pc, #16]	; (9c00 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
    9bf0:	9b01      	ldr	r3, [sp, #4]
    9bf2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9bf6:	bf00      	nop
    9bf8:	b003      	add	sp, #12
    9bfa:	f85d fb04 	ldr.w	pc, [sp], #4
    9bfe:	bf00      	nop
    9c00:	1fff8e90 	.word	0x1fff8e90
    9c04:	1fff8e8c 	.word	0x1fff8e8c

00009c08 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
    9c08:	b500      	push	{lr}
    9c0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c0c:	f7f7 f842 	bl	c94 <Sys_GetCoreID>
    9c10:	4603      	mov	r3, r0
    9c12:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]--;
    9c14:	4a0d      	ldr	r2, [pc, #52]	; (9c4c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    9c16:	9b01      	ldr	r3, [sp, #4]
    9c18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c1c:	1e5a      	subs	r2, r3, #1
    9c1e:	490b      	ldr	r1, [pc, #44]	; (9c4c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    9c20:	9b01      	ldr	r3, [sp, #4]
    9c22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    9c26:	4a0a      	ldr	r2, [pc, #40]	; (9c50 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x48>)
    9c28:	9b01      	ldr	r3, [sp, #4]
    9c2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c2e:	f003 0301 	and.w	r3, r3, #1
    9c32:	2b00      	cmp	r3, #0
    9c34:	d106      	bne.n	9c44 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
    9c36:	4a05      	ldr	r2, [pc, #20]	; (9c4c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
    9c38:	9b01      	ldr	r3, [sp, #4]
    9c3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c3e:	2b00      	cmp	r3, #0
    9c40:	d100      	bne.n	9c44 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9c42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9c44:	bf00      	nop
    9c46:	b003      	add	sp, #12
    9c48:	f85d fb04 	ldr.w	pc, [sp], #4
    9c4c:	1fff8e90 	.word	0x1fff8e90
    9c50:	1fff8e8c 	.word	0x1fff8e8c

00009c54 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
    9c54:	b500      	push	{lr}
    9c56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c58:	f7f7 f81c 	bl	c94 <Sys_GetCoreID>
    9c5c:	4603      	mov	r3, r0
    9c5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId])
    9c60:	4a10      	ldr	r2, [pc, #64]	; (9ca4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    9c62:	9b01      	ldr	r3, [sp, #4]
    9c64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c68:	2b00      	cmp	r3, #0
    9c6a:	d10d      	bne.n	9c88 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9c6c:	f7f6 ff42 	bl	af4 <Spi_schm_read_msr>
    9c70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9c72:	9b00      	ldr	r3, [sp, #0]
    9c74:	f003 0301 	and.w	r3, r3, #1
    9c78:	2b00      	cmp	r3, #0
    9c7a:	d100      	bne.n	9c7e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9c7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    9c7e:	490a      	ldr	r1, [pc, #40]	; (9ca8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x54>)
    9c80:	9b01      	ldr	r3, [sp, #4]
    9c82:	9a00      	ldr	r2, [sp, #0]
    9c84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]++;
    9c88:	4a06      	ldr	r2, [pc, #24]	; (9ca4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    9c8a:	9b01      	ldr	r3, [sp, #4]
    9c8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c90:	1c5a      	adds	r2, r3, #1
    9c92:	4904      	ldr	r1, [pc, #16]	; (9ca4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
    9c94:	9b01      	ldr	r3, [sp, #4]
    9c96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9c9a:	bf00      	nop
    9c9c:	b003      	add	sp, #12
    9c9e:	f85d fb04 	ldr.w	pc, [sp], #4
    9ca2:	bf00      	nop
    9ca4:	1fff8e98 	.word	0x1fff8e98
    9ca8:	1fff8e94 	.word	0x1fff8e94

00009cac <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
    9cac:	b500      	push	{lr}
    9cae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9cb0:	f7f6 fff0 	bl	c94 <Sys_GetCoreID>
    9cb4:	4603      	mov	r3, r0
    9cb6:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]--;
    9cb8:	4a0d      	ldr	r2, [pc, #52]	; (9cf0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    9cba:	9b01      	ldr	r3, [sp, #4]
    9cbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cc0:	1e5a      	subs	r2, r3, #1
    9cc2:	490b      	ldr	r1, [pc, #44]	; (9cf0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    9cc4:	9b01      	ldr	r3, [sp, #4]
    9cc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    9cca:	4a0a      	ldr	r2, [pc, #40]	; (9cf4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x48>)
    9ccc:	9b01      	ldr	r3, [sp, #4]
    9cce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cd2:	f003 0301 	and.w	r3, r3, #1
    9cd6:	2b00      	cmp	r3, #0
    9cd8:	d106      	bne.n	9ce8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
    9cda:	4a05      	ldr	r2, [pc, #20]	; (9cf0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
    9cdc:	9b01      	ldr	r3, [sp, #4]
    9cde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ce2:	2b00      	cmp	r3, #0
    9ce4:	d100      	bne.n	9ce8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9ce6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ce8:	bf00      	nop
    9cea:	b003      	add	sp, #12
    9cec:	f85d fb04 	ldr.w	pc, [sp], #4
    9cf0:	1fff8e98 	.word	0x1fff8e98
    9cf4:	1fff8e94 	.word	0x1fff8e94

00009cf8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
    9cf8:	b500      	push	{lr}
    9cfa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9cfc:	f7f6 ffca 	bl	c94 <Sys_GetCoreID>
    9d00:	4603      	mov	r3, r0
    9d02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId])
    9d04:	4a10      	ldr	r2, [pc, #64]	; (9d48 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    9d06:	9b01      	ldr	r3, [sp, #4]
    9d08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d0c:	2b00      	cmp	r3, #0
    9d0e:	d10d      	bne.n	9d2c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9d10:	f7f6 fef0 	bl	af4 <Spi_schm_read_msr>
    9d14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9d16:	9b00      	ldr	r3, [sp, #0]
    9d18:	f003 0301 	and.w	r3, r3, #1
    9d1c:	2b00      	cmp	r3, #0
    9d1e:	d100      	bne.n	9d22 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9d20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    9d22:	490a      	ldr	r1, [pc, #40]	; (9d4c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x54>)
    9d24:	9b01      	ldr	r3, [sp, #4]
    9d26:	9a00      	ldr	r2, [sp, #0]
    9d28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]++;
    9d2c:	4a06      	ldr	r2, [pc, #24]	; (9d48 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    9d2e:	9b01      	ldr	r3, [sp, #4]
    9d30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d34:	1c5a      	adds	r2, r3, #1
    9d36:	4904      	ldr	r1, [pc, #16]	; (9d48 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
    9d38:	9b01      	ldr	r3, [sp, #4]
    9d3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9d3e:	bf00      	nop
    9d40:	b003      	add	sp, #12
    9d42:	f85d fb04 	ldr.w	pc, [sp], #4
    9d46:	bf00      	nop
    9d48:	1fff8ea0 	.word	0x1fff8ea0
    9d4c:	1fff8e9c 	.word	0x1fff8e9c

00009d50 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
    9d50:	b500      	push	{lr}
    9d52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9d54:	f7f6 ff9e 	bl	c94 <Sys_GetCoreID>
    9d58:	4603      	mov	r3, r0
    9d5a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]--;
    9d5c:	4a0d      	ldr	r2, [pc, #52]	; (9d94 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    9d5e:	9b01      	ldr	r3, [sp, #4]
    9d60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d64:	1e5a      	subs	r2, r3, #1
    9d66:	490b      	ldr	r1, [pc, #44]	; (9d94 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    9d68:	9b01      	ldr	r3, [sp, #4]
    9d6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    9d6e:	4a0a      	ldr	r2, [pc, #40]	; (9d98 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x48>)
    9d70:	9b01      	ldr	r3, [sp, #4]
    9d72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d76:	f003 0301 	and.w	r3, r3, #1
    9d7a:	2b00      	cmp	r3, #0
    9d7c:	d106      	bne.n	9d8c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
    9d7e:	4a05      	ldr	r2, [pc, #20]	; (9d94 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
    9d80:	9b01      	ldr	r3, [sp, #4]
    9d82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d86:	2b00      	cmp	r3, #0
    9d88:	d100      	bne.n	9d8c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9d8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9d8c:	bf00      	nop
    9d8e:	b003      	add	sp, #12
    9d90:	f85d fb04 	ldr.w	pc, [sp], #4
    9d94:	1fff8ea0 	.word	0x1fff8ea0
    9d98:	1fff8e9c 	.word	0x1fff8e9c

00009d9c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
    9d9c:	b500      	push	{lr}
    9d9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9da0:	f7f6 ff78 	bl	c94 <Sys_GetCoreID>
    9da4:	4603      	mov	r3, r0
    9da6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId])
    9da8:	4a10      	ldr	r2, [pc, #64]	; (9dec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    9daa:	9b01      	ldr	r3, [sp, #4]
    9dac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9db0:	2b00      	cmp	r3, #0
    9db2:	d10d      	bne.n	9dd0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9db4:	f7f6 fe9e 	bl	af4 <Spi_schm_read_msr>
    9db8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9dba:	9b00      	ldr	r3, [sp, #0]
    9dbc:	f003 0301 	and.w	r3, r3, #1
    9dc0:	2b00      	cmp	r3, #0
    9dc2:	d100      	bne.n	9dc6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9dc4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    9dc6:	490a      	ldr	r1, [pc, #40]	; (9df0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x54>)
    9dc8:	9b01      	ldr	r3, [sp, #4]
    9dca:	9a00      	ldr	r2, [sp, #0]
    9dcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]++;
    9dd0:	4a06      	ldr	r2, [pc, #24]	; (9dec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    9dd2:	9b01      	ldr	r3, [sp, #4]
    9dd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9dd8:	1c5a      	adds	r2, r3, #1
    9dda:	4904      	ldr	r1, [pc, #16]	; (9dec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
    9ddc:	9b01      	ldr	r3, [sp, #4]
    9dde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9de2:	bf00      	nop
    9de4:	b003      	add	sp, #12
    9de6:	f85d fb04 	ldr.w	pc, [sp], #4
    9dea:	bf00      	nop
    9dec:	1fff8ea8 	.word	0x1fff8ea8
    9df0:	1fff8ea4 	.word	0x1fff8ea4

00009df4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
    9df4:	b500      	push	{lr}
    9df6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9df8:	f7f6 ff4c 	bl	c94 <Sys_GetCoreID>
    9dfc:	4603      	mov	r3, r0
    9dfe:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]--;
    9e00:	4a0d      	ldr	r2, [pc, #52]	; (9e38 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9e02:	9b01      	ldr	r3, [sp, #4]
    9e04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e08:	1e5a      	subs	r2, r3, #1
    9e0a:	490b      	ldr	r1, [pc, #44]	; (9e38 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9e0c:	9b01      	ldr	r3, [sp, #4]
    9e0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    9e12:	4a0a      	ldr	r2, [pc, #40]	; (9e3c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x48>)
    9e14:	9b01      	ldr	r3, [sp, #4]
    9e16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e1a:	f003 0301 	and.w	r3, r3, #1
    9e1e:	2b00      	cmp	r3, #0
    9e20:	d106      	bne.n	9e30 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
    9e22:	4a05      	ldr	r2, [pc, #20]	; (9e38 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
    9e24:	9b01      	ldr	r3, [sp, #4]
    9e26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e2a:	2b00      	cmp	r3, #0
    9e2c:	d100      	bne.n	9e30 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9e2e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9e30:	bf00      	nop
    9e32:	b003      	add	sp, #12
    9e34:	f85d fb04 	ldr.w	pc, [sp], #4
    9e38:	1fff8ea8 	.word	0x1fff8ea8
    9e3c:	1fff8ea4 	.word	0x1fff8ea4

00009e40 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
    9e40:	b500      	push	{lr}
    9e42:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e44:	f7f6 ff26 	bl	c94 <Sys_GetCoreID>
    9e48:	4603      	mov	r3, r0
    9e4a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId])
    9e4c:	4a10      	ldr	r2, [pc, #64]	; (9e90 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    9e4e:	9b01      	ldr	r3, [sp, #4]
    9e50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e54:	2b00      	cmp	r3, #0
    9e56:	d10d      	bne.n	9e74 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9e58:	f7f6 fe4c 	bl	af4 <Spi_schm_read_msr>
    9e5c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9e5e:	9b00      	ldr	r3, [sp, #0]
    9e60:	f003 0301 	and.w	r3, r3, #1
    9e64:	2b00      	cmp	r3, #0
    9e66:	d100      	bne.n	9e6a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9e68:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    9e6a:	490a      	ldr	r1, [pc, #40]	; (9e94 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x54>)
    9e6c:	9b01      	ldr	r3, [sp, #4]
    9e6e:	9a00      	ldr	r2, [sp, #0]
    9e70:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]++;
    9e74:	4a06      	ldr	r2, [pc, #24]	; (9e90 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    9e76:	9b01      	ldr	r3, [sp, #4]
    9e78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e7c:	1c5a      	adds	r2, r3, #1
    9e7e:	4904      	ldr	r1, [pc, #16]	; (9e90 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
    9e80:	9b01      	ldr	r3, [sp, #4]
    9e82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9e86:	bf00      	nop
    9e88:	b003      	add	sp, #12
    9e8a:	f85d fb04 	ldr.w	pc, [sp], #4
    9e8e:	bf00      	nop
    9e90:	1fff8eb0 	.word	0x1fff8eb0
    9e94:	1fff8eac 	.word	0x1fff8eac

00009e98 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
    9e98:	b500      	push	{lr}
    9e9a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e9c:	f7f6 fefa 	bl	c94 <Sys_GetCoreID>
    9ea0:	4603      	mov	r3, r0
    9ea2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]--;
    9ea4:	4a0d      	ldr	r2, [pc, #52]	; (9edc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    9ea6:	9b01      	ldr	r3, [sp, #4]
    9ea8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9eac:	1e5a      	subs	r2, r3, #1
    9eae:	490b      	ldr	r1, [pc, #44]	; (9edc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    9eb0:	9b01      	ldr	r3, [sp, #4]
    9eb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    9eb6:	4a0a      	ldr	r2, [pc, #40]	; (9ee0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x48>)
    9eb8:	9b01      	ldr	r3, [sp, #4]
    9eba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ebe:	f003 0301 	and.w	r3, r3, #1
    9ec2:	2b00      	cmp	r3, #0
    9ec4:	d106      	bne.n	9ed4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
    9ec6:	4a05      	ldr	r2, [pc, #20]	; (9edc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
    9ec8:	9b01      	ldr	r3, [sp, #4]
    9eca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ece:	2b00      	cmp	r3, #0
    9ed0:	d100      	bne.n	9ed4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9ed2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ed4:	bf00      	nop
    9ed6:	b003      	add	sp, #12
    9ed8:	f85d fb04 	ldr.w	pc, [sp], #4
    9edc:	1fff8eb0 	.word	0x1fff8eb0
    9ee0:	1fff8eac 	.word	0x1fff8eac

00009ee4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
    9ee4:	b500      	push	{lr}
    9ee6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ee8:	f7f6 fed4 	bl	c94 <Sys_GetCoreID>
    9eec:	4603      	mov	r3, r0
    9eee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId])
    9ef0:	4a10      	ldr	r2, [pc, #64]	; (9f34 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    9ef2:	9b01      	ldr	r3, [sp, #4]
    9ef4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ef8:	2b00      	cmp	r3, #0
    9efa:	d10d      	bne.n	9f18 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9efc:	f7f6 fdfa 	bl	af4 <Spi_schm_read_msr>
    9f00:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9f02:	9b00      	ldr	r3, [sp, #0]
    9f04:	f003 0301 	and.w	r3, r3, #1
    9f08:	2b00      	cmp	r3, #0
    9f0a:	d100      	bne.n	9f0e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9f0c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    9f0e:	490a      	ldr	r1, [pc, #40]	; (9f38 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x54>)
    9f10:	9b01      	ldr	r3, [sp, #4]
    9f12:	9a00      	ldr	r2, [sp, #0]
    9f14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]++;
    9f18:	4a06      	ldr	r2, [pc, #24]	; (9f34 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    9f1a:	9b01      	ldr	r3, [sp, #4]
    9f1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f20:	1c5a      	adds	r2, r3, #1
    9f22:	4904      	ldr	r1, [pc, #16]	; (9f34 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
    9f24:	9b01      	ldr	r3, [sp, #4]
    9f26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9f2a:	bf00      	nop
    9f2c:	b003      	add	sp, #12
    9f2e:	f85d fb04 	ldr.w	pc, [sp], #4
    9f32:	bf00      	nop
    9f34:	1fff8eb8 	.word	0x1fff8eb8
    9f38:	1fff8eb4 	.word	0x1fff8eb4

00009f3c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
    9f3c:	b500      	push	{lr}
    9f3e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f40:	f7f6 fea8 	bl	c94 <Sys_GetCoreID>
    9f44:	4603      	mov	r3, r0
    9f46:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]--;
    9f48:	4a0d      	ldr	r2, [pc, #52]	; (9f80 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    9f4a:	9b01      	ldr	r3, [sp, #4]
    9f4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f50:	1e5a      	subs	r2, r3, #1
    9f52:	490b      	ldr	r1, [pc, #44]	; (9f80 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    9f54:	9b01      	ldr	r3, [sp, #4]
    9f56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    9f5a:	4a0a      	ldr	r2, [pc, #40]	; (9f84 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x48>)
    9f5c:	9b01      	ldr	r3, [sp, #4]
    9f5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f62:	f003 0301 	and.w	r3, r3, #1
    9f66:	2b00      	cmp	r3, #0
    9f68:	d106      	bne.n	9f78 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
    9f6a:	4a05      	ldr	r2, [pc, #20]	; (9f80 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
    9f6c:	9b01      	ldr	r3, [sp, #4]
    9f6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f72:	2b00      	cmp	r3, #0
    9f74:	d100      	bne.n	9f78 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9f76:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9f78:	bf00      	nop
    9f7a:	b003      	add	sp, #12
    9f7c:	f85d fb04 	ldr.w	pc, [sp], #4
    9f80:	1fff8eb8 	.word	0x1fff8eb8
    9f84:	1fff8eb4 	.word	0x1fff8eb4

00009f88 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
    9f88:	b500      	push	{lr}
    9f8a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f8c:	f7f6 fe82 	bl	c94 <Sys_GetCoreID>
    9f90:	4603      	mov	r3, r0
    9f92:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId])
    9f94:	4a10      	ldr	r2, [pc, #64]	; (9fd8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    9f96:	9b01      	ldr	r3, [sp, #4]
    9f98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f9c:	2b00      	cmp	r3, #0
    9f9e:	d10d      	bne.n	9fbc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9fa0:	f7f6 fda8 	bl	af4 <Spi_schm_read_msr>
    9fa4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9fa6:	9b00      	ldr	r3, [sp, #0]
    9fa8:	f003 0301 	and.w	r3, r3, #1
    9fac:	2b00      	cmp	r3, #0
    9fae:	d100      	bne.n	9fb2 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9fb0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    9fb2:	490a      	ldr	r1, [pc, #40]	; (9fdc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x54>)
    9fb4:	9b01      	ldr	r3, [sp, #4]
    9fb6:	9a00      	ldr	r2, [sp, #0]
    9fb8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]++;
    9fbc:	4a06      	ldr	r2, [pc, #24]	; (9fd8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    9fbe:	9b01      	ldr	r3, [sp, #4]
    9fc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fc4:	1c5a      	adds	r2, r3, #1
    9fc6:	4904      	ldr	r1, [pc, #16]	; (9fd8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
    9fc8:	9b01      	ldr	r3, [sp, #4]
    9fca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9fce:	bf00      	nop
    9fd0:	b003      	add	sp, #12
    9fd2:	f85d fb04 	ldr.w	pc, [sp], #4
    9fd6:	bf00      	nop
    9fd8:	1fff8ec0 	.word	0x1fff8ec0
    9fdc:	1fff8ebc 	.word	0x1fff8ebc

00009fe0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
    9fe0:	b500      	push	{lr}
    9fe2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9fe4:	f7f6 fe56 	bl	c94 <Sys_GetCoreID>
    9fe8:	4603      	mov	r3, r0
    9fea:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]--;
    9fec:	4a0d      	ldr	r2, [pc, #52]	; (a024 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    9fee:	9b01      	ldr	r3, [sp, #4]
    9ff0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ff4:	1e5a      	subs	r2, r3, #1
    9ff6:	490b      	ldr	r1, [pc, #44]	; (a024 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    9ff8:	9b01      	ldr	r3, [sp, #4]
    9ffa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    9ffe:	4a0a      	ldr	r2, [pc, #40]	; (a028 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x48>)
    a000:	9b01      	ldr	r3, [sp, #4]
    a002:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a006:	f003 0301 	and.w	r3, r3, #1
    a00a:	2b00      	cmp	r3, #0
    a00c:	d106      	bne.n	a01c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
    a00e:	4a05      	ldr	r2, [pc, #20]	; (a024 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
    a010:	9b01      	ldr	r3, [sp, #4]
    a012:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a016:	2b00      	cmp	r3, #0
    a018:	d100      	bne.n	a01c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a01a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a01c:	bf00      	nop
    a01e:	b003      	add	sp, #12
    a020:	f85d fb04 	ldr.w	pc, [sp], #4
    a024:	1fff8ec0 	.word	0x1fff8ec0
    a028:	1fff8ebc 	.word	0x1fff8ebc

0000a02c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
    a02c:	b500      	push	{lr}
    a02e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a030:	f7f6 fe30 	bl	c94 <Sys_GetCoreID>
    a034:	4603      	mov	r3, r0
    a036:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId])
    a038:	4a10      	ldr	r2, [pc, #64]	; (a07c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    a03a:	9b01      	ldr	r3, [sp, #4]
    a03c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a040:	2b00      	cmp	r3, #0
    a042:	d10d      	bne.n	a060 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a044:	f7f6 fd56 	bl	af4 <Spi_schm_read_msr>
    a048:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a04a:	9b00      	ldr	r3, [sp, #0]
    a04c:	f003 0301 	and.w	r3, r3, #1
    a050:	2b00      	cmp	r3, #0
    a052:	d100      	bne.n	a056 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a054:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    a056:	490a      	ldr	r1, [pc, #40]	; (a080 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x54>)
    a058:	9b01      	ldr	r3, [sp, #4]
    a05a:	9a00      	ldr	r2, [sp, #0]
    a05c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]++;
    a060:	4a06      	ldr	r2, [pc, #24]	; (a07c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    a062:	9b01      	ldr	r3, [sp, #4]
    a064:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a068:	1c5a      	adds	r2, r3, #1
    a06a:	4904      	ldr	r1, [pc, #16]	; (a07c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
    a06c:	9b01      	ldr	r3, [sp, #4]
    a06e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a072:	bf00      	nop
    a074:	b003      	add	sp, #12
    a076:	f85d fb04 	ldr.w	pc, [sp], #4
    a07a:	bf00      	nop
    a07c:	1fff8ec8 	.word	0x1fff8ec8
    a080:	1fff8ec4 	.word	0x1fff8ec4

0000a084 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
    a084:	b500      	push	{lr}
    a086:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a088:	f7f6 fe04 	bl	c94 <Sys_GetCoreID>
    a08c:	4603      	mov	r3, r0
    a08e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]--;
    a090:	4a0d      	ldr	r2, [pc, #52]	; (a0c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    a092:	9b01      	ldr	r3, [sp, #4]
    a094:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a098:	1e5a      	subs	r2, r3, #1
    a09a:	490b      	ldr	r1, [pc, #44]	; (a0c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    a09c:	9b01      	ldr	r3, [sp, #4]
    a09e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    a0a2:	4a0a      	ldr	r2, [pc, #40]	; (a0cc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x48>)
    a0a4:	9b01      	ldr	r3, [sp, #4]
    a0a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0aa:	f003 0301 	and.w	r3, r3, #1
    a0ae:	2b00      	cmp	r3, #0
    a0b0:	d106      	bne.n	a0c0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
    a0b2:	4a05      	ldr	r2, [pc, #20]	; (a0c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
    a0b4:	9b01      	ldr	r3, [sp, #4]
    a0b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0ba:	2b00      	cmp	r3, #0
    a0bc:	d100      	bne.n	a0c0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a0be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a0c0:	bf00      	nop
    a0c2:	b003      	add	sp, #12
    a0c4:	f85d fb04 	ldr.w	pc, [sp], #4
    a0c8:	1fff8ec8 	.word	0x1fff8ec8
    a0cc:	1fff8ec4 	.word	0x1fff8ec4

0000a0d0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
    a0d0:	b500      	push	{lr}
    a0d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a0d4:	f7f6 fdde 	bl	c94 <Sys_GetCoreID>
    a0d8:	4603      	mov	r3, r0
    a0da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId])
    a0dc:	4a10      	ldr	r2, [pc, #64]	; (a120 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    a0de:	9b01      	ldr	r3, [sp, #4]
    a0e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0e4:	2b00      	cmp	r3, #0
    a0e6:	d10d      	bne.n	a104 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a0e8:	f7f6 fd04 	bl	af4 <Spi_schm_read_msr>
    a0ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a0ee:	9b00      	ldr	r3, [sp, #0]
    a0f0:	f003 0301 	and.w	r3, r3, #1
    a0f4:	2b00      	cmp	r3, #0
    a0f6:	d100      	bne.n	a0fa <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a0f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    a0fa:	490a      	ldr	r1, [pc, #40]	; (a124 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x54>)
    a0fc:	9b01      	ldr	r3, [sp, #4]
    a0fe:	9a00      	ldr	r2, [sp, #0]
    a100:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]++;
    a104:	4a06      	ldr	r2, [pc, #24]	; (a120 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    a106:	9b01      	ldr	r3, [sp, #4]
    a108:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a10c:	1c5a      	adds	r2, r3, #1
    a10e:	4904      	ldr	r1, [pc, #16]	; (a120 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
    a110:	9b01      	ldr	r3, [sp, #4]
    a112:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a116:	bf00      	nop
    a118:	b003      	add	sp, #12
    a11a:	f85d fb04 	ldr.w	pc, [sp], #4
    a11e:	bf00      	nop
    a120:	1fff8ed0 	.word	0x1fff8ed0
    a124:	1fff8ecc 	.word	0x1fff8ecc

0000a128 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
    a128:	b500      	push	{lr}
    a12a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a12c:	f7f6 fdb2 	bl	c94 <Sys_GetCoreID>
    a130:	4603      	mov	r3, r0
    a132:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]--;
    a134:	4a0d      	ldr	r2, [pc, #52]	; (a16c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    a136:	9b01      	ldr	r3, [sp, #4]
    a138:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a13c:	1e5a      	subs	r2, r3, #1
    a13e:	490b      	ldr	r1, [pc, #44]	; (a16c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    a140:	9b01      	ldr	r3, [sp, #4]
    a142:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    a146:	4a0a      	ldr	r2, [pc, #40]	; (a170 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x48>)
    a148:	9b01      	ldr	r3, [sp, #4]
    a14a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a14e:	f003 0301 	and.w	r3, r3, #1
    a152:	2b00      	cmp	r3, #0
    a154:	d106      	bne.n	a164 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
    a156:	4a05      	ldr	r2, [pc, #20]	; (a16c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
    a158:	9b01      	ldr	r3, [sp, #4]
    a15a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a15e:	2b00      	cmp	r3, #0
    a160:	d100      	bne.n	a164 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a162:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a164:	bf00      	nop
    a166:	b003      	add	sp, #12
    a168:	f85d fb04 	ldr.w	pc, [sp], #4
    a16c:	1fff8ed0 	.word	0x1fff8ed0
    a170:	1fff8ecc 	.word	0x1fff8ecc

0000a174 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
    a174:	b500      	push	{lr}
    a176:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a178:	f7f6 fd8c 	bl	c94 <Sys_GetCoreID>
    a17c:	4603      	mov	r3, r0
    a17e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId])
    a180:	4a10      	ldr	r2, [pc, #64]	; (a1c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    a182:	9b01      	ldr	r3, [sp, #4]
    a184:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a188:	2b00      	cmp	r3, #0
    a18a:	d10d      	bne.n	a1a8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a18c:	f7f6 fcb2 	bl	af4 <Spi_schm_read_msr>
    a190:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a192:	9b00      	ldr	r3, [sp, #0]
    a194:	f003 0301 	and.w	r3, r3, #1
    a198:	2b00      	cmp	r3, #0
    a19a:	d100      	bne.n	a19e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a19c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    a19e:	490a      	ldr	r1, [pc, #40]	; (a1c8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x54>)
    a1a0:	9b01      	ldr	r3, [sp, #4]
    a1a2:	9a00      	ldr	r2, [sp, #0]
    a1a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]++;
    a1a8:	4a06      	ldr	r2, [pc, #24]	; (a1c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    a1aa:	9b01      	ldr	r3, [sp, #4]
    a1ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1b0:	1c5a      	adds	r2, r3, #1
    a1b2:	4904      	ldr	r1, [pc, #16]	; (a1c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
    a1b4:	9b01      	ldr	r3, [sp, #4]
    a1b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a1ba:	bf00      	nop
    a1bc:	b003      	add	sp, #12
    a1be:	f85d fb04 	ldr.w	pc, [sp], #4
    a1c2:	bf00      	nop
    a1c4:	1fff8ed8 	.word	0x1fff8ed8
    a1c8:	1fff8ed4 	.word	0x1fff8ed4

0000a1cc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
    a1cc:	b500      	push	{lr}
    a1ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a1d0:	f7f6 fd60 	bl	c94 <Sys_GetCoreID>
    a1d4:	4603      	mov	r3, r0
    a1d6:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]--;
    a1d8:	4a0d      	ldr	r2, [pc, #52]	; (a210 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    a1da:	9b01      	ldr	r3, [sp, #4]
    a1dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1e0:	1e5a      	subs	r2, r3, #1
    a1e2:	490b      	ldr	r1, [pc, #44]	; (a210 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    a1e4:	9b01      	ldr	r3, [sp, #4]
    a1e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    a1ea:	4a0a      	ldr	r2, [pc, #40]	; (a214 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x48>)
    a1ec:	9b01      	ldr	r3, [sp, #4]
    a1ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1f2:	f003 0301 	and.w	r3, r3, #1
    a1f6:	2b00      	cmp	r3, #0
    a1f8:	d106      	bne.n	a208 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
    a1fa:	4a05      	ldr	r2, [pc, #20]	; (a210 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
    a1fc:	9b01      	ldr	r3, [sp, #4]
    a1fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a202:	2b00      	cmp	r3, #0
    a204:	d100      	bne.n	a208 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a206:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a208:	bf00      	nop
    a20a:	b003      	add	sp, #12
    a20c:	f85d fb04 	ldr.w	pc, [sp], #4
    a210:	1fff8ed8 	.word	0x1fff8ed8
    a214:	1fff8ed4 	.word	0x1fff8ed4

0000a218 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
    a218:	b500      	push	{lr}
    a21a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a21c:	f7f6 fd3a 	bl	c94 <Sys_GetCoreID>
    a220:	4603      	mov	r3, r0
    a222:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId])
    a224:	4a10      	ldr	r2, [pc, #64]	; (a268 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    a226:	9b01      	ldr	r3, [sp, #4]
    a228:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a22c:	2b00      	cmp	r3, #0
    a22e:	d10d      	bne.n	a24c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a230:	f7f6 fc60 	bl	af4 <Spi_schm_read_msr>
    a234:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a236:	9b00      	ldr	r3, [sp, #0]
    a238:	f003 0301 	and.w	r3, r3, #1
    a23c:	2b00      	cmp	r3, #0
    a23e:	d100      	bne.n	a242 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a240:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    a242:	490a      	ldr	r1, [pc, #40]	; (a26c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x54>)
    a244:	9b01      	ldr	r3, [sp, #4]
    a246:	9a00      	ldr	r2, [sp, #0]
    a248:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]++;
    a24c:	4a06      	ldr	r2, [pc, #24]	; (a268 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    a24e:	9b01      	ldr	r3, [sp, #4]
    a250:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a254:	1c5a      	adds	r2, r3, #1
    a256:	4904      	ldr	r1, [pc, #16]	; (a268 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
    a258:	9b01      	ldr	r3, [sp, #4]
    a25a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a25e:	bf00      	nop
    a260:	b003      	add	sp, #12
    a262:	f85d fb04 	ldr.w	pc, [sp], #4
    a266:	bf00      	nop
    a268:	1fff8ee0 	.word	0x1fff8ee0
    a26c:	1fff8edc 	.word	0x1fff8edc

0000a270 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
    a270:	b500      	push	{lr}
    a272:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a274:	f7f6 fd0e 	bl	c94 <Sys_GetCoreID>
    a278:	4603      	mov	r3, r0
    a27a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]--;
    a27c:	4a0d      	ldr	r2, [pc, #52]	; (a2b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    a27e:	9b01      	ldr	r3, [sp, #4]
    a280:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a284:	1e5a      	subs	r2, r3, #1
    a286:	490b      	ldr	r1, [pc, #44]	; (a2b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    a288:	9b01      	ldr	r3, [sp, #4]
    a28a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    a28e:	4a0a      	ldr	r2, [pc, #40]	; (a2b8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x48>)
    a290:	9b01      	ldr	r3, [sp, #4]
    a292:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a296:	f003 0301 	and.w	r3, r3, #1
    a29a:	2b00      	cmp	r3, #0
    a29c:	d106      	bne.n	a2ac <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
    a29e:	4a05      	ldr	r2, [pc, #20]	; (a2b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
    a2a0:	9b01      	ldr	r3, [sp, #4]
    a2a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2a6:	2b00      	cmp	r3, #0
    a2a8:	d100      	bne.n	a2ac <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a2aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a2ac:	bf00      	nop
    a2ae:	b003      	add	sp, #12
    a2b0:	f85d fb04 	ldr.w	pc, [sp], #4
    a2b4:	1fff8ee0 	.word	0x1fff8ee0
    a2b8:	1fff8edc 	.word	0x1fff8edc

0000a2bc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
    a2bc:	b500      	push	{lr}
    a2be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a2c0:	f7f6 fce8 	bl	c94 <Sys_GetCoreID>
    a2c4:	4603      	mov	r3, r0
    a2c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId])
    a2c8:	4a10      	ldr	r2, [pc, #64]	; (a30c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    a2ca:	9b01      	ldr	r3, [sp, #4]
    a2cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2d0:	2b00      	cmp	r3, #0
    a2d2:	d10d      	bne.n	a2f0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a2d4:	f7f6 fc0e 	bl	af4 <Spi_schm_read_msr>
    a2d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a2da:	9b00      	ldr	r3, [sp, #0]
    a2dc:	f003 0301 	and.w	r3, r3, #1
    a2e0:	2b00      	cmp	r3, #0
    a2e2:	d100      	bne.n	a2e6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a2e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    a2e6:	490a      	ldr	r1, [pc, #40]	; (a310 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x54>)
    a2e8:	9b01      	ldr	r3, [sp, #4]
    a2ea:	9a00      	ldr	r2, [sp, #0]
    a2ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]++;
    a2f0:	4a06      	ldr	r2, [pc, #24]	; (a30c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    a2f2:	9b01      	ldr	r3, [sp, #4]
    a2f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2f8:	1c5a      	adds	r2, r3, #1
    a2fa:	4904      	ldr	r1, [pc, #16]	; (a30c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
    a2fc:	9b01      	ldr	r3, [sp, #4]
    a2fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a302:	bf00      	nop
    a304:	b003      	add	sp, #12
    a306:	f85d fb04 	ldr.w	pc, [sp], #4
    a30a:	bf00      	nop
    a30c:	1fff8ee8 	.word	0x1fff8ee8
    a310:	1fff8ee4 	.word	0x1fff8ee4

0000a314 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
    a314:	b500      	push	{lr}
    a316:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a318:	f7f6 fcbc 	bl	c94 <Sys_GetCoreID>
    a31c:	4603      	mov	r3, r0
    a31e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]--;
    a320:	4a0d      	ldr	r2, [pc, #52]	; (a358 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    a322:	9b01      	ldr	r3, [sp, #4]
    a324:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a328:	1e5a      	subs	r2, r3, #1
    a32a:	490b      	ldr	r1, [pc, #44]	; (a358 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    a32c:	9b01      	ldr	r3, [sp, #4]
    a32e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    a332:	4a0a      	ldr	r2, [pc, #40]	; (a35c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x48>)
    a334:	9b01      	ldr	r3, [sp, #4]
    a336:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a33a:	f003 0301 	and.w	r3, r3, #1
    a33e:	2b00      	cmp	r3, #0
    a340:	d106      	bne.n	a350 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
    a342:	4a05      	ldr	r2, [pc, #20]	; (a358 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
    a344:	9b01      	ldr	r3, [sp, #4]
    a346:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a34a:	2b00      	cmp	r3, #0
    a34c:	d100      	bne.n	a350 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a34e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a350:	bf00      	nop
    a352:	b003      	add	sp, #12
    a354:	f85d fb04 	ldr.w	pc, [sp], #4
    a358:	1fff8ee8 	.word	0x1fff8ee8
    a35c:	1fff8ee4 	.word	0x1fff8ee4

0000a360 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
    a360:	b500      	push	{lr}
    a362:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a364:	f7f6 fc96 	bl	c94 <Sys_GetCoreID>
    a368:	4603      	mov	r3, r0
    a36a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId])
    a36c:	4a10      	ldr	r2, [pc, #64]	; (a3b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    a36e:	9b01      	ldr	r3, [sp, #4]
    a370:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a374:	2b00      	cmp	r3, #0
    a376:	d10d      	bne.n	a394 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a378:	f7f6 fbbc 	bl	af4 <Spi_schm_read_msr>
    a37c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a37e:	9b00      	ldr	r3, [sp, #0]
    a380:	f003 0301 	and.w	r3, r3, #1
    a384:	2b00      	cmp	r3, #0
    a386:	d100      	bne.n	a38a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a388:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    a38a:	490a      	ldr	r1, [pc, #40]	; (a3b4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x54>)
    a38c:	9b01      	ldr	r3, [sp, #4]
    a38e:	9a00      	ldr	r2, [sp, #0]
    a390:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]++;
    a394:	4a06      	ldr	r2, [pc, #24]	; (a3b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    a396:	9b01      	ldr	r3, [sp, #4]
    a398:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a39c:	1c5a      	adds	r2, r3, #1
    a39e:	4904      	ldr	r1, [pc, #16]	; (a3b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
    a3a0:	9b01      	ldr	r3, [sp, #4]
    a3a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a3a6:	bf00      	nop
    a3a8:	b003      	add	sp, #12
    a3aa:	f85d fb04 	ldr.w	pc, [sp], #4
    a3ae:	bf00      	nop
    a3b0:	1fff8ef0 	.word	0x1fff8ef0
    a3b4:	1fff8eec 	.word	0x1fff8eec

0000a3b8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
    a3b8:	b500      	push	{lr}
    a3ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a3bc:	f7f6 fc6a 	bl	c94 <Sys_GetCoreID>
    a3c0:	4603      	mov	r3, r0
    a3c2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]--;
    a3c4:	4a0d      	ldr	r2, [pc, #52]	; (a3fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    a3c6:	9b01      	ldr	r3, [sp, #4]
    a3c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3cc:	1e5a      	subs	r2, r3, #1
    a3ce:	490b      	ldr	r1, [pc, #44]	; (a3fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    a3d0:	9b01      	ldr	r3, [sp, #4]
    a3d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    a3d6:	4a0a      	ldr	r2, [pc, #40]	; (a400 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x48>)
    a3d8:	9b01      	ldr	r3, [sp, #4]
    a3da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3de:	f003 0301 	and.w	r3, r3, #1
    a3e2:	2b00      	cmp	r3, #0
    a3e4:	d106      	bne.n	a3f4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
    a3e6:	4a05      	ldr	r2, [pc, #20]	; (a3fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
    a3e8:	9b01      	ldr	r3, [sp, #4]
    a3ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3ee:	2b00      	cmp	r3, #0
    a3f0:	d100      	bne.n	a3f4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a3f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a3f4:	bf00      	nop
    a3f6:	b003      	add	sp, #12
    a3f8:	f85d fb04 	ldr.w	pc, [sp], #4
    a3fc:	1fff8ef0 	.word	0x1fff8ef0
    a400:	1fff8eec 	.word	0x1fff8eec

0000a404 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
    a404:	b500      	push	{lr}
    a406:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a408:	f7f6 fc44 	bl	c94 <Sys_GetCoreID>
    a40c:	4603      	mov	r3, r0
    a40e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId])
    a410:	4a10      	ldr	r2, [pc, #64]	; (a454 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    a412:	9b01      	ldr	r3, [sp, #4]
    a414:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a418:	2b00      	cmp	r3, #0
    a41a:	d10d      	bne.n	a438 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a41c:	f7f6 fb6a 	bl	af4 <Spi_schm_read_msr>
    a420:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a422:	9b00      	ldr	r3, [sp, #0]
    a424:	f003 0301 	and.w	r3, r3, #1
    a428:	2b00      	cmp	r3, #0
    a42a:	d100      	bne.n	a42e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a42c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    a42e:	490a      	ldr	r1, [pc, #40]	; (a458 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x54>)
    a430:	9b01      	ldr	r3, [sp, #4]
    a432:	9a00      	ldr	r2, [sp, #0]
    a434:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]++;
    a438:	4a06      	ldr	r2, [pc, #24]	; (a454 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    a43a:	9b01      	ldr	r3, [sp, #4]
    a43c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a440:	1c5a      	adds	r2, r3, #1
    a442:	4904      	ldr	r1, [pc, #16]	; (a454 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
    a444:	9b01      	ldr	r3, [sp, #4]
    a446:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a44a:	bf00      	nop
    a44c:	b003      	add	sp, #12
    a44e:	f85d fb04 	ldr.w	pc, [sp], #4
    a452:	bf00      	nop
    a454:	1fff8ef8 	.word	0x1fff8ef8
    a458:	1fff8ef4 	.word	0x1fff8ef4

0000a45c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
    a45c:	b500      	push	{lr}
    a45e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a460:	f7f6 fc18 	bl	c94 <Sys_GetCoreID>
    a464:	4603      	mov	r3, r0
    a466:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]--;
    a468:	4a0d      	ldr	r2, [pc, #52]	; (a4a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    a46a:	9b01      	ldr	r3, [sp, #4]
    a46c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a470:	1e5a      	subs	r2, r3, #1
    a472:	490b      	ldr	r1, [pc, #44]	; (a4a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    a474:	9b01      	ldr	r3, [sp, #4]
    a476:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    a47a:	4a0a      	ldr	r2, [pc, #40]	; (a4a4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x48>)
    a47c:	9b01      	ldr	r3, [sp, #4]
    a47e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a482:	f003 0301 	and.w	r3, r3, #1
    a486:	2b00      	cmp	r3, #0
    a488:	d106      	bne.n	a498 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
    a48a:	4a05      	ldr	r2, [pc, #20]	; (a4a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
    a48c:	9b01      	ldr	r3, [sp, #4]
    a48e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a492:	2b00      	cmp	r3, #0
    a494:	d100      	bne.n	a498 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a496:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a498:	bf00      	nop
    a49a:	b003      	add	sp, #12
    a49c:	f85d fb04 	ldr.w	pc, [sp], #4
    a4a0:	1fff8ef8 	.word	0x1fff8ef8
    a4a4:	1fff8ef4 	.word	0x1fff8ef4

0000a4a8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
    a4a8:	b500      	push	{lr}
    a4aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a4ac:	f7f6 fbf2 	bl	c94 <Sys_GetCoreID>
    a4b0:	4603      	mov	r3, r0
    a4b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId])
    a4b4:	4a10      	ldr	r2, [pc, #64]	; (a4f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    a4b6:	9b01      	ldr	r3, [sp, #4]
    a4b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4bc:	2b00      	cmp	r3, #0
    a4be:	d10d      	bne.n	a4dc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a4c0:	f7f6 fb18 	bl	af4 <Spi_schm_read_msr>
    a4c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a4c6:	9b00      	ldr	r3, [sp, #0]
    a4c8:	f003 0301 	and.w	r3, r3, #1
    a4cc:	2b00      	cmp	r3, #0
    a4ce:	d100      	bne.n	a4d2 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a4d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    a4d2:	490a      	ldr	r1, [pc, #40]	; (a4fc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x54>)
    a4d4:	9b01      	ldr	r3, [sp, #4]
    a4d6:	9a00      	ldr	r2, [sp, #0]
    a4d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]++;
    a4dc:	4a06      	ldr	r2, [pc, #24]	; (a4f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    a4de:	9b01      	ldr	r3, [sp, #4]
    a4e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4e4:	1c5a      	adds	r2, r3, #1
    a4e6:	4904      	ldr	r1, [pc, #16]	; (a4f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
    a4e8:	9b01      	ldr	r3, [sp, #4]
    a4ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a4ee:	bf00      	nop
    a4f0:	b003      	add	sp, #12
    a4f2:	f85d fb04 	ldr.w	pc, [sp], #4
    a4f6:	bf00      	nop
    a4f8:	1fff8f00 	.word	0x1fff8f00
    a4fc:	1fff8efc 	.word	0x1fff8efc

0000a500 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
    a500:	b500      	push	{lr}
    a502:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a504:	f7f6 fbc6 	bl	c94 <Sys_GetCoreID>
    a508:	4603      	mov	r3, r0
    a50a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]--;
    a50c:	4a0d      	ldr	r2, [pc, #52]	; (a544 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    a50e:	9b01      	ldr	r3, [sp, #4]
    a510:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a514:	1e5a      	subs	r2, r3, #1
    a516:	490b      	ldr	r1, [pc, #44]	; (a544 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    a518:	9b01      	ldr	r3, [sp, #4]
    a51a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    a51e:	4a0a      	ldr	r2, [pc, #40]	; (a548 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x48>)
    a520:	9b01      	ldr	r3, [sp, #4]
    a522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a526:	f003 0301 	and.w	r3, r3, #1
    a52a:	2b00      	cmp	r3, #0
    a52c:	d106      	bne.n	a53c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
    a52e:	4a05      	ldr	r2, [pc, #20]	; (a544 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
    a530:	9b01      	ldr	r3, [sp, #4]
    a532:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a536:	2b00      	cmp	r3, #0
    a538:	d100      	bne.n	a53c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a53a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a53c:	bf00      	nop
    a53e:	b003      	add	sp, #12
    a540:	f85d fb04 	ldr.w	pc, [sp], #4
    a544:	1fff8f00 	.word	0x1fff8f00
    a548:	1fff8efc 	.word	0x1fff8efc

0000a54c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
    a54c:	b500      	push	{lr}
    a54e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a550:	f7f6 fba0 	bl	c94 <Sys_GetCoreID>
    a554:	4603      	mov	r3, r0
    a556:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId])
    a558:	4a10      	ldr	r2, [pc, #64]	; (a59c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    a55a:	9b01      	ldr	r3, [sp, #4]
    a55c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a560:	2b00      	cmp	r3, #0
    a562:	d10d      	bne.n	a580 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a564:	f7f6 fac6 	bl	af4 <Spi_schm_read_msr>
    a568:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a56a:	9b00      	ldr	r3, [sp, #0]
    a56c:	f003 0301 	and.w	r3, r3, #1
    a570:	2b00      	cmp	r3, #0
    a572:	d100      	bne.n	a576 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a574:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    a576:	490a      	ldr	r1, [pc, #40]	; (a5a0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x54>)
    a578:	9b01      	ldr	r3, [sp, #4]
    a57a:	9a00      	ldr	r2, [sp, #0]
    a57c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]++;
    a580:	4a06      	ldr	r2, [pc, #24]	; (a59c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    a582:	9b01      	ldr	r3, [sp, #4]
    a584:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a588:	1c5a      	adds	r2, r3, #1
    a58a:	4904      	ldr	r1, [pc, #16]	; (a59c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
    a58c:	9b01      	ldr	r3, [sp, #4]
    a58e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a592:	bf00      	nop
    a594:	b003      	add	sp, #12
    a596:	f85d fb04 	ldr.w	pc, [sp], #4
    a59a:	bf00      	nop
    a59c:	1fff8f08 	.word	0x1fff8f08
    a5a0:	1fff8f04 	.word	0x1fff8f04

0000a5a4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
    a5a4:	b500      	push	{lr}
    a5a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a5a8:	f7f6 fb74 	bl	c94 <Sys_GetCoreID>
    a5ac:	4603      	mov	r3, r0
    a5ae:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]--;
    a5b0:	4a0d      	ldr	r2, [pc, #52]	; (a5e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    a5b2:	9b01      	ldr	r3, [sp, #4]
    a5b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5b8:	1e5a      	subs	r2, r3, #1
    a5ba:	490b      	ldr	r1, [pc, #44]	; (a5e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    a5bc:	9b01      	ldr	r3, [sp, #4]
    a5be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    a5c2:	4a0a      	ldr	r2, [pc, #40]	; (a5ec <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x48>)
    a5c4:	9b01      	ldr	r3, [sp, #4]
    a5c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5ca:	f003 0301 	and.w	r3, r3, #1
    a5ce:	2b00      	cmp	r3, #0
    a5d0:	d106      	bne.n	a5e0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
    a5d2:	4a05      	ldr	r2, [pc, #20]	; (a5e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
    a5d4:	9b01      	ldr	r3, [sp, #4]
    a5d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5da:	2b00      	cmp	r3, #0
    a5dc:	d100      	bne.n	a5e0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a5de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a5e0:	bf00      	nop
    a5e2:	b003      	add	sp, #12
    a5e4:	f85d fb04 	ldr.w	pc, [sp], #4
    a5e8:	1fff8f08 	.word	0x1fff8f08
    a5ec:	1fff8f04 	.word	0x1fff8f04

0000a5f0 <Fls_ACEraseRomEnd>:
    a5f0:	61746144 	.word	0x61746144
    a5f4:	6f726620 	.word	0x6f726620
    a5f8:	6565206d 	.word	0x6565206d
    a5fc:	6d6f7270 	.word	0x6d6f7270
    a600:	203a3120 	.word	0x203a3120
    a604:	78257830 	.word	0x78257830
    a608:	6441202c 	.word	0x6441202c
    a60c:	73657264 	.word	0x73657264
    a610:	30203a73 	.word	0x30203a73
    a614:	0a782578 	.word	0x0a782578
    a618:	00000000 	.word	0x00000000
    a61c:	6265445b 	.word	0x6265445b
    a620:	205d6775 	.word	0x205d6775
    a624:	61746144 	.word	0x61746144
    a628:	61657220 	.word	0x61657220
    a62c:	72662064 	.word	0x72662064
    a630:	65206d6f 	.word	0x65206d6f
    a634:	6f727065 	.word	0x6f727065
    a638:	2031206d 	.word	0x2031206d
    a63c:	7852202d 	.word	0x7852202d
    a640:	66667542 	.word	0x66667542
    a644:	305b7265 	.word	0x305b7265
    a648:	30203a5d 	.word	0x30203a5d
    a64c:	0a782578 	.word	0x0a782578
    a650:	00000000 	.word	0x00000000
    a654:	6265445b 	.word	0x6265445b
    a658:	205d6775 	.word	0x205d6775
    a65c:	61746144 	.word	0x61746144
    a660:	61657220 	.word	0x61657220
    a664:	72662064 	.word	0x72662064
    a668:	65206d6f 	.word	0x65206d6f
    a66c:	6f727065 	.word	0x6f727065
    a670:	2031206d 	.word	0x2031206d
    a674:	7852202d 	.word	0x7852202d
    a678:	66667542 	.word	0x66667542
    a67c:	255b7265 	.word	0x255b7265
    a680:	203a5d64 	.word	0x203a5d64
    a684:	78257830 	.word	0x78257830
    a688:	0000000a 	.word	0x0000000a
    a68c:	6d726554 	.word	0x6d726554
    a690:	6c616e69 	.word	0x6c616e69
    a694:	00000000 	.word	0x00000000
    a698:	4c554e28 	.word	0x4c554e28
    a69c:	0000294c 	.word	0x0000294c

0000a6a0 <Clock_Ip_au8DividerCallbackIndex>:
    a6a0:	0e0d0c00 06030201 0a070409 000b0805     ................

0000a6b0 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

0000a6c0 <Clock_Ip_au8XoscCallbackIndex>:
    a6c0:	00000100 00000000 00000000 00000000     ................

0000a6d0 <Clock_Ip_au8IrcoscCallbackIndex>:
    a6d0:	03020100 00000004 00000000 00000000     ................

0000a6e0 <Clock_Ip_au8GateCallbackIndex>:
    a6e0:	06010200 01040301 00000500 00000000     ................

0000a6f0 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

0000a700 <Clock_Ip_au8PllCallbackIndex>:
    a700:	00000100 00000000 00000000 00000000     ................

0000a710 <Clock_Ip_au8SelectorCallbackIndex>:
    a710:	0a090800 03020109 07060504 00000000     ................

0000a720 <Clock_Ip_au8PcfsCallbackIndex>:
	...

0000a730 <Clock_Ip_au8CmuCallbackIndex>:
	...

0000a740 <Clock_Ip_au8ClockFeatures>:
	...
    a750:	01000000 00000000 00000000 00000002     ................
    a760:	00000000 00000300 00000000 00040000     ................
    a770:	00000000 05000000 00000000 00000000     ................
    a780:	00000006 00000000 00000100 00000000     ................
    a790:	00010000 00000000 04000000 00000000     ................
    a7a0:	00000000 00000005 00000001 00000401     ................
    a7b0:	00000200 00050100 00030000 04020000     ................
    a7c0:	04000000 02000000 00000005 00000005     ................
    a7d0:	00000403 00000600 00050300 00070000     ................
    a7e0:	05000000 00000000 00000000 00000006     ................
	...
    a820:	00050000 00000000 06000000 00000100     ................
    a830:	00000000 00030007 00000000 00000000     ................
    a840:	00000000 00060000 00000000 07000000     ................
    a850:	00000100 00000000 00030008 00000000     ................
	...
    a868:	00090000 00000000 0a000000 00000100     ................
    a878:	00000000 0003000b 00000000 00000000     ................
    a888:	00000000 000c0000 00000000 0d000000     ................
    a898:	00000100 00000000 0003000e 00000000     ................
    a8a8:	00000800 00000000 00090000 00000000     ................
    a8b8:	0a000000 00000000 00000000 0000000b     ................
    a8c8:	00000000 00000b01 00000000 000b0200     ................
    a8d8:	00000000 0b030000 00000000 00000000     ................
	...
    a8f0:	00000400 003b003b 00040000 27002700     ....;.;......'.'
    a900:	01000000 00000000 00000000 00000007     ................
    a910:	00007300 00000700 00320000 00090000     .s........2.....
    a920:	02000000 07000000 00000000 00000021     ............!...
    a930:	00000009 00000400 00000900 00030000     ................
    a940:	00070000 61000000 07000000 00000000     .......a........
    a950:	00000024 00000007 00002500 00000700     $........%......
    a960:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
    a970:	00000000 00000020 38000004 00003800     .... ......8.8..
    a980:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
    a990:	04000000 00260000 00000026 66000004     ......&.&......f
    a9a0:	00006600 00000400 00370037 00040000     .f......7.7.....
    a9b0:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
    a9c0:	2e000004 00002e00 00000200 00404040     ............@@@.
    a9d0:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
    a9e0:	0000006b 6c000004 00006c00 00000900     k......l.l......
    a9f0:	00010000 00090000 00000000 07000000     ................
    aa00:	00000000 00000036 00000007 00003100     ....6........1..
    aa10:	00000700 00490000 00070000 4a000000     ......I........J
    aa20:	07000000 00000000 0000004b 00000007     ........K.......
    aa30:	00004c00 00000700 004d0000 00070000     .L........M.....
    aa40:	3d000000 03000000 00000000 00000000     ...=............

0000aa50 <Clock_Ip_au16SelectorEntryHardwareValue>:
    aa50:	01010a03 01010001 04040002 02000603     ................
    aa60:	00010810 02020100 00000000 00000007     ................
    aa70:	00000009 00000000 00000c0e 00000000     ................
	...

0000aaa8 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    aaa8:	00020000 00000300 00000601 00000000     ................
	...

0000aad8 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    aad8:	00000700 00000000 02020000 01010303     ................
    aae8:	03020606 00000000 00000000 00000000     ................
	...

0000ab08 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    ab08:	00000001 00000000 02020000 01010303     ................
    ab18:	03020606 00000000 00000000 00000000     ................
	...

0000ab38 <Clock_Ip_au8DividerValueHardwareValue>:
    ab38:	00020100 00000003 00000004 00000000     ................
    ab48:	00000005 00000000 00000000 00000000     ................
    ab58:	00000006 00000000 00000000 00000000     ................
	...
    ab78:	00000007                                ....

0000ab7c <Clock_Ip_apxScgPeriphAsyncDivs>:
    ab7c:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

0000ab8c <Clock_Ip_aeSourceTypeClockName>:
    ab8c:	00000000 00000001 00000001 00000001     ................
    ab9c:	00000001 00000001 00000001 00000001     ................
    abac:	00000002 00000003 00000001 00000001     ................
    abbc:	00000001 00000001 00000002 00000002     ................
    abcc:	00000003 00000003 00000001 00000001     ................
    abdc:	00000004 00000004 00000004 00000004     ................
	...

0000ac48 <Clock_Ip_aeHwPllName>:
    ac48:	00000009                                ....

0000ac4c <Clock_Ip_aeHwDfsName>:
    ac4c:	00000057                                W...

0000ac50 <Clock_Ip_axDividerCallbacks>:
    ac50:	00002cd5 00002cdf 00002cf9 00002d13     .,...,...,...-..
    ac60:	00002d2d 00002d47 00002d61 00002d7b     --..G-..a-..{-..
    ac70:	00002d95 00002daf 00002dc9 00002de3     .-...-...-...-..
    ac80:	00002dfd 00002e17 00002e31              .-......1...

0000ac8c <Clock_Ip_axDividerTriggerCallbacks>:
    ac8c:	000031a5 000031a5                       .1...1..

0000ac94 <Clock_Ip_axExtOscCallbacks>:
    ac94:	000031b1 000031b1 000031b1 000031bb     .1...1...1...1..
    aca4:	000031b1 000031c5 000031df 000031f9     .1...1...1...1..
    acb4:	0000327d 00003291                       }2...2..

0000acbc <Clock_Ip_axFracDivCallbacks>:
    acbc:	00003451 00003451 0000345b              Q4..Q4..[4..

0000acc8 <Clock_Ip_axGateCallbacks>:
    acc8:	00003475 0000347f 0000357f 00003599     u4...4...5...5..
    acd8:	0000352f 00003549 000034df 000034f9     /5..I5...4...4..
    ace8:	0000348f 000034a9 000035cf 000035e9     .4...4...5...5..
    acf8:	0000361f 00003639                       .6..96..

0000ad00 <Clock_Ip_axIntOscCallbacks>:
    ad00:	000037e5 000037e5 000037ef 000037f9     .7...7...7...7..
    ad10:	00003813 0000382d 00003841 0000385b     .8..-8..A8..[8..
    ad20:	00003875 00003889 000038a3 000038bd     u8...8...8...8..
    ad30:	00003965 0000397f 00003999              e9...9...9..

0000ad3c <Clock_Ip_axCmuCallbacks>:
    ad3c:	00003f35 00003f3f 00003f4b 00003f35     5?..??..K?..5?..

0000ad4c <Clock_Ip_axPllCallbacks>:
    ad4c:	00003f55 00003f55 00003f5f 00003f55     U?..U?.._?..U?..
    ad5c:	00003f6b 00003f75 00003f8f 00003fa9     k?..u?...?...?..
    ad6c:	0000404d 00004039                       M@..9@..

0000ad74 <Clock_Ip_axPcfsCallbacks>:
    ad74:	000041a9                                .A..

0000ad78 <Clock_Ip_axSelectorCallbacks>:
    ad78:	000041b5 000041b5 000041bf 000041d9     .A...A...A...A..
    ad88:	000041b5 000041f3 0000420d 00004227     .A...A...B..'B..
    ad98:	00004241 0000425b 00004275 0000428f     AB..[B..uB...B..
    ada8:	000042a9 000042c3 000042dd 000042f7     .B...B...B...B..
    adb8:	00004311 0000432b 00004345 0000435f     .C..+C..EC.._C..
    adc8:	00004379 00004393                       yC...C..

0000add0 <ClockSource>:
    add0:	00000000 00000008 00000002 00000005     ................
	...
    ade8:	00000009                                ....

0000adec <ResetReasonArray>:
    adec:	00000000 00000001 00000002 00000003     ................
    adfc:	00000004 00000005 00000006 00000007     ................
    ae0c:	00000008 00000009 0000000a 0000000b     ................
    ae1c:	0000000c 0000000d 0000000e              ............

0000ae28 <Port_au32PortCiPortBaseAddr>:
    ae28:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
    ae38:	4004d000                                ...@

0000ae3c <Port_au32PortCiGpioBaseAddr>:
    ae3c:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
    ae4c:	400ff100                                ...@

0000ae50 <Lpspi_Ip_apxBases>:
    ae50:	4002c000 4002d000 4002e000              ...@...@...@

0000ae5c <Mcu_aClockConfigPB>:
	...
    ae64:	1c000101 04000010 01000029 00000005     ........).......
    ae74:	00000001 00000000 00000057 00000000     ........W.......
    ae84:	00000000 00000008 007a1200 00000001     ..........z.....
    ae94:	00000001 00000000 00000057 00000000     ........W.......
    aea4:	00000057 00000000 00000000 00000000     W...............
	...
    aec4:	00000019 00000005 0000001a 00000002     ................
    aed4:	0000001b 00000005 0000002a 00000005     ........*.......
    aee4:	00000028 0000000e 00000029 00000001     (.......).......
    aef4:	00000056 0000001c 00000032 0000002a     V.......2...*...
    af04:	0000002b 00000014 0000002c 00000014     +.......,.......
    af14:	0000002d 00000014 0000002e 00000014     -...............
    af24:	0000003f 00000000 00000040 00000000     ?.......@.......
    af34:	00000041 00000000 00000042 00000000     A.......B.......
    af44:	00000031 00000000 00000045 0000000d     1.......E.......
    af54:	00000046 00000000 00000047 00000000     F.......G.......
    af64:	00000044 00000000 00000030 00000000     D.......0.......
    af74:	0000003d 00000000 00000043 00000000     =.......C.......
    af84:	00000049 00000000 0000004a 00000000     I.......J.......
    af94:	0000004b 00000000 00000048 00000000     K.......H.......
    afa4:	0000000c 00000001 00000000 0000000d     ................
    afb4:	00000002 00000000 0000000e 00000001     ................
    afc4:	00000000 0000000f 00000001 00000000     ................
    afd4:	0000001d 00000001 00000000 0000001e     ................
    afe4:	00000008 00000000 0000001f 00000001     ................
    aff4:	00000000 00000021 00000001 00000000     ....!...........
    b004:	00000022 00000002 00000000 00000023     "...........#...
    b014:	00000001 00000000 00000025 00000003     ........%.......
    b024:	00000000 00000026 00000004 00000000     ....&...........
    b034:	00000027 00000002 00000000 00000032     '...........2...
    b044:	00000001 00000000 00000048 00000001     ........H.......
    b054:	00000001 00000056 00000001 00000001     ....V...........
    b064:	00000057 00000000 00000000 00000057     W...........W...
	...
    b07c:	00000057 00000000 00000000 00000057     W...........W...
	...
    b094:	00000057 00000000 00000057 00000057     W.......W...W...
	...
    b0b0:	00000014 00007d00 00000015 00007d00     .....}.......}..
    b0c0:	00000016 00007d00 00000017 00008000     .....}..........
    b0d0:	00000012 00000001 00000013 00000001     ................
    b0e0:	00000030 00000000 00000031 00000000     0.......1.......
    b0f0:	00000032 00000000 00000033 00000000     2.......3.......
    b100:	00000034 00000000 00000035 00000001     4.......5.......
    b110:	00000036 00000000 00000037 00000001     6.......7.......
    b120:	00000038 00000001 00000039 00000000     8.......9.......
    b130:	0000003a 00000000 0000003b 00000000     :.......;.......
    b140:	0000003c 00000000 0000003d 00000000     <.......=.......
    b150:	0000003e 00000000 0000003f 00000000     >.......?.......
    b160:	00000040 00000000 00000041 00000000     @.......A.......
    b170:	00000042 00000000 00000043 00000000     B.......C.......
    b180:	00000044 00000000 00000045 00000001     D.......E.......
    b190:	00000046 00000000 00000047 00000000     F.......G.......
    b1a0:	00000048 00000000 00000049 00000000     H.......I.......
    b1b0:	0000004a 00000000 0000004b 00000000     J.......K.......
    b1c0:	0000004c 00000001 0000004d 00000001     L.......M.......
    b1d0:	0000004e 00000000 0000004f 00000000     N.......O.......
    b1e0:	00000050 00000001 00000051 00000001     P.......Q.......
    b1f0:	00000052 00000001 00000053 00000001     R.......S.......
    b200:	00000054 00000001 00000055 00000000     T.......U.......
    b210:	00000056 00000001 00000057 00000000     V.......W.......
    b220:	00000000 00000057 00000000 00000057     ....W.......W...
	...

0000b254 <Lpspi_Ip_DeviceAttributes_SpiExternalDevice_0>:
    b254:	00000000 2f2f2e2e 00200000 1fff8b24     ......//.. .$...

0000b264 <Lpspi_Ip_DeviceAttributes_SpiExternalDevice_1>:
    b264:	00000000 2f2f2e2e 01200000 1fff8b2c     ......//.. .,...

0000b274 <Lpspi_Ip_PhyUnitConfig_SpiPhyUnit_0>:
	...
    b27c:	03000001 00000000 00000000              ............

0000b288 <Mcu_Config>:
    b288:	0000005a 00000000 00000001 00000001     Z...............
    b298:	0000b4e4 0000ae5c 0000b4f0              ....\.......

0000b2a4 <OsIf_xPredefinedConfig>:
    b2a4:	00000000 02dc6c00                       .....l..

0000b2ac <OsIf_apxPredefinedConfig>:
    b2ac:	0000b2a4                                ....

0000b2b0 <Platform_uConfiguration>:
    b2b0:	0000b2b8                                ....

0000b2b4 <Platform_Config>:
    b2b4:	0000b2b0                                ....

0000b2b8 <ipwConfig>:
	...

0000b2c0 <g_pin_mux_InitConfigArr>:
    b2c0:	4004a000 00000000 00000004 00000002     ...@............
    b2d0:	00000003 00000002 00000000 00000000     ................
	...
    b2e8:	4004a000 00000000 00000003 00000002     ...@............
    b2f8:	00000003 00000001 00000000 00000000     ................
	...
    b310:	4004a000 00000000 00000002 00000002     ...@............
    b320:	00000003 00000001 00000000 00000000     ................
	...
    b338:	4004a000 00000000 00000005 00000002     ...@............
    b348:	00000003 00000001 00000000 00000000     ................
	...
    b360:	4004a000 00000000 00000000 00000002     ...@............
    b370:	00000003 00000001 00000000 00000000     ................
	...

0000b388 <au8Port_PartitionList>:
    b388:	00000001                                ....

0000b38c <au32Port_PinToPartitionMap>:
    b38c:	00000001 00000001 00000001 00000001     ................
    b39c:	00000001                                ....

0000b3a0 <Port_au16NoUnUsedPadsArrayDefault>:
    b3a0:	00010000 00030002 00070006 00090008     ................
    b3b0:	000c000b 000e000d 0010000f 00210011     ..............!.
    b3c0:	00270026 00290028 002b002a 002d002c     &.'.(.).*.+.,.-.
    b3d0:	002f002e 00310030 00410040 00430042     ../.0.1.@.A.B.C.
    b3e0:	00470046 00490048 004b004a 004d004c     F.G.H.I.J.K.L.M.
    b3f0:	004f004e 00510050 00610060 00630062     N.O.P.Q.`.a.b.c.
    b400:	00650064 00670066 00690068 006b006a     d.e.f.g.h.i.j.k.
    b410:	006d006c 006f006e 00710070 00810080     l.m.n.o.p.q.....
    b420:	00830082 00850084 00870086 00890088     ................
    b430:	008b008a 008d008c 008f008e 00000090     ................

0000b440 <Port_UnUsedPin>:
    b440:	00000100 00000001 00000000              ............

0000b44c <Port_aPinConfigDefault>:
    b44c:	00000024 00000300 00000000 00000002     $...............
    b45c:	00010000 00000023 00000300 00000000     ....#...........
    b46c:	00000001 00010000 00000022 00000300     ........".......
    b47c:	00000000 00000001 00010000 00000025     ............%...
    b48c:	00000300 00000000 00000001 00010000     ................
    b49c:	00000020 00000300 00000000 00000001      ...............
    b4ac:	00010000                                ....

0000b4b0 <Port_Config>:
    b4b0:	004f0005 0000b3a0 0000b440 0000b44c     ..O.....@...L...
	...
    b4c8:	0000b38c 0000b388 0000b2c0              ............

0000b4d4 <Power_Ip_RCM_ConfigPB>:
	...

0000b4dc <Power_Ip_PMC_ConfigPB>:
    b4dc:	00000000                                ....

0000b4e0 <Power_Ip_SMC_ConfigPB>:
    b4e0:	00000000                                ....

0000b4e4 <Power_Ip_aModeConfigPB>:
	...

0000b4f0 <Power_Ip_HwIPsConfigPB>:
    b4f0:	0000b4d4 0000b4dc 0000b4e0              ............

0000b4fc <Spi_ExternalDeviceConfig_SpiExternalDevice_0>:
	...
    b504:	0000b254 00000000                       T.......

0000b50c <Spi_ExternalDeviceConfig_SpiExternalDevice_1>:
	...
    b514:	0000b264 00000000                       d.......

0000b51c <Spi_aExternalDeviceConfigList>:
    b51c:	0000b4fc 0000b50c                       ........

0000b524 <Spi_HwUnitConfig_SpiPhyUnit_0>:
	...
    b530:	0000b274 00000001                       t.......

0000b538 <Spi_aHwUnitConfigList>:
    b538:	0000b524                                $...

0000b53c <Spi_ChannelConfig_SpiChannel_Wren>:
    b53c:	00000001 00000008 00000001 00000004     ................
    b54c:	1fff8f10 00000000 1fff8d60              ........`...

0000b558 <Spi_ChannelConfig_SpiChannel_Cmd>:
    b558:	00000001 00000008 00000001 00000004     ................
    b568:	1fff8f1c 00000000 1fff8d64              ........d...

0000b574 <Spi_ChannelConfig_SpiChannel_Addr>:
    b574:	00000001 00000010 00000001 00000004     ................
    b584:	1fff8f28 00000000 1fff8d68              (.......h...

0000b590 <Spi_ChannelConfig_SpiChannel_Data>:
    b590:	00000001 00000008 00000001 00000004     ................
    b5a0:	1fff8f34 00000000 1fff8d6c              4.......l...

0000b5ac <Spi_aChannelConfigList>:
    b5ac:	0000b53c 0000b558 0000b574 0000b590     <...X...t.......

0000b5bc <Spi_SpiJob_Wren_ChannelAssignment>:
    b5bc:	00000000                                ....

0000b5c0 <Spi_SpiJob_Data_ChannelAssignment>:
    b5c0:	00030201                                ....

0000b5c4 <Spi_JobConfig_SpiJob_Wren>:
    b5c4:	00000001 0000b5bc 00000000 00000000     ................
	...
    b5dc:	1fff8d58 00000000 0000b51c              X...........

0000b5e8 <Spi_JobConfig_SpiJob_Data>:
    b5e8:	00000003 0000b5c0 00000000 00000000     ................
	...
    b600:	1fff8d5c 00000000 0000b51c              \...........

0000b60c <Spi_aJobConfigList>:
    b60c:	0000b5c4 0000b5e8                       ........

0000b614 <Spi_SpiSequence_Write_JobAssignment>:
    b614:	00010000                                ....

0000b618 <Spi_SpiSequence_Read_JobAssignment>:
    b618:	00000001                                ....

0000b61c <Spi_SequenceConfig_SpiSequence_Write>:
    b61c:	00000002 00000000 0000b614 00000000     ................
    b62c:	00000000                                ....

0000b630 <Spi_SequenceConfig_SpiSequence_Read>:
    b630:	00000001 00000000 0000b618 00000000     ................
    b640:	00000000                                ....

0000b644 <Spi_aSequenceConfigList>:
    b644:	0000b61c 0000b630                       ....0...

0000b64c <Spi_Config>:
    b64c:	00030002 00010001 00000000 0000b5ac     ................
    b65c:	0000b60c 0000b644 0000b51c 0000b538     ....D.......8...

0000b66c <_aInitStr.0>:
    b66c:	00000000 54540000 45522052 53454747     ......TTR REGGES
    b67c:	00000000                                ....

0000b680 <_aV2C.0>:
    b680:	33323130 37363534 42413938 46454443     0123456789ABCDEF

0000b690 <__INIT_TABLE>:
    b690:	00000002 	.word	0x00000002
    b694:	1fff8b10 	.word	0x1fff8b10
    b698:	0000b6b8 	.word	0x0000b6b8
    b69c:	0000b6dc 	.word	0x0000b6dc
    b6a0:	1fff8800 	.word	0x1fff8800
    b6a4:	00000000 	.word	0x00000000
    b6a8:	00000310 	.word	0x00000310

0000b6ac <__ZERO_TABLE>:
    b6ac:	00000001 	.word	0x00000001
    b6b0:	1fff8b40 	.word	0x1fff8b40
    b6b4:	1fff9400 	.word	0x1fff9400
