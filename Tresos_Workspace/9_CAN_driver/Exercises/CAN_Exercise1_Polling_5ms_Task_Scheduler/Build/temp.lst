
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000feb 	.word	0x00000feb
  10:	00000fed 	.word	0x00000fed
  14:	00000fef 	.word	0x00000fef
  18:	00000ff1 	.word	0x00000ff1
	...
  2c:	00000ff3 	.word	0x00000ff3
  30:	00000ff5 	.word	0x00000ff5
  34:	00000000 	.word	0x00000000
  38:	00000ff7 	.word	0x00000ff7
  3c:	00000ff9 	.word	0x00000ff9
  40:	00000ffb 	.word	0x00000ffb
  44:	00000ffb 	.word	0x00000ffb
  48:	00000ffb 	.word	0x00000ffb
  4c:	00000ffb 	.word	0x00000ffb
  50:	00000ffb 	.word	0x00000ffb
  54:	00000ffb 	.word	0x00000ffb
  58:	00000ffb 	.word	0x00000ffb
  5c:	00000ffb 	.word	0x00000ffb
  60:	00000ffb 	.word	0x00000ffb
  64:	00000ffb 	.word	0x00000ffb
  68:	00000ffb 	.word	0x00000ffb
  6c:	00000ffb 	.word	0x00000ffb
  70:	00000ffb 	.word	0x00000ffb
  74:	00000ffb 	.word	0x00000ffb
  78:	00000ffb 	.word	0x00000ffb
  7c:	00000ffb 	.word	0x00000ffb
  80:	00000ffb 	.word	0x00000ffb
  84:	00000ffb 	.word	0x00000ffb
  88:	00000ffb 	.word	0x00000ffb
  8c:	00000ffb 	.word	0x00000ffb
  90:	00000ffb 	.word	0x00000ffb
  94:	00000ffb 	.word	0x00000ffb
  98:	00000ffb 	.word	0x00000ffb
  9c:	00000ffb 	.word	0x00000ffb
  a0:	00000ffb 	.word	0x00000ffb
  a4:	00000ffb 	.word	0x00000ffb
  a8:	00000ffb 	.word	0x00000ffb
  ac:	00000ffb 	.word	0x00000ffb
  b0:	00000ffb 	.word	0x00000ffb
  b4:	00000ffb 	.word	0x00000ffb
  b8:	00000ffb 	.word	0x00000ffb
  bc:	00000ffb 	.word	0x00000ffb
  c0:	00000ffb 	.word	0x00000ffb
  c4:	00000ffb 	.word	0x00000ffb
  c8:	00000ffb 	.word	0x00000ffb
  cc:	00000ffb 	.word	0x00000ffb
  d0:	00000ffb 	.word	0x00000ffb
  d4:	00000ffb 	.word	0x00000ffb
  d8:	00000ffb 	.word	0x00000ffb
  dc:	00000ffb 	.word	0x00000ffb
  e0:	00000ffb 	.word	0x00000ffb
  e4:	00000ffb 	.word	0x00000ffb
  e8:	00000ffb 	.word	0x00000ffb
  ec:	00000ffb 	.word	0x00000ffb
  f0:	00000ffb 	.word	0x00000ffb
  f4:	00000ffb 	.word	0x00000ffb
  f8:	00000ffb 	.word	0x00000ffb
  fc:	00000ffb 	.word	0x00000ffb
 100:	00000ffb 	.word	0x00000ffb
 104:	00000ffb 	.word	0x00000ffb
 108:	00000ffb 	.word	0x00000ffb
 10c:	00000ffb 	.word	0x00000ffb
 110:	00000ffb 	.word	0x00000ffb
 114:	00000ffb 	.word	0x00000ffb
 118:	00000ffb 	.word	0x00000ffb
 11c:	00000ffb 	.word	0x00000ffb
 120:	00000ffb 	.word	0x00000ffb
 124:	00000ffb 	.word	0x00000ffb
 128:	00000ffb 	.word	0x00000ffb
 12c:	00000ffb 	.word	0x00000ffb
 130:	00000ffb 	.word	0x00000ffb
 134:	00000ffb 	.word	0x00000ffb
 138:	00000ffb 	.word	0x00000ffb
 13c:	00000ffb 	.word	0x00000ffb
 140:	00000ffb 	.word	0x00000ffb
 144:	00000ffb 	.word	0x00000ffb
 148:	00000ffb 	.word	0x00000ffb
 14c:	00000ffb 	.word	0x00000ffb
 150:	00000ffb 	.word	0x00000ffb
 154:	00000ffb 	.word	0x00000ffb
 158:	00000ffb 	.word	0x00000ffb
 15c:	00000ffb 	.word	0x00000ffb
 160:	00000ffb 	.word	0x00000ffb
 164:	00000ffb 	.word	0x00000ffb
 168:	00000ffb 	.word	0x00000ffb
 16c:	00000ffb 	.word	0x00000ffb
 170:	00000ffb 	.word	0x00000ffb
 174:	00000ffb 	.word	0x00000ffb
 178:	00000ffb 	.word	0x00000ffb
 17c:	00000ffb 	.word	0x00000ffb
 180:	00000ffb 	.word	0x00000ffb
 184:	00000ffb 	.word	0x00000ffb
 188:	00000ffb 	.word	0x00000ffb
 18c:	00000ffb 	.word	0x00000ffb
 190:	00000ffb 	.word	0x00000ffb
 194:	00000ffb 	.word	0x00000ffb
 198:	00000ffb 	.word	0x00000ffb
 19c:	00000ffb 	.word	0x00000ffb
 1a0:	00000ffb 	.word	0x00000ffb
 1a4:	00000ffb 	.word	0x00000ffb
 1a8:	00000ffb 	.word	0x00000ffb
 1ac:	00000ffb 	.word	0x00000ffb
 1b0:	00000ffb 	.word	0x00000ffb
 1b4:	00000ffb 	.word	0x00000ffb
 1b8:	00000ffb 	.word	0x00000ffb
 1bc:	00000ffb 	.word	0x00000ffb
 1c0:	00000ffb 	.word	0x00000ffb
 1c4:	00000ffb 	.word	0x00000ffb
 1c8:	00000ffb 	.word	0x00000ffb
 1cc:	00000ffb 	.word	0x00000ffb
 1d0:	00000ffb 	.word	0x00000ffb
 1d4:	00000ffb 	.word	0x00000ffb
 1d8:	00000ffb 	.word	0x00000ffb
 1dc:	00000ffb 	.word	0x00000ffb
 1e0:	00000ffb 	.word	0x00000ffb
 1e4:	00000ffb 	.word	0x00000ffb
 1e8:	00000ffb 	.word	0x00000ffb
 1ec:	00000ffb 	.word	0x00000ffb
 1f0:	00000ffb 	.word	0x00000ffb
 1f4:	00000ffb 	.word	0x00000ffb
 1f8:	00000ffb 	.word	0x00000ffb
 1fc:	00000ffb 	.word	0x00000ffb
 200:	00000ffb 	.word	0x00000ffb
 204:	00000ffb 	.word	0x00000ffb
 208:	00000ffb 	.word	0x00000ffb
 20c:	00000ffb 	.word	0x00000ffb
 210:	00000ffb 	.word	0x00000ffb
 214:	00000ffb 	.word	0x00000ffb
 218:	00000ffb 	.word	0x00000ffb
 21c:	00000ffb 	.word	0x00000ffb
 220:	00000ffb 	.word	0x00000ffb
 224:	00000ffb 	.word	0x00000ffb
 228:	00000ffb 	.word	0x00000ffb
 22c:	00000ffb 	.word	0x00000ffb
 230:	00000ffb 	.word	0x00000ffb
 234:	00000ffb 	.word	0x00000ffb
 238:	00000ffb 	.word	0x00000ffb
 23c:	00000ffb 	.word	0x00000ffb
 240:	00000ffb 	.word	0x00000ffb
 244:	00000ffb 	.word	0x00000ffb
 248:	00000ffb 	.word	0x00000ffb
 24c:	00000ffb 	.word	0x00000ffb
 250:	00000ffb 	.word	0x00000ffb
 254:	00000ffb 	.word	0x00000ffb
 258:	00000ffb 	.word	0x00000ffb
 25c:	00000ffb 	.word	0x00000ffb
 260:	00000ffb 	.word	0x00000ffb
 264:	00000ffb 	.word	0x00000ffb
 268:	00000ffb 	.word	0x00000ffb
 26c:	00000ffb 	.word	0x00000ffb
 270:	00000ffb 	.word	0x00000ffb
 274:	00000ffb 	.word	0x00000ffb
 278:	00000ffb 	.word	0x00000ffb
 27c:	00000ffb 	.word	0x00000ffb
 280:	00000ffb 	.word	0x00000ffb
 284:	00000ffb 	.word	0x00000ffb
 288:	00000ffb 	.word	0x00000ffb
 28c:	00000ffb 	.word	0x00000ffb
 290:	00000ffb 	.word	0x00000ffb
 294:	00000ffb 	.word	0x00000ffb
 298:	00000ffb 	.word	0x00000ffb
 29c:	00000ffb 	.word	0x00000ffb
 2a0:	00000ffb 	.word	0x00000ffb
 2a4:	00000ffb 	.word	0x00000ffb
 2a8:	00000ffb 	.word	0x00000ffb
 2ac:	00000ffb 	.word	0x00000ffb
 2b0:	00000ffb 	.word	0x00000ffb
 2b4:	00000ffb 	.word	0x00000ffb
 2b8:	00000ffb 	.word	0x00000ffb
 2bc:	00000ffb 	.word	0x00000ffb
 2c0:	00000ffb 	.word	0x00000ffb
 2c4:	00000ffb 	.word	0x00000ffb
 2c8:	00000ffb 	.word	0x00000ffb
 2cc:	00000ffb 	.word	0x00000ffb
 2d0:	00000ffb 	.word	0x00000ffb
 2d4:	00000ffb 	.word	0x00000ffb
 2d8:	00000ffb 	.word	0x00000ffb
 2dc:	00000ffb 	.word	0x00000ffb
 2e0:	00000ffb 	.word	0x00000ffb
 2e4:	00000ffb 	.word	0x00000ffb
 2e8:	00000ffb 	.word	0x00000ffb
 2ec:	00000ffb 	.word	0x00000ffb
 2f0:	00000ffb 	.word	0x00000ffb
 2f4:	00000ffb 	.word	0x00000ffb
 2f8:	00000ffb 	.word	0x00000ffb
 2fc:	00000ffb 	.word	0x00000ffb
 300:	00000ffb 	.word	0x00000ffb
 304:	00000ffb 	.word	0x00000ffb
 308:	00000ffb 	.word	0x00000ffb
 30c:	00000ffb 	.word	0x00000ffb

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fce9 	bl	e58 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fda8 	bl	fe0 <startup_go_to_user_mode>
     490:	f000 fa5c 	bl	94c <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff90c0 	.word	0x1fff90c0

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fcf3 	bl	f84 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <Delay>:
void Os_CanTask( void );

/*this is dummy delay function prepare just for this example, in a real application 
no delay shall be used*/
void Delay( uint32 ms )
{
     8b0:	b500      	push	{lr}
     8b2:	b087      	sub	sp, #28
     8b4:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
     8b6:	9b01      	ldr	r3, [sp, #4]
     8b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8bc:	fb02 f303 	mul.w	r3, r2, r3
     8c0:	2101      	movs	r1, #1
     8c2:	4618      	mov	r0, r3
     8c4:	f000 fc03 	bl	10ce <OsIf_MicrosToTicks>
     8c8:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
     8ca:	2001      	movs	r0, #1
     8cc:	f000 fbb3 	bl	1036 <OsIf_GetCounter>
     8d0:	4603      	mov	r3, r0
     8d2:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
     8d4:	2300      	movs	r3, #0
     8d6:	9305      	str	r3, [sp, #20]
    do{
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     8d8:	ab03      	add	r3, sp, #12
     8da:	2101      	movs	r1, #1
     8dc:	4618      	mov	r0, r3
     8de:	f000 fbc3 	bl	1068 <OsIf_GetElapsed>
     8e2:	4602      	mov	r2, r0
     8e4:	9b05      	ldr	r3, [sp, #20]
     8e6:	4413      	add	r3, r2
     8e8:	9305      	str	r3, [sp, #20]
    }
    while( ElapsedTime < Timeout );
     8ea:	9a05      	ldr	r2, [sp, #20]
     8ec:	9b04      	ldr	r3, [sp, #16]
     8ee:	429a      	cmp	r2, r3
     8f0:	d3f2      	bcc.n	8d8 <Delay+0x28>
}
     8f2:	bf00      	nop
     8f4:	bf00      	nop
     8f6:	b007      	add	sp, #28
     8f8:	f85d fb04 	ldr.w	pc, [sp], #4

000008fc <CanIf_ControllerBusOff>:

/*CanIf callback function implementation, just to avoid compiler errors
in reality this function is already implemented in CanIf layer*/
void CanIf_ControllerBusOff(uint8 ControllerId)
{
     8fc:	b082      	sub	sp, #8
     8fe:	4603      	mov	r3, r0
     900:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
}
     904:	bf00      	nop
     906:	b002      	add	sp, #8
     908:	4770      	bx	lr

0000090a <CanIf_ControllerModeIndication>:

/*CanIf callback function implementation, just to avoid compiler errors
in reality this function is already implemented in CanIf layer*/
void CanIf_ControllerModeIndication(uint8 ControllerId, Can_ControllerStateType ControllerMode )
{
     90a:	b082      	sub	sp, #8
     90c:	4603      	mov	r3, r0
     90e:	9100      	str	r1, [sp, #0]
     910:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
    (void)ControllerMode;
}
     914:	bf00      	nop
     916:	b002      	add	sp, #8
     918:	4770      	bx	lr
	...

0000091c <CanIf_TxConfirmation>:

/*CanIf callback function implementation to set the flag when a message is transmited
this function is called by the Can_43_FLEXCAN_MainFunction_Write function.
In reality this function is already implemented in CanIf layer*/
void CanIf_TxConfirmation( PduIdType CanTxPduId )
{
     91c:	b082      	sub	sp, #8
     91e:	4603      	mov	r3, r0
     920:	f8ad 3006 	strh.w	r3, [sp, #6]
    CanIf_bTxFlag = TRUE;
     924:	4b02      	ldr	r3, [pc, #8]	; (930 <CanIf_TxConfirmation+0x14>)
     926:	2201      	movs	r2, #1
     928:	701a      	strb	r2, [r3, #0]
    (void)CanTxPduId;
}
     92a:	bf00      	nop
     92c:	b002      	add	sp, #8
     92e:	4770      	bx	lr
     930:	1fff8b30 	.word	0x1fff8b30

00000934 <CanIf_RxIndication>:

/*CanIf callback function implementation to set the flag when a message is received
this function is called by the Can_43_FLEXCAN_MainFunction_Read function.
In reality this function is already implemented in CanIf layer*/
void CanIf_RxIndication(const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr )
{
     934:	b082      	sub	sp, #8
     936:	9001      	str	r0, [sp, #4]
     938:	9100      	str	r1, [sp, #0]
    CanIf_bRxFlag = TRUE;
     93a:	4b03      	ldr	r3, [pc, #12]	; (948 <CanIf_RxIndication+0x14>)
     93c:	2201      	movs	r2, #1
     93e:	701a      	strb	r2, [r3, #0]
    (void)Mailbox;
    /*the received message is store in PduInfoPtr->SduDataPtr*/
    (void)PduInfoPtr;
}
     940:	bf00      	nop
     942:	b002      	add	sp, #8
     944:	4770      	bx	lr
     946:	bf00      	nop
     948:	1fff8b31 	.word	0x1fff8b31

0000094c <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     94c:	b508      	push	{r3, lr}
    EcuM_Init();
     94e:	f000 f81d 	bl	98c <EcuM_Init>

    /* Init the scheduler with two tasks */
    Scheduler_Init( &Scheduler_Config );
     952:	480b      	ldr	r0, [pc, #44]	; (980 <main+0x34>)
     954:	f000 f8dc 	bl	b10 <Scheduler_Init>

    /*Start the CAN controller and make it active in the CAN bus network*/
    Can_43_FLEXCAN_SetControllerMode( CanController_0, CAN_CS_STARTED );
     958:	2101      	movs	r1, #1
     95a:	2000      	movs	r0, #0
     95c:	f004 fe56 	bl	560c <Can_43_FLEXCAN_SetControllerMode>

    /*Fill the structure with the information to be transmitted*/
    PduInfo.id = 0u;
     960:	4b08      	ldr	r3, [pc, #32]	; (984 <main+0x38>)
     962:	2200      	movs	r2, #0
     964:	601a      	str	r2, [r3, #0]
    PduInfo.swPduHandle = 0u;
     966:	4b07      	ldr	r3, [pc, #28]	; (984 <main+0x38>)
     968:	2200      	movs	r2, #0
     96a:	809a      	strh	r2, [r3, #4]
    PduInfo.length = 8u;
     96c:	4b05      	ldr	r3, [pc, #20]	; (984 <main+0x38>)
     96e:	2208      	movs	r2, #8
     970:	719a      	strb	r2, [r3, #6]
    PduInfo.sdu = Can_au8Sdu8bytes;
     972:	4b04      	ldr	r3, [pc, #16]	; (984 <main+0x38>)
     974:	4a04      	ldr	r2, [pc, #16]	; (988 <main+0x3c>)
     976:	609a      	str	r2, [r3, #8]

    while( 1u )
    {
        /* Run the scheduler forever */
        Scheduler_MainFunction( );
     978:	f000 f986 	bl	c88 <Scheduler_MainFunction>
     97c:	e7fc      	b.n	978 <main+0x2c>
     97e:	bf00      	nop
     980:	0000c71c 	.word	0x0000c71c
     984:	1fff8b34 	.word	0x1fff8b34
     988:	1fff8b10 	.word	0x1fff8b10

0000098c <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     98c:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );
     98e:	4808      	ldr	r0, [pc, #32]	; (9b0 <EcuM_Init+0x24>)
     990:	f004 f8de 	bl	4b50 <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     994:	2000      	movs	r0, #0
     996:	f004 f92f 	bl	4bf8 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     99a:	2000      	movs	r0, #0
     99c:	f004 f950 	bl	4c40 <Mcu_SetMode>
    /*Init the internal tick reference Systick Timer*/
    OsIf_Init( NULL_PTR );
     9a0:	2000      	movs	r0, #0
     9a2:	f000 fb3f 	bl	1024 <OsIf_Init>

    /*init the FlexCAN0 with the paramters set in Tresos in loop back mode*/
    Can_43_FLEXCAN_Init( &Can_43_FLEXCAN_Config );
     9a6:	4803      	ldr	r0, [pc, #12]	; (9b4 <EcuM_Init+0x28>)
     9a8:	f004 fdc2 	bl	5530 <Can_43_FLEXCAN_Init>
}
     9ac:	bf00      	nop
     9ae:	bd08      	pop	{r3, pc}
     9b0:	0000cc50 	.word	0x0000cc50
     9b4:	0000c7f0 	.word	0x0000c7f0

000009b8 <Os_50ms_Task>:
 * @brief This is the function for the 50ms task.
 *
 * This function prepares to transmit messages.
 */
void Os_50ms_Task( void )
{
     9b8:	b508      	push	{r3, lr}
    /* Set the FlexCAN peripheral to transmit the message, the message will be
    transmitted by the Can_43_FLEXCAN_MainFunction_Write */
    Can_43_FLEXCAN_Write( CanHardwareObject_1, &PduInfo );
     9ba:	4909      	ldr	r1, [pc, #36]	; (9e0 <Os_50ms_Task+0x28>)
     9bc:	2001      	movs	r0, #1
     9be:	f004 ffe7 	bl	5990 <Can_43_FLEXCAN_Write>

    /* Increase some values just for ilustration purposes */
    Can_au8Sdu8bytes[0]++;
     9c2:	4b08      	ldr	r3, [pc, #32]	; (9e4 <Os_50ms_Task+0x2c>)
     9c4:	781b      	ldrb	r3, [r3, #0]
     9c6:	3301      	adds	r3, #1
     9c8:	b2da      	uxtb	r2, r3
     9ca:	4b06      	ldr	r3, [pc, #24]	; (9e4 <Os_50ms_Task+0x2c>)
     9cc:	701a      	strb	r2, [r3, #0]
    Can_au8Sdu8bytes[7]++;
     9ce:	4b05      	ldr	r3, [pc, #20]	; (9e4 <Os_50ms_Task+0x2c>)
     9d0:	79db      	ldrb	r3, [r3, #7]
     9d2:	3301      	adds	r3, #1
     9d4:	b2da      	uxtb	r2, r3
     9d6:	4b03      	ldr	r3, [pc, #12]	; (9e4 <Os_50ms_Task+0x2c>)
     9d8:	71da      	strb	r2, [r3, #7]
}
     9da:	bf00      	nop
     9dc:	bd08      	pop	{r3, pc}
     9de:	bf00      	nop
     9e0:	1fff8b34 	.word	0x1fff8b34
     9e4:	1fff8b10 	.word	0x1fff8b10

000009e8 <Os_CanTask>:
 * @brief This is the function for the 5ms task.
 *
 * This function calls Can_43_FLEXCAN_MainFunction_Write() and Can_43_FLEXCAN_MainFunction_Read().
 */
void Os_CanTask( void )
{
     9e8:	b508      	push	{r3, lr}
    /* Transmit a single 8 byte message and wait until the message is transmited
    This is not the most suitable way, but good enough for ilustration
    purposes, flag is updated by the callback function CanIf_TxConfirmation */
    while( CanIf_bTxFlag == FALSE )
     9ea:	e001      	b.n	9f0 <Os_CanTask+0x8>
    {
        /* In polling mode we need to call this function with the periodicity
        we set on CanMainFunctionRWPeriods->CanMainFunctionPeriod = 5ms */
        Can_43_FLEXCAN_MainFunction_Write();
     9ec:	f005 f82a 	bl	5a44 <Can_43_FLEXCAN_MainFunction_Write>
    while( CanIf_bTxFlag == FALSE )
     9f0:	4b0d      	ldr	r3, [pc, #52]	; (a28 <Os_CanTask+0x40>)
     9f2:	781b      	ldrb	r3, [r3, #0]
     9f4:	f083 0301 	eor.w	r3, r3, #1
     9f8:	b2db      	uxtb	r3, r3
     9fa:	2b00      	cmp	r3, #0
     9fc:	d1f6      	bne.n	9ec <Os_CanTask+0x4>
    }
    /* Clear the Tx flag */
    CanIf_bTxFlag = FALSE;
     9fe:	4b0a      	ldr	r3, [pc, #40]	; (a28 <Os_CanTask+0x40>)
     a00:	2200      	movs	r2, #0
     a02:	701a      	strb	r2, [r3, #0]

    /* Wait here until the previous transmited message is received
    This is not the most suitable way, but good enough for ilustration
    purposes, flag is updated by the callback function CanIf_RxIndication */
    while( CanIf_bRxFlag == FALSE )
     a04:	e004      	b.n	a10 <Os_CanTask+0x28>
    {
        /* In polling mode we need to call this function with the periodicity
        we set on CanMainFunctionRWPeriods->CanMainFunctionPeriod = 5ms */
        Can_43_FLEXCAN_MainFunction_Read();
     a06:	f005 f885 	bl	5b14 <Can_43_FLEXCAN_MainFunction_Read>
        Delay( 1u );
     a0a:	2001      	movs	r0, #1
     a0c:	f7ff ff50 	bl	8b0 <Delay>
    while( CanIf_bRxFlag == FALSE )
     a10:	4b06      	ldr	r3, [pc, #24]	; (a2c <Os_CanTask+0x44>)
     a12:	781b      	ldrb	r3, [r3, #0]
     a14:	f083 0301 	eor.w	r3, r3, #1
     a18:	b2db      	uxtb	r3, r3
     a1a:	2b00      	cmp	r3, #0
     a1c:	d1f3      	bne.n	a06 <Os_CanTask+0x1e>
    }
    /* Clear the Tx flag */
    CanIf_bRxFlag = FALSE;
     a1e:	4b03      	ldr	r3, [pc, #12]	; (a2c <Os_CanTask+0x44>)
     a20:	2200      	movs	r2, #0
     a22:	701a      	strb	r2, [r3, #0]
}
     a24:	bf00      	nop
     a26:	bd08      	pop	{r3, pc}
     a28:	1fff8b30 	.word	0x1fff8b30
     a2c:	1fff8b31 	.word	0x1fff8b31

00000a30 <Can_43_FLEXCAN_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Can_43_FLEXCAN_schm_read_msr(void)
{
     a30:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     a32:	f3ef 8310 	mrs	r3, PRIMASK
     a36:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a38:	4623      	mov	r3, r4
}
     a3a:	4618      	mov	r0, r3
     a3c:	f85d 4b04 	ldr.w	r4, [sp], #4
     a40:	4770      	bx	lr

00000a42 <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     a42:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     a44:	f3ef 8310 	mrs	r3, PRIMASK
     a48:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a4a:	4623      	mov	r3, r4
}
     a4c:	4618      	mov	r0, r3
     a4e:	f85d 4b04 	ldr.w	r4, [sp], #4
     a52:	4770      	bx	lr

00000a54 <Bfx_SetBit_u32u8>:
 * @param[in]  BitPn Bit position
 *
 * @reqs    SWS_Bfx_00001, SWS_Bfx_00002, SWS_Bfx_00008
 */
void Bfx_SetBit_u32u8( uint32 *Data, uint8 BitPn )
{
     a54:	b082      	sub	sp, #8
     a56:	9001      	str	r0, [sp, #4]
     a58:	460b      	mov	r3, r1
     a5a:	f88d 3003 	strb.w	r3, [sp, #3]
    *Data |= ( 1u << BitPn );
     a5e:	9b01      	ldr	r3, [sp, #4]
     a60:	681a      	ldr	r2, [r3, #0]
     a62:	f89d 3003 	ldrb.w	r3, [sp, #3]
     a66:	2101      	movs	r1, #1
     a68:	fa01 f303 	lsl.w	r3, r1, r3
     a6c:	431a      	orrs	r2, r3
     a6e:	9b01      	ldr	r3, [sp, #4]
     a70:	601a      	str	r2, [r3, #0]
}
     a72:	bf00      	nop
     a74:	b002      	add	sp, #8
     a76:	4770      	bx	lr

00000a78 <Bfx_ClrBit_u32u8>:
 * @param[in]  BitPn Bit position
 *
 * @reqs    SWS_Bfx_00010, SWS_Bfx_00011, SWS_Bfx_00015
 */
void Bfx_ClrBit_u32u8( uint32 *Data, uint8 BitPn )
{
     a78:	b082      	sub	sp, #8
     a7a:	9001      	str	r0, [sp, #4]
     a7c:	460b      	mov	r3, r1
     a7e:	f88d 3003 	strb.w	r3, [sp, #3]
    *Data &= ~( 1u << BitPn );
     a82:	9b01      	ldr	r3, [sp, #4]
     a84:	681a      	ldr	r2, [r3, #0]
     a86:	f89d 3003 	ldrb.w	r3, [sp, #3]
     a8a:	2101      	movs	r1, #1
     a8c:	fa01 f303 	lsl.w	r3, r1, r3
     a90:	43db      	mvns	r3, r3
     a92:	401a      	ands	r2, r3
     a94:	9b01      	ldr	r3, [sp, #4]
     a96:	601a      	str	r2, [r3, #0]
}
     a98:	bf00      	nop
     a9a:	b002      	add	sp, #8
     a9c:	4770      	bx	lr

00000a9e <Bfx_GetBit_u32u8_u8>:
 * @retval Boolean Bit status
 *
 * @reqs    SWS_Bfx_00016, SWS_Bfx_00017, SWS_Bfx_00020
 */
boolean Bfx_GetBit_u32u8_u8( uint32 Data, uint8 BitPn )
{
     a9e:	b082      	sub	sp, #8
     aa0:	9001      	str	r0, [sp, #4]
     aa2:	460b      	mov	r3, r1
     aa4:	f88d 3003 	strb.w	r3, [sp, #3]
    return ( ( Data & ( 1u << BitPn ) ) != 0u );
     aa8:	f89d 3003 	ldrb.w	r3, [sp, #3]
     aac:	2201      	movs	r2, #1
     aae:	409a      	lsls	r2, r3
     ab0:	9b01      	ldr	r3, [sp, #4]
     ab2:	4013      	ands	r3, r2
     ab4:	2b00      	cmp	r3, #0
     ab6:	bf14      	ite	ne
     ab8:	2301      	movne	r3, #1
     aba:	2300      	moveq	r3, #0
     abc:	b2db      	uxtb	r3, r3
}
     abe:	4618      	mov	r0, r3
     ac0:	b002      	add	sp, #8
     ac2:	4770      	bx	lr

00000ac4 <Bfx_PutBit_u32u8u8>:
 * @param[in] Status Source data
 *
 * @reqs    SWS_Bfx_00130, SWS_Bfx_00132
 */
void Bfx_PutBit_u32u8u8( uint32 *Data, uint8 BitPn, boolean Status )
{
     ac4:	b082      	sub	sp, #8
     ac6:	9001      	str	r0, [sp, #4]
     ac8:	460b      	mov	r3, r1
     aca:	f88d 3003 	strb.w	r3, [sp, #3]
     ace:	4613      	mov	r3, r2
     ad0:	f88d 3002 	strb.w	r3, [sp, #2]
    if( Status == TRUE )
     ad4:	f89d 3002 	ldrb.w	r3, [sp, #2]
     ad8:	2b00      	cmp	r3, #0
     ada:	d00a      	beq.n	af2 <Bfx_PutBit_u32u8u8+0x2e>
    {
        *Data |= ( 1u << BitPn );
     adc:	9b01      	ldr	r3, [sp, #4]
     ade:	681a      	ldr	r2, [r3, #0]
     ae0:	f89d 3003 	ldrb.w	r3, [sp, #3]
     ae4:	2101      	movs	r1, #1
     ae6:	fa01 f303 	lsl.w	r3, r1, r3
     aea:	431a      	orrs	r2, r3
     aec:	9b01      	ldr	r3, [sp, #4]
     aee:	601a      	str	r2, [r3, #0]
    }
    else
    {
        *Data &= ~( 1u << BitPn );
    }
}
     af0:	e00a      	b.n	b08 <Bfx_PutBit_u32u8u8+0x44>
        *Data &= ~( 1u << BitPn );
     af2:	9b01      	ldr	r3, [sp, #4]
     af4:	681a      	ldr	r2, [r3, #0]
     af6:	f89d 3003 	ldrb.w	r3, [sp, #3]
     afa:	2101      	movs	r1, #1
     afc:	fa01 f303 	lsl.w	r3, r1, r3
     b00:	43db      	mvns	r3, r3
     b02:	401a      	ands	r2, r3
     b04:	9b01      	ldr	r3, [sp, #4]
     b06:	601a      	str	r2, [r3, #0]
}
     b08:	bf00      	nop
     b0a:	b002      	add	sp, #8
     b0c:	4770      	bx	lr
	...

00000b10 <Scheduler_Init>:
 * value for the arguments.
 *
 * @param   scheduler  Scheduler control structure
 */
void Scheduler_Init( const Scheduler_ConfigType *SchedulerPtr )
{
     b10:	b500      	push	{lr}
     b12:	b085      	sub	sp, #20
     b14:	9001      	str	r0, [sp, #4]
    SchedulerControl.TaskFlags = 0u;
     b16:	4b56      	ldr	r3, [pc, #344]	; (c70 <Scheduler_Init+0x160>)
     b18:	2200      	movs	r2, #0
     b1a:	641a      	str	r2, [r3, #64]	; 0x40
    SchedulerControl.TimerFlags = 0u;
     b1c:	4b54      	ldr	r3, [pc, #336]	; (c70 <Scheduler_Init+0x160>)
     b1e:	2200      	movs	r2, #0
     b20:	645a      	str	r2, [r3, #68]	; 0x44
    
    for( uint8 i = 0u; i < SchedulerPtr->Tasks; i++ )
     b22:	2300      	movs	r3, #0
     b24:	f88d 300f 	strb.w	r3, [sp, #15]
     b28:	e02f      	b.n	b8a <Scheduler_Init+0x7a>
    {
        SchedulerControl.TaskElapsed[ i ] = 0u;
     b2a:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b2e:	4a50      	ldr	r2, [pc, #320]	; (c70 <Scheduler_Init+0x160>)
     b30:	2100      	movs	r1, #0
     b32:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        SchedulerControl.TaskPeriod[ i ] = SchedulerPtr->TaskPtr[ i ].InitPeriod;
     b36:	9b01      	ldr	r3, [sp, #4]
     b38:	6899      	ldr	r1, [r3, #8]
     b3a:	f89d 200f 	ldrb.w	r2, [sp, #15]
     b3e:	4613      	mov	r3, r2
     b40:	005b      	lsls	r3, r3, #1
     b42:	4413      	add	r3, r2
     b44:	009b      	lsls	r3, r3, #2
     b46:	18ca      	adds	r2, r1, r3
     b48:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b4c:	6812      	ldr	r2, [r2, #0]
     b4e:	4948      	ldr	r1, [pc, #288]	; (c70 <Scheduler_Init+0x160>)
     b50:	3306      	adds	r3, #6
     b52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        Bfx_PutBit_u32u8u8( &SchedulerControl.TaskFlags, i, SchedulerPtr->TaskPtr[ i ].InitFlag );
     b56:	9b01      	ldr	r3, [sp, #4]
     b58:	6899      	ldr	r1, [r3, #8]
     b5a:	f89d 200f 	ldrb.w	r2, [sp, #15]
     b5e:	4613      	mov	r3, r2
     b60:	005b      	lsls	r3, r3, #1
     b62:	4413      	add	r3, r2
     b64:	009b      	lsls	r3, r3, #2
     b66:	440b      	add	r3, r1
     b68:	791b      	ldrb	r3, [r3, #4]
     b6a:	2b00      	cmp	r3, #0
     b6c:	bf14      	ite	ne
     b6e:	2301      	movne	r3, #1
     b70:	2300      	moveq	r3, #0
     b72:	b2da      	uxtb	r2, r3
     b74:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b78:	4619      	mov	r1, r3
     b7a:	483e      	ldr	r0, [pc, #248]	; (c74 <Scheduler_Init+0x164>)
     b7c:	f7ff ffa2 	bl	ac4 <Bfx_PutBit_u32u8u8>
    for( uint8 i = 0u; i < SchedulerPtr->Tasks; i++ )
     b80:	f89d 300f 	ldrb.w	r3, [sp, #15]
     b84:	3301      	adds	r3, #1
     b86:	f88d 300f 	strb.w	r3, [sp, #15]
     b8a:	9b01      	ldr	r3, [sp, #4]
     b8c:	791b      	ldrb	r3, [r3, #4]
     b8e:	f89d 200f 	ldrb.w	r2, [sp, #15]
     b92:	429a      	cmp	r2, r3
     b94:	d3c9      	bcc.n	b2a <Scheduler_Init+0x1a>
    }

    for( uint8 i = 0u; i < SchedulerPtr->Timers; i++ )
     b96:	2300      	movs	r3, #0
     b98:	f88d 300e 	strb.w	r3, [sp, #14]
     b9c:	e031      	b.n	c02 <Scheduler_Init+0xf2>
    {
        SchedulerControl.TimerCount[ i ] = 0u;
     b9e:	f89d 300e 	ldrb.w	r3, [sp, #14]
     ba2:	4a33      	ldr	r2, [pc, #204]	; (c70 <Scheduler_Init+0x160>)
     ba4:	330c      	adds	r3, #12
     ba6:	2100      	movs	r1, #0
     ba8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        SchedulerControl.TimerTimeout[ i ] = SchedulerPtr->TimerPtr[ i ].InitTimeout;
     bac:	9b01      	ldr	r3, [sp, #4]
     bae:	6919      	ldr	r1, [r3, #16]
     bb0:	f89d 200e 	ldrb.w	r2, [sp, #14]
     bb4:	4613      	mov	r3, r2
     bb6:	005b      	lsls	r3, r3, #1
     bb8:	4413      	add	r3, r2
     bba:	009b      	lsls	r3, r3, #2
     bbc:	18ca      	adds	r2, r1, r3
     bbe:	f89d 300e 	ldrb.w	r3, [sp, #14]
     bc2:	6812      	ldr	r2, [r2, #0]
     bc4:	492a      	ldr	r1, [pc, #168]	; (c70 <Scheduler_Init+0x160>)
     bc6:	330c      	adds	r3, #12
     bc8:	009b      	lsls	r3, r3, #2
     bca:	440b      	add	r3, r1
     bcc:	605a      	str	r2, [r3, #4]
        Bfx_PutBit_u32u8u8( &SchedulerControl.TimerFlags, i, SchedulerPtr->TimerPtr[ i ].InitFlag );
     bce:	9b01      	ldr	r3, [sp, #4]
     bd0:	6919      	ldr	r1, [r3, #16]
     bd2:	f89d 200e 	ldrb.w	r2, [sp, #14]
     bd6:	4613      	mov	r3, r2
     bd8:	005b      	lsls	r3, r3, #1
     bda:	4413      	add	r3, r2
     bdc:	009b      	lsls	r3, r3, #2
     bde:	440b      	add	r3, r1
     be0:	791b      	ldrb	r3, [r3, #4]
     be2:	2b00      	cmp	r3, #0
     be4:	bf14      	ite	ne
     be6:	2301      	movne	r3, #1
     be8:	2300      	moveq	r3, #0
     bea:	b2da      	uxtb	r2, r3
     bec:	f89d 300e 	ldrb.w	r3, [sp, #14]
     bf0:	4619      	mov	r1, r3
     bf2:	4821      	ldr	r0, [pc, #132]	; (c78 <Scheduler_Init+0x168>)
     bf4:	f7ff ff66 	bl	ac4 <Bfx_PutBit_u32u8u8>
    for( uint8 i = 0u; i < SchedulerPtr->Timers; i++ )
     bf8:	f89d 300e 	ldrb.w	r3, [sp, #14]
     bfc:	3301      	adds	r3, #1
     bfe:	f88d 300e 	strb.w	r3, [sp, #14]
     c02:	9b01      	ldr	r3, [sp, #4]
     c04:	7b1b      	ldrb	r3, [r3, #12]
     c06:	f89d 200e 	ldrb.w	r2, [sp, #14]
     c0a:	429a      	cmp	r2, r3
     c0c:	d3c7      	bcc.n	b9e <Scheduler_Init+0x8e>
    }

    for( uint8 i = 0u; i < SchedulerPtr->Queues; i++ )
     c0e:	2300      	movs	r3, #0
     c10:	f88d 300d 	strb.w	r3, [sp, #13]
     c14:	e01f      	b.n	c56 <Scheduler_Init+0x146>
    {
        SchedulerControl.QueueHeads[ i ] = 0u;
     c16:	f89d 300d 	ldrb.w	r3, [sp, #13]
     c1a:	4a15      	ldr	r2, [pc, #84]	; (c70 <Scheduler_Init+0x160>)
     c1c:	330e      	adds	r3, #14
     c1e:	2100      	movs	r1, #0
     c20:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        SchedulerControl.QueueTails[ i ] = 0u;
     c24:	f89d 300d 	ldrb.w	r3, [sp, #13]
     c28:	4a11      	ldr	r2, [pc, #68]	; (c70 <Scheduler_Init+0x160>)
     c2a:	330e      	adds	r3, #14
     c2c:	009b      	lsls	r3, r3, #2
     c2e:	4413      	add	r3, r2
     c30:	2200      	movs	r2, #0
     c32:	605a      	str	r2, [r3, #4]
        Bfx_SetBit_u32u8( &SchedulerControl.QueueEmpties, i );
     c34:	f89d 300d 	ldrb.w	r3, [sp, #13]
     c38:	4619      	mov	r1, r3
     c3a:	4810      	ldr	r0, [pc, #64]	; (c7c <Scheduler_Init+0x16c>)
     c3c:	f7ff ff0a 	bl	a54 <Bfx_SetBit_u32u8>
        Bfx_ClrBit_u32u8( &SchedulerControl.QueueFulls, i );
     c40:	f89d 300d 	ldrb.w	r3, [sp, #13]
     c44:	4619      	mov	r1, r3
     c46:	480e      	ldr	r0, [pc, #56]	; (c80 <Scheduler_Init+0x170>)
     c48:	f7ff ff16 	bl	a78 <Bfx_ClrBit_u32u8>
    for( uint8 i = 0u; i < SchedulerPtr->Queues; i++ )
     c4c:	f89d 300d 	ldrb.w	r3, [sp, #13]
     c50:	3301      	adds	r3, #1
     c52:	f88d 300d 	strb.w	r3, [sp, #13]
     c56:	9b01      	ldr	r3, [sp, #4]
     c58:	7d1b      	ldrb	r3, [r3, #20]
     c5a:	f89d 200d 	ldrb.w	r2, [sp, #13]
     c5e:	429a      	cmp	r2, r3
     c60:	d3d9      	bcc.n	c16 <Scheduler_Init+0x106>
    }
    
    SchedulerLocal = SchedulerPtr;
     c62:	4a08      	ldr	r2, [pc, #32]	; (c84 <Scheduler_Init+0x174>)
     c64:	9b01      	ldr	r3, [sp, #4]
     c66:	6013      	str	r3, [r2, #0]
}
     c68:	bf00      	nop
     c6a:	b005      	add	sp, #20
     c6c:	f85d fb04 	ldr.w	pc, [sp], #4
     c70:	1fff9070 	.word	0x1fff9070
     c74:	1fff90b0 	.word	0x1fff90b0
     c78:	1fff90b4 	.word	0x1fff90b4
     c7c:	1fff90b8 	.word	0x1fff90b8
     c80:	1fff90bc 	.word	0x1fff90bc
     c84:	1fff906c 	.word	0x1fff906c

00000c88 <Scheduler_MainFunction>:
 * if it is time to run accordingly to the period registered on each of them. The function won't return
 * by any means since it is looping inside a __while(1u)__ forever. The algorithm is pretty simple since
 * first task to dispatch will be the first registered in the **Scheduler_ConfigType** array
 */
void Scheduler_MainFunction( void )
{
     c88:	b500      	push	{lr}
     c8a:	b085      	sub	sp, #20
    uint32 Timeout = OsIf_MicrosToTicks( ( SchedulerLocal->Tick * 1000 ), OSIF_COUNTER_SYSTEM );
     c8c:	4b13      	ldr	r3, [pc, #76]	; (cdc <Scheduler_MainFunction+0x54>)
     c8e:	681b      	ldr	r3, [r3, #0]
     c90:	681b      	ldr	r3, [r3, #0]
     c92:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     c96:	fb02 f303 	mul.w	r3, r2, r3
     c9a:	2101      	movs	r1, #1
     c9c:	4618      	mov	r0, r3
     c9e:	f000 fa16 	bl	10ce <OsIf_MicrosToTicks>
     ca2:	9002      	str	r0, [sp, #8]
    /*get the Systic Timer count for the first time*/
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
     ca4:	2001      	movs	r0, #1
     ca6:	f000 f9c6 	bl	1036 <OsIf_GetCounter>
     caa:	4603      	mov	r3, r0
     cac:	9301      	str	r3, [sp, #4]
    /*We need to count the elapsed time from zero*/
    uint32 ElapsedTime = 0u;
     cae:	2300      	movs	r3, #0
     cb0:	9303      	str	r3, [sp, #12]
    
    do /* cppcheck-suppress misra-c2012-14.4 ; this is an infinite loop */
    {
        /* get the elapsed time count from the seed tick value*/
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     cb2:	ab01      	add	r3, sp, #4
     cb4:	2101      	movs	r1, #1
     cb6:	4618      	mov	r0, r3
     cb8:	f000 f9d6 	bl	1068 <OsIf_GetElapsed>
     cbc:	4602      	mov	r2, r0
     cbe:	9b03      	ldr	r3, [sp, #12]
     cc0:	4413      	add	r3, r2
     cc2:	9303      	str	r3, [sp, #12]
        /*query if the elapsed time is already equal or bigger than the timeout*/
        if( ElapsedTime >= Timeout )
     cc4:	9a03      	ldr	r2, [sp, #12]
     cc6:	9b02      	ldr	r3, [sp, #8]
     cc8:	429a      	cmp	r2, r3
     cca:	d3f2      	bcc.n	cb2 <Scheduler_MainFunction+0x2a>
        {
            /*reset the elapsed time */
            ElapsedTime = 0u;
     ccc:	2300      	movs	r3, #0
     cce:	9303      	str	r3, [sp, #12]
            /*Scan all registered timers*/
            Timers_Dispatch( );
     cd0:	f000 f85a 	bl	d88 <Timers_Dispatch>
            /*Scan all registered task*/
            Tasks_Dispatch( );
     cd4:	f000 f804 	bl	ce0 <Tasks_Dispatch>
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
     cd8:	e7eb      	b.n	cb2 <Scheduler_MainFunction+0x2a>
     cda:	bf00      	nop
     cdc:	1fff906c 	.word	0x1fff906c

00000ce0 <Tasks_Dispatch>:
 * This is the only mechanism to stop a timer. The function only set the flag startFlag to FALSE.
 *
 * @param   scheduler  Scheduler control structure
 */
STATIC void Tasks_Dispatch( void )
{
     ce0:	b500      	push	{lr}
     ce2:	b083      	sub	sp, #12
    /*Scan all registered task*/
    for( uint8 i = 0u; i < SchedulerLocal->Tasks; i++ )
     ce4:	2300      	movs	r3, #0
     ce6:	f88d 3007 	strb.w	r3, [sp, #7]
     cea:	e03c      	b.n	d66 <Tasks_Dispatch+0x86>
    {
        /*Only run those tasks that are started*/
        if( Bfx_GetBit_u32u8_u8( SchedulerControl.TaskFlags, i ) == TRUE )
     cec:	4b24      	ldr	r3, [pc, #144]	; (d80 <Tasks_Dispatch+0xa0>)
     cee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
     cf0:	f89d 2007 	ldrb.w	r2, [sp, #7]
     cf4:	4611      	mov	r1, r2
     cf6:	4618      	mov	r0, r3
     cf8:	f7ff fed1 	bl	a9e <Bfx_GetBit_u32u8_u8>
     cfc:	4603      	mov	r3, r0
     cfe:	2b00      	cmp	r3, #0
     d00:	d01e      	beq.n	d40 <Tasks_Dispatch+0x60>
        {
            /*Only run those tasks that already has its elapsed time*/
            if( SchedulerControl.TaskElapsed[ i ] >= SchedulerControl.TaskPeriod[ i ] )
     d02:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d06:	4a1e      	ldr	r2, [pc, #120]	; (d80 <Tasks_Dispatch+0xa0>)
     d08:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     d0c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d10:	491b      	ldr	r1, [pc, #108]	; (d80 <Tasks_Dispatch+0xa0>)
     d12:	3306      	adds	r3, #6
     d14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
     d18:	429a      	cmp	r2, r3
     d1a:	d311      	bcc.n	d40 <Tasks_Dispatch+0x60>
            {
                SchedulerControl.TaskElapsed[ i ] = 0u;
     d1c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d20:	4a17      	ldr	r2, [pc, #92]	; (d80 <Tasks_Dispatch+0xa0>)
     d22:	2100      	movs	r1, #0
     d24:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                /*Run task*/
                SchedulerLocal->TaskPtr[ i ].TaskFunc( );
     d28:	4b16      	ldr	r3, [pc, #88]	; (d84 <Tasks_Dispatch+0xa4>)
     d2a:	681b      	ldr	r3, [r3, #0]
     d2c:	6899      	ldr	r1, [r3, #8]
     d2e:	f89d 2007 	ldrb.w	r2, [sp, #7]
     d32:	4613      	mov	r3, r2
     d34:	005b      	lsls	r3, r3, #1
     d36:	4413      	add	r3, r2
     d38:	009b      	lsls	r3, r3, #2
     d3a:	440b      	add	r3, r1
     d3c:	689b      	ldr	r3, [r3, #8]
     d3e:	4798      	blx	r3
            }
        }
        /*Increment the task elapsed time in ticks*/
        SchedulerControl.TaskElapsed[ i ] += SchedulerLocal->Tick;
     d40:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d44:	4a0e      	ldr	r2, [pc, #56]	; (d80 <Tasks_Dispatch+0xa0>)
     d46:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
     d4a:	4b0e      	ldr	r3, [pc, #56]	; (d84 <Tasks_Dispatch+0xa4>)
     d4c:	681b      	ldr	r3, [r3, #0]
     d4e:	681a      	ldr	r2, [r3, #0]
     d50:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d54:	440a      	add	r2, r1
     d56:	490a      	ldr	r1, [pc, #40]	; (d80 <Tasks_Dispatch+0xa0>)
     d58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for( uint8 i = 0u; i < SchedulerLocal->Tasks; i++ )
     d5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d60:	3301      	adds	r3, #1
     d62:	f88d 3007 	strb.w	r3, [sp, #7]
     d66:	4b07      	ldr	r3, [pc, #28]	; (d84 <Tasks_Dispatch+0xa4>)
     d68:	681b      	ldr	r3, [r3, #0]
     d6a:	791b      	ldrb	r3, [r3, #4]
     d6c:	f89d 2007 	ldrb.w	r2, [sp, #7]
     d70:	429a      	cmp	r2, r3
     d72:	d3bb      	bcc.n	cec <Tasks_Dispatch+0xc>
    }
}
     d74:	bf00      	nop
     d76:	bf00      	nop
     d78:	b003      	add	sp, #12
     d7a:	f85d fb04 	ldr.w	pc, [sp], #4
     d7e:	bf00      	nop
     d80:	1fff9070 	.word	0x1fff9070
     d84:	1fff906c 	.word	0x1fff906c

00000d88 <Timers_Dispatch>:

STATIC void Timers_Dispatch( void )
{
     d88:	b500      	push	{lr}
     d8a:	b083      	sub	sp, #12
    /*Scan all registered timers*/
    for( uint8 i = 0u; i < SchedulerLocal->Timers; i++ )
     d8c:	2300      	movs	r3, #0
     d8e:	f88d 3007 	strb.w	r3, [sp, #7]
     d92:	e046      	b.n	e22 <Timers_Dispatch+0x9a>
    {
        /*Only run those timers that are started*/
        if( Bfx_GetBit_u32u8_u8( SchedulerControl.TimerFlags, i ) == TRUE )
     d94:	4b29      	ldr	r3, [pc, #164]	; (e3c <Timers_Dispatch+0xb4>)
     d96:	6c5b      	ldr	r3, [r3, #68]	; 0x44
     d98:	f89d 2007 	ldrb.w	r2, [sp, #7]
     d9c:	4611      	mov	r1, r2
     d9e:	4618      	mov	r0, r3
     da0:	f7ff fe7d 	bl	a9e <Bfx_GetBit_u32u8_u8>
     da4:	4603      	mov	r3, r0
     da6:	2b00      	cmp	r3, #0
     da8:	d036      	beq.n	e18 <Timers_Dispatch+0x90>
        {
            /*Decrement timer count by one tick*/
            SchedulerControl.TimerCount[ i ] -= SchedulerLocal->Tick;
     daa:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dae:	4a23      	ldr	r2, [pc, #140]	; (e3c <Timers_Dispatch+0xb4>)
     db0:	330c      	adds	r3, #12
     db2:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
     db6:	4b22      	ldr	r3, [pc, #136]	; (e40 <Timers_Dispatch+0xb8>)
     db8:	681b      	ldr	r3, [r3, #0]
     dba:	681a      	ldr	r2, [r3, #0]
     dbc:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dc0:	1a8a      	subs	r2, r1, r2
     dc2:	491e      	ldr	r1, [pc, #120]	; (e3c <Timers_Dispatch+0xb4>)
     dc4:	330c      	adds	r3, #12
     dc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            /*Only run those timers that already has its elapsed time*/
            if( SchedulerControl.TimerCount[ i ] == 0u )
     dca:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dce:	4a1b      	ldr	r2, [pc, #108]	; (e3c <Timers_Dispatch+0xb4>)
     dd0:	330c      	adds	r3, #12
     dd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     dd6:	2b00      	cmp	r3, #0
     dd8:	d11e      	bne.n	e18 <Timers_Dispatch+0x90>
            {
                /*Prevent timer from running again*/
                Bfx_ClrBit_u32u8( &SchedulerControl.TimerFlags, i );
     dda:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dde:	4619      	mov	r1, r3
     de0:	4818      	ldr	r0, [pc, #96]	; (e44 <Timers_Dispatch+0xbc>)
     de2:	f7ff fe49 	bl	a78 <Bfx_ClrBit_u32u8>
                /*Check if the timer has a callback assosiate*/
                if( SchedulerLocal->TimerPtr[ i ].CallbackFunc != NULL )
     de6:	4b16      	ldr	r3, [pc, #88]	; (e40 <Timers_Dispatch+0xb8>)
     de8:	681b      	ldr	r3, [r3, #0]
     dea:	6919      	ldr	r1, [r3, #16]
     dec:	f89d 2007 	ldrb.w	r2, [sp, #7]
     df0:	4613      	mov	r3, r2
     df2:	005b      	lsls	r3, r3, #1
     df4:	4413      	add	r3, r2
     df6:	009b      	lsls	r3, r3, #2
     df8:	440b      	add	r3, r1
     dfa:	689b      	ldr	r3, [r3, #8]
     dfc:	2b00      	cmp	r3, #0
     dfe:	d00b      	beq.n	e18 <Timers_Dispatch+0x90>
                {
                    /*Run callback*/
                    SchedulerLocal->TimerPtr[ i ].CallbackFunc( );
     e00:	4b0f      	ldr	r3, [pc, #60]	; (e40 <Timers_Dispatch+0xb8>)
     e02:	681b      	ldr	r3, [r3, #0]
     e04:	6919      	ldr	r1, [r3, #16]
     e06:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e0a:	4613      	mov	r3, r2
     e0c:	005b      	lsls	r3, r3, #1
     e0e:	4413      	add	r3, r2
     e10:	009b      	lsls	r3, r3, #2
     e12:	440b      	add	r3, r1
     e14:	689b      	ldr	r3, [r3, #8]
     e16:	4798      	blx	r3
    for( uint8 i = 0u; i < SchedulerLocal->Timers; i++ )
     e18:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e1c:	3301      	adds	r3, #1
     e1e:	f88d 3007 	strb.w	r3, [sp, #7]
     e22:	4b07      	ldr	r3, [pc, #28]	; (e40 <Timers_Dispatch+0xb8>)
     e24:	681b      	ldr	r3, [r3, #0]
     e26:	7b1b      	ldrb	r3, [r3, #12]
     e28:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e2c:	429a      	cmp	r2, r3
     e2e:	d3b1      	bcc.n	d94 <Timers_Dispatch+0xc>
                }
            }
        }
    }
}
     e30:	bf00      	nop
     e32:	bf00      	nop
     e34:	b003      	add	sp, #12
     e36:	f85d fb04 	ldr.w	pc, [sp], #4
     e3a:	bf00      	nop
     e3c:	1fff9070 	.word	0x1fff9070
     e40:	1fff906c 	.word	0x1fff906c
     e44:	1fff90b4 	.word	0x1fff90b4

00000e48 <Os_PotsTask>:
//void Os_50ms_Task( void );
void Os_100ms_Task( void );

void Os_LedsTask( void ){}
void Os_ButtonsTask( void ){}
void Os_PotsTask( void ){}
     e48:	bf00      	nop
     e4a:	4770      	bx	lr

00000e4c <Os_EepromsTask>:
void Os_EepromsTask( void ){}
     e4c:	bf00      	nop
     e4e:	4770      	bx	lr

00000e50 <Os_BuzzerTask>:
//void Os_CanTask( void ){}
void Os_BuzzerTask( void ){}
     e50:	bf00      	nop
     e52:	4770      	bx	lr

00000e54 <Os_100ms_Task>:
//void Os_50ms_Task( void ){}
void Os_100ms_Task( void ){}
     e54:	bf00      	nop
     e56:	4770      	bx	lr

00000e58 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     e58:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     e5a:	2300      	movs	r3, #0
     e5c:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     e5e:	2300      	movs	r3, #0
     e60:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     e62:	2300      	movs	r3, #0
     e64:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     e66:	2300      	movs	r3, #0
     e68:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     e6a:	4b44      	ldr	r3, [pc, #272]	; (f7c <init_data_bss+0x124>)
     e6c:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     e6e:	4b44      	ldr	r3, [pc, #272]	; (f80 <init_data_bss+0x128>)
     e70:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     e72:	9b05      	ldr	r3, [sp, #20]
     e74:	681b      	ldr	r3, [r3, #0]
     e76:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     e78:	9b05      	ldr	r3, [sp, #20]
     e7a:	3304      	adds	r3, #4
     e7c:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     e7e:	9b05      	ldr	r3, [sp, #20]
     e80:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     e82:	2300      	movs	r3, #0
     e84:	9309      	str	r3, [sp, #36]	; 0x24
     e86:	e03d      	b.n	f04 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     e88:	9a09      	ldr	r2, [sp, #36]	; 0x24
     e8a:	4613      	mov	r3, r2
     e8c:	005b      	lsls	r3, r3, #1
     e8e:	4413      	add	r3, r2
     e90:	009b      	lsls	r3, r3, #2
     e92:	461a      	mov	r2, r3
     e94:	9b03      	ldr	r3, [sp, #12]
     e96:	4413      	add	r3, r2
     e98:	685b      	ldr	r3, [r3, #4]
     e9a:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     e9c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     e9e:	4613      	mov	r3, r2
     ea0:	005b      	lsls	r3, r3, #1
     ea2:	4413      	add	r3, r2
     ea4:	009b      	lsls	r3, r3, #2
     ea6:	461a      	mov	r2, r3
     ea8:	9b03      	ldr	r3, [sp, #12]
     eaa:	4413      	add	r3, r2
     eac:	681b      	ldr	r3, [r3, #0]
     eae:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     eb0:	9a09      	ldr	r2, [sp, #36]	; 0x24
     eb2:	4613      	mov	r3, r2
     eb4:	005b      	lsls	r3, r3, #1
     eb6:	4413      	add	r3, r2
     eb8:	009b      	lsls	r3, r3, #2
     eba:	461a      	mov	r2, r3
     ebc:	9b03      	ldr	r3, [sp, #12]
     ebe:	4413      	add	r3, r2
     ec0:	689b      	ldr	r3, [r3, #8]
     ec2:	4619      	mov	r1, r3
     ec4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     ec6:	4613      	mov	r3, r2
     ec8:	005b      	lsls	r3, r3, #1
     eca:	4413      	add	r3, r2
     ecc:	009b      	lsls	r3, r3, #2
     ece:	461a      	mov	r2, r3
     ed0:	9b03      	ldr	r3, [sp, #12]
     ed2:	4413      	add	r3, r2
     ed4:	685b      	ldr	r3, [r3, #4]
     ed6:	1acb      	subs	r3, r1, r3
     ed8:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     eda:	2300      	movs	r3, #0
     edc:	9308      	str	r3, [sp, #32]
     ede:	e00a      	b.n	ef6 <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     ee0:	9a00      	ldr	r2, [sp, #0]
     ee2:	9b08      	ldr	r3, [sp, #32]
     ee4:	441a      	add	r2, r3
     ee6:	9901      	ldr	r1, [sp, #4]
     ee8:	9b08      	ldr	r3, [sp, #32]
     eea:	440b      	add	r3, r1
     eec:	7812      	ldrb	r2, [r2, #0]
     eee:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     ef0:	9b08      	ldr	r3, [sp, #32]
     ef2:	3301      	adds	r3, #1
     ef4:	9308      	str	r3, [sp, #32]
     ef6:	9a08      	ldr	r2, [sp, #32]
     ef8:	9b06      	ldr	r3, [sp, #24]
     efa:	429a      	cmp	r2, r3
     efc:	d3f0      	bcc.n	ee0 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     efe:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f00:	3301      	adds	r3, #1
     f02:	9309      	str	r3, [sp, #36]	; 0x24
     f04:	9a09      	ldr	r2, [sp, #36]	; 0x24
     f06:	9b07      	ldr	r3, [sp, #28]
     f08:	429a      	cmp	r2, r3
     f0a:	d3bd      	bcc.n	e88 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     f0c:	9b04      	ldr	r3, [sp, #16]
     f0e:	681b      	ldr	r3, [r3, #0]
     f10:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     f12:	9b04      	ldr	r3, [sp, #16]
     f14:	3304      	adds	r3, #4
     f16:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     f18:	9b04      	ldr	r3, [sp, #16]
     f1a:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     f1c:	2300      	movs	r3, #0
     f1e:	9309      	str	r3, [sp, #36]	; 0x24
     f20:	e024      	b.n	f6c <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     f22:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f24:	00db      	lsls	r3, r3, #3
     f26:	9a02      	ldr	r2, [sp, #8]
     f28:	4413      	add	r3, r2
     f2a:	681b      	ldr	r3, [r3, #0]
     f2c:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     f2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f30:	00db      	lsls	r3, r3, #3
     f32:	9a02      	ldr	r2, [sp, #8]
     f34:	4413      	add	r3, r2
     f36:	685b      	ldr	r3, [r3, #4]
     f38:	4619      	mov	r1, r3
     f3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f3c:	00db      	lsls	r3, r3, #3
     f3e:	9a02      	ldr	r2, [sp, #8]
     f40:	4413      	add	r3, r2
     f42:	681b      	ldr	r3, [r3, #0]
     f44:	1acb      	subs	r3, r1, r3
     f46:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     f48:	2300      	movs	r3, #0
     f4a:	9308      	str	r3, [sp, #32]
     f4c:	e007      	b.n	f5e <init_data_bss+0x106>
        {
            ram[j] = 0U;
     f4e:	9a01      	ldr	r2, [sp, #4]
     f50:	9b08      	ldr	r3, [sp, #32]
     f52:	4413      	add	r3, r2
     f54:	2200      	movs	r2, #0
     f56:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     f58:	9b08      	ldr	r3, [sp, #32]
     f5a:	3301      	adds	r3, #1
     f5c:	9308      	str	r3, [sp, #32]
     f5e:	9a08      	ldr	r2, [sp, #32]
     f60:	9b06      	ldr	r3, [sp, #24]
     f62:	429a      	cmp	r2, r3
     f64:	d3f3      	bcc.n	f4e <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     f66:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f68:	3301      	adds	r3, #1
     f6a:	9309      	str	r3, [sp, #36]	; 0x24
     f6c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     f6e:	9b07      	ldr	r3, [sp, #28]
     f70:	429a      	cmp	r2, r3
     f72:	d3d6      	bcc.n	f22 <init_data_bss+0xca>
        }
    }
}
     f74:	bf00      	nop
     f76:	bf00      	nop
     f78:	b00a      	add	sp, #40	; 0x28
     f7a:	4770      	bx	lr
     f7c:	0000cca0 	.word	0x0000cca0
     f80:	0000ccbc 	.word	0x0000ccbc

00000f84 <sys_m4_cache_init>:
{
     f84:	b084      	sub	sp, #16
     f86:	4603      	mov	r3, r0
     f88:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     f8c:	2300      	movs	r3, #0
     f8e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     f92:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f96:	2b00      	cmp	r3, #0
     f98:	d118      	bne.n	fcc <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     f9a:	4b10      	ldr	r3, [pc, #64]	; (fdc <sys_m4_cache_init+0x58>)
     f9c:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     fa0:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     fa2:	4b0e      	ldr	r3, [pc, #56]	; (fdc <sys_m4_cache_init+0x58>)
     fa4:	681b      	ldr	r3, [r3, #0]
     fa6:	4a0d      	ldr	r2, [pc, #52]	; (fdc <sys_m4_cache_init+0x58>)
     fa8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     fac:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     fae:	bf00      	nop
     fb0:	4b0a      	ldr	r3, [pc, #40]	; (fdc <sys_m4_cache_init+0x58>)
     fb2:	681b      	ldr	r3, [r3, #0]
     fb4:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     fb8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     fbc:	d0f8      	beq.n	fb0 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     fbe:	4b07      	ldr	r3, [pc, #28]	; (fdc <sys_m4_cache_init+0x58>)
     fc0:	681b      	ldr	r3, [r3, #0]
     fc2:	4a06      	ldr	r2, [pc, #24]	; (fdc <sys_m4_cache_init+0x58>)
     fc4:	f043 0301 	orr.w	r3, r3, #1
     fc8:	6013      	str	r3, [r2, #0]
     fca:	e002      	b.n	fd2 <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     fcc:	2301      	movs	r3, #1
     fce:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     fd2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     fd6:	4618      	mov	r0, r3
     fd8:	b004      	add	sp, #16
     fda:	4770      	bx	lr
     fdc:	e0082000 	.word	0xe0082000

00000fe0 <startup_go_to_user_mode>:
}
     fe0:	bf00      	nop
     fe2:	4770      	bx	lr

00000fe4 <Sys_GetCoreID>:
    return 0U;
     fe4:	2300      	movs	r3, #0
}
     fe6:	4618      	mov	r0, r3
     fe8:	4770      	bx	lr

00000fea <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     fea:	e7fe      	b.n	fea <HardFault_Handler>

00000fec <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     fec:	e7fe      	b.n	fec <MemManage_Handler>

00000fee <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     fee:	e7fe      	b.n	fee <BusFault_Handler>

00000ff0 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     ff0:	e7fe      	b.n	ff0 <UsageFault_Handler>

00000ff2 <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     ff2:	e7fe      	b.n	ff2 <SVC_Handler>

00000ff4 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     ff4:	e7fe      	b.n	ff4 <DebugMon_Handler>

00000ff6 <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     ff6:	e7fe      	b.n	ff6 <PendSV_Handler>

00000ff8 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     ff8:	e7fe      	b.n	ff8 <SysTick_Handler>

00000ffa <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     ffa:	e7fe      	b.n	ffa <undefined_handler>

00000ffc <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
     ffc:	2300      	movs	r3, #0
}
     ffe:	4618      	mov	r0, r3
    1000:	4770      	bx	lr

00001002 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    1002:	b082      	sub	sp, #8
    1004:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    1006:	2301      	movs	r3, #1
}
    1008:	4618      	mov	r0, r3
    100a:	b002      	add	sp, #8
    100c:	4770      	bx	lr

0000100e <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    100e:	b082      	sub	sp, #8
    1010:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    1012:	bf00      	nop
    1014:	b002      	add	sp, #8
    1016:	4770      	bx	lr

00001018 <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    1018:	b082      	sub	sp, #8
    101a:	9001      	str	r0, [sp, #4]
    return Micros;
    101c:	9b01      	ldr	r3, [sp, #4]
}
    101e:	4618      	mov	r0, r3
    1020:	b002      	add	sp, #8
    1022:	4770      	bx	lr

00001024 <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    1024:	b500      	push	{lr}
    1026:	b083      	sub	sp, #12
    1028:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    102a:	f000 f86d 	bl	1108 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    102e:	bf00      	nop
    1030:	b003      	add	sp, #12
    1032:	f85d fb04 	ldr.w	pc, [sp], #4

00001036 <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    1036:	b500      	push	{lr}
    1038:	b085      	sub	sp, #20
    103a:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    103c:	2300      	movs	r3, #0
    103e:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1040:	9b01      	ldr	r3, [sp, #4]
    1042:	2b00      	cmp	r3, #0
    1044:	d003      	beq.n	104e <OsIf_GetCounter+0x18>
    1046:	9b01      	ldr	r3, [sp, #4]
    1048:	2b01      	cmp	r3, #1
    104a:	d004      	beq.n	1056 <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    104c:	e007      	b.n	105e <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    104e:	f7ff ffd5 	bl	ffc <OsIf_Timer_Dummy_GetCounter>
    1052:	9003      	str	r0, [sp, #12]
            break;
    1054:	e003      	b.n	105e <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    1056:	f000 f873 	bl	1140 <OsIf_Timer_System_GetCounter>
    105a:	9003      	str	r0, [sp, #12]
            break;
    105c:	bf00      	nop
    }

    return Value;
    105e:	9b03      	ldr	r3, [sp, #12]
}
    1060:	4618      	mov	r0, r3
    1062:	b005      	add	sp, #20
    1064:	f85d fb04 	ldr.w	pc, [sp], #4

00001068 <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    1068:	b500      	push	{lr}
    106a:	b085      	sub	sp, #20
    106c:	9001      	str	r0, [sp, #4]
    106e:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1070:	2300      	movs	r3, #0
    1072:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1074:	9b00      	ldr	r3, [sp, #0]
    1076:	2b00      	cmp	r3, #0
    1078:	d003      	beq.n	1082 <OsIf_GetElapsed+0x1a>
    107a:	9b00      	ldr	r3, [sp, #0]
    107c:	2b01      	cmp	r3, #1
    107e:	d005      	beq.n	108c <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1080:	e009      	b.n	1096 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    1082:	9801      	ldr	r0, [sp, #4]
    1084:	f7ff ffbd 	bl	1002 <OsIf_Timer_Dummy_GetElapsed>
    1088:	9003      	str	r0, [sp, #12]
            break;
    108a:	e004      	b.n	1096 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    108c:	9801      	ldr	r0, [sp, #4]
    108e:	f000 f865 	bl	115c <OsIf_Timer_System_GetElapsed>
    1092:	9003      	str	r0, [sp, #12]
            break;
    1094:	bf00      	nop
    }

    return Value;
    1096:	9b03      	ldr	r3, [sp, #12]
}
    1098:	4618      	mov	r0, r3
    109a:	b005      	add	sp, #20
    109c:	f85d fb04 	ldr.w	pc, [sp], #4

000010a0 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    10a0:	b500      	push	{lr}
    10a2:	b083      	sub	sp, #12
    10a4:	9001      	str	r0, [sp, #4]
    10a6:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    10a8:	9b00      	ldr	r3, [sp, #0]
    10aa:	2b00      	cmp	r3, #0
    10ac:	d003      	beq.n	10b6 <OsIf_SetTimerFrequency+0x16>
    10ae:	9b00      	ldr	r3, [sp, #0]
    10b0:	2b01      	cmp	r3, #1
    10b2:	d004      	beq.n	10be <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    10b4:	e007      	b.n	10c6 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    10b6:	9801      	ldr	r0, [sp, #4]
    10b8:	f7ff ffa9 	bl	100e <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    10bc:	e003      	b.n	10c6 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    10be:	9801      	ldr	r0, [sp, #4]
    10c0:	f000 f85c 	bl	117c <OsIf_Timer_System_SetTimerFrequency>
            break;
    10c4:	bf00      	nop
    }
}
    10c6:	bf00      	nop
    10c8:	b003      	add	sp, #12
    10ca:	f85d fb04 	ldr.w	pc, [sp], #4

000010ce <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    10ce:	b500      	push	{lr}
    10d0:	b085      	sub	sp, #20
    10d2:	9001      	str	r0, [sp, #4]
    10d4:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    10d6:	2300      	movs	r3, #0
    10d8:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    10da:	9b00      	ldr	r3, [sp, #0]
    10dc:	2b00      	cmp	r3, #0
    10de:	d003      	beq.n	10e8 <OsIf_MicrosToTicks+0x1a>
    10e0:	9b00      	ldr	r3, [sp, #0]
    10e2:	2b01      	cmp	r3, #1
    10e4:	d005      	beq.n	10f2 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    10e6:	e009      	b.n	10fc <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    10e8:	9801      	ldr	r0, [sp, #4]
    10ea:	f7ff ff95 	bl	1018 <OsIf_Timer_Dummy_MicrosToTicks>
    10ee:	9003      	str	r0, [sp, #12]
            break;
    10f0:	e004      	b.n	10fc <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    10f2:	9801      	ldr	r0, [sp, #4]
    10f4:	f000 f850 	bl	1198 <OsIf_Timer_System_MicrosToTicks>
    10f8:	9003      	str	r0, [sp, #12]
            break;
    10fa:	bf00      	nop
    }

    return Value;
    10fc:	9b03      	ldr	r3, [sp, #12]
}
    10fe:	4618      	mov	r0, r3
    1100:	b005      	add	sp, #20
    1102:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001108 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    1108:	b500      	push	{lr}
    110a:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    110c:	2300      	movs	r3, #0
    110e:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    1110:	4a09      	ldr	r2, [pc, #36]	; (1138 <OsIf_Timer_System_Init+0x30>)
    1112:	9b01      	ldr	r3, [sp, #4]
    1114:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1118:	685a      	ldr	r2, [r3, #4]
    111a:	4908      	ldr	r1, [pc, #32]	; (113c <OsIf_Timer_System_Init+0x34>)
    111c:	9b01      	ldr	r3, [sp, #4]
    111e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    1122:	4a06      	ldr	r2, [pc, #24]	; (113c <OsIf_Timer_System_Init+0x34>)
    1124:	9b01      	ldr	r3, [sp, #4]
    1126:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    112a:	4618      	mov	r0, r3
    112c:	f000 f868 	bl	1200 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    1130:	bf00      	nop
    1132:	b003      	add	sp, #12
    1134:	f85d fb04 	ldr.w	pc, [sp], #4
    1138:	0000cc74 	.word	0x0000cc74
    113c:	1fff8b40 	.word	0x1fff8b40

00001140 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    1140:	b500      	push	{lr}
    1142:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    1144:	2300      	movs	r3, #0
    1146:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1148:	2300      	movs	r3, #0
    114a:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    114c:	f000 f86c 	bl	1228 <OsIf_Timer_System_Internal_GetCounter>
    1150:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    1152:	9b01      	ldr	r3, [sp, #4]
}
    1154:	4618      	mov	r0, r3
    1156:	b003      	add	sp, #12
    1158:	f85d fb04 	ldr.w	pc, [sp], #4

0000115c <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    115c:	b500      	push	{lr}
    115e:	b085      	sub	sp, #20
    1160:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    1162:	2300      	movs	r3, #0
    1164:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    1166:	2300      	movs	r3, #0
    1168:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    116a:	9801      	ldr	r0, [sp, #4]
    116c:	f000 f864 	bl	1238 <OsIf_Timer_System_Internal_GetElapsed>
    1170:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    1172:	9b03      	ldr	r3, [sp, #12]
}
    1174:	4618      	mov	r0, r3
    1176:	b005      	add	sp, #20
    1178:	f85d fb04 	ldr.w	pc, [sp], #4

0000117c <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    117c:	b084      	sub	sp, #16
    117e:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1180:	2300      	movs	r3, #0
    1182:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    1184:	4903      	ldr	r1, [pc, #12]	; (1194 <OsIf_Timer_System_SetTimerFrequency+0x18>)
    1186:	9b03      	ldr	r3, [sp, #12]
    1188:	9a01      	ldr	r2, [sp, #4]
    118a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    118e:	bf00      	nop
    1190:	b004      	add	sp, #16
    1192:	4770      	bx	lr
    1194:	1fff8b40 	.word	0x1fff8b40

00001198 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    1198:	b5f0      	push	{r4, r5, r6, r7, lr}
    119a:	b087      	sub	sp, #28
    119c:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    119e:	2100      	movs	r1, #0
    11a0:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    11a2:	2100      	movs	r1, #0
    11a4:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    11a6:	9901      	ldr	r1, [sp, #4]
    11a8:	2000      	movs	r0, #0
    11aa:	460e      	mov	r6, r1
    11ac:	4607      	mov	r7, r0
    11ae:	4812      	ldr	r0, [pc, #72]	; (11f8 <OsIf_Timer_System_MicrosToTicks+0x60>)
    11b0:	9904      	ldr	r1, [sp, #16]
    11b2:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    11b6:	2000      	movs	r0, #0
    11b8:	460c      	mov	r4, r1
    11ba:	4605      	mov	r5, r0
    11bc:	fb04 f007 	mul.w	r0, r4, r7
    11c0:	fb06 f105 	mul.w	r1, r6, r5
    11c4:	4401      	add	r1, r0
    11c6:	fba6 2304 	umull	r2, r3, r6, r4
    11ca:	4419      	add	r1, r3
    11cc:	460b      	mov	r3, r1
    11ce:	e9cd 2302 	strd	r2, r3, [sp, #8]
    11d2:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    11d6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    11da:	4a08      	ldr	r2, [pc, #32]	; (11fc <OsIf_Timer_System_MicrosToTicks+0x64>)
    11dc:	f04f 0300 	mov.w	r3, #0
    11e0:	f7ff f9e0 	bl	5a4 <__aeabi_uldivmod>
    11e4:	4602      	mov	r2, r0
    11e6:	460b      	mov	r3, r1
    11e8:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    11ec:	9b02      	ldr	r3, [sp, #8]
    11ee:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    11f0:	9b05      	ldr	r3, [sp, #20]
}
    11f2:	4618      	mov	r0, r3
    11f4:	b007      	add	sp, #28
    11f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    11f8:	1fff8b40 	.word	0x1fff8b40
    11fc:	000f4240 	.word	0x000f4240

00001200 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    1200:	b082      	sub	sp, #8
    1202:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    1204:	4b07      	ldr	r3, [pc, #28]	; (1224 <OsIf_Timer_System_Internal_Init+0x24>)
    1206:	2200      	movs	r2, #0
    1208:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    120a:	4b06      	ldr	r3, [pc, #24]	; (1224 <OsIf_Timer_System_Internal_Init+0x24>)
    120c:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    1210:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    1212:	4b04      	ldr	r3, [pc, #16]	; (1224 <OsIf_Timer_System_Internal_Init+0x24>)
    1214:	2200      	movs	r2, #0
    1216:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    1218:	4b02      	ldr	r3, [pc, #8]	; (1224 <OsIf_Timer_System_Internal_Init+0x24>)
    121a:	2205      	movs	r2, #5
    121c:	601a      	str	r2, [r3, #0]
}
    121e:	bf00      	nop
    1220:	b002      	add	sp, #8
    1222:	4770      	bx	lr
    1224:	e000e010 	.word	0xe000e010

00001228 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    1228:	4b02      	ldr	r3, [pc, #8]	; (1234 <OsIf_Timer_System_Internal_GetCounter+0xc>)
    122a:	689b      	ldr	r3, [r3, #8]
    122c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    1230:	4618      	mov	r0, r3
    1232:	4770      	bx	lr
    1234:	e000e010 	.word	0xe000e010

00001238 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    1238:	b084      	sub	sp, #16
    123a:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    123c:	4b10      	ldr	r3, [pc, #64]	; (1280 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    123e:	689b      	ldr	r3, [r3, #8]
    1240:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    1244:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    1246:	2300      	movs	r3, #0
    1248:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    124a:	9b01      	ldr	r3, [sp, #4]
    124c:	681b      	ldr	r3, [r3, #0]
    124e:	9a02      	ldr	r2, [sp, #8]
    1250:	429a      	cmp	r2, r3
    1252:	d909      	bls.n	1268 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    1254:	9b01      	ldr	r3, [sp, #4]
    1256:	681a      	ldr	r2, [r3, #0]
    1258:	9b02      	ldr	r3, [sp, #8]
    125a:	1ad3      	subs	r3, r2, r3
    125c:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    1260:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    1264:	9303      	str	r3, [sp, #12]
    1266:	e004      	b.n	1272 <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    1268:	9b01      	ldr	r3, [sp, #4]
    126a:	681a      	ldr	r2, [r3, #0]
    126c:	9b02      	ldr	r3, [sp, #8]
    126e:	1ad3      	subs	r3, r2, r3
    1270:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    1272:	9b01      	ldr	r3, [sp, #4]
    1274:	9a02      	ldr	r2, [sp, #8]
    1276:	601a      	str	r2, [r3, #0]

    return dif;
    1278:	9b03      	ldr	r3, [sp, #12]
}
    127a:	4618      	mov	r0, r3
    127c:	b004      	add	sp, #16
    127e:	4770      	bx	lr
    1280:	e000e010 	.word	0xe000e010

00001284 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    1284:	b082      	sub	sp, #8
    1286:	9001      	str	r0, [sp, #4]
    1288:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    128a:	bf00      	nop
    128c:	b002      	add	sp, #8
    128e:	4770      	bx	lr

00001290 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    1290:	b500      	push	{lr}
    1292:	b085      	sub	sp, #20
    1294:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    1296:	4b24      	ldr	r3, [pc, #144]	; (1328 <Clock_Ip_UpdateDriverContext+0x98>)
    1298:	2201      	movs	r2, #1
    129a:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    129c:	4b23      	ldr	r3, [pc, #140]	; (132c <Clock_Ip_UpdateDriverContext+0x9c>)
    129e:	681b      	ldr	r3, [r3, #0]
    12a0:	2102      	movs	r1, #2
    12a2:	4618      	mov	r0, r3
    12a4:	f003 fc32 	bl	4b0c <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    12a8:	2300      	movs	r3, #0
    12aa:	f88d 300f 	strb.w	r3, [sp, #15]
    12ae:	e015      	b.n	12dc <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    12b0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12b4:	9a01      	ldr	r2, [sp, #4]
    12b6:	334a      	adds	r3, #74	; 0x4a
    12b8:	00db      	lsls	r3, r3, #3
    12ba:	4413      	add	r3, r2
    12bc:	6858      	ldr	r0, [r3, #4]
    12be:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12c2:	9a01      	ldr	r2, [sp, #4]
    12c4:	334a      	adds	r3, #74	; 0x4a
    12c6:	00db      	lsls	r3, r3, #3
    12c8:	4413      	add	r3, r2
    12ca:	689b      	ldr	r3, [r3, #8]
    12cc:	4619      	mov	r1, r3
    12ce:	f001 fadc 	bl	288a <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    12d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    12d6:	3301      	adds	r3, #1
    12d8:	f88d 300f 	strb.w	r3, [sp, #15]
    12dc:	9b01      	ldr	r3, [sp, #4]
    12de:	7bdb      	ldrb	r3, [r3, #15]
    12e0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    12e4:	429a      	cmp	r2, r3
    12e6:	d3e3      	bcc.n	12b0 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    12e8:	f000 f824 	bl	1334 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    12ec:	2301      	movs	r3, #1
    12ee:	f88d 300f 	strb.w	r3, [sp, #15]
    12f2:	e00e      	b.n	1312 <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    12f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
    12f8:	9b01      	ldr	r3, [sp, #4]
    12fa:	327e      	adds	r2, #126	; 0x7e
    12fc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1300:	490b      	ldr	r1, [pc, #44]	; (1330 <Clock_Ip_UpdateDriverContext+0xa0>)
    1302:	f89d 200f 	ldrb.w	r2, [sp, #15]
    1306:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    1308:	f89d 300f 	ldrb.w	r3, [sp, #15]
    130c:	3301      	adds	r3, #1
    130e:	f88d 300f 	strb.w	r3, [sp, #15]
    1312:	9b01      	ldr	r3, [sp, #4]
    1314:	7cdb      	ldrb	r3, [r3, #19]
    1316:	f89d 200f 	ldrb.w	r2, [sp, #15]
    131a:	429a      	cmp	r2, r3
    131c:	d3ea      	bcc.n	12f4 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    131e:	bf00      	nop
    1320:	bf00      	nop
    1322:	b005      	add	sp, #20
    1324:	f85d fb04 	ldr.w	pc, [sp], #4
    1328:	1fff8b18 	.word	0x1fff8b18
    132c:	1fff8b44 	.word	0x1fff8b44
    1330:	1fff8b50 	.word	0x1fff8b50

00001334 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    1334:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    1336:	4b23      	ldr	r3, [pc, #140]	; (13c4 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1338:	781b      	ldrb	r3, [r3, #0]
    133a:	f083 0301 	eor.w	r3, r3, #1
    133e:	b2db      	uxtb	r3, r3
    1340:	2b00      	cmp	r3, #0
    1342:	d03d      	beq.n	13c0 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    1344:	4b1f      	ldr	r3, [pc, #124]	; (13c4 <Clock_Ip_CallEmptyCallbacks+0x90>)
    1346:	2201      	movs	r2, #1
    1348:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    134a:	4b1f      	ldr	r3, [pc, #124]	; (13c8 <Clock_Ip_CallEmptyCallbacks+0x94>)
    134c:	685b      	ldr	r3, [r3, #4]
    134e:	2100      	movs	r1, #0
    1350:	2000      	movs	r0, #0
    1352:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    1354:	4b1c      	ldr	r3, [pc, #112]	; (13c8 <Clock_Ip_CallEmptyCallbacks+0x94>)
    1356:	689b      	ldr	r3, [r3, #8]
    1358:	2057      	movs	r0, #87	; 0x57
    135a:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    135c:	4b1b      	ldr	r3, [pc, #108]	; (13cc <Clock_Ip_CallEmptyCallbacks+0x98>)
    135e:	681b      	ldr	r3, [r3, #0]
    1360:	2000      	movs	r0, #0
    1362:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    1364:	4b1a      	ldr	r3, [pc, #104]	; (13d0 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    1366:	681b      	ldr	r3, [r3, #0]
    1368:	2000      	movs	r0, #0
    136a:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    136c:	4b19      	ldr	r3, [pc, #100]	; (13d4 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    136e:	681b      	ldr	r3, [r3, #0]
    1370:	2000      	movs	r0, #0
    1372:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1374:	4b18      	ldr	r3, [pc, #96]	; (13d8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    1376:	685b      	ldr	r3, [r3, #4]
    1378:	2000      	movs	r0, #0
    137a:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    137c:	4b16      	ldr	r3, [pc, #88]	; (13d8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    137e:	689b      	ldr	r3, [r3, #8]
    1380:	2057      	movs	r0, #87	; 0x57
    1382:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1384:	4b15      	ldr	r3, [pc, #84]	; (13dc <Clock_Ip_CallEmptyCallbacks+0xa8>)
    1386:	681b      	ldr	r3, [r3, #0]
    1388:	2000      	movs	r0, #0
    138a:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    138c:	4b13      	ldr	r3, [pc, #76]	; (13dc <Clock_Ip_CallEmptyCallbacks+0xa8>)
    138e:	685b      	ldr	r3, [r3, #4]
    1390:	2100      	movs	r1, #0
    1392:	2057      	movs	r0, #87	; 0x57
    1394:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    1396:	4b12      	ldr	r3, [pc, #72]	; (13e0 <Clock_Ip_CallEmptyCallbacks+0xac>)
    1398:	681b      	ldr	r3, [r3, #0]
    139a:	2000      	movs	r0, #0
    139c:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    139e:	4b11      	ldr	r3, [pc, #68]	; (13e4 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    13a0:	685b      	ldr	r3, [r3, #4]
    13a2:	2000      	movs	r0, #0
    13a4:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    13a6:	4b0f      	ldr	r3, [pc, #60]	; (13e4 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    13a8:	689b      	ldr	r3, [r3, #8]
    13aa:	2057      	movs	r0, #87	; 0x57
    13ac:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    13ae:	4b0e      	ldr	r3, [pc, #56]	; (13e8 <Clock_Ip_CallEmptyCallbacks+0xb4>)
    13b0:	685b      	ldr	r3, [r3, #4]
    13b2:	2000      	movs	r0, #0
    13b4:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    13b6:	4b0d      	ldr	r3, [pc, #52]	; (13ec <Clock_Ip_CallEmptyCallbacks+0xb8>)
    13b8:	681b      	ldr	r3, [r3, #0]
    13ba:	2100      	movs	r1, #0
    13bc:	2000      	movs	r0, #0
    13be:	4798      	blx	r3
    }
}
    13c0:	bf00      	nop
    13c2:	bd08      	pop	{r3, pc}
    13c4:	1fff8b48 	.word	0x1fff8b48
    13c8:	0000c564 	.word	0x0000c564
    13cc:	0000c478 	.word	0x0000c478
    13d0:	0000c4b4 	.word	0x0000c4b4
    13d4:	0000c4bc 	.word	0x0000c4bc
    13d8:	0000c4e4 	.word	0x0000c4e4
    13dc:	0000c4f0 	.word	0x0000c4f0
    13e0:	0000c528 	.word	0x0000c528
    13e4:	0000c574 	.word	0x0000c574
    13e8:	0000c5a0 	.word	0x0000c5a0
    13ec:	0000c59c 	.word	0x0000c59c

000013f0 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    13f0:	b500      	push	{lr}
    13f2:	b085      	sub	sp, #20
    13f4:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    13f6:	9b01      	ldr	r3, [sp, #4]
    13f8:	7adb      	ldrb	r3, [r3, #11]
    13fa:	9303      	str	r3, [sp, #12]
    13fc:	e01f      	b.n	143e <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    13fe:	9b03      	ldr	r3, [sp, #12]
    1400:	1e5a      	subs	r2, r3, #1
    1402:	9b01      	ldr	r3, [sp, #4]
    1404:	320d      	adds	r2, #13
    1406:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    140a:	495a      	ldr	r1, [pc, #360]	; (1574 <Clock_Ip_ResetClockConfiguration+0x184>)
    140c:	4613      	mov	r3, r2
    140e:	00db      	lsls	r3, r3, #3
    1410:	4413      	add	r3, r2
    1412:	440b      	add	r3, r1
    1414:	3301      	adds	r3, #1
    1416:	781b      	ldrb	r3, [r3, #0]
    1418:	461a      	mov	r2, r3
    141a:	4b57      	ldr	r3, [pc, #348]	; (1578 <Clock_Ip_ResetClockConfiguration+0x188>)
    141c:	5c9b      	ldrb	r3, [r3, r2]
    141e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    1420:	4a56      	ldr	r2, [pc, #344]	; (157c <Clock_Ip_ResetClockConfiguration+0x18c>)
    1422:	9b02      	ldr	r3, [sp, #8]
    1424:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1428:	9a03      	ldr	r2, [sp, #12]
    142a:	3a01      	subs	r2, #1
    142c:	320d      	adds	r2, #13
    142e:	00d2      	lsls	r2, r2, #3
    1430:	9901      	ldr	r1, [sp, #4]
    1432:	440a      	add	r2, r1
    1434:	4610      	mov	r0, r2
    1436:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    1438:	9b03      	ldr	r3, [sp, #12]
    143a:	3b01      	subs	r3, #1
    143c:	9303      	str	r3, [sp, #12]
    143e:	9b03      	ldr	r3, [sp, #12]
    1440:	2b00      	cmp	r3, #0
    1442:	d1dc      	bne.n	13fe <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    1444:	9b01      	ldr	r3, [sp, #4]
    1446:	7b9b      	ldrb	r3, [r3, #14]
    1448:	9303      	str	r3, [sp, #12]
    144a:	e026      	b.n	149a <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    144c:	9b03      	ldr	r3, [sp, #12]
    144e:	3b01      	subs	r3, #1
    1450:	9a01      	ldr	r2, [sp, #4]
    1452:	3324      	adds	r3, #36	; 0x24
    1454:	011b      	lsls	r3, r3, #4
    1456:	4413      	add	r3, r2
    1458:	3304      	adds	r3, #4
    145a:	681a      	ldr	r2, [r3, #0]
    145c:	4945      	ldr	r1, [pc, #276]	; (1574 <Clock_Ip_ResetClockConfiguration+0x184>)
    145e:	4613      	mov	r3, r2
    1460:	00db      	lsls	r3, r3, #3
    1462:	4413      	add	r3, r2
    1464:	440b      	add	r3, r1
    1466:	3301      	adds	r3, #1
    1468:	781b      	ldrb	r3, [r3, #0]
    146a:	461a      	mov	r2, r3
    146c:	4b44      	ldr	r3, [pc, #272]	; (1580 <Clock_Ip_ResetClockConfiguration+0x190>)
    146e:	5c9b      	ldrb	r3, [r3, r2]
    1470:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    1472:	4944      	ldr	r1, [pc, #272]	; (1584 <Clock_Ip_ResetClockConfiguration+0x194>)
    1474:	9a02      	ldr	r2, [sp, #8]
    1476:	4613      	mov	r3, r2
    1478:	005b      	lsls	r3, r3, #1
    147a:	4413      	add	r3, r2
    147c:	009b      	lsls	r3, r3, #2
    147e:	440b      	add	r3, r1
    1480:	681b      	ldr	r3, [r3, #0]
    1482:	9a03      	ldr	r2, [sp, #12]
    1484:	3a01      	subs	r2, #1
    1486:	3224      	adds	r2, #36	; 0x24
    1488:	0112      	lsls	r2, r2, #4
    148a:	9901      	ldr	r1, [sp, #4]
    148c:	440a      	add	r2, r1
    148e:	3204      	adds	r2, #4
    1490:	4610      	mov	r0, r2
    1492:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    1494:	9b03      	ldr	r3, [sp, #12]
    1496:	3b01      	subs	r3, #1
    1498:	9303      	str	r3, [sp, #12]
    149a:	9b03      	ldr	r3, [sp, #12]
    149c:	2b00      	cmp	r3, #0
    149e:	d1d5      	bne.n	144c <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    14a0:	9b01      	ldr	r3, [sp, #4]
    14a2:	7a9b      	ldrb	r3, [r3, #10]
    14a4:	9303      	str	r3, [sp, #12]
    14a6:	e02a      	b.n	14fe <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    14a8:	9b03      	ldr	r3, [sp, #12]
    14aa:	1e5a      	subs	r2, r3, #1
    14ac:	9901      	ldr	r1, [sp, #4]
    14ae:	4613      	mov	r3, r2
    14b0:	009b      	lsls	r3, r3, #2
    14b2:	4413      	add	r3, r2
    14b4:	00db      	lsls	r3, r3, #3
    14b6:	440b      	add	r3, r1
    14b8:	3340      	adds	r3, #64	; 0x40
    14ba:	681a      	ldr	r2, [r3, #0]
    14bc:	492d      	ldr	r1, [pc, #180]	; (1574 <Clock_Ip_ResetClockConfiguration+0x184>)
    14be:	4613      	mov	r3, r2
    14c0:	00db      	lsls	r3, r3, #3
    14c2:	4413      	add	r3, r2
    14c4:	440b      	add	r3, r1
    14c6:	3301      	adds	r3, #1
    14c8:	781b      	ldrb	r3, [r3, #0]
    14ca:	461a      	mov	r2, r3
    14cc:	4b2e      	ldr	r3, [pc, #184]	; (1588 <Clock_Ip_ResetClockConfiguration+0x198>)
    14ce:	5c9b      	ldrb	r3, [r3, r2]
    14d0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    14d2:	492e      	ldr	r1, [pc, #184]	; (158c <Clock_Ip_ResetClockConfiguration+0x19c>)
    14d4:	9a02      	ldr	r2, [sp, #8]
    14d6:	4613      	mov	r3, r2
    14d8:	009b      	lsls	r3, r3, #2
    14da:	4413      	add	r3, r2
    14dc:	009b      	lsls	r3, r3, #2
    14de:	440b      	add	r3, r1
    14e0:	6819      	ldr	r1, [r3, #0]
    14e2:	9b03      	ldr	r3, [sp, #12]
    14e4:	1e5a      	subs	r2, r3, #1
    14e6:	4613      	mov	r3, r2
    14e8:	009b      	lsls	r3, r3, #2
    14ea:	4413      	add	r3, r2
    14ec:	00db      	lsls	r3, r3, #3
    14ee:	3340      	adds	r3, #64	; 0x40
    14f0:	9a01      	ldr	r2, [sp, #4]
    14f2:	4413      	add	r3, r2
    14f4:	4618      	mov	r0, r3
    14f6:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    14f8:	9b03      	ldr	r3, [sp, #12]
    14fa:	3b01      	subs	r3, #1
    14fc:	9303      	str	r3, [sp, #12]
    14fe:	9b03      	ldr	r3, [sp, #12]
    1500:	2b00      	cmp	r3, #0
    1502:	d1d1      	bne.n	14a8 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    1504:	9b01      	ldr	r3, [sp, #4]
    1506:	7a5b      	ldrb	r3, [r3, #9]
    1508:	9303      	str	r3, [sp, #12]
    150a:	e02b      	b.n	1564 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    150c:	9b03      	ldr	r3, [sp, #12]
    150e:	1e5a      	subs	r2, r3, #1
    1510:	9901      	ldr	r1, [sp, #4]
    1512:	4613      	mov	r3, r2
    1514:	009b      	lsls	r3, r3, #2
    1516:	4413      	add	r3, r2
    1518:	009b      	lsls	r3, r3, #2
    151a:	440b      	add	r3, r1
    151c:	332c      	adds	r3, #44	; 0x2c
    151e:	681a      	ldr	r2, [r3, #0]
    1520:	4914      	ldr	r1, [pc, #80]	; (1574 <Clock_Ip_ResetClockConfiguration+0x184>)
    1522:	4613      	mov	r3, r2
    1524:	00db      	lsls	r3, r3, #3
    1526:	4413      	add	r3, r2
    1528:	440b      	add	r3, r1
    152a:	3301      	adds	r3, #1
    152c:	781b      	ldrb	r3, [r3, #0]
    152e:	461a      	mov	r2, r3
    1530:	4b17      	ldr	r3, [pc, #92]	; (1590 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    1532:	5c9b      	ldrb	r3, [r3, r2]
    1534:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    1536:	4917      	ldr	r1, [pc, #92]	; (1594 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    1538:	9a02      	ldr	r2, [sp, #8]
    153a:	4613      	mov	r3, r2
    153c:	009b      	lsls	r3, r3, #2
    153e:	4413      	add	r3, r2
    1540:	009b      	lsls	r3, r3, #2
    1542:	440b      	add	r3, r1
    1544:	6819      	ldr	r1, [r3, #0]
    1546:	9b03      	ldr	r3, [sp, #12]
    1548:	1e5a      	subs	r2, r3, #1
    154a:	4613      	mov	r3, r2
    154c:	009b      	lsls	r3, r3, #2
    154e:	4413      	add	r3, r2
    1550:	009b      	lsls	r3, r3, #2
    1552:	3328      	adds	r3, #40	; 0x28
    1554:	9a01      	ldr	r2, [sp, #4]
    1556:	4413      	add	r3, r2
    1558:	3304      	adds	r3, #4
    155a:	4618      	mov	r0, r3
    155c:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    155e:	9b03      	ldr	r3, [sp, #12]
    1560:	3b01      	subs	r3, #1
    1562:	9303      	str	r3, [sp, #12]
    1564:	9b03      	ldr	r3, [sp, #12]
    1566:	2b00      	cmp	r3, #0
    1568:	d1d0      	bne.n	150c <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    156a:	bf00      	nop
    156c:	bf00      	nop
    156e:	b005      	add	sp, #20
    1570:	f85d fb04 	ldr.w	pc, [sp], #4
    1574:	0000bf68 	.word	0x0000bf68
    1578:	0000bf38 	.word	0x0000bf38
    157c:	0000c5a0 	.word	0x0000c5a0
    1580:	0000bf18 	.word	0x0000bf18
    1584:	0000c4e4 	.word	0x0000c4e4
    1588:	0000bf28 	.word	0x0000bf28
    158c:	0000c574 	.word	0x0000c574
    1590:	0000bee8 	.word	0x0000bee8
    1594:	0000c4bc 	.word	0x0000c4bc

00001598 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    1598:	b500      	push	{lr}
    159a:	b085      	sub	sp, #20
    159c:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    159e:	2301      	movs	r3, #1
    15a0:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    15a2:	9801      	ldr	r0, [sp, #4]
    15a4:	f000 f818 	bl	15d8 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    15a8:	4b0a      	ldr	r3, [pc, #40]	; (15d4 <Clock_Ip_Init+0x3c>)
    15aa:	781b      	ldrb	r3, [r3, #0]
    15ac:	2b00      	cmp	r3, #0
    15ae:	d00a      	beq.n	15c6 <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    15b0:	f000 fb74 	bl	1c9c <Clock_Ip_GetPllStatus>
    15b4:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    15b6:	9b02      	ldr	r3, [sp, #8]
    15b8:	2b00      	cmp	r3, #0
    15ba:	d106      	bne.n	15ca <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    15bc:	f000 fbf2 	bl	1da4 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    15c0:	2300      	movs	r3, #0
    15c2:	9303      	str	r3, [sp, #12]
    15c4:	e001      	b.n	15ca <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    15c6:	2300      	movs	r3, #0
    15c8:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    15ca:	9b03      	ldr	r3, [sp, #12]
}
    15cc:	4618      	mov	r0, r3
    15ce:	b005      	add	sp, #20
    15d0:	f85d fb04 	ldr.w	pc, [sp], #4
    15d4:	1fff8b4c 	.word	0x1fff8b4c

000015d8 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    15d8:	b510      	push	{r4, lr}
    15da:	b084      	sub	sp, #16
    15dc:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    15de:	4a9f      	ldr	r2, [pc, #636]	; (185c <Clock_Ip_InitClock+0x284>)
    15e0:	9b01      	ldr	r3, [sp, #4]
    15e2:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    15e4:	2101      	movs	r1, #1
    15e6:	9801      	ldr	r0, [sp, #4]
    15e8:	f003 fa90 	bl	4b0c <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    15ec:	4b9b      	ldr	r3, [pc, #620]	; (185c <Clock_Ip_InitClock+0x284>)
    15ee:	681b      	ldr	r3, [r3, #0]
    15f0:	2b00      	cmp	r3, #0
    15f2:	d030      	beq.n	1656 <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    15f4:	2300      	movs	r3, #0
    15f6:	9303      	str	r3, [sp, #12]
    15f8:	e027      	b.n	164a <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    15fa:	9901      	ldr	r1, [sp, #4]
    15fc:	9a03      	ldr	r2, [sp, #12]
    15fe:	4613      	mov	r3, r2
    1600:	009b      	lsls	r3, r3, #2
    1602:	4413      	add	r3, r2
    1604:	009b      	lsls	r3, r3, #2
    1606:	440b      	add	r3, r1
    1608:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    160c:	681a      	ldr	r2, [r3, #0]
    160e:	4994      	ldr	r1, [pc, #592]	; (1860 <Clock_Ip_InitClock+0x288>)
    1610:	4613      	mov	r3, r2
    1612:	00db      	lsls	r3, r3, #3
    1614:	4413      	add	r3, r2
    1616:	440b      	add	r3, r1
    1618:	3301      	adds	r3, #1
    161a:	781b      	ldrb	r3, [r3, #0]
    161c:	461a      	mov	r2, r3
    161e:	4b91      	ldr	r3, [pc, #580]	; (1864 <Clock_Ip_InitClock+0x28c>)
    1620:	5c9b      	ldrb	r3, [r3, r2]
    1622:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    1624:	4a90      	ldr	r2, [pc, #576]	; (1868 <Clock_Ip_InitClock+0x290>)
    1626:	9b02      	ldr	r3, [sp, #8]
    1628:	011b      	lsls	r3, r3, #4
    162a:	4413      	add	r3, r2
    162c:	6819      	ldr	r1, [r3, #0]
    162e:	9a03      	ldr	r2, [sp, #12]
    1630:	4613      	mov	r3, r2
    1632:	009b      	lsls	r3, r3, #2
    1634:	4413      	add	r3, r2
    1636:	009b      	lsls	r3, r3, #2
    1638:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    163c:	9a01      	ldr	r2, [sp, #4]
    163e:	4413      	add	r3, r2
    1640:	4618      	mov	r0, r3
    1642:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    1644:	9b03      	ldr	r3, [sp, #12]
    1646:	3301      	adds	r3, #1
    1648:	9303      	str	r3, [sp, #12]
    164a:	9b01      	ldr	r3, [sp, #4]
    164c:	7c9b      	ldrb	r3, [r3, #18]
    164e:	461a      	mov	r2, r3
    1650:	9b03      	ldr	r3, [sp, #12]
    1652:	4293      	cmp	r3, r2
    1654:	d3d1      	bcc.n	15fa <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    1656:	9801      	ldr	r0, [sp, #4]
    1658:	f7ff feca 	bl	13f0 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    165c:	2300      	movs	r3, #0
    165e:	9303      	str	r3, [sp, #12]
    1660:	e029      	b.n	16b6 <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    1662:	9901      	ldr	r1, [sp, #4]
    1664:	9a03      	ldr	r2, [sp, #12]
    1666:	4613      	mov	r3, r2
    1668:	005b      	lsls	r3, r3, #1
    166a:	4413      	add	r3, r2
    166c:	009b      	lsls	r3, r3, #2
    166e:	440b      	add	r3, r1
    1670:	3314      	adds	r3, #20
    1672:	681a      	ldr	r2, [r3, #0]
    1674:	497a      	ldr	r1, [pc, #488]	; (1860 <Clock_Ip_InitClock+0x288>)
    1676:	4613      	mov	r3, r2
    1678:	00db      	lsls	r3, r3, #3
    167a:	4413      	add	r3, r2
    167c:	440b      	add	r3, r1
    167e:	3301      	adds	r3, #1
    1680:	781b      	ldrb	r3, [r3, #0]
    1682:	461a      	mov	r2, r3
    1684:	4b79      	ldr	r3, [pc, #484]	; (186c <Clock_Ip_InitClock+0x294>)
    1686:	5c9b      	ldrb	r3, [r3, r2]
    1688:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    168a:	4979      	ldr	r1, [pc, #484]	; (1870 <Clock_Ip_InitClock+0x298>)
    168c:	9a02      	ldr	r2, [sp, #8]
    168e:	4613      	mov	r3, r2
    1690:	005b      	lsls	r3, r3, #1
    1692:	4413      	add	r3, r2
    1694:	009b      	lsls	r3, r3, #2
    1696:	440b      	add	r3, r1
    1698:	6819      	ldr	r1, [r3, #0]
    169a:	9a03      	ldr	r2, [sp, #12]
    169c:	4613      	mov	r3, r2
    169e:	005b      	lsls	r3, r3, #1
    16a0:	4413      	add	r3, r2
    16a2:	009b      	lsls	r3, r3, #2
    16a4:	3310      	adds	r3, #16
    16a6:	9a01      	ldr	r2, [sp, #4]
    16a8:	4413      	add	r3, r2
    16aa:	3304      	adds	r3, #4
    16ac:	4618      	mov	r0, r3
    16ae:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    16b0:	9b03      	ldr	r3, [sp, #12]
    16b2:	3301      	adds	r3, #1
    16b4:	9303      	str	r3, [sp, #12]
    16b6:	9b01      	ldr	r3, [sp, #4]
    16b8:	7a1b      	ldrb	r3, [r3, #8]
    16ba:	461a      	mov	r2, r3
    16bc:	9b03      	ldr	r3, [sp, #12]
    16be:	4293      	cmp	r3, r2
    16c0:	d3cf      	bcc.n	1662 <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    16c2:	2300      	movs	r3, #0
    16c4:	9303      	str	r3, [sp, #12]
    16c6:	e02a      	b.n	171e <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    16c8:	9901      	ldr	r1, [sp, #4]
    16ca:	9a03      	ldr	r2, [sp, #12]
    16cc:	4613      	mov	r3, r2
    16ce:	009b      	lsls	r3, r3, #2
    16d0:	4413      	add	r3, r2
    16d2:	009b      	lsls	r3, r3, #2
    16d4:	440b      	add	r3, r1
    16d6:	332c      	adds	r3, #44	; 0x2c
    16d8:	681a      	ldr	r2, [r3, #0]
    16da:	4961      	ldr	r1, [pc, #388]	; (1860 <Clock_Ip_InitClock+0x288>)
    16dc:	4613      	mov	r3, r2
    16de:	00db      	lsls	r3, r3, #3
    16e0:	4413      	add	r3, r2
    16e2:	440b      	add	r3, r1
    16e4:	3301      	adds	r3, #1
    16e6:	781b      	ldrb	r3, [r3, #0]
    16e8:	461a      	mov	r2, r3
    16ea:	4b62      	ldr	r3, [pc, #392]	; (1874 <Clock_Ip_InitClock+0x29c>)
    16ec:	5c9b      	ldrb	r3, [r3, r2]
    16ee:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    16f0:	4961      	ldr	r1, [pc, #388]	; (1878 <Clock_Ip_InitClock+0x2a0>)
    16f2:	9a02      	ldr	r2, [sp, #8]
    16f4:	4613      	mov	r3, r2
    16f6:	009b      	lsls	r3, r3, #2
    16f8:	4413      	add	r3, r2
    16fa:	009b      	lsls	r3, r3, #2
    16fc:	440b      	add	r3, r1
    16fe:	3304      	adds	r3, #4
    1700:	6819      	ldr	r1, [r3, #0]
    1702:	9a03      	ldr	r2, [sp, #12]
    1704:	4613      	mov	r3, r2
    1706:	009b      	lsls	r3, r3, #2
    1708:	4413      	add	r3, r2
    170a:	009b      	lsls	r3, r3, #2
    170c:	3328      	adds	r3, #40	; 0x28
    170e:	9a01      	ldr	r2, [sp, #4]
    1710:	4413      	add	r3, r2
    1712:	3304      	adds	r3, #4
    1714:	4618      	mov	r0, r3
    1716:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    1718:	9b03      	ldr	r3, [sp, #12]
    171a:	3301      	adds	r3, #1
    171c:	9303      	str	r3, [sp, #12]
    171e:	9b01      	ldr	r3, [sp, #4]
    1720:	7a5b      	ldrb	r3, [r3, #9]
    1722:	461a      	mov	r2, r3
    1724:	9b03      	ldr	r3, [sp, #12]
    1726:	4293      	cmp	r3, r2
    1728:	d3ce      	bcc.n	16c8 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    172a:	9801      	ldr	r0, [sp, #4]
    172c:	f7ff fdb0 	bl	1290 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    1730:	2300      	movs	r3, #0
    1732:	9303      	str	r3, [sp, #12]
    1734:	e028      	b.n	1788 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    1736:	9901      	ldr	r1, [sp, #4]
    1738:	9a03      	ldr	r2, [sp, #12]
    173a:	4613      	mov	r3, r2
    173c:	009b      	lsls	r3, r3, #2
    173e:	4413      	add	r3, r2
    1740:	009b      	lsls	r3, r3, #2
    1742:	440b      	add	r3, r1
    1744:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    1748:	681a      	ldr	r2, [r3, #0]
    174a:	4945      	ldr	r1, [pc, #276]	; (1860 <Clock_Ip_InitClock+0x288>)
    174c:	4613      	mov	r3, r2
    174e:	00db      	lsls	r3, r3, #3
    1750:	4413      	add	r3, r2
    1752:	440b      	add	r3, r1
    1754:	3301      	adds	r3, #1
    1756:	781b      	ldrb	r3, [r3, #0]
    1758:	461a      	mov	r2, r3
    175a:	4b48      	ldr	r3, [pc, #288]	; (187c <Clock_Ip_InitClock+0x2a4>)
    175c:	5c9b      	ldrb	r3, [r3, r2]
    175e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    1760:	4a47      	ldr	r2, [pc, #284]	; (1880 <Clock_Ip_InitClock+0x2a8>)
    1762:	9b02      	ldr	r3, [sp, #8]
    1764:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    1768:	9a03      	ldr	r2, [sp, #12]
    176a:	4613      	mov	r3, r2
    176c:	009b      	lsls	r3, r3, #2
    176e:	4413      	add	r3, r2
    1770:	009b      	lsls	r3, r3, #2
    1772:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    1776:	9a01      	ldr	r2, [sp, #4]
    1778:	4413      	add	r3, r2
    177a:	3304      	adds	r3, #4
    177c:	9903      	ldr	r1, [sp, #12]
    177e:	4618      	mov	r0, r3
    1780:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    1782:	9b03      	ldr	r3, [sp, #12]
    1784:	3301      	adds	r3, #1
    1786:	9303      	str	r3, [sp, #12]
    1788:	9b01      	ldr	r3, [sp, #4]
    178a:	7c5b      	ldrb	r3, [r3, #17]
    178c:	461a      	mov	r2, r3
    178e:	9b03      	ldr	r3, [sp, #12]
    1790:	4293      	cmp	r3, r2
    1792:	d3d0      	bcc.n	1736 <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1794:	2300      	movs	r3, #0
    1796:	9303      	str	r3, [sp, #12]
    1798:	e026      	b.n	17e8 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    179a:	9901      	ldr	r1, [sp, #4]
    179c:	9a03      	ldr	r2, [sp, #12]
    179e:	4613      	mov	r3, r2
    17a0:	005b      	lsls	r3, r3, #1
    17a2:	4413      	add	r3, r2
    17a4:	009b      	lsls	r3, r3, #2
    17a6:	440b      	add	r3, r1
    17a8:	f503 730e 	add.w	r3, r3, #568	; 0x238
    17ac:	681a      	ldr	r2, [r3, #0]
    17ae:	492c      	ldr	r1, [pc, #176]	; (1860 <Clock_Ip_InitClock+0x288>)
    17b0:	4613      	mov	r3, r2
    17b2:	00db      	lsls	r3, r3, #3
    17b4:	4413      	add	r3, r2
    17b6:	440b      	add	r3, r1
    17b8:	3301      	adds	r3, #1
    17ba:	781b      	ldrb	r3, [r3, #0]
    17bc:	461a      	mov	r2, r3
    17be:	4b31      	ldr	r3, [pc, #196]	; (1884 <Clock_Ip_InitClock+0x2ac>)
    17c0:	5c9b      	ldrb	r3, [r3, r2]
    17c2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    17c4:	4a30      	ldr	r2, [pc, #192]	; (1888 <Clock_Ip_InitClock+0x2b0>)
    17c6:	9b02      	ldr	r3, [sp, #8]
    17c8:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    17cc:	9a03      	ldr	r2, [sp, #12]
    17ce:	4613      	mov	r3, r2
    17d0:	005b      	lsls	r3, r3, #1
    17d2:	4413      	add	r3, r2
    17d4:	009b      	lsls	r3, r3, #2
    17d6:	f503 730e 	add.w	r3, r3, #568	; 0x238
    17da:	9a01      	ldr	r2, [sp, #4]
    17dc:	4413      	add	r3, r2
    17de:	4618      	mov	r0, r3
    17e0:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    17e2:	9b03      	ldr	r3, [sp, #12]
    17e4:	3301      	adds	r3, #1
    17e6:	9303      	str	r3, [sp, #12]
    17e8:	9b01      	ldr	r3, [sp, #4]
    17ea:	7b5b      	ldrb	r3, [r3, #13]
    17ec:	461a      	mov	r2, r3
    17ee:	9b03      	ldr	r3, [sp, #12]
    17f0:	4293      	cmp	r3, r2
    17f2:	d3d2      	bcc.n	179a <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    17f4:	2300      	movs	r3, #0
    17f6:	9303      	str	r3, [sp, #12]
    17f8:	e026      	b.n	1848 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    17fa:	9901      	ldr	r1, [sp, #4]
    17fc:	9a03      	ldr	r2, [sp, #12]
    17fe:	4613      	mov	r3, r2
    1800:	005b      	lsls	r3, r3, #1
    1802:	4413      	add	r3, r2
    1804:	009b      	lsls	r3, r3, #2
    1806:	440b      	add	r3, r1
    1808:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    180c:	681a      	ldr	r2, [r3, #0]
    180e:	4914      	ldr	r1, [pc, #80]	; (1860 <Clock_Ip_InitClock+0x288>)
    1810:	4613      	mov	r3, r2
    1812:	00db      	lsls	r3, r3, #3
    1814:	4413      	add	r3, r2
    1816:	440b      	add	r3, r1
    1818:	3301      	adds	r3, #1
    181a:	781b      	ldrb	r3, [r3, #0]
    181c:	461a      	mov	r2, r3
    181e:	4b1b      	ldr	r3, [pc, #108]	; (188c <Clock_Ip_InitClock+0x2b4>)
    1820:	5c9b      	ldrb	r3, [r3, r2]
    1822:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    1824:	4a1a      	ldr	r2, [pc, #104]	; (1890 <Clock_Ip_InitClock+0x2b8>)
    1826:	9b02      	ldr	r3, [sp, #8]
    1828:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    182c:	9a03      	ldr	r2, [sp, #12]
    182e:	4613      	mov	r3, r2
    1830:	005b      	lsls	r3, r3, #1
    1832:	4413      	add	r3, r2
    1834:	009b      	lsls	r3, r3, #2
    1836:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    183a:	9a01      	ldr	r2, [sp, #4]
    183c:	4413      	add	r3, r2
    183e:	4618      	mov	r0, r3
    1840:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    1842:	9b03      	ldr	r3, [sp, #12]
    1844:	3301      	adds	r3, #1
    1846:	9303      	str	r3, [sp, #12]
    1848:	9b01      	ldr	r3, [sp, #4]
    184a:	7b1b      	ldrb	r3, [r3, #12]
    184c:	461a      	mov	r2, r3
    184e:	9b03      	ldr	r3, [sp, #12]
    1850:	4293      	cmp	r3, r2
    1852:	d3d2      	bcc.n	17fa <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1854:	2300      	movs	r3, #0
    1856:	9303      	str	r3, [sp, #12]
    1858:	e044      	b.n	18e4 <Clock_Ip_InitClock+0x30c>
    185a:	bf00      	nop
    185c:	1fff8b44 	.word	0x1fff8b44
    1860:	0000bf68 	.word	0x0000bf68
    1864:	0000bf58 	.word	0x0000bf58
    1868:	0000c564 	.word	0x0000c564
    186c:	0000bef8 	.word	0x0000bef8
    1870:	0000c528 	.word	0x0000c528
    1874:	0000bee8 	.word	0x0000bee8
    1878:	0000c4bc 	.word	0x0000c4bc
    187c:	0000bf48 	.word	0x0000bf48
    1880:	0000c59c 	.word	0x0000c59c
    1884:	0000bed8 	.word	0x0000bed8
    1888:	0000c4b4 	.word	0x0000c4b4
    188c:	0000bec8 	.word	0x0000bec8
    1890:	0000c478 	.word	0x0000c478
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    1894:	9901      	ldr	r1, [sp, #4]
    1896:	9a03      	ldr	r2, [sp, #12]
    1898:	4613      	mov	r3, r2
    189a:	005b      	lsls	r3, r3, #1
    189c:	4413      	add	r3, r2
    189e:	009b      	lsls	r3, r3, #2
    18a0:	440b      	add	r3, r1
    18a2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    18a6:	681a      	ldr	r2, [r3, #0]
    18a8:	49ac      	ldr	r1, [pc, #688]	; (1b5c <Clock_Ip_InitClock+0x584>)
    18aa:	4613      	mov	r3, r2
    18ac:	00db      	lsls	r3, r3, #3
    18ae:	4413      	add	r3, r2
    18b0:	440b      	add	r3, r1
    18b2:	3301      	adds	r3, #1
    18b4:	781b      	ldrb	r3, [r3, #0]
    18b6:	461a      	mov	r2, r3
    18b8:	4ba9      	ldr	r3, [pc, #676]	; (1b60 <Clock_Ip_InitClock+0x588>)
    18ba:	5c9b      	ldrb	r3, [r3, r2]
    18bc:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    18be:	4aa9      	ldr	r2, [pc, #676]	; (1b64 <Clock_Ip_InitClock+0x58c>)
    18c0:	9b02      	ldr	r3, [sp, #8]
    18c2:	00db      	lsls	r3, r3, #3
    18c4:	4413      	add	r3, r2
    18c6:	6859      	ldr	r1, [r3, #4]
    18c8:	9a03      	ldr	r2, [sp, #12]
    18ca:	4613      	mov	r3, r2
    18cc:	005b      	lsls	r3, r3, #1
    18ce:	4413      	add	r3, r2
    18d0:	009b      	lsls	r3, r3, #2
    18d2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    18d6:	9a01      	ldr	r2, [sp, #4]
    18d8:	4413      	add	r3, r2
    18da:	4618      	mov	r0, r3
    18dc:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    18de:	9b03      	ldr	r3, [sp, #12]
    18e0:	3301      	adds	r3, #1
    18e2:	9303      	str	r3, [sp, #12]
    18e4:	9b01      	ldr	r3, [sp, #4]
    18e6:	7b5b      	ldrb	r3, [r3, #13]
    18e8:	461a      	mov	r2, r3
    18ea:	9b03      	ldr	r3, [sp, #12]
    18ec:	4293      	cmp	r3, r2
    18ee:	d3d1      	bcc.n	1894 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    18f0:	2300      	movs	r3, #0
    18f2:	9303      	str	r3, [sp, #12]
    18f4:	e029      	b.n	194a <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    18f6:	9901      	ldr	r1, [sp, #4]
    18f8:	9a03      	ldr	r2, [sp, #12]
    18fa:	4613      	mov	r3, r2
    18fc:	009b      	lsls	r3, r3, #2
    18fe:	4413      	add	r3, r2
    1900:	00db      	lsls	r3, r3, #3
    1902:	440b      	add	r3, r1
    1904:	3340      	adds	r3, #64	; 0x40
    1906:	681a      	ldr	r2, [r3, #0]
    1908:	4994      	ldr	r1, [pc, #592]	; (1b5c <Clock_Ip_InitClock+0x584>)
    190a:	4613      	mov	r3, r2
    190c:	00db      	lsls	r3, r3, #3
    190e:	4413      	add	r3, r2
    1910:	440b      	add	r3, r1
    1912:	3301      	adds	r3, #1
    1914:	781b      	ldrb	r3, [r3, #0]
    1916:	461a      	mov	r2, r3
    1918:	4b93      	ldr	r3, [pc, #588]	; (1b68 <Clock_Ip_InitClock+0x590>)
    191a:	5c9b      	ldrb	r3, [r3, r2]
    191c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    191e:	4993      	ldr	r1, [pc, #588]	; (1b6c <Clock_Ip_InitClock+0x594>)
    1920:	9a02      	ldr	r2, [sp, #8]
    1922:	4613      	mov	r3, r2
    1924:	009b      	lsls	r3, r3, #2
    1926:	4413      	add	r3, r2
    1928:	009b      	lsls	r3, r3, #2
    192a:	440b      	add	r3, r1
    192c:	3304      	adds	r3, #4
    192e:	6819      	ldr	r1, [r3, #0]
    1930:	9a03      	ldr	r2, [sp, #12]
    1932:	4613      	mov	r3, r2
    1934:	009b      	lsls	r3, r3, #2
    1936:	4413      	add	r3, r2
    1938:	00db      	lsls	r3, r3, #3
    193a:	3340      	adds	r3, #64	; 0x40
    193c:	9a01      	ldr	r2, [sp, #4]
    193e:	4413      	add	r3, r2
    1940:	4618      	mov	r0, r3
    1942:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    1944:	9b03      	ldr	r3, [sp, #12]
    1946:	3301      	adds	r3, #1
    1948:	9303      	str	r3, [sp, #12]
    194a:	9b01      	ldr	r3, [sp, #4]
    194c:	7a9b      	ldrb	r3, [r3, #10]
    194e:	461a      	mov	r2, r3
    1950:	9b03      	ldr	r3, [sp, #12]
    1952:	4293      	cmp	r3, r2
    1954:	d3cf      	bcc.n	18f6 <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    1956:	2300      	movs	r3, #0
    1958:	9303      	str	r3, [sp, #12]
    195a:	e029      	b.n	19b0 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    195c:	9901      	ldr	r1, [sp, #4]
    195e:	9a03      	ldr	r2, [sp, #12]
    1960:	4613      	mov	r3, r2
    1962:	009b      	lsls	r3, r3, #2
    1964:	4413      	add	r3, r2
    1966:	009b      	lsls	r3, r3, #2
    1968:	440b      	add	r3, r1
    196a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    196e:	681a      	ldr	r2, [r3, #0]
    1970:	497a      	ldr	r1, [pc, #488]	; (1b5c <Clock_Ip_InitClock+0x584>)
    1972:	4613      	mov	r3, r2
    1974:	00db      	lsls	r3, r3, #3
    1976:	4413      	add	r3, r2
    1978:	440b      	add	r3, r1
    197a:	3301      	adds	r3, #1
    197c:	781b      	ldrb	r3, [r3, #0]
    197e:	461a      	mov	r2, r3
    1980:	4b7b      	ldr	r3, [pc, #492]	; (1b70 <Clock_Ip_InitClock+0x598>)
    1982:	5c9b      	ldrb	r3, [r3, r2]
    1984:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    1986:	4a7b      	ldr	r2, [pc, #492]	; (1b74 <Clock_Ip_InitClock+0x59c>)
    1988:	9b02      	ldr	r3, [sp, #8]
    198a:	011b      	lsls	r3, r3, #4
    198c:	4413      	add	r3, r2
    198e:	3304      	adds	r3, #4
    1990:	681c      	ldr	r4, [r3, #0]
    1992:	9a03      	ldr	r2, [sp, #12]
    1994:	4613      	mov	r3, r2
    1996:	009b      	lsls	r3, r3, #2
    1998:	4413      	add	r3, r2
    199a:	009b      	lsls	r3, r3, #2
    199c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    19a0:	9a01      	ldr	r2, [sp, #4]
    19a2:	4413      	add	r3, r2
    19a4:	9903      	ldr	r1, [sp, #12]
    19a6:	4618      	mov	r0, r3
    19a8:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    19aa:	9b03      	ldr	r3, [sp, #12]
    19ac:	3301      	adds	r3, #1
    19ae:	9303      	str	r3, [sp, #12]
    19b0:	9b01      	ldr	r3, [sp, #4]
    19b2:	7c9b      	ldrb	r3, [r3, #18]
    19b4:	461a      	mov	r2, r3
    19b6:	9b03      	ldr	r3, [sp, #12]
    19b8:	4293      	cmp	r3, r2
    19ba:	d3cf      	bcc.n	195c <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    19bc:	2300      	movs	r3, #0
    19be:	9303      	str	r3, [sp, #12]
    19c0:	e02a      	b.n	1a18 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    19c2:	9901      	ldr	r1, [sp, #4]
    19c4:	9a03      	ldr	r2, [sp, #12]
    19c6:	4613      	mov	r3, r2
    19c8:	009b      	lsls	r3, r3, #2
    19ca:	4413      	add	r3, r2
    19cc:	009b      	lsls	r3, r3, #2
    19ce:	440b      	add	r3, r1
    19d0:	332c      	adds	r3, #44	; 0x2c
    19d2:	681a      	ldr	r2, [r3, #0]
    19d4:	4961      	ldr	r1, [pc, #388]	; (1b5c <Clock_Ip_InitClock+0x584>)
    19d6:	4613      	mov	r3, r2
    19d8:	00db      	lsls	r3, r3, #3
    19da:	4413      	add	r3, r2
    19dc:	440b      	add	r3, r1
    19de:	3301      	adds	r3, #1
    19e0:	781b      	ldrb	r3, [r3, #0]
    19e2:	461a      	mov	r2, r3
    19e4:	4b64      	ldr	r3, [pc, #400]	; (1b78 <Clock_Ip_InitClock+0x5a0>)
    19e6:	5c9b      	ldrb	r3, [r3, r2]
    19e8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    19ea:	4964      	ldr	r1, [pc, #400]	; (1b7c <Clock_Ip_InitClock+0x5a4>)
    19ec:	9a02      	ldr	r2, [sp, #8]
    19ee:	4613      	mov	r3, r2
    19f0:	009b      	lsls	r3, r3, #2
    19f2:	4413      	add	r3, r2
    19f4:	009b      	lsls	r3, r3, #2
    19f6:	440b      	add	r3, r1
    19f8:	3308      	adds	r3, #8
    19fa:	6819      	ldr	r1, [r3, #0]
    19fc:	9a03      	ldr	r2, [sp, #12]
    19fe:	4613      	mov	r3, r2
    1a00:	009b      	lsls	r3, r3, #2
    1a02:	4413      	add	r3, r2
    1a04:	009b      	lsls	r3, r3, #2
    1a06:	3328      	adds	r3, #40	; 0x28
    1a08:	9a01      	ldr	r2, [sp, #4]
    1a0a:	4413      	add	r3, r2
    1a0c:	3304      	adds	r3, #4
    1a0e:	4618      	mov	r0, r3
    1a10:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    1a12:	9b03      	ldr	r3, [sp, #12]
    1a14:	3301      	adds	r3, #1
    1a16:	9303      	str	r3, [sp, #12]
    1a18:	9b01      	ldr	r3, [sp, #4]
    1a1a:	7a5b      	ldrb	r3, [r3, #9]
    1a1c:	461a      	mov	r2, r3
    1a1e:	9b03      	ldr	r3, [sp, #12]
    1a20:	4293      	cmp	r3, r2
    1a22:	d3ce      	bcc.n	19c2 <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1a24:	2300      	movs	r3, #0
    1a26:	9303      	str	r3, [sp, #12]
    1a28:	e029      	b.n	1a7e <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    1a2a:	9901      	ldr	r1, [sp, #4]
    1a2c:	9a03      	ldr	r2, [sp, #12]
    1a2e:	4613      	mov	r3, r2
    1a30:	009b      	lsls	r3, r3, #2
    1a32:	4413      	add	r3, r2
    1a34:	00db      	lsls	r3, r3, #3
    1a36:	440b      	add	r3, r1
    1a38:	3340      	adds	r3, #64	; 0x40
    1a3a:	681a      	ldr	r2, [r3, #0]
    1a3c:	4947      	ldr	r1, [pc, #284]	; (1b5c <Clock_Ip_InitClock+0x584>)
    1a3e:	4613      	mov	r3, r2
    1a40:	00db      	lsls	r3, r3, #3
    1a42:	4413      	add	r3, r2
    1a44:	440b      	add	r3, r1
    1a46:	3301      	adds	r3, #1
    1a48:	781b      	ldrb	r3, [r3, #0]
    1a4a:	461a      	mov	r2, r3
    1a4c:	4b46      	ldr	r3, [pc, #280]	; (1b68 <Clock_Ip_InitClock+0x590>)
    1a4e:	5c9b      	ldrb	r3, [r3, r2]
    1a50:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    1a52:	4946      	ldr	r1, [pc, #280]	; (1b6c <Clock_Ip_InitClock+0x594>)
    1a54:	9a02      	ldr	r2, [sp, #8]
    1a56:	4613      	mov	r3, r2
    1a58:	009b      	lsls	r3, r3, #2
    1a5a:	4413      	add	r3, r2
    1a5c:	009b      	lsls	r3, r3, #2
    1a5e:	440b      	add	r3, r1
    1a60:	330c      	adds	r3, #12
    1a62:	6819      	ldr	r1, [r3, #0]
    1a64:	9a03      	ldr	r2, [sp, #12]
    1a66:	4613      	mov	r3, r2
    1a68:	009b      	lsls	r3, r3, #2
    1a6a:	4413      	add	r3, r2
    1a6c:	00db      	lsls	r3, r3, #3
    1a6e:	3340      	adds	r3, #64	; 0x40
    1a70:	9a01      	ldr	r2, [sp, #4]
    1a72:	4413      	add	r3, r2
    1a74:	4618      	mov	r0, r3
    1a76:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1a78:	9b03      	ldr	r3, [sp, #12]
    1a7a:	3301      	adds	r3, #1
    1a7c:	9303      	str	r3, [sp, #12]
    1a7e:	9b01      	ldr	r3, [sp, #4]
    1a80:	7a9b      	ldrb	r3, [r3, #10]
    1a82:	461a      	mov	r2, r3
    1a84:	9b03      	ldr	r3, [sp, #12]
    1a86:	4293      	cmp	r3, r2
    1a88:	d3cf      	bcc.n	1a2a <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1a8a:	2300      	movs	r3, #0
    1a8c:	9303      	str	r3, [sp, #12]
    1a8e:	e025      	b.n	1adc <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    1a90:	9a01      	ldr	r2, [sp, #4]
    1a92:	9b03      	ldr	r3, [sp, #12]
    1a94:	3324      	adds	r3, #36	; 0x24
    1a96:	011b      	lsls	r3, r3, #4
    1a98:	4413      	add	r3, r2
    1a9a:	3304      	adds	r3, #4
    1a9c:	681a      	ldr	r2, [r3, #0]
    1a9e:	492f      	ldr	r1, [pc, #188]	; (1b5c <Clock_Ip_InitClock+0x584>)
    1aa0:	4613      	mov	r3, r2
    1aa2:	00db      	lsls	r3, r3, #3
    1aa4:	4413      	add	r3, r2
    1aa6:	440b      	add	r3, r1
    1aa8:	3301      	adds	r3, #1
    1aaa:	781b      	ldrb	r3, [r3, #0]
    1aac:	461a      	mov	r2, r3
    1aae:	4b34      	ldr	r3, [pc, #208]	; (1b80 <Clock_Ip_InitClock+0x5a8>)
    1ab0:	5c9b      	ldrb	r3, [r3, r2]
    1ab2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    1ab4:	4933      	ldr	r1, [pc, #204]	; (1b84 <Clock_Ip_InitClock+0x5ac>)
    1ab6:	9a02      	ldr	r2, [sp, #8]
    1ab8:	4613      	mov	r3, r2
    1aba:	005b      	lsls	r3, r3, #1
    1abc:	4413      	add	r3, r2
    1abe:	009b      	lsls	r3, r3, #2
    1ac0:	440b      	add	r3, r1
    1ac2:	3304      	adds	r3, #4
    1ac4:	681b      	ldr	r3, [r3, #0]
    1ac6:	9a03      	ldr	r2, [sp, #12]
    1ac8:	3224      	adds	r2, #36	; 0x24
    1aca:	0112      	lsls	r2, r2, #4
    1acc:	9901      	ldr	r1, [sp, #4]
    1ace:	440a      	add	r2, r1
    1ad0:	3204      	adds	r2, #4
    1ad2:	4610      	mov	r0, r2
    1ad4:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1ad6:	9b03      	ldr	r3, [sp, #12]
    1ad8:	3301      	adds	r3, #1
    1ada:	9303      	str	r3, [sp, #12]
    1adc:	9b01      	ldr	r3, [sp, #4]
    1ade:	7b9b      	ldrb	r3, [r3, #14]
    1ae0:	461a      	mov	r2, r3
    1ae2:	9b03      	ldr	r3, [sp, #12]
    1ae4:	4293      	cmp	r3, r2
    1ae6:	d3d3      	bcc.n	1a90 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    1ae8:	4b27      	ldr	r3, [pc, #156]	; (1b88 <Clock_Ip_InitClock+0x5b0>)
    1aea:	2200      	movs	r2, #0
    1aec:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    1aee:	4b26      	ldr	r3, [pc, #152]	; (1b88 <Clock_Ip_InitClock+0x5b0>)
    1af0:	2200      	movs	r2, #0
    1af2:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    1af4:	4b24      	ldr	r3, [pc, #144]	; (1b88 <Clock_Ip_InitClock+0x5b0>)
    1af6:	2201      	movs	r2, #1
    1af8:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    1afa:	4b23      	ldr	r3, [pc, #140]	; (1b88 <Clock_Ip_InitClock+0x5b0>)
    1afc:	2200      	movs	r2, #0
    1afe:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    1b00:	f000 fa9c 	bl	203c <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    1b04:	2300      	movs	r3, #0
    1b06:	9303      	str	r3, [sp, #12]
    1b08:	e04c      	b.n	1ba4 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    1b0a:	9a01      	ldr	r2, [sp, #4]
    1b0c:	9b03      	ldr	r3, [sp, #12]
    1b0e:	330d      	adds	r3, #13
    1b10:	00db      	lsls	r3, r3, #3
    1b12:	4413      	add	r3, r2
    1b14:	685b      	ldr	r3, [r3, #4]
    1b16:	4a1d      	ldr	r2, [pc, #116]	; (1b8c <Clock_Ip_InitClock+0x5b4>)
    1b18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1b1c:	2b03      	cmp	r3, #3
    1b1e:	d03b      	beq.n	1b98 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    1b20:	9b01      	ldr	r3, [sp, #4]
    1b22:	9a03      	ldr	r2, [sp, #12]
    1b24:	320d      	adds	r2, #13
    1b26:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1b2a:	490c      	ldr	r1, [pc, #48]	; (1b5c <Clock_Ip_InitClock+0x584>)
    1b2c:	4613      	mov	r3, r2
    1b2e:	00db      	lsls	r3, r3, #3
    1b30:	4413      	add	r3, r2
    1b32:	440b      	add	r3, r1
    1b34:	3301      	adds	r3, #1
    1b36:	781b      	ldrb	r3, [r3, #0]
    1b38:	461a      	mov	r2, r3
    1b3a:	4b15      	ldr	r3, [pc, #84]	; (1b90 <Clock_Ip_InitClock+0x5b8>)
    1b3c:	5c9b      	ldrb	r3, [r3, r2]
    1b3e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    1b40:	4a14      	ldr	r2, [pc, #80]	; (1b94 <Clock_Ip_InitClock+0x5bc>)
    1b42:	9b02      	ldr	r3, [sp, #8]
    1b44:	00db      	lsls	r3, r3, #3
    1b46:	4413      	add	r3, r2
    1b48:	685b      	ldr	r3, [r3, #4]
    1b4a:	9a03      	ldr	r2, [sp, #12]
    1b4c:	320d      	adds	r2, #13
    1b4e:	00d2      	lsls	r2, r2, #3
    1b50:	9901      	ldr	r1, [sp, #4]
    1b52:	440a      	add	r2, r1
    1b54:	4610      	mov	r0, r2
    1b56:	4798      	blx	r3
    1b58:	e021      	b.n	1b9e <Clock_Ip_InitClock+0x5c6>
    1b5a:	bf00      	nop
    1b5c:	0000bf68 	.word	0x0000bf68
    1b60:	0000bed8 	.word	0x0000bed8
    1b64:	0000c4b4 	.word	0x0000c4b4
    1b68:	0000bf28 	.word	0x0000bf28
    1b6c:	0000c574 	.word	0x0000c574
    1b70:	0000bf58 	.word	0x0000bf58
    1b74:	0000c564 	.word	0x0000c564
    1b78:	0000bee8 	.word	0x0000bee8
    1b7c:	0000c4bc 	.word	0x0000c4bc
    1b80:	0000bf18 	.word	0x0000bf18
    1b84:	0000c4e4 	.word	0x0000c4e4
    1b88:	1fff8b4c 	.word	0x1fff8b4c
    1b8c:	0000c3b4 	.word	0x0000c3b4
    1b90:	0000bf38 	.word	0x0000bf38
    1b94:	0000c5a0 	.word	0x0000c5a0
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    1b98:	4b3a      	ldr	r3, [pc, #232]	; (1c84 <Clock_Ip_InitClock+0x6ac>)
    1b9a:	2201      	movs	r2, #1
    1b9c:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    1b9e:	9b03      	ldr	r3, [sp, #12]
    1ba0:	3301      	adds	r3, #1
    1ba2:	9303      	str	r3, [sp, #12]
    1ba4:	9b01      	ldr	r3, [sp, #4]
    1ba6:	7adb      	ldrb	r3, [r3, #11]
    1ba8:	461a      	mov	r2, r3
    1baa:	9b03      	ldr	r3, [sp, #12]
    1bac:	4293      	cmp	r3, r2
    1bae:	d3ac      	bcc.n	1b0a <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    1bb0:	4b34      	ldr	r3, [pc, #208]	; (1c84 <Clock_Ip_InitClock+0x6ac>)
    1bb2:	781b      	ldrb	r3, [r3, #0]
    1bb4:	f083 0301 	eor.w	r3, r3, #1
    1bb8:	b2db      	uxtb	r3, r3
    1bba:	2b00      	cmp	r3, #0
    1bbc:	d05e      	beq.n	1c7c <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1bbe:	2300      	movs	r3, #0
    1bc0:	9303      	str	r3, [sp, #12]
    1bc2:	e01f      	b.n	1c04 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    1bc4:	9a01      	ldr	r2, [sp, #4]
    1bc6:	9b03      	ldr	r3, [sp, #12]
    1bc8:	334e      	adds	r3, #78	; 0x4e
    1bca:	00db      	lsls	r3, r3, #3
    1bcc:	4413      	add	r3, r2
    1bce:	685a      	ldr	r2, [r3, #4]
    1bd0:	492d      	ldr	r1, [pc, #180]	; (1c88 <Clock_Ip_InitClock+0x6b0>)
    1bd2:	4613      	mov	r3, r2
    1bd4:	00db      	lsls	r3, r3, #3
    1bd6:	4413      	add	r3, r2
    1bd8:	440b      	add	r3, r1
    1bda:	3301      	adds	r3, #1
    1bdc:	781b      	ldrb	r3, [r3, #0]
    1bde:	461a      	mov	r2, r3
    1be0:	4b2a      	ldr	r3, [pc, #168]	; (1c8c <Clock_Ip_InitClock+0x6b4>)
    1be2:	5c9b      	ldrb	r3, [r3, r2]
    1be4:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    1be6:	4a2a      	ldr	r2, [pc, #168]	; (1c90 <Clock_Ip_InitClock+0x6b8>)
    1be8:	9b02      	ldr	r3, [sp, #8]
    1bea:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1bee:	9a03      	ldr	r2, [sp, #12]
    1bf0:	324e      	adds	r2, #78	; 0x4e
    1bf2:	00d2      	lsls	r2, r2, #3
    1bf4:	9901      	ldr	r1, [sp, #4]
    1bf6:	440a      	add	r2, r1
    1bf8:	3204      	adds	r2, #4
    1bfa:	4610      	mov	r0, r2
    1bfc:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1bfe:	9b03      	ldr	r3, [sp, #12]
    1c00:	3301      	adds	r3, #1
    1c02:	9303      	str	r3, [sp, #12]
    1c04:	9b01      	ldr	r3, [sp, #4]
    1c06:	7c1b      	ldrb	r3, [r3, #16]
    1c08:	461a      	mov	r2, r3
    1c0a:	9b03      	ldr	r3, [sp, #12]
    1c0c:	4293      	cmp	r3, r2
    1c0e:	d3d9      	bcc.n	1bc4 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    1c10:	2300      	movs	r3, #0
    1c12:	9303      	str	r3, [sp, #12]
    1c14:	e028      	b.n	1c68 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1c16:	9901      	ldr	r1, [sp, #4]
    1c18:	9a03      	ldr	r2, [sp, #12]
    1c1a:	4613      	mov	r3, r2
    1c1c:	009b      	lsls	r3, r3, #2
    1c1e:	4413      	add	r3, r2
    1c20:	009b      	lsls	r3, r3, #2
    1c22:	440b      	add	r3, r1
    1c24:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1c28:	681a      	ldr	r2, [r3, #0]
    1c2a:	4917      	ldr	r1, [pc, #92]	; (1c88 <Clock_Ip_InitClock+0x6b0>)
    1c2c:	4613      	mov	r3, r2
    1c2e:	00db      	lsls	r3, r3, #3
    1c30:	4413      	add	r3, r2
    1c32:	440b      	add	r3, r1
    1c34:	3301      	adds	r3, #1
    1c36:	781b      	ldrb	r3, [r3, #0]
    1c38:	461a      	mov	r2, r3
    1c3a:	4b16      	ldr	r3, [pc, #88]	; (1c94 <Clock_Ip_InitClock+0x6bc>)
    1c3c:	5c9b      	ldrb	r3, [r3, r2]
    1c3e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    1c40:	4a15      	ldr	r2, [pc, #84]	; (1c98 <Clock_Ip_InitClock+0x6c0>)
    1c42:	9b02      	ldr	r3, [sp, #8]
    1c44:	011b      	lsls	r3, r3, #4
    1c46:	4413      	add	r3, r2
    1c48:	330c      	adds	r3, #12
    1c4a:	6819      	ldr	r1, [r3, #0]
    1c4c:	9a03      	ldr	r2, [sp, #12]
    1c4e:	4613      	mov	r3, r2
    1c50:	009b      	lsls	r3, r3, #2
    1c52:	4413      	add	r3, r2
    1c54:	009b      	lsls	r3, r3, #2
    1c56:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1c5a:	9a01      	ldr	r2, [sp, #4]
    1c5c:	4413      	add	r3, r2
    1c5e:	4618      	mov	r0, r3
    1c60:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    1c62:	9b03      	ldr	r3, [sp, #12]
    1c64:	3301      	adds	r3, #1
    1c66:	9303      	str	r3, [sp, #12]
    1c68:	9b01      	ldr	r3, [sp, #4]
    1c6a:	7c9b      	ldrb	r3, [r3, #18]
    1c6c:	461a      	mov	r2, r3
    1c6e:	9b03      	ldr	r3, [sp, #12]
    1c70:	4293      	cmp	r3, r2
    1c72:	d3d0      	bcc.n	1c16 <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1c74:	2104      	movs	r1, #4
    1c76:	9801      	ldr	r0, [sp, #4]
    1c78:	f002 ff48 	bl	4b0c <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    1c7c:	bf00      	nop
    1c7e:	b004      	add	sp, #16
    1c80:	bd10      	pop	{r4, pc}
    1c82:	bf00      	nop
    1c84:	1fff8b4c 	.word	0x1fff8b4c
    1c88:	0000bf68 	.word	0x0000bf68
    1c8c:	0000bf08 	.word	0x0000bf08
    1c90:	0000c4f0 	.word	0x0000c4f0
    1c94:	0000bf58 	.word	0x0000bf58
    1c98:	0000c564 	.word	0x0000c564

00001c9c <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    1c9c:	b500      	push	{lr}
    1c9e:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    1ca0:	2302      	movs	r3, #2
    1ca2:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    1ca4:	2300      	movs	r3, #0
    1ca6:	9304      	str	r3, [sp, #16]
    1ca8:	e02c      	b.n	1d04 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    1caa:	4a36      	ldr	r2, [pc, #216]	; (1d84 <Clock_Ip_GetPllStatus+0xe8>)
    1cac:	9b04      	ldr	r3, [sp, #16]
    1cae:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1cb2:	4935      	ldr	r1, [pc, #212]	; (1d88 <Clock_Ip_GetPllStatus+0xec>)
    1cb4:	4613      	mov	r3, r2
    1cb6:	00db      	lsls	r3, r3, #3
    1cb8:	4413      	add	r3, r2
    1cba:	440b      	add	r3, r1
    1cbc:	3301      	adds	r3, #1
    1cbe:	781b      	ldrb	r3, [r3, #0]
    1cc0:	461a      	mov	r2, r3
    1cc2:	4b32      	ldr	r3, [pc, #200]	; (1d8c <Clock_Ip_GetPllStatus+0xf0>)
    1cc4:	5c9b      	ldrb	r3, [r3, r2]
    1cc6:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    1cc8:	4931      	ldr	r1, [pc, #196]	; (1d90 <Clock_Ip_GetPllStatus+0xf4>)
    1cca:	9a03      	ldr	r2, [sp, #12]
    1ccc:	4613      	mov	r3, r2
    1cce:	009b      	lsls	r3, r3, #2
    1cd0:	4413      	add	r3, r2
    1cd2:	009b      	lsls	r3, r3, #2
    1cd4:	440b      	add	r3, r1
    1cd6:	3308      	adds	r3, #8
    1cd8:	681b      	ldr	r3, [r3, #0]
    1cda:	492a      	ldr	r1, [pc, #168]	; (1d84 <Clock_Ip_GetPllStatus+0xe8>)
    1cdc:	9a04      	ldr	r2, [sp, #16]
    1cde:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    1ce2:	4610      	mov	r0, r2
    1ce4:	4798      	blx	r3
    1ce6:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    1ce8:	9b02      	ldr	r3, [sp, #8]
    1cea:	2b01      	cmp	r3, #1
    1cec:	d102      	bne.n	1cf4 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    1cee:	2301      	movs	r3, #1
    1cf0:	9305      	str	r3, [sp, #20]
            break;
    1cf2:	e00d      	b.n	1d10 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    1cf4:	9b02      	ldr	r3, [sp, #8]
    1cf6:	2b02      	cmp	r3, #2
    1cf8:	d101      	bne.n	1cfe <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    1cfa:	2300      	movs	r3, #0
    1cfc:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    1cfe:	9b04      	ldr	r3, [sp, #16]
    1d00:	3301      	adds	r3, #1
    1d02:	9304      	str	r3, [sp, #16]
    1d04:	4b23      	ldr	r3, [pc, #140]	; (1d94 <Clock_Ip_GetPllStatus+0xf8>)
    1d06:	789b      	ldrb	r3, [r3, #2]
    1d08:	461a      	mov	r2, r3
    1d0a:	9b04      	ldr	r3, [sp, #16]
    1d0c:	4293      	cmp	r3, r2
    1d0e:	d3cc      	bcc.n	1caa <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    1d10:	9b05      	ldr	r3, [sp, #20]
    1d12:	2b00      	cmp	r3, #0
    1d14:	d130      	bne.n	1d78 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    1d16:	2300      	movs	r3, #0
    1d18:	9304      	str	r3, [sp, #16]
    1d1a:	e027      	b.n	1d6c <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    1d1c:	4a1e      	ldr	r2, [pc, #120]	; (1d98 <Clock_Ip_GetPllStatus+0xfc>)
    1d1e:	9b04      	ldr	r3, [sp, #16]
    1d20:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1d24:	4918      	ldr	r1, [pc, #96]	; (1d88 <Clock_Ip_GetPllStatus+0xec>)
    1d26:	4613      	mov	r3, r2
    1d28:	00db      	lsls	r3, r3, #3
    1d2a:	4413      	add	r3, r2
    1d2c:	440b      	add	r3, r1
    1d2e:	3301      	adds	r3, #1
    1d30:	781b      	ldrb	r3, [r3, #0]
    1d32:	461a      	mov	r2, r3
    1d34:	4b19      	ldr	r3, [pc, #100]	; (1d9c <Clock_Ip_GetPllStatus+0x100>)
    1d36:	5c9b      	ldrb	r3, [r3, r2]
    1d38:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    1d3a:	4919      	ldr	r1, [pc, #100]	; (1da0 <Clock_Ip_GetPllStatus+0x104>)
    1d3c:	9a03      	ldr	r2, [sp, #12]
    1d3e:	4613      	mov	r3, r2
    1d40:	005b      	lsls	r3, r3, #1
    1d42:	4413      	add	r3, r2
    1d44:	009b      	lsls	r3, r3, #2
    1d46:	440b      	add	r3, r1
    1d48:	3308      	adds	r3, #8
    1d4a:	681b      	ldr	r3, [r3, #0]
    1d4c:	4912      	ldr	r1, [pc, #72]	; (1d98 <Clock_Ip_GetPllStatus+0xfc>)
    1d4e:	9a04      	ldr	r2, [sp, #16]
    1d50:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    1d54:	4610      	mov	r0, r2
    1d56:	4798      	blx	r3
    1d58:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    1d5a:	9b01      	ldr	r3, [sp, #4]
    1d5c:	2b01      	cmp	r3, #1
    1d5e:	d102      	bne.n	1d66 <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    1d60:	2301      	movs	r3, #1
    1d62:	9305      	str	r3, [sp, #20]
                break;
    1d64:	e008      	b.n	1d78 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    1d66:	9b04      	ldr	r3, [sp, #16]
    1d68:	3301      	adds	r3, #1
    1d6a:	9304      	str	r3, [sp, #16]
    1d6c:	4b09      	ldr	r3, [pc, #36]	; (1d94 <Clock_Ip_GetPllStatus+0xf8>)
    1d6e:	78db      	ldrb	r3, [r3, #3]
    1d70:	461a      	mov	r2, r3
    1d72:	9b04      	ldr	r3, [sp, #16]
    1d74:	4293      	cmp	r3, r2
    1d76:	d3d1      	bcc.n	1d1c <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    1d78:	9b05      	ldr	r3, [sp, #20]
}
    1d7a:	4618      	mov	r0, r3
    1d7c:	b007      	add	sp, #28
    1d7e:	f85d fb04 	ldr.w	pc, [sp], #4
    1d82:	bf00      	nop
    1d84:	0000c470 	.word	0x0000c470
    1d88:	0000bf68 	.word	0x0000bf68
    1d8c:	0000bf28 	.word	0x0000bf28
    1d90:	0000c574 	.word	0x0000c574
    1d94:	1fff8b4c 	.word	0x1fff8b4c
    1d98:	0000c474 	.word	0x0000c474
    1d9c:	0000bf18 	.word	0x0000bf18
    1da0:	0000c4e4 	.word	0x0000c4e4

00001da4 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    1da4:	b500      	push	{lr}
    1da6:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    1da8:	4b55      	ldr	r3, [pc, #340]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1daa:	681b      	ldr	r3, [r3, #0]
    1dac:	2b00      	cmp	r3, #0
    1dae:	f000 80a2 	beq.w	1ef6 <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    1db2:	2300      	movs	r3, #0
    1db4:	9301      	str	r3, [sp, #4]
    1db6:	e02c      	b.n	1e12 <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    1db8:	4b51      	ldr	r3, [pc, #324]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1dba:	681a      	ldr	r2, [r3, #0]
    1dbc:	9b01      	ldr	r3, [sp, #4]
    1dbe:	330d      	adds	r3, #13
    1dc0:	00db      	lsls	r3, r3, #3
    1dc2:	4413      	add	r3, r2
    1dc4:	685b      	ldr	r3, [r3, #4]
    1dc6:	4a4f      	ldr	r2, [pc, #316]	; (1f04 <Clock_Ip_DistributePll+0x160>)
    1dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1dcc:	2b03      	cmp	r3, #3
    1dce:	d11d      	bne.n	1e0c <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    1dd0:	4b4b      	ldr	r3, [pc, #300]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1dd2:	681b      	ldr	r3, [r3, #0]
    1dd4:	9a01      	ldr	r2, [sp, #4]
    1dd6:	320d      	adds	r2, #13
    1dd8:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1ddc:	494a      	ldr	r1, [pc, #296]	; (1f08 <Clock_Ip_DistributePll+0x164>)
    1dde:	4613      	mov	r3, r2
    1de0:	00db      	lsls	r3, r3, #3
    1de2:	4413      	add	r3, r2
    1de4:	440b      	add	r3, r1
    1de6:	3301      	adds	r3, #1
    1de8:	781b      	ldrb	r3, [r3, #0]
    1dea:	461a      	mov	r2, r3
    1dec:	4b47      	ldr	r3, [pc, #284]	; (1f0c <Clock_Ip_DistributePll+0x168>)
    1dee:	5c9b      	ldrb	r3, [r3, r2]
    1df0:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    1df2:	4a47      	ldr	r2, [pc, #284]	; (1f10 <Clock_Ip_DistributePll+0x16c>)
    1df4:	9b00      	ldr	r3, [sp, #0]
    1df6:	00db      	lsls	r3, r3, #3
    1df8:	4413      	add	r3, r2
    1dfa:	685b      	ldr	r3, [r3, #4]
    1dfc:	4a40      	ldr	r2, [pc, #256]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1dfe:	6811      	ldr	r1, [r2, #0]
    1e00:	9a01      	ldr	r2, [sp, #4]
    1e02:	320d      	adds	r2, #13
    1e04:	00d2      	lsls	r2, r2, #3
    1e06:	440a      	add	r2, r1
    1e08:	4610      	mov	r0, r2
    1e0a:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    1e0c:	9b01      	ldr	r3, [sp, #4]
    1e0e:	3301      	adds	r3, #1
    1e10:	9301      	str	r3, [sp, #4]
    1e12:	4b3b      	ldr	r3, [pc, #236]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1e14:	681b      	ldr	r3, [r3, #0]
    1e16:	7adb      	ldrb	r3, [r3, #11]
    1e18:	461a      	mov	r2, r3
    1e1a:	9b01      	ldr	r3, [sp, #4]
    1e1c:	4293      	cmp	r3, r2
    1e1e:	d3cb      	bcc.n	1db8 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    1e20:	4b3c      	ldr	r3, [pc, #240]	; (1f14 <Clock_Ip_DistributePll+0x170>)
    1e22:	781b      	ldrb	r3, [r3, #0]
    1e24:	2b00      	cmp	r3, #0
    1e26:	d066      	beq.n	1ef6 <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1e28:	2300      	movs	r3, #0
    1e2a:	9301      	str	r3, [sp, #4]
    1e2c:	e021      	b.n	1e72 <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    1e2e:	4b34      	ldr	r3, [pc, #208]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1e30:	681a      	ldr	r2, [r3, #0]
    1e32:	9b01      	ldr	r3, [sp, #4]
    1e34:	334e      	adds	r3, #78	; 0x4e
    1e36:	00db      	lsls	r3, r3, #3
    1e38:	4413      	add	r3, r2
    1e3a:	685a      	ldr	r2, [r3, #4]
    1e3c:	4932      	ldr	r1, [pc, #200]	; (1f08 <Clock_Ip_DistributePll+0x164>)
    1e3e:	4613      	mov	r3, r2
    1e40:	00db      	lsls	r3, r3, #3
    1e42:	4413      	add	r3, r2
    1e44:	440b      	add	r3, r1
    1e46:	3301      	adds	r3, #1
    1e48:	781b      	ldrb	r3, [r3, #0]
    1e4a:	461a      	mov	r2, r3
    1e4c:	4b32      	ldr	r3, [pc, #200]	; (1f18 <Clock_Ip_DistributePll+0x174>)
    1e4e:	5c9b      	ldrb	r3, [r3, r2]
    1e50:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    1e52:	4a32      	ldr	r2, [pc, #200]	; (1f1c <Clock_Ip_DistributePll+0x178>)
    1e54:	9b00      	ldr	r3, [sp, #0]
    1e56:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1e5a:	4a29      	ldr	r2, [pc, #164]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1e5c:	6811      	ldr	r1, [r2, #0]
    1e5e:	9a01      	ldr	r2, [sp, #4]
    1e60:	324e      	adds	r2, #78	; 0x4e
    1e62:	00d2      	lsls	r2, r2, #3
    1e64:	440a      	add	r2, r1
    1e66:	3204      	adds	r2, #4
    1e68:	4610      	mov	r0, r2
    1e6a:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1e6c:	9b01      	ldr	r3, [sp, #4]
    1e6e:	3301      	adds	r3, #1
    1e70:	9301      	str	r3, [sp, #4]
    1e72:	4b23      	ldr	r3, [pc, #140]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1e74:	681b      	ldr	r3, [r3, #0]
    1e76:	7c1b      	ldrb	r3, [r3, #16]
    1e78:	461a      	mov	r2, r3
    1e7a:	9b01      	ldr	r3, [sp, #4]
    1e7c:	4293      	cmp	r3, r2
    1e7e:	d3d6      	bcc.n	1e2e <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1e80:	2300      	movs	r3, #0
    1e82:	9301      	str	r3, [sp, #4]
    1e84:	e02a      	b.n	1edc <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1e86:	4b1e      	ldr	r3, [pc, #120]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1e88:	6819      	ldr	r1, [r3, #0]
    1e8a:	9a01      	ldr	r2, [sp, #4]
    1e8c:	4613      	mov	r3, r2
    1e8e:	009b      	lsls	r3, r3, #2
    1e90:	4413      	add	r3, r2
    1e92:	009b      	lsls	r3, r3, #2
    1e94:	440b      	add	r3, r1
    1e96:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1e9a:	681a      	ldr	r2, [r3, #0]
    1e9c:	491a      	ldr	r1, [pc, #104]	; (1f08 <Clock_Ip_DistributePll+0x164>)
    1e9e:	4613      	mov	r3, r2
    1ea0:	00db      	lsls	r3, r3, #3
    1ea2:	4413      	add	r3, r2
    1ea4:	440b      	add	r3, r1
    1ea6:	3301      	adds	r3, #1
    1ea8:	781b      	ldrb	r3, [r3, #0]
    1eaa:	461a      	mov	r2, r3
    1eac:	4b1c      	ldr	r3, [pc, #112]	; (1f20 <Clock_Ip_DistributePll+0x17c>)
    1eae:	5c9b      	ldrb	r3, [r3, r2]
    1eb0:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    1eb2:	4a1c      	ldr	r2, [pc, #112]	; (1f24 <Clock_Ip_DistributePll+0x180>)
    1eb4:	9b00      	ldr	r3, [sp, #0]
    1eb6:	011b      	lsls	r3, r3, #4
    1eb8:	4413      	add	r3, r2
    1eba:	330c      	adds	r3, #12
    1ebc:	6819      	ldr	r1, [r3, #0]
    1ebe:	4b10      	ldr	r3, [pc, #64]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1ec0:	6818      	ldr	r0, [r3, #0]
    1ec2:	9a01      	ldr	r2, [sp, #4]
    1ec4:	4613      	mov	r3, r2
    1ec6:	009b      	lsls	r3, r3, #2
    1ec8:	4413      	add	r3, r2
    1eca:	009b      	lsls	r3, r3, #2
    1ecc:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1ed0:	4403      	add	r3, r0
    1ed2:	4618      	mov	r0, r3
    1ed4:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1ed6:	9b01      	ldr	r3, [sp, #4]
    1ed8:	3301      	adds	r3, #1
    1eda:	9301      	str	r3, [sp, #4]
    1edc:	4b08      	ldr	r3, [pc, #32]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1ede:	681b      	ldr	r3, [r3, #0]
    1ee0:	7c9b      	ldrb	r3, [r3, #18]
    1ee2:	461a      	mov	r2, r3
    1ee4:	9b01      	ldr	r3, [sp, #4]
    1ee6:	4293      	cmp	r3, r2
    1ee8:	d3cd      	bcc.n	1e86 <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1eea:	4b05      	ldr	r3, [pc, #20]	; (1f00 <Clock_Ip_DistributePll+0x15c>)
    1eec:	681b      	ldr	r3, [r3, #0]
    1eee:	2104      	movs	r1, #4
    1ef0:	4618      	mov	r0, r3
    1ef2:	f002 fe0b 	bl	4b0c <Clock_Ip_Command>
        }
    }
}
    1ef6:	bf00      	nop
    1ef8:	b003      	add	sp, #12
    1efa:	f85d fb04 	ldr.w	pc, [sp], #4
    1efe:	bf00      	nop
    1f00:	1fff8b44 	.word	0x1fff8b44
    1f04:	0000c3b4 	.word	0x0000c3b4
    1f08:	0000bf68 	.word	0x0000bf68
    1f0c:	0000bf38 	.word	0x0000bf38
    1f10:	0000c5a0 	.word	0x0000c5a0
    1f14:	1fff8b4c 	.word	0x1fff8b4c
    1f18:	0000bf08 	.word	0x0000bf08
    1f1c:	0000c4f0 	.word	0x0000c4f0
    1f20:	0000bf58 	.word	0x0000bf58
    1f24:	0000c564 	.word	0x0000c564

00001f28 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    1f28:	b500      	push	{lr}
    1f2a:	b085      	sub	sp, #20
    1f2c:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1f2e:	490c      	ldr	r1, [pc, #48]	; (1f60 <Clock_Ip_DisableClockMonitor+0x38>)
    1f30:	9a01      	ldr	r2, [sp, #4]
    1f32:	4613      	mov	r3, r2
    1f34:	00db      	lsls	r3, r3, #3
    1f36:	4413      	add	r3, r2
    1f38:	440b      	add	r3, r1
    1f3a:	3301      	adds	r3, #1
    1f3c:	781b      	ldrb	r3, [r3, #0]
    1f3e:	461a      	mov	r2, r3
    1f40:	4b08      	ldr	r3, [pc, #32]	; (1f64 <Clock_Ip_DisableClockMonitor+0x3c>)
    1f42:	5c9b      	ldrb	r3, [r3, r2]
    1f44:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    1f46:	4a08      	ldr	r2, [pc, #32]	; (1f68 <Clock_Ip_DisableClockMonitor+0x40>)
    1f48:	9b03      	ldr	r3, [sp, #12]
    1f4a:	011b      	lsls	r3, r3, #4
    1f4c:	4413      	add	r3, r2
    1f4e:	3308      	adds	r3, #8
    1f50:	681b      	ldr	r3, [r3, #0]
    1f52:	9801      	ldr	r0, [sp, #4]
    1f54:	4798      	blx	r3
}
    1f56:	bf00      	nop
    1f58:	b005      	add	sp, #20
    1f5a:	f85d fb04 	ldr.w	pc, [sp], #4
    1f5e:	bf00      	nop
    1f60:	0000bf68 	.word	0x0000bf68
    1f64:	0000bf58 	.word	0x0000bf58
    1f68:	0000c564 	.word	0x0000c564

00001f6c <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    1f6c:	b082      	sub	sp, #8
    1f6e:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    1f70:	4a02      	ldr	r2, [pc, #8]	; (1f7c <Clock_Ip_InstallNotificationsCallback+0x10>)
    1f72:	9b01      	ldr	r3, [sp, #4]
    1f74:	6013      	str	r3, [r2, #0]
}
    1f76:	bf00      	nop
    1f78:	b002      	add	sp, #8
    1f7a:	4770      	bx	lr
    1f7c:	1fff8b1c 	.word	0x1fff8b1c

00001f80 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    1f80:	b500      	push	{lr}
    1f82:	b085      	sub	sp, #20
    1f84:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1f86:	490c      	ldr	r1, [pc, #48]	; (1fb8 <Clock_Ip_DisableModuleClock+0x38>)
    1f88:	9a01      	ldr	r2, [sp, #4]
    1f8a:	4613      	mov	r3, r2
    1f8c:	00db      	lsls	r3, r3, #3
    1f8e:	4413      	add	r3, r2
    1f90:	440b      	add	r3, r1
    1f92:	3301      	adds	r3, #1
    1f94:	781b      	ldrb	r3, [r3, #0]
    1f96:	461a      	mov	r2, r3
    1f98:	4b08      	ldr	r3, [pc, #32]	; (1fbc <Clock_Ip_DisableModuleClock+0x3c>)
    1f9a:	5c9b      	ldrb	r3, [r3, r2]
    1f9c:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    1f9e:	4a08      	ldr	r2, [pc, #32]	; (1fc0 <Clock_Ip_DisableModuleClock+0x40>)
    1fa0:	9b03      	ldr	r3, [sp, #12]
    1fa2:	00db      	lsls	r3, r3, #3
    1fa4:	4413      	add	r3, r2
    1fa6:	685b      	ldr	r3, [r3, #4]
    1fa8:	2101      	movs	r1, #1
    1faa:	9801      	ldr	r0, [sp, #4]
    1fac:	4798      	blx	r3
}
    1fae:	bf00      	nop
    1fb0:	b005      	add	sp, #20
    1fb2:	f85d fb04 	ldr.w	pc, [sp], #4
    1fb6:	bf00      	nop
    1fb8:	0000bf68 	.word	0x0000bf68
    1fbc:	0000bf08 	.word	0x0000bf08
    1fc0:	0000c4f0 	.word	0x0000c4f0

00001fc4 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    1fc4:	b500      	push	{lr}
    1fc6:	b085      	sub	sp, #20
    1fc8:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1fca:	490c      	ldr	r1, [pc, #48]	; (1ffc <Clock_Ip_EnableModuleClock+0x38>)
    1fcc:	9a01      	ldr	r2, [sp, #4]
    1fce:	4613      	mov	r3, r2
    1fd0:	00db      	lsls	r3, r3, #3
    1fd2:	4413      	add	r3, r2
    1fd4:	440b      	add	r3, r1
    1fd6:	3301      	adds	r3, #1
    1fd8:	781b      	ldrb	r3, [r3, #0]
    1fda:	461a      	mov	r2, r3
    1fdc:	4b08      	ldr	r3, [pc, #32]	; (2000 <Clock_Ip_EnableModuleClock+0x3c>)
    1fde:	5c9b      	ldrb	r3, [r3, r2]
    1fe0:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    1fe2:	4a08      	ldr	r2, [pc, #32]	; (2004 <Clock_Ip_EnableModuleClock+0x40>)
    1fe4:	9b03      	ldr	r3, [sp, #12]
    1fe6:	00db      	lsls	r3, r3, #3
    1fe8:	4413      	add	r3, r2
    1fea:	685b      	ldr	r3, [r3, #4]
    1fec:	2100      	movs	r1, #0
    1fee:	9801      	ldr	r0, [sp, #4]
    1ff0:	4798      	blx	r3
}
    1ff2:	bf00      	nop
    1ff4:	b005      	add	sp, #20
    1ff6:	f85d fb04 	ldr.w	pc, [sp], #4
    1ffa:	bf00      	nop
    1ffc:	0000bf68 	.word	0x0000bf68
    2000:	0000bf08 	.word	0x0000bf08
    2004:	0000c4f0 	.word	0x0000c4f0

00002008 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    2008:	b500      	push	{lr}
    200a:	b083      	sub	sp, #12
    200c:	9001      	str	r0, [sp, #4]
    200e:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    2010:	4b08      	ldr	r3, [pc, #32]	; (2034 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    2012:	2200      	movs	r2, #0
    2014:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2016:	4b08      	ldr	r3, [pc, #32]	; (2038 <Clock_Ip_PowerModeChangeNotification+0x30>)
    2018:	681b      	ldr	r3, [r3, #0]
    201a:	2102      	movs	r1, #2
    201c:	4618      	mov	r0, r3
    201e:	f002 fd75 	bl	4b0c <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    2022:	9900      	ldr	r1, [sp, #0]
    2024:	9801      	ldr	r0, [sp, #4]
    2026:	f002 fc51 	bl	48cc <Clock_Ip_ClockPowerModeChangeNotification>
}
    202a:	bf00      	nop
    202c:	b003      	add	sp, #12
    202e:	f85d fb04 	ldr.w	pc, [sp], #4
    2032:	bf00      	nop
    2034:	1fff8b18 	.word	0x1fff8b18
    2038:	1fff8b44 	.word	0x1fff8b44

0000203c <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    203c:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    203e:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    2042:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    2044:	4b06      	ldr	r3, [pc, #24]	; (2060 <Clock_Ip_SetWaitStates+0x24>)
    2046:	785b      	ldrb	r3, [r3, #1]
    2048:	2b00      	cmp	r3, #0
    204a:	d005      	beq.n	2058 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    204c:	9b01      	ldr	r3, [sp, #4]
    204e:	3b01      	subs	r3, #1
    2050:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    2052:	9b01      	ldr	r3, [sp, #4]
    2054:	2b00      	cmp	r3, #0
    2056:	d1f9      	bne.n	204c <Clock_Ip_SetWaitStates+0x10>
    }
}
    2058:	bf00      	nop
    205a:	b002      	add	sp, #8
    205c:	4770      	bx	lr
    205e:	bf00      	nop
    2060:	1fff8b4c 	.word	0x1fff8b4c

00002064 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    2064:	b500      	push	{lr}
    2066:	b083      	sub	sp, #12
    2068:	9001      	str	r0, [sp, #4]
    206a:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    206c:	4b04      	ldr	r3, [pc, #16]	; (2080 <Clock_Ip_ReportClockErrors+0x1c>)
    206e:	681b      	ldr	r3, [r3, #0]
    2070:	9900      	ldr	r1, [sp, #0]
    2072:	9801      	ldr	r0, [sp, #4]
    2074:	4798      	blx	r3
}
    2076:	bf00      	nop
    2078:	b003      	add	sp, #12
    207a:	f85d fb04 	ldr.w	pc, [sp], #4
    207e:	bf00      	nop
    2080:	1fff8b1c 	.word	0x1fff8b1c

00002084 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    2084:	b500      	push	{lr}
    2086:	b085      	sub	sp, #20
    2088:	9003      	str	r0, [sp, #12]
    208a:	9102      	str	r1, [sp, #8]
    208c:	9201      	str	r2, [sp, #4]
    208e:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    2090:	2000      	movs	r0, #0
    2092:	f7fe ffd0 	bl	1036 <OsIf_GetCounter>
    2096:	4602      	mov	r2, r0
    2098:	9b03      	ldr	r3, [sp, #12]
    209a:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    209c:	9b02      	ldr	r3, [sp, #8]
    209e:	2200      	movs	r2, #0
    20a0:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    20a2:	2100      	movs	r1, #0
    20a4:	9800      	ldr	r0, [sp, #0]
    20a6:	f7ff f812 	bl	10ce <OsIf_MicrosToTicks>
    20aa:	4602      	mov	r2, r0
    20ac:	9b01      	ldr	r3, [sp, #4]
    20ae:	601a      	str	r2, [r3, #0]
}
    20b0:	bf00      	nop
    20b2:	b005      	add	sp, #20
    20b4:	f85d fb04 	ldr.w	pc, [sp], #4

000020b8 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    20b8:	b500      	push	{lr}
    20ba:	b087      	sub	sp, #28
    20bc:	9003      	str	r0, [sp, #12]
    20be:	9102      	str	r1, [sp, #8]
    20c0:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    20c2:	2300      	movs	r3, #0
    20c4:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    20c8:	2100      	movs	r1, #0
    20ca:	9803      	ldr	r0, [sp, #12]
    20cc:	f7fe ffcc 	bl	1068 <OsIf_GetElapsed>
    20d0:	4602      	mov	r2, r0
    20d2:	9b02      	ldr	r3, [sp, #8]
    20d4:	681b      	ldr	r3, [r3, #0]
    20d6:	441a      	add	r2, r3
    20d8:	9b02      	ldr	r3, [sp, #8]
    20da:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    20dc:	9b02      	ldr	r3, [sp, #8]
    20de:	681b      	ldr	r3, [r3, #0]
    20e0:	9a01      	ldr	r2, [sp, #4]
    20e2:	429a      	cmp	r2, r3
    20e4:	d802      	bhi.n	20ec <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    20e6:	2301      	movs	r3, #1
    20e8:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    20ec:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    20f0:	4618      	mov	r0, r3
    20f2:	b007      	add	sp, #28
    20f4:	f85d fb04 	ldr.w	pc, [sp], #4

000020f8 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    20f8:	b082      	sub	sp, #8
    20fa:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    20fc:	bf00      	nop
    20fe:	b002      	add	sp, #8
    2100:	4770      	bx	lr

00002102 <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    2102:	b500      	push	{lr}
    2104:	b083      	sub	sp, #12
    2106:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2108:	9b01      	ldr	r3, [sp, #4]
    210a:	2b00      	cmp	r3, #0
    210c:	d002      	beq.n	2114 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    210e:	9801      	ldr	r0, [sp, #4]
    2110:	f000 f8ad 	bl	226e <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2114:	bf00      	nop
    2116:	b003      	add	sp, #12
    2118:	f85d fb04 	ldr.w	pc, [sp], #4

0000211c <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    211c:	b500      	push	{lr}
    211e:	b083      	sub	sp, #12
    2120:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2122:	9b01      	ldr	r3, [sp, #4]
    2124:	2b00      	cmp	r3, #0
    2126:	d002      	beq.n	212e <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    2128:	9801      	ldr	r0, [sp, #4]
    212a:	f000 f8cd 	bl	22c8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    212e:	bf00      	nop
    2130:	b003      	add	sp, #12
    2132:	f85d fb04 	ldr.w	pc, [sp], #4

00002136 <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2136:	b500      	push	{lr}
    2138:	b083      	sub	sp, #12
    213a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    213c:	9b01      	ldr	r3, [sp, #4]
    213e:	2b00      	cmp	r3, #0
    2140:	d002      	beq.n	2148 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    2142:	9801      	ldr	r0, [sp, #4]
    2144:	f000 f8ee 	bl	2324 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2148:	bf00      	nop
    214a:	b003      	add	sp, #12
    214c:	f85d fb04 	ldr.w	pc, [sp], #4

00002150 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2150:	b500      	push	{lr}
    2152:	b083      	sub	sp, #12
    2154:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2156:	9b01      	ldr	r3, [sp, #4]
    2158:	2b00      	cmp	r3, #0
    215a:	d002      	beq.n	2162 <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    215c:	9801      	ldr	r0, [sp, #4]
    215e:	f000 f8f9 	bl	2354 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2162:	bf00      	nop
    2164:	b003      	add	sp, #12
    2166:	f85d fb04 	ldr.w	pc, [sp], #4

0000216a <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    216a:	b500      	push	{lr}
    216c:	b083      	sub	sp, #12
    216e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2170:	9b01      	ldr	r3, [sp, #4]
    2172:	2b00      	cmp	r3, #0
    2174:	d002      	beq.n	217c <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    2176:	9801      	ldr	r0, [sp, #4]
    2178:	f000 f904 	bl	2384 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    217c:	bf00      	nop
    217e:	b003      	add	sp, #12
    2180:	f85d fb04 	ldr.w	pc, [sp], #4

00002184 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2184:	b500      	push	{lr}
    2186:	b083      	sub	sp, #12
    2188:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    218a:	9b01      	ldr	r3, [sp, #4]
    218c:	2b00      	cmp	r3, #0
    218e:	d002      	beq.n	2196 <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    2190:	9801      	ldr	r0, [sp, #4]
    2192:	f000 f90f 	bl	23b4 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2196:	bf00      	nop
    2198:	b003      	add	sp, #12
    219a:	f85d fb04 	ldr.w	pc, [sp], #4

0000219e <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    219e:	b500      	push	{lr}
    21a0:	b083      	sub	sp, #12
    21a2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21a4:	9b01      	ldr	r3, [sp, #4]
    21a6:	2b00      	cmp	r3, #0
    21a8:	d002      	beq.n	21b0 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    21aa:	9801      	ldr	r0, [sp, #4]
    21ac:	f000 f91a 	bl	23e4 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21b0:	bf00      	nop
    21b2:	b003      	add	sp, #12
    21b4:	f85d fb04 	ldr.w	pc, [sp], #4

000021b8 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    21b8:	b500      	push	{lr}
    21ba:	b083      	sub	sp, #12
    21bc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21be:	9b01      	ldr	r3, [sp, #4]
    21c0:	2b00      	cmp	r3, #0
    21c2:	d002      	beq.n	21ca <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    21c4:	9801      	ldr	r0, [sp, #4]
    21c6:	f000 f925 	bl	2414 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21ca:	bf00      	nop
    21cc:	b003      	add	sp, #12
    21ce:	f85d fb04 	ldr.w	pc, [sp], #4

000021d2 <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    21d2:	b500      	push	{lr}
    21d4:	b083      	sub	sp, #12
    21d6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21d8:	9b01      	ldr	r3, [sp, #4]
    21da:	2b00      	cmp	r3, #0
    21dc:	d002      	beq.n	21e4 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    21de:	9801      	ldr	r0, [sp, #4]
    21e0:	f000 f930 	bl	2444 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21e4:	bf00      	nop
    21e6:	b003      	add	sp, #12
    21e8:	f85d fb04 	ldr.w	pc, [sp], #4

000021ec <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    21ec:	b500      	push	{lr}
    21ee:	b083      	sub	sp, #12
    21f0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21f2:	9b01      	ldr	r3, [sp, #4]
    21f4:	2b00      	cmp	r3, #0
    21f6:	d002      	beq.n	21fe <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    21f8:	9801      	ldr	r0, [sp, #4]
    21fa:	f000 f93b 	bl	2474 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21fe:	bf00      	nop
    2200:	b003      	add	sp, #12
    2202:	f85d fb04 	ldr.w	pc, [sp], #4

00002206 <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2206:	b500      	push	{lr}
    2208:	b083      	sub	sp, #12
    220a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    220c:	9b01      	ldr	r3, [sp, #4]
    220e:	2b00      	cmp	r3, #0
    2210:	d002      	beq.n	2218 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    2212:	9801      	ldr	r0, [sp, #4]
    2214:	f000 f946 	bl	24a4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2218:	bf00      	nop
    221a:	b003      	add	sp, #12
    221c:	f85d fb04 	ldr.w	pc, [sp], #4

00002220 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    2220:	b500      	push	{lr}
    2222:	b083      	sub	sp, #12
    2224:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2226:	9b01      	ldr	r3, [sp, #4]
    2228:	2b00      	cmp	r3, #0
    222a:	d002      	beq.n	2232 <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    222c:	9801      	ldr	r0, [sp, #4]
    222e:	f000 f951 	bl	24d4 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2232:	bf00      	nop
    2234:	b003      	add	sp, #12
    2236:	f85d fb04 	ldr.w	pc, [sp], #4

0000223a <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    223a:	b500      	push	{lr}
    223c:	b083      	sub	sp, #12
    223e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2240:	9b01      	ldr	r3, [sp, #4]
    2242:	2b00      	cmp	r3, #0
    2244:	d002      	beq.n	224c <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    2246:	9801      	ldr	r0, [sp, #4]
    2248:	f000 f95e 	bl	2508 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    224c:	bf00      	nop
    224e:	b003      	add	sp, #12
    2250:	f85d fb04 	ldr.w	pc, [sp], #4

00002254 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    2254:	b500      	push	{lr}
    2256:	b083      	sub	sp, #12
    2258:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    225a:	9b01      	ldr	r3, [sp, #4]
    225c:	2b00      	cmp	r3, #0
    225e:	d002      	beq.n	2266 <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    2260:	9801      	ldr	r0, [sp, #4]
    2262:	f000 f98b 	bl	257c <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2266:	bf00      	nop
    2268:	b003      	add	sp, #12
    226a:	f85d fb04 	ldr.w	pc, [sp], #4

0000226e <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    226e:	b086      	sub	sp, #24
    2270:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2272:	9b01      	ldr	r3, [sp, #4]
    2274:	681a      	ldr	r2, [r3, #0]
    2276:	4911      	ldr	r1, [pc, #68]	; (22bc <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    2278:	4613      	mov	r3, r2
    227a:	00db      	lsls	r3, r3, #3
    227c:	4413      	add	r3, r2
    227e:	440b      	add	r3, r1
    2280:	781b      	ldrb	r3, [r3, #0]
    2282:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    2284:	9b01      	ldr	r3, [sp, #4]
    2286:	685b      	ldr	r3, [r3, #4]
    2288:	4a0d      	ldr	r2, [pc, #52]	; (22c0 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    228a:	5cd3      	ldrb	r3, [r2, r3]
    228c:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    228e:	4a0d      	ldr	r2, [pc, #52]	; (22c4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    2290:	9b05      	ldr	r3, [sp, #20]
    2292:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2296:	681b      	ldr	r3, [r3, #0]
    2298:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    229a:	9b03      	ldr	r3, [sp, #12]
    229c:	f023 0307 	bic.w	r3, r3, #7
    22a0:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    22a2:	9a03      	ldr	r2, [sp, #12]
    22a4:	9b04      	ldr	r3, [sp, #16]
    22a6:	4313      	orrs	r3, r2
    22a8:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    22aa:	4a06      	ldr	r2, [pc, #24]	; (22c4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    22ac:	9b05      	ldr	r3, [sp, #20]
    22ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22b2:	9a03      	ldr	r2, [sp, #12]
    22b4:	601a      	str	r2, [r3, #0]
}
    22b6:	bf00      	nop
    22b8:	b006      	add	sp, #24
    22ba:	4770      	bx	lr
    22bc:	0000bf68 	.word	0x0000bf68
    22c0:	0000c360 	.word	0x0000c360
    22c4:	0000c3a4 	.word	0x0000c3a4

000022c8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    22c8:	b086      	sub	sp, #24
    22ca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    22cc:	9b01      	ldr	r3, [sp, #4]
    22ce:	681a      	ldr	r2, [r3, #0]
    22d0:	4911      	ldr	r1, [pc, #68]	; (2318 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    22d2:	4613      	mov	r3, r2
    22d4:	00db      	lsls	r3, r3, #3
    22d6:	4413      	add	r3, r2
    22d8:	440b      	add	r3, r1
    22da:	781b      	ldrb	r3, [r3, #0]
    22dc:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    22de:	9b01      	ldr	r3, [sp, #4]
    22e0:	685b      	ldr	r3, [r3, #4]
    22e2:	4a0e      	ldr	r2, [pc, #56]	; (231c <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    22e4:	5cd3      	ldrb	r3, [r2, r3]
    22e6:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    22e8:	4a0d      	ldr	r2, [pc, #52]	; (2320 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    22ea:	9b05      	ldr	r3, [sp, #20]
    22ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    22f0:	681b      	ldr	r3, [r3, #0]
    22f2:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    22f4:	9b03      	ldr	r3, [sp, #12]
    22f6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    22fa:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    22fc:	9b04      	ldr	r3, [sp, #16]
    22fe:	021b      	lsls	r3, r3, #8
    2300:	9a03      	ldr	r2, [sp, #12]
    2302:	4313      	orrs	r3, r2
    2304:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    2306:	4a06      	ldr	r2, [pc, #24]	; (2320 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    2308:	9b05      	ldr	r3, [sp, #20]
    230a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    230e:	9a03      	ldr	r2, [sp, #12]
    2310:	601a      	str	r2, [r3, #0]
}
    2312:	bf00      	nop
    2314:	b006      	add	sp, #24
    2316:	4770      	bx	lr
    2318:	0000bf68 	.word	0x0000bf68
    231c:	0000c360 	.word	0x0000c360
    2320:	0000c3a4 	.word	0x0000c3a4

00002324 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2324:	b084      	sub	sp, #16
    2326:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2328:	4b09      	ldr	r3, [pc, #36]	; (2350 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    232a:	695b      	ldr	r3, [r3, #20]
    232c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    232e:	9b03      	ldr	r3, [sp, #12]
    2330:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2334:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    2336:	9b01      	ldr	r3, [sp, #4]
    2338:	685b      	ldr	r3, [r3, #4]
    233a:	3b01      	subs	r3, #1
    233c:	041b      	lsls	r3, r3, #16
    233e:	9a03      	ldr	r2, [sp, #12]
    2340:	4313      	orrs	r3, r2
    2342:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2344:	4a02      	ldr	r2, [pc, #8]	; (2350 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    2346:	9b03      	ldr	r3, [sp, #12]
    2348:	6153      	str	r3, [r2, #20]
}
    234a:	bf00      	nop
    234c:	b004      	add	sp, #16
    234e:	4770      	bx	lr
    2350:	40064000 	.word	0x40064000

00002354 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2354:	b084      	sub	sp, #16
    2356:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2358:	4b09      	ldr	r3, [pc, #36]	; (2380 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    235a:	695b      	ldr	r3, [r3, #20]
    235c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    235e:	9b03      	ldr	r3, [sp, #12]
    2360:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2364:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    2366:	9b01      	ldr	r3, [sp, #4]
    2368:	685b      	ldr	r3, [r3, #4]
    236a:	3b01      	subs	r3, #1
    236c:	011b      	lsls	r3, r3, #4
    236e:	9a03      	ldr	r2, [sp, #12]
    2370:	4313      	orrs	r3, r2
    2372:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    2374:	4a02      	ldr	r2, [pc, #8]	; (2380 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    2376:	9b03      	ldr	r3, [sp, #12]
    2378:	6153      	str	r3, [r2, #20]
}
    237a:	bf00      	nop
    237c:	b004      	add	sp, #16
    237e:	4770      	bx	lr
    2380:	40064000 	.word	0x40064000

00002384 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2384:	b084      	sub	sp, #16
    2386:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    2388:	4b09      	ldr	r3, [pc, #36]	; (23b0 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    238a:	695b      	ldr	r3, [r3, #20]
    238c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    238e:	9b03      	ldr	r3, [sp, #12]
    2390:	f023 030f 	bic.w	r3, r3, #15
    2394:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    2396:	9b01      	ldr	r3, [sp, #4]
    2398:	685b      	ldr	r3, [r3, #4]
    239a:	3b01      	subs	r3, #1
    239c:	9a03      	ldr	r2, [sp, #12]
    239e:	4313      	orrs	r3, r2
    23a0:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    23a2:	4a03      	ldr	r2, [pc, #12]	; (23b0 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    23a4:	9b03      	ldr	r3, [sp, #12]
    23a6:	6153      	str	r3, [r2, #20]
}
    23a8:	bf00      	nop
    23aa:	b004      	add	sp, #16
    23ac:	4770      	bx	lr
    23ae:	bf00      	nop
    23b0:	40064000 	.word	0x40064000

000023b4 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    23b4:	b084      	sub	sp, #16
    23b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    23b8:	4b09      	ldr	r3, [pc, #36]	; (23e0 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    23ba:	699b      	ldr	r3, [r3, #24]
    23bc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    23be:	9b03      	ldr	r3, [sp, #12]
    23c0:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    23c4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    23c6:	9b01      	ldr	r3, [sp, #4]
    23c8:	685b      	ldr	r3, [r3, #4]
    23ca:	3b01      	subs	r3, #1
    23cc:	041b      	lsls	r3, r3, #16
    23ce:	9a03      	ldr	r2, [sp, #12]
    23d0:	4313      	orrs	r3, r2
    23d2:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    23d4:	4a02      	ldr	r2, [pc, #8]	; (23e0 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    23d6:	9b03      	ldr	r3, [sp, #12]
    23d8:	6193      	str	r3, [r2, #24]
}
    23da:	bf00      	nop
    23dc:	b004      	add	sp, #16
    23de:	4770      	bx	lr
    23e0:	40064000 	.word	0x40064000

000023e4 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    23e4:	b084      	sub	sp, #16
    23e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    23e8:	4b09      	ldr	r3, [pc, #36]	; (2410 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    23ea:	699b      	ldr	r3, [r3, #24]
    23ec:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    23ee:	9b03      	ldr	r3, [sp, #12]
    23f0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    23f4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    23f6:	9b01      	ldr	r3, [sp, #4]
    23f8:	685b      	ldr	r3, [r3, #4]
    23fa:	3b01      	subs	r3, #1
    23fc:	011b      	lsls	r3, r3, #4
    23fe:	9a03      	ldr	r2, [sp, #12]
    2400:	4313      	orrs	r3, r2
    2402:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2404:	4a02      	ldr	r2, [pc, #8]	; (2410 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    2406:	9b03      	ldr	r3, [sp, #12]
    2408:	6193      	str	r3, [r2, #24]
}
    240a:	bf00      	nop
    240c:	b004      	add	sp, #16
    240e:	4770      	bx	lr
    2410:	40064000 	.word	0x40064000

00002414 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2414:	b084      	sub	sp, #16
    2416:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    2418:	4b09      	ldr	r3, [pc, #36]	; (2440 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    241a:	699b      	ldr	r3, [r3, #24]
    241c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    241e:	9b03      	ldr	r3, [sp, #12]
    2420:	f023 030f 	bic.w	r3, r3, #15
    2424:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    2426:	9b01      	ldr	r3, [sp, #4]
    2428:	685b      	ldr	r3, [r3, #4]
    242a:	3b01      	subs	r3, #1
    242c:	9a03      	ldr	r2, [sp, #12]
    242e:	4313      	orrs	r3, r2
    2430:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    2432:	4a03      	ldr	r2, [pc, #12]	; (2440 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    2434:	9b03      	ldr	r3, [sp, #12]
    2436:	6193      	str	r3, [r2, #24]
}
    2438:	bf00      	nop
    243a:	b004      	add	sp, #16
    243c:	4770      	bx	lr
    243e:	bf00      	nop
    2440:	40064000 	.word	0x40064000

00002444 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2444:	b084      	sub	sp, #16
    2446:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2448:	4b09      	ldr	r3, [pc, #36]	; (2470 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    244a:	69db      	ldr	r3, [r3, #28]
    244c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    244e:	9b03      	ldr	r3, [sp, #12]
    2450:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    2454:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    2456:	9b01      	ldr	r3, [sp, #4]
    2458:	685b      	ldr	r3, [r3, #4]
    245a:	3b01      	subs	r3, #1
    245c:	041b      	lsls	r3, r3, #16
    245e:	9a03      	ldr	r2, [sp, #12]
    2460:	4313      	orrs	r3, r2
    2462:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    2464:	4a02      	ldr	r2, [pc, #8]	; (2470 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    2466:	9b03      	ldr	r3, [sp, #12]
    2468:	61d3      	str	r3, [r2, #28]
}
    246a:	bf00      	nop
    246c:	b004      	add	sp, #16
    246e:	4770      	bx	lr
    2470:	40064000 	.word	0x40064000

00002474 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2474:	b084      	sub	sp, #16
    2476:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2478:	4b09      	ldr	r3, [pc, #36]	; (24a0 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    247a:	69db      	ldr	r3, [r3, #28]
    247c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    247e:	9b03      	ldr	r3, [sp, #12]
    2480:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    2484:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    2486:	9b01      	ldr	r3, [sp, #4]
    2488:	685b      	ldr	r3, [r3, #4]
    248a:	3b01      	subs	r3, #1
    248c:	011b      	lsls	r3, r3, #4
    248e:	9a03      	ldr	r2, [sp, #12]
    2490:	4313      	orrs	r3, r2
    2492:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    2494:	4a02      	ldr	r2, [pc, #8]	; (24a0 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    2496:	9b03      	ldr	r3, [sp, #12]
    2498:	61d3      	str	r3, [r2, #28]
}
    249a:	bf00      	nop
    249c:	b004      	add	sp, #16
    249e:	4770      	bx	lr
    24a0:	40064000 	.word	0x40064000

000024a4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    24a4:	b084      	sub	sp, #16
    24a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    24a8:	4b09      	ldr	r3, [pc, #36]	; (24d0 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    24aa:	69db      	ldr	r3, [r3, #28]
    24ac:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    24ae:	9b03      	ldr	r3, [sp, #12]
    24b0:	f023 030f 	bic.w	r3, r3, #15
    24b4:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    24b6:	9b01      	ldr	r3, [sp, #4]
    24b8:	685b      	ldr	r3, [r3, #4]
    24ba:	3b01      	subs	r3, #1
    24bc:	9a03      	ldr	r2, [sp, #12]
    24be:	4313      	orrs	r3, r2
    24c0:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    24c2:	4a03      	ldr	r2, [pc, #12]	; (24d0 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    24c4:	9b03      	ldr	r3, [sp, #12]
    24c6:	61d3      	str	r3, [r2, #28]
}
    24c8:	bf00      	nop
    24ca:	b004      	add	sp, #16
    24cc:	4770      	bx	lr
    24ce:	bf00      	nop
    24d0:	40064000 	.word	0x40064000

000024d4 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    24d4:	b084      	sub	sp, #16
    24d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    24d8:	4b0a      	ldr	r3, [pc, #40]	; (2504 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    24da:	685b      	ldr	r3, [r3, #4]
    24dc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    24de:	9b03      	ldr	r3, [sp, #12]
    24e0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    24e4:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    24e6:	9b01      	ldr	r3, [sp, #4]
    24e8:	685b      	ldr	r3, [r3, #4]
    24ea:	3b01      	subs	r3, #1
    24ec:	021b      	lsls	r3, r3, #8
    24ee:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    24f2:	9a03      	ldr	r2, [sp, #12]
    24f4:	4313      	orrs	r3, r2
    24f6:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    24f8:	4a02      	ldr	r2, [pc, #8]	; (2504 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    24fa:	9b03      	ldr	r3, [sp, #12]
    24fc:	6053      	str	r3, [r2, #4]
}
    24fe:	bf00      	nop
    2500:	b004      	add	sp, #16
    2502:	4770      	bx	lr
    2504:	40048000 	.word	0x40048000

00002508 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2508:	b084      	sub	sp, #16
    250a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    250c:	4919      	ldr	r1, [pc, #100]	; (2574 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    250e:	9b01      	ldr	r3, [sp, #4]
    2510:	681a      	ldr	r2, [r3, #0]
    2512:	4819      	ldr	r0, [pc, #100]	; (2578 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2514:	4613      	mov	r3, r2
    2516:	00db      	lsls	r3, r3, #3
    2518:	4413      	add	r3, r2
    251a:	4403      	add	r3, r0
    251c:	3305      	adds	r3, #5
    251e:	781b      	ldrb	r3, [r3, #0]
    2520:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    2524:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    2526:	9b03      	ldr	r3, [sp, #12]
    2528:	f023 030f 	bic.w	r3, r3, #15
    252c:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    252e:	9b01      	ldr	r3, [sp, #4]
    2530:	685b      	ldr	r3, [r3, #4]
    2532:	3b01      	subs	r3, #1
    2534:	f003 0307 	and.w	r3, r3, #7
    2538:	9a03      	ldr	r2, [sp, #12]
    253a:	4313      	orrs	r3, r2
    253c:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    253e:	9b01      	ldr	r3, [sp, #4]
    2540:	7a1b      	ldrb	r3, [r3, #8]
    2542:	3b01      	subs	r3, #1
    2544:	00db      	lsls	r3, r3, #3
    2546:	f003 0308 	and.w	r3, r3, #8
    254a:	9a03      	ldr	r2, [sp, #12]
    254c:	4313      	orrs	r3, r2
    254e:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    2550:	4908      	ldr	r1, [pc, #32]	; (2574 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    2552:	9b01      	ldr	r3, [sp, #4]
    2554:	681a      	ldr	r2, [r3, #0]
    2556:	4808      	ldr	r0, [pc, #32]	; (2578 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2558:	4613      	mov	r3, r2
    255a:	00db      	lsls	r3, r3, #3
    255c:	4413      	add	r3, r2
    255e:	4403      	add	r3, r0
    2560:	3305      	adds	r3, #5
    2562:	781b      	ldrb	r3, [r3, #0]
    2564:	461a      	mov	r2, r3
    2566:	9b03      	ldr	r3, [sp, #12]
    2568:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    256c:	bf00      	nop
    256e:	b004      	add	sp, #16
    2570:	4770      	bx	lr
    2572:	bf00      	nop
    2574:	40065000 	.word	0x40065000
    2578:	0000bf68 	.word	0x0000bf68

0000257c <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    257c:	b084      	sub	sp, #16
    257e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    2580:	4b10      	ldr	r3, [pc, #64]	; (25c4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2582:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2584:	4a0f      	ldr	r2, [pc, #60]	; (25c4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2586:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    258a:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    258c:	4b0d      	ldr	r3, [pc, #52]	; (25c4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    258e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2590:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    2592:	9b03      	ldr	r3, [sp, #12]
    2594:	f023 030f 	bic.w	r3, r3, #15
    2598:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    259a:	9b01      	ldr	r3, [sp, #4]
    259c:	685b      	ldr	r3, [r3, #4]
    259e:	3b01      	subs	r3, #1
    25a0:	005b      	lsls	r3, r3, #1
    25a2:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    25a6:	9b01      	ldr	r3, [sp, #4]
    25a8:	7a1b      	ldrb	r3, [r3, #8]
    25aa:	3b01      	subs	r3, #1
    25ac:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    25b0:	4313      	orrs	r3, r2
    25b2:	9a03      	ldr	r2, [sp, #12]
    25b4:	4313      	orrs	r3, r2
    25b6:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    25b8:	4a02      	ldr	r2, [pc, #8]	; (25c4 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    25ba:	9b03      	ldr	r3, [sp, #12]
    25bc:	6693      	str	r3, [r2, #104]	; 0x68
}
    25be:	bf00      	nop
    25c0:	b004      	add	sp, #16
    25c2:	4770      	bx	lr
    25c4:	40048000 	.word	0x40048000

000025c8 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    25c8:	b082      	sub	sp, #8
    25ca:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    25cc:	bf00      	nop
    25ce:	b002      	add	sp, #8
    25d0:	4770      	bx	lr
	...

000025d4 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    25d4:	b082      	sub	sp, #8
    25d6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    25d8:	bf00      	nop
    25da:	b002      	add	sp, #8
    25dc:	4770      	bx	lr

000025de <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    25de:	b082      	sub	sp, #8
    25e0:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    25e2:	bf00      	nop
    25e4:	b002      	add	sp, #8
    25e6:	4770      	bx	lr

000025e8 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    25e8:	b500      	push	{lr}
    25ea:	b083      	sub	sp, #12
    25ec:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    25ee:	9b01      	ldr	r3, [sp, #4]
    25f0:	2b00      	cmp	r3, #0
    25f2:	d002      	beq.n	25fa <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    25f4:	9801      	ldr	r0, [sp, #4]
    25f6:	f000 f86a 	bl	26ce <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    25fa:	bf00      	nop
    25fc:	b003      	add	sp, #12
    25fe:	f85d fb04 	ldr.w	pc, [sp], #4

00002602 <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    2602:	b500      	push	{lr}
    2604:	b083      	sub	sp, #12
    2606:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2608:	9b01      	ldr	r3, [sp, #4]
    260a:	2b00      	cmp	r3, #0
    260c:	d002      	beq.n	2614 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    260e:	9801      	ldr	r0, [sp, #4]
    2610:	f000 f884 	bl	271c <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    2614:	bf00      	nop
    2616:	b003      	add	sp, #12
    2618:	f85d fb04 	ldr.w	pc, [sp], #4

0000261c <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    261c:	b500      	push	{lr}
    261e:	b089      	sub	sp, #36	; 0x24
    2620:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2622:	2300      	movs	r3, #0
    2624:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    2628:	9b01      	ldr	r3, [sp, #4]
    262a:	2b00      	cmp	r3, #0
    262c:	d031      	beq.n	2692 <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    262e:	4b1b      	ldr	r3, [pc, #108]	; (269c <Clock_Ip_CompleteSOSC+0x80>)
    2630:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2634:	f003 0301 	and.w	r3, r3, #1
    2638:	2b00      	cmp	r3, #0
    263a:	d02a      	beq.n	2692 <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    263c:	aa03      	add	r2, sp, #12
    263e:	a904      	add	r1, sp, #16
    2640:	a805      	add	r0, sp, #20
    2642:	f24c 3350 	movw	r3, #50000	; 0xc350
    2646:	f7ff fd1d 	bl	2084 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    264a:	4b14      	ldr	r3, [pc, #80]	; (269c <Clock_Ip_CompleteSOSC+0x80>)
    264c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2650:	0e1b      	lsrs	r3, r3, #24
    2652:	f003 0301 	and.w	r3, r3, #1
    2656:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2658:	9a03      	ldr	r2, [sp, #12]
    265a:	a904      	add	r1, sp, #16
    265c:	ab05      	add	r3, sp, #20
    265e:	4618      	mov	r0, r3
    2660:	f7ff fd2a 	bl	20b8 <Clock_Ip_TimeoutExpired>
    2664:	4603      	mov	r3, r0
    2666:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    266a:	9b06      	ldr	r3, [sp, #24]
    266c:	2b00      	cmp	r3, #0
    266e:	d106      	bne.n	267e <Clock_Ip_CompleteSOSC+0x62>
    2670:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2674:	f083 0301 	eor.w	r3, r3, #1
    2678:	b2db      	uxtb	r3, r3
    267a:	2b00      	cmp	r3, #0
    267c:	d1e5      	bne.n	264a <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    267e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2682:	2b00      	cmp	r3, #0
    2684:	d005      	beq.n	2692 <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2686:	9b01      	ldr	r3, [sp, #4]
    2688:	681b      	ldr	r3, [r3, #0]
    268a:	4619      	mov	r1, r3
    268c:	2001      	movs	r0, #1
    268e:	f7ff fce9 	bl	2064 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    2692:	bf00      	nop
    2694:	b009      	add	sp, #36	; 0x24
    2696:	f85d fb04 	ldr.w	pc, [sp], #4
    269a:	bf00      	nop
    269c:	40064000 	.word	0x40064000

000026a0 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    26a0:	b500      	push	{lr}
    26a2:	b083      	sub	sp, #12
    26a4:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    26a6:	9801      	ldr	r0, [sp, #4]
    26a8:	f000 f8c0 	bl	282c <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    26ac:	bf00      	nop
    26ae:	b003      	add	sp, #12
    26b0:	f85d fb04 	ldr.w	pc, [sp], #4

000026b4 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    26b4:	b500      	push	{lr}
    26b6:	b083      	sub	sp, #12
    26b8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    26ba:	9b01      	ldr	r3, [sp, #4]
    26bc:	2b00      	cmp	r3, #0
    26be:	d002      	beq.n	26c6 <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    26c0:	9801      	ldr	r0, [sp, #4]
    26c2:	f000 f8c3 	bl	284c <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    26c6:	bf00      	nop
    26c8:	b003      	add	sp, #12
    26ca:	f85d fb04 	ldr.w	pc, [sp], #4

000026ce <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    26ce:	b082      	sub	sp, #8
    26d0:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    26d2:	4b11      	ldr	r3, [pc, #68]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26d4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    26d8:	4a0f      	ldr	r2, [pc, #60]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26da:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    26de:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    26e2:	4b0d      	ldr	r3, [pc, #52]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26e4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    26e8:	4a0b      	ldr	r2, [pc, #44]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26ea:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    26ee:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    26f2:	4b09      	ldr	r3, [pc, #36]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26f4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    26f8:	4a07      	ldr	r2, [pc, #28]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    26fa:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    26fe:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    2702:	4b05      	ldr	r3, [pc, #20]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2704:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2708:	4a03      	ldr	r2, [pc, #12]	; (2718 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    270a:	f023 0301 	bic.w	r3, r3, #1
    270e:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2712:	bf00      	nop
    2714:	b002      	add	sp, #8
    2716:	4770      	bx	lr
    2718:	40064000 	.word	0x40064000

0000271c <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    271c:	b082      	sub	sp, #8
    271e:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    2720:	9b01      	ldr	r3, [sp, #4]
    2722:	891b      	ldrh	r3, [r3, #8]
    2724:	2b01      	cmp	r3, #1
    2726:	d174      	bne.n	2812 <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    2728:	9b01      	ldr	r3, [sp, #4]
    272a:	7bdb      	ldrb	r3, [r3, #15]
    272c:	2b00      	cmp	r3, #0
    272e:	d002      	beq.n	2736 <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    2730:	2b01      	cmp	r3, #1
    2732:	d009      	beq.n	2748 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    2734:	e011      	b.n	275a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    2736:	4b39      	ldr	r3, [pc, #228]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2738:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    273c:	4a37      	ldr	r2, [pc, #220]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    273e:	f023 0308 	bic.w	r3, r3, #8
    2742:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2746:	e008      	b.n	275a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    2748:	4b34      	ldr	r3, [pc, #208]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    274a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    274e:	4a33      	ldr	r2, [pc, #204]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2750:	f043 0308 	orr.w	r3, r3, #8
    2754:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2758:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    275a:	4b30      	ldr	r3, [pc, #192]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    275c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2760:	4a2e      	ldr	r2, [pc, #184]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2762:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    2766:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    276a:	9b01      	ldr	r3, [sp, #4]
    276c:	685b      	ldr	r3, [r3, #4]
    276e:	4a2c      	ldr	r2, [pc, #176]	; (2820 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    2770:	4293      	cmp	r3, r2
    2772:	d90d      	bls.n	2790 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    2774:	9b01      	ldr	r3, [sp, #4]
    2776:	685b      	ldr	r3, [r3, #4]
    2778:	4a2a      	ldr	r2, [pc, #168]	; (2824 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    277a:	4293      	cmp	r3, r2
    277c:	d208      	bcs.n	2790 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    277e:	4b27      	ldr	r3, [pc, #156]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2780:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2784:	4a25      	ldr	r2, [pc, #148]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2786:	f043 0320 	orr.w	r3, r3, #32
    278a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    278e:	e007      	b.n	27a0 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    2790:	4b22      	ldr	r3, [pc, #136]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2792:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2796:	4a21      	ldr	r2, [pc, #132]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2798:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    279c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    27a0:	9b01      	ldr	r3, [sp, #4]
    27a2:	7b1b      	ldrb	r3, [r3, #12]
    27a4:	2b00      	cmp	r3, #0
    27a6:	d108      	bne.n	27ba <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    27a8:	4b1c      	ldr	r3, [pc, #112]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27aa:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27ae:	4a1b      	ldr	r2, [pc, #108]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27b0:	f043 0304 	orr.w	r3, r3, #4
    27b4:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    27b8:	e007      	b.n	27ca <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    27ba:	4b18      	ldr	r3, [pc, #96]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27bc:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    27c0:	4a16      	ldr	r2, [pc, #88]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27c2:	f023 0304 	bic.w	r3, r3, #4
    27c6:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    27ca:	9b01      	ldr	r3, [sp, #4]
    27cc:	7c1b      	ldrb	r3, [r3, #16]
    27ce:	2b02      	cmp	r3, #2
    27d0:	d011      	beq.n	27f6 <Clock_Ip_SetSOSC_TrustedCall+0xda>
    27d2:	2b02      	cmp	r3, #2
    27d4:	dc14      	bgt.n	2800 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    27d6:	2b00      	cmp	r3, #0
    27d8:	d002      	beq.n	27e0 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    27da:	2b01      	cmp	r3, #1
    27dc:	d005      	beq.n	27ea <Clock_Ip_SetSOSC_TrustedCall+0xce>
    27de:	e00f      	b.n	2800 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    27e0:	4b0e      	ldr	r3, [pc, #56]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27e2:	2201      	movs	r2, #1
    27e4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    27e8:	e014      	b.n	2814 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    27ea:	4b0c      	ldr	r3, [pc, #48]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27ec:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    27f0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    27f4:	e00e      	b.n	2814 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    27f6:	4b09      	ldr	r3, [pc, #36]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    27f8:	4a0b      	ldr	r2, [pc, #44]	; (2828 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    27fa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    27fe:	e009      	b.n	2814 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2800:	4b06      	ldr	r3, [pc, #24]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2802:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2806:	4a05      	ldr	r2, [pc, #20]	; (281c <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2808:	f043 0301 	orr.w	r3, r3, #1
    280c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    2810:	e000      	b.n	2814 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    2812:	bf00      	nop
}
    2814:	bf00      	nop
    2816:	b002      	add	sp, #8
    2818:	4770      	bx	lr
    281a:	bf00      	nop
    281c:	40064000 	.word	0x40064000
    2820:	003d08ff 	.word	0x003d08ff
    2824:	007a1200 	.word	0x007a1200
    2828:	00030001 	.word	0x00030001

0000282c <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    282c:	b082      	sub	sp, #8
    282e:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    2830:	4b05      	ldr	r3, [pc, #20]	; (2848 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2832:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2836:	4a04      	ldr	r2, [pc, #16]	; (2848 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2838:	f023 0301 	bic.w	r3, r3, #1
    283c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2840:	bf00      	nop
    2842:	b002      	add	sp, #8
    2844:	4770      	bx	lr
    2846:	bf00      	nop
    2848:	40064000 	.word	0x40064000

0000284c <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    284c:	b082      	sub	sp, #8
    284e:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2850:	9b01      	ldr	r3, [sp, #4]
    2852:	891b      	ldrh	r3, [r3, #8]
    2854:	2b01      	cmp	r3, #1
    2856:	d107      	bne.n	2868 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2858:	4b05      	ldr	r3, [pc, #20]	; (2870 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    285a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    285e:	4a04      	ldr	r2, [pc, #16]	; (2870 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2860:	f043 0301 	orr.w	r3, r3, #1
    2864:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    2868:	bf00      	nop
    286a:	b002      	add	sp, #8
    286c:	4770      	bx	lr
    286e:	bf00      	nop
    2870:	40064000 	.word	0x40064000

00002874 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    2874:	b082      	sub	sp, #8
    2876:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2878:	bf00      	nop
    287a:	b002      	add	sp, #8
    287c:	4770      	bx	lr

0000287e <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    287e:	b082      	sub	sp, #8
    2880:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    2882:	2300      	movs	r3, #0
}
    2884:	4618      	mov	r0, r3
    2886:	b002      	add	sp, #8
    2888:	4770      	bx	lr

0000288a <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    288a:	b082      	sub	sp, #8
    288c:	9001      	str	r0, [sp, #4]
    288e:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    2890:	bf00      	nop
    2892:	b002      	add	sp, #8
    2894:	4770      	bx	lr
	...

00002898 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    2898:	b082      	sub	sp, #8
    289a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    289c:	bf00      	nop
    289e:	b002      	add	sp, #8
    28a0:	4770      	bx	lr

000028a2 <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    28a2:	b082      	sub	sp, #8
    28a4:	9001      	str	r0, [sp, #4]
    28a6:	460b      	mov	r3, r1
    28a8:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    28ac:	bf00      	nop
    28ae:	b002      	add	sp, #8
    28b0:	4770      	bx	lr

000028b2 <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    28b2:	b500      	push	{lr}
    28b4:	b083      	sub	sp, #12
    28b6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    28b8:	9b01      	ldr	r3, [sp, #4]
    28ba:	2b00      	cmp	r3, #0
    28bc:	d002      	beq.n	28c4 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    28be:	9801      	ldr	r0, [sp, #4]
    28c0:	f000 f8e7 	bl	2a92 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    28c4:	bf00      	nop
    28c6:	b003      	add	sp, #12
    28c8:	f85d fb04 	ldr.w	pc, [sp], #4

000028cc <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    28cc:	b500      	push	{lr}
    28ce:	b085      	sub	sp, #20
    28d0:	9001      	str	r0, [sp, #4]
    28d2:	460b      	mov	r3, r1
    28d4:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    28d8:	9b01      	ldr	r3, [sp, #4]
    28da:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    28dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
    28e0:	2b00      	cmp	r3, #0
    28e2:	d003      	beq.n	28ec <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    28e4:	2300      	movs	r3, #0
    28e6:	f8ad 300c 	strh.w	r3, [sp, #12]
    28ea:	e002      	b.n	28f2 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    28ec:	2301      	movs	r3, #1
    28ee:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    28f2:	ab02      	add	r3, sp, #8
    28f4:	4618      	mov	r0, r3
    28f6:	f7ff ffdc 	bl	28b2 <Clock_Ip_ClockSetSimLPO1KEnable>
}
    28fa:	bf00      	nop
    28fc:	b005      	add	sp, #20
    28fe:	f85d fb04 	ldr.w	pc, [sp], #4

00002902 <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    2902:	b500      	push	{lr}
    2904:	b083      	sub	sp, #12
    2906:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2908:	9b01      	ldr	r3, [sp, #4]
    290a:	2b00      	cmp	r3, #0
    290c:	d002      	beq.n	2914 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    290e:	9801      	ldr	r0, [sp, #4]
    2910:	f000 f8d6 	bl	2ac0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2914:	bf00      	nop
    2916:	b003      	add	sp, #12
    2918:	f85d fb04 	ldr.w	pc, [sp], #4

0000291c <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    291c:	b500      	push	{lr}
    291e:	b085      	sub	sp, #20
    2920:	9001      	str	r0, [sp, #4]
    2922:	460b      	mov	r3, r1
    2924:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2928:	9b01      	ldr	r3, [sp, #4]
    292a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    292c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2930:	2b00      	cmp	r3, #0
    2932:	d003      	beq.n	293c <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    2934:	2300      	movs	r3, #0
    2936:	f8ad 300c 	strh.w	r3, [sp, #12]
    293a:	e002      	b.n	2942 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    293c:	2301      	movs	r3, #1
    293e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    2942:	ab02      	add	r3, sp, #8
    2944:	4618      	mov	r0, r3
    2946:	f7ff ffdc 	bl	2902 <Clock_Ip_ClockSetSimLPO32KEnable>
}
    294a:	bf00      	nop
    294c:	b005      	add	sp, #20
    294e:	f85d fb04 	ldr.w	pc, [sp], #4

00002952 <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    2952:	b500      	push	{lr}
    2954:	b083      	sub	sp, #12
    2956:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2958:	9b01      	ldr	r3, [sp, #4]
    295a:	2b00      	cmp	r3, #0
    295c:	d002      	beq.n	2964 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    295e:	9801      	ldr	r0, [sp, #4]
    2960:	f000 f8c6 	bl	2af0 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2964:	bf00      	nop
    2966:	b003      	add	sp, #12
    2968:	f85d fb04 	ldr.w	pc, [sp], #4

0000296c <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    296c:	b500      	push	{lr}
    296e:	b085      	sub	sp, #20
    2970:	9001      	str	r0, [sp, #4]
    2972:	460b      	mov	r3, r1
    2974:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2978:	9b01      	ldr	r3, [sp, #4]
    297a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    297c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2980:	2b00      	cmp	r3, #0
    2982:	d003      	beq.n	298c <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    2984:	2300      	movs	r3, #0
    2986:	f8ad 300c 	strh.w	r3, [sp, #12]
    298a:	e002      	b.n	2992 <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    298c:	2301      	movs	r3, #1
    298e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    2992:	ab02      	add	r3, sp, #8
    2994:	4618      	mov	r0, r3
    2996:	f7ff ffdc 	bl	2952 <Clock_Ip_ClockSetSimClkoutEnable>
}
    299a:	bf00      	nop
    299c:	b005      	add	sp, #20
    299e:	f85d fb04 	ldr.w	pc, [sp], #4

000029a2 <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    29a2:	b500      	push	{lr}
    29a4:	b083      	sub	sp, #12
    29a6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    29a8:	9b01      	ldr	r3, [sp, #4]
    29aa:	2b00      	cmp	r3, #0
    29ac:	d002      	beq.n	29b4 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    29ae:	9801      	ldr	r0, [sp, #4]
    29b0:	f000 f8b6 	bl	2b20 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    29b4:	bf00      	nop
    29b6:	b003      	add	sp, #12
    29b8:	f85d fb04 	ldr.w	pc, [sp], #4

000029bc <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    29bc:	b500      	push	{lr}
    29be:	b085      	sub	sp, #20
    29c0:	9001      	str	r0, [sp, #4]
    29c2:	460b      	mov	r3, r1
    29c4:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    29c8:	9b01      	ldr	r3, [sp, #4]
    29ca:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    29cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
    29d0:	2b00      	cmp	r3, #0
    29d2:	d003      	beq.n	29dc <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    29d4:	2300      	movs	r3, #0
    29d6:	f8ad 300c 	strh.w	r3, [sp, #12]
    29da:	e002      	b.n	29e2 <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    29dc:	2301      	movs	r3, #1
    29de:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    29e2:	ab02      	add	r3, sp, #8
    29e4:	4618      	mov	r0, r3
    29e6:	f7ff ffdc 	bl	29a2 <Clock_Ip_ClockSetPccCgcEnable>
}
    29ea:	bf00      	nop
    29ec:	b005      	add	sp, #20
    29ee:	f85d fb04 	ldr.w	pc, [sp], #4

000029f2 <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    29f2:	b500      	push	{lr}
    29f4:	b083      	sub	sp, #12
    29f6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    29f8:	9b01      	ldr	r3, [sp, #4]
    29fa:	2b00      	cmp	r3, #0
    29fc:	d002      	beq.n	2a04 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    29fe:	9801      	ldr	r0, [sp, #4]
    2a00:	f000 f8bc 	bl	2b7c <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2a04:	bf00      	nop
    2a06:	b003      	add	sp, #12
    2a08:	f85d fb04 	ldr.w	pc, [sp], #4

00002a0c <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    2a0c:	b500      	push	{lr}
    2a0e:	b085      	sub	sp, #20
    2a10:	9001      	str	r0, [sp, #4]
    2a12:	460b      	mov	r3, r1
    2a14:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2a18:	9b01      	ldr	r3, [sp, #4]
    2a1a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2a1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2a20:	2b00      	cmp	r3, #0
    2a22:	d003      	beq.n	2a2c <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    2a24:	2300      	movs	r3, #0
    2a26:	f8ad 300c 	strh.w	r3, [sp, #12]
    2a2a:	e002      	b.n	2a32 <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2a2c:	2301      	movs	r3, #1
    2a2e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    2a32:	ab02      	add	r3, sp, #8
    2a34:	4618      	mov	r0, r3
    2a36:	f7ff ffdc 	bl	29f2 <Clock_Ip_ClockSetSimGate>
}
    2a3a:	bf00      	nop
    2a3c:	b005      	add	sp, #20
    2a3e:	f85d fb04 	ldr.w	pc, [sp], #4

00002a42 <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    2a42:	b500      	push	{lr}
    2a44:	b083      	sub	sp, #12
    2a46:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2a48:	9b01      	ldr	r3, [sp, #4]
    2a4a:	2b00      	cmp	r3, #0
    2a4c:	d002      	beq.n	2a54 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    2a4e:	9801      	ldr	r0, [sp, #4]
    2a50:	f000 f8c0 	bl	2bd4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2a54:	bf00      	nop
    2a56:	b003      	add	sp, #12
    2a58:	f85d fb04 	ldr.w	pc, [sp], #4

00002a5c <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2a5c:	b500      	push	{lr}
    2a5e:	b085      	sub	sp, #20
    2a60:	9001      	str	r0, [sp, #4]
    2a62:	460b      	mov	r3, r1
    2a64:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2a68:	9b01      	ldr	r3, [sp, #4]
    2a6a:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2a6c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2a70:	2b00      	cmp	r3, #0
    2a72:	d003      	beq.n	2a7c <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    2a74:	2300      	movs	r3, #0
    2a76:	f8ad 300c 	strh.w	r3, [sp, #12]
    2a7a:	e002      	b.n	2a82 <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2a7c:	2301      	movs	r3, #1
    2a7e:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    2a82:	ab02      	add	r3, sp, #8
    2a84:	4618      	mov	r0, r3
    2a86:	f7ff ffdc 	bl	2a42 <Clock_Ip_ClockSetSimTraceEnable>
}
    2a8a:	bf00      	nop
    2a8c:	b005      	add	sp, #20
    2a8e:	f85d fb04 	ldr.w	pc, [sp], #4

00002a92 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2a92:	b084      	sub	sp, #16
    2a94:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2a96:	4b09      	ldr	r3, [pc, #36]	; (2abc <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2a98:	691b      	ldr	r3, [r3, #16]
    2a9a:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    2a9c:	9b03      	ldr	r3, [sp, #12]
    2a9e:	f023 0301 	bic.w	r3, r3, #1
    2aa2:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    2aa4:	9b01      	ldr	r3, [sp, #4]
    2aa6:	889b      	ldrh	r3, [r3, #4]
    2aa8:	461a      	mov	r2, r3
    2aaa:	9b03      	ldr	r3, [sp, #12]
    2aac:	4313      	orrs	r3, r2
    2aae:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    2ab0:	4a02      	ldr	r2, [pc, #8]	; (2abc <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2ab2:	9b03      	ldr	r3, [sp, #12]
    2ab4:	6113      	str	r3, [r2, #16]
}
    2ab6:	bf00      	nop
    2ab8:	b004      	add	sp, #16
    2aba:	4770      	bx	lr
    2abc:	40048000 	.word	0x40048000

00002ac0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2ac0:	b084      	sub	sp, #16
    2ac2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2ac4:	4b09      	ldr	r3, [pc, #36]	; (2aec <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    2ac6:	691b      	ldr	r3, [r3, #16]
    2ac8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    2aca:	9b03      	ldr	r3, [sp, #12]
    2acc:	f023 0302 	bic.w	r3, r3, #2
    2ad0:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    2ad2:	9b01      	ldr	r3, [sp, #4]
    2ad4:	889b      	ldrh	r3, [r3, #4]
    2ad6:	005b      	lsls	r3, r3, #1
    2ad8:	9a03      	ldr	r2, [sp, #12]
    2ada:	4313      	orrs	r3, r2
    2adc:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    2ade:	4a03      	ldr	r2, [pc, #12]	; (2aec <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    2ae0:	9b03      	ldr	r3, [sp, #12]
    2ae2:	6113      	str	r3, [r2, #16]
}
    2ae4:	bf00      	nop
    2ae6:	b004      	add	sp, #16
    2ae8:	4770      	bx	lr
    2aea:	bf00      	nop
    2aec:	40048000 	.word	0x40048000

00002af0 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2af0:	b084      	sub	sp, #16
    2af2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    2af4:	4b09      	ldr	r3, [pc, #36]	; (2b1c <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    2af6:	685b      	ldr	r3, [r3, #4]
    2af8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    2afa:	9b03      	ldr	r3, [sp, #12]
    2afc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    2b00:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    2b02:	9b01      	ldr	r3, [sp, #4]
    2b04:	889b      	ldrh	r3, [r3, #4]
    2b06:	02db      	lsls	r3, r3, #11
    2b08:	9a03      	ldr	r2, [sp, #12]
    2b0a:	4313      	orrs	r3, r2
    2b0c:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    2b0e:	4a03      	ldr	r2, [pc, #12]	; (2b1c <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    2b10:	9b03      	ldr	r3, [sp, #12]
    2b12:	6053      	str	r3, [r2, #4]
}
    2b14:	bf00      	nop
    2b16:	b004      	add	sp, #16
    2b18:	4770      	bx	lr
    2b1a:	bf00      	nop
    2b1c:	40048000 	.word	0x40048000

00002b20 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2b20:	b084      	sub	sp, #16
    2b22:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    2b24:	4913      	ldr	r1, [pc, #76]	; (2b74 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    2b26:	9b01      	ldr	r3, [sp, #4]
    2b28:	681a      	ldr	r2, [r3, #0]
    2b2a:	4813      	ldr	r0, [pc, #76]	; (2b78 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2b2c:	4613      	mov	r3, r2
    2b2e:	00db      	lsls	r3, r3, #3
    2b30:	4413      	add	r3, r2
    2b32:	4403      	add	r3, r0
    2b34:	3306      	adds	r3, #6
    2b36:	781b      	ldrb	r3, [r3, #0]
    2b38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    2b3c:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    2b3e:	9b03      	ldr	r3, [sp, #12]
    2b40:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    2b44:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    2b46:	9b01      	ldr	r3, [sp, #4]
    2b48:	889b      	ldrh	r3, [r3, #4]
    2b4a:	079b      	lsls	r3, r3, #30
    2b4c:	9a03      	ldr	r2, [sp, #12]
    2b4e:	4313      	orrs	r3, r2
    2b50:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    2b52:	4908      	ldr	r1, [pc, #32]	; (2b74 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    2b54:	9b01      	ldr	r3, [sp, #4]
    2b56:	681a      	ldr	r2, [r3, #0]
    2b58:	4807      	ldr	r0, [pc, #28]	; (2b78 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2b5a:	4613      	mov	r3, r2
    2b5c:	00db      	lsls	r3, r3, #3
    2b5e:	4413      	add	r3, r2
    2b60:	4403      	add	r3, r0
    2b62:	3306      	adds	r3, #6
    2b64:	781b      	ldrb	r3, [r3, #0]
    2b66:	461a      	mov	r2, r3
    2b68:	9b03      	ldr	r3, [sp, #12]
    2b6a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    2b6e:	bf00      	nop
    2b70:	b004      	add	sp, #16
    2b72:	4770      	bx	lr
    2b74:	40065000 	.word	0x40065000
    2b78:	0000bf68 	.word	0x0000bf68

00002b7c <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2b7c:	b086      	sub	sp, #24
    2b7e:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    2b80:	9b01      	ldr	r3, [sp, #4]
    2b82:	889b      	ldrh	r3, [r3, #4]
    2b84:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    2b86:	9b01      	ldr	r3, [sp, #4]
    2b88:	681a      	ldr	r2, [r3, #0]
    2b8a:	4910      	ldr	r1, [pc, #64]	; (2bcc <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    2b8c:	4613      	mov	r3, r2
    2b8e:	00db      	lsls	r3, r3, #3
    2b90:	4413      	add	r3, r2
    2b92:	440b      	add	r3, r1
    2b94:	3306      	adds	r3, #6
    2b96:	781b      	ldrb	r3, [r3, #0]
    2b98:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    2b9a:	4b0d      	ldr	r3, [pc, #52]	; (2bd0 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2b9c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2b9e:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    2ba0:	2201      	movs	r2, #1
    2ba2:	9b04      	ldr	r3, [sp, #16]
    2ba4:	fa02 f303 	lsl.w	r3, r2, r3
    2ba8:	43db      	mvns	r3, r3
    2baa:	9a03      	ldr	r2, [sp, #12]
    2bac:	4013      	ands	r3, r2
    2bae:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    2bb0:	9a05      	ldr	r2, [sp, #20]
    2bb2:	9b04      	ldr	r3, [sp, #16]
    2bb4:	fa02 f303 	lsl.w	r3, r2, r3
    2bb8:	9a03      	ldr	r2, [sp, #12]
    2bba:	4313      	orrs	r3, r2
    2bbc:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    2bbe:	4a04      	ldr	r2, [pc, #16]	; (2bd0 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2bc0:	9b03      	ldr	r3, [sp, #12]
    2bc2:	6413      	str	r3, [r2, #64]	; 0x40
}
    2bc4:	bf00      	nop
    2bc6:	b006      	add	sp, #24
    2bc8:	4770      	bx	lr
    2bca:	bf00      	nop
    2bcc:	0000bf68 	.word	0x0000bf68
    2bd0:	40048000 	.word	0x40048000

00002bd4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2bd4:	b084      	sub	sp, #16
    2bd6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    2bd8:	4b0a      	ldr	r3, [pc, #40]	; (2c04 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    2bda:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2bdc:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    2bde:	9b01      	ldr	r3, [sp, #4]
    2be0:	889b      	ldrh	r3, [r3, #4]
    2be2:	2b01      	cmp	r3, #1
    2be4:	d104      	bne.n	2bf0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    2be6:	9b03      	ldr	r3, [sp, #12]
    2be8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    2bec:	9303      	str	r3, [sp, #12]
    2bee:	e003      	b.n	2bf8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    2bf0:	9b03      	ldr	r3, [sp, #12]
    2bf2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2bf6:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    2bf8:	4a02      	ldr	r2, [pc, #8]	; (2c04 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    2bfa:	9b03      	ldr	r3, [sp, #12]
    2bfc:	6693      	str	r3, [r2, #104]	; 0x68
}
    2bfe:	bf00      	nop
    2c00:	b004      	add	sp, #16
    2c02:	4770      	bx	lr
    2c04:	40048000 	.word	0x40048000

00002c08 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    2c08:	b082      	sub	sp, #8
    2c0a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2c0c:	bf00      	nop
    2c0e:	b002      	add	sp, #8
    2c10:	4770      	bx	lr

00002c12 <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    2c12:	b082      	sub	sp, #8
    2c14:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    2c16:	bf00      	nop
    2c18:	b002      	add	sp, #8
    2c1a:	4770      	bx	lr

00002c1c <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2c1c:	b500      	push	{lr}
    2c1e:	b083      	sub	sp, #12
    2c20:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c22:	9b01      	ldr	r3, [sp, #4]
    2c24:	2b00      	cmp	r3, #0
    2c26:	d002      	beq.n	2c2e <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    2c28:	9801      	ldr	r0, [sp, #4]
    2c2a:	f000 f8d1 	bl	2dd0 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c2e:	bf00      	nop
    2c30:	b003      	add	sp, #12
    2c32:	f85d fb04 	ldr.w	pc, [sp], #4

00002c36 <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2c36:	b500      	push	{lr}
    2c38:	b083      	sub	sp, #12
    2c3a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c3c:	9b01      	ldr	r3, [sp, #4]
    2c3e:	2b00      	cmp	r3, #0
    2c40:	d002      	beq.n	2c48 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    2c42:	9801      	ldr	r0, [sp, #4]
    2c44:	f000 f950 	bl	2ee8 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c48:	bf00      	nop
    2c4a:	b003      	add	sp, #12
    2c4c:	f85d fb04 	ldr.w	pc, [sp], #4

00002c50 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    2c50:	b500      	push	{lr}
    2c52:	b083      	sub	sp, #12
    2c54:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    2c56:	9801      	ldr	r0, [sp, #4]
    2c58:	f000 f98e 	bl	2f78 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2c5c:	bf00      	nop
    2c5e:	b003      	add	sp, #12
    2c60:	f85d fb04 	ldr.w	pc, [sp], #4

00002c64 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2c64:	b500      	push	{lr}
    2c66:	b083      	sub	sp, #12
    2c68:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c6a:	9b01      	ldr	r3, [sp, #4]
    2c6c:	2b00      	cmp	r3, #0
    2c6e:	d002      	beq.n	2c76 <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    2c70:	9801      	ldr	r0, [sp, #4]
    2c72:	f000 f999 	bl	2fa8 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c76:	bf00      	nop
    2c78:	b003      	add	sp, #12
    2c7a:	f85d fb04 	ldr.w	pc, [sp], #4

00002c7e <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2c7e:	b500      	push	{lr}
    2c80:	b083      	sub	sp, #12
    2c82:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2c84:	9b01      	ldr	r3, [sp, #4]
    2c86:	2b00      	cmp	r3, #0
    2c88:	d002      	beq.n	2c90 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    2c8a:	9801      	ldr	r0, [sp, #4]
    2c8c:	f000 f9b0 	bl	2ff0 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2c90:	bf00      	nop
    2c92:	b003      	add	sp, #12
    2c94:	f85d fb04 	ldr.w	pc, [sp], #4

00002c98 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    2c98:	b500      	push	{lr}
    2c9a:	b083      	sub	sp, #12
    2c9c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    2c9e:	9801      	ldr	r0, [sp, #4]
    2ca0:	f000 f9ba 	bl	3018 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2ca4:	bf00      	nop
    2ca6:	b003      	add	sp, #12
    2ca8:	f85d fb04 	ldr.w	pc, [sp], #4

00002cac <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2cac:	b500      	push	{lr}
    2cae:	b083      	sub	sp, #12
    2cb0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2cb2:	9b01      	ldr	r3, [sp, #4]
    2cb4:	2b00      	cmp	r3, #0
    2cb6:	d002      	beq.n	2cbe <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    2cb8:	9801      	ldr	r0, [sp, #4]
    2cba:	f000 f9bd 	bl	3038 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cbe:	bf00      	nop
    2cc0:	b003      	add	sp, #12
    2cc2:	f85d fb04 	ldr.w	pc, [sp], #4

00002cc6 <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2cc6:	b500      	push	{lr}
    2cc8:	b083      	sub	sp, #12
    2cca:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ccc:	9b01      	ldr	r3, [sp, #4]
    2cce:	2b00      	cmp	r3, #0
    2cd0:	d002      	beq.n	2cd8 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    2cd2:	9801      	ldr	r0, [sp, #4]
    2cd4:	f000 f9d4 	bl	3080 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2cd8:	bf00      	nop
    2cda:	b003      	add	sp, #12
    2cdc:	f85d fb04 	ldr.w	pc, [sp], #4

00002ce0 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    2ce0:	b500      	push	{lr}
    2ce2:	b083      	sub	sp, #12
    2ce4:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    2ce6:	9801      	ldr	r0, [sp, #4]
    2ce8:	f000 f9de 	bl	30a8 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2cec:	bf00      	nop
    2cee:	b003      	add	sp, #12
    2cf0:	f85d fb04 	ldr.w	pc, [sp], #4

00002cf4 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    2cf4:	b500      	push	{lr}
    2cf6:	b089      	sub	sp, #36	; 0x24
    2cf8:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    2cfa:	2300      	movs	r3, #0
    2cfc:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    2d00:	4b20      	ldr	r3, [pc, #128]	; (2d84 <SetInputSouceSytemClock+0x90>)
    2d02:	695b      	ldr	r3, [r3, #20]
    2d04:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    2d06:	9b06      	ldr	r3, [sp, #24]
    2d08:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    2d0c:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    2d0e:	9b01      	ldr	r3, [sp, #4]
    2d10:	061b      	lsls	r3, r3, #24
    2d12:	9a06      	ldr	r2, [sp, #24]
    2d14:	4313      	orrs	r3, r2
    2d16:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    2d18:	4a1a      	ldr	r2, [pc, #104]	; (2d84 <SetInputSouceSytemClock+0x90>)
    2d1a:	9b06      	ldr	r3, [sp, #24]
    2d1c:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2d1e:	aa02      	add	r2, sp, #8
    2d20:	a903      	add	r1, sp, #12
    2d22:	a804      	add	r0, sp, #16
    2d24:	f24c 3350 	movw	r3, #50000	; 0xc350
    2d28:	f7ff f9ac 	bl	2084 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    2d2c:	4b15      	ldr	r3, [pc, #84]	; (2d84 <SetInputSouceSytemClock+0x90>)
    2d2e:	691b      	ldr	r3, [r3, #16]
    2d30:	0e1b      	lsrs	r3, r3, #24
    2d32:	f003 030f 	and.w	r3, r3, #15
    2d36:	9a01      	ldr	r2, [sp, #4]
    2d38:	429a      	cmp	r2, r3
    2d3a:	bf0c      	ite	eq
    2d3c:	2301      	moveq	r3, #1
    2d3e:	2300      	movne	r3, #0
    2d40:	b2db      	uxtb	r3, r3
    2d42:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2d44:	9a02      	ldr	r2, [sp, #8]
    2d46:	a903      	add	r1, sp, #12
    2d48:	ab04      	add	r3, sp, #16
    2d4a:	4618      	mov	r0, r3
    2d4c:	f7ff f9b4 	bl	20b8 <Clock_Ip_TimeoutExpired>
    2d50:	4603      	mov	r3, r0
    2d52:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    2d56:	9b05      	ldr	r3, [sp, #20]
    2d58:	2b00      	cmp	r3, #0
    2d5a:	d106      	bne.n	2d6a <SetInputSouceSytemClock+0x76>
    2d5c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d60:	f083 0301 	eor.w	r3, r3, #1
    2d64:	b2db      	uxtb	r3, r3
    2d66:	2b00      	cmp	r3, #0
    2d68:	d1e0      	bne.n	2d2c <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    2d6a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d6e:	2b00      	cmp	r3, #0
    2d70:	d003      	beq.n	2d7a <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    2d72:	2105      	movs	r1, #5
    2d74:	2001      	movs	r0, #1
    2d76:	f7ff f975 	bl	2064 <Clock_Ip_ReportClockErrors>
    }
}
    2d7a:	bf00      	nop
    2d7c:	b009      	add	sp, #36	; 0x24
    2d7e:	f85d fb04 	ldr.w	pc, [sp], #4
    2d82:	bf00      	nop
    2d84:	40064000 	.word	0x40064000

00002d88 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2d88:	b500      	push	{lr}
    2d8a:	b083      	sub	sp, #12
    2d8c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2d8e:	9b01      	ldr	r3, [sp, #4]
    2d90:	2b00      	cmp	r3, #0
    2d92:	d002      	beq.n	2d9a <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    2d94:	9801      	ldr	r0, [sp, #4]
    2d96:	f000 f997 	bl	30c8 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2d9a:	bf00      	nop
    2d9c:	b003      	add	sp, #12
    2d9e:	f85d fb04 	ldr.w	pc, [sp], #4

00002da2 <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2da2:	b500      	push	{lr}
    2da4:	b083      	sub	sp, #12
    2da6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2da8:	9b01      	ldr	r3, [sp, #4]
    2daa:	2b00      	cmp	r3, #0
    2dac:	d002      	beq.n	2db4 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    2dae:	9801      	ldr	r0, [sp, #4]
    2db0:	f000 fa7e 	bl	32b0 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2db4:	bf00      	nop
    2db6:	b003      	add	sp, #12
    2db8:	f85d fb04 	ldr.w	pc, [sp], #4

00002dbc <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    2dbc:	b500      	push	{lr}
    2dbe:	b083      	sub	sp, #12
    2dc0:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    2dc2:	9801      	ldr	r0, [sp, #4]
    2dc4:	f000 fab8 	bl	3338 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2dc8:	bf00      	nop
    2dca:	b003      	add	sp, #12
    2dcc:	f85d fb04 	ldr.w	pc, [sp], #4

00002dd0 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2dd0:	b500      	push	{lr}
    2dd2:	b08b      	sub	sp, #44	; 0x2c
    2dd4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2dd6:	2300      	movs	r3, #0
    2dd8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    2ddc:	9b01      	ldr	r3, [sp, #4]
    2dde:	2b00      	cmp	r3, #0
    2de0:	d10b      	bne.n	2dfa <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    2de2:	2305      	movs	r3, #5
    2de4:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    2de6:	2301      	movs	r3, #1
    2de8:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    2dec:	2301      	movs	r3, #1
    2dee:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    2df2:	2301      	movs	r3, #1
    2df4:	f88d 3010 	strb.w	r3, [sp, #16]
    2df8:	e00e      	b.n	2e18 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    2dfa:	9b01      	ldr	r3, [sp, #4]
    2dfc:	681b      	ldr	r3, [r3, #0]
    2dfe:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    2e00:	9b01      	ldr	r3, [sp, #4]
    2e02:	79db      	ldrb	r3, [r3, #7]
    2e04:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    2e08:	9b01      	ldr	r3, [sp, #4]
    2e0a:	889b      	ldrh	r3, [r3, #4]
    2e0c:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    2e10:	9b01      	ldr	r3, [sp, #4]
    2e12:	7a1b      	ldrb	r3, [r3, #8]
    2e14:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2e18:	4b32      	ldr	r3, [pc, #200]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e1a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e1e:	4a31      	ldr	r2, [pc, #196]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e20:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2e24:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    2e28:	4b2e      	ldr	r3, [pc, #184]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e2a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e2e:	4a2d      	ldr	r2, [pc, #180]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e30:	f023 0301 	bic.w	r3, r3, #1
    2e34:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2e38:	4b2a      	ldr	r3, [pc, #168]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e3a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e3e:	4a29      	ldr	r2, [pc, #164]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e40:	f023 0304 	bic.w	r3, r3, #4
    2e44:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    2e48:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    2e4c:	2b01      	cmp	r3, #1
    2e4e:	d144      	bne.n	2eda <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    2e50:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2e54:	4a23      	ldr	r2, [pc, #140]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e56:	f003 0301 	and.w	r3, r3, #1
    2e5a:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2e5e:	4b21      	ldr	r3, [pc, #132]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e60:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e64:	4a1f      	ldr	r2, [pc, #124]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e66:	f043 0301 	orr.w	r3, r3, #1
    2e6a:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    2e6e:	4b1d      	ldr	r3, [pc, #116]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e70:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2e74:	f89d 3010 	ldrb.w	r3, [sp, #16]
    2e78:	009b      	lsls	r3, r3, #2
    2e7a:	f003 0304 	and.w	r3, r3, #4
    2e7e:	4919      	ldr	r1, [pc, #100]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e80:	4313      	orrs	r3, r2
    2e82:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2e86:	aa05      	add	r2, sp, #20
    2e88:	a906      	add	r1, sp, #24
    2e8a:	a807      	add	r0, sp, #28
    2e8c:	f24c 3350 	movw	r3, #50000	; 0xc350
    2e90:	f7ff f8f8 	bl	2084 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2e94:	4b13      	ldr	r3, [pc, #76]	; (2ee4 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2e96:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2e9a:	0e1b      	lsrs	r3, r3, #24
    2e9c:	f003 0301 	and.w	r3, r3, #1
    2ea0:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2ea2:	9a05      	ldr	r2, [sp, #20]
    2ea4:	a906      	add	r1, sp, #24
    2ea6:	ab07      	add	r3, sp, #28
    2ea8:	4618      	mov	r0, r3
    2eaa:	f7ff f905 	bl	20b8 <Clock_Ip_TimeoutExpired>
    2eae:	4603      	mov	r3, r0
    2eb0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2eb4:	9b08      	ldr	r3, [sp, #32]
    2eb6:	2b00      	cmp	r3, #0
    2eb8:	d106      	bne.n	2ec8 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    2eba:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2ebe:	f083 0301 	eor.w	r3, r3, #1
    2ec2:	b2db      	uxtb	r3, r3
    2ec4:	2b00      	cmp	r3, #0
    2ec6:	d1e5      	bne.n	2e94 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    2ec8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2ecc:	2b00      	cmp	r3, #0
    2ece:	d004      	beq.n	2eda <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    2ed0:	9b02      	ldr	r3, [sp, #8]
    2ed2:	4619      	mov	r1, r3
    2ed4:	2001      	movs	r0, #1
    2ed6:	f7ff f8c5 	bl	2064 <Clock_Ip_ReportClockErrors>
        }
    }
}
    2eda:	bf00      	nop
    2edc:	b00b      	add	sp, #44	; 0x2c
    2ede:	f85d fb04 	ldr.w	pc, [sp], #4
    2ee2:	bf00      	nop
    2ee4:	40064000 	.word	0x40064000

00002ee8 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2ee8:	b500      	push	{lr}
    2eea:	b089      	sub	sp, #36	; 0x24
    2eec:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2eee:	2300      	movs	r3, #0
    2ef0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2ef4:	4b1f      	ldr	r3, [pc, #124]	; (2f74 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2ef6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2efa:	4a1e      	ldr	r2, [pc, #120]	; (2f74 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2efc:	f043 0301 	orr.w	r3, r3, #1
    2f00:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    2f04:	4b1b      	ldr	r3, [pc, #108]	; (2f74 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f06:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f0a:	4a1a      	ldr	r2, [pc, #104]	; (2f74 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f0c:	f043 0304 	orr.w	r3, r3, #4
    2f10:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2f14:	aa03      	add	r2, sp, #12
    2f16:	a904      	add	r1, sp, #16
    2f18:	a805      	add	r0, sp, #20
    2f1a:	f24c 3350 	movw	r3, #50000	; 0xc350
    2f1e:	f7ff f8b1 	bl	2084 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2f22:	4b14      	ldr	r3, [pc, #80]	; (2f74 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2f24:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f28:	0e1b      	lsrs	r3, r3, #24
    2f2a:	f003 0301 	and.w	r3, r3, #1
    2f2e:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2f30:	9a03      	ldr	r2, [sp, #12]
    2f32:	a904      	add	r1, sp, #16
    2f34:	ab05      	add	r3, sp, #20
    2f36:	4618      	mov	r0, r3
    2f38:	f7ff f8be 	bl	20b8 <Clock_Ip_TimeoutExpired>
    2f3c:	4603      	mov	r3, r0
    2f3e:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2f42:	9b06      	ldr	r3, [sp, #24]
    2f44:	2b00      	cmp	r3, #0
    2f46:	d106      	bne.n	2f56 <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    2f48:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2f4c:	f083 0301 	eor.w	r3, r3, #1
    2f50:	b2db      	uxtb	r3, r3
    2f52:	2b00      	cmp	r3, #0
    2f54:	d1e5      	bne.n	2f22 <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    2f56:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2f5a:	2b00      	cmp	r3, #0
    2f5c:	d005      	beq.n	2f6a <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2f5e:	9b01      	ldr	r3, [sp, #4]
    2f60:	681b      	ldr	r3, [r3, #0]
    2f62:	4619      	mov	r1, r3
    2f64:	2001      	movs	r0, #1
    2f66:	f7ff f87d 	bl	2064 <Clock_Ip_ReportClockErrors>
    }
}
    2f6a:	bf00      	nop
    2f6c:	b009      	add	sp, #36	; 0x24
    2f6e:	f85d fb04 	ldr.w	pc, [sp], #4
    2f72:	bf00      	nop
    2f74:	40064000 	.word	0x40064000

00002f78 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    2f78:	b082      	sub	sp, #8
    2f7a:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    2f7c:	4b09      	ldr	r3, [pc, #36]	; (2fa4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2f7e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f82:	4a08      	ldr	r2, [pc, #32]	; (2fa4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2f84:	f023 0301 	bic.w	r3, r3, #1
    2f88:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2f8c:	4b05      	ldr	r3, [pc, #20]	; (2fa4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2f8e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2f92:	4a04      	ldr	r2, [pc, #16]	; (2fa4 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2f94:	f023 0304 	bic.w	r3, r3, #4
    2f98:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2f9c:	bf00      	nop
    2f9e:	b002      	add	sp, #8
    2fa0:	4770      	bx	lr
    2fa2:	bf00      	nop
    2fa4:	40064000 	.word	0x40064000

00002fa8 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2fa8:	b082      	sub	sp, #8
    2faa:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2fac:	4b0f      	ldr	r3, [pc, #60]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fae:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fb2:	4a0e      	ldr	r2, [pc, #56]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fb4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2fb8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2fbc:	4b0b      	ldr	r3, [pc, #44]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fbe:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2fc2:	4a0a      	ldr	r2, [pc, #40]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fc4:	f023 0304 	bic.w	r3, r3, #4
    2fc8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    2fcc:	4b07      	ldr	r3, [pc, #28]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fce:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2fd2:	9b01      	ldr	r3, [sp, #4]
    2fd4:	7a1b      	ldrb	r3, [r3, #8]
    2fd6:	009b      	lsls	r3, r3, #2
    2fd8:	f003 0304 	and.w	r3, r3, #4
    2fdc:	4903      	ldr	r1, [pc, #12]	; (2fec <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2fde:	4313      	orrs	r3, r2
    2fe0:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    2fe4:	bf00      	nop
    2fe6:	b002      	add	sp, #8
    2fe8:	4770      	bx	lr
    2fea:	bf00      	nop
    2fec:	40064000 	.word	0x40064000

00002ff0 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2ff0:	b082      	sub	sp, #8
    2ff2:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2ff4:	9b01      	ldr	r3, [sp, #4]
    2ff6:	889b      	ldrh	r3, [r3, #4]
    2ff8:	2b01      	cmp	r3, #1
    2ffa:	d107      	bne.n	300c <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    2ffc:	4b05      	ldr	r3, [pc, #20]	; (3014 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    2ffe:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3002:	4a04      	ldr	r2, [pc, #16]	; (3014 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3004:	f043 0304 	orr.w	r3, r3, #4
    3008:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    300c:	bf00      	nop
    300e:	b002      	add	sp, #8
    3010:	4770      	bx	lr
    3012:	bf00      	nop
    3014:	40064000 	.word	0x40064000

00003018 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    3018:	b082      	sub	sp, #8
    301a:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    301c:	4b05      	ldr	r3, [pc, #20]	; (3034 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    301e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3022:	4a04      	ldr	r2, [pc, #16]	; (3034 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3024:	f023 0304 	bic.w	r3, r3, #4
    3028:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    302c:	bf00      	nop
    302e:	b002      	add	sp, #8
    3030:	4770      	bx	lr
    3032:	bf00      	nop
    3034:	40064000 	.word	0x40064000

00003038 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3038:	b082      	sub	sp, #8
    303a:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    303c:	4b0f      	ldr	r3, [pc, #60]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    303e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3042:	4a0e      	ldr	r2, [pc, #56]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3044:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3048:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    304c:	4b0b      	ldr	r3, [pc, #44]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    304e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3052:	4a0a      	ldr	r2, [pc, #40]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3054:	f023 0302 	bic.w	r3, r3, #2
    3058:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    305c:	4b07      	ldr	r3, [pc, #28]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    305e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3062:	9b01      	ldr	r3, [sp, #4]
    3064:	7a5b      	ldrb	r3, [r3, #9]
    3066:	005b      	lsls	r3, r3, #1
    3068:	f003 0302 	and.w	r3, r3, #2
    306c:	4903      	ldr	r1, [pc, #12]	; (307c <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    306e:	4313      	orrs	r3, r2
    3070:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3074:	bf00      	nop
    3076:	b002      	add	sp, #8
    3078:	4770      	bx	lr
    307a:	bf00      	nop
    307c:	40064000 	.word	0x40064000

00003080 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3080:	b082      	sub	sp, #8
    3082:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3084:	9b01      	ldr	r3, [sp, #4]
    3086:	889b      	ldrh	r3, [r3, #4]
    3088:	2b01      	cmp	r3, #1
    308a:	d107      	bne.n	309c <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    308c:	4b05      	ldr	r3, [pc, #20]	; (30a4 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    308e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3092:	4a04      	ldr	r2, [pc, #16]	; (30a4 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3094:	f043 0302 	orr.w	r3, r3, #2
    3098:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    309c:	bf00      	nop
    309e:	b002      	add	sp, #8
    30a0:	4770      	bx	lr
    30a2:	bf00      	nop
    30a4:	40064000 	.word	0x40064000

000030a8 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    30a8:	b082      	sub	sp, #8
    30aa:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    30ac:	4b05      	ldr	r3, [pc, #20]	; (30c4 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    30ae:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    30b2:	4a04      	ldr	r2, [pc, #16]	; (30c4 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    30b4:	f023 0302 	bic.w	r3, r3, #2
    30b8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    30bc:	bf00      	nop
    30be:	b002      	add	sp, #8
    30c0:	4770      	bx	lr
    30c2:	bf00      	nop
    30c4:	40064000 	.word	0x40064000

000030c8 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    30c8:	b500      	push	{lr}
    30ca:	b08b      	sub	sp, #44	; 0x2c
    30cc:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    30ce:	9b01      	ldr	r3, [sp, #4]
    30d0:	681a      	ldr	r2, [r3, #0]
    30d2:	4975      	ldr	r1, [pc, #468]	; (32a8 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    30d4:	4613      	mov	r3, r2
    30d6:	00db      	lsls	r3, r3, #3
    30d8:	4413      	add	r3, r2
    30da:	440b      	add	r3, r1
    30dc:	781b      	ldrb	r3, [r3, #0]
    30de:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    30e0:	2300      	movs	r3, #0
    30e2:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    30e6:	2300      	movs	r3, #0
    30e8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    30ec:	4b6f      	ldr	r3, [pc, #444]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    30ee:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    30f2:	4a6e      	ldr	r2, [pc, #440]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    30f4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    30f8:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    30fc:	4b6b      	ldr	r3, [pc, #428]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    30fe:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3102:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    3106:	2b00      	cmp	r3, #0
    3108:	d07d      	beq.n	3206 <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    310a:	9b01      	ldr	r3, [sp, #4]
    310c:	79db      	ldrb	r3, [r3, #7]
    310e:	461a      	mov	r2, r3
    3110:	4b66      	ldr	r3, [pc, #408]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3112:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3116:	f003 0303 	and.w	r3, r3, #3
    311a:	429a      	cmp	r2, r3
    311c:	d10b      	bne.n	3136 <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    311e:	9b01      	ldr	r3, [sp, #4]
    3120:	799b      	ldrb	r3, [r3, #6]
    3122:	461a      	mov	r2, r3
    3124:	4b61      	ldr	r3, [pc, #388]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3126:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    312a:	08db      	lsrs	r3, r3, #3
    312c:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3130:	429a      	cmp	r2, r3
    3132:	f000 80b4 	beq.w	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    3136:	4b5d      	ldr	r3, [pc, #372]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3138:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    313c:	f003 0301 	and.w	r3, r3, #1
    3140:	2b00      	cmp	r3, #0
    3142:	d105      	bne.n	3150 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    3144:	2301      	movs	r3, #1
    3146:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    314a:	2000      	movs	r0, #0
    314c:	f7ff fd66 	bl	2c1c <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    3150:	2002      	movs	r0, #2
    3152:	f7ff fdcf 	bl	2cf4 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3156:	4b55      	ldr	r3, [pc, #340]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3158:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    315c:	4a53      	ldr	r2, [pc, #332]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    315e:	f023 0301 	bic.w	r3, r3, #1
    3162:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    3166:	9b01      	ldr	r3, [sp, #4]
    3168:	889b      	ldrh	r3, [r3, #4]
    316a:	2b01      	cmp	r3, #1
    316c:	f040 8097 	bne.w	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3170:	9b01      	ldr	r3, [sp, #4]
    3172:	79db      	ldrb	r3, [r3, #7]
    3174:	4a4d      	ldr	r2, [pc, #308]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3176:	f003 0303 	and.w	r3, r3, #3
    317a:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    317e:	4b4b      	ldr	r3, [pc, #300]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3180:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3184:	9b01      	ldr	r3, [sp, #4]
    3186:	799b      	ldrb	r3, [r3, #6]
    3188:	00db      	lsls	r3, r3, #3
    318a:	f003 0308 	and.w	r3, r3, #8
    318e:	4313      	orrs	r3, r2
    3190:	4a46      	ldr	r2, [pc, #280]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3192:	f043 0301 	orr.w	r3, r3, #1
    3196:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    319a:	aa03      	add	r2, sp, #12
    319c:	a904      	add	r1, sp, #16
    319e:	a805      	add	r0, sp, #20
    31a0:	f24c 3350 	movw	r3, #50000	; 0xc350
    31a4:	f7fe ff6e 	bl	2084 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    31a8:	4b40      	ldr	r3, [pc, #256]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    31aa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    31ae:	0e1b      	lsrs	r3, r3, #24
    31b0:	f003 0301 	and.w	r3, r3, #1
    31b4:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    31b6:	9a03      	ldr	r2, [sp, #12]
    31b8:	a904      	add	r1, sp, #16
    31ba:	ab05      	add	r3, sp, #20
    31bc:	4618      	mov	r0, r3
    31be:	f7fe ff7b 	bl	20b8 <Clock_Ip_TimeoutExpired>
    31c2:	4603      	mov	r3, r0
    31c4:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    31c8:	9b06      	ldr	r3, [sp, #24]
    31ca:	2b00      	cmp	r3, #0
    31cc:	d106      	bne.n	31dc <Clock_Ip_SetFirc_TrustedCall+0x114>
    31ce:	f89d 301f 	ldrb.w	r3, [sp, #31]
    31d2:	f083 0301 	eor.w	r3, r3, #1
    31d6:	b2db      	uxtb	r3, r3
    31d8:	2b00      	cmp	r3, #0
    31da:	d1e5      	bne.n	31a8 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    31dc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    31e0:	2b00      	cmp	r3, #0
    31e2:	d005      	beq.n	31f0 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    31e4:	9b01      	ldr	r3, [sp, #4]
    31e6:	681b      	ldr	r3, [r3, #0]
    31e8:	4619      	mov	r1, r3
    31ea:	2001      	movs	r0, #1
    31ec:	f7fe ff3a 	bl	2064 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    31f0:	2003      	movs	r0, #3
    31f2:	f7ff fd7f 	bl	2cf4 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    31f6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    31fa:	2b00      	cmp	r3, #0
    31fc:	d04f      	beq.n	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    31fe:	2002      	movs	r0, #2
    3200:	f7ff fd26 	bl	2c50 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    3204:	e04b      	b.n	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3206:	4b29      	ldr	r3, [pc, #164]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3208:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    320c:	4a27      	ldr	r2, [pc, #156]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    320e:	f023 0301 	bic.w	r3, r3, #1
    3212:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    3216:	9b01      	ldr	r3, [sp, #4]
    3218:	889b      	ldrh	r3, [r3, #4]
    321a:	2b01      	cmp	r3, #1
    321c:	d13f      	bne.n	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    321e:	9b01      	ldr	r3, [sp, #4]
    3220:	79db      	ldrb	r3, [r3, #7]
    3222:	4a22      	ldr	r2, [pc, #136]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3224:	f003 0303 	and.w	r3, r3, #3
    3228:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    322c:	4b1f      	ldr	r3, [pc, #124]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    322e:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3232:	9b01      	ldr	r3, [sp, #4]
    3234:	799b      	ldrb	r3, [r3, #6]
    3236:	00db      	lsls	r3, r3, #3
    3238:	f003 0308 	and.w	r3, r3, #8
    323c:	4313      	orrs	r3, r2
    323e:	4a1b      	ldr	r2, [pc, #108]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3240:	f043 0301 	orr.w	r3, r3, #1
    3244:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3248:	aa03      	add	r2, sp, #12
    324a:	a904      	add	r1, sp, #16
    324c:	a805      	add	r0, sp, #20
    324e:	f24c 3350 	movw	r3, #50000	; 0xc350
    3252:	f7fe ff17 	bl	2084 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3256:	4b15      	ldr	r3, [pc, #84]	; (32ac <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3258:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    325c:	0e1b      	lsrs	r3, r3, #24
    325e:	f003 0301 	and.w	r3, r3, #1
    3262:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3264:	9a03      	ldr	r2, [sp, #12]
    3266:	a904      	add	r1, sp, #16
    3268:	ab05      	add	r3, sp, #20
    326a:	4618      	mov	r0, r3
    326c:	f7fe ff24 	bl	20b8 <Clock_Ip_TimeoutExpired>
    3270:	4603      	mov	r3, r0
    3272:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3276:	9b06      	ldr	r3, [sp, #24]
    3278:	2b00      	cmp	r3, #0
    327a:	d106      	bne.n	328a <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    327c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3280:	f083 0301 	eor.w	r3, r3, #1
    3284:	b2db      	uxtb	r3, r3
    3286:	2b00      	cmp	r3, #0
    3288:	d1e5      	bne.n	3256 <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    328a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    328e:	2b00      	cmp	r3, #0
    3290:	d005      	beq.n	329e <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3292:	9b01      	ldr	r3, [sp, #4]
    3294:	681b      	ldr	r3, [r3, #0]
    3296:	4619      	mov	r1, r3
    3298:	2001      	movs	r0, #1
    329a:	f7fe fee3 	bl	2064 <Clock_Ip_ReportClockErrors>
}
    329e:	bf00      	nop
    32a0:	b00b      	add	sp, #44	; 0x2c
    32a2:	f85d fb04 	ldr.w	pc, [sp], #4
    32a6:	bf00      	nop
    32a8:	0000bf68 	.word	0x0000bf68
    32ac:	40064000 	.word	0x40064000

000032b0 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    32b0:	b500      	push	{lr}
    32b2:	b089      	sub	sp, #36	; 0x24
    32b4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    32b6:	2300      	movs	r3, #0
    32b8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    32bc:	9b01      	ldr	r3, [sp, #4]
    32be:	889b      	ldrh	r3, [r3, #4]
    32c0:	2b01      	cmp	r3, #1
    32c2:	d132      	bne.n	332a <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    32c4:	4b1b      	ldr	r3, [pc, #108]	; (3334 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    32c6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    32ca:	4a1a      	ldr	r2, [pc, #104]	; (3334 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    32cc:	f043 0301 	orr.w	r3, r3, #1
    32d0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    32d4:	aa03      	add	r2, sp, #12
    32d6:	a904      	add	r1, sp, #16
    32d8:	a805      	add	r0, sp, #20
    32da:	f24c 3350 	movw	r3, #50000	; 0xc350
    32de:	f7fe fed1 	bl	2084 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    32e2:	4b14      	ldr	r3, [pc, #80]	; (3334 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    32e4:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    32e8:	0e1b      	lsrs	r3, r3, #24
    32ea:	f003 0301 	and.w	r3, r3, #1
    32ee:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    32f0:	9a03      	ldr	r2, [sp, #12]
    32f2:	a904      	add	r1, sp, #16
    32f4:	ab05      	add	r3, sp, #20
    32f6:	4618      	mov	r0, r3
    32f8:	f7fe fede 	bl	20b8 <Clock_Ip_TimeoutExpired>
    32fc:	4603      	mov	r3, r0
    32fe:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3302:	9b06      	ldr	r3, [sp, #24]
    3304:	2b00      	cmp	r3, #0
    3306:	d106      	bne.n	3316 <Clock_Ip_EnableFirc_TrustedCall+0x66>
    3308:	f89d 301f 	ldrb.w	r3, [sp, #31]
    330c:	f083 0301 	eor.w	r3, r3, #1
    3310:	b2db      	uxtb	r3, r3
    3312:	2b00      	cmp	r3, #0
    3314:	d1e5      	bne.n	32e2 <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    3316:	f89d 301f 	ldrb.w	r3, [sp, #31]
    331a:	2b00      	cmp	r3, #0
    331c:	d005      	beq.n	332a <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    331e:	9b01      	ldr	r3, [sp, #4]
    3320:	681b      	ldr	r3, [r3, #0]
    3322:	4619      	mov	r1, r3
    3324:	2001      	movs	r0, #1
    3326:	f7fe fe9d 	bl	2064 <Clock_Ip_ReportClockErrors>
        }
    }
}
    332a:	bf00      	nop
    332c:	b009      	add	sp, #36	; 0x24
    332e:	f85d fb04 	ldr.w	pc, [sp], #4
    3332:	bf00      	nop
    3334:	40064000 	.word	0x40064000

00003338 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    3338:	b082      	sub	sp, #8
    333a:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    333c:	4b05      	ldr	r3, [pc, #20]	; (3354 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    333e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3342:	4a04      	ldr	r2, [pc, #16]	; (3354 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    3344:	f023 0301 	bic.w	r3, r3, #1
    3348:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    334c:	bf00      	nop
    334e:	b002      	add	sp, #8
    3350:	4770      	bx	lr
    3352:	bf00      	nop
    3354:	40064000 	.word	0x40064000

00003358 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    3358:	b082      	sub	sp, #8
    335a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    335c:	bf00      	nop
    335e:	b002      	add	sp, #8
    3360:	4770      	bx	lr

00003362 <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    3362:	b082      	sub	sp, #8
    3364:	9001      	str	r0, [sp, #4]
    3366:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    3368:	bf00      	nop
    336a:	b002      	add	sp, #8
    336c:	4770      	bx	lr

0000336e <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    336e:	b082      	sub	sp, #8
    3370:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3372:	bf00      	nop
    3374:	b002      	add	sp, #8
    3376:	4770      	bx	lr

00003378 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    3378:	b082      	sub	sp, #8
    337a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    337c:	bf00      	nop
    337e:	b002      	add	sp, #8
    3380:	4770      	bx	lr

00003382 <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    3382:	b082      	sub	sp, #8
    3384:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    3386:	2302      	movs	r3, #2
}
    3388:	4618      	mov	r0, r3
    338a:	b002      	add	sp, #8
    338c:	4770      	bx	lr

0000338e <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    338e:	b082      	sub	sp, #8
    3390:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    3392:	bf00      	nop
    3394:	b002      	add	sp, #8
    3396:	4770      	bx	lr

00003398 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    3398:	b500      	push	{lr}
    339a:	b083      	sub	sp, #12
    339c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    339e:	9b01      	ldr	r3, [sp, #4]
    33a0:	2b00      	cmp	r3, #0
    33a2:	d002      	beq.n	33aa <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    33a4:	9801      	ldr	r0, [sp, #4]
    33a6:	f000 f870 	bl	348a <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33aa:	bf00      	nop
    33ac:	b003      	add	sp, #12
    33ae:	f85d fb04 	ldr.w	pc, [sp], #4

000033b2 <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    33b2:	b500      	push	{lr}
    33b4:	b083      	sub	sp, #12
    33b6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    33b8:	9b01      	ldr	r3, [sp, #4]
    33ba:	2b00      	cmp	r3, #0
    33bc:	d002      	beq.n	33c4 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    33be:	9801      	ldr	r0, [sp, #4]
    33c0:	f000 f89a 	bl	34f8 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    33c4:	bf00      	nop
    33c6:	b003      	add	sp, #12
    33c8:	f85d fb04 	ldr.w	pc, [sp], #4

000033cc <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    33cc:	b500      	push	{lr}
    33ce:	b089      	sub	sp, #36	; 0x24
    33d0:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    33d2:	2301      	movs	r3, #1
    33d4:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    33d6:	2300      	movs	r3, #0
    33d8:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    33dc:	4b1e      	ldr	r3, [pc, #120]	; (3458 <Clock_Ip_CompleteSpll+0x8c>)
    33de:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    33e2:	f003 0301 	and.w	r3, r3, #1
    33e6:	2b00      	cmp	r3, #0
    33e8:	d02f      	beq.n	344a <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    33ea:	aa02      	add	r2, sp, #8
    33ec:	a903      	add	r1, sp, #12
    33ee:	a804      	add	r0, sp, #16
    33f0:	f24c 3350 	movw	r3, #50000	; 0xc350
    33f4:	f7fe fe46 	bl	2084 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    33f8:	4b17      	ldr	r3, [pc, #92]	; (3458 <Clock_Ip_CompleteSpll+0x8c>)
    33fa:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    33fe:	0e1b      	lsrs	r3, r3, #24
    3400:	f003 0301 	and.w	r3, r3, #1
    3404:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3406:	9a02      	ldr	r2, [sp, #8]
    3408:	a903      	add	r1, sp, #12
    340a:	ab04      	add	r3, sp, #16
    340c:	4618      	mov	r0, r3
    340e:	f7fe fe53 	bl	20b8 <Clock_Ip_TimeoutExpired>
    3412:	4603      	mov	r3, r0
    3414:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    3418:	9b05      	ldr	r3, [sp, #20]
    341a:	2b00      	cmp	r3, #0
    341c:	d106      	bne.n	342c <Clock_Ip_CompleteSpll+0x60>
    341e:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3422:	f083 0301 	eor.w	r3, r3, #1
    3426:	b2db      	uxtb	r3, r3
    3428:	2b00      	cmp	r3, #0
    342a:	d1e5      	bne.n	33f8 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    342c:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3430:	f083 0301 	eor.w	r3, r3, #1
    3434:	b2db      	uxtb	r3, r3
    3436:	2b00      	cmp	r3, #0
    3438:	d002      	beq.n	3440 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    343a:	2302      	movs	r3, #2
    343c:	9307      	str	r3, [sp, #28]
    343e:	e006      	b.n	344e <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    3440:	9901      	ldr	r1, [sp, #4]
    3442:	2001      	movs	r0, #1
    3444:	f7fe fe0e 	bl	2064 <Clock_Ip_ReportClockErrors>
    3448:	e001      	b.n	344e <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    344a:	2300      	movs	r3, #0
    344c:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    344e:	9b07      	ldr	r3, [sp, #28]
}
    3450:	4618      	mov	r0, r3
    3452:	b009      	add	sp, #36	; 0x24
    3454:	f85d fb04 	ldr.w	pc, [sp], #4
    3458:	40064000 	.word	0x40064000

0000345c <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    345c:	b500      	push	{lr}
    345e:	b083      	sub	sp, #12
    3460:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    3462:	9801      	ldr	r0, [sp, #4]
    3464:	f000 f886 	bl	3574 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3468:	bf00      	nop
    346a:	b003      	add	sp, #12
    346c:	f85d fb04 	ldr.w	pc, [sp], #4

00003470 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    3470:	b500      	push	{lr}
    3472:	b083      	sub	sp, #12
    3474:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3476:	9b01      	ldr	r3, [sp, #4]
    3478:	2b00      	cmp	r3, #0
    347a:	d002      	beq.n	3482 <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    347c:	9801      	ldr	r0, [sp, #4]
    347e:	f000 f891 	bl	35a4 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3482:	bf00      	nop
    3484:	b003      	add	sp, #12
    3486:	f85d fb04 	ldr.w	pc, [sp], #4

0000348a <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    348a:	b082      	sub	sp, #8
    348c:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    348e:	4b19      	ldr	r3, [pc, #100]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3490:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3494:	4a17      	ldr	r2, [pc, #92]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3496:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    349a:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    349e:	4b15      	ldr	r3, [pc, #84]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34a0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34a4:	4a13      	ldr	r2, [pc, #76]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34a6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    34aa:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    34ae:	4b11      	ldr	r3, [pc, #68]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34b0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34b4:	4a0f      	ldr	r2, [pc, #60]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34b6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    34ba:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    34be:	4b0d      	ldr	r3, [pc, #52]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34c0:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    34c4:	4a0b      	ldr	r2, [pc, #44]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34c6:	f023 0301 	bic.w	r3, r3, #1
    34ca:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    34ce:	4b09      	ldr	r3, [pc, #36]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34d0:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    34d4:	4a07      	ldr	r2, [pc, #28]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34d6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    34da:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    34de:	4b05      	ldr	r3, [pc, #20]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34e0:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    34e4:	4a03      	ldr	r2, [pc, #12]	; (34f4 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    34e6:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    34ea:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    34ee:	bf00      	nop
    34f0:	b002      	add	sp, #8
    34f2:	4770      	bx	lr
    34f4:	40064000 	.word	0x40064000

000034f8 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    34f8:	b082      	sub	sp, #8
    34fa:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    34fc:	9b01      	ldr	r3, [sp, #4]
    34fe:	889b      	ldrh	r3, [r3, #4]
    3500:	2b01      	cmp	r3, #1
    3502:	d12f      	bne.n	3564 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    3504:	4b1a      	ldr	r3, [pc, #104]	; (3570 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3506:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    350a:	9b01      	ldr	r3, [sp, #4]
    350c:	7b5b      	ldrb	r3, [r3, #13]
    350e:	3b01      	subs	r3, #1
    3510:	021b      	lsls	r3, r3, #8
    3512:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    3516:	9b01      	ldr	r3, [sp, #4]
    3518:	7d1b      	ldrb	r3, [r3, #20]
    351a:	3b10      	subs	r3, #16
    351c:	041b      	lsls	r3, r3, #16
    351e:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    3522:	430b      	orrs	r3, r1
    3524:	4912      	ldr	r1, [pc, #72]	; (3570 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3526:	4313      	orrs	r3, r2
    3528:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    352c:	9b01      	ldr	r3, [sp, #4]
    352e:	7fdb      	ldrb	r3, [r3, #31]
    3530:	2b02      	cmp	r3, #2
    3532:	d011      	beq.n	3558 <Clock_Ip_SetSpll_TrustedCall+0x60>
    3534:	2b02      	cmp	r3, #2
    3536:	dc17      	bgt.n	3568 <Clock_Ip_SetSpll_TrustedCall+0x70>
    3538:	2b00      	cmp	r3, #0
    353a:	d002      	beq.n	3542 <Clock_Ip_SetSpll_TrustedCall+0x4a>
    353c:	2b01      	cmp	r3, #1
    353e:	d005      	beq.n	354c <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    3540:	e012      	b.n	3568 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    3542:	4b0b      	ldr	r3, [pc, #44]	; (3570 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3544:	2200      	movs	r2, #0
    3546:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    354a:	e00e      	b.n	356a <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    354c:	4b08      	ldr	r3, [pc, #32]	; (3570 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    354e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    3552:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3556:	e008      	b.n	356a <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3558:	4b05      	ldr	r3, [pc, #20]	; (3570 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    355a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    355e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3562:	e002      	b.n	356a <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    3564:	bf00      	nop
    3566:	e000      	b.n	356a <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    3568:	bf00      	nop
}
    356a:	bf00      	nop
    356c:	b002      	add	sp, #8
    356e:	4770      	bx	lr
    3570:	40064000 	.word	0x40064000

00003574 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    3574:	b082      	sub	sp, #8
    3576:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    3578:	4b09      	ldr	r3, [pc, #36]	; (35a0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    357a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    357e:	4a08      	ldr	r2, [pc, #32]	; (35a0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3580:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3584:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    3588:	4b05      	ldr	r3, [pc, #20]	; (35a0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    358a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    358e:	4a04      	ldr	r2, [pc, #16]	; (35a0 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3590:	f023 0301 	bic.w	r3, r3, #1
    3594:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    3598:	bf00      	nop
    359a:	b002      	add	sp, #8
    359c:	4770      	bx	lr
    359e:	bf00      	nop
    35a0:	40064000 	.word	0x40064000

000035a4 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    35a4:	b082      	sub	sp, #8
    35a6:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    35a8:	9b01      	ldr	r3, [sp, #4]
    35aa:	889b      	ldrh	r3, [r3, #4]
    35ac:	2b01      	cmp	r3, #1
    35ae:	d107      	bne.n	35c0 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    35b0:	4b05      	ldr	r3, [pc, #20]	; (35c8 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    35b2:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    35b6:	4a04      	ldr	r2, [pc, #16]	; (35c8 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    35b8:	f043 0301 	orr.w	r3, r3, #1
    35bc:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    35c0:	bf00      	nop
    35c2:	b002      	add	sp, #8
    35c4:	4770      	bx	lr
    35c6:	bf00      	nop
    35c8:	40064000 	.word	0x40064000

000035cc <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    35cc:	b082      	sub	sp, #8
    35ce:	9001      	str	r0, [sp, #4]
    35d0:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    35d2:	bf00      	nop
    35d4:	b002      	add	sp, #8
    35d6:	4770      	bx	lr

000035d8 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    35d8:	b082      	sub	sp, #8
    35da:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    35dc:	bf00      	nop
    35de:	b002      	add	sp, #8
    35e0:	4770      	bx	lr

000035e2 <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    35e2:	b500      	push	{lr}
    35e4:	b083      	sub	sp, #12
    35e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    35e8:	9b01      	ldr	r3, [sp, #4]
    35ea:	2b00      	cmp	r3, #0
    35ec:	d002      	beq.n	35f4 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    35ee:	9801      	ldr	r0, [sp, #4]
    35f0:	f000 f8ee 	bl	37d0 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    35f4:	bf00      	nop
    35f6:	b003      	add	sp, #12
    35f8:	f85d fb04 	ldr.w	pc, [sp], #4

000035fc <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    35fc:	b500      	push	{lr}
    35fe:	b083      	sub	sp, #12
    3600:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3602:	9b01      	ldr	r3, [sp, #4]
    3604:	2b00      	cmp	r3, #0
    3606:	d002      	beq.n	360e <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    3608:	9801      	ldr	r0, [sp, #4]
    360a:	f000 f8ff 	bl	380c <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    360e:	bf00      	nop
    3610:	b003      	add	sp, #12
    3612:	f85d fb04 	ldr.w	pc, [sp], #4

00003616 <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    3616:	b500      	push	{lr}
    3618:	b083      	sub	sp, #12
    361a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    361c:	9b01      	ldr	r3, [sp, #4]
    361e:	2b00      	cmp	r3, #0
    3620:	d002      	beq.n	3628 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    3622:	9801      	ldr	r0, [sp, #4]
    3624:	f000 f912 	bl	384c <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3628:	bf00      	nop
    362a:	b003      	add	sp, #12
    362c:	f85d fb04 	ldr.w	pc, [sp], #4

00003630 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    3630:	b500      	push	{lr}
    3632:	b083      	sub	sp, #12
    3634:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3636:	9b01      	ldr	r3, [sp, #4]
    3638:	2b00      	cmp	r3, #0
    363a:	d002      	beq.n	3642 <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    363c:	9801      	ldr	r0, [sp, #4]
    363e:	f000 f925 	bl	388c <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3642:	bf00      	nop
    3644:	b003      	add	sp, #12
    3646:	f85d fb04 	ldr.w	pc, [sp], #4

0000364a <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    364a:	b500      	push	{lr}
    364c:	b083      	sub	sp, #12
    364e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3650:	9b01      	ldr	r3, [sp, #4]
    3652:	2b00      	cmp	r3, #0
    3654:	d002      	beq.n	365c <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    3656:	9801      	ldr	r0, [sp, #4]
    3658:	f000 f936 	bl	38c8 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    365c:	bf00      	nop
    365e:	b003      	add	sp, #12
    3660:	f85d fb04 	ldr.w	pc, [sp], #4

00003664 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    3664:	b500      	push	{lr}
    3666:	b083      	sub	sp, #12
    3668:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    366a:	9b01      	ldr	r3, [sp, #4]
    366c:	2b00      	cmp	r3, #0
    366e:	d002      	beq.n	3676 <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    3670:	9801      	ldr	r0, [sp, #4]
    3672:	f000 f949 	bl	3908 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3676:	bf00      	nop
    3678:	b003      	add	sp, #12
    367a:	f85d fb04 	ldr.w	pc, [sp], #4

0000367e <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    367e:	b500      	push	{lr}
    3680:	b083      	sub	sp, #12
    3682:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3684:	9b01      	ldr	r3, [sp, #4]
    3686:	2b00      	cmp	r3, #0
    3688:	d002      	beq.n	3690 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    368a:	9801      	ldr	r0, [sp, #4]
    368c:	f000 f958 	bl	3940 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3690:	bf00      	nop
    3692:	b003      	add	sp, #12
    3694:	f85d fb04 	ldr.w	pc, [sp], #4

00003698 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    3698:	b500      	push	{lr}
    369a:	b083      	sub	sp, #12
    369c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    369e:	9b01      	ldr	r3, [sp, #4]
    36a0:	2b00      	cmp	r3, #0
    36a2:	d002      	beq.n	36aa <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    36a4:	9801      	ldr	r0, [sp, #4]
    36a6:	f000 f969 	bl	397c <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36aa:	bf00      	nop
    36ac:	b003      	add	sp, #12
    36ae:	f85d fb04 	ldr.w	pc, [sp], #4

000036b2 <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    36b2:	b500      	push	{lr}
    36b4:	b083      	sub	sp, #12
    36b6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36b8:	9b01      	ldr	r3, [sp, #4]
    36ba:	2b00      	cmp	r3, #0
    36bc:	d002      	beq.n	36c4 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    36be:	9801      	ldr	r0, [sp, #4]
    36c0:	f000 f978 	bl	39b4 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36c4:	bf00      	nop
    36c6:	b003      	add	sp, #12
    36c8:	f85d fb04 	ldr.w	pc, [sp], #4

000036cc <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    36cc:	b500      	push	{lr}
    36ce:	b083      	sub	sp, #12
    36d0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36d2:	9b01      	ldr	r3, [sp, #4]
    36d4:	2b00      	cmp	r3, #0
    36d6:	d002      	beq.n	36de <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    36d8:	9801      	ldr	r0, [sp, #4]
    36da:	f000 f989 	bl	39f0 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36de:	bf00      	nop
    36e0:	b003      	add	sp, #12
    36e2:	f85d fb04 	ldr.w	pc, [sp], #4

000036e6 <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    36e6:	b500      	push	{lr}
    36e8:	b083      	sub	sp, #12
    36ea:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36ec:	9b01      	ldr	r3, [sp, #4]
    36ee:	2b00      	cmp	r3, #0
    36f0:	d002      	beq.n	36f8 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    36f2:	9801      	ldr	r0, [sp, #4]
    36f4:	f000 f998 	bl	3a28 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36f8:	bf00      	nop
    36fa:	b003      	add	sp, #12
    36fc:	f85d fb04 	ldr.w	pc, [sp], #4

00003700 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    3700:	b500      	push	{lr}
    3702:	b083      	sub	sp, #12
    3704:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3706:	9b01      	ldr	r3, [sp, #4]
    3708:	2b00      	cmp	r3, #0
    370a:	d002      	beq.n	3712 <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    370c:	9801      	ldr	r0, [sp, #4]
    370e:	f000 f9a9 	bl	3a64 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3712:	bf00      	nop
    3714:	b003      	add	sp, #12
    3716:	f85d fb04 	ldr.w	pc, [sp], #4

0000371a <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    371a:	b500      	push	{lr}
    371c:	b083      	sub	sp, #12
    371e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3720:	9b01      	ldr	r3, [sp, #4]
    3722:	2b00      	cmp	r3, #0
    3724:	d002      	beq.n	372c <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    3726:	9801      	ldr	r0, [sp, #4]
    3728:	f000 f9e6 	bl	3af8 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    372c:	bf00      	nop
    372e:	b003      	add	sp, #12
    3730:	f85d fb04 	ldr.w	pc, [sp], #4

00003734 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3734:	b500      	push	{lr}
    3736:	b083      	sub	sp, #12
    3738:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    373a:	9b01      	ldr	r3, [sp, #4]
    373c:	2b00      	cmp	r3, #0
    373e:	d002      	beq.n	3746 <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    3740:	9801      	ldr	r0, [sp, #4]
    3742:	f000 fa25 	bl	3b90 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3746:	bf00      	nop
    3748:	b003      	add	sp, #12
    374a:	f85d fb04 	ldr.w	pc, [sp], #4

0000374e <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    374e:	b500      	push	{lr}
    3750:	b083      	sub	sp, #12
    3752:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3754:	9b01      	ldr	r3, [sp, #4]
    3756:	2b00      	cmp	r3, #0
    3758:	d002      	beq.n	3760 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    375a:	9801      	ldr	r0, [sp, #4]
    375c:	f000 fa2a 	bl	3bb4 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3760:	bf00      	nop
    3762:	b003      	add	sp, #12
    3764:	f85d fb04 	ldr.w	pc, [sp], #4

00003768 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    3768:	b500      	push	{lr}
    376a:	b083      	sub	sp, #12
    376c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    376e:	9b01      	ldr	r3, [sp, #4]
    3770:	2b00      	cmp	r3, #0
    3772:	d002      	beq.n	377a <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    3774:	9801      	ldr	r0, [sp, #4]
    3776:	f000 fa3b 	bl	3bf0 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    377a:	bf00      	nop
    377c:	b003      	add	sp, #12
    377e:	f85d fb04 	ldr.w	pc, [sp], #4

00003782 <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    3782:	b500      	push	{lr}
    3784:	b083      	sub	sp, #12
    3786:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3788:	9b01      	ldr	r3, [sp, #4]
    378a:	2b00      	cmp	r3, #0
    378c:	d002      	beq.n	3794 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    378e:	9801      	ldr	r0, [sp, #4]
    3790:	f000 fa56 	bl	3c40 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3794:	bf00      	nop
    3796:	b003      	add	sp, #12
    3798:	f85d fb04 	ldr.w	pc, [sp], #4

0000379c <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    379c:	b500      	push	{lr}
    379e:	b083      	sub	sp, #12
    37a0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37a2:	9b01      	ldr	r3, [sp, #4]
    37a4:	2b00      	cmp	r3, #0
    37a6:	d002      	beq.n	37ae <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    37a8:	9801      	ldr	r0, [sp, #4]
    37aa:	f000 fa79 	bl	3ca0 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37ae:	bf00      	nop
    37b0:	b003      	add	sp, #12
    37b2:	f85d fb04 	ldr.w	pc, [sp], #4

000037b6 <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    37b6:	b500      	push	{lr}
    37b8:	b083      	sub	sp, #12
    37ba:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37bc:	9b01      	ldr	r3, [sp, #4]
    37be:	2b00      	cmp	r3, #0
    37c0:	d002      	beq.n	37c8 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    37c2:	9801      	ldr	r0, [sp, #4]
    37c4:	f000 fa8a 	bl	3cdc <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37c8:	bf00      	nop
    37ca:	b003      	add	sp, #12
    37cc:	f85d fb04 	ldr.w	pc, [sp], #4

000037d0 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    37d0:	b084      	sub	sp, #16
    37d2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    37d4:	4b0b      	ldr	r3, [pc, #44]	; (3804 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    37d6:	795b      	ldrb	r3, [r3, #5]
    37d8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    37da:	4b0b      	ldr	r3, [pc, #44]	; (3808 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    37dc:	695b      	ldr	r3, [r3, #20]
    37de:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    37e0:	9b02      	ldr	r3, [sp, #8]
    37e2:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    37e6:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    37e8:	9b03      	ldr	r3, [sp, #12]
    37ea:	061b      	lsls	r3, r3, #24
    37ec:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    37f0:	9a02      	ldr	r2, [sp, #8]
    37f2:	4313      	orrs	r3, r2
    37f4:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    37f6:	4a04      	ldr	r2, [pc, #16]	; (3808 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    37f8:	9b02      	ldr	r3, [sp, #8]
    37fa:	6153      	str	r3, [r2, #20]
}
    37fc:	bf00      	nop
    37fe:	b004      	add	sp, #16
    3800:	4770      	bx	lr
    3802:	bf00      	nop
    3804:	0000c2d0 	.word	0x0000c2d0
    3808:	40064000 	.word	0x40064000

0000380c <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    380c:	b084      	sub	sp, #16
    380e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3810:	9b01      	ldr	r3, [sp, #4]
    3812:	685b      	ldr	r3, [r3, #4]
    3814:	4a0b      	ldr	r2, [pc, #44]	; (3844 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    3816:	5cd3      	ldrb	r3, [r2, r3]
    3818:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    381a:	4b0b      	ldr	r3, [pc, #44]	; (3848 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    381c:	695b      	ldr	r3, [r3, #20]
    381e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3820:	9b02      	ldr	r3, [sp, #8]
    3822:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3826:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    3828:	9b03      	ldr	r3, [sp, #12]
    382a:	061b      	lsls	r3, r3, #24
    382c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3830:	9a02      	ldr	r2, [sp, #8]
    3832:	4313      	orrs	r3, r2
    3834:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    3836:	4a04      	ldr	r2, [pc, #16]	; (3848 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    3838:	9b02      	ldr	r3, [sp, #8]
    383a:	6153      	str	r3, [r2, #20]
}
    383c:	bf00      	nop
    383e:	b004      	add	sp, #16
    3840:	4770      	bx	lr
    3842:	bf00      	nop
    3844:	0000c2d0 	.word	0x0000c2d0
    3848:	40064000 	.word	0x40064000

0000384c <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    384c:	b084      	sub	sp, #16
    384e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3850:	9b01      	ldr	r3, [sp, #4]
    3852:	685b      	ldr	r3, [r3, #4]
    3854:	4a0b      	ldr	r2, [pc, #44]	; (3884 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    3856:	5cd3      	ldrb	r3, [r2, r3]
    3858:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    385a:	4b0b      	ldr	r3, [pc, #44]	; (3888 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    385c:	699b      	ldr	r3, [r3, #24]
    385e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    3860:	9b02      	ldr	r3, [sp, #8]
    3862:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3866:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    3868:	9b03      	ldr	r3, [sp, #12]
    386a:	061b      	lsls	r3, r3, #24
    386c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3870:	9a02      	ldr	r2, [sp, #8]
    3872:	4313      	orrs	r3, r2
    3874:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    3876:	4a04      	ldr	r2, [pc, #16]	; (3888 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3878:	9b02      	ldr	r3, [sp, #8]
    387a:	6193      	str	r3, [r2, #24]
}
    387c:	bf00      	nop
    387e:	b004      	add	sp, #16
    3880:	4770      	bx	lr
    3882:	bf00      	nop
    3884:	0000c2d0 	.word	0x0000c2d0
    3888:	40064000 	.word	0x40064000

0000388c <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    388c:	b084      	sub	sp, #16
    388e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3890:	4b0b      	ldr	r3, [pc, #44]	; (38c0 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    3892:	795b      	ldrb	r3, [r3, #5]
    3894:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    3896:	4b0b      	ldr	r3, [pc, #44]	; (38c4 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    3898:	69db      	ldr	r3, [r3, #28]
    389a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    389c:	9b02      	ldr	r3, [sp, #8]
    389e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    38a2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    38a4:	9b03      	ldr	r3, [sp, #12]
    38a6:	061b      	lsls	r3, r3, #24
    38a8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    38ac:	9a02      	ldr	r2, [sp, #8]
    38ae:	4313      	orrs	r3, r2
    38b0:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    38b2:	4a04      	ldr	r2, [pc, #16]	; (38c4 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    38b4:	9b02      	ldr	r3, [sp, #8]
    38b6:	61d3      	str	r3, [r2, #28]
}
    38b8:	bf00      	nop
    38ba:	b004      	add	sp, #16
    38bc:	4770      	bx	lr
    38be:	bf00      	nop
    38c0:	0000c2d0 	.word	0x0000c2d0
    38c4:	40064000 	.word	0x40064000

000038c8 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    38c8:	b084      	sub	sp, #16
    38ca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    38cc:	9b01      	ldr	r3, [sp, #4]
    38ce:	685b      	ldr	r3, [r3, #4]
    38d0:	4a0b      	ldr	r2, [pc, #44]	; (3900 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    38d2:	5cd3      	ldrb	r3, [r2, r3]
    38d4:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    38d6:	4b0b      	ldr	r3, [pc, #44]	; (3904 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    38d8:	69db      	ldr	r3, [r3, #28]
    38da:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    38dc:	9b02      	ldr	r3, [sp, #8]
    38de:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    38e2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    38e4:	9b03      	ldr	r3, [sp, #12]
    38e6:	061b      	lsls	r3, r3, #24
    38e8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    38ec:	9a02      	ldr	r2, [sp, #8]
    38ee:	4313      	orrs	r3, r2
    38f0:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    38f2:	4a04      	ldr	r2, [pc, #16]	; (3904 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    38f4:	9b02      	ldr	r3, [sp, #8]
    38f6:	61d3      	str	r3, [r2, #28]
}
    38f8:	bf00      	nop
    38fa:	b004      	add	sp, #16
    38fc:	4770      	bx	lr
    38fe:	bf00      	nop
    3900:	0000c2d0 	.word	0x0000c2d0
    3904:	40064000 	.word	0x40064000

00003908 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3908:	b084      	sub	sp, #16
    390a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    390c:	4b0a      	ldr	r3, [pc, #40]	; (3938 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    390e:	7b9b      	ldrb	r3, [r3, #14]
    3910:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    3912:	4b0a      	ldr	r3, [pc, #40]	; (393c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    3914:	691b      	ldr	r3, [r3, #16]
    3916:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    3918:	9b02      	ldr	r3, [sp, #8]
    391a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    391e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3920:	9b03      	ldr	r3, [sp, #12]
    3922:	011b      	lsls	r3, r3, #4
    3924:	9a02      	ldr	r2, [sp, #8]
    3926:	4313      	orrs	r3, r2
    3928:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    392a:	4a04      	ldr	r2, [pc, #16]	; (393c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    392c:	9b02      	ldr	r3, [sp, #8]
    392e:	6113      	str	r3, [r2, #16]
}
    3930:	bf00      	nop
    3932:	b004      	add	sp, #16
    3934:	4770      	bx	lr
    3936:	bf00      	nop
    3938:	0000c278 	.word	0x0000c278
    393c:	40048000 	.word	0x40048000

00003940 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3940:	b084      	sub	sp, #16
    3942:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3944:	9b01      	ldr	r3, [sp, #4]
    3946:	685b      	ldr	r3, [r3, #4]
    3948:	4a0a      	ldr	r2, [pc, #40]	; (3974 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    394a:	5cd3      	ldrb	r3, [r2, r3]
    394c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    394e:	4b0a      	ldr	r3, [pc, #40]	; (3978 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3950:	691b      	ldr	r3, [r3, #16]
    3952:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    3954:	9b02      	ldr	r3, [sp, #8]
    3956:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    395a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    395c:	9b03      	ldr	r3, [sp, #12]
    395e:	011b      	lsls	r3, r3, #4
    3960:	9a02      	ldr	r2, [sp, #8]
    3962:	4313      	orrs	r3, r2
    3964:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    3966:	4a04      	ldr	r2, [pc, #16]	; (3978 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3968:	9b02      	ldr	r3, [sp, #8]
    396a:	6113      	str	r3, [r2, #16]
}
    396c:	bf00      	nop
    396e:	b004      	add	sp, #16
    3970:	4770      	bx	lr
    3972:	bf00      	nop
    3974:	0000c278 	.word	0x0000c278
    3978:	40048000 	.word	0x40048000

0000397c <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    397c:	b084      	sub	sp, #16
    397e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3980:	4b0a      	ldr	r3, [pc, #40]	; (39ac <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    3982:	785b      	ldrb	r3, [r3, #1]
    3984:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    3986:	4b0a      	ldr	r3, [pc, #40]	; (39b0 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    3988:	691b      	ldr	r3, [r3, #16]
    398a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    398c:	9b02      	ldr	r3, [sp, #8]
    398e:	f023 030c 	bic.w	r3, r3, #12
    3992:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3994:	9b03      	ldr	r3, [sp, #12]
    3996:	009b      	lsls	r3, r3, #2
    3998:	9a02      	ldr	r2, [sp, #8]
    399a:	4313      	orrs	r3, r2
    399c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    399e:	4a04      	ldr	r2, [pc, #16]	; (39b0 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    39a0:	9b02      	ldr	r3, [sp, #8]
    39a2:	6113      	str	r3, [r2, #16]
}
    39a4:	bf00      	nop
    39a6:	b004      	add	sp, #16
    39a8:	4770      	bx	lr
    39aa:	bf00      	nop
    39ac:	0000c330 	.word	0x0000c330
    39b0:	40048000 	.word	0x40048000

000039b4 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    39b4:	b084      	sub	sp, #16
    39b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    39b8:	9b01      	ldr	r3, [sp, #4]
    39ba:	685b      	ldr	r3, [r3, #4]
    39bc:	4a0a      	ldr	r2, [pc, #40]	; (39e8 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    39be:	5cd3      	ldrb	r3, [r2, r3]
    39c0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    39c2:	4b0a      	ldr	r3, [pc, #40]	; (39ec <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    39c4:	691b      	ldr	r3, [r3, #16]
    39c6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    39c8:	9b02      	ldr	r3, [sp, #8]
    39ca:	f023 030c 	bic.w	r3, r3, #12
    39ce:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    39d0:	9b03      	ldr	r3, [sp, #12]
    39d2:	009b      	lsls	r3, r3, #2
    39d4:	9a02      	ldr	r2, [sp, #8]
    39d6:	4313      	orrs	r3, r2
    39d8:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    39da:	4a04      	ldr	r2, [pc, #16]	; (39ec <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    39dc:	9b02      	ldr	r3, [sp, #8]
    39de:	6113      	str	r3, [r2, #16]
}
    39e0:	bf00      	nop
    39e2:	b004      	add	sp, #16
    39e4:	4770      	bx	lr
    39e6:	bf00      	nop
    39e8:	0000c330 	.word	0x0000c330
    39ec:	40048000 	.word	0x40048000

000039f0 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    39f0:	b084      	sub	sp, #16
    39f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    39f4:	4b0a      	ldr	r3, [pc, #40]	; (3a20 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    39f6:	795b      	ldrb	r3, [r3, #5]
    39f8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    39fa:	4b0a      	ldr	r3, [pc, #40]	; (3a24 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    39fc:	6a1b      	ldr	r3, [r3, #32]
    39fe:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    3a00:	9b02      	ldr	r3, [sp, #8]
    3a02:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3a06:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    3a08:	9b03      	ldr	r3, [sp, #12]
    3a0a:	061b      	lsls	r3, r3, #24
    3a0c:	9a02      	ldr	r2, [sp, #8]
    3a0e:	4313      	orrs	r3, r2
    3a10:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    3a12:	4a04      	ldr	r2, [pc, #16]	; (3a24 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    3a14:	9b02      	ldr	r3, [sp, #8]
    3a16:	6213      	str	r3, [r2, #32]
}
    3a18:	bf00      	nop
    3a1a:	b004      	add	sp, #16
    3a1c:	4770      	bx	lr
    3a1e:	bf00      	nop
    3a20:	0000c2d0 	.word	0x0000c2d0
    3a24:	40064000 	.word	0x40064000

00003a28 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3a28:	b084      	sub	sp, #16
    3a2a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3a2c:	9b01      	ldr	r3, [sp, #4]
    3a2e:	685b      	ldr	r3, [r3, #4]
    3a30:	4a0a      	ldr	r2, [pc, #40]	; (3a5c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    3a32:	5cd3      	ldrb	r3, [r2, r3]
    3a34:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    3a36:	4b0a      	ldr	r3, [pc, #40]	; (3a60 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3a38:	6a1b      	ldr	r3, [r3, #32]
    3a3a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    3a3c:	9b02      	ldr	r3, [sp, #8]
    3a3e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3a42:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    3a44:	9b03      	ldr	r3, [sp, #12]
    3a46:	061b      	lsls	r3, r3, #24
    3a48:	9a02      	ldr	r2, [sp, #8]
    3a4a:	4313      	orrs	r3, r2
    3a4c:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    3a4e:	4a04      	ldr	r2, [pc, #16]	; (3a60 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3a50:	9b02      	ldr	r3, [sp, #8]
    3a52:	6213      	str	r3, [r2, #32]
}
    3a54:	bf00      	nop
    3a56:	b004      	add	sp, #16
    3a58:	4770      	bx	lr
    3a5a:	bf00      	nop
    3a5c:	0000c2d0 	.word	0x0000c2d0
    3a60:	40064000 	.word	0x40064000

00003a64 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3a64:	b086      	sub	sp, #24
    3a66:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3a68:	4b20      	ldr	r3, [pc, #128]	; (3aec <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    3a6a:	795b      	ldrb	r3, [r3, #5]
    3a6c:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3a6e:	9b01      	ldr	r3, [sp, #4]
    3a70:	681a      	ldr	r2, [r3, #0]
    3a72:	491f      	ldr	r1, [pc, #124]	; (3af0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    3a74:	4613      	mov	r3, r2
    3a76:	00db      	lsls	r3, r3, #3
    3a78:	4413      	add	r3, r2
    3a7a:	440b      	add	r3, r1
    3a7c:	781b      	ldrb	r3, [r3, #0]
    3a7e:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    3a80:	4b1c      	ldr	r3, [pc, #112]	; (3af4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    3a82:	68db      	ldr	r3, [r3, #12]
    3a84:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    3a86:	9b03      	ldr	r3, [sp, #12]
    3a88:	2b03      	cmp	r3, #3
    3a8a:	d813      	bhi.n	3ab4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3a8c:	9b03      	ldr	r3, [sp, #12]
    3a8e:	005b      	lsls	r3, r3, #1
    3a90:	3318      	adds	r3, #24
    3a92:	2203      	movs	r2, #3
    3a94:	fa02 f303 	lsl.w	r3, r2, r3
    3a98:	43db      	mvns	r3, r3
    3a9a:	9a05      	ldr	r2, [sp, #20]
    3a9c:	4013      	ands	r3, r2
    3a9e:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3aa0:	9b03      	ldr	r3, [sp, #12]
    3aa2:	005b      	lsls	r3, r3, #1
    3aa4:	3318      	adds	r3, #24
    3aa6:	9a04      	ldr	r2, [sp, #16]
    3aa8:	fa02 f303 	lsl.w	r3, r2, r3
    3aac:	9a05      	ldr	r2, [sp, #20]
    3aae:	4313      	orrs	r3, r2
    3ab0:	9305      	str	r3, [sp, #20]
    3ab2:	e014      	b.n	3ade <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3ab4:	9b03      	ldr	r3, [sp, #12]
    3ab6:	3b04      	subs	r3, #4
    3ab8:	005b      	lsls	r3, r3, #1
    3aba:	3310      	adds	r3, #16
    3abc:	2203      	movs	r2, #3
    3abe:	fa02 f303 	lsl.w	r3, r2, r3
    3ac2:	43db      	mvns	r3, r3
    3ac4:	9a05      	ldr	r2, [sp, #20]
    3ac6:	4013      	ands	r3, r2
    3ac8:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3aca:	9b03      	ldr	r3, [sp, #12]
    3acc:	3b04      	subs	r3, #4
    3ace:	005b      	lsls	r3, r3, #1
    3ad0:	3310      	adds	r3, #16
    3ad2:	9a04      	ldr	r2, [sp, #16]
    3ad4:	fa02 f303 	lsl.w	r3, r2, r3
    3ad8:	9a05      	ldr	r2, [sp, #20]
    3ada:	4313      	orrs	r3, r2
    3adc:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    3ade:	4a05      	ldr	r2, [pc, #20]	; (3af4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    3ae0:	9b05      	ldr	r3, [sp, #20]
    3ae2:	60d3      	str	r3, [r2, #12]
}
    3ae4:	bf00      	nop
    3ae6:	b006      	add	sp, #24
    3ae8:	4770      	bx	lr
    3aea:	bf00      	nop
    3aec:	0000c278 	.word	0x0000c278
    3af0:	0000bf68 	.word	0x0000bf68
    3af4:	40048000 	.word	0x40048000

00003af8 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3af8:	b086      	sub	sp, #24
    3afa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3afc:	9b01      	ldr	r3, [sp, #4]
    3afe:	685b      	ldr	r3, [r3, #4]
    3b00:	4a20      	ldr	r2, [pc, #128]	; (3b84 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    3b02:	5cd3      	ldrb	r3, [r2, r3]
    3b04:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3b06:	9b01      	ldr	r3, [sp, #4]
    3b08:	681a      	ldr	r2, [r3, #0]
    3b0a:	491f      	ldr	r1, [pc, #124]	; (3b88 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    3b0c:	4613      	mov	r3, r2
    3b0e:	00db      	lsls	r3, r3, #3
    3b10:	4413      	add	r3, r2
    3b12:	440b      	add	r3, r1
    3b14:	781b      	ldrb	r3, [r3, #0]
    3b16:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    3b18:	4b1c      	ldr	r3, [pc, #112]	; (3b8c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3b1a:	68db      	ldr	r3, [r3, #12]
    3b1c:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    3b1e:	9b03      	ldr	r3, [sp, #12]
    3b20:	2b03      	cmp	r3, #3
    3b22:	d813      	bhi.n	3b4c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3b24:	9b03      	ldr	r3, [sp, #12]
    3b26:	005b      	lsls	r3, r3, #1
    3b28:	3318      	adds	r3, #24
    3b2a:	2203      	movs	r2, #3
    3b2c:	fa02 f303 	lsl.w	r3, r2, r3
    3b30:	43db      	mvns	r3, r3
    3b32:	9a05      	ldr	r2, [sp, #20]
    3b34:	4013      	ands	r3, r2
    3b36:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3b38:	9b03      	ldr	r3, [sp, #12]
    3b3a:	005b      	lsls	r3, r3, #1
    3b3c:	3318      	adds	r3, #24
    3b3e:	9a04      	ldr	r2, [sp, #16]
    3b40:	fa02 f303 	lsl.w	r3, r2, r3
    3b44:	9a05      	ldr	r2, [sp, #20]
    3b46:	4313      	orrs	r3, r2
    3b48:	9305      	str	r3, [sp, #20]
    3b4a:	e014      	b.n	3b76 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3b4c:	9b03      	ldr	r3, [sp, #12]
    3b4e:	3b04      	subs	r3, #4
    3b50:	005b      	lsls	r3, r3, #1
    3b52:	3310      	adds	r3, #16
    3b54:	2203      	movs	r2, #3
    3b56:	fa02 f303 	lsl.w	r3, r2, r3
    3b5a:	43db      	mvns	r3, r3
    3b5c:	9a05      	ldr	r2, [sp, #20]
    3b5e:	4013      	ands	r3, r2
    3b60:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3b62:	9b03      	ldr	r3, [sp, #12]
    3b64:	3b04      	subs	r3, #4
    3b66:	005b      	lsls	r3, r3, #1
    3b68:	3310      	adds	r3, #16
    3b6a:	9a04      	ldr	r2, [sp, #16]
    3b6c:	fa02 f303 	lsl.w	r3, r2, r3
    3b70:	9a05      	ldr	r2, [sp, #20]
    3b72:	4313      	orrs	r3, r2
    3b74:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    3b76:	4a05      	ldr	r2, [pc, #20]	; (3b8c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3b78:	9b05      	ldr	r3, [sp, #20]
    3b7a:	60d3      	str	r3, [r2, #12]
}
    3b7c:	bf00      	nop
    3b7e:	b006      	add	sp, #24
    3b80:	4770      	bx	lr
    3b82:	bf00      	nop
    3b84:	0000c278 	.word	0x0000c278
    3b88:	0000bf68 	.word	0x0000bf68
    3b8c:	40048000 	.word	0x40048000

00003b90 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3b90:	b084      	sub	sp, #16
    3b92:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    3b94:	4b06      	ldr	r3, [pc, #24]	; (3bb0 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3b96:	685b      	ldr	r3, [r3, #4]
    3b98:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    3b9a:	9b03      	ldr	r3, [sp, #12]
    3b9c:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    3ba0:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3ba2:	4a03      	ldr	r2, [pc, #12]	; (3bb0 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3ba4:	9b03      	ldr	r3, [sp, #12]
    3ba6:	6053      	str	r3, [r2, #4]
}
    3ba8:	bf00      	nop
    3baa:	b004      	add	sp, #16
    3bac:	4770      	bx	lr
    3bae:	bf00      	nop
    3bb0:	40048000 	.word	0x40048000

00003bb4 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3bb4:	b084      	sub	sp, #16
    3bb6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3bb8:	9b01      	ldr	r3, [sp, #4]
    3bba:	685b      	ldr	r3, [r3, #4]
    3bbc:	4a0a      	ldr	r2, [pc, #40]	; (3be8 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    3bbe:	5cd3      	ldrb	r3, [r2, r3]
    3bc0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    3bc2:	4b0a      	ldr	r3, [pc, #40]	; (3bec <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3bc4:	685b      	ldr	r3, [r3, #4]
    3bc6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    3bc8:	9b02      	ldr	r3, [sp, #8]
    3bca:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3bce:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    3bd0:	9b03      	ldr	r3, [sp, #12]
    3bd2:	011b      	lsls	r3, r3, #4
    3bd4:	9a02      	ldr	r2, [sp, #8]
    3bd6:	4313      	orrs	r3, r2
    3bd8:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    3bda:	4a04      	ldr	r2, [pc, #16]	; (3bec <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3bdc:	9b02      	ldr	r3, [sp, #8]
    3bde:	6053      	str	r3, [r2, #4]
}
    3be0:	bf00      	nop
    3be2:	b004      	add	sp, #16
    3be4:	4770      	bx	lr
    3be6:	bf00      	nop
    3be8:	0000c278 	.word	0x0000c278
    3bec:	40048000 	.word	0x40048000

00003bf0 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3bf0:	b084      	sub	sp, #16
    3bf2:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    3bf4:	9b01      	ldr	r3, [sp, #4]
    3bf6:	681a      	ldr	r2, [r3, #0]
    3bf8:	490f      	ldr	r1, [pc, #60]	; (3c38 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    3bfa:	4613      	mov	r3, r2
    3bfc:	00db      	lsls	r3, r3, #3
    3bfe:	4413      	add	r3, r2
    3c00:	440b      	add	r3, r1
    3c02:	3304      	adds	r3, #4
    3c04:	781b      	ldrb	r3, [r3, #0]
    3c06:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    3c08:	4a0c      	ldr	r2, [pc, #48]	; (3c3c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c0a:	9b03      	ldr	r3, [sp, #12]
    3c0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c10:	490a      	ldr	r1, [pc, #40]	; (3c3c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c12:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    3c16:	9b03      	ldr	r3, [sp, #12]
    3c18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    3c1c:	4a07      	ldr	r2, [pc, #28]	; (3c3c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c1e:	9b03      	ldr	r3, [sp, #12]
    3c20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c24:	4905      	ldr	r1, [pc, #20]	; (3c3c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    3c26:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    3c2a:	9b03      	ldr	r3, [sp, #12]
    3c2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3c30:	bf00      	nop
    3c32:	b004      	add	sp, #16
    3c34:	4770      	bx	lr
    3c36:	bf00      	nop
    3c38:	0000bf68 	.word	0x0000bf68
    3c3c:	40065000 	.word	0x40065000

00003c40 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3c40:	b086      	sub	sp, #24
    3c42:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    3c44:	9b01      	ldr	r3, [sp, #4]
    3c46:	681a      	ldr	r2, [r3, #0]
    3c48:	4912      	ldr	r1, [pc, #72]	; (3c94 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    3c4a:	4613      	mov	r3, r2
    3c4c:	00db      	lsls	r3, r3, #3
    3c4e:	4413      	add	r3, r2
    3c50:	440b      	add	r3, r1
    3c52:	3304      	adds	r3, #4
    3c54:	781b      	ldrb	r3, [r3, #0]
    3c56:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3c58:	9b01      	ldr	r3, [sp, #4]
    3c5a:	685b      	ldr	r3, [r3, #4]
    3c5c:	4a0e      	ldr	r2, [pc, #56]	; (3c98 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    3c5e:	5cd3      	ldrb	r3, [r2, r3]
    3c60:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    3c62:	4a0e      	ldr	r2, [pc, #56]	; (3c9c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3c64:	9b05      	ldr	r3, [sp, #20]
    3c66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3c6a:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    3c6c:	9b03      	ldr	r3, [sp, #12]
    3c6e:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    3c72:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    3c74:	9b04      	ldr	r3, [sp, #16]
    3c76:	061b      	lsls	r3, r3, #24
    3c78:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    3c7c:	9a03      	ldr	r2, [sp, #12]
    3c7e:	4313      	orrs	r3, r2
    3c80:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    3c82:	4906      	ldr	r1, [pc, #24]	; (3c9c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3c84:	9b05      	ldr	r3, [sp, #20]
    3c86:	9a03      	ldr	r2, [sp, #12]
    3c88:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3c8c:	bf00      	nop
    3c8e:	b006      	add	sp, #24
    3c90:	4770      	bx	lr
    3c92:	bf00      	nop
    3c94:	0000bf68 	.word	0x0000bf68
    3c98:	0000c300 	.word	0x0000c300
    3c9c:	40065000 	.word	0x40065000

00003ca0 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3ca0:	b084      	sub	sp, #16
    3ca2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3ca4:	4b0b      	ldr	r3, [pc, #44]	; (3cd4 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    3ca6:	7f1b      	ldrb	r3, [r3, #28]
    3ca8:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    3caa:	4b0b      	ldr	r3, [pc, #44]	; (3cd8 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3cac:	685b      	ldr	r3, [r3, #4]
    3cae:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    3cb0:	9b02      	ldr	r3, [sp, #8]
    3cb2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    3cb6:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3cb8:	9b03      	ldr	r3, [sp, #12]
    3cba:	031b      	lsls	r3, r3, #12
    3cbc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    3cc0:	9a02      	ldr	r2, [sp, #8]
    3cc2:	4313      	orrs	r3, r2
    3cc4:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    3cc6:	4a04      	ldr	r2, [pc, #16]	; (3cd8 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3cc8:	9b02      	ldr	r3, [sp, #8]
    3cca:	6053      	str	r3, [r2, #4]
}
    3ccc:	bf00      	nop
    3cce:	b004      	add	sp, #16
    3cd0:	4770      	bx	lr
    3cd2:	bf00      	nop
    3cd4:	0000c278 	.word	0x0000c278
    3cd8:	40048000 	.word	0x40048000

00003cdc <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3cdc:	b084      	sub	sp, #16
    3cde:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3ce0:	9b01      	ldr	r3, [sp, #4]
    3ce2:	685b      	ldr	r3, [r3, #4]
    3ce4:	4a0b      	ldr	r2, [pc, #44]	; (3d14 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    3ce6:	5cd3      	ldrb	r3, [r2, r3]
    3ce8:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    3cea:	4b0b      	ldr	r3, [pc, #44]	; (3d18 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    3cec:	685b      	ldr	r3, [r3, #4]
    3cee:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    3cf0:	9b02      	ldr	r3, [sp, #8]
    3cf2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    3cf6:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3cf8:	9b03      	ldr	r3, [sp, #12]
    3cfa:	031b      	lsls	r3, r3, #12
    3cfc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    3d00:	9a02      	ldr	r2, [sp, #8]
    3d02:	4313      	orrs	r3, r2
    3d04:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    3d06:	4a04      	ldr	r2, [pc, #16]	; (3d18 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    3d08:	9b02      	ldr	r3, [sp, #8]
    3d0a:	6053      	str	r3, [r2, #4]
}
    3d0c:	bf00      	nop
    3d0e:	b004      	add	sp, #16
    3d10:	4770      	bx	lr
    3d12:	bf00      	nop
    3d14:	0000c278 	.word	0x0000c278
    3d18:	40048000 	.word	0x40048000

00003d1c <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    3d1c:	b500      	push	{lr}
    3d1e:	b085      	sub	sp, #20
    3d20:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    3d22:	2300      	movs	r3, #0
    3d24:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    3d28:	9b01      	ldr	r3, [sp, #4]
    3d2a:	2b00      	cmp	r3, #0
    3d2c:	d037      	beq.n	3d9e <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3d2e:	2300      	movs	r3, #0
    3d30:	9303      	str	r3, [sp, #12]
    3d32:	e02b      	b.n	3d8c <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3d34:	4b29      	ldr	r3, [pc, #164]	; (3ddc <DisableSafeClock+0xc0>)
    3d36:	6819      	ldr	r1, [r3, #0]
    3d38:	9a03      	ldr	r2, [sp, #12]
    3d3a:	4613      	mov	r3, r2
    3d3c:	005b      	lsls	r3, r3, #1
    3d3e:	4413      	add	r3, r2
    3d40:	009b      	lsls	r3, r3, #2
    3d42:	440b      	add	r3, r1
    3d44:	3314      	adds	r3, #20
    3d46:	681b      	ldr	r3, [r3, #0]
    3d48:	2b05      	cmp	r3, #5
    3d4a:	d11c      	bne.n	3d86 <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    3d4c:	2301      	movs	r3, #1
    3d4e:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    3d52:	4b22      	ldr	r3, [pc, #136]	; (3ddc <DisableSafeClock+0xc0>)
    3d54:	6819      	ldr	r1, [r3, #0]
    3d56:	9a03      	ldr	r2, [sp, #12]
    3d58:	4613      	mov	r3, r2
    3d5a:	005b      	lsls	r3, r3, #1
    3d5c:	4413      	add	r3, r2
    3d5e:	009b      	lsls	r3, r3, #2
    3d60:	440b      	add	r3, r1
    3d62:	3318      	adds	r3, #24
    3d64:	881b      	ldrh	r3, [r3, #0]
    3d66:	2b00      	cmp	r3, #0
    3d68:	d118      	bne.n	3d9c <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3d6a:	4b1d      	ldr	r3, [pc, #116]	; (3de0 <DisableSafeClock+0xc4>)
    3d6c:	791b      	ldrb	r3, [r3, #4]
    3d6e:	4619      	mov	r1, r3
    3d70:	4a1c      	ldr	r2, [pc, #112]	; (3de4 <DisableSafeClock+0xc8>)
    3d72:	460b      	mov	r3, r1
    3d74:	005b      	lsls	r3, r3, #1
    3d76:	440b      	add	r3, r1
    3d78:	009b      	lsls	r3, r3, #2
    3d7a:	4413      	add	r3, r2
    3d7c:	3308      	adds	r3, #8
    3d7e:	681b      	ldr	r3, [r3, #0]
    3d80:	2005      	movs	r0, #5
    3d82:	4798      	blx	r3
                }
                break;
    3d84:	e00a      	b.n	3d9c <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3d86:	9b03      	ldr	r3, [sp, #12]
    3d88:	3301      	adds	r3, #1
    3d8a:	9303      	str	r3, [sp, #12]
    3d8c:	4b13      	ldr	r3, [pc, #76]	; (3ddc <DisableSafeClock+0xc0>)
    3d8e:	681b      	ldr	r3, [r3, #0]
    3d90:	7a1b      	ldrb	r3, [r3, #8]
    3d92:	461a      	mov	r2, r3
    3d94:	9b03      	ldr	r3, [sp, #12]
    3d96:	4293      	cmp	r3, r2
    3d98:	d3cc      	bcc.n	3d34 <DisableSafeClock+0x18>
    3d9a:	e000      	b.n	3d9e <DisableSafeClock+0x82>
                break;
    3d9c:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    3d9e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    3da2:	f083 0301 	eor.w	r3, r3, #1
    3da6:	b2db      	uxtb	r3, r3
    3da8:	2b00      	cmp	r3, #0
    3daa:	d013      	beq.n	3dd4 <DisableSafeClock+0xb8>
    3dac:	4b0e      	ldr	r3, [pc, #56]	; (3de8 <DisableSafeClock+0xcc>)
    3dae:	781b      	ldrb	r3, [r3, #0]
    3db0:	f083 0301 	eor.w	r3, r3, #1
    3db4:	b2db      	uxtb	r3, r3
    3db6:	2b00      	cmp	r3, #0
    3db8:	d00c      	beq.n	3dd4 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3dba:	4b09      	ldr	r3, [pc, #36]	; (3de0 <DisableSafeClock+0xc4>)
    3dbc:	791b      	ldrb	r3, [r3, #4]
    3dbe:	4619      	mov	r1, r3
    3dc0:	4a08      	ldr	r2, [pc, #32]	; (3de4 <DisableSafeClock+0xc8>)
    3dc2:	460b      	mov	r3, r1
    3dc4:	005b      	lsls	r3, r3, #1
    3dc6:	440b      	add	r3, r1
    3dc8:	009b      	lsls	r3, r3, #2
    3dca:	4413      	add	r3, r2
    3dcc:	3308      	adds	r3, #8
    3dce:	681b      	ldr	r3, [r3, #0]
    3dd0:	2005      	movs	r0, #5
    3dd2:	4798      	blx	r3
    }
}
    3dd4:	bf00      	nop
    3dd6:	b005      	add	sp, #20
    3dd8:	f85d fb04 	ldr.w	pc, [sp], #4
    3ddc:	1fff8ba8 	.word	0x1fff8ba8
    3de0:	0000bef8 	.word	0x0000bef8
    3de4:	0000c528 	.word	0x0000c528
    3de8:	1fff8b20 	.word	0x1fff8b20

00003dec <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    3dec:	4b06      	ldr	r3, [pc, #24]	; (3e08 <SetFircToResetValue_TrustedCall+0x1c>)
    3dee:	2200      	movs	r2, #0
    3df0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    3df4:	4b04      	ldr	r3, [pc, #16]	; (3e08 <SetFircToResetValue_TrustedCall+0x1c>)
    3df6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3dfa:	4a03      	ldr	r2, [pc, #12]	; (3e08 <SetFircToResetValue_TrustedCall+0x1c>)
    3dfc:	f043 0301 	orr.w	r3, r3, #1
    3e00:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    3e04:	bf00      	nop
    3e06:	4770      	bx	lr
    3e08:	40064000 	.word	0x40064000

00003e0c <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    3e0c:	b084      	sub	sp, #16
    3e0e:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    3e10:	2303      	movs	r3, #3
    3e12:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3e14:	2300      	movs	r3, #0
    3e16:	9302      	str	r3, [sp, #8]
    3e18:	e028      	b.n	3e6c <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    3e1a:	9b01      	ldr	r3, [sp, #4]
    3e1c:	9a02      	ldr	r2, [sp, #8]
    3e1e:	320d      	adds	r2, #13
    3e20:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3e24:	2b28      	cmp	r3, #40	; 0x28
    3e26:	d10b      	bne.n	3e40 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3e28:	9a01      	ldr	r2, [sp, #4]
    3e2a:	9b02      	ldr	r3, [sp, #8]
    3e2c:	330d      	adds	r3, #13
    3e2e:	00db      	lsls	r3, r3, #3
    3e30:	4413      	add	r3, r2
    3e32:	685b      	ldr	r3, [r3, #4]
    3e34:	4a2b      	ldr	r2, [pc, #172]	; (3ee4 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    3e36:	5cd3      	ldrb	r3, [r2, r3]
    3e38:	011b      	lsls	r3, r3, #4
    3e3a:	9a03      	ldr	r2, [sp, #12]
    3e3c:	4313      	orrs	r3, r2
    3e3e:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    3e40:	9b01      	ldr	r3, [sp, #4]
    3e42:	9a02      	ldr	r2, [sp, #8]
    3e44:	320d      	adds	r2, #13
    3e46:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3e4a:	2b29      	cmp	r3, #41	; 0x29
    3e4c:	d10b      	bne.n	3e66 <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3e4e:	9a01      	ldr	r2, [sp, #4]
    3e50:	9b02      	ldr	r3, [sp, #8]
    3e52:	330d      	adds	r3, #13
    3e54:	00db      	lsls	r3, r3, #3
    3e56:	4413      	add	r3, r2
    3e58:	685b      	ldr	r3, [r3, #4]
    3e5a:	4a23      	ldr	r2, [pc, #140]	; (3ee8 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    3e5c:	5cd3      	ldrb	r3, [r2, r3]
    3e5e:	009b      	lsls	r3, r3, #2
    3e60:	9a03      	ldr	r2, [sp, #12]
    3e62:	4313      	orrs	r3, r2
    3e64:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3e66:	9b02      	ldr	r3, [sp, #8]
    3e68:	3301      	adds	r3, #1
    3e6a:	9302      	str	r3, [sp, #8]
    3e6c:	9b01      	ldr	r3, [sp, #4]
    3e6e:	7adb      	ldrb	r3, [r3, #11]
    3e70:	461a      	mov	r2, r3
    3e72:	9b02      	ldr	r3, [sp, #8]
    3e74:	4293      	cmp	r3, r2
    3e76:	d3d0      	bcc.n	3e1a <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3e78:	2300      	movs	r3, #0
    3e7a:	9302      	str	r3, [sp, #8]
    3e7c:	e026      	b.n	3ecc <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    3e7e:	9a01      	ldr	r2, [sp, #4]
    3e80:	9b02      	ldr	r3, [sp, #8]
    3e82:	334e      	adds	r3, #78	; 0x4e
    3e84:	00db      	lsls	r3, r3, #3
    3e86:	4413      	add	r3, r2
    3e88:	685b      	ldr	r3, [r3, #4]
    3e8a:	2b12      	cmp	r3, #18
    3e8c:	d109      	bne.n	3ea2 <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3e8e:	9a01      	ldr	r2, [sp, #4]
    3e90:	9b02      	ldr	r3, [sp, #8]
    3e92:	334e      	adds	r3, #78	; 0x4e
    3e94:	00db      	lsls	r3, r3, #3
    3e96:	4413      	add	r3, r2
    3e98:	891b      	ldrh	r3, [r3, #8]
    3e9a:	005b      	lsls	r3, r3, #1
    3e9c:	9a03      	ldr	r2, [sp, #12]
    3e9e:	4313      	orrs	r3, r2
    3ea0:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    3ea2:	9a01      	ldr	r2, [sp, #4]
    3ea4:	9b02      	ldr	r3, [sp, #8]
    3ea6:	334e      	adds	r3, #78	; 0x4e
    3ea8:	00db      	lsls	r3, r3, #3
    3eaa:	4413      	add	r3, r2
    3eac:	685b      	ldr	r3, [r3, #4]
    3eae:	2b13      	cmp	r3, #19
    3eb0:	d109      	bne.n	3ec6 <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3eb2:	9a01      	ldr	r2, [sp, #4]
    3eb4:	9b02      	ldr	r3, [sp, #8]
    3eb6:	334e      	adds	r3, #78	; 0x4e
    3eb8:	00db      	lsls	r3, r3, #3
    3eba:	4413      	add	r3, r2
    3ebc:	891b      	ldrh	r3, [r3, #8]
    3ebe:	461a      	mov	r2, r3
    3ec0:	9b03      	ldr	r3, [sp, #12]
    3ec2:	4313      	orrs	r3, r2
    3ec4:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3ec6:	9b02      	ldr	r3, [sp, #8]
    3ec8:	3301      	adds	r3, #1
    3eca:	9302      	str	r3, [sp, #8]
    3ecc:	9b01      	ldr	r3, [sp, #4]
    3ece:	7c1b      	ldrb	r3, [r3, #16]
    3ed0:	461a      	mov	r2, r3
    3ed2:	9b02      	ldr	r3, [sp, #8]
    3ed4:	4293      	cmp	r3, r2
    3ed6:	d3d2      	bcc.n	3e7e <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    3ed8:	4a04      	ldr	r2, [pc, #16]	; (3eec <SetSimLpoclksRegister_TrustedCall+0xe0>)
    3eda:	9b03      	ldr	r3, [sp, #12]
    3edc:	6113      	str	r3, [r2, #16]
}
    3ede:	bf00      	nop
    3ee0:	b004      	add	sp, #16
    3ee2:	4770      	bx	lr
    3ee4:	0000c278 	.word	0x0000c278
    3ee8:	0000c330 	.word	0x0000c330
    3eec:	40048000 	.word	0x40048000

00003ef0 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    3ef0:	b500      	push	{lr}
    3ef2:	b089      	sub	sp, #36	; 0x24
    3ef4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3ef6:	2300      	movs	r3, #0
    3ef8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    3efc:	4a21      	ldr	r2, [pc, #132]	; (3f84 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    3efe:	9b01      	ldr	r3, [sp, #4]
    3f00:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    3f02:	4b21      	ldr	r3, [pc, #132]	; (3f88 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3f04:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f08:	f003 0301 	and.w	r3, r3, #1
    3f0c:	2b00      	cmp	r3, #0
    3f0e:	d12e      	bne.n	3f6e <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    3f10:	4b1e      	ldr	r3, [pc, #120]	; (3f8c <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3f12:	2200      	movs	r2, #0
    3f14:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    3f16:	f7ff ff69 	bl	3dec <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3f1a:	aa03      	add	r2, sp, #12
    3f1c:	a904      	add	r1, sp, #16
    3f1e:	a805      	add	r0, sp, #20
    3f20:	f24c 3350 	movw	r3, #50000	; 0xc350
    3f24:	f7fe f8ae 	bl	2084 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3f28:	4b17      	ldr	r3, [pc, #92]	; (3f88 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3f2a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f2e:	0e1b      	lsrs	r3, r3, #24
    3f30:	f003 0301 	and.w	r3, r3, #1
    3f34:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3f36:	9a03      	ldr	r2, [sp, #12]
    3f38:	a904      	add	r1, sp, #16
    3f3a:	ab05      	add	r3, sp, #20
    3f3c:	4618      	mov	r0, r3
    3f3e:	f7fe f8bb 	bl	20b8 <Clock_Ip_TimeoutExpired>
    3f42:	4603      	mov	r3, r0
    3f44:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    3f48:	9b06      	ldr	r3, [sp, #24]
    3f4a:	2b00      	cmp	r3, #0
    3f4c:	d106      	bne.n	3f5c <Clock_Ip_SpecificPlatformInitClock+0x6c>
    3f4e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f52:	f083 0301 	eor.w	r3, r3, #1
    3f56:	b2db      	uxtb	r3, r3
    3f58:	2b00      	cmp	r3, #0
    3f5a:	d1e5      	bne.n	3f28 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    3f5c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f60:	2b00      	cmp	r3, #0
    3f62:	d007      	beq.n	3f74 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3f64:	2105      	movs	r1, #5
    3f66:	2001      	movs	r0, #1
    3f68:	f7fe f87c 	bl	2064 <Clock_Ip_ReportClockErrors>
    3f6c:	e002      	b.n	3f74 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    3f6e:	4b07      	ldr	r3, [pc, #28]	; (3f8c <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3f70:	2201      	movs	r2, #1
    3f72:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    3f74:	9801      	ldr	r0, [sp, #4]
    3f76:	f7ff ff49 	bl	3e0c <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    3f7a:	bf00      	nop
    3f7c:	b009      	add	sp, #36	; 0x24
    3f7e:	f85d fb04 	ldr.w	pc, [sp], #4
    3f82:	bf00      	nop
    3f84:	1fff8ba8 	.word	0x1fff8ba8
    3f88:	40064000 	.word	0x40064000
    3f8c:	1fff8b20 	.word	0x1fff8b20

00003f90 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    3f90:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    3f92:	2300      	movs	r3, #0
    3f94:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3f96:	4b29      	ldr	r3, [pc, #164]	; (403c <getFircConfig+0xac>)
    3f98:	681b      	ldr	r3, [r3, #0]
    3f9a:	2b00      	cmp	r3, #0
    3f9c:	d024      	beq.n	3fe8 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3f9e:	2300      	movs	r3, #0
    3fa0:	9301      	str	r3, [sp, #4]
    3fa2:	e01a      	b.n	3fda <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3fa4:	4b25      	ldr	r3, [pc, #148]	; (403c <getFircConfig+0xac>)
    3fa6:	6819      	ldr	r1, [r3, #0]
    3fa8:	9a01      	ldr	r2, [sp, #4]
    3faa:	4613      	mov	r3, r2
    3fac:	005b      	lsls	r3, r3, #1
    3fae:	4413      	add	r3, r2
    3fb0:	009b      	lsls	r3, r3, #2
    3fb2:	440b      	add	r3, r1
    3fb4:	3314      	adds	r3, #20
    3fb6:	681b      	ldr	r3, [r3, #0]
    3fb8:	2b05      	cmp	r3, #5
    3fba:	d10b      	bne.n	3fd4 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    3fbc:	4b1f      	ldr	r3, [pc, #124]	; (403c <getFircConfig+0xac>)
    3fbe:	6819      	ldr	r1, [r3, #0]
    3fc0:	9a01      	ldr	r2, [sp, #4]
    3fc2:	4613      	mov	r3, r2
    3fc4:	005b      	lsls	r3, r3, #1
    3fc6:	4413      	add	r3, r2
    3fc8:	009b      	lsls	r3, r3, #2
    3fca:	3310      	adds	r3, #16
    3fcc:	440b      	add	r3, r1
    3fce:	3304      	adds	r3, #4
    3fd0:	9300      	str	r3, [sp, #0]
                break;
    3fd2:	e009      	b.n	3fe8 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3fd4:	9b01      	ldr	r3, [sp, #4]
    3fd6:	3301      	adds	r3, #1
    3fd8:	9301      	str	r3, [sp, #4]
    3fda:	4b18      	ldr	r3, [pc, #96]	; (403c <getFircConfig+0xac>)
    3fdc:	681b      	ldr	r3, [r3, #0]
    3fde:	7a1b      	ldrb	r3, [r3, #8]
    3fe0:	461a      	mov	r2, r3
    3fe2:	9b01      	ldr	r3, [sp, #4]
    3fe4:	4293      	cmp	r3, r2
    3fe6:	d3dd      	bcc.n	3fa4 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3fe8:	9b00      	ldr	r3, [sp, #0]
    3fea:	2b00      	cmp	r3, #0
    3fec:	d121      	bne.n	4032 <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    3fee:	4b14      	ldr	r3, [pc, #80]	; (4040 <getFircConfig+0xb0>)
    3ff0:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    3ff2:	4b13      	ldr	r3, [pc, #76]	; (4040 <getFircConfig+0xb0>)
    3ff4:	2205      	movs	r2, #5
    3ff6:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    3ff8:	4b12      	ldr	r3, [pc, #72]	; (4044 <getFircConfig+0xb4>)
    3ffa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ffe:	b29b      	uxth	r3, r3
    4000:	f003 0301 	and.w	r3, r3, #1
    4004:	b29a      	uxth	r2, r3
    4006:	4b0e      	ldr	r3, [pc, #56]	; (4040 <getFircConfig+0xb0>)
    4008:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    400a:	4b0e      	ldr	r3, [pc, #56]	; (4044 <getFircConfig+0xb4>)
    400c:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    4010:	b2db      	uxtb	r3, r3
    4012:	f003 0303 	and.w	r3, r3, #3
    4016:	b2da      	uxtb	r2, r3
    4018:	4b09      	ldr	r3, [pc, #36]	; (4040 <getFircConfig+0xb0>)
    401a:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    401c:	4b09      	ldr	r3, [pc, #36]	; (4044 <getFircConfig+0xb4>)
    401e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4022:	b2db      	uxtb	r3, r3
    4024:	10db      	asrs	r3, r3, #3
    4026:	b2db      	uxtb	r3, r3
    4028:	f003 0301 	and.w	r3, r3, #1
    402c:	b2da      	uxtb	r2, r3
    402e:	4b04      	ldr	r3, [pc, #16]	; (4040 <getFircConfig+0xb0>)
    4030:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    4032:	9b00      	ldr	r3, [sp, #0]
}
    4034:	4618      	mov	r0, r3
    4036:	b002      	add	sp, #8
    4038:	4770      	bx	lr
    403a:	bf00      	nop
    403c:	1fff8ba8 	.word	0x1fff8ba8
    4040:	1fff8c14 	.word	0x1fff8c14
    4044:	40064000 	.word	0x40064000

00004048 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    4048:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    404a:	2300      	movs	r3, #0
    404c:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    404e:	4b20      	ldr	r3, [pc, #128]	; (40d0 <getSoscConfig+0x88>)
    4050:	681b      	ldr	r3, [r3, #0]
    4052:	2b00      	cmp	r3, #0
    4054:	d024      	beq.n	40a0 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4056:	2300      	movs	r3, #0
    4058:	9301      	str	r3, [sp, #4]
    405a:	e01a      	b.n	4092 <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    405c:	4b1c      	ldr	r3, [pc, #112]	; (40d0 <getSoscConfig+0x88>)
    405e:	6819      	ldr	r1, [r3, #0]
    4060:	9a01      	ldr	r2, [sp, #4]
    4062:	4613      	mov	r3, r2
    4064:	009b      	lsls	r3, r3, #2
    4066:	4413      	add	r3, r2
    4068:	009b      	lsls	r3, r3, #2
    406a:	440b      	add	r3, r1
    406c:	332c      	adds	r3, #44	; 0x2c
    406e:	681b      	ldr	r3, [r3, #0]
    4070:	2b08      	cmp	r3, #8
    4072:	d10b      	bne.n	408c <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    4074:	4b16      	ldr	r3, [pc, #88]	; (40d0 <getSoscConfig+0x88>)
    4076:	6819      	ldr	r1, [r3, #0]
    4078:	9a01      	ldr	r2, [sp, #4]
    407a:	4613      	mov	r3, r2
    407c:	009b      	lsls	r3, r3, #2
    407e:	4413      	add	r3, r2
    4080:	009b      	lsls	r3, r3, #2
    4082:	3328      	adds	r3, #40	; 0x28
    4084:	440b      	add	r3, r1
    4086:	3304      	adds	r3, #4
    4088:	9300      	str	r3, [sp, #0]
                break;
    408a:	e009      	b.n	40a0 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    408c:	9b01      	ldr	r3, [sp, #4]
    408e:	3301      	adds	r3, #1
    4090:	9301      	str	r3, [sp, #4]
    4092:	4b0f      	ldr	r3, [pc, #60]	; (40d0 <getSoscConfig+0x88>)
    4094:	681b      	ldr	r3, [r3, #0]
    4096:	7a5b      	ldrb	r3, [r3, #9]
    4098:	461a      	mov	r2, r3
    409a:	9b01      	ldr	r3, [sp, #4]
    409c:	4293      	cmp	r3, r2
    409e:	d3dd      	bcc.n	405c <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    40a0:	9b00      	ldr	r3, [sp, #0]
    40a2:	2b00      	cmp	r3, #0
    40a4:	d110      	bne.n	40c8 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    40a6:	4b0b      	ldr	r3, [pc, #44]	; (40d4 <getSoscConfig+0x8c>)
    40a8:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    40aa:	4b0a      	ldr	r3, [pc, #40]	; (40d4 <getSoscConfig+0x8c>)
    40ac:	2208      	movs	r2, #8
    40ae:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    40b0:	4b09      	ldr	r3, [pc, #36]	; (40d8 <getSoscConfig+0x90>)
    40b2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    40b6:	b29b      	uxth	r3, r3
    40b8:	f003 0301 	and.w	r3, r3, #1
    40bc:	b29a      	uxth	r2, r3
    40be:	4b05      	ldr	r3, [pc, #20]	; (40d4 <getSoscConfig+0x8c>)
    40c0:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    40c2:	4b04      	ldr	r3, [pc, #16]	; (40d4 <getSoscConfig+0x8c>)
    40c4:	4a05      	ldr	r2, [pc, #20]	; (40dc <getSoscConfig+0x94>)
    40c6:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    40c8:	9b00      	ldr	r3, [sp, #0]
}
    40ca:	4618      	mov	r0, r3
    40cc:	b002      	add	sp, #8
    40ce:	4770      	bx	lr
    40d0:	1fff8ba8 	.word	0x1fff8ba8
    40d4:	1fff8c20 	.word	0x1fff8c20
    40d8:	40064000 	.word	0x40064000
    40dc:	02625a00 	.word	0x02625a00

000040e0 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    40e0:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    40e2:	2300      	movs	r3, #0
    40e4:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    40e6:	4b28      	ldr	r3, [pc, #160]	; (4188 <getSpllConfig+0xa8>)
    40e8:	681b      	ldr	r3, [r3, #0]
    40ea:	2b00      	cmp	r3, #0
    40ec:	d023      	beq.n	4136 <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    40ee:	2300      	movs	r3, #0
    40f0:	9301      	str	r3, [sp, #4]
    40f2:	e019      	b.n	4128 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    40f4:	4b24      	ldr	r3, [pc, #144]	; (4188 <getSpllConfig+0xa8>)
    40f6:	6819      	ldr	r1, [r3, #0]
    40f8:	9a01      	ldr	r2, [sp, #4]
    40fa:	4613      	mov	r3, r2
    40fc:	009b      	lsls	r3, r3, #2
    40fe:	4413      	add	r3, r2
    4100:	00db      	lsls	r3, r3, #3
    4102:	440b      	add	r3, r1
    4104:	3340      	adds	r3, #64	; 0x40
    4106:	681b      	ldr	r3, [r3, #0]
    4108:	2b09      	cmp	r3, #9
    410a:	d10a      	bne.n	4122 <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    410c:	4b1e      	ldr	r3, [pc, #120]	; (4188 <getSpllConfig+0xa8>)
    410e:	6819      	ldr	r1, [r3, #0]
    4110:	9a01      	ldr	r2, [sp, #4]
    4112:	4613      	mov	r3, r2
    4114:	009b      	lsls	r3, r3, #2
    4116:	4413      	add	r3, r2
    4118:	00db      	lsls	r3, r3, #3
    411a:	3340      	adds	r3, #64	; 0x40
    411c:	440b      	add	r3, r1
    411e:	9300      	str	r3, [sp, #0]
                break;
    4120:	e009      	b.n	4136 <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4122:	9b01      	ldr	r3, [sp, #4]
    4124:	3301      	adds	r3, #1
    4126:	9301      	str	r3, [sp, #4]
    4128:	4b17      	ldr	r3, [pc, #92]	; (4188 <getSpllConfig+0xa8>)
    412a:	681b      	ldr	r3, [r3, #0]
    412c:	7a9b      	ldrb	r3, [r3, #10]
    412e:	461a      	mov	r2, r3
    4130:	9b01      	ldr	r3, [sp, #4]
    4132:	4293      	cmp	r3, r2
    4134:	d3de      	bcc.n	40f4 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4136:	9b00      	ldr	r3, [sp, #0]
    4138:	2b00      	cmp	r3, #0
    413a:	d121      	bne.n	4180 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    413c:	4b13      	ldr	r3, [pc, #76]	; (418c <getSpllConfig+0xac>)
    413e:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    4140:	4b12      	ldr	r3, [pc, #72]	; (418c <getSpllConfig+0xac>)
    4142:	2209      	movs	r2, #9
    4144:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    4146:	4b12      	ldr	r3, [pc, #72]	; (4190 <getSpllConfig+0xb0>)
    4148:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    414c:	b29b      	uxth	r3, r3
    414e:	f003 0301 	and.w	r3, r3, #1
    4152:	b29a      	uxth	r2, r3
    4154:	4b0d      	ldr	r3, [pc, #52]	; (418c <getSpllConfig+0xac>)
    4156:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    4158:	4b0d      	ldr	r3, [pc, #52]	; (4190 <getSpllConfig+0xb0>)
    415a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    415e:	0a1b      	lsrs	r3, r3, #8
    4160:	b2db      	uxtb	r3, r3
    4162:	f003 0307 	and.w	r3, r3, #7
    4166:	b2da      	uxtb	r2, r3
    4168:	4b08      	ldr	r3, [pc, #32]	; (418c <getSpllConfig+0xac>)
    416a:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    416c:	4b08      	ldr	r3, [pc, #32]	; (4190 <getSpllConfig+0xb0>)
    416e:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4172:	0c1b      	lsrs	r3, r3, #16
    4174:	b2db      	uxtb	r3, r3
    4176:	f003 031f 	and.w	r3, r3, #31
    417a:	b2da      	uxtb	r2, r3
    417c:	4b03      	ldr	r3, [pc, #12]	; (418c <getSpllConfig+0xac>)
    417e:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    4180:	9b00      	ldr	r3, [sp, #0]
}
    4182:	4618      	mov	r0, r3
    4184:	b002      	add	sp, #8
    4186:	4770      	bx	lr
    4188:	1fff8ba8 	.word	0x1fff8ba8
    418c:	1fff8c34 	.word	0x1fff8c34
    4190:	40064000 	.word	0x40064000

00004194 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    4194:	b086      	sub	sp, #24
    4196:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    4198:	2300      	movs	r3, #0
    419a:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    419c:	9b01      	ldr	r3, [sp, #4]
    419e:	2b1b      	cmp	r3, #27
    41a0:	d00f      	beq.n	41c2 <getSelectorConfig+0x2e>
    41a2:	9b01      	ldr	r3, [sp, #4]
    41a4:	2b1b      	cmp	r3, #27
    41a6:	d80f      	bhi.n	41c8 <getSelectorConfig+0x34>
    41a8:	9b01      	ldr	r3, [sp, #4]
    41aa:	2b19      	cmp	r3, #25
    41ac:	d003      	beq.n	41b6 <getSelectorConfig+0x22>
    41ae:	9b01      	ldr	r3, [sp, #4]
    41b0:	2b1a      	cmp	r3, #26
    41b2:	d003      	beq.n	41bc <getSelectorConfig+0x28>
    41b4:	e008      	b.n	41c8 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    41b6:	2300      	movs	r3, #0
    41b8:	9304      	str	r3, [sp, #16]
            break;
    41ba:	e008      	b.n	41ce <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    41bc:	2301      	movs	r3, #1
    41be:	9304      	str	r3, [sp, #16]
            break;
    41c0:	e005      	b.n	41ce <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    41c2:	2302      	movs	r3, #2
    41c4:	9304      	str	r3, [sp, #16]
            break;
    41c6:	e002      	b.n	41ce <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    41c8:	2300      	movs	r3, #0
    41ca:	9304      	str	r3, [sp, #16]
            break;
    41cc:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    41ce:	4b36      	ldr	r3, [pc, #216]	; (42a8 <getSelectorConfig+0x114>)
    41d0:	681b      	ldr	r3, [r3, #0]
    41d2:	2b00      	cmp	r3, #0
    41d4:	d01d      	beq.n	4212 <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    41d6:	2300      	movs	r3, #0
    41d8:	9303      	str	r3, [sp, #12]
    41da:	e013      	b.n	4204 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    41dc:	4b32      	ldr	r3, [pc, #200]	; (42a8 <getSelectorConfig+0x114>)
    41de:	681b      	ldr	r3, [r3, #0]
    41e0:	9a03      	ldr	r2, [sp, #12]
    41e2:	320d      	adds	r2, #13
    41e4:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    41e8:	9a01      	ldr	r2, [sp, #4]
    41ea:	429a      	cmp	r2, r3
    41ec:	d107      	bne.n	41fe <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    41ee:	4b2e      	ldr	r3, [pc, #184]	; (42a8 <getSelectorConfig+0x114>)
    41f0:	681a      	ldr	r2, [r3, #0]
    41f2:	9b03      	ldr	r3, [sp, #12]
    41f4:	330d      	adds	r3, #13
    41f6:	00db      	lsls	r3, r3, #3
    41f8:	4413      	add	r3, r2
    41fa:	9305      	str	r3, [sp, #20]
                break;
    41fc:	e009      	b.n	4212 <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    41fe:	9b03      	ldr	r3, [sp, #12]
    4200:	3301      	adds	r3, #1
    4202:	9303      	str	r3, [sp, #12]
    4204:	4b28      	ldr	r3, [pc, #160]	; (42a8 <getSelectorConfig+0x114>)
    4206:	681b      	ldr	r3, [r3, #0]
    4208:	7adb      	ldrb	r3, [r3, #11]
    420a:	461a      	mov	r2, r3
    420c:	9b03      	ldr	r3, [sp, #12]
    420e:	4293      	cmp	r3, r2
    4210:	d3e4      	bcc.n	41dc <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4212:	9b05      	ldr	r3, [sp, #20]
    4214:	2b00      	cmp	r3, #0
    4216:	d140      	bne.n	429a <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    4218:	9b04      	ldr	r3, [sp, #16]
    421a:	00db      	lsls	r3, r3, #3
    421c:	4a23      	ldr	r2, [pc, #140]	; (42ac <getSelectorConfig+0x118>)
    421e:	4413      	add	r3, r2
    4220:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    4222:	4922      	ldr	r1, [pc, #136]	; (42ac <getSelectorConfig+0x118>)
    4224:	9b04      	ldr	r3, [sp, #16]
    4226:	9a01      	ldr	r2, [sp, #4]
    4228:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    422c:	9b01      	ldr	r3, [sp, #4]
    422e:	2b1b      	cmp	r3, #27
    4230:	d025      	beq.n	427e <getSelectorConfig+0xea>
    4232:	9b01      	ldr	r3, [sp, #4]
    4234:	2b1b      	cmp	r3, #27
    4236:	d832      	bhi.n	429e <getSelectorConfig+0x10a>
    4238:	9b01      	ldr	r3, [sp, #4]
    423a:	2b19      	cmp	r3, #25
    423c:	d003      	beq.n	4246 <getSelectorConfig+0xb2>
    423e:	9b01      	ldr	r3, [sp, #4]
    4240:	2b1a      	cmp	r3, #26
    4242:	d00e      	beq.n	4262 <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4244:	e02b      	b.n	429e <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    4246:	4b1a      	ldr	r3, [pc, #104]	; (42b0 <getSelectorConfig+0x11c>)
    4248:	695b      	ldr	r3, [r3, #20]
    424a:	0e1b      	lsrs	r3, r3, #24
    424c:	f003 030f 	and.w	r3, r3, #15
    4250:	4a18      	ldr	r2, [pc, #96]	; (42b4 <getSelectorConfig+0x120>)
    4252:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4256:	4915      	ldr	r1, [pc, #84]	; (42ac <getSelectorConfig+0x118>)
    4258:	9b04      	ldr	r3, [sp, #16]
    425a:	00db      	lsls	r3, r3, #3
    425c:	440b      	add	r3, r1
    425e:	605a      	str	r2, [r3, #4]
                break;
    4260:	e01e      	b.n	42a0 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    4262:	4b13      	ldr	r3, [pc, #76]	; (42b0 <getSelectorConfig+0x11c>)
    4264:	699b      	ldr	r3, [r3, #24]
    4266:	0e1b      	lsrs	r3, r3, #24
    4268:	f003 030f 	and.w	r3, r3, #15
    426c:	4a11      	ldr	r2, [pc, #68]	; (42b4 <getSelectorConfig+0x120>)
    426e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4272:	490e      	ldr	r1, [pc, #56]	; (42ac <getSelectorConfig+0x118>)
    4274:	9b04      	ldr	r3, [sp, #16]
    4276:	00db      	lsls	r3, r3, #3
    4278:	440b      	add	r3, r1
    427a:	605a      	str	r2, [r3, #4]
                break;
    427c:	e010      	b.n	42a0 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    427e:	4b0c      	ldr	r3, [pc, #48]	; (42b0 <getSelectorConfig+0x11c>)
    4280:	69db      	ldr	r3, [r3, #28]
    4282:	0e1b      	lsrs	r3, r3, #24
    4284:	f003 030f 	and.w	r3, r3, #15
    4288:	4a0a      	ldr	r2, [pc, #40]	; (42b4 <getSelectorConfig+0x120>)
    428a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    428e:	4907      	ldr	r1, [pc, #28]	; (42ac <getSelectorConfig+0x118>)
    4290:	9b04      	ldr	r3, [sp, #16]
    4292:	00db      	lsls	r3, r3, #3
    4294:	440b      	add	r3, r1
    4296:	605a      	str	r2, [r3, #4]
                break;
    4298:	e002      	b.n	42a0 <getSelectorConfig+0x10c>
        }
    }
    429a:	bf00      	nop
    429c:	e000      	b.n	42a0 <getSelectorConfig+0x10c>
                break;
    429e:	bf00      	nop

    return ReturnValue;
    42a0:	9b05      	ldr	r3, [sp, #20]
}
    42a2:	4618      	mov	r0, r3
    42a4:	b006      	add	sp, #24
    42a6:	4770      	bx	lr
    42a8:	1fff8ba8 	.word	0x1fff8ba8
    42ac:	1fff8c5c 	.word	0x1fff8c5c
    42b0:	40064000 	.word	0x40064000
    42b4:	0000c5f8 	.word	0x0000c5f8

000042b8 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    42b8:	b086      	sub	sp, #24
    42ba:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    42bc:	2300      	movs	r3, #0
    42be:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    42c0:	2300      	movs	r3, #0
    42c2:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    42c4:	9b01      	ldr	r3, [sp, #4]
    42c6:	2b1f      	cmp	r3, #31
    42c8:	d00f      	beq.n	42ea <getCoreDividerConfig+0x32>
    42ca:	9b01      	ldr	r3, [sp, #4]
    42cc:	2b1f      	cmp	r3, #31
    42ce:	d80f      	bhi.n	42f0 <getCoreDividerConfig+0x38>
    42d0:	9b01      	ldr	r3, [sp, #4]
    42d2:	2b1d      	cmp	r3, #29
    42d4:	d003      	beq.n	42de <getCoreDividerConfig+0x26>
    42d6:	9b01      	ldr	r3, [sp, #4]
    42d8:	2b1e      	cmp	r3, #30
    42da:	d003      	beq.n	42e4 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    42dc:	e008      	b.n	42f0 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    42de:	2300      	movs	r3, #0
    42e0:	9304      	str	r3, [sp, #16]
            break;
    42e2:	e006      	b.n	42f2 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    42e4:	2301      	movs	r3, #1
    42e6:	9304      	str	r3, [sp, #16]
            break;
    42e8:	e003      	b.n	42f2 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    42ea:	2302      	movs	r3, #2
    42ec:	9304      	str	r3, [sp, #16]
            break;
    42ee:	e000      	b.n	42f2 <getCoreDividerConfig+0x3a>
                break;
    42f0:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    42f2:	4b41      	ldr	r3, [pc, #260]	; (43f8 <getCoreDividerConfig+0x140>)
    42f4:	681b      	ldr	r3, [r3, #0]
    42f6:	2b00      	cmp	r3, #0
    42f8:	d026      	beq.n	4348 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    42fa:	2300      	movs	r3, #0
    42fc:	9303      	str	r3, [sp, #12]
    42fe:	e01c      	b.n	433a <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4300:	4b3d      	ldr	r3, [pc, #244]	; (43f8 <getCoreDividerConfig+0x140>)
    4302:	6819      	ldr	r1, [r3, #0]
    4304:	9a03      	ldr	r2, [sp, #12]
    4306:	4613      	mov	r3, r2
    4308:	005b      	lsls	r3, r3, #1
    430a:	4413      	add	r3, r2
    430c:	009b      	lsls	r3, r3, #2
    430e:	440b      	add	r3, r1
    4310:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4314:	681b      	ldr	r3, [r3, #0]
    4316:	9a01      	ldr	r2, [sp, #4]
    4318:	429a      	cmp	r2, r3
    431a:	d10b      	bne.n	4334 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    431c:	4b36      	ldr	r3, [pc, #216]	; (43f8 <getCoreDividerConfig+0x140>)
    431e:	6819      	ldr	r1, [r3, #0]
    4320:	9a03      	ldr	r2, [sp, #12]
    4322:	4613      	mov	r3, r2
    4324:	005b      	lsls	r3, r3, #1
    4326:	4413      	add	r3, r2
    4328:	009b      	lsls	r3, r3, #2
    432a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    432e:	440b      	add	r3, r1
    4330:	9305      	str	r3, [sp, #20]
                break;
    4332:	e009      	b.n	4348 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4334:	9b03      	ldr	r3, [sp, #12]
    4336:	3301      	adds	r3, #1
    4338:	9303      	str	r3, [sp, #12]
    433a:	4b2f      	ldr	r3, [pc, #188]	; (43f8 <getCoreDividerConfig+0x140>)
    433c:	681b      	ldr	r3, [r3, #0]
    433e:	7b1b      	ldrb	r3, [r3, #12]
    4340:	461a      	mov	r2, r3
    4342:	9b03      	ldr	r3, [sp, #12]
    4344:	4293      	cmp	r3, r2
    4346:	d3db      	bcc.n	4300 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4348:	9b05      	ldr	r3, [sp, #20]
    434a:	2b00      	cmp	r3, #0
    434c:	d14d      	bne.n	43ea <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    434e:	9a04      	ldr	r2, [sp, #16]
    4350:	4613      	mov	r3, r2
    4352:	005b      	lsls	r3, r3, #1
    4354:	4413      	add	r3, r2
    4356:	009b      	lsls	r3, r3, #2
    4358:	4a28      	ldr	r2, [pc, #160]	; (43fc <getCoreDividerConfig+0x144>)
    435a:	4413      	add	r3, r2
    435c:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    435e:	4927      	ldr	r1, [pc, #156]	; (43fc <getCoreDividerConfig+0x144>)
    4360:	9a04      	ldr	r2, [sp, #16]
    4362:	4613      	mov	r3, r2
    4364:	005b      	lsls	r3, r3, #1
    4366:	4413      	add	r3, r2
    4368:	009b      	lsls	r3, r3, #2
    436a:	440b      	add	r3, r1
    436c:	9a01      	ldr	r2, [sp, #4]
    436e:	601a      	str	r2, [r3, #0]
        switch(Name)
    4370:	9b01      	ldr	r3, [sp, #4]
    4372:	2b1f      	cmp	r3, #31
    4374:	d029      	beq.n	43ca <getCoreDividerConfig+0x112>
    4376:	9b01      	ldr	r3, [sp, #4]
    4378:	2b1f      	cmp	r3, #31
    437a:	d838      	bhi.n	43ee <getCoreDividerConfig+0x136>
    437c:	9b01      	ldr	r3, [sp, #4]
    437e:	2b1d      	cmp	r3, #29
    4380:	d003      	beq.n	438a <getCoreDividerConfig+0xd2>
    4382:	9b01      	ldr	r3, [sp, #4]
    4384:	2b1e      	cmp	r3, #30
    4386:	d010      	beq.n	43aa <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4388:	e031      	b.n	43ee <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    438a:	4b1d      	ldr	r3, [pc, #116]	; (4400 <getCoreDividerConfig+0x148>)
    438c:	695b      	ldr	r3, [r3, #20]
    438e:	0c1b      	lsrs	r3, r3, #16
    4390:	f003 030f 	and.w	r3, r3, #15
    4394:	1c59      	adds	r1, r3, #1
    4396:	4819      	ldr	r0, [pc, #100]	; (43fc <getCoreDividerConfig+0x144>)
    4398:	9a04      	ldr	r2, [sp, #16]
    439a:	4613      	mov	r3, r2
    439c:	005b      	lsls	r3, r3, #1
    439e:	4413      	add	r3, r2
    43a0:	009b      	lsls	r3, r3, #2
    43a2:	4403      	add	r3, r0
    43a4:	3304      	adds	r3, #4
    43a6:	6019      	str	r1, [r3, #0]
                break;
    43a8:	e022      	b.n	43f0 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    43aa:	4b15      	ldr	r3, [pc, #84]	; (4400 <getCoreDividerConfig+0x148>)
    43ac:	699b      	ldr	r3, [r3, #24]
    43ae:	0c1b      	lsrs	r3, r3, #16
    43b0:	f003 030f 	and.w	r3, r3, #15
    43b4:	1c59      	adds	r1, r3, #1
    43b6:	4811      	ldr	r0, [pc, #68]	; (43fc <getCoreDividerConfig+0x144>)
    43b8:	9a04      	ldr	r2, [sp, #16]
    43ba:	4613      	mov	r3, r2
    43bc:	005b      	lsls	r3, r3, #1
    43be:	4413      	add	r3, r2
    43c0:	009b      	lsls	r3, r3, #2
    43c2:	4403      	add	r3, r0
    43c4:	3304      	adds	r3, #4
    43c6:	6019      	str	r1, [r3, #0]
                break;
    43c8:	e012      	b.n	43f0 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    43ca:	4b0d      	ldr	r3, [pc, #52]	; (4400 <getCoreDividerConfig+0x148>)
    43cc:	69db      	ldr	r3, [r3, #28]
    43ce:	0c1b      	lsrs	r3, r3, #16
    43d0:	f003 030f 	and.w	r3, r3, #15
    43d4:	1c59      	adds	r1, r3, #1
    43d6:	4809      	ldr	r0, [pc, #36]	; (43fc <getCoreDividerConfig+0x144>)
    43d8:	9a04      	ldr	r2, [sp, #16]
    43da:	4613      	mov	r3, r2
    43dc:	005b      	lsls	r3, r3, #1
    43de:	4413      	add	r3, r2
    43e0:	009b      	lsls	r3, r3, #2
    43e2:	4403      	add	r3, r0
    43e4:	3304      	adds	r3, #4
    43e6:	6019      	str	r1, [r3, #0]
                break;
    43e8:	e002      	b.n	43f0 <getCoreDividerConfig+0x138>
        }
    }
    43ea:	bf00      	nop
    43ec:	e000      	b.n	43f0 <getCoreDividerConfig+0x138>
                break;
    43ee:	bf00      	nop

    return ReturnValue;
    43f0:	9b05      	ldr	r3, [sp, #20]
}
    43f2:	4618      	mov	r0, r3
    43f4:	b006      	add	sp, #24
    43f6:	4770      	bx	lr
    43f8:	1fff8ba8 	.word	0x1fff8ba8
    43fc:	1fff8c74 	.word	0x1fff8c74
    4400:	40064000 	.word	0x40064000

00004404 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    4404:	b086      	sub	sp, #24
    4406:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4408:	2300      	movs	r3, #0
    440a:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    440c:	2300      	movs	r3, #0
    440e:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4410:	9b01      	ldr	r3, [sp, #4]
    4412:	2b23      	cmp	r3, #35	; 0x23
    4414:	d00f      	beq.n	4436 <getBusDividerConfig+0x32>
    4416:	9b01      	ldr	r3, [sp, #4]
    4418:	2b23      	cmp	r3, #35	; 0x23
    441a:	d80f      	bhi.n	443c <getBusDividerConfig+0x38>
    441c:	9b01      	ldr	r3, [sp, #4]
    441e:	2b21      	cmp	r3, #33	; 0x21
    4420:	d003      	beq.n	442a <getBusDividerConfig+0x26>
    4422:	9b01      	ldr	r3, [sp, #4]
    4424:	2b22      	cmp	r3, #34	; 0x22
    4426:	d003      	beq.n	4430 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4428:	e008      	b.n	443c <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    442a:	2300      	movs	r3, #0
    442c:	9304      	str	r3, [sp, #16]
            break;
    442e:	e006      	b.n	443e <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4430:	2301      	movs	r3, #1
    4432:	9304      	str	r3, [sp, #16]
            break;
    4434:	e003      	b.n	443e <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    4436:	2302      	movs	r3, #2
    4438:	9304      	str	r3, [sp, #16]
            break;
    443a:	e000      	b.n	443e <getBusDividerConfig+0x3a>
                break;
    443c:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    443e:	4b41      	ldr	r3, [pc, #260]	; (4544 <getBusDividerConfig+0x140>)
    4440:	681b      	ldr	r3, [r3, #0]
    4442:	2b00      	cmp	r3, #0
    4444:	d026      	beq.n	4494 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4446:	2300      	movs	r3, #0
    4448:	9303      	str	r3, [sp, #12]
    444a:	e01c      	b.n	4486 <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    444c:	4b3d      	ldr	r3, [pc, #244]	; (4544 <getBusDividerConfig+0x140>)
    444e:	6819      	ldr	r1, [r3, #0]
    4450:	9a03      	ldr	r2, [sp, #12]
    4452:	4613      	mov	r3, r2
    4454:	005b      	lsls	r3, r3, #1
    4456:	4413      	add	r3, r2
    4458:	009b      	lsls	r3, r3, #2
    445a:	440b      	add	r3, r1
    445c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4460:	681b      	ldr	r3, [r3, #0]
    4462:	9a01      	ldr	r2, [sp, #4]
    4464:	429a      	cmp	r2, r3
    4466:	d10b      	bne.n	4480 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    4468:	4b36      	ldr	r3, [pc, #216]	; (4544 <getBusDividerConfig+0x140>)
    446a:	6819      	ldr	r1, [r3, #0]
    446c:	9a03      	ldr	r2, [sp, #12]
    446e:	4613      	mov	r3, r2
    4470:	005b      	lsls	r3, r3, #1
    4472:	4413      	add	r3, r2
    4474:	009b      	lsls	r3, r3, #2
    4476:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    447a:	440b      	add	r3, r1
    447c:	9305      	str	r3, [sp, #20]
                break;
    447e:	e009      	b.n	4494 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4480:	9b03      	ldr	r3, [sp, #12]
    4482:	3301      	adds	r3, #1
    4484:	9303      	str	r3, [sp, #12]
    4486:	4b2f      	ldr	r3, [pc, #188]	; (4544 <getBusDividerConfig+0x140>)
    4488:	681b      	ldr	r3, [r3, #0]
    448a:	7b1b      	ldrb	r3, [r3, #12]
    448c:	461a      	mov	r2, r3
    448e:	9b03      	ldr	r3, [sp, #12]
    4490:	4293      	cmp	r3, r2
    4492:	d3db      	bcc.n	444c <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4494:	9b05      	ldr	r3, [sp, #20]
    4496:	2b00      	cmp	r3, #0
    4498:	d14d      	bne.n	4536 <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    449a:	9a04      	ldr	r2, [sp, #16]
    449c:	4613      	mov	r3, r2
    449e:	005b      	lsls	r3, r3, #1
    44a0:	4413      	add	r3, r2
    44a2:	009b      	lsls	r3, r3, #2
    44a4:	4a28      	ldr	r2, [pc, #160]	; (4548 <getBusDividerConfig+0x144>)
    44a6:	4413      	add	r3, r2
    44a8:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    44aa:	4927      	ldr	r1, [pc, #156]	; (4548 <getBusDividerConfig+0x144>)
    44ac:	9a04      	ldr	r2, [sp, #16]
    44ae:	4613      	mov	r3, r2
    44b0:	005b      	lsls	r3, r3, #1
    44b2:	4413      	add	r3, r2
    44b4:	009b      	lsls	r3, r3, #2
    44b6:	440b      	add	r3, r1
    44b8:	9a01      	ldr	r2, [sp, #4]
    44ba:	601a      	str	r2, [r3, #0]
        switch(Name)
    44bc:	9b01      	ldr	r3, [sp, #4]
    44be:	2b23      	cmp	r3, #35	; 0x23
    44c0:	d029      	beq.n	4516 <getBusDividerConfig+0x112>
    44c2:	9b01      	ldr	r3, [sp, #4]
    44c4:	2b23      	cmp	r3, #35	; 0x23
    44c6:	d838      	bhi.n	453a <getBusDividerConfig+0x136>
    44c8:	9b01      	ldr	r3, [sp, #4]
    44ca:	2b21      	cmp	r3, #33	; 0x21
    44cc:	d003      	beq.n	44d6 <getBusDividerConfig+0xd2>
    44ce:	9b01      	ldr	r3, [sp, #4]
    44d0:	2b22      	cmp	r3, #34	; 0x22
    44d2:	d010      	beq.n	44f6 <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    44d4:	e031      	b.n	453a <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    44d6:	4b1d      	ldr	r3, [pc, #116]	; (454c <getBusDividerConfig+0x148>)
    44d8:	695b      	ldr	r3, [r3, #20]
    44da:	091b      	lsrs	r3, r3, #4
    44dc:	f003 030f 	and.w	r3, r3, #15
    44e0:	1c59      	adds	r1, r3, #1
    44e2:	4819      	ldr	r0, [pc, #100]	; (4548 <getBusDividerConfig+0x144>)
    44e4:	9a04      	ldr	r2, [sp, #16]
    44e6:	4613      	mov	r3, r2
    44e8:	005b      	lsls	r3, r3, #1
    44ea:	4413      	add	r3, r2
    44ec:	009b      	lsls	r3, r3, #2
    44ee:	4403      	add	r3, r0
    44f0:	3304      	adds	r3, #4
    44f2:	6019      	str	r1, [r3, #0]
                break;
    44f4:	e022      	b.n	453c <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    44f6:	4b15      	ldr	r3, [pc, #84]	; (454c <getBusDividerConfig+0x148>)
    44f8:	699b      	ldr	r3, [r3, #24]
    44fa:	091b      	lsrs	r3, r3, #4
    44fc:	f003 030f 	and.w	r3, r3, #15
    4500:	1c59      	adds	r1, r3, #1
    4502:	4811      	ldr	r0, [pc, #68]	; (4548 <getBusDividerConfig+0x144>)
    4504:	9a04      	ldr	r2, [sp, #16]
    4506:	4613      	mov	r3, r2
    4508:	005b      	lsls	r3, r3, #1
    450a:	4413      	add	r3, r2
    450c:	009b      	lsls	r3, r3, #2
    450e:	4403      	add	r3, r0
    4510:	3304      	adds	r3, #4
    4512:	6019      	str	r1, [r3, #0]
                break;
    4514:	e012      	b.n	453c <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    4516:	4b0d      	ldr	r3, [pc, #52]	; (454c <getBusDividerConfig+0x148>)
    4518:	69db      	ldr	r3, [r3, #28]
    451a:	091b      	lsrs	r3, r3, #4
    451c:	f003 030f 	and.w	r3, r3, #15
    4520:	1c59      	adds	r1, r3, #1
    4522:	4809      	ldr	r0, [pc, #36]	; (4548 <getBusDividerConfig+0x144>)
    4524:	9a04      	ldr	r2, [sp, #16]
    4526:	4613      	mov	r3, r2
    4528:	005b      	lsls	r3, r3, #1
    452a:	4413      	add	r3, r2
    452c:	009b      	lsls	r3, r3, #2
    452e:	4403      	add	r3, r0
    4530:	3304      	adds	r3, #4
    4532:	6019      	str	r1, [r3, #0]
                break;
    4534:	e002      	b.n	453c <getBusDividerConfig+0x138>
        }
    }
    4536:	bf00      	nop
    4538:	e000      	b.n	453c <getBusDividerConfig+0x138>
                break;
    453a:	bf00      	nop

    return ReturnValue;
    453c:	9b05      	ldr	r3, [sp, #20]
}
    453e:	4618      	mov	r0, r3
    4540:	b006      	add	sp, #24
    4542:	4770      	bx	lr
    4544:	1fff8ba8 	.word	0x1fff8ba8
    4548:	1fff8c98 	.word	0x1fff8c98
    454c:	40064000 	.word	0x40064000

00004550 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    4550:	b086      	sub	sp, #24
    4552:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4554:	2300      	movs	r3, #0
    4556:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4558:	2300      	movs	r3, #0
    455a:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    455c:	9b01      	ldr	r3, [sp, #4]
    455e:	2b27      	cmp	r3, #39	; 0x27
    4560:	d00f      	beq.n	4582 <getSlowDividerConfig+0x32>
    4562:	9b01      	ldr	r3, [sp, #4]
    4564:	2b27      	cmp	r3, #39	; 0x27
    4566:	d80f      	bhi.n	4588 <getSlowDividerConfig+0x38>
    4568:	9b01      	ldr	r3, [sp, #4]
    456a:	2b25      	cmp	r3, #37	; 0x25
    456c:	d003      	beq.n	4576 <getSlowDividerConfig+0x26>
    456e:	9b01      	ldr	r3, [sp, #4]
    4570:	2b26      	cmp	r3, #38	; 0x26
    4572:	d003      	beq.n	457c <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4574:	e008      	b.n	4588 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    4576:	2300      	movs	r3, #0
    4578:	9304      	str	r3, [sp, #16]
            break;
    457a:	e006      	b.n	458a <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    457c:	2301      	movs	r3, #1
    457e:	9304      	str	r3, [sp, #16]
            break;
    4580:	e003      	b.n	458a <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    4582:	2302      	movs	r3, #2
    4584:	9304      	str	r3, [sp, #16]
            break;
    4586:	e000      	b.n	458a <getSlowDividerConfig+0x3a>
                break;
    4588:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    458a:	4b40      	ldr	r3, [pc, #256]	; (468c <getSlowDividerConfig+0x13c>)
    458c:	681b      	ldr	r3, [r3, #0]
    458e:	2b00      	cmp	r3, #0
    4590:	d026      	beq.n	45e0 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4592:	2300      	movs	r3, #0
    4594:	9303      	str	r3, [sp, #12]
    4596:	e01c      	b.n	45d2 <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4598:	4b3c      	ldr	r3, [pc, #240]	; (468c <getSlowDividerConfig+0x13c>)
    459a:	6819      	ldr	r1, [r3, #0]
    459c:	9a03      	ldr	r2, [sp, #12]
    459e:	4613      	mov	r3, r2
    45a0:	005b      	lsls	r3, r3, #1
    45a2:	4413      	add	r3, r2
    45a4:	009b      	lsls	r3, r3, #2
    45a6:	440b      	add	r3, r1
    45a8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    45ac:	681b      	ldr	r3, [r3, #0]
    45ae:	9a01      	ldr	r2, [sp, #4]
    45b0:	429a      	cmp	r2, r3
    45b2:	d10b      	bne.n	45cc <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    45b4:	4b35      	ldr	r3, [pc, #212]	; (468c <getSlowDividerConfig+0x13c>)
    45b6:	6819      	ldr	r1, [r3, #0]
    45b8:	9a03      	ldr	r2, [sp, #12]
    45ba:	4613      	mov	r3, r2
    45bc:	005b      	lsls	r3, r3, #1
    45be:	4413      	add	r3, r2
    45c0:	009b      	lsls	r3, r3, #2
    45c2:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    45c6:	440b      	add	r3, r1
    45c8:	9305      	str	r3, [sp, #20]
                break;
    45ca:	e009      	b.n	45e0 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    45cc:	9b03      	ldr	r3, [sp, #12]
    45ce:	3301      	adds	r3, #1
    45d0:	9303      	str	r3, [sp, #12]
    45d2:	4b2e      	ldr	r3, [pc, #184]	; (468c <getSlowDividerConfig+0x13c>)
    45d4:	681b      	ldr	r3, [r3, #0]
    45d6:	7b1b      	ldrb	r3, [r3, #12]
    45d8:	461a      	mov	r2, r3
    45da:	9b03      	ldr	r3, [sp, #12]
    45dc:	4293      	cmp	r3, r2
    45de:	d3db      	bcc.n	4598 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    45e0:	9b05      	ldr	r3, [sp, #20]
    45e2:	2b00      	cmp	r3, #0
    45e4:	d14a      	bne.n	467c <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    45e6:	9a04      	ldr	r2, [sp, #16]
    45e8:	4613      	mov	r3, r2
    45ea:	005b      	lsls	r3, r3, #1
    45ec:	4413      	add	r3, r2
    45ee:	009b      	lsls	r3, r3, #2
    45f0:	4a27      	ldr	r2, [pc, #156]	; (4690 <getSlowDividerConfig+0x140>)
    45f2:	4413      	add	r3, r2
    45f4:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    45f6:	4926      	ldr	r1, [pc, #152]	; (4690 <getSlowDividerConfig+0x140>)
    45f8:	9a04      	ldr	r2, [sp, #16]
    45fa:	4613      	mov	r3, r2
    45fc:	005b      	lsls	r3, r3, #1
    45fe:	4413      	add	r3, r2
    4600:	009b      	lsls	r3, r3, #2
    4602:	440b      	add	r3, r1
    4604:	9a01      	ldr	r2, [sp, #4]
    4606:	601a      	str	r2, [r3, #0]
        switch(Name)
    4608:	9b01      	ldr	r3, [sp, #4]
    460a:	2b27      	cmp	r3, #39	; 0x27
    460c:	d027      	beq.n	465e <getSlowDividerConfig+0x10e>
    460e:	9b01      	ldr	r3, [sp, #4]
    4610:	2b27      	cmp	r3, #39	; 0x27
    4612:	d835      	bhi.n	4680 <getSlowDividerConfig+0x130>
    4614:	9b01      	ldr	r3, [sp, #4]
    4616:	2b25      	cmp	r3, #37	; 0x25
    4618:	d003      	beq.n	4622 <getSlowDividerConfig+0xd2>
    461a:	9b01      	ldr	r3, [sp, #4]
    461c:	2b26      	cmp	r3, #38	; 0x26
    461e:	d00f      	beq.n	4640 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4620:	e02e      	b.n	4680 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    4622:	4b1c      	ldr	r3, [pc, #112]	; (4694 <getSlowDividerConfig+0x144>)
    4624:	695b      	ldr	r3, [r3, #20]
    4626:	f003 030f 	and.w	r3, r3, #15
    462a:	1c59      	adds	r1, r3, #1
    462c:	4818      	ldr	r0, [pc, #96]	; (4690 <getSlowDividerConfig+0x140>)
    462e:	9a04      	ldr	r2, [sp, #16]
    4630:	4613      	mov	r3, r2
    4632:	005b      	lsls	r3, r3, #1
    4634:	4413      	add	r3, r2
    4636:	009b      	lsls	r3, r3, #2
    4638:	4403      	add	r3, r0
    463a:	3304      	adds	r3, #4
    463c:	6019      	str	r1, [r3, #0]
                break;
    463e:	e020      	b.n	4682 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    4640:	4b14      	ldr	r3, [pc, #80]	; (4694 <getSlowDividerConfig+0x144>)
    4642:	699b      	ldr	r3, [r3, #24]
    4644:	f003 030f 	and.w	r3, r3, #15
    4648:	1c59      	adds	r1, r3, #1
    464a:	4811      	ldr	r0, [pc, #68]	; (4690 <getSlowDividerConfig+0x140>)
    464c:	9a04      	ldr	r2, [sp, #16]
    464e:	4613      	mov	r3, r2
    4650:	005b      	lsls	r3, r3, #1
    4652:	4413      	add	r3, r2
    4654:	009b      	lsls	r3, r3, #2
    4656:	4403      	add	r3, r0
    4658:	3304      	adds	r3, #4
    465a:	6019      	str	r1, [r3, #0]
                break;
    465c:	e011      	b.n	4682 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    465e:	4b0d      	ldr	r3, [pc, #52]	; (4694 <getSlowDividerConfig+0x144>)
    4660:	69db      	ldr	r3, [r3, #28]
    4662:	f003 030f 	and.w	r3, r3, #15
    4666:	1c59      	adds	r1, r3, #1
    4668:	4809      	ldr	r0, [pc, #36]	; (4690 <getSlowDividerConfig+0x140>)
    466a:	9a04      	ldr	r2, [sp, #16]
    466c:	4613      	mov	r3, r2
    466e:	005b      	lsls	r3, r3, #1
    4670:	4413      	add	r3, r2
    4672:	009b      	lsls	r3, r3, #2
    4674:	4403      	add	r3, r0
    4676:	3304      	adds	r3, #4
    4678:	6019      	str	r1, [r3, #0]
                break;
    467a:	e002      	b.n	4682 <getSlowDividerConfig+0x132>
        }
    }
    467c:	bf00      	nop
    467e:	e000      	b.n	4682 <getSlowDividerConfig+0x132>
                break;
    4680:	bf00      	nop

    return ReturnValue;
    4682:	9b05      	ldr	r3, [sp, #20]
}
    4684:	4618      	mov	r0, r3
    4686:	b006      	add	sp, #24
    4688:	4770      	bx	lr
    468a:	bf00      	nop
    468c:	1fff8ba8 	.word	0x1fff8ba8
    4690:	1fff8cbc 	.word	0x1fff8cbc
    4694:	40064000 	.word	0x40064000

00004698 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    4698:	b500      	push	{lr}
    469a:	b083      	sub	sp, #12
    469c:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    469e:	4b64      	ldr	r3, [pc, #400]	; (4830 <Clock_Ip_ClockInitializeObjects+0x198>)
    46a0:	781b      	ldrb	r3, [r3, #0]
    46a2:	f083 0301 	eor.w	r3, r3, #1
    46a6:	b2db      	uxtb	r3, r3
    46a8:	2b00      	cmp	r3, #0
    46aa:	d05b      	beq.n	4764 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    46ac:	4b60      	ldr	r3, [pc, #384]	; (4830 <Clock_Ip_ClockInitializeObjects+0x198>)
    46ae:	2201      	movs	r2, #1
    46b0:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    46b2:	4b60      	ldr	r3, [pc, #384]	; (4834 <Clock_Ip_ClockInitializeObjects+0x19c>)
    46b4:	785b      	ldrb	r3, [r3, #1]
    46b6:	461a      	mov	r2, r3
    46b8:	4613      	mov	r3, r2
    46ba:	009b      	lsls	r3, r3, #2
    46bc:	4413      	add	r3, r2
    46be:	009b      	lsls	r3, r3, #2
    46c0:	4a5d      	ldr	r2, [pc, #372]	; (4838 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    46c2:	4413      	add	r3, r2
    46c4:	4a5d      	ldr	r2, [pc, #372]	; (483c <Clock_Ip_ClockInitializeObjects+0x1a4>)
    46c6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    46c8:	4b5d      	ldr	r3, [pc, #372]	; (4840 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    46ca:	785b      	ldrb	r3, [r3, #1]
    46cc:	461a      	mov	r2, r3
    46ce:	4613      	mov	r3, r2
    46d0:	009b      	lsls	r3, r3, #2
    46d2:	4413      	add	r3, r2
    46d4:	009b      	lsls	r3, r3, #2
    46d6:	4a5b      	ldr	r2, [pc, #364]	; (4844 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    46d8:	4413      	add	r3, r2
    46da:	4a5b      	ldr	r2, [pc, #364]	; (4848 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    46dc:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    46de:	4b5b      	ldr	r3, [pc, #364]	; (484c <Clock_Ip_ClockInitializeObjects+0x1b4>)
    46e0:	791b      	ldrb	r3, [r3, #4]
    46e2:	461a      	mov	r2, r3
    46e4:	4613      	mov	r3, r2
    46e6:	005b      	lsls	r3, r3, #1
    46e8:	4413      	add	r3, r2
    46ea:	009b      	lsls	r3, r3, #2
    46ec:	4a58      	ldr	r2, [pc, #352]	; (4850 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    46ee:	4413      	add	r3, r2
    46f0:	4a58      	ldr	r2, [pc, #352]	; (4854 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    46f2:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    46f4:	4b58      	ldr	r3, [pc, #352]	; (4858 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    46f6:	795b      	ldrb	r3, [r3, #5]
    46f8:	00db      	lsls	r3, r3, #3
    46fa:	4a58      	ldr	r2, [pc, #352]	; (485c <Clock_Ip_ClockInitializeObjects+0x1c4>)
    46fc:	4413      	add	r3, r2
    46fe:	4a58      	ldr	r2, [pc, #352]	; (4860 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    4700:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    4702:	4b55      	ldr	r3, [pc, #340]	; (4858 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    4704:	79db      	ldrb	r3, [r3, #7]
    4706:	00db      	lsls	r3, r3, #3
    4708:	4a54      	ldr	r2, [pc, #336]	; (485c <Clock_Ip_ClockInitializeObjects+0x1c4>)
    470a:	4413      	add	r3, r2
    470c:	4a55      	ldr	r2, [pc, #340]	; (4864 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    470e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    4710:	4b55      	ldr	r3, [pc, #340]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4712:	799b      	ldrb	r3, [r3, #6]
    4714:	009b      	lsls	r3, r3, #2
    4716:	4a55      	ldr	r2, [pc, #340]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4718:	4413      	add	r3, r2
    471a:	4a55      	ldr	r2, [pc, #340]	; (4870 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    471c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    471e:	4b52      	ldr	r3, [pc, #328]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4720:	7a1b      	ldrb	r3, [r3, #8]
    4722:	009b      	lsls	r3, r3, #2
    4724:	4a51      	ldr	r2, [pc, #324]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4726:	4413      	add	r3, r2
    4728:	4a52      	ldr	r2, [pc, #328]	; (4874 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    472a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    472c:	4b4e      	ldr	r3, [pc, #312]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    472e:	7a5b      	ldrb	r3, [r3, #9]
    4730:	009b      	lsls	r3, r3, #2
    4732:	4a4e      	ldr	r2, [pc, #312]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4734:	4413      	add	r3, r2
    4736:	4a50      	ldr	r2, [pc, #320]	; (4878 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    4738:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    473a:	4b4b      	ldr	r3, [pc, #300]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    473c:	7adb      	ldrb	r3, [r3, #11]
    473e:	009b      	lsls	r3, r3, #2
    4740:	4a4a      	ldr	r2, [pc, #296]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4742:	4413      	add	r3, r2
    4744:	4a4d      	ldr	r2, [pc, #308]	; (487c <Clock_Ip_ClockInitializeObjects+0x1e4>)
    4746:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    4748:	4b47      	ldr	r3, [pc, #284]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    474a:	7b1b      	ldrb	r3, [r3, #12]
    474c:	009b      	lsls	r3, r3, #2
    474e:	4a47      	ldr	r2, [pc, #284]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4750:	4413      	add	r3, r2
    4752:	4a4b      	ldr	r2, [pc, #300]	; (4880 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    4754:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    4756:	4b44      	ldr	r3, [pc, #272]	; (4868 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4758:	7b9b      	ldrb	r3, [r3, #14]
    475a:	009b      	lsls	r3, r3, #2
    475c:	4a43      	ldr	r2, [pc, #268]	; (486c <Clock_Ip_ClockInitializeObjects+0x1d4>)
    475e:	4413      	add	r3, r2
    4760:	4a48      	ldr	r2, [pc, #288]	; (4884 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    4762:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    4764:	4b48      	ldr	r3, [pc, #288]	; (4888 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    4766:	781b      	ldrb	r3, [r3, #0]
    4768:	2b00      	cmp	r3, #0
    476a:	d002      	beq.n	4772 <Clock_Ip_ClockInitializeObjects+0xda>
    476c:	9b01      	ldr	r3, [sp, #4]
    476e:	2b00      	cmp	r3, #0
    4770:	d003      	beq.n	477a <Clock_Ip_ClockInitializeObjects+0xe2>
    4772:	4b46      	ldr	r3, [pc, #280]	; (488c <Clock_Ip_ClockInitializeObjects+0x1f4>)
    4774:	781b      	ldrb	r3, [r3, #0]
    4776:	2b00      	cmp	r3, #0
    4778:	d056      	beq.n	4828 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    477a:	f7ff fc09 	bl	3f90 <getFircConfig>
    477e:	4603      	mov	r3, r0
    4780:	4a43      	ldr	r2, [pc, #268]	; (4890 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    4782:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    4784:	f7ff fc60 	bl	4048 <getSoscConfig>
    4788:	4603      	mov	r3, r0
    478a:	4a42      	ldr	r2, [pc, #264]	; (4894 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    478c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    478e:	f7ff fca7 	bl	40e0 <getSpllConfig>
    4792:	4603      	mov	r3, r0
    4794:	4a40      	ldr	r2, [pc, #256]	; (4898 <Clock_Ip_ClockInitializeObjects+0x200>)
    4796:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    4798:	2019      	movs	r0, #25
    479a:	f7ff fcfb 	bl	4194 <getSelectorConfig>
    479e:	4603      	mov	r3, r0
    47a0:	4a3e      	ldr	r2, [pc, #248]	; (489c <Clock_Ip_ClockInitializeObjects+0x204>)
    47a2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    47a4:	201a      	movs	r0, #26
    47a6:	f7ff fcf5 	bl	4194 <getSelectorConfig>
    47aa:	4603      	mov	r3, r0
    47ac:	4a3c      	ldr	r2, [pc, #240]	; (48a0 <Clock_Ip_ClockInitializeObjects+0x208>)
    47ae:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    47b0:	201b      	movs	r0, #27
    47b2:	f7ff fcef 	bl	4194 <getSelectorConfig>
    47b6:	4603      	mov	r3, r0
    47b8:	4a3a      	ldr	r2, [pc, #232]	; (48a4 <Clock_Ip_ClockInitializeObjects+0x20c>)
    47ba:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    47bc:	201d      	movs	r0, #29
    47be:	f7ff fd7b 	bl	42b8 <getCoreDividerConfig>
    47c2:	4603      	mov	r3, r0
    47c4:	4a38      	ldr	r2, [pc, #224]	; (48a8 <Clock_Ip_ClockInitializeObjects+0x210>)
    47c6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    47c8:	201e      	movs	r0, #30
    47ca:	f7ff fd75 	bl	42b8 <getCoreDividerConfig>
    47ce:	4603      	mov	r3, r0
    47d0:	4a36      	ldr	r2, [pc, #216]	; (48ac <Clock_Ip_ClockInitializeObjects+0x214>)
    47d2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    47d4:	201f      	movs	r0, #31
    47d6:	f7ff fd6f 	bl	42b8 <getCoreDividerConfig>
    47da:	4603      	mov	r3, r0
    47dc:	4a34      	ldr	r2, [pc, #208]	; (48b0 <Clock_Ip_ClockInitializeObjects+0x218>)
    47de:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    47e0:	2021      	movs	r0, #33	; 0x21
    47e2:	f7ff fe0f 	bl	4404 <getBusDividerConfig>
    47e6:	4603      	mov	r3, r0
    47e8:	4a32      	ldr	r2, [pc, #200]	; (48b4 <Clock_Ip_ClockInitializeObjects+0x21c>)
    47ea:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    47ec:	2022      	movs	r0, #34	; 0x22
    47ee:	f7ff fe09 	bl	4404 <getBusDividerConfig>
    47f2:	4603      	mov	r3, r0
    47f4:	4a30      	ldr	r2, [pc, #192]	; (48b8 <Clock_Ip_ClockInitializeObjects+0x220>)
    47f6:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    47f8:	2023      	movs	r0, #35	; 0x23
    47fa:	f7ff fe03 	bl	4404 <getBusDividerConfig>
    47fe:	4603      	mov	r3, r0
    4800:	4a2e      	ldr	r2, [pc, #184]	; (48bc <Clock_Ip_ClockInitializeObjects+0x224>)
    4802:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    4804:	2025      	movs	r0, #37	; 0x25
    4806:	f7ff fea3 	bl	4550 <getSlowDividerConfig>
    480a:	4603      	mov	r3, r0
    480c:	4a2c      	ldr	r2, [pc, #176]	; (48c0 <Clock_Ip_ClockInitializeObjects+0x228>)
    480e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    4810:	2026      	movs	r0, #38	; 0x26
    4812:	f7ff fe9d 	bl	4550 <getSlowDividerConfig>
    4816:	4603      	mov	r3, r0
    4818:	4a2a      	ldr	r2, [pc, #168]	; (48c4 <Clock_Ip_ClockInitializeObjects+0x22c>)
    481a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    481c:	2027      	movs	r0, #39	; 0x27
    481e:	f7ff fe97 	bl	4550 <getSlowDividerConfig>
    4822:	4603      	mov	r3, r0
    4824:	4a28      	ldr	r2, [pc, #160]	; (48c8 <Clock_Ip_ClockInitializeObjects+0x230>)
    4826:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    4828:	bf00      	nop
    482a:	b003      	add	sp, #12
    482c:	f85d fb04 	ldr.w	pc, [sp], #4
    4830:	1fff8ce0 	.word	0x1fff8ce0
    4834:	0000bf28 	.word	0x0000bf28
    4838:	0000c574 	.word	0x0000c574
    483c:	1fff8bac 	.word	0x1fff8bac
    4840:	0000bee8 	.word	0x0000bee8
    4844:	0000c4bc 	.word	0x0000c4bc
    4848:	1fff8bb0 	.word	0x1fff8bb0
    484c:	0000bef8 	.word	0x0000bef8
    4850:	0000c528 	.word	0x0000c528
    4854:	1fff8bb4 	.word	0x1fff8bb4
    4858:	0000bf38 	.word	0x0000bf38
    485c:	0000c5a0 	.word	0x0000c5a0
    4860:	1fff8bb8 	.word	0x1fff8bb8
    4864:	1fff8bf4 	.word	0x1fff8bf4
    4868:	0000bec8 	.word	0x0000bec8
    486c:	0000c478 	.word	0x0000c478
    4870:	1fff8bbc 	.word	0x1fff8bbc
    4874:	1fff8bf8 	.word	0x1fff8bf8
    4878:	1fff8bc0 	.word	0x1fff8bc0
    487c:	1fff8bfc 	.word	0x1fff8bfc
    4880:	1fff8bc4 	.word	0x1fff8bc4
    4884:	1fff8c00 	.word	0x1fff8c00
    4888:	1fff8b21 	.word	0x1fff8b21
    488c:	1fff8b18 	.word	0x1fff8b18
    4890:	1fff8bc8 	.word	0x1fff8bc8
    4894:	1fff8bcc 	.word	0x1fff8bcc
    4898:	1fff8bd0 	.word	0x1fff8bd0
    489c:	1fff8bd4 	.word	0x1fff8bd4
    48a0:	1fff8bd8 	.word	0x1fff8bd8
    48a4:	1fff8c04 	.word	0x1fff8c04
    48a8:	1fff8bdc 	.word	0x1fff8bdc
    48ac:	1fff8be0 	.word	0x1fff8be0
    48b0:	1fff8c08 	.word	0x1fff8c08
    48b4:	1fff8be4 	.word	0x1fff8be4
    48b8:	1fff8be8 	.word	0x1fff8be8
    48bc:	1fff8c0c 	.word	0x1fff8c0c
    48c0:	1fff8bec 	.word	0x1fff8bec
    48c4:	1fff8bf0 	.word	0x1fff8bf0
    48c8:	1fff8c10 	.word	0x1fff8c10

000048cc <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    48cc:	b500      	push	{lr}
    48ce:	b083      	sub	sp, #12
    48d0:	9001      	str	r0, [sp, #4]
    48d2:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    48d4:	9b01      	ldr	r3, [sp, #4]
    48d6:	2b03      	cmp	r3, #3
    48d8:	f000 8090 	beq.w	49fc <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    48dc:	9b01      	ldr	r3, [sp, #4]
    48de:	2b03      	cmp	r3, #3
    48e0:	f200 80d3 	bhi.w	4a8a <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    48e4:	9b01      	ldr	r3, [sp, #4]
    48e6:	2b00      	cmp	r3, #0
    48e8:	d040      	beq.n	496c <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    48ea:	9b01      	ldr	r3, [sp, #4]
    48ec:	3b01      	subs	r3, #1
    48ee:	2b01      	cmp	r3, #1
    48f0:	f200 80cb 	bhi.w	4a8a <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    48f4:	9b00      	ldr	r3, [sp, #0]
    48f6:	2b00      	cmp	r3, #0
    48f8:	f040 80c9 	bne.w	4a8e <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    48fc:	4b68      	ldr	r3, [pc, #416]	; (4aa0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    48fe:	2200      	movs	r2, #0
    4900:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    4902:	4b68      	ldr	r3, [pc, #416]	; (4aa4 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    4904:	681b      	ldr	r3, [r3, #0]
    4906:	685b      	ldr	r3, [r3, #4]
    4908:	4a67      	ldr	r2, [pc, #412]	; (4aa8 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    490a:	6812      	ldr	r2, [r2, #0]
    490c:	4610      	mov	r0, r2
    490e:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    4910:	4b66      	ldr	r3, [pc, #408]	; (4aac <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    4912:	681b      	ldr	r3, [r3, #0]
    4914:	681b      	ldr	r3, [r3, #0]
    4916:	4a66      	ldr	r2, [pc, #408]	; (4ab0 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    4918:	6812      	ldr	r2, [r2, #0]
    491a:	4610      	mov	r0, r2
    491c:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    491e:	4b65      	ldr	r3, [pc, #404]	; (4ab4 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    4920:	681b      	ldr	r3, [r3, #0]
    4922:	681b      	ldr	r3, [r3, #0]
    4924:	4a64      	ldr	r2, [pc, #400]	; (4ab8 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    4926:	6812      	ldr	r2, [r2, #0]
    4928:	4610      	mov	r0, r2
    492a:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    492c:	4b63      	ldr	r3, [pc, #396]	; (4abc <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    492e:	681b      	ldr	r3, [r3, #0]
    4930:	681b      	ldr	r3, [r3, #0]
    4932:	4a63      	ldr	r2, [pc, #396]	; (4ac0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    4934:	6812      	ldr	r2, [r2, #0]
    4936:	4610      	mov	r0, r2
    4938:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    493a:	4b62      	ldr	r3, [pc, #392]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    493c:	681b      	ldr	r3, [r3, #0]
    493e:	691b      	ldr	r3, [r3, #16]
    4940:	4a61      	ldr	r2, [pc, #388]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4942:	6812      	ldr	r2, [r2, #0]
    4944:	6812      	ldr	r2, [r2, #0]
    4946:	4610      	mov	r0, r2
    4948:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    494a:	4b60      	ldr	r3, [pc, #384]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    494c:	681b      	ldr	r3, [r3, #0]
    494e:	68db      	ldr	r3, [r3, #12]
    4950:	4a5f      	ldr	r2, [pc, #380]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4952:	6812      	ldr	r2, [r2, #0]
    4954:	6812      	ldr	r2, [r2, #0]
    4956:	4610      	mov	r0, r2
    4958:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    495a:	4b5e      	ldr	r3, [pc, #376]	; (4ad4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    495c:	681b      	ldr	r3, [r3, #0]
    495e:	689b      	ldr	r3, [r3, #8]
    4960:	4a5d      	ldr	r2, [pc, #372]	; (4ad8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    4962:	6812      	ldr	r2, [r2, #0]
    4964:	6812      	ldr	r2, [r2, #0]
    4966:	4610      	mov	r0, r2
    4968:	4798      	blx	r3
            }
        }
        break;
    496a:	e090      	b.n	4a8e <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    496c:	9b00      	ldr	r3, [sp, #0]
    496e:	2b02      	cmp	r3, #2
    4970:	f040 808f 	bne.w	4a92 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    4974:	4b4a      	ldr	r3, [pc, #296]	; (4aa0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    4976:	2201      	movs	r2, #1
    4978:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    497a:	4b56      	ldr	r3, [pc, #344]	; (4ad4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    497c:	681b      	ldr	r3, [r3, #0]
    497e:	685b      	ldr	r3, [r3, #4]
    4980:	4a55      	ldr	r2, [pc, #340]	; (4ad8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    4982:	6812      	ldr	r2, [r2, #0]
    4984:	4610      	mov	r0, r2
    4986:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    4988:	4b50      	ldr	r3, [pc, #320]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    498a:	681b      	ldr	r3, [r3, #0]
    498c:	691b      	ldr	r3, [r3, #16]
    498e:	4a50      	ldr	r2, [pc, #320]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4990:	6812      	ldr	r2, [r2, #0]
    4992:	4610      	mov	r0, r2
    4994:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    4996:	4b4d      	ldr	r3, [pc, #308]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4998:	681b      	ldr	r3, [r3, #0]
    499a:	689b      	ldr	r3, [r3, #8]
    499c:	4a4c      	ldr	r2, [pc, #304]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    499e:	6812      	ldr	r2, [r2, #0]
    49a0:	4610      	mov	r0, r2
    49a2:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    49a4:	4b47      	ldr	r3, [pc, #284]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    49a6:	681b      	ldr	r3, [r3, #0]
    49a8:	68db      	ldr	r3, [r3, #12]
    49aa:	4a47      	ldr	r2, [pc, #284]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    49ac:	6812      	ldr	r2, [r2, #0]
    49ae:	4610      	mov	r0, r2
    49b0:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    49b2:	4b44      	ldr	r3, [pc, #272]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    49b4:	681b      	ldr	r3, [r3, #0]
    49b6:	689b      	ldr	r3, [r3, #8]
    49b8:	4a43      	ldr	r2, [pc, #268]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    49ba:	6812      	ldr	r2, [r2, #0]
    49bc:	6812      	ldr	r2, [r2, #0]
    49be:	4610      	mov	r0, r2
    49c0:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    49c2:	4b38      	ldr	r3, [pc, #224]	; (4aa4 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    49c4:	681b      	ldr	r3, [r3, #0]
    49c6:	685b      	ldr	r3, [r3, #4]
    49c8:	4a44      	ldr	r2, [pc, #272]	; (4adc <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    49ca:	6812      	ldr	r2, [r2, #0]
    49cc:	4610      	mov	r0, r2
    49ce:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    49d0:	4b36      	ldr	r3, [pc, #216]	; (4aac <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    49d2:	681b      	ldr	r3, [r3, #0]
    49d4:	681b      	ldr	r3, [r3, #0]
    49d6:	4a42      	ldr	r2, [pc, #264]	; (4ae0 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    49d8:	6812      	ldr	r2, [r2, #0]
    49da:	4610      	mov	r0, r2
    49dc:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    49de:	4b35      	ldr	r3, [pc, #212]	; (4ab4 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    49e0:	681b      	ldr	r3, [r3, #0]
    49e2:	681b      	ldr	r3, [r3, #0]
    49e4:	4a3f      	ldr	r2, [pc, #252]	; (4ae4 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    49e6:	6812      	ldr	r2, [r2, #0]
    49e8:	4610      	mov	r0, r2
    49ea:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    49ec:	4b33      	ldr	r3, [pc, #204]	; (4abc <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    49ee:	681b      	ldr	r3, [r3, #0]
    49f0:	681b      	ldr	r3, [r3, #0]
    49f2:	4a3d      	ldr	r2, [pc, #244]	; (4ae8 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    49f4:	6812      	ldr	r2, [r2, #0]
    49f6:	4610      	mov	r0, r2
    49f8:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    49fa:	e04a      	b.n	4a92 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    49fc:	9b00      	ldr	r3, [sp, #0]
    49fe:	2b02      	cmp	r3, #2
    4a00:	d149      	bne.n	4a96 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    4a02:	4b27      	ldr	r3, [pc, #156]	; (4aa0 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    4a04:	2201      	movs	r2, #1
    4a06:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    4a08:	4b32      	ldr	r3, [pc, #200]	; (4ad4 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4a0a:	681b      	ldr	r3, [r3, #0]
    4a0c:	685b      	ldr	r3, [r3, #4]
    4a0e:	4a32      	ldr	r2, [pc, #200]	; (4ad8 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    4a10:	6812      	ldr	r2, [r2, #0]
    4a12:	4610      	mov	r0, r2
    4a14:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    4a16:	4b2d      	ldr	r3, [pc, #180]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4a18:	681b      	ldr	r3, [r3, #0]
    4a1a:	691b      	ldr	r3, [r3, #16]
    4a1c:	4a2c      	ldr	r2, [pc, #176]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4a1e:	6812      	ldr	r2, [r2, #0]
    4a20:	4610      	mov	r0, r2
    4a22:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    4a24:	4b29      	ldr	r3, [pc, #164]	; (4acc <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4a26:	681b      	ldr	r3, [r3, #0]
    4a28:	689b      	ldr	r3, [r3, #8]
    4a2a:	4a29      	ldr	r2, [pc, #164]	; (4ad0 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4a2c:	6812      	ldr	r2, [r2, #0]
    4a2e:	4610      	mov	r0, r2
    4a30:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    4a32:	4b24      	ldr	r3, [pc, #144]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4a34:	681b      	ldr	r3, [r3, #0]
    4a36:	68db      	ldr	r3, [r3, #12]
    4a38:	4a23      	ldr	r2, [pc, #140]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4a3a:	6812      	ldr	r2, [r2, #0]
    4a3c:	4610      	mov	r0, r2
    4a3e:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    4a40:	4b20      	ldr	r3, [pc, #128]	; (4ac4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4a42:	681b      	ldr	r3, [r3, #0]
    4a44:	689b      	ldr	r3, [r3, #8]
    4a46:	4a20      	ldr	r2, [pc, #128]	; (4ac8 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4a48:	6812      	ldr	r2, [r2, #0]
    4a4a:	6812      	ldr	r2, [r2, #0]
    4a4c:	4610      	mov	r0, r2
    4a4e:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    4a50:	4b26      	ldr	r3, [pc, #152]	; (4aec <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    4a52:	681b      	ldr	r3, [r3, #0]
    4a54:	685b      	ldr	r3, [r3, #4]
    4a56:	4a26      	ldr	r2, [pc, #152]	; (4af0 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    4a58:	6812      	ldr	r2, [r2, #0]
    4a5a:	4610      	mov	r0, r2
    4a5c:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    4a5e:	4b25      	ldr	r3, [pc, #148]	; (4af4 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    4a60:	681b      	ldr	r3, [r3, #0]
    4a62:	681b      	ldr	r3, [r3, #0]
    4a64:	4a24      	ldr	r2, [pc, #144]	; (4af8 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    4a66:	6812      	ldr	r2, [r2, #0]
    4a68:	4610      	mov	r0, r2
    4a6a:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    4a6c:	4b23      	ldr	r3, [pc, #140]	; (4afc <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    4a6e:	681b      	ldr	r3, [r3, #0]
    4a70:	681b      	ldr	r3, [r3, #0]
    4a72:	4a23      	ldr	r2, [pc, #140]	; (4b00 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    4a74:	6812      	ldr	r2, [r2, #0]
    4a76:	4610      	mov	r0, r2
    4a78:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    4a7a:	4b22      	ldr	r3, [pc, #136]	; (4b04 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    4a7c:	681b      	ldr	r3, [r3, #0]
    4a7e:	681b      	ldr	r3, [r3, #0]
    4a80:	4a21      	ldr	r2, [pc, #132]	; (4b08 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    4a82:	6812      	ldr	r2, [r2, #0]
    4a84:	4610      	mov	r0, r2
    4a86:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    4a88:	e005      	b.n	4a96 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    4a8a:	bf00      	nop
    4a8c:	e004      	b.n	4a98 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4a8e:	bf00      	nop
    4a90:	e002      	b.n	4a98 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4a92:	bf00      	nop
    4a94:	e000      	b.n	4a98 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4a96:	bf00      	nop
    }

}
    4a98:	bf00      	nop
    4a9a:	b003      	add	sp, #12
    4a9c:	f85d fb04 	ldr.w	pc, [sp], #4
    4aa0:	1fff8b21 	.word	0x1fff8b21
    4aa4:	1fff8bb8 	.word	0x1fff8bb8
    4aa8:	1fff8bd8 	.word	0x1fff8bd8
    4aac:	1fff8bbc 	.word	0x1fff8bbc
    4ab0:	1fff8be0 	.word	0x1fff8be0
    4ab4:	1fff8bc0 	.word	0x1fff8bc0
    4ab8:	1fff8be8 	.word	0x1fff8be8
    4abc:	1fff8bc4 	.word	0x1fff8bc4
    4ac0:	1fff8bf0 	.word	0x1fff8bf0
    4ac4:	1fff8bac 	.word	0x1fff8bac
    4ac8:	1fff8bd0 	.word	0x1fff8bd0
    4acc:	1fff8bb0 	.word	0x1fff8bb0
    4ad0:	1fff8bcc 	.word	0x1fff8bcc
    4ad4:	1fff8bb4 	.word	0x1fff8bb4
    4ad8:	1fff8bc8 	.word	0x1fff8bc8
    4adc:	1fff8bd4 	.word	0x1fff8bd4
    4ae0:	1fff8bdc 	.word	0x1fff8bdc
    4ae4:	1fff8be4 	.word	0x1fff8be4
    4ae8:	1fff8bec 	.word	0x1fff8bec
    4aec:	1fff8bf4 	.word	0x1fff8bf4
    4af0:	1fff8c04 	.word	0x1fff8c04
    4af4:	1fff8bf8 	.word	0x1fff8bf8
    4af8:	1fff8c08 	.word	0x1fff8c08
    4afc:	1fff8bfc 	.word	0x1fff8bfc
    4b00:	1fff8c0c 	.word	0x1fff8c0c
    4b04:	1fff8c00 	.word	0x1fff8c00
    4b08:	1fff8c10 	.word	0x1fff8c10

00004b0c <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    4b0c:	b500      	push	{lr}
    4b0e:	b083      	sub	sp, #12
    4b10:	9001      	str	r0, [sp, #4]
    4b12:	9100      	str	r1, [sp, #0]
    switch(Command)
    4b14:	9b00      	ldr	r3, [sp, #0]
    4b16:	2b04      	cmp	r3, #4
    4b18:	d010      	beq.n	4b3c <Clock_Ip_Command+0x30>
    4b1a:	9b00      	ldr	r3, [sp, #0]
    4b1c:	2b04      	cmp	r3, #4
    4b1e:	d811      	bhi.n	4b44 <Clock_Ip_Command+0x38>
    4b20:	9b00      	ldr	r3, [sp, #0]
    4b22:	2b01      	cmp	r3, #1
    4b24:	d006      	beq.n	4b34 <Clock_Ip_Command+0x28>
    4b26:	9b00      	ldr	r3, [sp, #0]
    4b28:	2b02      	cmp	r3, #2
    4b2a:	d10b      	bne.n	4b44 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    4b2c:	9801      	ldr	r0, [sp, #4]
    4b2e:	f7ff fdb3 	bl	4698 <Clock_Ip_ClockInitializeObjects>
            break;
    4b32:	e008      	b.n	4b46 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    4b34:	9801      	ldr	r0, [sp, #4]
    4b36:	f7ff f9db 	bl	3ef0 <Clock_Ip_SpecificPlatformInitClock>
            break;
    4b3a:	e004      	b.n	4b46 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    4b3c:	9801      	ldr	r0, [sp, #4]
    4b3e:	f7ff f8ed 	bl	3d1c <DisableSafeClock>
            break;
    4b42:	e000      	b.n	4b46 <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    4b44:	bf00      	nop
    }
}
    4b46:	bf00      	nop
    4b48:	b003      	add	sp, #12
    4b4a:	f85d fb04 	ldr.w	pc, [sp], #4
    4b4e:	bf00      	nop

00004b50 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    4b50:	b500      	push	{lr}
    4b52:	b085      	sub	sp, #20
    4b54:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    4b56:	4a20      	ldr	r2, [pc, #128]	; (4bd8 <Mcu_Init+0x88>)
    4b58:	9b01      	ldr	r3, [sp, #4]
    4b5a:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4b5c:	2300      	movs	r3, #0
    4b5e:	9303      	str	r3, [sp, #12]
    4b60:	e010      	b.n	4b84 <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    4b62:	4b1d      	ldr	r3, [pc, #116]	; (4bd8 <Mcu_Init+0x88>)
    4b64:	681b      	ldr	r3, [r3, #0]
    4b66:	6919      	ldr	r1, [r3, #16]
    4b68:	9a03      	ldr	r2, [sp, #12]
    4b6a:	4613      	mov	r3, r2
    4b6c:	005b      	lsls	r3, r3, #1
    4b6e:	4413      	add	r3, r2
    4b70:	009b      	lsls	r3, r3, #2
    4b72:	440b      	add	r3, r1
    4b74:	681b      	ldr	r3, [r3, #0]
    4b76:	9a03      	ldr	r2, [sp, #12]
    4b78:	b2d1      	uxtb	r1, r2
    4b7a:	4a18      	ldr	r2, [pc, #96]	; (4bdc <Mcu_Init+0x8c>)
    4b7c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4b7e:	9b03      	ldr	r3, [sp, #12]
    4b80:	3301      	adds	r3, #1
    4b82:	9303      	str	r3, [sp, #12]
    4b84:	4b14      	ldr	r3, [pc, #80]	; (4bd8 <Mcu_Init+0x88>)
    4b86:	681b      	ldr	r3, [r3, #0]
    4b88:	689b      	ldr	r3, [r3, #8]
    4b8a:	9a03      	ldr	r2, [sp, #12]
    4b8c:	429a      	cmp	r2, r3
    4b8e:	d3e8      	bcc.n	4b62 <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    4b90:	2300      	movs	r3, #0
    4b92:	9303      	str	r3, [sp, #12]
    4b94:	e010      	b.n	4bb8 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    4b96:	4b10      	ldr	r3, [pc, #64]	; (4bd8 <Mcu_Init+0x88>)
    4b98:	681b      	ldr	r3, [r3, #0]
    4b9a:	6959      	ldr	r1, [r3, #20]
    4b9c:	9a03      	ldr	r2, [sp, #12]
    4b9e:	4613      	mov	r3, r2
    4ba0:	01db      	lsls	r3, r3, #7
    4ba2:	1a9b      	subs	r3, r3, r2
    4ba4:	00db      	lsls	r3, r3, #3
    4ba6:	440b      	add	r3, r1
    4ba8:	681b      	ldr	r3, [r3, #0]
    4baa:	9a03      	ldr	r2, [sp, #12]
    4bac:	b2d1      	uxtb	r1, r2
    4bae:	4a0c      	ldr	r2, [pc, #48]	; (4be0 <Mcu_Init+0x90>)
    4bb0:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    4bb2:	9b03      	ldr	r3, [sp, #12]
    4bb4:	3301      	adds	r3, #1
    4bb6:	9303      	str	r3, [sp, #12]
    4bb8:	4b07      	ldr	r3, [pc, #28]	; (4bd8 <Mcu_Init+0x88>)
    4bba:	681b      	ldr	r3, [r3, #0]
    4bbc:	68db      	ldr	r3, [r3, #12]
    4bbe:	9a03      	ldr	r2, [sp, #12]
    4bc0:	429a      	cmp	r2, r3
    4bc2:	d3e8      	bcc.n	4b96 <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    4bc4:	4b04      	ldr	r3, [pc, #16]	; (4bd8 <Mcu_Init+0x88>)
    4bc6:	681b      	ldr	r3, [r3, #0]
    4bc8:	699b      	ldr	r3, [r3, #24]
    4bca:	4618      	mov	r0, r3
    4bcc:	f000 f88a 	bl	4ce4 <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4bd0:	bf00      	nop
    4bd2:	b005      	add	sp, #20
    4bd4:	f85d fb04 	ldr.w	pc, [sp], #4
    4bd8:	1fff8cec 	.word	0x1fff8cec
    4bdc:	1fff8ce8 	.word	0x1fff8ce8
    4be0:	1fff8ce4 	.word	0x1fff8ce4

00004be4 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    4be4:	b084      	sub	sp, #16
    4be6:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    4be8:	2301      	movs	r3, #1
    4bea:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    4bee:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    4bf2:	4618      	mov	r0, r3
    4bf4:	b004      	add	sp, #16
    4bf6:	4770      	bx	lr

00004bf8 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    4bf8:	b500      	push	{lr}
    4bfa:	b085      	sub	sp, #20
    4bfc:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    4bfe:	4a0e      	ldr	r2, [pc, #56]	; (4c38 <Mcu_InitClock+0x40>)
    4c00:	9b01      	ldr	r3, [sp, #4]
    4c02:	4413      	add	r3, r2
    4c04:	781b      	ldrb	r3, [r3, #0]
    4c06:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    4c0a:	4b0c      	ldr	r3, [pc, #48]	; (4c3c <Mcu_InitClock+0x44>)
    4c0c:	681b      	ldr	r3, [r3, #0]
    4c0e:	6959      	ldr	r1, [r3, #20]
    4c10:	f89d 200f 	ldrb.w	r2, [sp, #15]
    4c14:	4613      	mov	r3, r2
    4c16:	01db      	lsls	r3, r3, #7
    4c18:	1a9b      	subs	r3, r3, r2
    4c1a:	00db      	lsls	r3, r3, #3
    4c1c:	440b      	add	r3, r1
    4c1e:	4618      	mov	r0, r3
    4c20:	f000 f86a 	bl	4cf8 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    4c24:	2300      	movs	r3, #0
    4c26:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    4c2a:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    4c2e:	4618      	mov	r0, r3
    4c30:	b005      	add	sp, #20
    4c32:	f85d fb04 	ldr.w	pc, [sp], #4
    4c36:	bf00      	nop
    4c38:	1fff8ce4 	.word	0x1fff8ce4
    4c3c:	1fff8cec 	.word	0x1fff8cec

00004c40 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    4c40:	b500      	push	{lr}
    4c42:	b085      	sub	sp, #20
    4c44:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    4c46:	4a0d      	ldr	r2, [pc, #52]	; (4c7c <Mcu_SetMode+0x3c>)
    4c48:	9b01      	ldr	r3, [sp, #4]
    4c4a:	4413      	add	r3, r2
    4c4c:	781b      	ldrb	r3, [r3, #0]
    4c4e:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    4c52:	f006 ff91 	bl	bb78 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    4c56:	4b0a      	ldr	r3, [pc, #40]	; (4c80 <Mcu_SetMode+0x40>)
    4c58:	681b      	ldr	r3, [r3, #0]
    4c5a:	6919      	ldr	r1, [r3, #16]
    4c5c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    4c60:	4613      	mov	r3, r2
    4c62:	005b      	lsls	r3, r3, #1
    4c64:	4413      	add	r3, r2
    4c66:	009b      	lsls	r3, r3, #2
    4c68:	440b      	add	r3, r1
    4c6a:	4618      	mov	r0, r3
    4c6c:	f000 f84e 	bl	4d0c <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    4c70:	f006 ffae 	bl	bbd0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4c74:	bf00      	nop
    4c76:	b005      	add	sp, #20
    4c78:	f85d fb04 	ldr.w	pc, [sp], #4
    4c7c:	1fff8ce8 	.word	0x1fff8ce8
    4c80:	1fff8cec 	.word	0x1fff8cec

00004c84 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    4c84:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    4c86:	2302      	movs	r3, #2
    4c88:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    4c8a:	9b01      	ldr	r3, [sp, #4]
}
    4c8c:	4618      	mov	r0, r3
    4c8e:	b002      	add	sp, #8
    4c90:	4770      	bx	lr

00004c92 <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    4c92:	b500      	push	{lr}
    4c94:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    4c96:	f000 f843 	bl	4d20 <Mcu_Ipw_GetResetReason>
    4c9a:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    4c9c:	9b01      	ldr	r3, [sp, #4]
}
    4c9e:	4618      	mov	r0, r3
    4ca0:	b003      	add	sp, #12
    4ca2:	f85d fb04 	ldr.w	pc, [sp], #4

00004ca6 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    4ca6:	b500      	push	{lr}
    4ca8:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    4caa:	f000 f83f 	bl	4d2c <Mcu_Ipw_GetResetRawValue>
    4cae:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    4cb0:	9b01      	ldr	r3, [sp, #4]
}
    4cb2:	4618      	mov	r0, r3
    4cb4:	b003      	add	sp, #12
    4cb6:	f85d fb04 	ldr.w	pc, [sp], #4

00004cba <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4cba:	b500      	push	{lr}
    4cbc:	b083      	sub	sp, #12
    4cbe:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    4cc0:	9801      	ldr	r0, [sp, #4]
    4cc2:	f000 f839 	bl	4d38 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    4cc6:	bf00      	nop
    4cc8:	b003      	add	sp, #12
    4cca:	f85d fb04 	ldr.w	pc, [sp], #4

00004cce <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    4cce:	b082      	sub	sp, #8
    4cd0:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    4cd2:	4b03      	ldr	r3, [pc, #12]	; (4ce0 <Mcu_ClkSrcFailureNotification+0x12>)
    4cd4:	681b      	ldr	r3, [r3, #0]
    4cd6:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    4cd8:	bf00      	nop
    4cda:	b002      	add	sp, #8
    4cdc:	4770      	bx	lr
    4cde:	bf00      	nop
    4ce0:	1fff8cec 	.word	0x1fff8cec

00004ce4 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    4ce4:	b500      	push	{lr}
    4ce6:	b083      	sub	sp, #12
    4ce8:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    4cea:	9801      	ldr	r0, [sp, #4]
    4cec:	f000 f882 	bl	4df4 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    4cf0:	bf00      	nop
    4cf2:	b003      	add	sp, #12
    4cf4:	f85d fb04 	ldr.w	pc, [sp], #4

00004cf8 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    4cf8:	b500      	push	{lr}
    4cfa:	b083      	sub	sp, #12
    4cfc:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    4cfe:	9801      	ldr	r0, [sp, #4]
    4d00:	f7fc fc6a 	bl	15d8 <Clock_Ip_InitClock>
}
    4d04:	bf00      	nop
    4d06:	b003      	add	sp, #12
    4d08:	f85d fb04 	ldr.w	pc, [sp], #4

00004d0c <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    4d0c:	b500      	push	{lr}
    4d0e:	b083      	sub	sp, #12
    4d10:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    4d12:	9801      	ldr	r0, [sp, #4]
    4d14:	f000 f820 	bl	4d58 <Power_Ip_SetMode>
}
    4d18:	bf00      	nop
    4d1a:	b003      	add	sp, #12
    4d1c:	f85d fb04 	ldr.w	pc, [sp], #4

00004d20 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    4d20:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    4d22:	f000 f84f 	bl	4dc4 <Power_Ip_GetResetReason>
    4d26:	4603      	mov	r3, r0
}
    4d28:	4618      	mov	r0, r3
    4d2a:	bd08      	pop	{r3, pc}

00004d2c <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    4d2c:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    4d2e:	f000 f857 	bl	4de0 <Power_Ip_GetResetRawValue>
    4d32:	4603      	mov	r3, r0
}
    4d34:	4618      	mov	r0, r3
    4d36:	bd08      	pop	{r3, pc}

00004d38 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4d38:	b500      	push	{lr}
    4d3a:	b083      	sub	sp, #12
    4d3c:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    4d3e:	9b01      	ldr	r3, [sp, #4]
    4d40:	2b00      	cmp	r3, #0
    4d42:	d102      	bne.n	4d4a <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    4d44:	f000 f86c 	bl	4e20 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    4d48:	e001      	b.n	4d4e <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    4d4a:	f000 f86e 	bl	4e2a <Power_Ip_EnableSleepOnExit>
}
    4d4e:	bf00      	nop
    4d50:	b003      	add	sp, #12
    4d52:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004d58 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4d58:	b500      	push	{lr}
    4d5a:	b085      	sub	sp, #20
    4d5c:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    4d5e:	9b01      	ldr	r3, [sp, #4]
    4d60:	685b      	ldr	r3, [r3, #4]
    4d62:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    4d64:	9802      	ldr	r0, [sp, #8]
    4d66:	f000 f9f5 	bl	5154 <Power_Ip_SMC_ModeCheckEntry>
    4d6a:	4603      	mov	r3, r0
    4d6c:	2b00      	cmp	r3, #0
    4d6e:	d002      	beq.n	4d76 <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4d70:	2301      	movs	r3, #1
    4d72:	9303      	str	r3, [sp, #12]
    4d74:	e003      	b.n	4d7e <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    4d76:	9801      	ldr	r0, [sp, #4]
    4d78:	f000 fa1e 	bl	51b8 <Power_Ip_SMC_ModeConfig>
    4d7c:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    4d7e:	9b03      	ldr	r3, [sp, #12]
    4d80:	2b01      	cmp	r3, #1
    4d82:	d103      	bne.n	4d8c <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4d84:	21ff      	movs	r1, #255	; 0xff
    4d86:	2003      	movs	r0, #3
    4d88:	f000 f8f4 	bl	4f74 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    4d8c:	bf00      	nop
    4d8e:	b005      	add	sp, #20
    4d90:	f85d fb04 	ldr.w	pc, [sp], #4

00004d94 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    4d94:	b084      	sub	sp, #16
    4d96:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    4d98:	230c      	movs	r3, #12
    4d9a:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    4d9c:	4a08      	ldr	r2, [pc, #32]	; (4dc0 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4d9e:	9b01      	ldr	r3, [sp, #4]
    4da0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4da4:	2b0e      	cmp	r3, #14
    4da6:	d805      	bhi.n	4db4 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    4da8:	4a05      	ldr	r2, [pc, #20]	; (4dc0 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4daa:	9b01      	ldr	r3, [sp, #4]
    4dac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4db0:	9303      	str	r3, [sp, #12]
    4db2:	e001      	b.n	4db8 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    4db4:	230c      	movs	r3, #12
    4db6:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    4db8:	9b03      	ldr	r3, [sp, #12]
}
    4dba:	4618      	mov	r0, r3
    4dbc:	b004      	add	sp, #16
    4dbe:	4770      	bx	lr
    4dc0:	0000c614 	.word	0x0000c614

00004dc4 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    4dc4:	b500      	push	{lr}
    4dc6:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    4dc8:	f000 f940 	bl	504c <Power_Ip_RCM_GetResetReason>
    4dcc:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    4dce:	9801      	ldr	r0, [sp, #4]
    4dd0:	f7ff ffe0 	bl	4d94 <Power_Ip_ConvertIntergeToResetType>
    4dd4:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    4dd6:	9b00      	ldr	r3, [sp, #0]
}
    4dd8:	4618      	mov	r0, r3
    4dda:	b003      	add	sp, #12
    4ddc:	f85d fb04 	ldr.w	pc, [sp], #4

00004de0 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    4de0:	b500      	push	{lr}
    4de2:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    4de4:	f000 f98a 	bl	50fc <Power_Ip_RCM_GetResetRawValue>
    4de8:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    4dea:	9b01      	ldr	r3, [sp, #4]
}
    4dec:	4618      	mov	r0, r3
    4dee:	b003      	add	sp, #12
    4df0:	f85d fb04 	ldr.w	pc, [sp], #4

00004df4 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    4df4:	b500      	push	{lr}
    4df6:	b083      	sub	sp, #12
    4df8:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    4dfa:	9b01      	ldr	r3, [sp, #4]
    4dfc:	681b      	ldr	r3, [r3, #0]
    4dfe:	4618      	mov	r0, r3
    4e00:	f000 f90e 	bl	5020 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    4e04:	9b01      	ldr	r3, [sp, #4]
    4e06:	685b      	ldr	r3, [r3, #4]
    4e08:	4618      	mov	r0, r3
    4e0a:	f000 f86d 	bl	4ee8 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    4e0e:	9b01      	ldr	r3, [sp, #4]
    4e10:	689b      	ldr	r3, [r3, #8]
    4e12:	4618      	mov	r0, r3
    4e14:	f000 f990 	bl	5138 <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    4e18:	bf00      	nop
    4e1a:	b003      	add	sp, #12
    4e1c:	f85d fb04 	ldr.w	pc, [sp], #4

00004e20 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    4e20:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    4e22:	f000 f811 	bl	4e48 <Power_Ip_CM4_DisableSleepOnExit>
}
    4e26:	bf00      	nop
    4e28:	bd08      	pop	{r3, pc}

00004e2a <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    4e2a:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    4e2c:	f000 f820 	bl	4e70 <Power_Ip_CM4_EnableSleepOnExit>
}
    4e30:	bf00      	nop
    4e32:	bd08      	pop	{r3, pc}

00004e34 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    4e34:	b082      	sub	sp, #8
    4e36:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    4e38:	4a02      	ldr	r2, [pc, #8]	; (4e44 <Power_Ip_InstallNotificationsCallback+0x10>)
    4e3a:	9b01      	ldr	r3, [sp, #4]
    4e3c:	6013      	str	r3, [r2, #0]
}
    4e3e:	bf00      	nop
    4e40:	b002      	add	sp, #8
    4e42:	4770      	bx	lr
    4e44:	1fff8b24 	.word	0x1fff8b24

00004e48 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    4e48:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4e4a:	2300      	movs	r3, #0
    4e4c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4e4e:	4b07      	ldr	r3, [pc, #28]	; (4e6c <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4e50:	681b      	ldr	r3, [r3, #0]
    4e52:	685b      	ldr	r3, [r3, #4]
    4e54:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    4e56:	9b01      	ldr	r3, [sp, #4]
    4e58:	f023 0302 	bic.w	r3, r3, #2
    4e5c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4e5e:	4b03      	ldr	r3, [pc, #12]	; (4e6c <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4e60:	681b      	ldr	r3, [r3, #0]
    4e62:	9a01      	ldr	r2, [sp, #4]
    4e64:	605a      	str	r2, [r3, #4]
}
    4e66:	bf00      	nop
    4e68:	b002      	add	sp, #8
    4e6a:	4770      	bx	lr
    4e6c:	1fff8b28 	.word	0x1fff8b28

00004e70 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    4e70:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4e72:	2300      	movs	r3, #0
    4e74:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4e76:	4b07      	ldr	r3, [pc, #28]	; (4e94 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4e78:	681b      	ldr	r3, [r3, #0]
    4e7a:	685b      	ldr	r3, [r3, #4]
    4e7c:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    4e7e:	9b01      	ldr	r3, [sp, #4]
    4e80:	f043 0302 	orr.w	r3, r3, #2
    4e84:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4e86:	4b03      	ldr	r3, [pc, #12]	; (4e94 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4e88:	681b      	ldr	r3, [r3, #0]
    4e8a:	9a01      	ldr	r2, [sp, #4]
    4e8c:	605a      	str	r2, [r3, #4]
}
    4e8e:	bf00      	nop
    4e90:	b002      	add	sp, #8
    4e92:	4770      	bx	lr
    4e94:	1fff8b28 	.word	0x1fff8b28

00004e98 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    4e98:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4e9a:	2300      	movs	r3, #0
    4e9c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4e9e:	4b07      	ldr	r3, [pc, #28]	; (4ebc <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4ea0:	681b      	ldr	r3, [r3, #0]
    4ea2:	685b      	ldr	r3, [r3, #4]
    4ea4:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    4ea6:	9b01      	ldr	r3, [sp, #4]
    4ea8:	f043 0304 	orr.w	r3, r3, #4
    4eac:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4eae:	4b03      	ldr	r3, [pc, #12]	; (4ebc <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4eb0:	681b      	ldr	r3, [r3, #0]
    4eb2:	9a01      	ldr	r2, [sp, #4]
    4eb4:	605a      	str	r2, [r3, #4]
}
    4eb6:	bf00      	nop
    4eb8:	b002      	add	sp, #8
    4eba:	4770      	bx	lr
    4ebc:	1fff8b28 	.word	0x1fff8b28

00004ec0 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    4ec0:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4ec2:	2300      	movs	r3, #0
    4ec4:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4ec6:	4b07      	ldr	r3, [pc, #28]	; (4ee4 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4ec8:	681b      	ldr	r3, [r3, #0]
    4eca:	685b      	ldr	r3, [r3, #4]
    4ecc:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    4ece:	9b01      	ldr	r3, [sp, #4]
    4ed0:	f023 0304 	bic.w	r3, r3, #4
    4ed4:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4ed6:	4b03      	ldr	r3, [pc, #12]	; (4ee4 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4ed8:	681b      	ldr	r3, [r3, #0]
    4eda:	9a01      	ldr	r2, [sp, #4]
    4edc:	605a      	str	r2, [r3, #4]
}
    4ede:	bf00      	nop
    4ee0:	b002      	add	sp, #8
    4ee2:	4770      	bx	lr
    4ee4:	1fff8b28 	.word	0x1fff8b28

00004ee8 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    4ee8:	b084      	sub	sp, #16
    4eea:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    4eec:	4b20      	ldr	r3, [pc, #128]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4eee:	781b      	ldrb	r3, [r3, #0]
    4ef0:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    4ef4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4ef8:	f003 030f 	and.w	r3, r3, #15
    4efc:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    4f00:	9b01      	ldr	r3, [sp, #4]
    4f02:	781a      	ldrb	r2, [r3, #0]
    4f04:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f08:	4313      	orrs	r3, r2
    4f0a:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    4f0e:	4a18      	ldr	r2, [pc, #96]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4f10:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f14:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    4f16:	4b16      	ldr	r3, [pc, #88]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4f18:	785b      	ldrb	r3, [r3, #1]
    4f1a:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    4f1e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f22:	f003 031f 	and.w	r3, r3, #31
    4f26:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    4f2a:	9b01      	ldr	r3, [sp, #4]
    4f2c:	785a      	ldrb	r2, [r3, #1]
    4f2e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f32:	4313      	orrs	r3, r2
    4f34:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    4f38:	4a0d      	ldr	r2, [pc, #52]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4f3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f3e:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    4f40:	4b0b      	ldr	r3, [pc, #44]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4f42:	789b      	ldrb	r3, [r3, #2]
    4f44:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    4f48:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f4c:	f003 0338 	and.w	r3, r3, #56	; 0x38
    4f50:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    4f54:	9b01      	ldr	r3, [sp, #4]
    4f56:	789a      	ldrb	r2, [r3, #2]
    4f58:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f5c:	4313      	orrs	r3, r2
    4f5e:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    4f62:	4a03      	ldr	r2, [pc, #12]	; (4f70 <Power_Ip_PMC_PowerInit+0x88>)
    4f64:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4f68:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    4f6a:	bf00      	nop
    4f6c:	b004      	add	sp, #16
    4f6e:	4770      	bx	lr
    4f70:	4007d000 	.word	0x4007d000

00004f74 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4f74:	b500      	push	{lr}
    4f76:	b083      	sub	sp, #12
    4f78:	9001      	str	r0, [sp, #4]
    4f7a:	460b      	mov	r3, r1
    4f7c:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    4f80:	4b05      	ldr	r3, [pc, #20]	; (4f98 <Power_Ip_ReportPowerErrors+0x24>)
    4f82:	681b      	ldr	r3, [r3, #0]
    4f84:	f89d 2003 	ldrb.w	r2, [sp, #3]
    4f88:	4611      	mov	r1, r2
    4f8a:	9801      	ldr	r0, [sp, #4]
    4f8c:	4798      	blx	r3
}
    4f8e:	bf00      	nop
    4f90:	b003      	add	sp, #12
    4f92:	f85d fb04 	ldr.w	pc, [sp], #4
    4f96:	bf00      	nop
    4f98:	1fff8b24 	.word	0x1fff8b24

00004f9c <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4f9c:	b082      	sub	sp, #8
    4f9e:	9001      	str	r0, [sp, #4]
    4fa0:	460b      	mov	r3, r1
    4fa2:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    4fa6:	bf00      	nop
    4fa8:	b002      	add	sp, #8
    4faa:	4770      	bx	lr

00004fac <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    4fac:	b500      	push	{lr}
    4fae:	b085      	sub	sp, #20
    4fb0:	9003      	str	r0, [sp, #12]
    4fb2:	9102      	str	r1, [sp, #8]
    4fb4:	9201      	str	r2, [sp, #4]
    4fb6:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    4fb8:	2000      	movs	r0, #0
    4fba:	f7fc f83c 	bl	1036 <OsIf_GetCounter>
    4fbe:	4602      	mov	r2, r0
    4fc0:	9b03      	ldr	r3, [sp, #12]
    4fc2:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    4fc4:	9b02      	ldr	r3, [sp, #8]
    4fc6:	2200      	movs	r2, #0
    4fc8:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    4fca:	2100      	movs	r1, #0
    4fcc:	9800      	ldr	r0, [sp, #0]
    4fce:	f7fc f87e 	bl	10ce <OsIf_MicrosToTicks>
    4fd2:	4602      	mov	r2, r0
    4fd4:	9b01      	ldr	r3, [sp, #4]
    4fd6:	601a      	str	r2, [r3, #0]
}
    4fd8:	bf00      	nop
    4fda:	b005      	add	sp, #20
    4fdc:	f85d fb04 	ldr.w	pc, [sp], #4

00004fe0 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    4fe0:	b500      	push	{lr}
    4fe2:	b087      	sub	sp, #28
    4fe4:	9003      	str	r0, [sp, #12]
    4fe6:	9102      	str	r1, [sp, #8]
    4fe8:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    4fea:	2300      	movs	r3, #0
    4fec:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    4ff0:	2100      	movs	r1, #0
    4ff2:	9803      	ldr	r0, [sp, #12]
    4ff4:	f7fc f838 	bl	1068 <OsIf_GetElapsed>
    4ff8:	4602      	mov	r2, r0
    4ffa:	9b02      	ldr	r3, [sp, #8]
    4ffc:	681b      	ldr	r3, [r3, #0]
    4ffe:	441a      	add	r2, r3
    5000:	9b02      	ldr	r3, [sp, #8]
    5002:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    5004:	9b02      	ldr	r3, [sp, #8]
    5006:	681b      	ldr	r3, [r3, #0]
    5008:	9a01      	ldr	r2, [sp, #4]
    500a:	429a      	cmp	r2, r3
    500c:	d802      	bhi.n	5014 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    500e:	2301      	movs	r3, #1
    5010:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    5014:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5018:	4618      	mov	r0, r3
    501a:	b007      	add	sp, #28
    501c:	f85d fb04 	ldr.w	pc, [sp], #4

00005020 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    5020:	b082      	sub	sp, #8
    5022:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    5024:	9b01      	ldr	r3, [sp, #4]
    5026:	681a      	ldr	r2, [r3, #0]
    5028:	4907      	ldr	r1, [pc, #28]	; (5048 <Power_Ip_RCM_ResetInit+0x28>)
    502a:	f641 7307 	movw	r3, #7943	; 0x1f07
    502e:	4013      	ands	r3, r2
    5030:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    5032:	9b01      	ldr	r3, [sp, #4]
    5034:	685a      	ldr	r2, [r3, #4]
    5036:	4904      	ldr	r1, [pc, #16]	; (5048 <Power_Ip_RCM_ResetInit+0x28>)
    5038:	f642 73ff 	movw	r3, #12287	; 0x2fff
    503c:	4013      	ands	r3, r2
    503e:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    5040:	bf00      	nop
    5042:	b002      	add	sp, #8
    5044:	4770      	bx	lr
    5046:	bf00      	nop
    5048:	4007f000 	.word	0x4007f000

0000504c <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    504c:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    504e:	230c      	movs	r3, #12
    5050:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    5052:	2300      	movs	r3, #0
    5054:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    5056:	2300      	movs	r3, #0
    5058:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    505a:	2300      	movs	r3, #0
    505c:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    505e:	4b25      	ldr	r3, [pc, #148]	; (50f4 <Power_Ip_RCM_GetResetReason+0xa8>)
    5060:	699a      	ldr	r2, [r3, #24]
    5062:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5066:	4013      	ands	r3, r2
    5068:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    506a:	9b03      	ldr	r3, [sp, #12]
    506c:	2b00      	cmp	r3, #0
    506e:	d008      	beq.n	5082 <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5070:	4920      	ldr	r1, [pc, #128]	; (50f4 <Power_Ip_RCM_GetResetReason+0xa8>)
    5072:	9a03      	ldr	r2, [sp, #12]
    5074:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5078:	4013      	ands	r3, r2
    507a:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    507c:	4a1e      	ldr	r2, [pc, #120]	; (50f8 <Power_Ip_RCM_GetResetReason+0xac>)
    507e:	9b03      	ldr	r3, [sp, #12]
    5080:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    5082:	4b1d      	ldr	r3, [pc, #116]	; (50f8 <Power_Ip_RCM_GetResetReason+0xac>)
    5084:	681b      	ldr	r3, [r3, #0]
    5086:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    5088:	9a02      	ldr	r2, [sp, #8]
    508a:	f642 73ee 	movw	r3, #12270	; 0x2fee
    508e:	4013      	ands	r3, r2
    5090:	2b82      	cmp	r3, #130	; 0x82
    5092:	d102      	bne.n	509a <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    5094:	2305      	movs	r3, #5
    5096:	9307      	str	r3, [sp, #28]
    5098:	e027      	b.n	50ea <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    509a:	2300      	movs	r3, #0
    509c:	9306      	str	r3, [sp, #24]
    509e:	e021      	b.n	50e4 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    50a0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    50a4:	9b06      	ldr	r3, [sp, #24]
    50a6:	fa22 f303 	lsr.w	r3, r2, r3
    50aa:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    50ac:	9a01      	ldr	r2, [sp, #4]
    50ae:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    50b2:	4013      	ands	r3, r2
    50b4:	2b00      	cmp	r3, #0
    50b6:	d012      	beq.n	50de <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    50b8:	9a01      	ldr	r2, [sp, #4]
    50ba:	9b02      	ldr	r3, [sp, #8]
    50bc:	4013      	ands	r3, r2
    50be:	2b00      	cmp	r3, #0
    50c0:	d00a      	beq.n	50d8 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    50c2:	9b05      	ldr	r3, [sp, #20]
    50c4:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    50c6:	9b04      	ldr	r3, [sp, #16]
    50c8:	3301      	adds	r3, #1
    50ca:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    50cc:	9b04      	ldr	r3, [sp, #16]
    50ce:	2b01      	cmp	r3, #1
    50d0:	d902      	bls.n	50d8 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    50d2:	230d      	movs	r3, #13
    50d4:	9307      	str	r3, [sp, #28]
                        break;
    50d6:	e008      	b.n	50ea <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    50d8:	9b05      	ldr	r3, [sp, #20]
    50da:	3301      	adds	r3, #1
    50dc:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    50de:	9b06      	ldr	r3, [sp, #24]
    50e0:	3301      	adds	r3, #1
    50e2:	9306      	str	r3, [sp, #24]
    50e4:	9b06      	ldr	r3, [sp, #24]
    50e6:	2b1f      	cmp	r3, #31
    50e8:	d9da      	bls.n	50a0 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    50ea:	9b07      	ldr	r3, [sp, #28]
}
    50ec:	4618      	mov	r0, r3
    50ee:	b008      	add	sp, #32
    50f0:	4770      	bx	lr
    50f2:	bf00      	nop
    50f4:	4007f000 	.word	0x4007f000
    50f8:	1fff8cf0 	.word	0x1fff8cf0

000050fc <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    50fc:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    50fe:	4b0c      	ldr	r3, [pc, #48]	; (5130 <Power_Ip_RCM_GetResetRawValue+0x34>)
    5100:	699a      	ldr	r2, [r3, #24]
    5102:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5106:	4013      	ands	r3, r2
    5108:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    510a:	9b01      	ldr	r3, [sp, #4]
    510c:	2b00      	cmp	r3, #0
    510e:	d008      	beq.n	5122 <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    5110:	4907      	ldr	r1, [pc, #28]	; (5130 <Power_Ip_RCM_GetResetRawValue+0x34>)
    5112:	9a01      	ldr	r2, [sp, #4]
    5114:	f642 73ee 	movw	r3, #12270	; 0x2fee
    5118:	4013      	ands	r3, r2
    511a:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    511c:	4a05      	ldr	r2, [pc, #20]	; (5134 <Power_Ip_RCM_GetResetRawValue+0x38>)
    511e:	9b01      	ldr	r3, [sp, #4]
    5120:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    5122:	4b04      	ldr	r3, [pc, #16]	; (5134 <Power_Ip_RCM_GetResetRawValue+0x38>)
    5124:	681b      	ldr	r3, [r3, #0]
    5126:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    5128:	9b00      	ldr	r3, [sp, #0]
}
    512a:	4618      	mov	r0, r3
    512c:	b002      	add	sp, #8
    512e:	4770      	bx	lr
    5130:	4007f000 	.word	0x4007f000
    5134:	1fff8cf0 	.word	0x1fff8cf0

00005138 <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    5138:	b082      	sub	sp, #8
    513a:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    513c:	9b01      	ldr	r3, [sp, #4]
    513e:	681b      	ldr	r3, [r3, #0]
    5140:	4a03      	ldr	r2, [pc, #12]	; (5150 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    5142:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    5146:	6093      	str	r3, [r2, #8]
}
    5148:	bf00      	nop
    514a:	b002      	add	sp, #8
    514c:	4770      	bx	lr
    514e:	bf00      	nop
    5150:	4007e000 	.word	0x4007e000

00005154 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    5154:	b084      	sub	sp, #16
    5156:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    5158:	2301      	movs	r3, #1
    515a:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    515c:	4b15      	ldr	r3, [pc, #84]	; (51b4 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    515e:	695b      	ldr	r3, [r3, #20]
    5160:	b2db      	uxtb	r3, r3
    5162:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    5164:	9b01      	ldr	r3, [sp, #4]
    5166:	2b02      	cmp	r3, #2
    5168:	d012      	beq.n	5190 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    516a:	9b01      	ldr	r3, [sp, #4]
    516c:	2b02      	cmp	r3, #2
    516e:	d818      	bhi.n	51a2 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    5170:	9b01      	ldr	r3, [sp, #4]
    5172:	2b00      	cmp	r3, #0
    5174:	d003      	beq.n	517e <Power_Ip_SMC_ModeCheckEntry+0x2a>
    5176:	9b01      	ldr	r3, [sp, #4]
    5178:	2b01      	cmp	r3, #1
    517a:	d003      	beq.n	5184 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    517c:	e011      	b.n	51a2 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    517e:	2300      	movs	r3, #0
    5180:	9303      	str	r3, [sp, #12]
            break;
    5182:	e013      	b.n	51ac <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    5184:	9b02      	ldr	r3, [sp, #8]
    5186:	2b01      	cmp	r3, #1
    5188:	d10d      	bne.n	51a6 <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    518a:	2300      	movs	r3, #0
    518c:	9303      	str	r3, [sp, #12]
            break;
    518e:	e00a      	b.n	51a6 <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    5190:	9b02      	ldr	r3, [sp, #8]
    5192:	2b01      	cmp	r3, #1
    5194:	d002      	beq.n	519c <Power_Ip_SMC_ModeCheckEntry+0x48>
    5196:	9b02      	ldr	r3, [sp, #8]
    5198:	2b10      	cmp	r3, #16
    519a:	d106      	bne.n	51aa <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    519c:	2300      	movs	r3, #0
    519e:	9303      	str	r3, [sp, #12]
            break;
    51a0:	e003      	b.n	51aa <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    51a2:	bf00      	nop
    51a4:	e002      	b.n	51ac <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    51a6:	bf00      	nop
    51a8:	e000      	b.n	51ac <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    51aa:	bf00      	nop
        }
    }

    return PowerModeCheck;
    51ac:	9b03      	ldr	r3, [sp, #12]
}
    51ae:	4618      	mov	r0, r3
    51b0:	b004      	add	sp, #16
    51b2:	4770      	bx	lr
    51b4:	4007e000 	.word	0x4007e000

000051b8 <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    51b8:	b500      	push	{lr}
    51ba:	b08b      	sub	sp, #44	; 0x2c
    51bc:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    51be:	2300      	movs	r3, #0
    51c0:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    51c2:	2300      	movs	r3, #0
    51c4:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    51c6:	2300      	movs	r3, #0
    51c8:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    51cc:	9b01      	ldr	r3, [sp, #4]
    51ce:	685b      	ldr	r3, [r3, #4]
    51d0:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    51d2:	9b08      	ldr	r3, [sp, #32]
    51d4:	2b02      	cmp	r3, #2
    51d6:	d076      	beq.n	52c6 <Power_Ip_SMC_ModeConfig+0x10e>
    51d8:	9b08      	ldr	r3, [sp, #32]
    51da:	2b02      	cmp	r3, #2
    51dc:	f200 80ab 	bhi.w	5336 <Power_Ip_SMC_ModeConfig+0x17e>
    51e0:	9b08      	ldr	r3, [sp, #32]
    51e2:	2b00      	cmp	r3, #0
    51e4:	d003      	beq.n	51ee <Power_Ip_SMC_ModeConfig+0x36>
    51e6:	9b08      	ldr	r3, [sp, #32]
    51e8:	2b01      	cmp	r3, #1
    51ea:	d034      	beq.n	5256 <Power_Ip_SMC_ModeConfig+0x9e>
    51ec:	e0a3      	b.n	5336 <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    51ee:	4b58      	ldr	r3, [pc, #352]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    51f0:	68db      	ldr	r3, [r3, #12]
    51f2:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    51f4:	9b06      	ldr	r3, [sp, #24]
    51f6:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    51fa:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    51fc:	4a54      	ldr	r2, [pc, #336]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    51fe:	9b06      	ldr	r3, [sp, #24]
    5200:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5202:	aa02      	add	r2, sp, #8
    5204:	a903      	add	r1, sp, #12
    5206:	a804      	add	r0, sp, #16
    5208:	f24c 3350 	movw	r3, #50000	; 0xc350
    520c:	f7ff fece 	bl	4fac <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5210:	9a02      	ldr	r2, [sp, #8]
    5212:	a903      	add	r1, sp, #12
    5214:	ab04      	add	r3, sp, #16
    5216:	4618      	mov	r0, r3
    5218:	f7ff fee2 	bl	4fe0 <Power_Ip_TimeoutExpired>
    521c:	4603      	mov	r3, r0
    521e:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    5222:	4b4b      	ldr	r3, [pc, #300]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    5224:	695b      	ldr	r3, [r3, #20]
    5226:	f003 0301 	and.w	r3, r3, #1
    522a:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    522c:	9b05      	ldr	r3, [sp, #20]
    522e:	2b01      	cmp	r3, #1
    5230:	d006      	beq.n	5240 <Power_Ip_SMC_ModeConfig+0x88>
    5232:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5236:	f083 0301 	eor.w	r3, r3, #1
    523a:	b2db      	uxtb	r3, r3
    523c:	2b00      	cmp	r3, #0
    523e:	d1e7      	bne.n	5210 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    5240:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5244:	2b00      	cmp	r3, #0
    5246:	d079      	beq.n	533c <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5248:	2301      	movs	r3, #1
    524a:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    524c:	21ff      	movs	r1, #255	; 0xff
    524e:	2000      	movs	r0, #0
    5250:	f7ff fe90 	bl	4f74 <Power_Ip_ReportPowerErrors>
            }

            break;
    5254:	e072      	b.n	533c <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    5256:	4b3e      	ldr	r3, [pc, #248]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    5258:	68db      	ldr	r3, [r3, #12]
    525a:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    525c:	9b06      	ldr	r3, [sp, #24]
    525e:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    5262:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    5264:	9b06      	ldr	r3, [sp, #24]
    5266:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    526a:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    526c:	4a38      	ldr	r2, [pc, #224]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    526e:	9b06      	ldr	r3, [sp, #24]
    5270:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    5272:	aa02      	add	r2, sp, #8
    5274:	a903      	add	r1, sp, #12
    5276:	a804      	add	r0, sp, #16
    5278:	f24c 3350 	movw	r3, #50000	; 0xc350
    527c:	f7ff fe96 	bl	4fac <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    5280:	9a02      	ldr	r2, [sp, #8]
    5282:	a903      	add	r1, sp, #12
    5284:	ab04      	add	r3, sp, #16
    5286:	4618      	mov	r0, r3
    5288:	f7ff feaa 	bl	4fe0 <Power_Ip_TimeoutExpired>
    528c:	4603      	mov	r3, r0
    528e:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    5292:	4b2f      	ldr	r3, [pc, #188]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    5294:	695b      	ldr	r3, [r3, #20]
    5296:	f003 0380 	and.w	r3, r3, #128	; 0x80
    529a:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    529c:	9b05      	ldr	r3, [sp, #20]
    529e:	2b80      	cmp	r3, #128	; 0x80
    52a0:	d006      	beq.n	52b0 <Power_Ip_SMC_ModeConfig+0xf8>
    52a2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    52a6:	f083 0301 	eor.w	r3, r3, #1
    52aa:	b2db      	uxtb	r3, r3
    52ac:	2b00      	cmp	r3, #0
    52ae:	d1e7      	bne.n	5280 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    52b0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    52b4:	2b00      	cmp	r3, #0
    52b6:	d043      	beq.n	5340 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    52b8:	2301      	movs	r3, #1
    52ba:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    52bc:	21ff      	movs	r1, #255	; 0xff
    52be:	2000      	movs	r0, #0
    52c0:	f7ff fe58 	bl	4f74 <Power_Ip_ReportPowerErrors>
            }

            break;
    52c4:	e03c      	b.n	5340 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    52c6:	4b22      	ldr	r3, [pc, #136]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    52c8:	68db      	ldr	r3, [r3, #12]
    52ca:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    52cc:	9b06      	ldr	r3, [sp, #24]
    52ce:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    52d2:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    52d4:	9b06      	ldr	r3, [sp, #24]
    52d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    52da:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    52dc:	4a1c      	ldr	r2, [pc, #112]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    52de:	9b06      	ldr	r3, [sp, #24]
    52e0:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    52e2:	aa02      	add	r2, sp, #8
    52e4:	a903      	add	r1, sp, #12
    52e6:	a804      	add	r0, sp, #16
    52e8:	f24c 3350 	movw	r3, #50000	; 0xc350
    52ec:	f7ff fe5e 	bl	4fac <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    52f0:	9a02      	ldr	r2, [sp, #8]
    52f2:	a903      	add	r1, sp, #12
    52f4:	ab04      	add	r3, sp, #16
    52f6:	4618      	mov	r0, r3
    52f8:	f7ff fe72 	bl	4fe0 <Power_Ip_TimeoutExpired>
    52fc:	4603      	mov	r3, r0
    52fe:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    5302:	4b13      	ldr	r3, [pc, #76]	; (5350 <Power_Ip_SMC_ModeConfig+0x198>)
    5304:	695b      	ldr	r3, [r3, #20]
    5306:	f003 0304 	and.w	r3, r3, #4
    530a:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    530c:	9b05      	ldr	r3, [sp, #20]
    530e:	2b04      	cmp	r3, #4
    5310:	d006      	beq.n	5320 <Power_Ip_SMC_ModeConfig+0x168>
    5312:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5316:	f083 0301 	eor.w	r3, r3, #1
    531a:	b2db      	uxtb	r3, r3
    531c:	2b00      	cmp	r3, #0
    531e:	d1e7      	bne.n	52f0 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    5320:	f89d 301f 	ldrb.w	r3, [sp, #31]
    5324:	2b00      	cmp	r3, #0
    5326:	d00d      	beq.n	5344 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5328:	2301      	movs	r3, #1
    532a:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    532c:	21ff      	movs	r1, #255	; 0xff
    532e:	2000      	movs	r0, #0
    5330:	f7ff fe20 	bl	4f74 <Power_Ip_ReportPowerErrors>
            }

            break;
    5334:	e006      	b.n	5344 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5336:	2301      	movs	r3, #1
    5338:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    533a:	e004      	b.n	5346 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    533c:	bf00      	nop
    533e:	e002      	b.n	5346 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5340:	bf00      	nop
    5342:	e000      	b.n	5346 <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    5344:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    5346:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5348:	4618      	mov	r0, r3
    534a:	b00b      	add	sp, #44	; 0x2c
    534c:	f85d fb04 	ldr.w	pc, [sp], #4
    5350:	4007e000 	.word	0x4007e000

00005354 <Can_IsControllersBusy>:
        }
    }
#endif /* CAN_43_FLEXCAN_MAINFUNCTION_MULTIPLE_READ == STD_ON */

static boolean Can_IsControllersBusy(uint32 u32CoreId)
{
    5354:	b084      	sub	sp, #16
    5356:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    5358:	2300      	movs	r3, #0
    535a:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    535e:	2300      	movs	r3, #0
    5360:	f88d 300e 	strb.w	r3, [sp, #14]

    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    5364:	2300      	movs	r3, #0
    5366:	f88d 300e 	strb.w	r3, [sp, #14]
    536a:	e01b      	b.n	53a4 <Can_IsControllersBusy+0x50>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    536c:	4a12      	ldr	r2, [pc, #72]	; (53b8 <Can_IsControllersBusy+0x64>)
    536e:	9b01      	ldr	r3, [sp, #4]
    5370:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5374:	695a      	ldr	r2, [r3, #20]
    5376:	f89d 300e 	ldrb.w	r3, [sp, #14]
    537a:	009b      	lsls	r3, r3, #2
    537c:	4413      	add	r3, r2
    537e:	681b      	ldr	r3, [r3, #0]
    5380:	2b00      	cmp	r3, #0
    5382:	d00a      	beq.n	539a <Can_IsControllersBusy+0x46>
        {
            if (CAN_CS_UNINIT != Can_eControllerState[u8ControllerID])
    5384:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5388:	4a0c      	ldr	r2, [pc, #48]	; (53bc <Can_IsControllersBusy+0x68>)
    538a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    538e:	2b00      	cmp	r3, #0
    5390:	d003      	beq.n	539a <Can_IsControllersBusy+0x46>
                *   The function Can_Init shall raise the error CAN_E_TRANSITION if the CAN
                *   controllers are not in state UNINIT.
                */
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_TRANSITION);
            #endif
                bCtrlBusy = TRUE;
    5392:	2301      	movs	r3, #1
    5394:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    5398:	e008      	b.n	53ac <Can_IsControllersBusy+0x58>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    539a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    539e:	3301      	adds	r3, #1
    53a0:	f88d 300e 	strb.w	r3, [sp, #14]
    53a4:	f89d 300e 	ldrb.w	r3, [sp, #14]
    53a8:	2b00      	cmp	r3, #0
    53aa:	d0df      	beq.n	536c <Can_IsControllersBusy+0x18>
            }
        }
    }

    return bCtrlBusy;
    53ac:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    53b0:	4618      	mov	r0, r3
    53b2:	b004      	add	sp, #16
    53b4:	4770      	bx	lr
    53b6:	bf00      	nop
    53b8:	1fff8cfc 	.word	0x1fff8cfc
    53bc:	1fff8cf8 	.word	0x1fff8cf8

000053c0 <Can_InitControllers>:

static void Can_InitControllers(uint32 u32CoreId)
{
    53c0:	b500      	push	{lr}
    53c2:	b085      	sub	sp, #20
    53c4:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    53c6:	2300      	movs	r3, #0
    53c8:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    53cc:	2300      	movs	r3, #0
    53ce:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    53d2:	2300      	movs	r3, #0
    53d4:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    53d6:	2300      	movs	r3, #0
    53d8:	f88d 300e 	strb.w	r3, [sp, #14]
    53dc:	e035      	b.n	544a <Can_InitControllers+0x8a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    53de:	4a30      	ldr	r2, [pc, #192]	; (54a0 <Can_InitControllers+0xe0>)
    53e0:	9b01      	ldr	r3, [sp, #4]
    53e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    53e6:	695a      	ldr	r2, [r3, #20]
    53e8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    53ec:	009b      	lsls	r3, r3, #2
    53ee:	4413      	add	r3, r2
    53f0:	681b      	ldr	r3, [r3, #0]
    53f2:	2b00      	cmp	r3, #0
    53f4:	d024      	beq.n	5440 <Can_InitControllers+0x80>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    53f6:	4a2a      	ldr	r2, [pc, #168]	; (54a0 <Can_InitControllers+0xe0>)
    53f8:	9b01      	ldr	r3, [sp, #4]
    53fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    53fe:	695a      	ldr	r2, [r3, #20]
    5400:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5404:	009b      	lsls	r3, r3, #2
    5406:	4413      	add	r3, r2
    5408:	681b      	ldr	r3, [r3, #0]
    540a:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    540c:	9b02      	ldr	r3, [sp, #8]
    540e:	7a1b      	ldrb	r3, [r3, #8]
    5410:	2b00      	cmp	r3, #0
    5412:	d015      	beq.n	5440 <Can_InitControllers+0x80>
                */
            #if ((CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) || (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON))
                Can_au16BaudrateIDConfig[u8ControllerID] = Can_pController->Can_u16DefaultBaudrateID;
            #endif
                /* Reset interrupt level to default value after re-init */
                Can_au8DisableInterruptLevel[u8ControllerID] = 0U;
    5414:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5418:	4a22      	ldr	r2, [pc, #136]	; (54a4 <Can_InitControllers+0xe4>)
    541a:	2100      	movs	r1, #0
    541c:	54d1      	strb	r1, [r2, r3]
            #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
                Can_apxCtrlConfigIcomIndex[u8ControllerID] = NULL_PTR;
            #endif
                /* Init the controller */
                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_Init(Can_pController))
    541e:	9802      	ldr	r0, [sp, #8]
    5420:	f000 ffd8 	bl	63d4 <Can_43_FLEXCAN_Ipw_Init>
    5424:	4603      	mov	r3, r0
    5426:	2b00      	cmp	r3, #0
    5428:	d106      	bne.n	5438 <Can_InitControllers+0x78>
                {
                    Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    542a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    542e:	4a1e      	ldr	r2, [pc, #120]	; (54a8 <Can_InitControllers+0xe8>)
    5430:	2102      	movs	r1, #2
    5432:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    5436:	e003      	b.n	5440 <Can_InitControllers+0x80>
                else
                {
                    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_INIT_FAILED);
                    #endif
                    bCtrlBusy = TRUE;
    5438:	2301      	movs	r3, #1
    543a:	f88d 300f 	strb.w	r3, [sp, #15]
                    break;
    543e:	e008      	b.n	5452 <Can_InitControllers+0x92>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    5440:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5444:	3301      	adds	r3, #1
    5446:	f88d 300e 	strb.w	r3, [sp, #14]
    544a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    544e:	2b00      	cmp	r3, #0
    5450:	d0c5      	beq.n	53de <Can_InitControllers+0x1e>
    }
    /*
    *  [SWS_Can_00246] After initializing all controllers inside the HW Unit, the function Can_Init
    *   shall change the module state to CAN_READY.
    */
    if (TRUE == bCtrlBusy)
    5452:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5456:	2b00      	cmp	r3, #0
    5458:	d01e      	beq.n	5498 <Can_InitControllers+0xd8>
    {
        /* Init failed due to one or more controllers failed, reset status of all  core's current controllers */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    545a:	2300      	movs	r3, #0
    545c:	f88d 300e 	strb.w	r3, [sp, #14]
    5460:	e016      	b.n	5490 <Can_InitControllers+0xd0>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    5462:	4a0f      	ldr	r2, [pc, #60]	; (54a0 <Can_InitControllers+0xe0>)
    5464:	9b01      	ldr	r3, [sp, #4]
    5466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    546a:	695a      	ldr	r2, [r3, #20]
    546c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5470:	009b      	lsls	r3, r3, #2
    5472:	4413      	add	r3, r2
    5474:	681b      	ldr	r3, [r3, #0]
    5476:	2b00      	cmp	r3, #0
    5478:	d005      	beq.n	5486 <Can_InitControllers+0xc6>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    547a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    547e:	4a0a      	ldr	r2, [pc, #40]	; (54a8 <Can_InitControllers+0xe8>)
    5480:	2100      	movs	r1, #0
    5482:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    5486:	f89d 300e 	ldrb.w	r3, [sp, #14]
    548a:	3301      	adds	r3, #1
    548c:	f88d 300e 	strb.w	r3, [sp, #14]
    5490:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5494:	2b00      	cmp	r3, #0
    5496:	d0e4      	beq.n	5462 <Can_InitControllers+0xa2>
    else
    {
        Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_READY;
    }
#endif
}
    5498:	bf00      	nop
    549a:	b005      	add	sp, #20
    549c:	f85d fb04 	ldr.w	pc, [sp], #4
    54a0:	1fff8cfc 	.word	0x1fff8cfc
    54a4:	1fff8cf4 	.word	0x1fff8cf4
    54a8:	1fff8cf8 	.word	0x1fff8cf8

000054ac <Can_DeInitControllers>:
    return bResult;
}
#endif

static void Can_DeInitControllers(uint32 u32CoreId)
{
    54ac:	b500      	push	{lr}
    54ae:	b085      	sub	sp, #20
    54b0:	9001      	str	r0, [sp, #4]
    uint8 u8ControllerID = 0U;
    54b2:	2300      	movs	r3, #0
    54b4:	f88d 300f 	strb.w	r3, [sp, #15]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    54b8:	2300      	movs	r3, #0
    54ba:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    54bc:	2300      	movs	r3, #0
    54be:	f88d 300f 	strb.w	r3, [sp, #15]
    54c2:	e028      	b.n	5516 <Can_DeInitControllers+0x6a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    54c4:	4a18      	ldr	r2, [pc, #96]	; (5528 <Can_DeInitControllers+0x7c>)
    54c6:	9b01      	ldr	r3, [sp, #4]
    54c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    54cc:	695a      	ldr	r2, [r3, #20]
    54ce:	f89d 300f 	ldrb.w	r3, [sp, #15]
    54d2:	009b      	lsls	r3, r3, #2
    54d4:	4413      	add	r3, r2
    54d6:	681b      	ldr	r3, [r3, #0]
    54d8:	2b00      	cmp	r3, #0
    54da:	d017      	beq.n	550c <Can_DeInitControllers+0x60>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    54dc:	4a12      	ldr	r2, [pc, #72]	; (5528 <Can_DeInitControllers+0x7c>)
    54de:	9b01      	ldr	r3, [sp, #4]
    54e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    54e4:	695a      	ldr	r2, [r3, #20]
    54e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    54ea:	009b      	lsls	r3, r3, #2
    54ec:	4413      	add	r3, r2
    54ee:	681b      	ldr	r3, [r3, #0]
    54f0:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    54f2:	9b02      	ldr	r3, [sp, #8]
    54f4:	7a1b      	ldrb	r3, [r3, #8]
    54f6:	2b00      	cmp	r3, #0
    54f8:	d008      	beq.n	550c <Can_DeInitControllers+0x60>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    54fa:	f89d 300f 	ldrb.w	r3, [sp, #15]
    54fe:	4a0b      	ldr	r2, [pc, #44]	; (552c <Can_DeInitControllers+0x80>)
    5500:	2100      	movs	r1, #0
    5502:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                Can_43_FLEXCAN_Ipw_DeInit(Can_pController);
    5506:	9802      	ldr	r0, [sp, #8]
    5508:	f000 ffce 	bl	64a8 <Can_43_FLEXCAN_Ipw_DeInit>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    550c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5510:	3301      	adds	r3, #1
    5512:	f88d 300f 	strb.w	r3, [sp, #15]
    5516:	f89d 300f 	ldrb.w	r3, [sp, #15]
    551a:	2b00      	cmp	r3, #0
    551c:	d0d2      	beq.n	54c4 <Can_DeInitControllers+0x18>
            }
        }
    }
}
    551e:	bf00      	nop
    5520:	bf00      	nop
    5522:	b005      	add	sp, #20
    5524:	f85d fb04 	ldr.w	pc, [sp], #4
    5528:	1fff8cfc 	.word	0x1fff8cfc
    552c:	1fff8cf8 	.word	0x1fff8cf8

00005530 <Can_43_FLEXCAN_Init>:
* @api
*/

/* implements     Can_Init_Activity */
void Can_43_FLEXCAN_Init(const Can_43_FLEXCAN_ConfigType * Config)
{
    5530:	b500      	push	{lr}
    5532:	b085      	sub	sp, #20
    5534:	9001      	str	r0, [sp, #4]
    uint32 u32CoreId = 0U;
    5536:	2300      	movs	r3, #0
    5538:	9303      	str	r3, [sp, #12]
    boolean bCtrlBusy = FALSE;
    553a:	2300      	movs	r3, #0
    553c:	f88d 300b 	strb.w	r3, [sp, #11]
#if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
    boolean bValidCoreID = FALSE;
#endif

    u32CoreId = Can_GetCoreID();
    5540:	2300      	movs	r3, #0
    5542:	9303      	str	r3, [sp, #12]
        #if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
            if (u32CoreId == Config->Can_u32CoreID)
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Copy pointer to current Can Driver configuration. */
                Can_apxConfig[u32CoreId] = Config;
    5544:	490c      	ldr	r1, [pc, #48]	; (5578 <Can_43_FLEXCAN_Init+0x48>)
    5546:	9b03      	ldr	r3, [sp, #12]
    5548:	9a01      	ldr	r2, [sp, #4]
    554a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            if (TRUE == bValidCoreID)
            {
#endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Fault Injection point to allow to test SWS_Can_00408 */
                MCAL_FAULT_INJECTION_POINT(CAN_FIP_1_CHANGE_DRIVER_TO_UNINITIALIZED);
                bCtrlBusy = Can_IsControllersBusy(u32CoreId);
    554e:	9803      	ldr	r0, [sp, #12]
    5550:	f7ff ff00 	bl	5354 <Can_IsControllersBusy>
    5554:	4603      	mov	r3, r0
    5556:	f88d 300b 	strb.w	r3, [sp, #11]
                if (FALSE == bCtrlBusy)
    555a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    555e:	f083 0301 	eor.w	r3, r3, #1
    5562:	b2db      	uxtb	r3, r3
    5564:	2b00      	cmp	r3, #0
    5566:	d002      	beq.n	556e <Can_43_FLEXCAN_Init+0x3e>
                {
                    Can_InitControllers(u32CoreId);
    5568:	9803      	ldr	r0, [sp, #12]
    556a:	f7ff ff29 	bl	53c0 <Can_InitControllers>

#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif /* (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) */
}
    556e:	bf00      	nop
    5570:	b005      	add	sp, #20
    5572:	f85d fb04 	ldr.w	pc, [sp], #4
    5576:	bf00      	nop
    5578:	1fff8cfc 	.word	0x1fff8cfc

0000557c <Can_43_FLEXCAN_DeInit>:
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
*/
/* implements     Can_DeInit_Activity */
void Can_43_FLEXCAN_DeInit(void)
{
    557c:	b500      	push	{lr}
    557e:	b083      	sub	sp, #12
    /* Variable for indexing the controllers. */
    uint8 u8ControllerID = 0U;
    5580:	2300      	movs	r3, #0
    5582:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean bCtrlBusy = FALSE;
    5586:	2300      	movs	r3, #0
    5588:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 u32CoreId = 0U;
    558c:	2300      	movs	r3, #0
    558e:	9300      	str	r3, [sp, #0]

    u32CoreId = Can_GetCoreID();
    5590:	2300      	movs	r3, #0
    5592:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    5594:	2300      	movs	r3, #0
    5596:	f88d 3007 	strb.w	r3, [sp, #7]
    559a:	e01b      	b.n	55d4 <Can_43_FLEXCAN_DeInit+0x58>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    559c:	4a19      	ldr	r2, [pc, #100]	; (5604 <Can_43_FLEXCAN_DeInit+0x88>)
    559e:	9b00      	ldr	r3, [sp, #0]
    55a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    55a4:	695a      	ldr	r2, [r3, #20]
    55a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    55aa:	009b      	lsls	r3, r3, #2
    55ac:	4413      	add	r3, r2
    55ae:	681b      	ldr	r3, [r3, #0]
    55b0:	2b00      	cmp	r3, #0
    55b2:	d00a      	beq.n	55ca <Can_43_FLEXCAN_DeInit+0x4e>
            {
                if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    55b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    55b8:	4a13      	ldr	r2, [pc, #76]	; (5608 <Can_43_FLEXCAN_DeInit+0x8c>)
    55ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    55be:	2b01      	cmp	r3, #1
    55c0:	d103      	bne.n	55ca <Can_43_FLEXCAN_DeInit+0x4e>
                    *   if any of the CAN controllers is in state STARTED.
                    */
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_DEINIT, (uint8)CAN_43_FLEXCAN_E_TRANSITION);
                #endif
                    /* Controller is busy */
                    bCtrlBusy =  TRUE;
    55c2:	2301      	movs	r3, #1
    55c4:	f88d 3006 	strb.w	r3, [sp, #6]
                    /* Skipping the loop if any of Can Controller is in state STARTED */
                    break;
    55c8:	e008      	b.n	55dc <Can_43_FLEXCAN_DeInit+0x60>
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    55ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
    55ce:	3301      	adds	r3, #1
    55d0:	f88d 3007 	strb.w	r3, [sp, #7]
    55d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    55d8:	2b00      	cmp	r3, #0
    55da:	d0df      	beq.n	559c <Can_43_FLEXCAN_DeInit+0x20>
                }
            }
        }
        /* All Controllers are not busy */
        if (FALSE == bCtrlBusy)
    55dc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    55e0:	f083 0301 	eor.w	r3, r3, #1
    55e4:	b2db      	uxtb	r3, r3
    55e6:	2b00      	cmp	r3, #0
    55e8:	d007      	beq.n	55fa <Can_43_FLEXCAN_DeInit+0x7e>
            *   [SWS_Can_91010] The function Can_DeInit shall change the module state to
            *   CAN_UNINIT before de-initializing all controllers inside the HW unit
            */
            Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_UNINIT;
        #endif
            Can_DeInitControllers(u32CoreId);
    55ea:	9800      	ldr	r0, [sp, #0]
    55ec:	f7ff ff5e 	bl	54ac <Can_DeInitControllers>
            Can_apxConfig[u32CoreId] = NULL_PTR;
    55f0:	4a04      	ldr	r2, [pc, #16]	; (5604 <Can_43_FLEXCAN_DeInit+0x88>)
    55f2:	9b00      	ldr	r3, [sp, #0]
    55f4:	2100      	movs	r1, #0
    55f6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
}
    55fa:	bf00      	nop
    55fc:	b003      	add	sp, #12
    55fe:	f85d fb04 	ldr.w	pc, [sp], #4
    5602:	bf00      	nop
    5604:	1fff8cfc 	.word	0x1fff8cfc
    5608:	1fff8cf8 	.word	0x1fff8cf8

0000560c <Can_43_FLEXCAN_SetControllerMode>:
*
* @api
*/
/* implements     Can_SetControllerMode_Activity */
Std_ReturnType Can_43_FLEXCAN_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    560c:	b500      	push	{lr}
    560e:	b087      	sub	sp, #28
    5610:	4603      	mov	r3, r0
    5612:	9100      	str	r1, [sp, #0]
    5614:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    5618:	2301      	movs	r3, #1
    561a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    561e:	2300      	movs	r3, #0
    5620:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5622:	2300      	movs	r3, #0
    5624:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    5626:	2300      	movs	r3, #0
    5628:	9304      	str	r3, [sp, #16]
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    if (TRUE == Can_ValidateController(u32CoreId, Controller, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE))
    {
#endif
                Can_pController = (const Can_43_FLEXCAN_ControllerConfigType *)(Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    562a:	4a47      	ldr	r2, [pc, #284]	; (5748 <Can_43_FLEXCAN_SetControllerMode+0x13c>)
    562c:	9b04      	ldr	r3, [sp, #16]
    562e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5632:	695a      	ldr	r2, [r3, #20]
    5634:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5638:	009b      	lsls	r3, r3, #2
    563a:	4413      	add	r3, r2
    563c:	681b      	ldr	r3, [r3, #0]
    563e:	9303      	str	r3, [sp, #12]
                /*
                *   [SWS_Can_00017] The function Can_SetControllerMode shall perform software
                *   triggered state transitions of the CAN controller State machine.
                */
                switch (Transition)
    5640:	9b00      	ldr	r3, [sp, #0]
    5642:	2b03      	cmp	r3, #3
    5644:	d05d      	beq.n	5702 <Can_43_FLEXCAN_SetControllerMode+0xf6>
    5646:	9b00      	ldr	r3, [sp, #0]
    5648:	2b03      	cmp	r3, #3
    564a:	d874      	bhi.n	5736 <Can_43_FLEXCAN_SetControllerMode+0x12a>
    564c:	9b00      	ldr	r3, [sp, #0]
    564e:	2b01      	cmp	r3, #1
    5650:	d003      	beq.n	565a <Can_43_FLEXCAN_SetControllerMode+0x4e>
    5652:	9b00      	ldr	r3, [sp, #0]
    5654:	2b02      	cmp	r3, #2
    5656:	d01d      	beq.n	5694 <Can_43_FLEXCAN_SetControllerMode+0x88>
                        *   has been requested, the function Can_SetControllerMode shall raise the error CAN_E_TRANSITION and
                        *   return E_NOT_OK
                        */
                        (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_TRANSITION);
                    #endif
                        break;
    5658:	e06d      	b.n	5736 <Can_43_FLEXCAN_SetControllerMode+0x12a>
                        if (CAN_CS_STOPPED == Can_eControllerState[Controller])
    565a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    565e:	4a3b      	ldr	r2, [pc, #236]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    5660:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5664:	2b02      	cmp	r3, #2
    5666:	d168      	bne.n	573a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStartMode(Can_pController))
    5668:	9803      	ldr	r0, [sp, #12]
    566a:	f000 ff49 	bl	6500 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>
    566e:	4603      	mov	r3, r0
    5670:	2b00      	cmp	r3, #0
    5672:	d162      	bne.n	573a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                                Can_eControllerState[Controller] = CAN_CS_STARTED;
    5674:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5678:	4a34      	ldr	r2, [pc, #208]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    567a:	2101      	movs	r1, #1
    567c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STARTED);
    5680:	9b03      	ldr	r3, [sp, #12]
    5682:	781b      	ldrb	r3, [r3, #0]
    5684:	2101      	movs	r1, #1
    5686:	4618      	mov	r0, r3
    5688:	f7fb f93f 	bl	90a <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    568c:	2300      	movs	r3, #0
    568e:	f88d 3017 	strb.w	r3, [sp, #23]
                        break;
    5692:	e052      	b.n	573a <Can_43_FLEXCAN_SetControllerMode+0x12e>
                        switch (Can_eControllerState[Controller])
    5694:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5698:	4a2c      	ldr	r2, [pc, #176]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    569a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    569e:	2b01      	cmp	r3, #1
    56a0:	d005      	beq.n	56ae <Can_43_FLEXCAN_SetControllerMode+0xa2>
    56a2:	2b00      	cmp	r3, #0
    56a4:	d029      	beq.n	56fa <Can_43_FLEXCAN_SetControllerMode+0xee>
    56a6:	3b02      	subs	r3, #2
    56a8:	2b01      	cmp	r3, #1
    56aa:	d826      	bhi.n	56fa <Can_43_FLEXCAN_SetControllerMode+0xee>
    56ac:	e015      	b.n	56da <Can_43_FLEXCAN_SetControllerMode+0xce>
                                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    56ae:	9803      	ldr	r0, [sp, #12]
    56b0:	f000 ff54 	bl	655c <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    56b4:	4603      	mov	r3, r0
    56b6:	2b00      	cmp	r3, #0
    56b8:	d121      	bne.n	56fe <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                    Can_eControllerState[Controller] = CAN_CS_STOPPED;
    56ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    56be:	4a23      	ldr	r2, [pc, #140]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    56c0:	2102      	movs	r1, #2
    56c2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                    CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    56c6:	9b03      	ldr	r3, [sp, #12]
    56c8:	781b      	ldrb	r3, [r3, #0]
    56ca:	2102      	movs	r1, #2
    56cc:	4618      	mov	r0, r3
    56ce:	f7fb f91c 	bl	90a <CanIf_ControllerModeIndication>
                                    eRetVal = E_OK;
    56d2:	2300      	movs	r3, #0
    56d4:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    56d8:	e011      	b.n	56fe <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                Can_eControllerState[Controller] = CAN_CS_STOPPED;
    56da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    56de:	4a1b      	ldr	r2, [pc, #108]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    56e0:	2102      	movs	r1, #2
    56e2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    56e6:	9b03      	ldr	r3, [sp, #12]
    56e8:	781b      	ldrb	r3, [r3, #0]
    56ea:	2102      	movs	r1, #2
    56ec:	4618      	mov	r0, r3
    56ee:	f7fb f90c 	bl	90a <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    56f2:	2300      	movs	r3, #0
    56f4:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    56f8:	e002      	b.n	5700 <Can_43_FLEXCAN_SetControllerMode+0xf4>
                                break;
    56fa:	bf00      	nop
    56fc:	e01e      	b.n	573c <Can_43_FLEXCAN_SetControllerMode+0x130>
                                break;
    56fe:	bf00      	nop
                        break;
    5700:	e01c      	b.n	573c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        switch (Can_eControllerState[Controller])
    5702:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5706:	4a11      	ldr	r2, [pc, #68]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    5708:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    570c:	3b02      	subs	r3, #2
    570e:	2b01      	cmp	r3, #1
    5710:	d80f      	bhi.n	5732 <Can_43_FLEXCAN_SetControllerMode+0x126>
                                Can_eControllerState[Controller] = CAN_CS_SLEEP;
    5712:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5716:	4a0d      	ldr	r2, [pc, #52]	; (574c <Can_43_FLEXCAN_SetControllerMode+0x140>)
    5718:	2103      	movs	r1, #3
    571a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_SLEEP);
    571e:	9b03      	ldr	r3, [sp, #12]
    5720:	781b      	ldrb	r3, [r3, #0]
    5722:	2103      	movs	r1, #3
    5724:	4618      	mov	r0, r3
    5726:	f7fb f8f0 	bl	90a <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    572a:	2300      	movs	r3, #0
    572c:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    5730:	e000      	b.n	5734 <Can_43_FLEXCAN_SetControllerMode+0x128>
                                break;
    5732:	bf00      	nop
                        break;
    5734:	e002      	b.n	573c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    5736:	bf00      	nop
    5738:	e000      	b.n	573c <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    573a:	bf00      	nop
                    }
                }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eRetVal;
    573c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5740:	4618      	mov	r0, r3
    5742:	b007      	add	sp, #28
    5744:	f85d fb04 	ldr.w	pc, [sp], #4
    5748:	1fff8cfc 	.word	0x1fff8cfc
    574c:	1fff8cf8 	.word	0x1fff8cf8

00005750 <Can_43_FLEXCAN_DisableControllerInterrupts>:
*
* @api
*/
/* implements     Can_DisableControllerInterrupts_Activity */
void Can_43_FLEXCAN_DisableControllerInterrupts(uint8 Controller)
{
    5750:	b500      	push	{lr}
    5752:	b085      	sub	sp, #20
    5754:	4603      	mov	r3, r0
    5756:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    575a:	2300      	movs	r3, #0
    575c:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    575e:	2300      	movs	r3, #0
    5760:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    5762:	2300      	movs	r3, #0
    5764:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    5766:	4a10      	ldr	r2, [pc, #64]	; (57a8 <Can_43_FLEXCAN_DisableControllerInterrupts+0x58>)
    5768:	9b03      	ldr	r3, [sp, #12]
    576a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    576e:	695a      	ldr	r2, [r3, #20]
    5770:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5774:	009b      	lsls	r3, r3, #2
    5776:	4413      	add	r3, r2
    5778:	681b      	ldr	r3, [r3, #0]
    577a:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    577c:	f005 fb42 	bl	ae04 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_au8DisableInterruptLevel[Controller] += 1U;
    5780:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5784:	4a09      	ldr	r2, [pc, #36]	; (57ac <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    5786:	5cd2      	ldrb	r2, [r2, r3]
    5788:	f89d 3007 	ldrb.w	r3, [sp, #7]
    578c:	3201      	adds	r2, #1
    578e:	b2d1      	uxtb	r1, r2
    5790:	4a06      	ldr	r2, [pc, #24]	; (57ac <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    5792:	54d1      	strb	r1, [r2, r3]
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    5794:	f005 fb62 	bl	ae5c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(Can_pController);
    5798:	9802      	ldr	r0, [sp, #8]
    579a:	f000 ff4f 	bl	663c <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    579e:	bf00      	nop
    57a0:	b005      	add	sp, #20
    57a2:	f85d fb04 	ldr.w	pc, [sp], #4
    57a6:	bf00      	nop
    57a8:	1fff8cfc 	.word	0x1fff8cfc
    57ac:	1fff8cf4 	.word	0x1fff8cf4

000057b0 <Can_43_FLEXCAN_EnableControllerInterrupts>:
*
* @api
*/
/* implements     Can_EnableControllerInterrupts_Activity */
void Can_43_FLEXCAN_EnableControllerInterrupts(uint8 Controller)
{
    57b0:	b500      	push	{lr}
    57b2:	b085      	sub	sp, #20
    57b4:	4603      	mov	r3, r0
    57b6:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    57ba:	2300      	movs	r3, #0
    57bc:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    57be:	2300      	movs	r3, #0
    57c0:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    57c2:	2300      	movs	r3, #0
    57c4:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    57c6:	4a16      	ldr	r2, [pc, #88]	; (5820 <Can_43_FLEXCAN_EnableControllerInterrupts+0x70>)
    57c8:	9b03      	ldr	r3, [sp, #12]
    57ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    57ce:	695a      	ldr	r2, [r3, #20]
    57d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    57d4:	009b      	lsls	r3, r3, #2
    57d6:	4413      	add	r3, r2
    57d8:	681b      	ldr	r3, [r3, #0]
    57da:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    57dc:	f005 fb64 	bl	aea8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>
                if (Can_au8DisableInterruptLevel[Controller] > 0U)
    57e0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    57e4:	4a0f      	ldr	r2, [pc, #60]	; (5824 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    57e6:	5cd3      	ldrb	r3, [r2, r3]
    57e8:	2b00      	cmp	r3, #0
    57ea:	d009      	beq.n	5800 <Can_43_FLEXCAN_EnableControllerInterrupts+0x50>
                {
                    Can_au8DisableInterruptLevel[Controller] -= 1U;
    57ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
    57f0:	4a0c      	ldr	r2, [pc, #48]	; (5824 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    57f2:	5cd2      	ldrb	r2, [r2, r3]
    57f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    57f8:	3a01      	subs	r2, #1
    57fa:	b2d1      	uxtb	r1, r2
    57fc:	4a09      	ldr	r2, [pc, #36]	; (5824 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    57fe:	54d1      	strb	r1, [r2, r3]
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    5800:	f005 fb7e 	bl	af00 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>

                if (0U == Can_au8DisableInterruptLevel[Controller])
    5804:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5808:	4a06      	ldr	r2, [pc, #24]	; (5824 <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    580a:	5cd3      	ldrb	r3, [r2, r3]
    580c:	2b00      	cmp	r3, #0
    580e:	d102      	bne.n	5816 <Can_43_FLEXCAN_EnableControllerInterrupts+0x66>
                {
                    Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(Can_pController);
    5810:	9802      	ldr	r0, [sp, #8]
    5812:	f000 ff2f 	bl	6674 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    5816:	bf00      	nop
    5818:	b005      	add	sp, #20
    581a:	f85d fb04 	ldr.w	pc, [sp], #4
    581e:	bf00      	nop
    5820:	1fff8cfc 	.word	0x1fff8cfc
    5824:	1fff8cf4 	.word	0x1fff8cf4

00005828 <Can_43_FLEXCAN_GetControllerErrorState>:
Std_ReturnType Can_43_FLEXCAN_GetControllerErrorState
(
    uint8 ControllerId,
    Can_ErrorStateType * ErrorStatePtr
)
{
    5828:	b500      	push	{lr}
    582a:	b087      	sub	sp, #28
    582c:	4603      	mov	r3, r0
    582e:	9100      	str	r1, [sp, #0]
    5830:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    5834:	2301      	movs	r3, #1
    5836:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 errorState = 0U;
    583a:	2300      	movs	r3, #0
    583c:	f88d 300b 	strb.w	r3, [sp, #11]
    uint32 u32CoreId = 0U;
    5840:	2300      	movs	r3, #0
    5842:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5844:	2300      	movs	r3, #0
    5846:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    5848:	2300      	movs	r3, #0
    584a:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_ERROR_STATE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    584c:	4a18      	ldr	r2, [pc, #96]	; (58b0 <Can_43_FLEXCAN_GetControllerErrorState+0x88>)
    584e:	9b04      	ldr	r3, [sp, #16]
    5850:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5854:	695a      	ldr	r2, [r3, #20]
    5856:	f89d 3007 	ldrb.w	r3, [sp, #7]
    585a:	009b      	lsls	r3, r3, #2
    585c:	4413      	add	r3, r2
    585e:	681b      	ldr	r3, [r3, #0]
    5860:	9303      	str	r3, [sp, #12]
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerErrorState(Can_pController, &errorState);
    5862:	f10d 030b 	add.w	r3, sp, #11
    5866:	4619      	mov	r1, r3
    5868:	9803      	ldr	r0, [sp, #12]
    586a:	f000 ff21 	bl	66b0 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>
    586e:	4603      	mov	r3, r0
    5870:	f88d 3017 	strb.w	r3, [sp, #23]
                    if(eRetVal == (Std_ReturnType)E_OK)
    5874:	f89d 3017 	ldrb.w	r3, [sp, #23]
    5878:	2b00      	cmp	r3, #0
    587a:	d112      	bne.n	58a2 <Can_43_FLEXCAN_GetControllerErrorState+0x7a>
                    {
                        switch (errorState)
    587c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5880:	2b00      	cmp	r3, #0
    5882:	d002      	beq.n	588a <Can_43_FLEXCAN_GetControllerErrorState+0x62>
    5884:	2b01      	cmp	r3, #1
    5886:	d004      	beq.n	5892 <Can_43_FLEXCAN_GetControllerErrorState+0x6a>
    5888:	e007      	b.n	589a <Can_43_FLEXCAN_GetControllerErrorState+0x72>
                        {
                            case 0x00U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
    588a:	9b00      	ldr	r3, [sp, #0]
    588c:	2200      	movs	r2, #0
    588e:	601a      	str	r2, [r3, #0]
                                break;
    5890:	e008      	b.n	58a4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            case 0x01U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
    5892:	9b00      	ldr	r3, [sp, #0]
    5894:	2201      	movs	r2, #1
    5896:	601a      	str	r2, [r3, #0]
                                break;
    5898:	e004      	b.n	58a4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            default:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
    589a:	9b00      	ldr	r3, [sp, #0]
    589c:	2202      	movs	r2, #2
    589e:	601a      	str	r2, [r3, #0]
                                break;
    58a0:	e000      	b.n	58a4 <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                        }
                    }
    58a2:	bf00      	nop
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                }
    }
#endif
    return eRetVal;
    58a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    58a8:	4618      	mov	r0, r3
    58aa:	b007      	add	sp, #28
    58ac:	f85d fb04 	ldr.w	pc, [sp], #4
    58b0:	1fff8cfc 	.word	0x1fff8cfc

000058b4 <Can_43_FLEXCAN_GetControllerMode>:
Std_ReturnType Can_43_FLEXCAN_GetControllerMode
(
    uint8 Controller,
    Can_ControllerStateType * ControllerModePtr
)
{
    58b4:	b084      	sub	sp, #16
    58b6:	4603      	mov	r3, r0
    58b8:	9100      	str	r1, [sp, #0]
    58ba:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    58be:	2301      	movs	r3, #1
    58c0:	f88d 300f 	strb.w	r3, [sp, #15]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    *ControllerModePtr = Can_eControllerState[Controller];
    58c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    58c8:	4a06      	ldr	r2, [pc, #24]	; (58e4 <Can_43_FLEXCAN_GetControllerMode+0x30>)
    58ca:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    58ce:	9b00      	ldr	r3, [sp, #0]
    58d0:	601a      	str	r2, [r3, #0]
                    eRetVal = E_OK;
    58d2:	2300      	movs	r3, #0
    58d4:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    58d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    58dc:	4618      	mov	r0, r3
    58de:	b004      	add	sp, #16
    58e0:	4770      	bx	lr
    58e2:	bf00      	nop
    58e4:	1fff8cf8 	.word	0x1fff8cf8

000058e8 <Can_43_FLEXCAN_GetControllerRxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerRxErrorCounter
(
    uint8 ControllerId,
    uint8 * RxErrorCounterPtr
)
{
    58e8:	b500      	push	{lr}
    58ea:	b087      	sub	sp, #28
    58ec:	4603      	mov	r3, r0
    58ee:	9100      	str	r1, [sp, #0]
    58f0:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    58f4:	2301      	movs	r3, #1
    58f6:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    58fa:	2300      	movs	r3, #0
    58fc:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    58fe:	2300      	movs	r3, #0
    5900:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    5902:	2300      	movs	r3, #0
    5904:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_RX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    5906:	4a0c      	ldr	r2, [pc, #48]	; (5938 <Can_43_FLEXCAN_GetControllerRxErrorCounter+0x50>)
    5908:	9b04      	ldr	r3, [sp, #16]
    590a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    590e:	695a      	ldr	r2, [r3, #20]
    5910:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5914:	009b      	lsls	r3, r3, #2
    5916:	4413      	add	r3, r2
    5918:	681b      	ldr	r3, [r3, #0]
    591a:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Rx error counter
                    *   register of Can Controller and shall return the Rx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(Can_pController, RxErrorCounterPtr);
    591c:	9900      	ldr	r1, [sp, #0]
    591e:	9803      	ldr	r0, [sp, #12]
    5920:	f000 fef1 	bl	6706 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>
    5924:	4603      	mov	r3, r0
    5926:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    592a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    592e:	4618      	mov	r0, r3
    5930:	b007      	add	sp, #28
    5932:	f85d fb04 	ldr.w	pc, [sp], #4
    5936:	bf00      	nop
    5938:	1fff8cfc 	.word	0x1fff8cfc

0000593c <Can_43_FLEXCAN_GetControllerTxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerTxErrorCounter
(
    uint8 ControllerId,
    uint8 * TxErrorCounterPtr
)
{
    593c:	b500      	push	{lr}
    593e:	b087      	sub	sp, #28
    5940:	4603      	mov	r3, r0
    5942:	9100      	str	r1, [sp, #0]
    5944:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    5948:	2301      	movs	r3, #1
    594a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    594e:	2300      	movs	r3, #0
    5950:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5952:	2300      	movs	r3, #0
    5954:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    5956:	2300      	movs	r3, #0
    5958:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_TX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    595a:	4a0c      	ldr	r2, [pc, #48]	; (598c <Can_43_FLEXCAN_GetControllerTxErrorCounter+0x50>)
    595c:	9b04      	ldr	r3, [sp, #16]
    595e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5962:	695a      	ldr	r2, [r3, #20]
    5964:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5968:	009b      	lsls	r3, r3, #2
    596a:	4413      	add	r3, r2
    596c:	681b      	ldr	r3, [r3, #0]
    596e:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Tx error counter
                    *   register of Can Controller and shall return the Tx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(Can_pController, TxErrorCounterPtr);
    5970:	9900      	ldr	r1, [sp, #0]
    5972:	9803      	ldr	r0, [sp, #12]
    5974:	f000 feb5 	bl	66e2 <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>
    5978:	4603      	mov	r3, r0
    597a:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    597e:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5982:	4618      	mov	r0, r3
    5984:	b007      	add	sp, #28
    5986:	f85d fb04 	ldr.w	pc, [sp], #4
    598a:	bf00      	nop
    598c:	1fff8cfc 	.word	0x1fff8cfc

00005990 <Can_43_FLEXCAN_Write>:
Std_ReturnType Can_43_FLEXCAN_Write
(
    Can_HwHandleType Hth,
    const Can_PduType * PduInfo
)
{
    5990:	b500      	push	{lr}
    5992:	b089      	sub	sp, #36	; 0x24
    5994:	4603      	mov	r3, r0
    5996:	9100      	str	r1, [sp, #0]
    5998:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType eRetVal = E_NOT_OK;
    599c:	2301      	movs	r3, #1
    599e:	f88d 301f 	strb.w	r3, [sp, #31]
    uint8 u8ControllerID = 0U;
    59a2:	2300      	movs	r3, #0
    59a4:	f88d 301e 	strb.w	r3, [sp, #30]
    uint32 u32CoreId = 0U;
    59a8:	2300      	movs	r3, #0
    59aa:	9306      	str	r3, [sp, #24]
    Can_HwHandleType HwObjectID = 0U;
    59ac:	2300      	movs	r3, #0
    59ae:	f8ad 3016 	strh.w	r3, [sp, #22]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    59b2:	2300      	movs	r3, #0
    59b4:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    59b6:	2300      	movs	r3, #0
    59b8:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    59ba:	2300      	movs	r3, #0
    59bc:	9306      	str	r3, [sp, #24]
    HwObjectID = Hth;
    59be:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59c2:	f8ad 3016 	strh.w	r3, [sp, #22]
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_WRITE, CAN_43_FLEXCAN_E_PARAM_POINTER);
            }
            else
            {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    59c6:	4a1d      	ldr	r2, [pc, #116]	; (5a3c <Can_43_FLEXCAN_Write+0xac>)
    59c8:	9b06      	ldr	r3, [sp, #24]
    59ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59ce:	68da      	ldr	r2, [r3, #12]
    59d0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    59d4:	4413      	add	r3, r2
    59d6:	781b      	ldrb	r3, [r3, #0]
    59d8:	f88d 301e 	strb.w	r3, [sp, #30]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    59dc:	4a17      	ldr	r2, [pc, #92]	; (5a3c <Can_43_FLEXCAN_Write+0xac>)
    59de:	9b06      	ldr	r3, [sp, #24]
    59e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59e4:	695a      	ldr	r2, [r3, #20]
    59e6:	f89d 301e 	ldrb.w	r3, [sp, #30]
    59ea:	009b      	lsls	r3, r3, #2
    59ec:	4413      	add	r3, r2
    59ee:	681b      	ldr	r3, [r3, #0]
    59f0:	9304      	str	r3, [sp, #16]
                if (NULL_PTR != Can_pController)
    59f2:	9b04      	ldr	r3, [sp, #16]
    59f4:	2b00      	cmp	r3, #0
    59f6:	d01b      	beq.n	5a30 <Can_43_FLEXCAN_Write+0xa0>
                {
                    Can_pHwObject = &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]);
    59f8:	4a10      	ldr	r2, [pc, #64]	; (5a3c <Can_43_FLEXCAN_Write+0xac>)
    59fa:	9b06      	ldr	r3, [sp, #24]
    59fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a00:	6919      	ldr	r1, [r3, #16]
    5a02:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    5a06:	4613      	mov	r3, r2
    5a08:	00db      	lsls	r3, r3, #3
    5a0a:	4413      	add	r3, r2
    5a0c:	009b      	lsls	r3, r3, #2
    5a0e:	440b      	add	r3, r1
    5a10:	9303      	str	r3, [sp, #12]
                #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    if ((TRUE == Can_ValidatePdu(Can_pController, Can_pHwObject, PduInfo)) && (CAN_CS_STARTED == Can_eControllerState[u8ControllerID]))
                #else
                    /* avoid unexpected behaviour when accessing to RAM */
                    if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    5a12:	f89d 301e 	ldrb.w	r3, [sp, #30]
    5a16:	4a0a      	ldr	r2, [pc, #40]	; (5a40 <Can_43_FLEXCAN_Write+0xb0>)
    5a18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a1c:	2b01      	cmp	r3, #1
    5a1e:	d107      	bne.n	5a30 <Can_43_FLEXCAN_Write+0xa0>
                            eRetVal = CAN_BUSY;
                        }
                        else
                        {
                    #endif
                            eRetVal = Can_43_FLEXCAN_Ipw_Write(Can_pController, Can_pHwObject, PduInfo);
    5a20:	9a00      	ldr	r2, [sp, #0]
    5a22:	9903      	ldr	r1, [sp, #12]
    5a24:	9804      	ldr	r0, [sp, #16]
    5a26:	f000 fe80 	bl	672a <Can_43_FLEXCAN_Ipw_Write>
    5a2a:	4603      	mov	r3, r0
    5a2c:	f88d 301f 	strb.w	r3, [sp, #31]
                }
            #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
            }
    }
#endif
    return eRetVal;
    5a30:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    5a34:	4618      	mov	r0, r3
    5a36:	b009      	add	sp, #36	; 0x24
    5a38:	f85d fb04 	ldr.w	pc, [sp], #4
    5a3c:	1fff8cfc 	.word	0x1fff8cfc
    5a40:	1fff8cf8 	.word	0x1fff8cf8

00005a44 <Can_43_FLEXCAN_MainFunction_Write>:
    *
    * @api
    */
    /* implements     Can_MainFunction_Write_Activity */
    void Can_43_FLEXCAN_MainFunction_Write(void)
    {
    5a44:	b500      	push	{lr}
    5a46:	b085      	sub	sp, #20
    #if (CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON)
        Can_HwHandleType HwObjectID = 0U;
    5a48:	2300      	movs	r3, #0
    5a4a:	f8ad 300e 	strh.w	r3, [sp, #14]
        uint8 u8ControllerID = 0U;
    5a4e:	2300      	movs	r3, #0
    5a50:	f88d 300d 	strb.w	r3, [sp, #13]
        uint32 u32CoreId = 0U;
    5a54:	2300      	movs	r3, #0
    5a56:	9302      	str	r3, [sp, #8]
        const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5a58:	2300      	movs	r3, #0
    5a5a:	9301      	str	r3, [sp, #4]

        u32CoreId = Can_GetCoreID();
    5a5c:	2300      	movs	r3, #0
    5a5e:	9302      	str	r3, [sp, #8]
        if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    5a60:	4a2b      	ldr	r2, [pc, #172]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5a62:	9b02      	ldr	r3, [sp, #8]
    5a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a68:	2b00      	cmp	r3, #0
    5a6a:	d04c      	beq.n	5b06 <Can_43_FLEXCAN_MainFunction_Write+0xc2>
        {
            HwObjectID = (Can_apxConfig[u32CoreId])->Can_uHthFirstIndex;
    5a6c:	4a28      	ldr	r2, [pc, #160]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5a6e:	9b02      	ldr	r3, [sp, #8]
    5a70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a74:	889b      	ldrh	r3, [r3, #4]
    5a76:	f8ad 300e 	strh.w	r3, [sp, #14]
            while (HwObjectID < CAN_43_FLEXCAN_HWOBJECT_CONFIG_COUNT)
    5a7a:	e040      	b.n	5afe <Can_43_FLEXCAN_MainFunction_Write+0xba>
            {
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    5a7c:	4a24      	ldr	r2, [pc, #144]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5a7e:	9b02      	ldr	r3, [sp, #8]
    5a80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a84:	68da      	ldr	r2, [r3, #12]
    5a86:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5a8a:	4413      	add	r3, r2
    5a8c:	781b      	ldrb	r3, [r3, #0]
    5a8e:	f88d 300d 	strb.w	r3, [sp, #13]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    5a92:	4a1f      	ldr	r2, [pc, #124]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5a94:	9b02      	ldr	r3, [sp, #8]
    5a96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a9a:	695a      	ldr	r2, [r3, #20]
    5a9c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    5aa0:	009b      	lsls	r3, r3, #2
    5aa2:	4413      	add	r3, r2
    5aa4:	681b      	ldr	r3, [r3, #0]
    5aa6:	9301      	str	r3, [sp, #4]
                if (NULL_PTR != Can_pController)
    5aa8:	9b01      	ldr	r3, [sp, #4]
    5aaa:	2b00      	cmp	r3, #0
    5aac:	d022      	beq.n	5af4 <Can_43_FLEXCAN_MainFunction_Write+0xb0>
                {
                    /* Check if the HwObject is config for polling */
                    if ((TRUE == Can_pController->Can_bActivation) && (TRUE == (Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID].Can_bHwObjectUsesPolling))
    5aae:	9b01      	ldr	r3, [sp, #4]
    5ab0:	7a1b      	ldrb	r3, [r3, #8]
    5ab2:	2b00      	cmp	r3, #0
    5ab4:	d01e      	beq.n	5af4 <Can_43_FLEXCAN_MainFunction_Write+0xb0>
    5ab6:	4a16      	ldr	r2, [pc, #88]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5ab8:	9b02      	ldr	r3, [sp, #8]
    5aba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5abe:	6919      	ldr	r1, [r3, #16]
    5ac0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5ac4:	4613      	mov	r3, r2
    5ac6:	00db      	lsls	r3, r3, #3
    5ac8:	4413      	add	r3, r2
    5aca:	009b      	lsls	r3, r3, #2
    5acc:	440b      	add	r3, r1
    5ace:	7b1b      	ldrb	r3, [r3, #12]
    5ad0:	2b00      	cmp	r3, #0
    5ad2:	d00f      	beq.n	5af4 <Can_43_FLEXCAN_MainFunction_Write+0xb0>
                    {
                        Can_43_FLEXCAN_Ipw_MainFunction_Write(Can_pController, &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]));
    5ad4:	4a0e      	ldr	r2, [pc, #56]	; (5b10 <Can_43_FLEXCAN_MainFunction_Write+0xcc>)
    5ad6:	9b02      	ldr	r3, [sp, #8]
    5ad8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5adc:	6919      	ldr	r1, [r3, #16]
    5ade:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5ae2:	4613      	mov	r3, r2
    5ae4:	00db      	lsls	r3, r3, #3
    5ae6:	4413      	add	r3, r2
    5ae8:	009b      	lsls	r3, r3, #2
    5aea:	440b      	add	r3, r1
    5aec:	4619      	mov	r1, r3
    5aee:	9801      	ldr	r0, [sp, #4]
    5af0:	f000 ff1b 	bl	692a <Can_43_FLEXCAN_Ipw_MainFunction_Write>
                    }
                }
                HwObjectID++;
    5af4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5af8:	3301      	adds	r3, #1
    5afa:	f8ad 300e 	strh.w	r3, [sp, #14]
            while (HwObjectID < CAN_43_FLEXCAN_HWOBJECT_CONFIG_COUNT)
    5afe:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b02:	2b01      	cmp	r3, #1
    5b04:	d9ba      	bls.n	5a7c <Can_43_FLEXCAN_MainFunction_Write+0x38>
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON */
    }
    5b06:	bf00      	nop
    5b08:	b005      	add	sp, #20
    5b0a:	f85d fb04 	ldr.w	pc, [sp], #4
    5b0e:	bf00      	nop
    5b10:	1fff8cfc 	.word	0x1fff8cfc

00005b14 <Can_43_FLEXCAN_MainFunction_Read>:
    *
    * @api
    */
    /* implements     Can_MainFunction_Read_Activity */
    void Can_43_FLEXCAN_MainFunction_Read(void)
    {
    5b14:	b500      	push	{lr}
    5b16:	b085      	sub	sp, #20
    #if (CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON)
        Can_HwHandleType HwObjectID = 0U;
    5b18:	2300      	movs	r3, #0
    5b1a:	f8ad 300e 	strh.w	r3, [sp, #14]
        uint8 u8ControllerID = 0U;
    5b1e:	2300      	movs	r3, #0
    5b20:	f88d 300d 	strb.w	r3, [sp, #13]
        uint32 u32CoreId = 0U;
    5b24:	2300      	movs	r3, #0
    5b26:	9302      	str	r3, [sp, #8]
        const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5b28:	2300      	movs	r3, #0
    5b2a:	9301      	str	r3, [sp, #4]

        u32CoreId = Can_GetCoreID();
    5b2c:	2300      	movs	r3, #0
    5b2e:	9302      	str	r3, [sp, #8]
        if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    5b30:	4a2a      	ldr	r2, [pc, #168]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5b32:	9b02      	ldr	r3, [sp, #8]
    5b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b38:	2b00      	cmp	r3, #0
    5b3a:	d04a      	beq.n	5bd2 <Can_43_FLEXCAN_MainFunction_Read+0xbe>
        {
            while (HwObjectID < (Can_apxConfig[u32CoreId])->Can_uHthFirstIndex)
    5b3c:	e040      	b.n	5bc0 <Can_43_FLEXCAN_MainFunction_Read+0xac>
            {
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    5b3e:	4a27      	ldr	r2, [pc, #156]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5b40:	9b02      	ldr	r3, [sp, #8]
    5b42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b46:	68da      	ldr	r2, [r3, #12]
    5b48:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5b4c:	4413      	add	r3, r2
    5b4e:	781b      	ldrb	r3, [r3, #0]
    5b50:	f88d 300d 	strb.w	r3, [sp, #13]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    5b54:	4a21      	ldr	r2, [pc, #132]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5b56:	9b02      	ldr	r3, [sp, #8]
    5b58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b5c:	695a      	ldr	r2, [r3, #20]
    5b5e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    5b62:	009b      	lsls	r3, r3, #2
    5b64:	4413      	add	r3, r2
    5b66:	681b      	ldr	r3, [r3, #0]
    5b68:	9301      	str	r3, [sp, #4]
                if (NULL_PTR != Can_pController)
    5b6a:	9b01      	ldr	r3, [sp, #4]
    5b6c:	2b00      	cmp	r3, #0
    5b6e:	d022      	beq.n	5bb6 <Can_43_FLEXCAN_MainFunction_Read+0xa2>
                {
                    /* Check if the HwObject is config for polling */
                    if ((TRUE == Can_pController->Can_bActivation) && (TRUE == (Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID].Can_bHwObjectUsesPolling))
    5b70:	9b01      	ldr	r3, [sp, #4]
    5b72:	7a1b      	ldrb	r3, [r3, #8]
    5b74:	2b00      	cmp	r3, #0
    5b76:	d01e      	beq.n	5bb6 <Can_43_FLEXCAN_MainFunction_Read+0xa2>
    5b78:	4a18      	ldr	r2, [pc, #96]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5b7a:	9b02      	ldr	r3, [sp, #8]
    5b7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b80:	6919      	ldr	r1, [r3, #16]
    5b82:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5b86:	4613      	mov	r3, r2
    5b88:	00db      	lsls	r3, r3, #3
    5b8a:	4413      	add	r3, r2
    5b8c:	009b      	lsls	r3, r3, #2
    5b8e:	440b      	add	r3, r1
    5b90:	7b1b      	ldrb	r3, [r3, #12]
    5b92:	2b00      	cmp	r3, #0
    5b94:	d00f      	beq.n	5bb6 <Can_43_FLEXCAN_MainFunction_Read+0xa2>
                    {
                        Can_43_FLEXCAN_Ipw_MainFunction_Read(Can_pController, &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]));
    5b96:	4a11      	ldr	r2, [pc, #68]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5b98:	9b02      	ldr	r3, [sp, #8]
    5b9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b9e:	6919      	ldr	r1, [r3, #16]
    5ba0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5ba4:	4613      	mov	r3, r2
    5ba6:	00db      	lsls	r3, r3, #3
    5ba8:	4413      	add	r3, r2
    5baa:	009b      	lsls	r3, r3, #2
    5bac:	440b      	add	r3, r1
    5bae:	4619      	mov	r1, r3
    5bb0:	9801      	ldr	r0, [sp, #4]
    5bb2:	f000 ff0d 	bl	69d0 <Can_43_FLEXCAN_Ipw_MainFunction_Read>
                    }
                }
                HwObjectID++;
    5bb6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5bba:	3301      	adds	r3, #1
    5bbc:	f8ad 300e 	strh.w	r3, [sp, #14]
            while (HwObjectID < (Can_apxConfig[u32CoreId])->Can_uHthFirstIndex)
    5bc0:	4a06      	ldr	r2, [pc, #24]	; (5bdc <Can_43_FLEXCAN_MainFunction_Read+0xc8>)
    5bc2:	9b02      	ldr	r3, [sp, #8]
    5bc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5bc8:	889b      	ldrh	r3, [r3, #4]
    5bca:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5bce:	429a      	cmp	r2, r3
    5bd0:	d3b5      	bcc.n	5b3e <Can_43_FLEXCAN_MainFunction_Read+0x2a>
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON */
    }
    5bd2:	bf00      	nop
    5bd4:	b005      	add	sp, #20
    5bd6:	f85d fb04 	ldr.w	pc, [sp], #4
    5bda:	bf00      	nop
    5bdc:	1fff8cfc 	.word	0x1fff8cfc

00005be0 <Can_43_FLEXCAN_MainFunction_BusOff>:
*
* @api
*/
/* implements     Can_MainFunction_BusOff_Activity */
void Can_43_FLEXCAN_MainFunction_BusOff(void)
{
    5be0:	b500      	push	{lr}
    5be2:	b085      	sub	sp, #20
#if (CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON)
    uint8 u8ControllerID = 0U;
    5be4:	2300      	movs	r3, #0
    5be6:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32CoreId = 0U;
    5bea:	2300      	movs	r3, #0
    5bec:	9302      	str	r3, [sp, #8]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5bee:	2300      	movs	r3, #0
    5bf0:	9301      	str	r3, [sp, #4]

    u32CoreId = Can_GetCoreID();
    5bf2:	2300      	movs	r3, #0
    5bf4:	9302      	str	r3, [sp, #8]
    if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    5bf6:	4a16      	ldr	r2, [pc, #88]	; (5c50 <Can_43_FLEXCAN_MainFunction_BusOff+0x70>)
    5bf8:	9b02      	ldr	r3, [sp, #8]
    5bfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5bfe:	2b00      	cmp	r3, #0
    5c00:	d022      	beq.n	5c48 <Can_43_FLEXCAN_MainFunction_BusOff+0x68>
    {
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    5c02:	e01d      	b.n	5c40 <Can_43_FLEXCAN_MainFunction_BusOff+0x60>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    5c04:	4a12      	ldr	r2, [pc, #72]	; (5c50 <Can_43_FLEXCAN_MainFunction_BusOff+0x70>)
    5c06:	9b02      	ldr	r3, [sp, #8]
    5c08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c0c:	695a      	ldr	r2, [r3, #20]
    5c0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5c12:	009b      	lsls	r3, r3, #2
    5c14:	4413      	add	r3, r2
    5c16:	681b      	ldr	r3, [r3, #0]
    5c18:	9301      	str	r3, [sp, #4]
            if (NULL_PTR != Can_pController)
    5c1a:	9b01      	ldr	r3, [sp, #4]
    5c1c:	2b00      	cmp	r3, #0
    5c1e:	d00a      	beq.n	5c36 <Can_43_FLEXCAN_MainFunction_BusOff+0x56>
            {
                if ((TRUE == Can_pController->Can_bActivation) && (TRUE == (Can_pController->Can_bBusOffUsesPolling)))
    5c20:	9b01      	ldr	r3, [sp, #4]
    5c22:	7a1b      	ldrb	r3, [r3, #8]
    5c24:	2b00      	cmp	r3, #0
    5c26:	d006      	beq.n	5c36 <Can_43_FLEXCAN_MainFunction_BusOff+0x56>
    5c28:	9b01      	ldr	r3, [sp, #4]
    5c2a:	7a5b      	ldrb	r3, [r3, #9]
    5c2c:	2b00      	cmp	r3, #0
    5c2e:	d002      	beq.n	5c36 <Can_43_FLEXCAN_MainFunction_BusOff+0x56>
                {
                    Can_43_FLEXCAN_Ipw_MainFunction_BusOff(Can_pController);
    5c30:	9801      	ldr	r0, [sp, #4]
    5c32:	f000 ff1c 	bl	6a6e <Can_43_FLEXCAN_Ipw_MainFunction_BusOff>
                }
            }
            u8ControllerID++;
    5c36:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5c3a:	3301      	adds	r3, #1
    5c3c:	f88d 300f 	strb.w	r3, [sp, #15]
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    5c40:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5c44:	2b00      	cmp	r3, #0
    5c46:	d0dd      	beq.n	5c04 <Can_43_FLEXCAN_MainFunction_BusOff+0x24>
        }
    }
#endif /* CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON */
}
    5c48:	bf00      	nop
    5c4a:	b005      	add	sp, #20
    5c4c:	f85d fb04 	ldr.w	pc, [sp], #4
    5c50:	1fff8cfc 	.word	0x1fff8cfc

00005c54 <Can_43_FLEXCAN_MainFunction_Mode>:
*
* @api
*/
/* implements     Can_MainFunction_Mode_Activity */
void Can_43_FLEXCAN_MainFunction_Mode(void)
{
    5c54:	b500      	push	{lr}
    5c56:	b085      	sub	sp, #20
    uint8 u8ControllerID = 0U;
    5c58:	2300      	movs	r3, #0
    5c5a:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32CoreId = 0U;
    5c5e:	2300      	movs	r3, #0
    5c60:	9302      	str	r3, [sp, #8]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5c62:	2300      	movs	r3, #0
    5c64:	9301      	str	r3, [sp, #4]

    u32CoreId = Can_GetCoreID();
    5c66:	2300      	movs	r3, #0
    5c68:	9302      	str	r3, [sp, #8]
    if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    5c6a:	4a17      	ldr	r2, [pc, #92]	; (5cc8 <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    5c6c:	9b02      	ldr	r3, [sp, #8]
    5c6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c72:	2b00      	cmp	r3, #0
    5c74:	d024      	beq.n	5cc0 <Can_43_FLEXCAN_MainFunction_Mode+0x6c>
    {
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    5c76:	e01f      	b.n	5cb8 <Can_43_FLEXCAN_MainFunction_Mode+0x64>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    5c78:	4a13      	ldr	r2, [pc, #76]	; (5cc8 <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    5c7a:	9b02      	ldr	r3, [sp, #8]
    5c7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c80:	695a      	ldr	r2, [r3, #20]
    5c82:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5c86:	009b      	lsls	r3, r3, #2
    5c88:	4413      	add	r3, r2
    5c8a:	681b      	ldr	r3, [r3, #0]
    5c8c:	9301      	str	r3, [sp, #4]
            if (NULL_PTR != Can_pController)
    5c8e:	9b01      	ldr	r3, [sp, #4]
    5c90:	2b00      	cmp	r3, #0
    5c92:	d00c      	beq.n	5cae <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
            {
                if (TRUE == Can_pController->Can_bActivation)
    5c94:	9b01      	ldr	r3, [sp, #4]
    5c96:	7a1b      	ldrb	r3, [r3, #8]
    5c98:	2b00      	cmp	r3, #0
    5c9a:	d008      	beq.n	5cae <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
                {
                    Can_43_FLEXCAN_Ipw_MainFunction_Mode(Can_pController, &Can_eControllerState[u8ControllerID]);
    5c9c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5ca0:	009b      	lsls	r3, r3, #2
    5ca2:	4a0a      	ldr	r2, [pc, #40]	; (5ccc <Can_43_FLEXCAN_MainFunction_Mode+0x78>)
    5ca4:	4413      	add	r3, r2
    5ca6:	4619      	mov	r1, r3
    5ca8:	9801      	ldr	r0, [sp, #4]
    5caa:	f000 feec 	bl	6a86 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>
                }
            }
            u8ControllerID++;
    5cae:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5cb2:	3301      	adds	r3, #1
    5cb4:	f88d 300f 	strb.w	r3, [sp, #15]
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    5cb8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5cbc:	2b00      	cmp	r3, #0
    5cbe:	d0db      	beq.n	5c78 <Can_43_FLEXCAN_MainFunction_Mode+0x24>
        }
    }
}
    5cc0:	bf00      	nop
    5cc2:	b005      	add	sp, #20
    5cc4:	f85d fb04 	ldr.w	pc, [sp], #4
    5cc8:	1fff8cfc 	.word	0x1fff8cfc
    5ccc:	1fff8cf8 	.word	0x1fff8cf8

00005cd0 <Can_43_FLEXCAN_ProcessBusOffInterrupt>:
*/
void Can_43_FLEXCAN_ProcessBusOffInterrupt
(
    uint8 u8CtrlOffset
)
{
    5cd0:	b500      	push	{lr}
    5cd2:	b087      	sub	sp, #28
    5cd4:	4603      	mov	r3, r0
    5cd6:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 u8ControllerID = 0U;
    5cda:	2300      	movs	r3, #0
    5cdc:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    5ce0:	2300      	movs	r3, #0
    5ce2:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    5ce4:	2300      	movs	r3, #0
    5ce6:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    5ce8:	2300      	movs	r3, #0
    5cea:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    5cec:	4a19      	ldr	r2, [pc, #100]	; (5d54 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    5cee:	9b04      	ldr	r3, [sp, #16]
    5cf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5cf4:	2b00      	cmp	r3, #0
    5cf6:	d029      	beq.n	5d4c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    5cf8:	4a16      	ldr	r2, [pc, #88]	; (5d54 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    5cfa:	9b04      	ldr	r3, [sp, #16]
    5cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d00:	689a      	ldr	r2, [r3, #8]
    5d02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5d06:	4413      	add	r3, r2
    5d08:	781b      	ldrb	r3, [r3, #0]
    5d0a:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    5d0e:	4a11      	ldr	r2, [pc, #68]	; (5d54 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    5d10:	9b04      	ldr	r3, [sp, #16]
    5d12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d16:	695a      	ldr	r2, [r3, #20]
    5d18:	f89d 3017 	ldrb.w	r3, [sp, #23]
    5d1c:	009b      	lsls	r3, r3, #2
    5d1e:	4413      	add	r3, r2
    5d20:	681b      	ldr	r3, [r3, #0]
    5d22:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    5d24:	9b03      	ldr	r3, [sp, #12]
    5d26:	2b00      	cmp	r3, #0
    5d28:	d010      	beq.n	5d4c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
        {
            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    5d2a:	9803      	ldr	r0, [sp, #12]
    5d2c:	f000 fc16 	bl	655c <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    5d30:	4603      	mov	r3, r0
    5d32:	2b00      	cmp	r3, #0
    5d34:	d10a      	bne.n	5d4c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    5d36:	f89d 3017 	ldrb.w	r3, [sp, #23]
    5d3a:	4a07      	ldr	r2, [pc, #28]	; (5d58 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x88>)
    5d3c:	2102      	movs	r1, #2
    5d3e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                CanIf_ControllerBusOff(Can_pController->Can_u8AbstControllerID);
    5d42:	9b03      	ldr	r3, [sp, #12]
    5d44:	781b      	ldrb	r3, [r3, #0]
    5d46:	4618      	mov	r0, r3
    5d48:	f7fa fdd8 	bl	8fc <CanIf_ControllerBusOff>
            }
        }
    }
}
    5d4c:	bf00      	nop
    5d4e:	b007      	add	sp, #28
    5d50:	f85d fb04 	ldr.w	pc, [sp], #4
    5d54:	1fff8cfc 	.word	0x1fff8cfc
    5d58:	1fff8cf8 	.word	0x1fff8cf8

00005d5c <Can_Ipw_ParseData>:
    PduInfoType * CanIf_PduInfo,
    Flexcan_Ip_MsgBuffType * pReceivedDataBuffer,
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
)
{
    5d5c:	b500      	push	{lr}
    5d5e:	b085      	sub	sp, #20
    5d60:	9003      	str	r0, [sp, #12]
    5d62:	9102      	str	r1, [sp, #8]
    5d64:	9201      	str	r2, [sp, #4]
    5d66:	9300      	str	r3, [sp, #0]
    CanIf_Mailbox->CanId = pReceivedDataBuffer->msgId;
    5d68:	9b01      	ldr	r3, [sp, #4]
    5d6a:	685a      	ldr	r2, [r3, #4]
    5d6c:	9b03      	ldr	r3, [sp, #12]
    5d6e:	601a      	str	r2, [r3, #0]
    * convert the ID to a standardized format since the Upper layer (CANIF) does not know
    * whether the received CAN frame is a Standard CAN frame or Extended CAN frame.
    * In case of an Extended CAN frame, MSB of a received CAN frame ID needs to be
    * made as ‘1’ to mark the received CAN frame as Extended.⌋
    */
    if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_IDE_MASK) != 0U)
    5d70:	9b01      	ldr	r3, [sp, #4]
    5d72:	681b      	ldr	r3, [r3, #0]
    5d74:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    5d78:	2b00      	cmp	r3, #0
    5d7a:	d005      	beq.n	5d88 <Can_Ipw_ParseData+0x2c>
    {
        CanIf_Mailbox->CanId |= (uint32)0x80000000U;
    5d7c:	9b03      	ldr	r3, [sp, #12]
    5d7e:	681b      	ldr	r3, [r3, #0]
    5d80:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    5d84:	9b03      	ldr	r3, [sp, #12]
    5d86:	601a      	str	r2, [r3, #0]
    }

    if (CAN_RX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    5d88:	9b06      	ldr	r3, [sp, #24]
    5d8a:	699b      	ldr	r3, [r3, #24]
    5d8c:	2b00      	cmp	r3, #0
    5d8e:	d10c      	bne.n	5daa <Can_Ipw_ParseData+0x4e>
    {
        /* Check if Mb Overrun */
        if ((uint32)(0x06000000U) == (pReceivedDataBuffer->cs & CAN_IPW_CS_CODE_MASK))
    5d90:	9b01      	ldr	r3, [sp, #4]
    5d92:	681b      	ldr	r3, [r3, #0]
    5d94:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    5d98:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
    5d9c:	d105      	bne.n	5daa <Can_Ipw_ParseData+0x4e>
        {
            (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    5d9e:	2301      	movs	r3, #1
    5da0:	2208      	movs	r2, #8
    5da2:	2100      	movs	r1, #0
    5da4:	2050      	movs	r0, #80	; 0x50
    5da6:	f006 f819 	bl	bddc <Det_ReportRuntimeError>
        }
    }

    /* when legacy fifo enabled, FD must be disabled */
    if (CAN_RX_LEGACY_FIFO != Can_pHwObjectConfig->Can_eReceiveType)
    5daa:	9b06      	ldr	r3, [sp, #24]
    5dac:	699b      	ldr	r3, [r3, #24]
    5dae:	2b01      	cmp	r3, #1
    5db0:	d009      	beq.n	5dc6 <Can_Ipw_ParseData+0x6a>
    {
        /*
        * [SWS_Can_00501] ⌈ CanDrv shall indicate whether the received message is a
        * conventional CAN frame or a CAN FD frame as described in Can_IdType.⌋
        */
        if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_EDL_MASK) != 0U)
    5db2:	9b01      	ldr	r3, [sp, #4]
    5db4:	681b      	ldr	r3, [r3, #0]
    5db6:	2b00      	cmp	r3, #0
    5db8:	da05      	bge.n	5dc6 <Can_Ipw_ParseData+0x6a>
        {
            CanIf_Mailbox->CanId |= (uint32)0x40000000U;
    5dba:	9b03      	ldr	r3, [sp, #12]
    5dbc:	681b      	ldr	r3, [r3, #0]
    5dbe:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    5dc2:	9b03      	ldr	r3, [sp, #12]
    5dc4:	601a      	str	r2, [r3, #0]
        }
    }

    if (Can_pHwObjectConfig->Can_u8PayloadLength <= pReceivedDataBuffer->dataLen)
    5dc6:	9b06      	ldr	r3, [sp, #24]
    5dc8:	7c1a      	ldrb	r2, [r3, #16]
    5dca:	9b01      	ldr	r3, [sp, #4]
    5dcc:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    5dd0:	429a      	cmp	r2, r3
    5dd2:	d805      	bhi.n	5de0 <Can_Ipw_ParseData+0x84>
    {
        CanIf_PduInfo->SduLength = Can_pHwObjectConfig->Can_u8PayloadLength;
    5dd4:	9b06      	ldr	r3, [sp, #24]
    5dd6:	7c1b      	ldrb	r3, [r3, #16]
    5dd8:	461a      	mov	r2, r3
    5dda:	9b02      	ldr	r3, [sp, #8]
    5ddc:	609a      	str	r2, [r3, #8]
    5dde:	e005      	b.n	5dec <Can_Ipw_ParseData+0x90>
    }
    else
    {
        CanIf_PduInfo->SduLength = pReceivedDataBuffer->dataLen;
    5de0:	9b01      	ldr	r3, [sp, #4]
    5de2:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    5de6:	461a      	mov	r2, r3
    5de8:	9b02      	ldr	r3, [sp, #8]
    5dea:	609a      	str	r2, [r3, #8]
                                                      CanIf_PduInfo->SduLength, \
                                                      &pReceivedDataBuffer->data[0]) \
                                                     )
    {
#endif
    CanIf_Mailbox->Hoh = Can_pHwObjectConfig->Can_HwObjectID;
    5dec:	9b06      	ldr	r3, [sp, #24]
    5dee:	881a      	ldrh	r2, [r3, #0]
    5df0:	9b03      	ldr	r3, [sp, #12]
    5df2:	809a      	strh	r2, [r3, #4]
    CanIf_Mailbox->ControllerId = Can_pControllerConfig->Can_u8AbstControllerID;
    5df4:	9b00      	ldr	r3, [sp, #0]
    5df6:	781a      	ldrb	r2, [r3, #0]
    5df8:	9b03      	ldr	r3, [sp, #12]
    5dfa:	719a      	strb	r2, [r3, #6]
    CanIf_PduInfo->SduDataPtr = &pReceivedDataBuffer->data[0];
    5dfc:	9b01      	ldr	r3, [sp, #4]
    5dfe:	f103 0208 	add.w	r2, r3, #8
    5e02:	9b02      	ldr	r3, [sp, #8]
    5e04:	601a      	str	r2, [r3, #0]
    CanIf_RxIndication(CanIf_Mailbox, CanIf_PduInfo);
    5e06:	9902      	ldr	r1, [sp, #8]
    5e08:	9803      	ldr	r0, [sp, #12]
    5e0a:	f7fa fd93 	bl	934 <CanIf_RxIndication>
#if (CAN_43_FLEXCAN_LPDU_CALLOUT_SUPPORT == STD_ON)
    }
#endif
}
    5e0e:	bf00      	nop
    5e10:	b005      	add	sp, #20
    5e12:	f85d fb04 	ldr.w	pc, [sp], #4

00005e16 <Can_Ipw_InitLegacyFifoFilter>:

static void Can_Ipw_InitLegacyFifoFilter(const Can_43_FLEXCAN_ControllerConfigType * Can_pController, const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject)
{
    5e16:	b500      	push	{lr}
    5e18:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
    5e1c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e20:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    5e24:	6018      	str	r0, [r3, #0]
    5e26:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e2a:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5e2e:	6019      	str	r1, [r3, #0]
    uint8 u8FilterIdx=0U;
    5e30:	2300      	movs	r3, #0
    5e32:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    uint8 u8HwFilterCount = 0U;
    5e36:	2300      	movs	r3, #0
    5e38:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
    uint32 u32HwFilterMask = (uint32)0x00000000U;
    5e3c:	2300      	movs	r3, #0
    5e3e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    /* The max FIFO id filter affected by Rx individual masks*/
    uint8 u8FiFoFilterIndvCount = 0U;
    5e42:	2300      	movs	r3, #0
    5e44:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    Flexcan_Ip_RxFifoIdElementFormatType eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    5e48:	2300      	movs	r3, #0
    5e4a:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
    /* Need to alocate a filter array with elemnets no as defined in HwObject */
    Flexcan_Ip_IdTableType RxFifoFilters[128];

    if (((Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U) <= 32U)
    5e4e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e52:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5e56:	681b      	ldr	r3, [r3, #0]
    5e58:	7c9b      	ldrb	r3, [r3, #18]
    5e5a:	089b      	lsrs	r3, r3, #2
    5e5c:	b2db      	uxtb	r3, r3
    5e5e:	3306      	adds	r3, #6
    5e60:	2b20      	cmp	r3, #32
    5e62:	d80b      	bhi.n	5e7c <Can_Ipw_InitLegacyFifoFilter+0x66>
    {
        u8FiFoFilterIndvCount = (Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U;
    5e64:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e68:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5e6c:	681b      	ldr	r3, [r3, #0]
    5e6e:	7c9b      	ldrb	r3, [r3, #18]
    5e70:	089b      	lsrs	r3, r3, #2
    5e72:	b2db      	uxtb	r3, r3
    5e74:	3306      	adds	r3, #6
    5e76:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    5e7a:	e002      	b.n	5e82 <Can_Ipw_InitLegacyFifoFilter+0x6c>
    }
    else
    {
        u8FiFoFilterIndvCount = 32U;
    5e7c:	2320      	movs	r3, #32
    5e7e:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    }
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    5e82:	2300      	movs	r3, #0
    5e84:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    5e88:	e169      	b.n	615e <Can_Ipw_InitLegacyFifoFilter+0x348>
    {
            if (CAN_LEGACY_FIFO_FORMAT_A == Can_pController->Can_eLegacyAcceptanceMode)
    5e8a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e8e:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    5e92:	681b      	ldr	r3, [r3, #0]
    5e94:	691b      	ldr	r3, [r3, #16]
    5e96:	2b00      	cmp	r3, #0
    5e98:	d13a      	bne.n	5f10 <Can_Ipw_InitLegacyFifoFilter+0xfa>
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount;
    5e9a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5e9e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5ea2:	681b      	ldr	r3, [r3, #0]
    5ea4:	7c9b      	ldrb	r3, [r3, #18]
    5ea6:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC0000000U;
    5eaa:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    5eae:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    5eb2:	2300      	movs	r3, #0
    5eb4:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    5eb8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5ebc:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5ec0:	681b      	ldr	r3, [r3, #0]
    5ec2:	689b      	ldr	r3, [r3, #8]
    5ec4:	2b00      	cmp	r3, #0
    5ec6:	d011      	beq.n	5eec <Can_Ipw_InitLegacyFifoFilter+0xd6>
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_EXT_SHIFT;
    5ec8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5ecc:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5ed0:	681b      	ldr	r3, [r3, #0]
    5ed2:	695a      	ldr	r2, [r3, #20]
    5ed4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5ed8:	00db      	lsls	r3, r3, #3
    5eda:	4413      	add	r3, r2
    5edc:	685b      	ldr	r3, [r3, #4]
    5ede:	005b      	lsls	r3, r3, #1
    5ee0:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5ee4:	4313      	orrs	r3, r2
    5ee6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    5eea:	e126      	b.n	613a <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_STD_SHIFT;
    5eec:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5ef0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5ef4:	681b      	ldr	r3, [r3, #0]
    5ef6:	695a      	ldr	r2, [r3, #20]
    5ef8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5efc:	00db      	lsls	r3, r3, #3
    5efe:	4413      	add	r3, r2
    5f00:	685b      	ldr	r3, [r3, #4]
    5f02:	04db      	lsls	r3, r3, #19
    5f04:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5f08:	4313      	orrs	r3, r2
    5f0a:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    5f0e:	e114      	b.n	613a <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else if (CAN_LEGACY_FIFO_FORMAT_B == Can_pController->Can_eLegacyAcceptanceMode)
    5f10:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f14:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    5f18:	681b      	ldr	r3, [r3, #0]
    5f1a:	691b      	ldr	r3, [r3, #16]
    5f1c:	2b01      	cmp	r3, #1
    5f1e:	d160      	bne.n	5fe2 <Can_Ipw_InitLegacyFifoFilter+0x1cc>
            {
                u8HwFilterCount = Can_pHwObject->Can_u8HwFilterCount * 2U ;
    5f20:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f24:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5f28:	681b      	ldr	r3, [r3, #0]
    5f2a:	7c9b      	ldrb	r3, [r3, #18]
    5f2c:	005b      	lsls	r3, r3, #1
    5f2e:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC000C000U;
    5f32:	f04f 23c0 	mov.w	r3, #3221274624	; 0xc000c000
    5f36:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_B;
    5f3a:	2301      	movs	r3, #1
    5f3c:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    5f40:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f44:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5f48:	681b      	ldr	r3, [r3, #0]
    5f4a:	689b      	ldr	r3, [r3, #8]
    5f4c:	2b00      	cmp	r3, #0
    5f4e:	d024      	beq.n	5f9a <Can_Ipw_InitLegacyFifoFilter+0x184>
                {
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT1;
    5f50:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f54:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5f58:	681b      	ldr	r3, [r3, #0]
    5f5a:	695a      	ldr	r2, [r3, #20]
    5f5c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5f60:	011b      	lsls	r3, r3, #4
    5f62:	4413      	add	r3, r2
    5f64:	685b      	ldr	r3, [r3, #4]
    5f66:	0bdb      	lsrs	r3, r3, #15
    5f68:	041b      	lsls	r3, r3, #16
    5f6a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5f6e:	4313      	orrs	r3, r2
    5f70:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT2;
    5f74:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f78:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5f7c:	681b      	ldr	r3, [r3, #0]
    5f7e:	695a      	ldr	r2, [r3, #20]
    5f80:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5f84:	011b      	lsls	r3, r3, #4
    5f86:	3308      	adds	r3, #8
    5f88:	4413      	add	r3, r2
    5f8a:	685b      	ldr	r3, [r3, #4]
    5f8c:	0bdb      	lsrs	r3, r3, #15
    5f8e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5f92:	4313      	orrs	r3, r2
    5f94:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    5f98:	e0cf      	b.n	613a <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT1;
    5f9a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5f9e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5fa2:	681b      	ldr	r3, [r3, #0]
    5fa4:	695a      	ldr	r2, [r3, #20]
    5fa6:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5faa:	011b      	lsls	r3, r3, #4
    5fac:	4413      	add	r3, r2
    5fae:	685b      	ldr	r3, [r3, #4]
    5fb0:	04db      	lsls	r3, r3, #19
    5fb2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5fb6:	4313      	orrs	r3, r2
    5fb8:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT2;
    5fbc:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5fc0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5fc4:	681b      	ldr	r3, [r3, #0]
    5fc6:	695a      	ldr	r2, [r3, #20]
    5fc8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    5fcc:	011b      	lsls	r3, r3, #4
    5fce:	3308      	adds	r3, #8
    5fd0:	4413      	add	r3, r2
    5fd2:	685b      	ldr	r3, [r3, #4]
    5fd4:	00db      	lsls	r3, r3, #3
    5fd6:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    5fda:	4313      	orrs	r3, r2
    5fdc:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    5fe0:	e0ab      	b.n	613a <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else /*CAN_LEGACY_FIFO_FORMAT_C == Can_pController->Can_eLegacyAcceptanceMode */
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount * 4U ;
    5fe2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    5fe6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    5fea:	681b      	ldr	r3, [r3, #0]
    5fec:	7c9b      	ldrb	r3, [r3, #18]
    5fee:	009b      	lsls	r3, r3, #2
    5ff0:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0x00000000U;
    5ff4:	2300      	movs	r3, #0
    5ff6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_C;
    5ffa:	2302      	movs	r3, #2
    5ffc:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    6000:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6004:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    6008:	681b      	ldr	r3, [r3, #0]
    600a:	689b      	ldr	r3, [r3, #8]
    600c:	2b00      	cmp	r3, #0
    600e:	d04a      	beq.n	60a6 <Can_Ipw_InitLegacyFifoFilter+0x290>
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    6010:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6014:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    6018:	681b      	ldr	r3, [r3, #0]
    601a:	695a      	ldr	r2, [r3, #20]
    601c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6020:	015b      	lsls	r3, r3, #5
    6022:	4413      	add	r3, r2
    6024:	685b      	ldr	r3, [r3, #4]
    6026:	0d5b      	lsrs	r3, r3, #21
    6028:	061b      	lsls	r3, r3, #24
    602a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    602e:	4313      	orrs	r3, r2
    6030:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    6034:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6038:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    603c:	681b      	ldr	r3, [r3, #0]
    603e:	695a      	ldr	r2, [r3, #20]
    6040:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6044:	015b      	lsls	r3, r3, #5
    6046:	3308      	adds	r3, #8
    6048:	4413      	add	r3, r2
    604a:	685b      	ldr	r3, [r3, #4]
    604c:	0d5b      	lsrs	r3, r3, #21
    604e:	041b      	lsls	r3, r3, #16
    6050:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    6054:	4313      	orrs	r3, r2
    6056:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    605a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    605e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    6062:	681b      	ldr	r3, [r3, #0]
    6064:	695a      	ldr	r2, [r3, #20]
    6066:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    606a:	015b      	lsls	r3, r3, #5
    606c:	3310      	adds	r3, #16
    606e:	4413      	add	r3, r2
    6070:	685b      	ldr	r3, [r3, #4]
    6072:	0d5b      	lsrs	r3, r3, #21
    6074:	021b      	lsls	r3, r3, #8
    6076:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    607a:	4313      	orrs	r3, r2
    607c:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    6080:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6084:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    6088:	681b      	ldr	r3, [r3, #0]
    608a:	695a      	ldr	r2, [r3, #20]
    608c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6090:	015b      	lsls	r3, r3, #5
    6092:	3318      	adds	r3, #24
    6094:	4413      	add	r3, r2
    6096:	685b      	ldr	r3, [r3, #4]
    6098:	0d5b      	lsrs	r3, r3, #21
    609a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    609e:	4313      	orrs	r3, r2
    60a0:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    60a4:	e049      	b.n	613a <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    60a6:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    60aa:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    60ae:	681b      	ldr	r3, [r3, #0]
    60b0:	695a      	ldr	r2, [r3, #20]
    60b2:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    60b6:	015b      	lsls	r3, r3, #5
    60b8:	4413      	add	r3, r2
    60ba:	685b      	ldr	r3, [r3, #4]
    60bc:	08db      	lsrs	r3, r3, #3
    60be:	061b      	lsls	r3, r3, #24
    60c0:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    60c4:	4313      	orrs	r3, r2
    60c6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    60ca:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    60ce:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    60d2:	681b      	ldr	r3, [r3, #0]
    60d4:	695a      	ldr	r2, [r3, #20]
    60d6:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    60da:	015b      	lsls	r3, r3, #5
    60dc:	3308      	adds	r3, #8
    60de:	4413      	add	r3, r2
    60e0:	685b      	ldr	r3, [r3, #4]
    60e2:	08db      	lsrs	r3, r3, #3
    60e4:	041b      	lsls	r3, r3, #16
    60e6:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    60ea:	4313      	orrs	r3, r2
    60ec:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    60f0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    60f4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    60f8:	681b      	ldr	r3, [r3, #0]
    60fa:	695a      	ldr	r2, [r3, #20]
    60fc:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6100:	015b      	lsls	r3, r3, #5
    6102:	3310      	adds	r3, #16
    6104:	4413      	add	r3, r2
    6106:	685b      	ldr	r3, [r3, #4]
    6108:	08db      	lsrs	r3, r3, #3
    610a:	021b      	lsls	r3, r3, #8
    610c:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    6110:	4313      	orrs	r3, r2
    6112:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    6116:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    611a:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    611e:	681b      	ldr	r3, [r3, #0]
    6120:	695a      	ldr	r2, [r3, #20]
    6122:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6126:	015b      	lsls	r3, r3, #5
    6128:	3318      	adds	r3, #24
    612a:	4413      	add	r3, r2
    612c:	685b      	ldr	r3, [r3, #4]
    612e:	08db      	lsrs	r3, r3, #3
    6130:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    6134:	4313      	orrs	r3, r2
    6136:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                }
            }
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, u8FilterIdx, u32HwFilterMask);
    613a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    613e:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    6142:	681b      	ldr	r3, [r3, #0]
    6144:	789b      	ldrb	r3, [r3, #2]
    6146:	f89d 1417 	ldrb.w	r1, [sp, #1047]	; 0x417
    614a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    614e:	4618      	mov	r0, r3
    6150:	f002 fb4e 	bl	87f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    6154:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6158:	3301      	adds	r3, #1
    615a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    615e:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    6162:	f89d 340f 	ldrb.w	r3, [sp, #1039]	; 0x40f
    6166:	429a      	cmp	r2, r3
    6168:	d20a      	bcs.n	6180 <Can_Ipw_InitLegacyFifoFilter+0x36a>
    616a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    616e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    6172:	681b      	ldr	r3, [r3, #0]
    6174:	7c9b      	ldrb	r3, [r3, #18]
    6176:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    617a:	429a      	cmp	r2, r3
    617c:	f4ff ae85 	bcc.w	5e8a <Can_Ipw_InitLegacyFifoFilter+0x74>
    }

    (void)FlexCAN_Ip_SetRxFifoGlobalMask(Can_pController->Can_u8ControllerOffset, Can_pController->Can_u32LegacyGlobalMask);
    6180:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6184:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    6188:	681b      	ldr	r3, [r3, #0]
    618a:	789a      	ldrb	r2, [r3, #2]
    618c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    6190:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    6194:	681b      	ldr	r3, [r3, #0]
    6196:	68db      	ldr	r3, [r3, #12]
    6198:	4619      	mov	r1, r3
    619a:	4610      	mov	r0, r2
    619c:	f002 fb76 	bl	888c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>
    
    if (u8HwFilterCount != 0U)
    61a0:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    61a4:	2b00      	cmp	r3, #0
    61a6:	d054      	beq.n	6252 <Can_Ipw_InitLegacyFifoFilter+0x43c>
    {
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    61a8:	2300      	movs	r3, #0
    61aa:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    61ae:	e03e      	b.n	622e <Can_Ipw_InitLegacyFifoFilter+0x418>
        {
            RxFifoFilters[u8FilterIdx].id = Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterCode;
    61b0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    61b4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    61b8:	681b      	ldr	r3, [r3, #0]
    61ba:	695a      	ldr	r2, [r3, #20]
    61bc:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    61c0:	00db      	lsls	r3, r3, #3
    61c2:	441a      	add	r2, r3
    61c4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    61c8:	6812      	ldr	r2, [r2, #0]
    61ca:	f50d 6183 	add.w	r1, sp, #1048	; 0x418
    61ce:	f5a1 6182 	sub.w	r1, r1, #1040	; 0x410
    61d2:	00db      	lsls	r3, r3, #3
    61d4:	440b      	add	r3, r1
    61d6:	605a      	str	r2, [r3, #4]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    61d8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    61dc:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    61e0:	681b      	ldr	r3, [r3, #0]
    61e2:	689b      	ldr	r3, [r3, #8]
    61e4:	2b00      	cmp	r3, #0
    61e6:	d00a      	beq.n	61fe <Can_Ipw_InitLegacyFifoFilter+0x3e8>
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = TRUE;
    61e8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    61ec:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    61f0:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    61f4:	00db      	lsls	r3, r3, #3
    61f6:	4413      	add	r3, r2
    61f8:	2201      	movs	r2, #1
    61fa:	705a      	strb	r2, [r3, #1]
    61fc:	e009      	b.n	6212 <Can_Ipw_InitLegacyFifoFilter+0x3fc>
            }
            else
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = FALSE;
    61fe:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6202:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    6206:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    620a:	00db      	lsls	r3, r3, #3
    620c:	4413      	add	r3, r2
    620e:	2200      	movs	r2, #0
    6210:	705a      	strb	r2, [r3, #1]
            }
            RxFifoFilters[u8FilterIdx].isRemoteFrame = FALSE;
    6212:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    6216:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    621a:	f5a3 6382 	sub.w	r3, r3, #1040	; 0x410
    621e:	2100      	movs	r1, #0
    6220:	f803 1032 	strb.w	r1, [r3, r2, lsl #3]
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    6224:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    6228:	3301      	adds	r3, #1
    622a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    622e:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    6232:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    6236:	429a      	cmp	r2, r3
    6238:	d3ba      	bcc.n	61b0 <Can_Ipw_InitLegacyFifoFilter+0x39a>
        }

        (void)FlexCAN_Ip_ConfigRxFifo(Can_pController->Can_u8ControllerOffset, eElementFormat, RxFifoFilters);
    623a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    623e:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    6242:	681b      	ldr	r3, [r3, #0]
    6244:	789b      	ldrb	r3, [r3, #2]
    6246:	aa02      	add	r2, sp, #8
    6248:	f8dd 1408 	ldr.w	r1, [sp, #1032]	; 0x408
    624c:	4618      	mov	r0, r3
    624e:	f001 feb2 	bl	7fb6 <FlexCAN_Ip_ConfigRxFifo_Privileged>
    }
    
}
    6252:	bf00      	nop
    6254:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
    6258:	f85d fb04 	ldr.w	pc, [sp], #4

0000625c <Can_Ipw_ProcessLegacyFifoPolling>:
    PduInfoType * CanIf_PduInfo,
    Flexcan_Ip_MsgBuffType * pReceivedDataBuffer,
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
)
{
    625c:	b500      	push	{lr}
    625e:	b089      	sub	sp, #36	; 0x24
    6260:	9005      	str	r0, [sp, #20]
    6262:	9104      	str	r1, [sp, #16]
    6264:	9203      	str	r2, [sp, #12]
    6266:	9302      	str	r3, [sp, #8]
    uint8 u8ObjIdx = 0U;
    6268:	2300      	movs	r3, #0
    626a:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean returnResult;

    returnResult = FlexCAN_Ip_GetBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 5U);
    626e:	9b02      	ldr	r3, [sp, #8]
    6270:	789b      	ldrb	r3, [r3, #2]
    6272:	2105      	movs	r1, #5
    6274:	4618      	mov	r0, r3
    6276:	f002 ff27 	bl	90c8 <FlexCAN_Ip_GetBuffStatusFlag>
    627a:	4603      	mov	r3, r0
    627c:	f88d 301e 	strb.w	r3, [sp, #30]
    while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (TRUE == returnResult))
    6280:	e060      	b.n	6344 <Can_Ipw_ProcessLegacyFifoPolling+0xe8>
    {
        u8ObjIdx++;
    6282:	f89d 301f 	ldrb.w	r3, [sp, #31]
    6286:	3301      	adds	r3, #1
    6288:	f88d 301f 	strb.w	r3, [sp, #31]
        /* Check Legacy OverFlow */
        if (TRUE == FlexCAN_Ip_GetBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 7U))
    628c:	9b02      	ldr	r3, [sp, #8]
    628e:	789b      	ldrb	r3, [r3, #2]
    6290:	2107      	movs	r1, #7
    6292:	4618      	mov	r0, r3
    6294:	f002 ff18 	bl	90c8 <FlexCAN_Ip_GetBuffStatusFlag>
    6298:	4603      	mov	r3, r0
    629a:	2b00      	cmp	r3, #0
    629c:	d012      	beq.n	62c4 <Can_Ipw_ProcessLegacyFifoPolling+0x68>
        {
            (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    629e:	2301      	movs	r3, #1
    62a0:	2208      	movs	r2, #8
    62a2:	2100      	movs	r1, #0
    62a4:	2050      	movs	r0, #80	; 0x50
    62a6:	f005 fd99 	bl	bddc <Det_ReportRuntimeError>
            if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoOvfNotif)
    62aa:	9b02      	ldr	r3, [sp, #8]
    62ac:	699b      	ldr	r3, [r3, #24]
    62ae:	2b00      	cmp	r3, #0
    62b0:	d002      	beq.n	62b8 <Can_Ipw_ProcessLegacyFifoPolling+0x5c>
            {
                Can_pControllerConfig->Can_pLegacyFiFoOvfNotif();
    62b2:	9b02      	ldr	r3, [sp, #8]
    62b4:	699b      	ldr	r3, [r3, #24]
    62b6:	4798      	blx	r3
            }
            FlexCAN_Ip_ClearBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 7U);
    62b8:	9b02      	ldr	r3, [sp, #8]
    62ba:	789b      	ldrb	r3, [r3, #2]
    62bc:	2107      	movs	r1, #7
    62be:	4618      	mov	r0, r3
    62c0:	f002 ff26 	bl	9110 <FlexCAN_Ip_ClearBuffStatusFlag>
        }

        /* Check Legacy FifoWarning */
        if (TRUE == FlexCAN_Ip_GetBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 6U))
    62c4:	9b02      	ldr	r3, [sp, #8]
    62c6:	789b      	ldrb	r3, [r3, #2]
    62c8:	2106      	movs	r1, #6
    62ca:	4618      	mov	r0, r3
    62cc:	f002 fefc 	bl	90c8 <FlexCAN_Ip_GetBuffStatusFlag>
    62d0:	4603      	mov	r3, r0
    62d2:	2b00      	cmp	r3, #0
    62d4:	d00c      	beq.n	62f0 <Can_Ipw_ProcessLegacyFifoPolling+0x94>
        {
            if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoWarnNotif)
    62d6:	9b02      	ldr	r3, [sp, #8]
    62d8:	695b      	ldr	r3, [r3, #20]
    62da:	2b00      	cmp	r3, #0
    62dc:	d002      	beq.n	62e4 <Can_Ipw_ProcessLegacyFifoPolling+0x88>
            {
                Can_pControllerConfig->Can_pLegacyFiFoWarnNotif();
    62de:	9b02      	ldr	r3, [sp, #8]
    62e0:	695b      	ldr	r3, [r3, #20]
    62e2:	4798      	blx	r3
            }
            FlexCAN_Ip_ClearBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 6U);
    62e4:	9b02      	ldr	r3, [sp, #8]
    62e6:	789b      	ldrb	r3, [r3, #2]
    62e8:	2106      	movs	r1, #6
    62ea:	4618      	mov	r0, r3
    62ec:	f002 ff10 	bl	9110 <FlexCAN_Ip_ClearBuffStatusFlag>
        }

        (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, pReceivedDataBuffer);
    62f0:	9b02      	ldr	r3, [sp, #8]
    62f2:	789b      	ldrb	r3, [r3, #2]
    62f4:	9903      	ldr	r1, [sp, #12]
    62f6:	4618      	mov	r0, r3
    62f8:	f001 fe2a 	bl	7f50 <FlexCAN_Ip_RxFifo>
        FlexCAN_Ip_MainFunctionRead(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex);
    62fc:	9b02      	ldr	r3, [sp, #8]
    62fe:	789a      	ldrb	r2, [r3, #2]
    6300:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6302:	7f1b      	ldrb	r3, [r3, #28]
    6304:	4619      	mov	r1, r3
    6306:	4610      	mov	r0, r2
    6308:	f002 fb30 	bl	896c <FlexCAN_Ip_MainFunctionRead>

        if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex))
    630c:	9b02      	ldr	r3, [sp, #8]
    630e:	789a      	ldrb	r2, [r3, #2]
    6310:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6312:	7f1b      	ldrb	r3, [r3, #28]
    6314:	4619      	mov	r1, r3
    6316:	4610      	mov	r0, r2
    6318:	f001 fef8 	bl	810c <FlexCAN_Ip_GetTransferStatus>
    631c:	4603      	mov	r3, r0
    631e:	2b00      	cmp	r3, #0
    6320:	d107      	bne.n	6332 <Can_Ipw_ProcessLegacyFifoPolling+0xd6>
        {
            Can_Ipw_ParseData(CanIf_Mailbox, \
    6322:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6324:	9300      	str	r3, [sp, #0]
    6326:	9b02      	ldr	r3, [sp, #8]
    6328:	9a03      	ldr	r2, [sp, #12]
    632a:	9904      	ldr	r1, [sp, #16]
    632c:	9805      	ldr	r0, [sp, #20]
    632e:	f7ff fd15 	bl	5d5c <Can_Ipw_ParseData>
                              pReceivedDataBuffer, \
                              Can_pControllerConfig, \
                              Can_pHwObjectConfig \
                             );
        }
        returnResult = FlexCAN_Ip_GetBuffStatusFlag(Can_pControllerConfig->Can_u8ControllerOffset, 5U);
    6332:	9b02      	ldr	r3, [sp, #8]
    6334:	789b      	ldrb	r3, [r3, #2]
    6336:	2105      	movs	r1, #5
    6338:	4618      	mov	r0, r3
    633a:	f002 fec5 	bl	90c8 <FlexCAN_Ip_GetBuffStatusFlag>
    633e:	4603      	mov	r3, r0
    6340:	f88d 301e 	strb.w	r3, [sp, #30]
    while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (TRUE == returnResult))
    6344:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6346:	7b9b      	ldrb	r3, [r3, #14]
    6348:	f89d 201f 	ldrb.w	r2, [sp, #31]
    634c:	429a      	cmp	r2, r3
    634e:	d203      	bcs.n	6358 <Can_Ipw_ProcessLegacyFifoPolling+0xfc>
    6350:	f89d 301e 	ldrb.w	r3, [sp, #30]
    6354:	2b00      	cmp	r3, #0
    6356:	d194      	bne.n	6282 <Can_Ipw_ProcessLegacyFifoPolling+0x26>
    }
}
    6358:	bf00      	nop
    635a:	b009      	add	sp, #36	; 0x24
    635c:	f85d fb04 	ldr.w	pc, [sp], #4

00006360 <Can_Ipw_InitBaudrate>:

#endif /* (CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON) */

/* Init baudrate for controller */
static void Can_Ipw_InitBaudrate(const Can_43_FLEXCAN_ControllerConfigType * ControllerConfig)
{
    6360:	b510      	push	{r4, lr}
    6362:	b084      	sub	sp, #16
    6364:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
    uint16 BaudRateConfigID = Can_au16ControllerBaudRateSel[ControllerConfig->Can_u8ControllerID];
#else
    uint16 BaudRateConfigID = ControllerConfig->Can_u16DefaultBaudrateID;
    6366:	9b01      	ldr	r3, [sp, #4]
    6368:	8b9b      	ldrh	r3, [r3, #28]
    636a:	f8ad 300e 	strh.w	r3, [sp, #14]
        FlexCANTimeSeg.phaseSeg1  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg1;
        FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg2;
        FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8ResyncJumpWidth;
        (void)FlexCAN_Ip_SetBitrate(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, FALSE);
#endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
        if (TRUE == ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bFDFrame)
    636e:	9b01      	ldr	r3, [sp, #4]
    6370:	6a1a      	ldr	r2, [r3, #32]
    6372:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6376:	2116      	movs	r1, #22
    6378:	fb01 f303 	mul.w	r3, r1, r3
    637c:	4413      	add	r3, r2
    637e:	785b      	ldrb	r3, [r3, #1]
    6380:	2b00      	cmp	r3, #0
    6382:	d016      	beq.n	63b2 <Can_Ipw_InitBaudrate+0x52>
            FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg2;
            FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8ResyncJumpWidth;

            (void)FlexCAN_Ip_SetBitrateCbt(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bBitRateSwitch);
    #endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
            (void)FlexCAN_Ip_SetTDCOffset(ControllerConfig->Can_u8ControllerOffset, \
    6384:	9b01      	ldr	r3, [sp, #4]
    6386:	7898      	ldrb	r0, [r3, #2]
    6388:	9b01      	ldr	r3, [sp, #4]
    638a:	6a1a      	ldr	r2, [r3, #32]
    638c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6390:	2116      	movs	r1, #22
    6392:	fb01 f303 	mul.w	r3, r1, r3
    6396:	4413      	add	r3, r2
    6398:	7cd9      	ldrb	r1, [r3, #19]
    639a:	9b01      	ldr	r3, [sp, #4]
    639c:	6a1a      	ldr	r2, [r3, #32]
    639e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    63a2:	2416      	movs	r4, #22
    63a4:	fb04 f303 	mul.w	r3, r4, r3
    63a8:	4413      	add	r3, r2
    63aa:	7d1b      	ldrb	r3, [r3, #20]
    63ac:	461a      	mov	r2, r3
    63ae:	f002 fde7 	bl	8f80 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bTrcvDelayEnable, \
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(ControllerConfig->Can_u8ControllerOffset, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TxArbitrationStartDelay);
    63b2:	9b01      	ldr	r3, [sp, #4]
    63b4:	7898      	ldrb	r0, [r3, #2]
    63b6:	9b01      	ldr	r3, [sp, #4]
    63b8:	6a1a      	ldr	r2, [r3, #32]
    63ba:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    63be:	2116      	movs	r1, #22
    63c0:	fb01 f303 	mul.w	r3, r1, r3
    63c4:	4413      	add	r3, r2
    63c6:	7c9b      	ldrb	r3, [r3, #18]
    63c8:	4619      	mov	r1, r3
    63ca:	f002 fe2d 	bl	9028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
}
    63ce:	bf00      	nop
    63d0:	b004      	add	sp, #16
    63d2:	bd10      	pop	{r4, pc}

000063d4 <Can_43_FLEXCAN_Ipw_Init>:
#endif /* (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON) */
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Std_ReturnType Can_43_FLEXCAN_Ipw_Init(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    63d4:	b510      	push	{r4, lr}
    63d6:	b084      	sub	sp, #16
    63d8:	9001      	str	r0, [sp, #4]
    Std_ReturnType eRetVal = (Std_ReturnType)FLEXCAN_STATUS_ERROR;
    63da:	2301      	movs	r3, #1
    63dc:	f88d 300f 	strb.w	r3, [sp, #15]
    {
        Can_Ipw_u32Seconds = 0U;
    }
#endif
    /* @violates @ref Can_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    eRetVal = (Std_ReturnType)Call_Can_FlexCan_Init(Can_pControllerConfig->Can_u8ControllerOffset, Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);
    63e0:	9b01      	ldr	r3, [sp, #4]
    63e2:	7898      	ldrb	r0, [r3, #2]
    63e4:	492e      	ldr	r1, [pc, #184]	; (64a0 <Can_43_FLEXCAN_Ipw_Init+0xcc>)
    63e6:	9b01      	ldr	r3, [sp, #4]
    63e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    63ea:	681b      	ldr	r3, [r3, #0]
    63ec:	461a      	mov	r2, r3
    63ee:	f001 fc15 	bl	7c1c <FlexCAN_Ip_Init_Privileged>
    63f2:	4603      	mov	r3, r0
    63f4:	f88d 300f 	strb.w	r3, [sp, #15]
    
    /* by defaut, enable interrupt when setcontroller to start */
    Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    63f8:	9b01      	ldr	r3, [sp, #4]
    63fa:	785b      	ldrb	r3, [r3, #1]
    63fc:	461a      	mov	r2, r3
    63fe:	4b29      	ldr	r3, [pc, #164]	; (64a4 <Can_43_FLEXCAN_Ipw_Init+0xd0>)
    6400:	2101      	movs	r1, #1
    6402:	5499      	strb	r1, [r3, r2]
    if ((Std_ReturnType)FLEXCAN_STATUS_SUCCESS == eRetVal)
    6404:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6408:	2b00      	cmp	r3, #0
    640a:	d13b      	bne.n	6484 <Can_43_FLEXCAN_Ipw_Init+0xb0>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    640c:	9b01      	ldr	r3, [sp, #4]
    640e:	789b      	ldrb	r3, [r3, #2]
    6410:	4618      	mov	r0, r3
    6412:	f002 fec7 	bl	91a4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* If the FlexCAN_Init retuns SUCCESS then the module is already in freezemode, and FlexCAN_Ip_SetTDCOffset and FlexCAN_Ip_SetTxArbitrationStartDelay will always retun success */
        if (Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bFDFrame)
    6416:	9b01      	ldr	r3, [sp, #4]
    6418:	6a1a      	ldr	r2, [r3, #32]
    641a:	9b01      	ldr	r3, [sp, #4]
    641c:	8b9b      	ldrh	r3, [r3, #28]
    641e:	4619      	mov	r1, r3
    6420:	2316      	movs	r3, #22
    6422:	fb01 f303 	mul.w	r3, r1, r3
    6426:	4413      	add	r3, r2
    6428:	785b      	ldrb	r3, [r3, #1]
    642a:	2b00      	cmp	r3, #0
    642c:	d018      	beq.n	6460 <Can_43_FLEXCAN_Ipw_Init+0x8c>
        {
            (void)FlexCAN_Ip_SetTDCOffset(Can_pControllerConfig->Can_u8ControllerOffset, \
    642e:	9b01      	ldr	r3, [sp, #4]
    6430:	7898      	ldrb	r0, [r3, #2]
    6432:	9b01      	ldr	r3, [sp, #4]
    6434:	6a1a      	ldr	r2, [r3, #32]
    6436:	9b01      	ldr	r3, [sp, #4]
    6438:	8b9b      	ldrh	r3, [r3, #28]
    643a:	4619      	mov	r1, r3
    643c:	2316      	movs	r3, #22
    643e:	fb01 f303 	mul.w	r3, r1, r3
    6442:	4413      	add	r3, r2
    6444:	7cd9      	ldrb	r1, [r3, #19]
    6446:	9b01      	ldr	r3, [sp, #4]
    6448:	6a1a      	ldr	r2, [r3, #32]
    644a:	9b01      	ldr	r3, [sp, #4]
    644c:	8b9b      	ldrh	r3, [r3, #28]
    644e:	461c      	mov	r4, r3
    6450:	2316      	movs	r3, #22
    6452:	fb04 f303 	mul.w	r3, r4, r3
    6456:	4413      	add	r3, r2
    6458:	7d1b      	ldrb	r3, [r3, #20]
    645a:	461a      	mov	r2, r3
    645c:	f002 fd90 	bl	8f80 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bTrcvDelayEnable, \
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(Can_pControllerConfig->Can_u8ControllerOffset, \
    6460:	9b01      	ldr	r3, [sp, #4]
    6462:	7898      	ldrb	r0, [r3, #2]
    6464:	9b01      	ldr	r3, [sp, #4]
    6466:	6a1a      	ldr	r2, [r3, #32]
    6468:	9b01      	ldr	r3, [sp, #4]
    646a:	8b9b      	ldrh	r3, [r3, #28]
    646c:	4619      	mov	r1, r3
    646e:	2316      	movs	r3, #22
    6470:	fb01 f303 	mul.w	r3, r1, r3
    6474:	4413      	add	r3, r2
    6476:	7c9b      	ldrb	r3, [r3, #18]
    6478:	4619      	mov	r1, r3
    647a:	f002 fdd5 	bl	9028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
                                                    Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TxArbitrationStartDelay);
        
        /* Init all Rx objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    647e:	9801      	ldr	r0, [sp, #4]
    6480:	f000 f9fc 	bl	687c <Can_Ipw_InitRx>
                break;
            }
        }
    }
#endif /* MB_INTERRUPT_SUPPORT */
    eRetVal = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    6484:	9b01      	ldr	r3, [sp, #4]
    6486:	789b      	ldrb	r3, [r3, #2]
    6488:	4618      	mov	r0, r3
    648a:	f002 fbdb 	bl	8c44 <FlexCAN_Ip_SetStopMode_Privileged>
    648e:	4603      	mov	r3, r0
    6490:	f88d 300f 	strb.w	r3, [sp, #15]

    return (Std_ReturnType)eRetVal;
    6494:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6498:	4618      	mov	r0, r3
    649a:	b004      	add	sp, #16
    649c:	bd10      	pop	{r4, pc}
    649e:	bf00      	nop
    64a0:	1fff8d00 	.word	0x1fff8d00
    64a4:	1fff8f60 	.word	0x1fff8f60

000064a8 <Can_43_FLEXCAN_Ipw_DeInit>:

/**
*   @brief      De-Initialize Controller
*/
void Can_43_FLEXCAN_Ipw_DeInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    64a8:	b500      	push	{lr}
    64aa:	b083      	sub	sp, #12
    64ac:	9001      	str	r0, [sp, #4]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    (void)FlexCAN_Ip_Deinit(Can_pControllerConfig->Can_u8ControllerOffset);
    64ae:	9b01      	ldr	r3, [sp, #4]
    64b0:	789b      	ldrb	r3, [r3, #2]
    64b2:	4618      	mov	r0, r3
    64b4:	f002 fa32 	bl	891c <FlexCAN_Ip_Deinit_Privileged>
}
    64b8:	bf00      	nop
    64ba:	b003      	add	sp, #12
    64bc:	f85d fb04 	ldr.w	pc, [sp], #4

000064c0 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>:

/**
*   @brief      Set Error Initialization and set Controller to start Mode.
*/
static Std_ReturnType Can_43_FLEXCAN_Ipw_SetControlerErrorInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    64c0:	b500      	push	{lr}
    64c2:	b085      	sub	sp, #20
    64c4:	9001      	str	r0, [sp, #4]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_SUCCESS;
    64c6:	2300      	movs	r3, #0
    64c8:	9303      	str	r3, [sp, #12]

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    64ca:	9b01      	ldr	r3, [sp, #4]
    64cc:	785b      	ldrb	r3, [r3, #1]
    64ce:	461a      	mov	r2, r3
    64d0:	4b0a      	ldr	r3, [pc, #40]	; (64fc <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x3c>)
    64d2:	5c9b      	ldrb	r3, [r3, r2]
    64d4:	2b00      	cmp	r3, #0
    64d6:	d004      	beq.n	64e2 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x22>
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    64d8:	9b01      	ldr	r3, [sp, #4]
    64da:	789b      	ldrb	r3, [r3, #2]
    64dc:	4618      	mov	r0, r3
    64de:	f002 fe33 	bl	9148 <FlexCAN_Ip_EnableInterrupts_Privileged>
    }
    eRetVal = FlexCAN_Ip_SetStartMode(Can_pControllerConfig->Can_u8ControllerOffset);
    64e2:	9b01      	ldr	r3, [sp, #4]
    64e4:	789b      	ldrb	r3, [r3, #2]
    64e6:	4618      	mov	r0, r3
    64e8:	f002 fb8c 	bl	8c04 <FlexCAN_Ip_SetStartMode_Privileged>
    64ec:	9003      	str	r0, [sp, #12]

    return (Std_ReturnType)eRetVal;
    64ee:	9b03      	ldr	r3, [sp, #12]
    64f0:	b2db      	uxtb	r3, r3
}
    64f2:	4618      	mov	r0, r3
    64f4:	b005      	add	sp, #20
    64f6:	f85d fb04 	ldr.w	pc, [sp], #4
    64fa:	bf00      	nop
    64fc:	1fff8f60 	.word	0x1fff8f60

00006500 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>:

/**
*   @brief      Set Controller to participate the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStartMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    6500:	b500      	push	{lr}
    6502:	b085      	sub	sp, #20
    6504:	9001      	str	r0, [sp, #4]
        {
            Can_Ipw_u32CurrentCompareVal = Stm_Ip_GetCompareValue(CAN_43_FLEXCAN_TS_STM_INSTANCE, CAN_43_FLEXCAN_TS_STM_CHANNEL);
        }
    }
#endif
    eRetVal = FlexCAN_Ip_Init(Can_pControllerConfig->Can_u8ControllerOffset, \
    6506:	9b01      	ldr	r3, [sp, #4]
    6508:	7898      	ldrb	r0, [r3, #2]
    650a:	4913      	ldr	r1, [pc, #76]	; (6558 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x58>)
    650c:	9b01      	ldr	r3, [sp, #4]
    650e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6510:	681b      	ldr	r3, [r3, #0]
    6512:	461a      	mov	r2, r3
    6514:	f001 fb82 	bl	7c1c <FlexCAN_Ip_Init_Privileged>
    6518:	9003      	str	r0, [sp, #12]
                                                    Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], \
                                                    Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);

    if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    651a:	9b03      	ldr	r3, [sp, #12]
    651c:	2b00      	cmp	r3, #0
    651e:	d114      	bne.n	654a <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x4a>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    6520:	9b01      	ldr	r3, [sp, #4]
    6522:	789b      	ldrb	r3, [r3, #2]
    6524:	4618      	mov	r0, r3
    6526:	f002 fe3d 	bl	91a4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* Re-Init baudrate */
        Can_Ipw_InitBaudrate(Can_pControllerConfig);
    652a:	9801      	ldr	r0, [sp, #4]
    652c:	f7ff ff18 	bl	6360 <Can_Ipw_InitBaudrate>

        /* Re-Init all Rx Objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    6530:	9801      	ldr	r0, [sp, #4]
    6532:	f000 f9a3 	bl	687c <Can_Ipw_InitRx>
                    }
                }
            }
        }
    #endif /* CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON */
        eRetVal = ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControlerErrorInit(Can_pControllerConfig)) ? (FLEXCAN_STATUS_SUCCESS) : (FLEXCAN_STATUS_ERROR);
    6536:	9801      	ldr	r0, [sp, #4]
    6538:	f7ff ffc2 	bl	64c0 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>
    653c:	4603      	mov	r3, r0
    653e:	2b00      	cmp	r3, #0
    6540:	bf14      	ite	ne
    6542:	2301      	movne	r3, #1
    6544:	2300      	moveq	r3, #0
    6546:	b2db      	uxtb	r3, r3
    6548:	9303      	str	r3, [sp, #12]
    }
    return (Std_ReturnType)eRetVal;
    654a:	9b03      	ldr	r3, [sp, #12]
    654c:	b2db      	uxtb	r3, r3
}
    654e:	4618      	mov	r0, r3
    6550:	b005      	add	sp, #20
    6552:	f85d fb04 	ldr.w	pc, [sp], #4
    6556:	bf00      	nop
    6558:	1fff8d00 	.word	0x1fff8d00

0000655c <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>:

/**
*   @brief      Set Controller to stop participating the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStopMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    655c:	b500      	push	{lr}
    655e:	b085      	sub	sp, #20
    6560:	9001      	str	r0, [sp, #4]
    * that are not allowed in the new state. ⌋
    * [SWS_Can_00426] ⌈ Disabling of CAN interrupts shall not be executed, when CAN
    * interrupts have been disabled by function Can_DisableControllerInterrupts.⌋
    */
    Std_ReturnType eReturnValue;
    uint8 u8HwObjRefIdx = 0U;
    6562:	2300      	movs	r3, #0
    6564:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    uint8 u8Idx = 0U;
    6568:	2300      	movs	r3, #0
    656a:	f88d 300d 	strb.w	r3, [sp, #13]

    if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_EnterFreezeMode(Can_pControllerConfig->Can_u8ControllerOffset))
    656e:	9b01      	ldr	r3, [sp, #4]
    6570:	789b      	ldrb	r3, [r3, #2]
    6572:	4618      	mov	r0, r3
    6574:	f002 f910 	bl	8798 <FlexCAN_Ip_EnterFreezeMode_Privileged>
    6578:	4603      	mov	r3, r0
    657a:	2b00      	cmp	r3, #0
    657c:	d152      	bne.n	6624 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xc8>
    {
    #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_ConfigPN(Can_pControllerConfig->Can_u8ControllerOffset, FALSE, NULL_PTR);
    #endif

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    657e:	9b01      	ldr	r3, [sp, #4]
    6580:	785b      	ldrb	r3, [r3, #1]
    6582:	461a      	mov	r2, r3
    6584:	4b2c      	ldr	r3, [pc, #176]	; (6638 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xdc>)
    6586:	5c9b      	ldrb	r3, [r3, r2]
    6588:	2b00      	cmp	r3, #0
    658a:	d004      	beq.n	6596 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x3a>
    {
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    658c:	9b01      	ldr	r3, [sp, #4]
    658e:	789b      	ldrb	r3, [r3, #2]
    6590:	4618      	mov	r0, r3
    6592:	f002 fe07 	bl	91a4 <FlexCAN_Ip_DisableInterrupts_Privileged>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    6596:	2300      	movs	r3, #0
    6598:	f88d 300e 	strb.w	r3, [sp, #14]
    659c:	e032      	b.n	6604 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xa8>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    659e:	9b01      	ldr	r3, [sp, #4]
    65a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    65a2:	f89d 300e 	ldrb.w	r3, [sp, #14]
    65a6:	009b      	lsls	r3, r3, #2
    65a8:	4413      	add	r3, r2
    65aa:	681b      	ldr	r3, [r3, #0]
    65ac:	9302      	str	r3, [sp, #8]

        if (CAN_TX_NORMAL == Can_pHwObject->Can_eReceiveType)
    65ae:	9b02      	ldr	r3, [sp, #8]
    65b0:	699b      	ldr	r3, [r3, #24]
    65b2:	2b03      	cmp	r3, #3
    65b4:	d119      	bne.n	65ea <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x8e>
        {
            u8Idx = 0U;
    65b6:	2300      	movs	r3, #0
    65b8:	f88d 300d 	strb.w	r3, [sp, #13]
            do
            {
                (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex + u8Idx);
    65bc:	9b01      	ldr	r3, [sp, #4]
    65be:	7898      	ldrb	r0, [r3, #2]
    65c0:	9b02      	ldr	r3, [sp, #8]
    65c2:	7f1a      	ldrb	r2, [r3, #28]
    65c4:	f89d 300d 	ldrb.w	r3, [sp, #13]
    65c8:	4413      	add	r3, r2
    65ca:	b2db      	uxtb	r3, r3
    65cc:	4619      	mov	r1, r3
    65ce:	f002 fe9b 	bl	9308 <FlexCAN_Ip_AbortTransfer>
                u8Idx++;
    65d2:	f89d 300d 	ldrb.w	r3, [sp, #13]
    65d6:	3301      	adds	r3, #1
    65d8:	f88d 300d 	strb.w	r3, [sp, #13]
            }while (u8Idx < Can_pHwObject->Can_u8ObjectCount);
    65dc:	9b02      	ldr	r3, [sp, #8]
    65de:	7b9b      	ldrb	r3, [r3, #14]
    65e0:	f89d 200d 	ldrb.w	r2, [sp, #13]
    65e4:	429a      	cmp	r2, r3
    65e6:	d3e9      	bcc.n	65bc <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x60>
    65e8:	e007      	b.n	65fa <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x9e>
        }
        else
        {
            (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex);
    65ea:	9b01      	ldr	r3, [sp, #4]
    65ec:	789a      	ldrb	r2, [r3, #2]
    65ee:	9b02      	ldr	r3, [sp, #8]
    65f0:	7f1b      	ldrb	r3, [r3, #28]
    65f2:	4619      	mov	r1, r3
    65f4:	4610      	mov	r0, r2
    65f6:	f002 fe87 	bl	9308 <FlexCAN_Ip_AbortTransfer>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    65fa:	f89d 300e 	ldrb.w	r3, [sp, #14]
    65fe:	3301      	adds	r3, #1
    6600:	f88d 300e 	strb.w	r3, [sp, #14]
    6604:	9b01      	ldr	r3, [sp, #4]
    6606:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    660a:	f89d 200e 	ldrb.w	r2, [sp, #14]
    660e:	429a      	cmp	r2, r3
    6610:	d3c5      	bcc.n	659e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x42>
        }
    }
    eReturnValue = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    6612:	9b01      	ldr	r3, [sp, #4]
    6614:	789b      	ldrb	r3, [r3, #2]
    6616:	4618      	mov	r0, r3
    6618:	f002 fb14 	bl	8c44 <FlexCAN_Ip_SetStopMode_Privileged>
    661c:	4603      	mov	r3, r0
    661e:	f88d 300f 	strb.w	r3, [sp, #15]
    6622:	e002      	b.n	662a <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xce>
    }
    else
    {
        eReturnValue = E_NOT_OK;
    6624:	2301      	movs	r3, #1
    6626:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return eReturnValue;
    662a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    662e:	4618      	mov	r0, r3
    6630:	b005      	add	sp, #20
    6632:	f85d fb04 	ldr.w	pc, [sp], #4
    6636:	bf00      	nop
    6638:	1fff8f60 	.word	0x1fff8f60

0000663c <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>:
/**
*   @brief      Disable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    663c:	b500      	push	{lr}
    663e:	b083      	sub	sp, #12
    6640:	9001      	str	r0, [sp, #4]
    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    6642:	9b01      	ldr	r3, [sp, #4]
    6644:	785b      	ldrb	r3, [r3, #1]
    6646:	461a      	mov	r2, r3
    6648:	4b09      	ldr	r3, [pc, #36]	; (6670 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x34>)
    664a:	5c9b      	ldrb	r3, [r3, r2]
    664c:	2b00      	cmp	r3, #0
    664e:	d00a      	beq.n	6666 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x2a>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    6650:	9b01      	ldr	r3, [sp, #4]
    6652:	789b      	ldrb	r3, [r3, #2]
    6654:	4618      	mov	r0, r3
    6656:	f002 fda5 	bl	91a4 <FlexCAN_Ip_DisableInterrupts_Privileged>
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = FALSE;
    665a:	9b01      	ldr	r3, [sp, #4]
    665c:	785b      	ldrb	r3, [r3, #1]
    665e:	461a      	mov	r2, r3
    6660:	4b03      	ldr	r3, [pc, #12]	; (6670 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x34>)
    6662:	2100      	movs	r1, #0
    6664:	5499      	strb	r1, [r3, r2]
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
}
    6666:	bf00      	nop
    6668:	b003      	add	sp, #12
    666a:	f85d fb04 	ldr.w	pc, [sp], #4
    666e:	bf00      	nop
    6670:	1fff8f60 	.word	0x1fff8f60

00006674 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>:

/**
*   @brief      Enable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    6674:	b500      	push	{lr}
    6676:	b083      	sub	sp, #12
    6678:	9001      	str	r0, [sp, #4]
    /*
    * [SWS_Can_00208] ⌈ The function Can_EnableControllerInterrupts shall perform no
    * action when Can_DisableControllerInterrupts has not been called before.⌋
    */
    if (FALSE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    667a:	9b01      	ldr	r3, [sp, #4]
    667c:	785b      	ldrb	r3, [r3, #1]
    667e:	461a      	mov	r2, r3
    6680:	4b0a      	ldr	r3, [pc, #40]	; (66ac <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x38>)
    6682:	5c9b      	ldrb	r3, [r3, r2]
    6684:	f083 0301 	eor.w	r3, r3, #1
    6688:	b2db      	uxtb	r3, r3
    668a:	2b00      	cmp	r3, #0
    668c:	d00a      	beq.n	66a4 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x30>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    668e:	9b01      	ldr	r3, [sp, #4]
    6690:	789b      	ldrb	r3, [r3, #2]
    6692:	4618      	mov	r0, r3
    6694:	f002 fd58 	bl	9148 <FlexCAN_Ip_EnableInterrupts_Privileged>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        /* update status */
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    6698:	9b01      	ldr	r3, [sp, #4]
    669a:	785b      	ldrb	r3, [r3, #1]
    669c:	461a      	mov	r2, r3
    669e:	4b03      	ldr	r3, [pc, #12]	; (66ac <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x38>)
    66a0:	2101      	movs	r1, #1
    66a2:	5499      	strb	r1, [r3, r2]
    }
}
    66a4:	bf00      	nop
    66a6:	b003      	add	sp, #12
    66a8:	f85d fb04 	ldr.w	pc, [sp], #4
    66ac:	1fff8f60 	.word	0x1fff8f60

000066b0 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>:

/**
*   @brief      Get Controller Error State
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerErrorState(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    66b0:	b500      	push	{lr}
    66b2:	b085      	sub	sp, #20
    66b4:	9001      	str	r0, [sp, #4]
    66b6:	9100      	str	r1, [sp, #0]
    uint32 Error = 0U;
    66b8:	2300      	movs	r3, #0
    66ba:	9303      	str	r3, [sp, #12]

    Error = FlexCAN_Ip_GetErrorStatus(Can_pControllerConfig->Can_u8ControllerOffset);
    66bc:	9b01      	ldr	r3, [sp, #4]
    66be:	789b      	ldrb	r3, [r3, #2]
    66c0:	4618      	mov	r0, r3
    66c2:	f001 fe35 	bl	8330 <FlexCAN_Ip_GetErrorStatus>
    66c6:	9003      	str	r0, [sp, #12]

    *pValue = (uint8)((Error & FLEXCAN_ESR1_FLTCONF_MASK)>>FLEXCAN_ESR1_FLTCONF_SHIFT);
    66c8:	9b03      	ldr	r3, [sp, #12]
    66ca:	091b      	lsrs	r3, r3, #4
    66cc:	b2db      	uxtb	r3, r3
    66ce:	f003 0303 	and.w	r3, r3, #3
    66d2:	b2da      	uxtb	r2, r3
    66d4:	9b00      	ldr	r3, [sp, #0]
    66d6:	701a      	strb	r2, [r3, #0]
    return E_OK;
    66d8:	2300      	movs	r3, #0
}
    66da:	4618      	mov	r0, r3
    66dc:	b005      	add	sp, #20
    66de:	f85d fb04 	ldr.w	pc, [sp], #4

000066e2 <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>:

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    66e2:	b500      	push	{lr}
    66e4:	b083      	sub	sp, #12
    66e6:	9001      	str	r0, [sp, #4]
    66e8:	9100      	str	r1, [sp, #0]
     *pValue = FlexCAN_Ip_GetControllerTxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    66ea:	9b01      	ldr	r3, [sp, #4]
    66ec:	789b      	ldrb	r3, [r3, #2]
    66ee:	4618      	mov	r0, r3
    66f0:	f001 fe30 	bl	8354 <FlexCAN_Ip_GetControllerTxErrorCounter>
    66f4:	4603      	mov	r3, r0
    66f6:	461a      	mov	r2, r3
    66f8:	9b00      	ldr	r3, [sp, #0]
    66fa:	701a      	strb	r2, [r3, #0]
     return E_OK;
    66fc:	2300      	movs	r3, #0
}
    66fe:	4618      	mov	r0, r3
    6700:	b003      	add	sp, #12
    6702:	f85d fb04 	ldr.w	pc, [sp], #4

00006706 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>:

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    6706:	b500      	push	{lr}
    6708:	b083      	sub	sp, #12
    670a:	9001      	str	r0, [sp, #4]
    670c:	9100      	str	r1, [sp, #0]

    *pValue = FlexCAN_Ip_GetControllerRxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    670e:	9b01      	ldr	r3, [sp, #4]
    6710:	789b      	ldrb	r3, [r3, #2]
    6712:	4618      	mov	r0, r3
    6714:	f001 fe30 	bl	8378 <FlexCAN_Ip_GetControllerRxErrorCounter>
    6718:	4603      	mov	r3, r0
    671a:	461a      	mov	r2, r3
    671c:	9b00      	ldr	r3, [sp, #0]
    671e:	701a      	strb	r2, [r3, #0]
    return E_OK;
    6720:	2300      	movs	r3, #0
}
    6722:	4618      	mov	r0, r3
    6724:	b003      	add	sp, #12
    6726:	f85d fb04 	ldr.w	pc, [sp], #4

0000672a <Can_43_FLEXCAN_Ipw_Write>:
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
    const Can_PduType * PduInfo
)
{
    672a:	b510      	push	{r4, lr}
    672c:	b08c      	sub	sp, #48	; 0x30
    672e:	9005      	str	r0, [sp, #20]
    6730:	9104      	str	r1, [sp, #16]
    6732:	9203      	str	r2, [sp, #12]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    6734:	2301      	movs	r3, #1
    6736:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_DataInfoType DataInfo;
    uint8 u8ObjIdx = 0U;
    6738:	2300      	movs	r3, #0
    673a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
#if (CAN_43_FLEXCAN_TRIGGER_TRANSMIT_USED == STD_ON)
    PduInfoType CanIf_PduInfo;
    uint8 Data[64U];
#endif

    DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    673e:	2300      	movs	r3, #0
    6740:	9306      	str	r3, [sp, #24]
    DataInfo.data_length = 0U;
    6742:	2300      	movs	r3, #0
    6744:	9307      	str	r3, [sp, #28]
    DataInfo.fd_padding = 0U;
    6746:	2300      	movs	r3, #0
    6748:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    DataInfo.fd_enable = FALSE;
    674c:	2300      	movs	r3, #0
    674e:	f88d 3020 	strb.w	r3, [sp, #32]
    DataInfo.enable_brs = FALSE;
    6752:	2300      	movs	r3, #0
    6754:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    DataInfo.is_remote = FALSE;
    6758:	2300      	movs	r3, #0
    675a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    DataInfo.is_polling = FALSE;
    675e:	2300      	movs	r3, #0
    6760:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    if (CAN_TX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    6764:	9b04      	ldr	r3, [sp, #16]
    6766:	699b      	ldr	r3, [r3, #24]
    6768:	2b03      	cmp	r3, #3
    676a:	d173      	bne.n	6854 <Can_43_FLEXCAN_Ipw_Write+0x12a>
    {
        DataInfo.msg_id_type = ((PduInfo->id & CAN_43_FLEXCAN_EXTENDED_ID_U32) != 0U) ? FLEXCAN_MSG_ID_EXT : FLEXCAN_MSG_ID_STD;
    676c:	9b03      	ldr	r3, [sp, #12]
    676e:	681b      	ldr	r3, [r3, #0]
    6770:	0fdb      	lsrs	r3, r3, #31
    6772:	9306      	str	r3, [sp, #24]
        if (Can_pHwObjectConfig->Can_u8PayloadLength <=  PduInfo->length)
    6774:	9b04      	ldr	r3, [sp, #16]
    6776:	7c1a      	ldrb	r2, [r3, #16]
    6778:	9b03      	ldr	r3, [sp, #12]
    677a:	799b      	ldrb	r3, [r3, #6]
    677c:	429a      	cmp	r2, r3
    677e:	d803      	bhi.n	6788 <Can_43_FLEXCAN_Ipw_Write+0x5e>
        {
            DataInfo.data_length = Can_pHwObjectConfig->Can_u8PayloadLength;
    6780:	9b04      	ldr	r3, [sp, #16]
    6782:	7c1b      	ldrb	r3, [r3, #16]
    6784:	9307      	str	r3, [sp, #28]
    6786:	e002      	b.n	678e <Can_43_FLEXCAN_Ipw_Write+0x64>
        }
        else
        {
            DataInfo.data_length = PduInfo->length;
    6788:	9b03      	ldr	r3, [sp, #12]
    678a:	799b      	ldrb	r3, [r3, #6]
    678c:	9307      	str	r3, [sp, #28]
        }
#if (CAN_43_FLEXCAN_FEATURE_HAS_FD == STD_ON)
        DataInfo.fd_padding = Can_pHwObjectConfig->Can_u8PaddingValue;
    678e:	9b04      	ldr	r3, [sp, #16]
    6790:	7c5b      	ldrb	r3, [r3, #17]
    6792:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        DataInfo.fd_enable = ((PduInfo->id & CAN_43_FLEXCAN_FD_FRAME_U32) != 0U) ? TRUE : FALSE;
    6796:	9b03      	ldr	r3, [sp, #12]
    6798:	681b      	ldr	r3, [r3, #0]
    679a:	0f9b      	lsrs	r3, r3, #30
    679c:	f003 0301 	and.w	r3, r3, #1
    67a0:	2b00      	cmp	r3, #0
    67a2:	bf14      	ite	ne
    67a4:	2301      	movne	r3, #1
    67a6:	2300      	moveq	r3, #0
    67a8:	b2db      	uxtb	r3, r3
    67aa:	f88d 3020 	strb.w	r3, [sp, #32]
    #if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
            DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID]].Can_bBitRateSwitch;
    #else
        DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bBitRateSwitch;
    67ae:	9b05      	ldr	r3, [sp, #20]
    67b0:	6a1a      	ldr	r2, [r3, #32]
    67b2:	9b05      	ldr	r3, [sp, #20]
    67b4:	8b9b      	ldrh	r3, [r3, #28]
    67b6:	4619      	mov	r1, r3
    67b8:	2316      	movs	r3, #22
    67ba:	fb01 f303 	mul.w	r3, r1, r3
    67be:	4413      	add	r3, r2
    67c0:	781b      	ldrb	r3, [r3, #0]
    67c2:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    #endif
#endif
        DataInfo.is_remote = FALSE;
    67c6:	2300      	movs	r3, #0
    67c8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        DataInfo.is_polling = Can_pHwObjectConfig->Can_bHwObjectUsesPolling;
    67cc:	9b04      	ldr	r3, [sp, #16]
    67ce:	7b1b      	ldrb	r3, [r3, #12]
    67d0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        do
        {
            eRetVal = FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx);
    67d4:	9b05      	ldr	r3, [sp, #20]
    67d6:	7898      	ldrb	r0, [r3, #2]
    67d8:	9b04      	ldr	r3, [sp, #16]
    67da:	7f1a      	ldrb	r2, [r3, #28]
    67dc:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    67e0:	4413      	add	r3, r2
    67e2:	b2db      	uxtb	r3, r3
    67e4:	4619      	mov	r1, r3
    67e6:	f001 fc91 	bl	810c <FlexCAN_Ip_GetTransferStatus>
    67ea:	900b      	str	r0, [sp, #44]	; 0x2c
            if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    67ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    67ee:	2b00      	cmp	r3, #0
    67f0:	d122      	bne.n	6838 <Can_43_FLEXCAN_Ipw_Write+0x10e>
            {
                #if ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))
                Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = PduInfo->swPduHandle;
    67f2:	9b05      	ldr	r3, [sp, #20]
    67f4:	785b      	ldrb	r3, [r3, #1]
    67f6:	461c      	mov	r4, r3
    67f8:	9b04      	ldr	r3, [sp, #16]
    67fa:	7f1b      	ldrb	r3, [r3, #28]
    67fc:	461a      	mov	r2, r3
    67fe:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    6802:	4413      	add	r3, r2
    6804:	9a03      	ldr	r2, [sp, #12]
    6806:	8890      	ldrh	r0, [r2, #4]
    6808:	491b      	ldr	r1, [pc, #108]	; (6878 <Can_43_FLEXCAN_Ipw_Write+0x14e>)
    680a:	0162      	lsls	r2, r4, #5
    680c:	4413      	add	r3, r2
    680e:	4602      	mov	r2, r0
    6810:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                    }
                }
                else
                {
            #endif
                    eRetVal = FlexCAN_Ip_Send(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx, &DataInfo, PduInfo->id, PduInfo->sdu);
    6814:	9b05      	ldr	r3, [sp, #20]
    6816:	7898      	ldrb	r0, [r3, #2]
    6818:	9b04      	ldr	r3, [sp, #16]
    681a:	7f1a      	ldrb	r2, [r3, #28]
    681c:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    6820:	4413      	add	r3, r2
    6822:	b2d9      	uxtb	r1, r3
    6824:	9b03      	ldr	r3, [sp, #12]
    6826:	681c      	ldr	r4, [r3, #0]
    6828:	9b03      	ldr	r3, [sp, #12]
    682a:	689b      	ldr	r3, [r3, #8]
    682c:	aa06      	add	r2, sp, #24
    682e:	9300      	str	r3, [sp, #0]
    6830:	4623      	mov	r3, r4
    6832:	f001 fa6f 	bl	7d14 <FlexCAN_Ip_Send>
    6836:	900b      	str	r0, [sp, #44]	; 0x2c
                /* Revert to FALSE due to the MB was not transmitted successfully */
                Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = FALSE;
            }
            #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */
            }
            u8ObjIdx++;
    6838:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    683c:	3301      	adds	r3, #1
    683e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        } while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (FLEXCAN_STATUS_BUSY == eRetVal));
    6842:	9b04      	ldr	r3, [sp, #16]
    6844:	7b9b      	ldrb	r3, [r3, #14]
    6846:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    684a:	429a      	cmp	r2, r3
    684c:	d202      	bcs.n	6854 <Can_43_FLEXCAN_Ipw_Write+0x12a>
    684e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6850:	2b02      	cmp	r3, #2
    6852:	d0bf      	beq.n	67d4 <Can_43_FLEXCAN_Ipw_Write+0xaa>
    }

    if ((FLEXCAN_STATUS_SUCCESS != eRetVal) && (FLEXCAN_STATUS_BUSY != eRetVal))
    6854:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6856:	2b00      	cmp	r3, #0
    6858:	d004      	beq.n	6864 <Can_43_FLEXCAN_Ipw_Write+0x13a>
    685a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    685c:	2b02      	cmp	r3, #2
    685e:	d001      	beq.n	6864 <Can_43_FLEXCAN_Ipw_Write+0x13a>
    {
        eRetVal = FLEXCAN_STATUS_ERROR;
    6860:	2301      	movs	r3, #1
    6862:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    return ((FLEXCAN_STATUS_BUSY == eRetVal) ? ((Std_ReturnType)CAN_BUSY) : ((Std_ReturnType)eRetVal));
    6864:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6866:	2b02      	cmp	r3, #2
    6868:	d002      	beq.n	6870 <Can_43_FLEXCAN_Ipw_Write+0x146>
    686a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    686c:	b2db      	uxtb	r3, r3
    686e:	e000      	b.n	6872 <Can_43_FLEXCAN_Ipw_Write+0x148>
    6870:	2302      	movs	r3, #2
}
    6872:	4618      	mov	r0, r3
    6874:	b00c      	add	sp, #48	; 0x30
    6876:	bd10      	pop	{r4, pc}
    6878:	1fff8f20 	.word	0x1fff8f20

0000687c <Can_Ipw_InitRx>:

static void Can_Ipw_InitRx(const Can_43_FLEXCAN_ControllerConfigType * Can_pController)
{
    687c:	b500      	push	{lr}
    687e:	b089      	sub	sp, #36	; 0x24
    6880:	9001      	str	r0, [sp, #4]
    uint8 u8HwObjRefIdx = 0U;
    6882:	2300      	movs	r3, #0
    6884:	f88d 301f 	strb.w	r3, [sp, #31]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    Flexcan_Ip_DataInfoType DataInfo;

    /* This function just is called only if controller is in freeze mode */
    /* Always enable individual mask , Already in freeze mode */
    (void)FlexCAN_Ip_SetRxMaskType(Can_pController->Can_u8ControllerOffset, FLEXCAN_RX_MASK_INDIVIDUAL);
    6888:	9b01      	ldr	r3, [sp, #4]
    688a:	789b      	ldrb	r3, [r3, #2]
    688c:	2101      	movs	r1, #1
    688e:	4618      	mov	r0, r3
    6890:	f002 f9f6 	bl	8c80 <FlexCAN_Ip_SetRxMaskType_Privileged>

    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    6894:	2300      	movs	r3, #0
    6896:	f88d 301f 	strb.w	r3, [sp, #31]
    689a:	e03a      	b.n	6912 <Can_Ipw_InitRx+0x96>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pController->Can_ppHwObject[u8HwObjRefIdx];
    689c:	9b01      	ldr	r3, [sp, #4]
    689e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    68a0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    68a4:	009b      	lsls	r3, r3, #2
    68a6:	4413      	add	r3, r2
    68a8:	681b      	ldr	r3, [r3, #0]
    68aa:	9306      	str	r3, [sp, #24]

        if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    68ac:	9b06      	ldr	r3, [sp, #24]
    68ae:	699b      	ldr	r3, [r3, #24]
    68b0:	2b00      	cmp	r3, #0
    68b2:	d121      	bne.n	68f8 <Can_Ipw_InitRx+0x7c>
        {
            DataInfo.fd_enable = FALSE;
    68b4:	2300      	movs	r3, #0
    68b6:	f88d 3010 	strb.w	r3, [sp, #16]
            DataInfo.data_length = 0U;
    68ba:	2300      	movs	r3, #0
    68bc:	9303      	str	r3, [sp, #12]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    68be:	9b06      	ldr	r3, [sp, #24]
    68c0:	689b      	ldr	r3, [r3, #8]
    68c2:	2b00      	cmp	r3, #0
    68c4:	d002      	beq.n	68cc <Can_Ipw_InitRx+0x50>
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_EXT;
    68c6:	2301      	movs	r3, #1
    68c8:	9302      	str	r3, [sp, #8]
    68ca:	e001      	b.n	68d0 <Can_Ipw_InitRx+0x54>
            }
            else
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    68cc:	2300      	movs	r3, #0
    68ce:	9302      	str	r3, [sp, #8]
            }
            (void)FlexCAN_Ip_ConfigRxMb(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, &DataInfo, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterCode);
    68d0:	9b01      	ldr	r3, [sp, #4]
    68d2:	7898      	ldrb	r0, [r3, #2]
    68d4:	9b06      	ldr	r3, [sp, #24]
    68d6:	7f19      	ldrb	r1, [r3, #28]
    68d8:	9b06      	ldr	r3, [sp, #24]
    68da:	695b      	ldr	r3, [r3, #20]
    68dc:	681b      	ldr	r3, [r3, #0]
    68de:	aa02      	add	r2, sp, #8
    68e0:	f001 fa46 	bl	7d70 <FlexCAN_Ip_ConfigRxMb>
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterMask);
    68e4:	9b01      	ldr	r3, [sp, #4]
    68e6:	7898      	ldrb	r0, [r3, #2]
    68e8:	9b06      	ldr	r3, [sp, #24]
    68ea:	7f19      	ldrb	r1, [r3, #28]
    68ec:	9b06      	ldr	r3, [sp, #24]
    68ee:	695b      	ldr	r3, [r3, #20]
    68f0:	685b      	ldr	r3, [r3, #4]
    68f2:	461a      	mov	r2, r3
    68f4:	f001 ff7c 	bl	87f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
        }

        if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    68f8:	9b06      	ldr	r3, [sp, #24]
    68fa:	699b      	ldr	r3, [r3, #24]
    68fc:	2b01      	cmp	r3, #1
    68fe:	d103      	bne.n	6908 <Can_Ipw_InitRx+0x8c>
        {
            Can_Ipw_InitLegacyFifoFilter(Can_pController, Can_pHwObject);
    6900:	9906      	ldr	r1, [sp, #24]
    6902:	9801      	ldr	r0, [sp, #4]
    6904:	f7ff fa87 	bl	5e16 <Can_Ipw_InitLegacyFifoFilter>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    6908:	f89d 301f 	ldrb.w	r3, [sp, #31]
    690c:	3301      	adds	r3, #1
    690e:	f88d 301f 	strb.w	r3, [sp, #31]
    6912:	9b01      	ldr	r3, [sp, #4]
    6914:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    6918:	f89d 201f 	ldrb.w	r2, [sp, #31]
    691c:	429a      	cmp	r2, r3
    691e:	d3bd      	bcc.n	689c <Can_Ipw_InitRx+0x20>
        }
    }
}
    6920:	bf00      	nop
    6922:	bf00      	nop
    6924:	b009      	add	sp, #36	; 0x24
    6926:	f85d fb04 	ldr.w	pc, [sp], #4

0000692a <Can_43_FLEXCAN_Ipw_MainFunction_Write>:
    void Can_43_FLEXCAN_Ipw_MainFunction_Write
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
    )
    {
    692a:	b500      	push	{lr}
    692c:	b085      	sub	sp, #20
    692e:	9001      	str	r0, [sp, #4]
    6930:	9100      	str	r1, [sp, #0]
        uint8 u8ObjIdx = 0U;
    6932:	2300      	movs	r3, #0
    6934:	f88d 300f 	strb.w	r3, [sp, #15]

        do
        {
            if (FLEXCAN_MB_TX_BUSY == ((Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx].state))
    6938:	4a23      	ldr	r2, [pc, #140]	; (69c8 <Can_43_FLEXCAN_Ipw_MainFunction_Write+0x9e>)
    693a:	9b00      	ldr	r3, [sp, #0]
    693c:	7f1b      	ldrb	r3, [r3, #28]
    693e:	4619      	mov	r1, r3
    6940:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6944:	440b      	add	r3, r1
    6946:	011b      	lsls	r3, r3, #4
    6948:	4413      	add	r3, r2
    694a:	3304      	adds	r3, #4
    694c:	681b      	ldr	r3, [r3, #0]
    694e:	2b02      	cmp	r3, #2
    6950:	d129      	bne.n	69a6 <Can_43_FLEXCAN_Ipw_MainFunction_Write+0x7c>
            {
                /* @violates @ref Can_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
                FlexCAN_Ip_MainFunctionWrite(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx);
    6952:	9b01      	ldr	r3, [sp, #4]
    6954:	7898      	ldrb	r0, [r3, #2]
    6956:	9b00      	ldr	r3, [sp, #0]
    6958:	7f1a      	ldrb	r2, [r3, #28]
    695a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    695e:	4413      	add	r3, r2
    6960:	b2db      	uxtb	r3, r3
    6962:	4619      	mov	r1, r3
    6964:	f002 f88e 	bl	8a84 <FlexCAN_Ip_MainFunctionWrite>
                if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx))
    6968:	9b01      	ldr	r3, [sp, #4]
    696a:	7898      	ldrb	r0, [r3, #2]
    696c:	9b00      	ldr	r3, [sp, #0]
    696e:	7f1a      	ldrb	r2, [r3, #28]
    6970:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6974:	4413      	add	r3, r2
    6976:	b2db      	uxtb	r3, r3
    6978:	4619      	mov	r1, r3
    697a:	f001 fbc7 	bl	810c <FlexCAN_Ip_GetTransferStatus>
    697e:	4603      	mov	r3, r0
    6980:	2b00      	cmp	r3, #0
    6982:	d110      	bne.n	69a6 <Can_43_FLEXCAN_Ipw_MainFunction_Write+0x7c>
                {
                    CanIf_TxConfirmation(Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx]);
    6984:	9b01      	ldr	r3, [sp, #4]
    6986:	785b      	ldrb	r3, [r3, #1]
    6988:	461a      	mov	r2, r3
    698a:	9b00      	ldr	r3, [sp, #0]
    698c:	7f1b      	ldrb	r3, [r3, #28]
    698e:	4619      	mov	r1, r3
    6990:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6994:	440b      	add	r3, r1
    6996:	490d      	ldr	r1, [pc, #52]	; (69cc <Can_43_FLEXCAN_Ipw_MainFunction_Write+0xa2>)
    6998:	0152      	lsls	r2, r2, #5
    699a:	4413      	add	r3, r2
    699c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    69a0:	4618      	mov	r0, r3
    69a2:	f7f9 ffbb 	bl	91c <CanIf_TxConfirmation>
                }
            }
            u8ObjIdx++;
    69a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    69aa:	3301      	adds	r3, #1
    69ac:	f88d 300f 	strb.w	r3, [sp, #15]
        }while (u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount);
    69b0:	9b00      	ldr	r3, [sp, #0]
    69b2:	7b9b      	ldrb	r3, [r3, #14]
    69b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
    69b8:	429a      	cmp	r2, r3
    69ba:	d3bd      	bcc.n	6938 <Can_43_FLEXCAN_Ipw_MainFunction_Write+0xe>
    }
    69bc:	bf00      	nop
    69be:	bf00      	nop
    69c0:	b005      	add	sp, #20
    69c2:	f85d fb04 	ldr.w	pc, [sp], #4
    69c6:	bf00      	nop
    69c8:	1fff8d00 	.word	0x1fff8d00
    69cc:	1fff8f20 	.word	0x1fff8f20

000069d0 <Can_43_FLEXCAN_Ipw_MainFunction_Read>:
    void Can_43_FLEXCAN_Ipw_MainFunction_Read
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
    )
    {
    69d0:	b500      	push	{lr}
    69d2:	b09f      	sub	sp, #124	; 0x7c
    69d4:	9003      	str	r0, [sp, #12]
    69d6:	9102      	str	r1, [sp, #8]
        Flexcan_Ip_MsgBuffType ReceivedDataBuffer;
        Can_HwType CanIf_Mailbox;
        PduInfoType CanIf_PduInfo;

        /* set some default values that maybe uninitialized but read in Can_Ipw_ParseData. This prevents Misra violation */
        ReceivedDataBuffer.cs = 0U;
    69d8:	2300      	movs	r3, #0
    69da:	930a      	str	r3, [sp, #40]	; 0x28
        ReceivedDataBuffer.msgId = 0U;
    69dc:	2300      	movs	r3, #0
    69de:	930b      	str	r3, [sp, #44]	; 0x2c
        ReceivedDataBuffer.dataLen = 0U;
    69e0:	2300      	movs	r3, #0
    69e2:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70

        if (FALSE == FlexCAN_Ip_GetStopMode(Can_pControllerConfig->Can_u8ControllerOffset))
    69e6:	9b03      	ldr	r3, [sp, #12]
    69e8:	789b      	ldrb	r3, [r3, #2]
    69ea:	4618      	mov	r0, r3
    69ec:	f002 f8d8 	bl	8ba0 <FlexCAN_Ip_GetStopMode_Privileged>
    69f0:	4603      	mov	r3, r0
    69f2:	f083 0301 	eor.w	r3, r3, #1
    69f6:	b2db      	uxtb	r3, r3
    69f8:	2b00      	cmp	r3, #0
    69fa:	d034      	beq.n	6a66 <Can_43_FLEXCAN_Ipw_MainFunction_Read+0x96>
        {
        if (CAN_RX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    69fc:	9b02      	ldr	r3, [sp, #8]
    69fe:	699b      	ldr	r3, [r3, #24]
    6a00:	2b00      	cmp	r3, #0
    6a02:	d124      	bne.n	6a4e <Can_43_FLEXCAN_Ipw_MainFunction_Read+0x7e>
        {
            (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex, &ReceivedDataBuffer, Can_pHwObjectConfig->Can_bHwObjectUsesPolling);
    6a04:	9b03      	ldr	r3, [sp, #12]
    6a06:	7898      	ldrb	r0, [r3, #2]
    6a08:	9b02      	ldr	r3, [sp, #8]
    6a0a:	7f19      	ldrb	r1, [r3, #28]
    6a0c:	9b02      	ldr	r3, [sp, #8]
    6a0e:	7b1b      	ldrb	r3, [r3, #12]
    6a10:	aa0a      	add	r2, sp, #40	; 0x28
    6a12:	f001 f9f1 	bl	7df8 <FlexCAN_Ip_Receive>
            FlexCAN_Ip_MainFunctionRead(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex);
    6a16:	9b03      	ldr	r3, [sp, #12]
    6a18:	789a      	ldrb	r2, [r3, #2]
    6a1a:	9b02      	ldr	r3, [sp, #8]
    6a1c:	7f1b      	ldrb	r3, [r3, #28]
    6a1e:	4619      	mov	r1, r3
    6a20:	4610      	mov	r0, r2
    6a22:	f001 ffa3 	bl	896c <FlexCAN_Ip_MainFunctionRead>

            if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex))
    6a26:	9b03      	ldr	r3, [sp, #12]
    6a28:	789a      	ldrb	r2, [r3, #2]
    6a2a:	9b02      	ldr	r3, [sp, #8]
    6a2c:	7f1b      	ldrb	r3, [r3, #28]
    6a2e:	4619      	mov	r1, r3
    6a30:	4610      	mov	r0, r2
    6a32:	f001 fb6b 	bl	810c <FlexCAN_Ip_GetTransferStatus>
    6a36:	4603      	mov	r3, r0
    6a38:	2b00      	cmp	r3, #0
    6a3a:	d114      	bne.n	6a66 <Can_43_FLEXCAN_Ipw_MainFunction_Read+0x96>
            {
                Can_Ipw_ParseData(&CanIf_Mailbox, \
    6a3c:	aa0a      	add	r2, sp, #40	; 0x28
    6a3e:	a905      	add	r1, sp, #20
    6a40:	a808      	add	r0, sp, #32
    6a42:	9b02      	ldr	r3, [sp, #8]
    6a44:	9300      	str	r3, [sp, #0]
    6a46:	9b03      	ldr	r3, [sp, #12]
    6a48:	f7ff f988 	bl	5d5c <Can_Ipw_ParseData>
        else
        {
            /* prevent misra */
        }
        }
    }
    6a4c:	e00b      	b.n	6a66 <Can_43_FLEXCAN_Ipw_MainFunction_Read+0x96>
        else if (CAN_RX_LEGACY_FIFO == Can_pHwObjectConfig->Can_eReceiveType)
    6a4e:	9b02      	ldr	r3, [sp, #8]
    6a50:	699b      	ldr	r3, [r3, #24]
    6a52:	2b01      	cmp	r3, #1
    6a54:	d107      	bne.n	6a66 <Can_43_FLEXCAN_Ipw_MainFunction_Read+0x96>
            Can_Ipw_ProcessLegacyFifoPolling(&CanIf_Mailbox, \
    6a56:	aa0a      	add	r2, sp, #40	; 0x28
    6a58:	a905      	add	r1, sp, #20
    6a5a:	a808      	add	r0, sp, #32
    6a5c:	9b02      	ldr	r3, [sp, #8]
    6a5e:	9300      	str	r3, [sp, #0]
    6a60:	9b03      	ldr	r3, [sp, #12]
    6a62:	f7ff fbfb 	bl	625c <Can_Ipw_ProcessLegacyFifoPolling>
    }
    6a66:	bf00      	nop
    6a68:	b01f      	add	sp, #124	; 0x7c
    6a6a:	f85d fb04 	ldr.w	pc, [sp], #4

00006a6e <Can_43_FLEXCAN_Ipw_MainFunction_BusOff>:
#if (CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON)
    /**
    *   @brief     Polling Bus Off
    */
    void Can_43_FLEXCAN_Ipw_MainFunction_BusOff(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
    {
    6a6e:	b500      	push	{lr}
    6a70:	b083      	sub	sp, #12
    6a72:	9001      	str	r0, [sp, #4]
        (void)FlexCAN_Ip_MainFunctionBusOff(Can_pControllerConfig->Can_u8ControllerOffset);
    6a74:	9b01      	ldr	r3, [sp, #4]
    6a76:	789b      	ldrb	r3, [r3, #2]
    6a78:	4618      	mov	r0, r3
    6a7a:	f001 ffcb 	bl	8a14 <FlexCAN_Ip_MainFunctionBusOff_Privileged>
    }
    6a7e:	bf00      	nop
    6a80:	b003      	add	sp, #12
    6a82:	f85d fb04 	ldr.w	pc, [sp], #4

00006a86 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>:
void Can_43_FLEXCAN_Ipw_MainFunction_Mode
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    Can_ControllerStateType * Can_pControllerState
)
{
    6a86:	b500      	push	{lr}
    6a88:	b083      	sub	sp, #12
    6a8a:	9001      	str	r0, [sp, #4]
    6a8c:	9100      	str	r1, [sp, #0]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    if (CAN_CS_STARTED == *Can_pControllerState)
    6a8e:	9b00      	ldr	r3, [sp, #0]
    6a90:	681b      	ldr	r3, [r3, #0]
    6a92:	2b01      	cmp	r3, #1
    6a94:	d114      	bne.n	6ac0 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x3a>
    {
        if (FALSE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    6a96:	9b01      	ldr	r3, [sp, #4]
    6a98:	789b      	ldrb	r3, [r3, #2]
    6a9a:	4618      	mov	r0, r3
    6a9c:	f002 f89a 	bl	8bd4 <FlexCAN_Ip_GetStartMode_Privileged>
    6aa0:	4603      	mov	r3, r0
    6aa2:	f083 0301 	eor.w	r3, r3, #1
    6aa6:	b2db      	uxtb	r3, r3
    6aa8:	2b00      	cmp	r3, #0
    6aaa:	d01e      	beq.n	6aea <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        {
            *Can_pControllerState = CAN_CS_STOPPED;
    6aac:	9b00      	ldr	r3, [sp, #0]
    6aae:	2202      	movs	r2, #2
    6ab0:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STOPPED);
    6ab2:	9b01      	ldr	r3, [sp, #4]
    6ab4:	781b      	ldrb	r3, [r3, #0]
    6ab6:	2102      	movs	r1, #2
    6ab8:	4618      	mov	r0, r3
    6aba:	f7f9 ff26 	bl	90a <CanIf_ControllerModeIndication>
    }
    else
    {
        /* nothing to do */
    }
}
    6abe:	e014      	b.n	6aea <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
    else if (CAN_CS_STOPPED == *Can_pControllerState)
    6ac0:	9b00      	ldr	r3, [sp, #0]
    6ac2:	681b      	ldr	r3, [r3, #0]
    6ac4:	2b02      	cmp	r3, #2
    6ac6:	d110      	bne.n	6aea <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        if (TRUE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    6ac8:	9b01      	ldr	r3, [sp, #4]
    6aca:	789b      	ldrb	r3, [r3, #2]
    6acc:	4618      	mov	r0, r3
    6ace:	f002 f881 	bl	8bd4 <FlexCAN_Ip_GetStartMode_Privileged>
    6ad2:	4603      	mov	r3, r0
    6ad4:	2b00      	cmp	r3, #0
    6ad6:	d008      	beq.n	6aea <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
            *Can_pControllerState = CAN_CS_STARTED;
    6ad8:	9b00      	ldr	r3, [sp, #0]
    6ada:	2201      	movs	r2, #1
    6adc:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STARTED);
    6ade:	9b01      	ldr	r3, [sp, #4]
    6ae0:	781b      	ldrb	r3, [r3, #0]
    6ae2:	2101      	movs	r1, #1
    6ae4:	4618      	mov	r0, r3
    6ae6:	f7f9 ff10 	bl	90a <CanIf_ControllerModeIndication>
}
    6aea:	bf00      	nop
    6aec:	b003      	add	sp, #12
    6aee:	f85d fb04 	ldr.w	pc, [sp], #4
    6af2:	bf00      	nop

00006af4 <Can_43_FLEXCAN_ErrorIrqCallback>:
void Can_43_FLEXCAN_ErrorIrqCallback(uint8 u8Instance,
                          Flexcan_Ip_EventType event,
                          uint32 u32ErrStatus,
                          const Flexcan_Ip_StateType *driverState
                         )
{
    6af4:	b500      	push	{lr}
    6af6:	b085      	sub	sp, #20
    6af8:	9102      	str	r1, [sp, #8]
    6afa:	9201      	str	r2, [sp, #4]
    6afc:	9300      	str	r3, [sp, #0]
    6afe:	4603      	mov	r3, r0
    6b00:	f88d 300f 	strb.w	r3, [sp, #15]
    (void) driverState; /* not used yet */
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON)
    (void) u32ErrStatus; /* prevent compiler warning */
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON) */

    switch (event)
    6b04:	9b02      	ldr	r3, [sp, #8]
    6b06:	2b07      	cmp	r3, #7
    6b08:	d105      	bne.n	6b16 <Can_43_FLEXCAN_ErrorIrqCallback+0x22>
        }
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON) */
        /* this function is called for both interrupt & polling */
        case FLEXCAN_EVENT_BUSOFF:
        {
            Can_43_FLEXCAN_ProcessBusOffInterrupt(u8Instance);
    6b0a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6b0e:	4618      	mov	r0, r3
    6b10:	f7ff f8de 	bl	5cd0 <Can_43_FLEXCAN_ProcessBusOffInterrupt>
            break;
    6b14:	e000      	b.n	6b18 <Can_43_FLEXCAN_ErrorIrqCallback+0x24>
        }
        default:
        {
            /* nothing to do */
            break;
    6b16:	bf00      	nop
        }
    }
}
    6b18:	bf00      	nop
    6b1a:	b005      	add	sp, #20
    6b1c:	f85d fb04 	ldr.w	pc, [sp], #4

00006b20 <FlexCAN_SetRxFifoGlobalMask>:
 *
 * @param[in]   base  The FlexCAN base address
 * @param[in]   Mask     Sets mask
 */
static inline void FlexCAN_SetRxFifoGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    6b20:	b082      	sub	sp, #8
    6b22:	9001      	str	r0, [sp, #4]
    6b24:	9100      	str	r1, [sp, #0]
    (base->RXFGMASK) = Mask;
    6b26:	9b01      	ldr	r3, [sp, #4]
    6b28:	9a00      	ldr	r2, [sp, #0]
    6b2a:	649a      	str	r2, [r3, #72]	; 0x48
}
    6b2c:	bf00      	nop
    6b2e:	b002      	add	sp, #8
    6b30:	4770      	bx	lr

00006b32 <FlexCAN_SetTDCOffset>:
 */
static inline void FlexCAN_SetTDCOffset(FLEXCAN_Type * base,
                                        boolean enable,
                                        uint8 offset
                                       )
{
    6b32:	b084      	sub	sp, #16
    6b34:	9001      	str	r0, [sp, #4]
    6b36:	460b      	mov	r3, r1
    6b38:	f88d 3003 	strb.w	r3, [sp, #3]
    6b3c:	4613      	mov	r3, r2
    6b3e:	f88d 3002 	strb.w	r3, [sp, #2]
    uint32 tmp;

    tmp = base->FDCTRL;
    6b42:	9b01      	ldr	r3, [sp, #4]
    6b44:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    6b48:	9303      	str	r3, [sp, #12]
    tmp &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    6b4a:	9b03      	ldr	r3, [sp, #12]
    6b4c:	f423 431f 	bic.w	r3, r3, #40704	; 0x9f00
    6b50:	9303      	str	r3, [sp, #12]

    if (enable)
    6b52:	f89d 3003 	ldrb.w	r3, [sp, #3]
    6b56:	2b00      	cmp	r3, #0
    6b58:	d00b      	beq.n	6b72 <FlexCAN_SetTDCOffset+0x40>
    {
        tmp = tmp | FLEXCAN_FDCTRL_TDCEN_MASK;
    6b5a:	9b03      	ldr	r3, [sp, #12]
    6b5c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    6b60:	9303      	str	r3, [sp, #12]
        tmp = tmp | FLEXCAN_FDCTRL_TDCOFF(offset);
    6b62:	f89d 3002 	ldrb.w	r3, [sp, #2]
    6b66:	021b      	lsls	r3, r3, #8
    6b68:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    6b6c:	9a03      	ldr	r2, [sp, #12]
    6b6e:	4313      	orrs	r3, r2
    6b70:	9303      	str	r3, [sp, #12]
    }

    base->FDCTRL = tmp;
    6b72:	9b01      	ldr	r3, [sp, #4]
    6b74:	9a03      	ldr	r2, [sp, #12]
    6b76:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    6b7a:	bf00      	nop
    6b7c:	b004      	add	sp, #16
    6b7e:	4770      	bx	lr

00006b80 <FlexCAN_IsEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsEnabled(const FLEXCAN_Type * pBase)
{
    6b80:	b082      	sub	sp, #8
    6b82:	9001      	str	r0, [sp, #4]
    return (((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U) ? FALSE : TRUE;
    6b84:	9b01      	ldr	r3, [sp, #4]
    6b86:	681b      	ldr	r3, [r3, #0]
    6b88:	43db      	mvns	r3, r3
    6b8a:	0fdb      	lsrs	r3, r3, #31
    6b8c:	b2db      	uxtb	r3, r3
}
    6b8e:	4618      	mov	r0, r3
    6b90:	b002      	add	sp, #8
    6b92:	4770      	bx	lr

00006b94 <FlexCAN_SetFDEnabled>:
 */
static inline void FlexCAN_SetFDEnabled(FLEXCAN_Type * base,
                                        boolean enableFD,
                                        boolean enableBRS
                                       )
{
    6b94:	b082      	sub	sp, #8
    6b96:	9001      	str	r0, [sp, #4]
    6b98:	460b      	mov	r3, r1
    6b9a:	f88d 3003 	strb.w	r3, [sp, #3]
    6b9e:	4613      	mov	r3, r2
    6ba0:	f88d 3002 	strb.w	r3, [sp, #2]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FDEN_MASK) | FLEXCAN_MCR_FDEN(enableFD ? 1UL : 0UL);
    6ba4:	9b01      	ldr	r3, [sp, #4]
    6ba6:	681b      	ldr	r3, [r3, #0]
    6ba8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    6bac:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6bb0:	2a00      	cmp	r2, #0
    6bb2:	d002      	beq.n	6bba <FlexCAN_SetFDEnabled+0x26>
    6bb4:	f44f 6200 	mov.w	r2, #2048	; 0x800
    6bb8:	e000      	b.n	6bbc <FlexCAN_SetFDEnabled+0x28>
    6bba:	2200      	movs	r2, #0
    6bbc:	431a      	orrs	r2, r3
    6bbe:	9b01      	ldr	r3, [sp, #4]
    6bc0:	601a      	str	r2, [r3, #0]

    /* Enable BitRate Switch support from BRS_TX_MB field or ignore it */
    base->FDCTRL = (base->FDCTRL & ~FLEXCAN_FDCTRL_FDRATE_MASK) | FLEXCAN_FDCTRL_FDRATE(enableBRS ? 1UL : 0UL);
    6bc2:	9b01      	ldr	r3, [sp, #4]
    6bc4:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    6bc8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    6bcc:	f89d 2002 	ldrb.w	r2, [sp, #2]
    6bd0:	2a00      	cmp	r2, #0
    6bd2:	d002      	beq.n	6bda <FlexCAN_SetFDEnabled+0x46>
    6bd4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6bd8:	e000      	b.n	6bdc <FlexCAN_SetFDEnabled+0x48>
    6bda:	2200      	movs	r2, #0
    6bdc:	431a      	orrs	r2, r3
    6bde:	9b01      	ldr	r3, [sp, #4]
    6be0:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00

    /* Disable Transmission Delay Compensation by default */
    base->FDCTRL &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    6be4:	9b01      	ldr	r3, [sp, #4]
    6be6:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    6bea:	f423 421f 	bic.w	r2, r3, #40704	; 0x9f00
    6bee:	9b01      	ldr	r3, [sp, #4]
    6bf0:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    6bf4:	bf00      	nop
    6bf6:	b002      	add	sp, #8
    6bf8:	4770      	bx	lr

00006bfa <FlexCAN_SetListenOnlyMode>:
 *
 * @param   base    The FlexCAN base address
 * @param   enable  TRUE to enable; FALSE to disable
 */
static inline void FlexCAN_SetListenOnlyMode(FLEXCAN_Type * base, boolean enableListenOnly)
{
    6bfa:	b082      	sub	sp, #8
    6bfc:	9001      	str	r0, [sp, #4]
    6bfe:	460b      	mov	r3, r1
    6c00:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(enableListenOnly ? 1UL : 0UL);
    6c04:	9b01      	ldr	r3, [sp, #4]
    6c06:	685b      	ldr	r3, [r3, #4]
    6c08:	f023 0308 	bic.w	r3, r3, #8
    6c0c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6c10:	2a00      	cmp	r2, #0
    6c12:	d001      	beq.n	6c18 <FlexCAN_SetListenOnlyMode+0x1e>
    6c14:	2208      	movs	r2, #8
    6c16:	e000      	b.n	6c1a <FlexCAN_SetListenOnlyMode+0x20>
    6c18:	2200      	movs	r2, #0
    6c1a:	431a      	orrs	r2, r3
    6c1c:	9b01      	ldr	r3, [sp, #4]
    6c1e:	605a      	str	r2, [r3, #4]
}
    6c20:	bf00      	nop
    6c22:	b002      	add	sp, #8
    6c24:	4770      	bx	lr

00006c26 <FlexCAN_UnlockRxMsgBuff>:
 * @brief Unlocks the FlexCAN Rx message buffer.
 *
 * @param   base     The FlexCAN base address
 */
static inline void FlexCAN_UnlockRxMsgBuff(const FLEXCAN_Type * base)
{
    6c26:	b082      	sub	sp, #8
    6c28:	9001      	str	r0, [sp, #4]
    /* Unlock the mailbox by reading the free running timer */
    (void)base->TIMER;
    6c2a:	9b01      	ldr	r3, [sp, #4]
    6c2c:	689b      	ldr	r3, [r3, #8]
}
    6c2e:	bf00      	nop
    6c30:	b002      	add	sp, #8
    6c32:	4770      	bx	lr

00006c34 <FlexCAN_ClearMsgBuffIntStatusFlag>:
 *
 * @param   base        The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 */
static inline void FlexCAN_ClearMsgBuffIntStatusFlag(FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    6c34:	b084      	sub	sp, #16
    6c36:	9001      	str	r0, [sp, #4]
    6c38:	9100      	str	r1, [sp, #0]
    uint32 flag = ((uint32)1U << (msgBuffIdx % 32U));
    6c3a:	9b00      	ldr	r3, [sp, #0]
    6c3c:	f003 031f 	and.w	r3, r3, #31
    6c40:	2201      	movs	r2, #1
    6c42:	fa02 f303 	lsl.w	r3, r2, r3
    6c46:	9303      	str	r3, [sp, #12]

    /* Clear the corresponding message buffer interrupt flag*/
    if (msgBuffIdx < 32U)
    6c48:	9b00      	ldr	r3, [sp, #0]
    6c4a:	2b1f      	cmp	r3, #31
    6c4c:	d802      	bhi.n	6c54 <FlexCAN_ClearMsgBuffIntStatusFlag+0x20>
    {
        (base->IFLAG1) = (flag);
    6c4e:	9b01      	ldr	r3, [sp, #4]
    6c50:	9a03      	ldr	r2, [sp, #12]
    6c52:	631a      	str	r2, [r3, #48]	; 0x30
    else
    {
        (base->IFLAG4) = (flag);
    }
#endif
}
    6c54:	bf00      	nop
    6c56:	b004      	add	sp, #16
    6c58:	4770      	bx	lr

00006c5a <FlexCAN_GetBuffStatusFlag>:
 * @param   base                The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 * @return  flag        The value of interrupt flag of the message buffer.
 */
static inline uint8 FlexCAN_GetBuffStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    6c5a:	b084      	sub	sp, #16
    6c5c:	9001      	str	r0, [sp, #4]
    6c5e:	9100      	str	r1, [sp, #0]
    uint32 flag = 0U;
    6c60:	2300      	movs	r3, #0
    6c62:	9303      	str	r3, [sp, #12]

    if (msgBuffIdx < 32U)
    6c64:	9b00      	ldr	r3, [sp, #0]
    6c66:	2b1f      	cmp	r3, #31
    6c68:	d80e      	bhi.n	6c88 <FlexCAN_GetBuffStatusFlag+0x2e>
    {
        flag = ((base->IFLAG1 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    6c6a:	9b01      	ldr	r3, [sp, #4]
    6c6c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    6c6e:	9b00      	ldr	r3, [sp, #0]
    6c70:	f003 031f 	and.w	r3, r3, #31
    6c74:	2101      	movs	r1, #1
    6c76:	fa01 f303 	lsl.w	r3, r1, r3
    6c7a:	401a      	ands	r2, r3
    6c7c:	9b00      	ldr	r3, [sp, #0]
    6c7e:	f003 031f 	and.w	r3, r3, #31
    6c82:	fa22 f303 	lsr.w	r3, r2, r3
    6c86:	9303      	str	r3, [sp, #12]
    {
        flag = ((base->IFLAG4 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    }
#endif

    return (uint8)flag;
    6c88:	9b03      	ldr	r3, [sp, #12]
    6c8a:	b2db      	uxtb	r3, r3
}
    6c8c:	4618      	mov	r0, r3
    6c8e:	b004      	add	sp, #16
    6c90:	4770      	bx	lr

00006c92 <FlexCAN_SetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetFDTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6c92:	b082      	sub	sp, #8
    6c94:	9001      	str	r0, [sp, #4]
    6c96:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* Set FlexCAN time segments*/
    (base->FDCBT) = ((base->FDCBT) & ~((FLEXCAN_FDCBT_FPROPSEG_MASK | FLEXCAN_FDCBT_FPSEG2_MASK |
    6c98:	9b01      	ldr	r3, [sp, #4]
    6c9a:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    6c9e:	4b15      	ldr	r3, [pc, #84]	; (6cf4 <FlexCAN_SetFDTimeSegments+0x62>)
    6ca0:	4013      	ands	r3, r2
    6ca2:	9a01      	ldr	r2, [sp, #4]
    6ca4:	f8c2 3c04 	str.w	r3, [r2, #3076]	; 0xc04
                                        FLEXCAN_FDCBT_FPSEG1_MASK | FLEXCAN_FDCBT_FPRESDIV_MASK
                                       ) | FLEXCAN_FDCBT_FRJW_MASK
                                      )
                    );

    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    6ca8:	9b01      	ldr	r3, [sp, #4]
    6caa:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    6cae:	9b00      	ldr	r3, [sp, #0]
    6cb0:	681b      	ldr	r3, [r3, #0]
    6cb2:	029b      	lsls	r3, r3, #10
    6cb4:	f403 41f8 	and.w	r1, r3, #31744	; 0x7c00
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    6cb8:	9b00      	ldr	r3, [sp, #0]
    6cba:	689b      	ldr	r3, [r3, #8]
    6cbc:	f003 0307 	and.w	r3, r3, #7
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    6cc0:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    6cc2:	9b00      	ldr	r3, [sp, #0]
    6cc4:	685b      	ldr	r3, [r3, #4]
    6cc6:	015b      	lsls	r3, r3, #5
    6cc8:	b2db      	uxtb	r3, r3
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    6cca:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    6ccc:	9b00      	ldr	r3, [sp, #0]
    6cce:	68db      	ldr	r3, [r3, #12]
    6cd0:	0518      	lsls	r0, r3, #20
    6cd2:	4b09      	ldr	r3, [pc, #36]	; (6cf8 <FlexCAN_SetFDTimeSegments+0x66>)
    6cd4:	4003      	ands	r3, r0
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    6cd6:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FRJW(timeSeg->rJumpwidth)
    6cd8:	9b00      	ldr	r3, [sp, #0]
    6cda:	691b      	ldr	r3, [r3, #16]
    6cdc:	041b      	lsls	r3, r3, #16
    6cde:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    6ce2:	430b      	orrs	r3, r1
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    6ce4:	431a      	orrs	r2, r3
    6ce6:	9b01      	ldr	r3, [sp, #4]
    6ce8:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
                                     )
                    );
}
    6cec:	bf00      	nop
    6cee:	b002      	add	sp, #8
    6cf0:	4770      	bx	lr
    6cf2:	bf00      	nop
    6cf4:	c0088318 	.word	0xc0088318
    6cf8:	3ff00000 	.word	0x3ff00000

00006cfc <FlexCAN_SetTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6cfc:	b082      	sub	sp, #8
    6cfe:	9001      	str	r0, [sp, #4]
    6d00:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    (base->CTRL1) = ((base->CTRL1) & ~((FLEXCAN_CTRL1_PROPSEG_MASK | FLEXCAN_CTRL1_PSEG2_MASK |
    6d02:	9b01      	ldr	r3, [sp, #4]
    6d04:	685a      	ldr	r2, [r3, #4]
    6d06:	f64f 73f8 	movw	r3, #65528	; 0xfff8
    6d0a:	4013      	ands	r3, r2
    6d0c:	9a01      	ldr	r2, [sp, #4]
    6d0e:	6053      	str	r3, [r2, #4]
                                        FLEXCAN_CTRL1_PSEG1_MASK | FLEXCAN_CTRL1_PRESDIV_MASK
                                       ) | FLEXCAN_CTRL1_RJW_MASK
                                      )
                    );

    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    6d10:	9b01      	ldr	r3, [sp, #4]
    6d12:	685a      	ldr	r2, [r3, #4]
    6d14:	9b00      	ldr	r3, [sp, #0]
    6d16:	681b      	ldr	r3, [r3, #0]
    6d18:	f003 0107 	and.w	r1, r3, #7
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    6d1c:	9b00      	ldr	r3, [sp, #0]
    6d1e:	689b      	ldr	r3, [r3, #8]
    6d20:	041b      	lsls	r3, r3, #16
    6d22:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    6d26:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    6d28:	9b00      	ldr	r3, [sp, #0]
    6d2a:	685b      	ldr	r3, [r3, #4]
    6d2c:	04db      	lsls	r3, r3, #19
    6d2e:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    6d32:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    6d34:	9b00      	ldr	r3, [sp, #0]
    6d36:	68db      	ldr	r3, [r3, #12]
    6d38:	061b      	lsls	r3, r3, #24
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    6d3a:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_RJW(timeSeg->rJumpwidth)
    6d3c:	9b00      	ldr	r3, [sp, #0]
    6d3e:	691b      	ldr	r3, [r3, #16]
    6d40:	059b      	lsls	r3, r3, #22
    6d42:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    6d46:	430b      	orrs	r3, r1
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    6d48:	431a      	orrs	r2, r3
    6d4a:	9b01      	ldr	r3, [sp, #4]
    6d4c:	605a      	str	r2, [r3, #4]
                                     )
                    );
}
    6d4e:	bf00      	nop
    6d50:	b002      	add	sp, #8
    6d52:	4770      	bx	lr

00006d54 <FlexCAN_SetExtendedTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetExtendedTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6d54:	b082      	sub	sp, #8
    6d56:	9001      	str	r0, [sp, #4]
    6d58:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* If extended bit time definitions are enabled, use CBT register */
    (base->CBT) = ((base->CBT) & ~((FLEXCAN_CBT_EPROPSEG_MASK | FLEXCAN_CBT_EPSEG2_MASK |
    6d5a:	9b01      	ldr	r3, [sp, #4]
    6d5c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6d5e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
    6d62:	9b01      	ldr	r3, [sp, #4]
    6d64:	651a      	str	r2, [r3, #80]	; 0x50
                                    FLEXCAN_CBT_EPSEG1_MASK | FLEXCAN_CBT_EPRESDIV_MASK
                                   ) | FLEXCAN_CBT_ERJW_MASK
                                  )
                  );

    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    6d66:	9b01      	ldr	r3, [sp, #4]
    6d68:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    6d6a:	9b00      	ldr	r3, [sp, #0]
    6d6c:	681b      	ldr	r3, [r3, #0]
    6d6e:	029b      	lsls	r3, r3, #10
    6d70:	b299      	uxth	r1, r3
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    6d72:	9b00      	ldr	r3, [sp, #0]
    6d74:	689b      	ldr	r3, [r3, #8]
    6d76:	f003 031f 	and.w	r3, r3, #31
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    6d7a:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    6d7c:	9b00      	ldr	r3, [sp, #0]
    6d7e:	685b      	ldr	r3, [r3, #4]
    6d80:	015b      	lsls	r3, r3, #5
    6d82:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    6d86:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    6d88:	9b00      	ldr	r3, [sp, #0]
    6d8a:	68db      	ldr	r3, [r3, #12]
    6d8c:	0558      	lsls	r0, r3, #21
    6d8e:	4b07      	ldr	r3, [pc, #28]	; (6dac <FlexCAN_SetExtendedTimeSegments+0x58>)
    6d90:	4003      	ands	r3, r0
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    6d92:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_ERJW(timeSeg->rJumpwidth)
    6d94:	9b00      	ldr	r3, [sp, #0]
    6d96:	691b      	ldr	r3, [r3, #16]
    6d98:	041b      	lsls	r3, r3, #16
    6d9a:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    6d9e:	430b      	orrs	r3, r1
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    6da0:	431a      	orrs	r2, r3
    6da2:	9b01      	ldr	r3, [sp, #4]
    6da4:	651a      	str	r2, [r3, #80]	; 0x50
                                 )
                  );
}
    6da6:	bf00      	nop
    6da8:	b002      	add	sp, #8
    6daa:	4770      	bx	lr
    6dac:	7fe00000 	.word	0x7fe00000

00006db0 <FlexCAN_GetExtendedTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetExtendedTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6db0:	b082      	sub	sp, #8
    6db2:	9001      	str	r0, [sp, #4]
    6db4:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CBT) & FLEXCAN_CBT_EPRESDIV_MASK) >> FLEXCAN_CBT_EPRESDIV_SHIFT;
    6db6:	9b01      	ldr	r3, [sp, #4]
    6db8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6dba:	0d5b      	lsrs	r3, r3, #21
    6dbc:	f3c3 0209 	ubfx	r2, r3, #0, #10
    6dc0:	9b00      	ldr	r3, [sp, #0]
    6dc2:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CBT) & FLEXCAN_CBT_EPROPSEG_MASK) >> FLEXCAN_CBT_EPROPSEG_SHIFT;
    6dc4:	9b01      	ldr	r3, [sp, #4]
    6dc6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6dc8:	0a9b      	lsrs	r3, r3, #10
    6dca:	f003 023f 	and.w	r2, r3, #63	; 0x3f
    6dce:	9b00      	ldr	r3, [sp, #0]
    6dd0:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CBT) & FLEXCAN_CBT_EPSEG1_MASK) >> FLEXCAN_CBT_EPSEG1_SHIFT;
    6dd2:	9b01      	ldr	r3, [sp, #4]
    6dd4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6dd6:	095b      	lsrs	r3, r3, #5
    6dd8:	f003 021f 	and.w	r2, r3, #31
    6ddc:	9b00      	ldr	r3, [sp, #0]
    6dde:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CBT) & FLEXCAN_CBT_EPSEG2_MASK) >> FLEXCAN_CBT_EPSEG2_SHIFT;
    6de0:	9b01      	ldr	r3, [sp, #4]
    6de2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6de4:	f003 021f 	and.w	r2, r3, #31
    6de8:	9b00      	ldr	r3, [sp, #0]
    6dea:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CBT) & FLEXCAN_CBT_ERJW_MASK) >> FLEXCAN_CBT_ERJW_SHIFT;
    6dec:	9b01      	ldr	r3, [sp, #4]
    6dee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6df0:	0c1b      	lsrs	r3, r3, #16
    6df2:	f003 021f 	and.w	r2, r3, #31
    6df6:	9b00      	ldr	r3, [sp, #0]
    6df8:	611a      	str	r2, [r3, #16]
}
    6dfa:	bf00      	nop
    6dfc:	b002      	add	sp, #8
    6dfe:	4770      	bx	lr

00006e00 <FlexCAN_GetTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6e00:	b082      	sub	sp, #8
    6e02:	9001      	str	r0, [sp, #4]
    6e04:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CTRL1) & FLEXCAN_CTRL1_PRESDIV_MASK) >> FLEXCAN_CTRL1_PRESDIV_SHIFT;
    6e06:	9b01      	ldr	r3, [sp, #4]
    6e08:	685b      	ldr	r3, [r3, #4]
    6e0a:	0e1b      	lsrs	r3, r3, #24
    6e0c:	b2da      	uxtb	r2, r3
    6e0e:	9b00      	ldr	r3, [sp, #0]
    6e10:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CTRL1) & FLEXCAN_CTRL1_PROPSEG_MASK) >> FLEXCAN_CTRL1_PROPSEG_SHIFT;
    6e12:	9b01      	ldr	r3, [sp, #4]
    6e14:	685b      	ldr	r3, [r3, #4]
    6e16:	f003 0207 	and.w	r2, r3, #7
    6e1a:	9b00      	ldr	r3, [sp, #0]
    6e1c:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG1_MASK) >> FLEXCAN_CTRL1_PSEG1_SHIFT;
    6e1e:	9b01      	ldr	r3, [sp, #4]
    6e20:	685b      	ldr	r3, [r3, #4]
    6e22:	0cdb      	lsrs	r3, r3, #19
    6e24:	f003 0207 	and.w	r2, r3, #7
    6e28:	9b00      	ldr	r3, [sp, #0]
    6e2a:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG2_MASK) >> FLEXCAN_CTRL1_PSEG2_SHIFT;
    6e2c:	9b01      	ldr	r3, [sp, #4]
    6e2e:	685b      	ldr	r3, [r3, #4]
    6e30:	0c1b      	lsrs	r3, r3, #16
    6e32:	f003 0207 	and.w	r2, r3, #7
    6e36:	9b00      	ldr	r3, [sp, #0]
    6e38:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CTRL1) & FLEXCAN_CTRL1_RJW_MASK) >> FLEXCAN_CTRL1_RJW_SHIFT;
    6e3a:	9b01      	ldr	r3, [sp, #4]
    6e3c:	685b      	ldr	r3, [r3, #4]
    6e3e:	0d9b      	lsrs	r3, r3, #22
    6e40:	f003 0203 	and.w	r2, r3, #3
    6e44:	9b00      	ldr	r3, [sp, #0]
    6e46:	611a      	str	r2, [r3, #16]
}
    6e48:	bf00      	nop
    6e4a:	b002      	add	sp, #8
    6e4c:	4770      	bx	lr

00006e4e <FlexCAN_GetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetFDTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    6e4e:	b082      	sub	sp, #8
    6e50:	9001      	str	r0, [sp, #4]
    6e52:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->FDCBT) & FLEXCAN_FDCBT_FPRESDIV_MASK) >> FLEXCAN_FDCBT_FPRESDIV_SHIFT;
    6e54:	9b01      	ldr	r3, [sp, #4]
    6e56:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    6e5a:	0d1b      	lsrs	r3, r3, #20
    6e5c:	f3c3 0209 	ubfx	r2, r3, #0, #10
    6e60:	9b00      	ldr	r3, [sp, #0]
    6e62:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->FDCBT) & FLEXCAN_FDCBT_FPROPSEG_MASK) >> FLEXCAN_FDCBT_FPROPSEG_SHIFT;
    6e64:	9b01      	ldr	r3, [sp, #4]
    6e66:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    6e6a:	0a9b      	lsrs	r3, r3, #10
    6e6c:	f003 021f 	and.w	r2, r3, #31
    6e70:	9b00      	ldr	r3, [sp, #0]
    6e72:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG1_MASK) >> FLEXCAN_FDCBT_FPSEG1_SHIFT;
    6e74:	9b01      	ldr	r3, [sp, #4]
    6e76:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    6e7a:	095b      	lsrs	r3, r3, #5
    6e7c:	f003 0207 	and.w	r2, r3, #7
    6e80:	9b00      	ldr	r3, [sp, #0]
    6e82:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG2_MASK) >> FLEXCAN_FDCBT_FPSEG2_SHIFT;
    6e84:	9b01      	ldr	r3, [sp, #4]
    6e86:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    6e8a:	f003 0207 	and.w	r2, r3, #7
    6e8e:	9b00      	ldr	r3, [sp, #0]
    6e90:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->FDCBT) & FLEXCAN_FDCBT_FRJW_MASK) >> FLEXCAN_FDCBT_FRJW_SHIFT;
    6e92:	9b01      	ldr	r3, [sp, #4]
    6e94:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    6e98:	0c1b      	lsrs	r3, r3, #16
    6e9a:	f003 0207 	and.w	r2, r3, #7
    6e9e:	9b00      	ldr	r3, [sp, #0]
    6ea0:	611a      	str	r2, [r3, #16]
}
    6ea2:	bf00      	nop
    6ea4:	b002      	add	sp, #8
    6ea6:	4770      	bx	lr

00006ea8 <FlexCAN_IsExCbtEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsExCbtEnabled(const FLEXCAN_Type * pBase)
{
    6ea8:	b082      	sub	sp, #8
    6eaa:	9001      	str	r0, [sp, #4]
    return (0U == ((pBase->CBT & FLEXCAN_CBT_BTF_MASK) >> FLEXCAN_CBT_BTF_SHIFT)) ? FALSE : TRUE;
    6eac:	9b01      	ldr	r3, [sp, #4]
    6eae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6eb0:	0fdb      	lsrs	r3, r3, #31
    6eb2:	b2db      	uxtb	r3, r3
}
    6eb4:	4618      	mov	r0, r3
    6eb6:	b002      	add	sp, #8
    6eb8:	4770      	bx	lr

00006eba <FlexCAN_EnableExtCbt>:
 *
 * @param   base    The FlexCAN base address
 * @param   enableCBT Enable/Disable use of Extent Time Segments
 */
static inline void FlexCAN_EnableExtCbt(FLEXCAN_Type * base, boolean enableCBT)
{   /* Enable the use of extended bit time definitions */
    6eba:	b082      	sub	sp, #8
    6ebc:	9001      	str	r0, [sp, #4]
    6ebe:	460b      	mov	r3, r1
    6ec0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CBT = (base->CBT & ~FLEXCAN_CBT_BTF_MASK) | FLEXCAN_CBT_BTF(enableCBT ? 1UL : 0UL);
    6ec4:	9b01      	ldr	r3, [sp, #4]
    6ec6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6ec8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    6ecc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6ed0:	2a00      	cmp	r2, #0
    6ed2:	d002      	beq.n	6eda <FlexCAN_EnableExtCbt+0x20>
    6ed4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6ed8:	e000      	b.n	6edc <FlexCAN_EnableExtCbt+0x22>
    6eda:	2200      	movs	r2, #0
    6edc:	431a      	orrs	r2, r3
    6ede:	9b01      	ldr	r3, [sp, #4]
    6ee0:	651a      	str	r2, [r3, #80]	; 0x50
}
    6ee2:	bf00      	nop
    6ee4:	b002      	add	sp, #8
    6ee6:	4770      	bx	lr

00006ee8 <FlexCAN_SetSelfReception>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Enable/Disable Self Reception
 */
static inline void FlexCAN_SetSelfReception(FLEXCAN_Type * base, boolean enable)
{
    6ee8:	b082      	sub	sp, #8
    6eea:	9001      	str	r0, [sp, #4]
    6eec:	460b      	mov	r3, r1
    6eee:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    6ef2:	9b01      	ldr	r3, [sp, #4]
    6ef4:	681b      	ldr	r3, [r3, #0]
    6ef6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    6efa:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6efe:	2a00      	cmp	r2, #0
    6f00:	d001      	beq.n	6f06 <FlexCAN_SetSelfReception+0x1e>
    6f02:	2200      	movs	r2, #0
    6f04:	e001      	b.n	6f0a <FlexCAN_SetSelfReception+0x22>
    6f06:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    6f0a:	431a      	orrs	r2, r3
    6f0c:	9b01      	ldr	r3, [sp, #4]
    6f0e:	601a      	str	r2, [r3, #0]
}
    6f10:	bf00      	nop
    6f12:	b002      	add	sp, #8
    6f14:	4770      	bx	lr

00006f16 <FlexCAN_IsFDEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsFDEnabled(const FLEXCAN_Type * base)
{
    6f16:	b082      	sub	sp, #8
    6f18:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    6f1a:	9b01      	ldr	r3, [sp, #4]
    6f1c:	681b      	ldr	r3, [r3, #0]
    6f1e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    6f22:	2b00      	cmp	r3, #0
    6f24:	bf14      	ite	ne
    6f26:	2301      	movne	r3, #1
    6f28:	2300      	moveq	r3, #0
    6f2a:	b2db      	uxtb	r3, r3
}
    6f2c:	4618      	mov	r0, r3
    6f2e:	b002      	add	sp, #8
    6f30:	4770      	bx	lr

00006f32 <FlexCAN_IsListenOnlyModeEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsListenOnlyModeEnabled(const FLEXCAN_Type * base)
{
    6f32:	b082      	sub	sp, #8
    6f34:	9001      	str	r0, [sp, #4]
    return (((base->CTRL1 & (FLEXCAN_CTRL1_LOM_MASK)) != 0U) ? TRUE : FALSE);
    6f36:	9b01      	ldr	r3, [sp, #4]
    6f38:	685b      	ldr	r3, [r3, #4]
    6f3a:	f003 0308 	and.w	r3, r3, #8
    6f3e:	2b00      	cmp	r3, #0
    6f40:	bf14      	ite	ne
    6f42:	2301      	movne	r3, #1
    6f44:	2300      	moveq	r3, #0
    6f46:	b2db      	uxtb	r3, r3
}
    6f48:	4618      	mov	r0, r3
    6f4a:	b002      	add	sp, #8
    6f4c:	4770      	bx	lr

00006f4e <RxFifoOcuppiedLastMsgBuff>:
 *
 * @param   x    Number of Configured RxFIFO Filters
 * @return  number of last MB occupied by RxFIFO
 */
static inline uint32 RxFifoOcuppiedLastMsgBuff(uint8 x)
{
    6f4e:	b082      	sub	sp, #8
    6f50:	4603      	mov	r3, r0
    6f52:	f88d 3007 	strb.w	r3, [sp, #7]
    return 5U + (((((uint32)x) + 1U) * 8U) / 4U);
    6f56:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6f5a:	3301      	adds	r3, #1
    6f5c:	00db      	lsls	r3, r3, #3
    6f5e:	089b      	lsrs	r3, r3, #2
    6f60:	3305      	adds	r3, #5
}
    6f62:	4618      	mov	r0, r3
    6f64:	b002      	add	sp, #8
    6f66:	4770      	bx	lr

00006f68 <FlexCAN_SetClkSrc>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Specifies if The CAN engine clock source is the oscillator clock(FALSE) or peripheral clock(TRUE).
 */
static inline void FlexCAN_SetClkSrc(FLEXCAN_Type * base, boolean enable)
{
    6f68:	b082      	sub	sp, #8
    6f6a:	9001      	str	r0, [sp, #4]
    6f6c:	460b      	mov	r3, r1
    6f6e:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_CLKSRC_MASK) | FLEXCAN_CTRL1_CLKSRC(enable ? 1UL : 0UL);
    6f72:	9b01      	ldr	r3, [sp, #4]
    6f74:	685b      	ldr	r3, [r3, #4]
    6f76:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    6f7a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6f7e:	2a00      	cmp	r2, #0
    6f80:	d002      	beq.n	6f88 <FlexCAN_SetClkSrc+0x20>
    6f82:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    6f86:	e000      	b.n	6f8a <FlexCAN_SetClkSrc+0x22>
    6f88:	2200      	movs	r2, #0
    6f8a:	431a      	orrs	r2, r3
    6f8c:	9b01      	ldr	r3, [sp, #4]
    6f8e:	605a      	str	r2, [r3, #4]
}
    6f90:	bf00      	nop
    6f92:	b002      	add	sp, #8
    6f94:	4770      	bx	lr

00006f96 <FlexCAN_GetMsgBuffIntStatusFlag>:
 * @param   base  The FlexCAN base address
 * @param   msgBuffIdx       Index of the message buffer
 * @return  the individual Message Buffer interrupt flag (0 and 1 are the flag value)
 */
static inline uint8 FlexCAN_GetMsgBuffIntStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    6f96:	b084      	sub	sp, #16
    6f98:	9001      	str	r0, [sp, #4]
    6f9a:	9100      	str	r1, [sp, #0]
    /* TODO: This need to be protected multithread access*/
    uint8 flag = 0;
    6f9c:	2300      	movs	r3, #0
    6f9e:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 mask;

    if (msgBuffIdx < 32U)
    6fa2:	9b00      	ldr	r3, [sp, #0]
    6fa4:	2b1f      	cmp	r3, #31
    6fa6:	d810      	bhi.n	6fca <FlexCAN_GetMsgBuffIntStatusFlag+0x34>
    {
        mask = base->IMASK1 & FLEXCAN_IMASK1_BUF31TO0M_MASK;
    6fa8:	9b01      	ldr	r3, [sp, #4]
    6faa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6fac:	9302      	str	r3, [sp, #8]
        flag = (uint8)(((base->IFLAG1 & mask) >> (msgBuffIdx % 32U)) & 1U);
    6fae:	9b01      	ldr	r3, [sp, #4]
    6fb0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    6fb2:	9b02      	ldr	r3, [sp, #8]
    6fb4:	401a      	ands	r2, r3
    6fb6:	9b00      	ldr	r3, [sp, #0]
    6fb8:	f003 031f 	and.w	r3, r3, #31
    6fbc:	fa22 f303 	lsr.w	r3, r2, r3
    6fc0:	b2db      	uxtb	r3, r3
    6fc2:	f003 0301 	and.w	r3, r3, #1
    6fc6:	f88d 300f 	strb.w	r3, [sp, #15]
        mask = base->IMASK4 & FLEXCAN_IMASK4_BUF127TO96M_MASK;
        flag = (uint8)(((base->IFLAG4 & mask) >> (msgBuffIdx % 32U)) & 1U);
    }
#endif

    return flag;
    6fca:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6fce:	4618      	mov	r0, r3
    6fd0:	b004      	add	sp, #16
    6fd2:	4770      	bx	lr

00006fd4 <FlexCAN_SetRxMsgBuffGlobalMask>:
 *
 * @param   base  The FlexCAN base address
 * @param   Mask  Mask Value
 */
static inline void FlexCAN_SetRxMsgBuffGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    6fd4:	b082      	sub	sp, #8
    6fd6:	9001      	str	r0, [sp, #4]
    6fd8:	9100      	str	r1, [sp, #0]
    (base->RXMGMASK) = Mask;
    6fda:	9b01      	ldr	r3, [sp, #4]
    6fdc:	9a00      	ldr	r2, [sp, #0]
    6fde:	611a      	str	r2, [r3, #16]
}
    6fe0:	bf00      	nop
    6fe2:	b002      	add	sp, #8
    6fe4:	4770      	bx	lr

00006fe6 <FlexCAN_SetRxIndividualMask>:
 */
static inline void FlexCAN_SetRxIndividualMask(FLEXCAN_Type * base,
                                               uint32 msgBuffIdx,
                                               uint32 mask
                                              )
{
    6fe6:	b084      	sub	sp, #16
    6fe8:	9003      	str	r0, [sp, #12]
    6fea:	9102      	str	r1, [sp, #8]
    6fec:	9201      	str	r2, [sp, #4]
    base->RXIMR[msgBuffIdx] = mask;
    6fee:	9b03      	ldr	r3, [sp, #12]
    6ff0:	9a02      	ldr	r2, [sp, #8]
    6ff2:	f502 7208 	add.w	r2, r2, #544	; 0x220
    6ff6:	9901      	ldr	r1, [sp, #4]
    6ff8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6ffc:	bf00      	nop
    6ffe:	b004      	add	sp, #16
    7000:	4770      	bx	lr

00007002 <FlexCAN_SetTxArbitrationStartDelay>:
 *
 * @param   base  The FlexCAN base address
 * @param   tasd  The Tx arbitration start delay value
 */
static inline void FlexCAN_SetTxArbitrationStartDelay(FLEXCAN_Type * base, uint8 tasd)
{
    7002:	b082      	sub	sp, #8
    7004:	9001      	str	r0, [sp, #4]
    7006:	460b      	mov	r3, r1
    7008:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_TASD_MASK) | FLEXCAN_CTRL2_TASD(tasd);
    700c:	9b01      	ldr	r3, [sp, #4]
    700e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7010:	f423 0278 	bic.w	r2, r3, #16252928	; 0xf80000
    7014:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7018:	04db      	lsls	r3, r3, #19
    701a:	f403 0378 	and.w	r3, r3, #16252928	; 0xf80000
    701e:	431a      	orrs	r2, r3
    7020:	9b01      	ldr	r3, [sp, #4]
    7022:	635a      	str	r2, [r3, #52]	; 0x34
}
    7024:	bf00      	nop
    7026:	b002      	add	sp, #8
    7028:	4770      	bx	lr

0000702a <FlexCAN_SetRxMaskType>:
 *
 * @param   base  The FlexCAN base address
 * @param   type         The FlexCAN Rx mask type
 */
static inline void FlexCAN_SetRxMaskType(FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
    702a:	b082      	sub	sp, #8
    702c:	9001      	str	r0, [sp, #4]
    702e:	9100      	str	r1, [sp, #0]
    /* Set RX masking type (RX global mask or RX individual mask)*/
    if (FLEXCAN_RX_MASK_GLOBAL == type)
    7030:	9b00      	ldr	r3, [sp, #0]
    7032:	2b00      	cmp	r3, #0
    7034:	d106      	bne.n	7044 <FlexCAN_SetRxMaskType+0x1a>
    {
        /* Enable Global RX masking */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(0U);
    7036:	9b01      	ldr	r3, [sp, #4]
    7038:	681b      	ldr	r3, [r3, #0]
    703a:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
    703e:	9b01      	ldr	r3, [sp, #4]
    7040:	601a      	str	r2, [r3, #0]
    else
    {
        /* Enable Individual Rx Masking and Queue */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    }
}
    7042:	e005      	b.n	7050 <FlexCAN_SetRxMaskType+0x26>
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    7044:	9b01      	ldr	r3, [sp, #4]
    7046:	681b      	ldr	r3, [r3, #0]
    7048:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
    704c:	9b01      	ldr	r3, [sp, #4]
    704e:	601a      	str	r2, [r3, #0]
}
    7050:	bf00      	nop
    7052:	b002      	add	sp, #8
    7054:	4770      	bx	lr

00007056 <FlexCAN_SetRegDefaultVal>:
 * @brief Will set Flexcan Peripheral Register to default val.
 *
 * @param   base    The FlexCAN base address
 */
static inline void FlexCAN_SetRegDefaultVal(FLEXCAN_Type * base)
{
    7056:	b500      	push	{lr}
    7058:	b083      	sub	sp, #12
    705a:	9001      	str	r0, [sp, #4]
        base->ERFCR = FLEXCAN_IP_ERFCR_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    705c:	9801      	ldr	r0, [sp, #4]
    705e:	f002 ff15 	bl	9e8c <FlexCAN_IsFDAvailable>
    7062:	4603      	mov	r3, r0
    7064:	2b00      	cmp	r3, #0
    7066:	d007      	beq.n	7078 <FlexCAN_SetRegDefaultVal+0x22>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    7068:	9b01      	ldr	r3, [sp, #4]
    706a:	2200      	movs	r2, #0
    706c:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    7070:	9b01      	ldr	r3, [sp, #4]
    7072:	4a12      	ldr	r2, [pc, #72]	; (70bc <FlexCAN_SetRegDefaultVal+0x66>)
    7074:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    {
        base->IFLAG2 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
        base->IMASK2 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */
    base->IFLAG1 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
    7078:	9b01      	ldr	r3, [sp, #4]
    707a:	f04f 32ff 	mov.w	r2, #4294967295
    707e:	631a      	str	r2, [r3, #48]	; 0x30
    base->IMASK1 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    7080:	9b01      	ldr	r3, [sp, #4]
    7082:	2200      	movs	r2, #0
    7084:	629a      	str	r2, [r3, #40]	; 0x28
    base->CBT = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    7086:	9b01      	ldr	r3, [sp, #4]
    7088:	2200      	movs	r2, #0
    708a:	651a      	str	r2, [r3, #80]	; 0x50
    base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    708c:	9b01      	ldr	r3, [sp, #4]
    708e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7092:	635a      	str	r2, [r3, #52]	; 0x34
    base->ESR1 = FLEXCAN_IP_ESR1_DEFAULT_VALUE_U32;
    7094:	9b01      	ldr	r3, [sp, #4]
    7096:	4a0a      	ldr	r2, [pc, #40]	; (70c0 <FlexCAN_SetRegDefaultVal+0x6a>)
    7098:	621a      	str	r2, [r3, #32]
    base->ECR = FLEXCAN_IP_ECR_DEFAULT_VALUE_U32;
    709a:	9b01      	ldr	r3, [sp, #4]
    709c:	2200      	movs	r2, #0
    709e:	61da      	str	r2, [r3, #28]
    base->TIMER = FLEXCAN_IP_TIMER_DEFAULT_VALUE_U32;
    70a0:	9b01      	ldr	r3, [sp, #4]
    70a2:	2200      	movs	r2, #0
    70a4:	609a      	str	r2, [r3, #8]
    base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    70a6:	9b01      	ldr	r3, [sp, #4]
    70a8:	2200      	movs	r2, #0
    70aa:	605a      	str	r2, [r3, #4]
    base->EPRS  = FLEXCAN_IP_EPRS_DEFAULT_VALUE_U32;
    base->ENCBT = FLEXCAN_IP_ENCBT_DEFAULT_VALUE_U32;
    base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
    base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
    base->MCR = FLEXCAN_IP_MCR_DEFAULT_VALUE_U32;
    70ac:	9b01      	ldr	r3, [sp, #4]
    70ae:	4a05      	ldr	r2, [pc, #20]	; (70c4 <FlexCAN_SetRegDefaultVal+0x6e>)
    70b0:	601a      	str	r2, [r3, #0]
}
    70b2:	bf00      	nop
    70b4:	b003      	add	sp, #12
    70b6:	f85d fb04 	ldr.w	pc, [sp], #4
    70ba:	bf00      	nop
    70bc:	80004100 	.word	0x80004100
    70c0:	0003b006 	.word	0x0003b006
    70c4:	d890000f 	.word	0xd890000f

000070c8 <FlexCAN_InitRxFifo>:
 * Description   : Initialize fifo and dma if requested.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitRxFifo(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    70c8:	b500      	push	{lr}
    70ca:	b085      	sub	sp, #20
    70cc:	9001      	str	r0, [sp, #4]
    70ce:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    70d0:	2300      	movs	r3, #0
    70d2:	9303      	str	r3, [sp, #12]

    /* Enable RxFIFO feature, if requested. This might fail if the FD mode is enabled. */
    if (Flexcan_Ip_pData->is_rx_fifo_needed)
    70d4:	9b00      	ldr	r3, [sp, #0]
    70d6:	7a1b      	ldrb	r3, [r3, #8]
    70d8:	2b00      	cmp	r3, #0
    70da:	d006      	beq.n	70ea <FlexCAN_InitRxFifo+0x22>
    {
        eResult = FlexCAN_EnableRxFifo(pBase, (uint32)Flexcan_Ip_pData->num_id_filters);
    70dc:	9b00      	ldr	r3, [sp, #0]
    70de:	685b      	ldr	r3, [r3, #4]
    70e0:	4619      	mov	r1, r3
    70e2:	9801      	ldr	r0, [sp, #4]
    70e4:	f002 fe8e 	bl	9e04 <FlexCAN_EnableRxFifo>
    70e8:	9003      	str	r0, [sp, #12]
        FlexCAN_SetRxFifoDMA(pBase, FALSE);
    }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    return eResult;
    70ea:	9b03      	ldr	r3, [sp, #12]
}
    70ec:	4618      	mov	r0, r3
    70ee:	b005      	add	sp, #20
    70f0:	f85d fb04 	ldr.w	pc, [sp], #4

000070f4 <FlexCAN_InitCtroll>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitCtroll(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    70f4:	b500      	push	{lr}
    70f6:	b085      	sub	sp, #20
    70f8:	9001      	str	r0, [sp, #4]
    70fa:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    70fc:	2300      	movs	r3, #0
    70fe:	9303      	str	r3, [sp, #12]
    /* Disable the self reception feature if FlexCAN is not in loopback mode. */
    if (Flexcan_Ip_pData->flexcanMode != FLEXCAN_LOOPBACK_MODE)
    7100:	9b00      	ldr	r3, [sp, #0]
    7102:	68db      	ldr	r3, [r3, #12]
    7104:	2b02      	cmp	r3, #2
    7106:	d003      	beq.n	7110 <FlexCAN_InitCtroll+0x1c>
    {
        FlexCAN_SetSelfReception(pBase, FALSE);
    7108:	2100      	movs	r1, #0
    710a:	9801      	ldr	r0, [sp, #4]
    710c:	f7ff feec 	bl	6ee8 <FlexCAN_SetSelfReception>
    }

    /* Init legacy fifo, enhanced fifo if requested. */
    eResult = FlexCAN_InitRxFifo(pBase, Flexcan_Ip_pData);
    7110:	9900      	ldr	r1, [sp, #0]
    7112:	9801      	ldr	r0, [sp, #4]
    7114:	f7ff ffd8 	bl	70c8 <FlexCAN_InitRxFifo>
    7118:	9003      	str	r0, [sp, #12]
    if (eResult != FLEXCAN_STATUS_SUCCESS)
    711a:	9b03      	ldr	r3, [sp, #12]
    711c:	2b00      	cmp	r3, #0
    711e:	d006      	beq.n	712e <FlexCAN_InitCtroll+0x3a>
    {
        /* To enter Disable Mode requires FreezMode first */
        (void)FlexCAN_EnterFreezeMode(pBase);
    7120:	9801      	ldr	r0, [sp, #4]
    7122:	f002 fc93 	bl	9a4c <FlexCAN_EnterFreezeMode>
        (void)FlexCAN_Disable(pBase);
    7126:	9801      	ldr	r0, [sp, #4]
    7128:	f002 fd5a 	bl	9be0 <FlexCAN_Disable>
    712c:	e00b      	b.n	7146 <FlexCAN_InitCtroll+0x52>
    }
    else
    {
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set payload size. */
        FlexCAN_SetPayloadSize(pBase, &Flexcan_Ip_pData->payload);
    712e:	9b00      	ldr	r3, [sp, #0]
    7130:	3314      	adds	r3, #20
    7132:	4619      	mov	r1, r3
    7134:	9801      	ldr	r0, [sp, #4]
    7136:	f002 fecb 	bl	9ed0 <FlexCAN_SetPayloadSize>
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
            (void)FlexCAN_Disable(pBase);
        }
    #else
        (void)FlexCAN_SetMaxMsgBuffNum(pBase, Flexcan_Ip_pData->max_num_mb);
    713a:	9b00      	ldr	r3, [sp, #0]
    713c:	681b      	ldr	r3, [r3, #0]
    713e:	4619      	mov	r1, r3
    7140:	9801      	ldr	r0, [sp, #4]
    7142:	f003 fa47 	bl	a5d4 <FlexCAN_SetMaxMsgBuffNum>
    #endif /* FLEXCAN_IP_DEV_ERROR_DETECT */
    }
    return eResult;
    7146:	9b03      	ldr	r3, [sp, #12]
}
    7148:	4618      	mov	r0, r3
    714a:	b005      	add	sp, #20
    714c:	f85d fb04 	ldr.w	pc, [sp], #4

00007150 <FlexCAN_InitController>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitController(uint8 Instance, FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    7150:	b500      	push	{lr}
    7152:	b087      	sub	sp, #28
    7154:	4603      	mov	r3, r0
    7156:	9102      	str	r1, [sp, #8]
    7158:	9201      	str	r2, [sp, #4]
    715a:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    715e:	2300      	movs	r3, #0
    7160:	9305      	str	r3, [sp, #20]

    if (FlexCAN_IsEnabled(pBase))
    7162:	9802      	ldr	r0, [sp, #8]
    7164:	f7ff fd0c 	bl	6b80 <FlexCAN_IsEnabled>
    7168:	4603      	mov	r3, r0
    716a:	2b00      	cmp	r3, #0
    716c:	d00a      	beq.n	7184 <FlexCAN_InitController+0x34>
    {
        /* To enter Disable Mode requires FreezMode first */
        eResult = FlexCAN_EnterFreezeMode(pBase);
    716e:	9802      	ldr	r0, [sp, #8]
    7170:	f002 fc6c 	bl	9a4c <FlexCAN_EnterFreezeMode>
    7174:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == eResult)
    7176:	9b05      	ldr	r3, [sp, #20]
    7178:	2b00      	cmp	r3, #0
    717a:	d103      	bne.n	7184 <FlexCAN_InitController+0x34>
        {
            eResult = FlexCAN_Disable(pBase);
    717c:	9802      	ldr	r0, [sp, #8]
    717e:	f002 fd2f 	bl	9be0 <FlexCAN_Disable>
    7182:	9005      	str	r0, [sp, #20]
        }
    }

    if (FLEXCAN_STATUS_SUCCESS == eResult)
    7184:	9b05      	ldr	r3, [sp, #20]
    7186:	2b00      	cmp	r3, #0
    7188:	d137      	bne.n	71fa <FlexCAN_InitController+0xaa>
    {
    #if (FLEXCAN_IP_FEATURE_HAS_PE_CLKSRC_SELECT == STD_ON)
        /* Select a source clock for the FlexCAN engine */
        FlexCAN_SetClkSrc(pBase, Flexcan_Ip_pData->is_pe_clock);
    718a:	9b01      	ldr	r3, [sp, #4]
    718c:	7e5b      	ldrb	r3, [r3, #25]
    718e:	4619      	mov	r1, r3
    7190:	9802      	ldr	r0, [sp, #8]
    7192:	f7ff fee9 	bl	6f68 <FlexCAN_SetClkSrc>
    #endif
        /* Enable FlexCAN Module need to perform SoftReset & ClearRam */
        pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    7196:	9b02      	ldr	r3, [sp, #8]
    7198:	681b      	ldr	r3, [r3, #0]
    719a:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    719e:	9b02      	ldr	r3, [sp, #8]
    71a0:	601a      	str	r2, [r3, #0]
        /* Initialize FLEXCAN device */
        eResult = FlexCAN_Init(pBase);
    71a2:	9802      	ldr	r0, [sp, #8]
    71a4:	f002 fdb8 	bl	9d18 <FlexCAN_Init>
    71a8:	9005      	str	r0, [sp, #20]
        if (eResult != FLEXCAN_STATUS_SUCCESS)
    71aa:	9b05      	ldr	r3, [sp, #20]
    71ac:	2b00      	cmp	r3, #0
    71ae:	d006      	beq.n	71be <FlexCAN_InitController+0x6e>
        {
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
    71b0:	9802      	ldr	r0, [sp, #8]
    71b2:	f002 fc4b 	bl	9a4c <FlexCAN_EnterFreezeMode>
            (void)FlexCAN_Disable(pBase);
    71b6:	9802      	ldr	r0, [sp, #8]
    71b8:	f002 fd12 	bl	9be0 <FlexCAN_Disable>
    71bc:	e01d      	b.n	71fa <FlexCAN_InitController+0xaa>
            /* Disable the Protection again because is enabled by soft reset */
            FlexCAN_DisableMemErrorDetection(pBase);
        #endif

        #if defined(CAN_FEATURE_S32K1XX)
            if (TRUE == FlexCAN_IsFDAvailable(pBase))
    71be:	9802      	ldr	r0, [sp, #8]
    71c0:	f002 fe64 	bl	9e8c <FlexCAN_IsFDAvailable>
    71c4:	4603      	mov	r3, r0
    71c6:	2b00      	cmp	r3, #0
    71c8:	d007      	beq.n	71da <FlexCAN_InitController+0x8a>
            {
        #endif /* defined(CAN_FEATURE_S32K1XX) */
                /* Enable/Disable FD and check FD was set as expected. Setting FD as enabled
                 * might fail if the current CAN instance does not support FD. */
                FlexCAN_SetFDEnabled(pBase, Flexcan_Ip_pData->fd_enable, Flexcan_Ip_pData->bitRateSwitch);
    71ca:	9b01      	ldr	r3, [sp, #4]
    71cc:	7e19      	ldrb	r1, [r3, #24]
    71ce:	9b01      	ldr	r3, [sp, #4]
    71d0:	7edb      	ldrb	r3, [r3, #27]
    71d2:	461a      	mov	r2, r3
    71d4:	9802      	ldr	r0, [sp, #8]
    71d6:	f7ff fcdd 	bl	6b94 <FlexCAN_SetFDEnabled>
                }*/
        #if defined(CAN_FEATURE_S32K1XX)
            }
        #endif /* defined(CAN_FEATURE_S32K1XX) */
            /* configure depends on controller options. */
            FlexCAN_ConfigCtrlOptions(pBase, Flexcan_Ip_pData->ctrlOptions);
    71da:	9b01      	ldr	r3, [sp, #4]
    71dc:	691b      	ldr	r3, [r3, #16]
    71de:	4619      	mov	r1, r3
    71e0:	9802      	ldr	r0, [sp, #8]
    71e2:	f003 fd7b 	bl	acdc <FlexCAN_ConfigCtrlOptions>
            /* reset Imask buffers */
            FlexCAN_ResetImaskBuff(Instance);
    71e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    71ea:	4618      	mov	r0, r3
    71ec:	f003 fde6 	bl	adbc <FlexCAN_ResetImaskBuff>
            eResult = FlexCAN_InitCtroll(pBase, Flexcan_Ip_pData);
    71f0:	9901      	ldr	r1, [sp, #4]
    71f2:	9802      	ldr	r0, [sp, #8]
    71f4:	f7ff ff7e 	bl	70f4 <FlexCAN_InitCtroll>
    71f8:	9005      	str	r0, [sp, #20]
        }
    }
    return eResult;
    71fa:	9b05      	ldr	r3, [sp, #20]
}
    71fc:	4618      	mov	r0, r3
    71fe:	b007      	add	sp, #28
    7200:	f85d fb04 	ldr.w	pc, [sp], #4

00007204 <FlexCAN_InitBaudrate>:
 * Description   : Init baudrate for given controller.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_InitBaudrate(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    7204:	b500      	push	{lr}
    7206:	b083      	sub	sp, #12
    7208:	9001      	str	r0, [sp, #4]
    720a:	9100      	str	r1, [sp, #0]
    /* Enable the use of extended bit time definitions */
    FlexCAN_EnableExtCbt(pBase, Flexcan_Ip_pData->fd_enable);
    720c:	9b00      	ldr	r3, [sp, #0]
    720e:	7e1b      	ldrb	r3, [r3, #24]
    7210:	4619      	mov	r1, r3
    7212:	9801      	ldr	r0, [sp, #4]
    7214:	f7ff fe51 	bl	6eba <FlexCAN_EnableExtCbt>
        /* Disable Enhanced CBT time segments */
        pBase->CTRL2 &= ~FLEXCAN_CTRL2_BTE_MASK;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set bit rate. */
        if (Flexcan_Ip_pData->fd_enable)
    7218:	9b00      	ldr	r3, [sp, #0]
    721a:	7e1b      	ldrb	r3, [r3, #24]
    721c:	2b00      	cmp	r3, #0
    721e:	d00c      	beq.n	723a <FlexCAN_InitBaudrate+0x36>
        {
            /* Write Normal bit time configuration to CBT register */
            FlexCAN_SetExtendedTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    7220:	9b00      	ldr	r3, [sp, #0]
    7222:	331c      	adds	r3, #28
    7224:	4619      	mov	r1, r3
    7226:	9801      	ldr	r0, [sp, #4]
    7228:	f7ff fd94 	bl	6d54 <FlexCAN_SetExtendedTimeSegments>
            /* Write Data bit time configuration to FDCBT register */
            FlexCAN_SetFDTimeSegments(pBase, &Flexcan_Ip_pData->bitrate_cbt);
    722c:	9b00      	ldr	r3, [sp, #0]
    722e:	3330      	adds	r3, #48	; 0x30
    7230:	4619      	mov	r1, r3
    7232:	9801      	ldr	r0, [sp, #4]
    7234:	f7ff fd2d 	bl	6c92 <FlexCAN_SetFDTimeSegments>
            /* Write Normal bit time configuration to CTRL1 register */
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
        }
#endif
    }
}
    7238:	e005      	b.n	7246 <FlexCAN_InitBaudrate+0x42>
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    723a:	9b00      	ldr	r3, [sp, #0]
    723c:	331c      	adds	r3, #28
    723e:	4619      	mov	r1, r3
    7240:	9801      	ldr	r0, [sp, #4]
    7242:	f7ff fd5b 	bl	6cfc <FlexCAN_SetTimeSegments>
}
    7246:	bf00      	nop
    7248:	b003      	add	sp, #12
    724a:	f85d fb04 	ldr.w	pc, [sp], #4

0000724e <FlexCAN_ProccessLegacyRxFIFO>:
 * Description   : This function will process the enhanced RxFIFO in blocking mode.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_ProccessLegacyRxFIFO(uint8 u8Instance, uint32 u32TimeoutMs)
{
    724e:	b500      	push	{lr}
    7250:	b08d      	sub	sp, #52	; 0x34
    7252:	4603      	mov	r3, r0
    7254:	9102      	str	r1, [sp, #8]
    7256:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    725a:	2300      	movs	r3, #0
    725c:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    725e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7262:	4a46      	ldr	r2, [pc, #280]	; (737c <FlexCAN_ProccessLegacyRxFIFO+0x12e>)
    7264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7268:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    726a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    726e:	4a44      	ldr	r2, [pc, #272]	; (7380 <FlexCAN_ProccessLegacyRxFIFO+0x132>)
    7270:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7274:	9307      	str	r3, [sp, #28]
    uint32 timeStart = 0U;
    7276:	2300      	movs	r3, #0
    7278:	9305      	str	r3, [sp, #20]
    uint32 timeElapsed = 0U;
    727a:	2300      	movs	r3, #0
    727c:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    727e:	9b02      	ldr	r3, [sp, #8]
    7280:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7284:	fb02 f303 	mul.w	r3, r2, r3
    7288:	2100      	movs	r1, #0
    728a:	4618      	mov	r0, r3
    728c:	f7f9 ff1f 	bl	10ce <OsIf_MicrosToTicks>
    7290:	9006      	str	r0, [sp, #24]
    uint32 u32intType = 0U;
    7292:	2300      	movs	r3, #0
    7294:	9309      	str	r3, [sp, #36]	; 0x24

        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7296:	2000      	movs	r0, #0
    7298:	f7f9 fecd 	bl	1036 <OsIf_GetCounter>
    729c:	4603      	mov	r3, r0
    729e:	9305      	str	r3, [sp, #20]

        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    72a0:	e02a      	b.n	72f8 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
        {
            if (FLEXCAN_RXFIFO_USING_POLLING == pState->transferType)
    72a2:	9b08      	ldr	r3, [sp, #32]
    72a4:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    72a8:	2b01      	cmp	r3, #1
    72aa:	d115      	bne.n	72d8 <FlexCAN_ProccessLegacyRxFIFO+0x8a>
            {
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    72ac:	2307      	movs	r3, #7
    72ae:	9309      	str	r3, [sp, #36]	; 0x24
    72b0:	e00f      	b.n	72d2 <FlexCAN_ProccessLegacyRxFIFO+0x84>
                     u32intType >= FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE; \
                     u32intType--)
                {
                    if (FlexCAN_GetBuffStatusFlag(pBase, u32intType) != 0U)
    72b2:	9909      	ldr	r1, [sp, #36]	; 0x24
    72b4:	9807      	ldr	r0, [sp, #28]
    72b6:	f7ff fcd0 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    72ba:	4603      	mov	r3, r0
    72bc:	2b00      	cmp	r3, #0
    72be:	d005      	beq.n	72cc <FlexCAN_ProccessLegacyRxFIFO+0x7e>
                    {
                        FlexCAN_IRQHandlerRxFIFO(u8Instance, u32intType);
    72c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    72c4:	9909      	ldr	r1, [sp, #36]	; 0x24
    72c6:	4618      	mov	r0, r3
    72c8:	f000 fb06 	bl	78d8 <FlexCAN_IRQHandlerRxFIFO>
                     u32intType--)
    72cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    72ce:	3b01      	subs	r3, #1
    72d0:	9309      	str	r3, [sp, #36]	; 0x24
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    72d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    72d4:	2b04      	cmp	r3, #4
    72d6:	d8ec      	bhi.n	72b2 <FlexCAN_ProccessLegacyRxFIFO+0x64>
                    }
                }
            }

            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    72d8:	ab05      	add	r3, sp, #20
    72da:	2100      	movs	r1, #0
    72dc:	4618      	mov	r0, r3
    72de:	f7f9 fec3 	bl	1068 <OsIf_GetElapsed>
    72e2:	4602      	mov	r2, r0
    72e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72e6:	4413      	add	r3, r2
    72e8:	930a      	str	r3, [sp, #40]	; 0x28
            if (timeElapsed >= mS2Ticks)
    72ea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    72ec:	9b06      	ldr	r3, [sp, #24]
    72ee:	429a      	cmp	r2, r3
    72f0:	d302      	bcc.n	72f8 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
            {
                eResult = FLEXCAN_STATUS_TIMEOUT;
    72f2:	2303      	movs	r3, #3
    72f4:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    72f6:	e003      	b.n	7300 <FlexCAN_ProccessLegacyRxFIFO+0xb2>
        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    72f8:	9b08      	ldr	r3, [sp, #32]
    72fa:	685b      	ldr	r3, [r3, #4]
    72fc:	2b01      	cmp	r3, #1
    72fe:	d0d0      	beq.n	72a2 <FlexCAN_ProccessLegacyRxFIFO+0x54>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == eResult) && (FLEXCAN_RXFIFO_USING_POLLING != pState->transferType))
    7300:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7302:	2b03      	cmp	r3, #3
    7304:	d125      	bne.n	7352 <FlexCAN_ProccessLegacyRxFIFO+0x104>
    7306:	9b08      	ldr	r3, [sp, #32]
    7308:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    730c:	2b01      	cmp	r3, #1
    730e:	d020      	beq.n	7352 <FlexCAN_ProccessLegacyRxFIFO+0x104>
        {
            /* Disable RX FIFO interrupts*/
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, pState->isIntActive);
    7310:	9b08      	ldr	r3, [sp, #32]
    7312:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7316:	f89d 100f 	ldrb.w	r1, [sp, #15]
    731a:	9300      	str	r3, [sp, #0]
    731c:	2300      	movs	r3, #0
    731e:	2205      	movs	r2, #5
    7320:	9807      	ldr	r0, [sp, #28]
    7322:	f002 fe7f 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, pState->isIntActive);
    7326:	9b08      	ldr	r3, [sp, #32]
    7328:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    732c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7330:	9300      	str	r3, [sp, #0]
    7332:	2300      	movs	r3, #0
    7334:	2206      	movs	r2, #6
    7336:	9807      	ldr	r0, [sp, #28]
    7338:	f002 fe74 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, pState->isIntActive);
    733c:	9b08      	ldr	r3, [sp, #32]
    733e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7342:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7346:	9300      	str	r3, [sp, #0]
    7348:	2300      	movs	r3, #0
    734a:	2207      	movs	r2, #7
    734c:	9807      	ldr	r0, [sp, #28]
    734e:	f002 fe69 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
                (void)Dma_Ip_SetLogicChannelCommand(pState->rxFifoDMAChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            }
#endif
        }

        switch (pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    7352:	9b08      	ldr	r3, [sp, #32]
    7354:	685b      	ldr	r3, [r3, #4]
    7356:	2b00      	cmp	r3, #0
    7358:	d005      	beq.n	7366 <FlexCAN_ProccessLegacyRxFIFO+0x118>
    735a:	2b01      	cmp	r3, #1
    735c:	d106      	bne.n	736c <FlexCAN_ProccessLegacyRxFIFO+0x11e>
        {
            case FLEXCAN_MB_RX_BUSY:
                pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    735e:	9b08      	ldr	r3, [sp, #32]
    7360:	2200      	movs	r2, #0
    7362:	605a      	str	r2, [r3, #4]
                break;
    7364:	e005      	b.n	7372 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_IDLE:
                eResult = FLEXCAN_STATUS_SUCCESS;
    7366:	2300      	movs	r3, #0
    7368:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    736a:	e002      	b.n	7372 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_DMA_ERROR:
                eResult = FLEXCAN_STATUS_ERROR;
                break;
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
            default:
                eResult = FLEXCAN_STATUS_ERROR;
    736c:	2301      	movs	r3, #1
    736e:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    7370:	bf00      	nop
        }

    return eResult;
    7372:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    7374:	4618      	mov	r0, r3
    7376:	b00d      	add	sp, #52	; 0x34
    7378:	f85d fb04 	ldr.w	pc, [sp], #4
    737c:	1fff8f64 	.word	0x1fff8f64
    7380:	0000c650 	.word	0x0000c650

00007384 <FlexCAN_StartRxMessageBufferData>:
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageBufferData(uint8 instance,
                                                              uint8 mb_idx,
                                                              Flexcan_Ip_MsgBuffType * data,
                                                              boolean isPolling
                                                             )
{
    7384:	b084      	sub	sp, #16
    7386:	9200      	str	r2, [sp, #0]
    7388:	461a      	mov	r2, r3
    738a:	4603      	mov	r3, r0
    738c:	f88d 3007 	strb.w	r3, [sp, #7]
    7390:	460b      	mov	r3, r1
    7392:	f88d 3006 	strb.w	r3, [sp, #6]
    7396:	4613      	mov	r3, r2
    7398:	f88d 3005 	strb.w	r3, [sp, #5]

    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    739c:	2300      	movs	r3, #0
    739e:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    73a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    73a4:	4a15      	ldr	r2, [pc, #84]	; (73fc <FlexCAN_StartRxMessageBufferData+0x78>)
    73a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73aa:	9302      	str	r3, [sp, #8]
    }
    else
    {
#endif
        /* Start receiving mailbox */
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    73ac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    73b0:	9a02      	ldr	r2, [sp, #8]
    73b2:	011b      	lsls	r3, r3, #4
    73b4:	4413      	add	r3, r2
    73b6:	3304      	adds	r3, #4
    73b8:	681b      	ldr	r3, [r3, #0]
    73ba:	2b00      	cmp	r3, #0
    73bc:	d002      	beq.n	73c4 <FlexCAN_StartRxMessageBufferData+0x40>
        {
            result = FLEXCAN_STATUS_BUSY;
    73be:	2302      	movs	r3, #2
    73c0:	9303      	str	r3, [sp, #12]
    73c2:	e017      	b.n	73f4 <FlexCAN_StartRxMessageBufferData+0x70>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_RX_BUSY;
    73c4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    73c8:	9a02      	ldr	r2, [sp, #8]
    73ca:	011b      	lsls	r3, r3, #4
    73cc:	4413      	add	r3, r2
    73ce:	3304      	adds	r3, #4
    73d0:	2201      	movs	r2, #1
    73d2:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].pMBmessage = data;
    73d4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    73d8:	9a02      	ldr	r2, [sp, #8]
    73da:	011b      	lsls	r3, r3, #4
    73dc:	4413      	add	r3, r2
    73de:	9a00      	ldr	r2, [sp, #0]
    73e0:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = isPolling;
    73e2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    73e6:	9a02      	ldr	r2, [sp, #8]
    73e8:	011b      	lsls	r3, r3, #4
    73ea:	4413      	add	r3, r2
    73ec:	3308      	adds	r3, #8
    73ee:	f89d 2005 	ldrb.w	r2, [sp, #5]
    73f2:	701a      	strb	r2, [r3, #0]
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    73f4:	9b03      	ldr	r3, [sp, #12]
}
    73f6:	4618      	mov	r0, r3
    73f8:	b004      	add	sp, #16
    73fa:	4770      	bx	lr
    73fc:	1fff8f64 	.word	0x1fff8f64

00007400 <FlexCAN_StartSendData>:
                                                   uint8 mb_idx,
                                                   const Flexcan_Ip_DataInfoType * tx_info,
                                                   uint32 msg_id,
                                                   const uint8 * mb_data
                                                  )
{
    7400:	b500      	push	{lr}
    7402:	b08f      	sub	sp, #60	; 0x3c
    7404:	9204      	str	r2, [sp, #16]
    7406:	9303      	str	r3, [sp, #12]
    7408:	4603      	mov	r3, r0
    740a:	f88d 3017 	strb.w	r3, [sp, #23]
    740e:	460b      	mov	r3, r1
    7410:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    7414:	2300      	movs	r3, #0
    7416:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[Flexcan_Ip_u8Instance];
    7418:	f89d 3017 	ldrb.w	r3, [sp, #23]
    741c:	4a38      	ldr	r2, [pc, #224]	; (7500 <FlexCAN_StartSendData+0x100>)
    741e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7422:	930c      	str	r3, [sp, #48]	; 0x30
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    7424:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7428:	4a36      	ldr	r2, [pc, #216]	; (7504 <FlexCAN_StartSendData+0x104>)
    742a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    742e:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    7430:	2300      	movs	r3, #0
    7432:	930a      	str	r3, [sp, #40]	; 0x28
        eResult = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
    else
    {
#endif
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    7434:	f89d 3016 	ldrb.w	r3, [sp, #22]
    7438:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    743a:	011b      	lsls	r3, r3, #4
    743c:	4413      	add	r3, r2
    743e:	3304      	adds	r3, #4
    7440:	681b      	ldr	r3, [r3, #0]
    7442:	2b00      	cmp	r3, #0
    7444:	d002      	beq.n	744c <FlexCAN_StartSendData+0x4c>
        {
            eResult = FLEXCAN_STATUS_BUSY;
    7446:	2302      	movs	r3, #2
    7448:	930d      	str	r3, [sp, #52]	; 0x34
    744a:	e053      	b.n	74f4 <FlexCAN_StartSendData+0xf4>
        }
        else
        {
            /* Clear message buffer flag */
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    744c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    7450:	4619      	mov	r1, r3
    7452:	980b      	ldr	r0, [sp, #44]	; 0x2c
    7454:	f7ff fbee 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>

            state->mbs[mb_idx].state = FLEXCAN_MB_TX_BUSY;
    7458:	f89d 3016 	ldrb.w	r3, [sp, #22]
    745c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    745e:	011b      	lsls	r3, r3, #4
    7460:	4413      	add	r3, r2
    7462:	3304      	adds	r3, #4
    7464:	2202      	movs	r2, #2
    7466:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].time_stamp = 0U;
    7468:	f89d 3016 	ldrb.w	r3, [sp, #22]
    746c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    746e:	011b      	lsls	r3, r3, #4
    7470:	4413      	add	r3, r2
    7472:	330c      	adds	r3, #12
    7474:	2200      	movs	r2, #0
    7476:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = tx_info->is_polling;
    7478:	f89d 3016 	ldrb.w	r3, [sp, #22]
    747c:	9a04      	ldr	r2, [sp, #16]
    747e:	7b11      	ldrb	r1, [r2, #12]
    7480:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    7482:	011b      	lsls	r3, r3, #4
    7484:	4413      	add	r3, r2
    7486:	3308      	adds	r3, #8
    7488:	460a      	mov	r2, r1
    748a:	701a      	strb	r2, [r3, #0]
            state->mbs[mb_idx].isRemote = tx_info->is_remote;
    748c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    7490:	9a04      	ldr	r2, [sp, #16]
    7492:	7ad1      	ldrb	r1, [r2, #11]
    7494:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    7496:	011b      	lsls	r3, r3, #4
    7498:	4413      	add	r3, r2
    749a:	3309      	adds	r3, #9
    749c:	460a      	mov	r2, r1
    749e:	701a      	strb	r2, [r3, #0]

            cs.dataLen = tx_info->data_length;
    74a0:	9b04      	ldr	r3, [sp, #16]
    74a2:	685b      	ldr	r3, [r3, #4]
    74a4:	9308      	str	r3, [sp, #32]

            cs.msgIdType = tx_info->msg_id_type;
    74a6:	9b04      	ldr	r3, [sp, #16]
    74a8:	681b      	ldr	r3, [r3, #0]
    74aa:	9307      	str	r3, [sp, #28]

        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            cs.fd_enable = tx_info->fd_enable;
    74ac:	9b04      	ldr	r3, [sp, #16]
    74ae:	7a1b      	ldrb	r3, [r3, #8]
    74b0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
            cs.fd_padding = tx_info->fd_padding;
    74b4:	9b04      	ldr	r3, [sp, #16]
    74b6:	7a5b      	ldrb	r3, [r3, #9]
    74b8:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
            cs.enable_brs = tx_info->enable_brs;
    74bc:	9b04      	ldr	r3, [sp, #16]
    74be:	7a9b      	ldrb	r3, [r3, #10]
    74c0:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        #endif

            if (tx_info->is_remote)
    74c4:	9b04      	ldr	r3, [sp, #16]
    74c6:	7adb      	ldrb	r3, [r3, #11]
    74c8:	2b00      	cmp	r3, #0
    74ca:	d002      	beq.n	74d2 <FlexCAN_StartSendData+0xd2>
            {
                cs.code = (uint32)FLEXCAN_TX_REMOTE;
    74cc:	231c      	movs	r3, #28
    74ce:	9306      	str	r3, [sp, #24]
    74d0:	e001      	b.n	74d6 <FlexCAN_StartSendData+0xd6>
            }
            else
            {
                cs.code = (uint32)FLEXCAN_TX_DATA;
    74d2:	230c      	movs	r3, #12
    74d4:	9306      	str	r3, [sp, #24]
            }
            pMbAddr = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    74d6:	f89d 3016 	ldrb.w	r3, [sp, #22]
    74da:	4619      	mov	r1, r3
    74dc:	980b      	ldr	r0, [sp, #44]	; 0x2c
    74de:	f002 fa19 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    74e2:	900a      	str	r0, [sp, #40]	; 0x28
            FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, FALSE);
    74e4:	a906      	add	r1, sp, #24
    74e6:	2300      	movs	r3, #0
    74e8:	9300      	str	r3, [sp, #0]
    74ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
    74ec:	9a03      	ldr	r2, [sp, #12]
    74ee:	980a      	ldr	r0, [sp, #40]	; 0x28
    74f0:	f002 ff62 	bl	a3b8 <FlexCAN_SetTxMsgBuff>
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    74f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    74f6:	4618      	mov	r0, r3
    74f8:	b00f      	add	sp, #60	; 0x3c
    74fa:	f85d fb04 	ldr.w	pc, [sp], #4
    74fe:	bf00      	nop
    7500:	1fff8f64 	.word	0x1fff8f64
    7504:	0000c650 	.word	0x0000c650

00007508 <FlexCAN_StartRxMessageFifoData>:
 * receiving data and enabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageFifoData(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    7508:	b500      	push	{lr}
    750a:	b089      	sub	sp, #36	; 0x24
    750c:	4603      	mov	r3, r0
    750e:	9102      	str	r1, [sp, #8]
    7510:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = NULL_PTR;
    7514:	2300      	movs	r3, #0
    7516:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StateType * state = NULL_PTR;
    7518:	2300      	movs	r3, #0
    751a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    751c:	2300      	movs	r3, #0
    751e:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base = Flexcan_Ip_apxBase[instance];
    7520:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7524:	4a26      	ldr	r2, [pc, #152]	; (75c0 <FlexCAN_StartRxMessageFifoData+0xb8>)
    7526:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    752a:	9306      	str	r3, [sp, #24]
    state = Flexcan_Ip_apxState[instance];
    752c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7530:	4a24      	ldr	r2, [pc, #144]	; (75c4 <FlexCAN_StartRxMessageFifoData+0xbc>)
    7532:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7536:	9305      	str	r3, [sp, #20]
    #endif
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    /* Start receiving fifo */
    if (state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY)
    7538:	9b05      	ldr	r3, [sp, #20]
    753a:	685b      	ldr	r3, [r3, #4]
    753c:	2b01      	cmp	r3, #1
    753e:	d102      	bne.n	7546 <FlexCAN_StartRxMessageFifoData+0x3e>
    {
        eResult = FLEXCAN_STATUS_BUSY;
    7540:	2302      	movs	r3, #2
    7542:	9307      	str	r3, [sp, #28]
    7544:	e036      	b.n	75b4 <FlexCAN_StartRxMessageFifoData+0xac>
    }
    else
    {
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_RX_BUSY;
    7546:	9b05      	ldr	r3, [sp, #20]
    7548:	2201      	movs	r2, #1
    754a:	605a      	str	r2, [r3, #4]
    if (FLEXCAN_RXFIFO_USING_POLLING == state->transferType)
    754c:	9b05      	ldr	r3, [sp, #20]
    754e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    7552:	2b01      	cmp	r3, #1
    7554:	d102      	bne.n	755c <FlexCAN_StartRxMessageFifoData+0x54>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    7556:	9b05      	ldr	r3, [sp, #20]
    7558:	2201      	movs	r2, #1
    755a:	721a      	strb	r2, [r3, #8]
    }

    /* This will get filled by the interrupt handler */
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = data;
    755c:	9b05      	ldr	r3, [sp, #20]
    755e:	9a02      	ldr	r2, [sp, #8]
    7560:	601a      	str	r2, [r3, #0]

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    7562:	9b05      	ldr	r3, [sp, #20]
    7564:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    7568:	2b00      	cmp	r3, #0
    756a:	d123      	bne.n	75b4 <FlexCAN_StartRxMessageFifoData+0xac>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = FALSE;
    756c:	9b05      	ldr	r3, [sp, #20]
    756e:	2200      	movs	r2, #0
    7570:	721a      	strb	r2, [r3, #8]
        /* Enable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, TRUE, state->isIntActive);
    7572:	9b05      	ldr	r3, [sp, #20]
    7574:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7578:	f89d 100f 	ldrb.w	r1, [sp, #15]
    757c:	9300      	str	r3, [sp, #0]
    757e:	2301      	movs	r3, #1
    7580:	2206      	movs	r2, #6
    7582:	9806      	ldr	r0, [sp, #24]
    7584:	f002 fd4e 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, TRUE, state->isIntActive);
    7588:	9b05      	ldr	r3, [sp, #20]
    758a:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    758e:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7592:	9300      	str	r3, [sp, #0]
    7594:	2301      	movs	r3, #1
    7596:	2207      	movs	r2, #7
    7598:	9806      	ldr	r0, [sp, #24]
    759a:	f002 fd43 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, TRUE, state->isIntActive);
    759e:	9b05      	ldr	r3, [sp, #20]
    75a0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    75a4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    75a8:	9300      	str	r3, [sp, #0]
    75aa:	2301      	movs	r3, #1
    75ac:	2205      	movs	r2, #5
    75ae:	9806      	ldr	r0, [sp, #24]
    75b0:	f002 fd38 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    75b4:	9b07      	ldr	r3, [sp, #28]
}
    75b6:	4618      	mov	r0, r3
    75b8:	b009      	add	sp, #36	; 0x24
    75ba:	f85d fb04 	ldr.w	pc, [sp], #4
    75be:	bf00      	nop
    75c0:	0000c650 	.word	0x0000c650
    75c4:	1fff8f64 	.word	0x1fff8f64

000075c8 <FlexCAN_IRQHandlerRxMB>:
 *
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerRxMB(uint8 instance, uint32 mb_idx)
{
    75c8:	b510      	push	{r4, lr}
    75ca:	b09e      	sub	sp, #120	; 0x78
    75cc:	4603      	mov	r3, r0
    75ce:	9102      	str	r1, [sp, #8]
    75d0:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    75d4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    75d8:	4a70      	ldr	r2, [pc, #448]	; (779c <FlexCAN_IRQHandlerRxMB+0x1d4>)
    75da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75de:	931c      	str	r3, [sp, #112]	; 0x70
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    75e0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    75e4:	4a6e      	ldr	r2, [pc, #440]	; (77a0 <FlexCAN_IRQHandlerRxMB+0x1d8>)
    75e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75ea:	931b      	str	r3, [sp, #108]	; 0x6c
    Flexcan_Ip_MsgBuffType data;
    boolean bCurrentIntStat = FALSE;
    75ec:	2300      	movs	r3, #0
    75ee:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[mb_idx].pMBmessage  */
    if (NULL_PTR == state->mbs[mb_idx].pMBmessage)
    75f2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    75f4:	9b02      	ldr	r3, [sp, #8]
    75f6:	011b      	lsls	r3, r3, #4
    75f8:	4413      	add	r3, r2
    75fa:	681b      	ldr	r3, [r3, #0]
    75fc:	2b00      	cmp	r3, #0
    75fe:	d105      	bne.n	760c <FlexCAN_IRQHandlerRxMB+0x44>
    {
        state->mbs[mb_idx].pMBmessage = &data;
    7600:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7602:	9b02      	ldr	r3, [sp, #8]
    7604:	011b      	lsls	r3, r3, #4
    7606:	4413      	add	r3, r2
    7608:	aa05      	add	r2, sp, #20
    760a:	601a      	str	r2, [r3, #0]
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    boolean bIsCriticalSectionNeeded = FALSE;
    760c:	2300      	movs	r3, #0
    760e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77

    /* Expectation: the sequence will not be interrupted when it already in interupt context */
    if (TRUE == state->mbs[mb_idx].isPolling)
    7612:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7614:	9b02      	ldr	r3, [sp, #8]
    7616:	011b      	lsls	r3, r3, #4
    7618:	4413      	add	r3, r2
    761a:	3308      	adds	r3, #8
    761c:	781b      	ldrb	r3, [r3, #0]
    761e:	2b00      	cmp	r3, #0
    7620:	d008      	beq.n	7634 <FlexCAN_IRQHandlerRxMB+0x6c>
        if ((state->bIsLegacyFifoEn ||  state->bIsEnhancedFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #else
        if ((state->bIsLegacyFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    #elif defined (ERR_IPV_FLEXCAN_E050246)
        if (state->bIsLegacyFifoEn)
    7622:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    7624:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    7628:	2b00      	cmp	r3, #0
    762a:	d003      	beq.n	7634 <FlexCAN_IRQHandlerRxMB+0x6c>
    #endif
        {
            bIsCriticalSectionNeeded = TRUE;
    762c:	2301      	movs	r3, #1
    762e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
            /* Disable all IRQs */
            OsIf_SuspendAllInterrupts();
    7632:	b672      	cpsid	i
        }
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    /* Lock RX message buffer and RX FIFO*/
    FlexCAN_LockRxMsgBuff(base, mb_idx);
    7634:	9902      	ldr	r1, [sp, #8]
    7636:	981c      	ldr	r0, [sp, #112]	; 0x70
    7638:	f002 fce5 	bl	a006 <FlexCAN_LockRxMsgBuff>

    /* Get RX MB field values*/
    FlexCAN_GetMsgBuff(base, mb_idx, state->mbs[mb_idx].pMBmessage);
    763c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    763e:	9b02      	ldr	r3, [sp, #8]
    7640:	011b      	lsls	r3, r3, #4
    7642:	4413      	add	r3, r2
    7644:	681b      	ldr	r3, [r3, #0]
    7646:	461a      	mov	r2, r3
    7648:	9902      	ldr	r1, [sp, #8]
    764a:	981c      	ldr	r0, [sp, #112]	; 0x70
    764c:	f002 fe0a 	bl	a264 <FlexCAN_GetMsgBuff>

    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    7650:	9902      	ldr	r1, [sp, #8]
    7652:	981c      	ldr	r0, [sp, #112]	; 0x70
    7654:	f7ff faee 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>

#if defined (ERR_IPV_FLEXCAN_E050246)
    /* the CODE field is updated with an incorrect value when MBx is locked by software for more than 20 CAN bit times and FIFO enable.
    When the CODE field is corrupted, it's probably updated with any value that is invalid. Except EMPTY, FULL and OVERRUN other values can not make MB unlocked and move-in process. */
    if ((state->bIsLegacyFifoEn) && \
    7658:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    765a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    765e:	2b00      	cmp	r3, #0
    7660:	d032      	beq.n	76c8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    7662:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7664:	9b02      	ldr	r3, [sp, #8]
    7666:	011b      	lsls	r3, r3, #4
    7668:	4413      	add	r3, r2
    766a:	681b      	ldr	r3, [r3, #0]
    766c:	681b      	ldr	r3, [r3, #0]
    766e:	0e1b      	lsrs	r3, r3, #24
    7670:	f003 030f 	and.w	r3, r3, #15
    if ((state->bIsLegacyFifoEn) && \
    7674:	2b02      	cmp	r3, #2
    7676:	d027      	beq.n	76c8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    7678:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    767a:	9b02      	ldr	r3, [sp, #8]
    767c:	011b      	lsls	r3, r3, #4
    767e:	4413      	add	r3, r2
    7680:	681b      	ldr	r3, [r3, #0]
    7682:	681b      	ldr	r3, [r3, #0]
    7684:	0e1b      	lsrs	r3, r3, #24
    7686:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    768a:	2b04      	cmp	r3, #4
    768c:	d01c      	beq.n	76c8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_OVERRUN != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)))
    768e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7690:	9b02      	ldr	r3, [sp, #8]
    7692:	011b      	lsls	r3, r3, #4
    7694:	4413      	add	r3, r2
    7696:	681b      	ldr	r3, [r3, #0]
    7698:	681b      	ldr	r3, [r3, #0]
    769a:	0e1b      	lsrs	r3, r3, #24
    769c:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    76a0:	2b06      	cmp	r3, #6
    76a2:	d011      	beq.n	76c8 <FlexCAN_IRQHandlerRxMB+0x100>
    {
        /* Update the cs code for next sequence move in MB.
        A CPU write into the C/S word also unlocks the MB */
        volatile uint32 *flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    76a4:	9902      	ldr	r1, [sp, #8]
    76a6:	981c      	ldr	r0, [sp, #112]	; 0x70
    76a8:	f002 f934 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    76ac:	9019      	str	r0, [sp, #100]	; 0x64
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    76ae:	9b19      	ldr	r3, [sp, #100]	; 0x64
    76b0:	681b      	ldr	r3, [r3, #0]
    76b2:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    76b6:	9b19      	ldr	r3, [sp, #100]	; 0x64
    76b8:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (((uint32)FLEXCAN_RX_EMPTY) << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    76ba:	9b19      	ldr	r3, [sp, #100]	; 0x64
    76bc:	681b      	ldr	r3, [r3, #0]
    76be:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    76c2:	9b19      	ldr	r3, [sp, #100]	; 0x64
    76c4:	601a      	str	r2, [r3, #0]
    {
    76c6:	e002      	b.n	76ce <FlexCAN_IRQHandlerRxMB+0x106>
    }
    else
#endif
    {
    /* Unlock RX message buffer and RX FIFO*/
    FlexCAN_UnlockRxMsgBuff(base);
    76c8:	981c      	ldr	r0, [sp, #112]	; 0x70
    76ca:	f7ff faac 	bl	6c26 <FlexCAN_UnlockRxMsgBuff>
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    /* To ensure that interrupts are resumed when they are suspended */
    if (TRUE == bIsCriticalSectionNeeded)
    76ce:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
    76d2:	2b00      	cmp	r3, #0
    76d4:	d000      	beq.n	76d8 <FlexCAN_IRQHandlerRxMB+0x110>
    {
        /* Enable all IRQs */
        OsIf_ResumeAllInterrupts();
    76d6:	b662      	cpsie	i
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    76d8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    76da:	9b02      	ldr	r3, [sp, #8]
    76dc:	011b      	lsls	r3, r3, #4
    76de:	4413      	add	r3, r2
    76e0:	3304      	adds	r3, #4
    76e2:	2200      	movs	r2, #0
    76e4:	601a      	str	r2, [r3, #0]

    bCurrentIntStat = state->mbs[mb_idx].isPolling;
    76e6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    76e8:	9b02      	ldr	r3, [sp, #8]
    76ea:	011b      	lsls	r3, r3, #4
    76ec:	4413      	add	r3, r2
    76ee:	3308      	adds	r3, #8
    76f0:	781b      	ldrb	r3, [r3, #0]
    76f2:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* Invoke callback */
    if (state->callback != NULL_PTR)
    76f6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    76f8:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    76fc:	2b00      	cmp	r3, #0
    76fe:	d008      	beq.n	7712 <FlexCAN_IRQHandlerRxMB+0x14a>
    {
        state->callback(instance, FLEXCAN_EVENT_RX_COMPLETE, mb_idx, state);
    7700:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    7702:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    7706:	f89d 000f 	ldrb.w	r0, [sp, #15]
    770a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    770c:	9a02      	ldr	r2, [sp, #8]
    770e:	2100      	movs	r1, #0
    7710:	47a0      	blx	r4
    }

    if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state) && (FALSE == state->mbs[mb_idx].isPolling))
    7712:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7714:	9b02      	ldr	r3, [sp, #8]
    7716:	011b      	lsls	r3, r3, #4
    7718:	4413      	add	r3, r2
    771a:	3304      	adds	r3, #4
    771c:	681b      	ldr	r3, [r3, #0]
    771e:	2b00      	cmp	r3, #0
    7720:	d11e      	bne.n	7760 <FlexCAN_IRQHandlerRxMB+0x198>
    7722:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7724:	9b02      	ldr	r3, [sp, #8]
    7726:	011b      	lsls	r3, r3, #4
    7728:	4413      	add	r3, r2
    772a:	3308      	adds	r3, #8
    772c:	781b      	ldrb	r3, [r3, #0]
    772e:	f083 0301 	eor.w	r3, r3, #1
    7732:	b2db      	uxtb	r3, r3
    7734:	2b00      	cmp	r3, #0
    7736:	d013      	beq.n	7760 <FlexCAN_IRQHandlerRxMB+0x198>
    {
        /* callback is not called, need to reset to default value */
        state->mbs[mb_idx].isPolling = TRUE;
    7738:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    773a:	9b02      	ldr	r3, [sp, #8]
    773c:	011b      	lsls	r3, r3, #4
    773e:	4413      	add	r3, r2
    7740:	3308      	adds	r3, #8
    7742:	2201      	movs	r2, #1
    7744:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    7746:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    7748:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    774c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7750:	9300      	str	r3, [sp, #0]
    7752:	2300      	movs	r3, #0
    7754:	9a02      	ldr	r2, [sp, #8]
    7756:	981c      	ldr	r0, [sp, #112]	; 0x70
    7758:	f002 fc64 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
    775c:	bf00      	nop
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    775e:	e019      	b.n	7794 <FlexCAN_IRQHandlerRxMB+0x1cc>
    else if ((FALSE == bCurrentIntStat) && (TRUE == state->mbs[mb_idx].isPolling))
    7760:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
    7764:	f083 0301 	eor.w	r3, r3, #1
    7768:	b2db      	uxtb	r3, r3
    776a:	2b00      	cmp	r3, #0
    776c:	d012      	beq.n	7794 <FlexCAN_IRQHandlerRxMB+0x1cc>
    776e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    7770:	9b02      	ldr	r3, [sp, #8]
    7772:	011b      	lsls	r3, r3, #4
    7774:	4413      	add	r3, r2
    7776:	3308      	adds	r3, #8
    7778:	781b      	ldrb	r3, [r3, #0]
    777a:	2b00      	cmp	r3, #0
    777c:	d00a      	beq.n	7794 <FlexCAN_IRQHandlerRxMB+0x1cc>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    777e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    7780:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7784:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7788:	9300      	str	r3, [sp, #0]
    778a:	2300      	movs	r3, #0
    778c:	9a02      	ldr	r2, [sp, #8]
    778e:	981c      	ldr	r0, [sp, #112]	; 0x70
    7790:	f002 fc48 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
}
    7794:	bf00      	nop
    7796:	b01e      	add	sp, #120	; 0x78
    7798:	bd10      	pop	{r4, pc}
    779a:	bf00      	nop
    779c:	0000c650 	.word	0x0000c650
    77a0:	1fff8f64 	.word	0x1fff8f64

000077a4 <FlexCAN_IRQHandlerTxMB>:
 * note: just using in interrupt mode
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerTxMB(uint8 u8Instance, uint32 u32MbIdx)
{
    77a4:	b510      	push	{r4, lr}
    77a6:	b09a      	sub	sp, #104	; 0x68
    77a8:	4603      	mov	r3, r0
    77aa:	9102      	str	r1, [sp, #8]
    77ac:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    77b0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    77b4:	4a46      	ldr	r2, [pc, #280]	; (78d0 <FlexCAN_IRQHandlerTxMB+0x12c>)
    77b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77ba:	9319      	str	r3, [sp, #100]	; 0x64
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    77bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    77c0:	4a44      	ldr	r2, [pc, #272]	; (78d4 <FlexCAN_IRQHandlerTxMB+0x130>)
    77c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77c6:	9318      	str	r3, [sp, #96]	; 0x60
    Flexcan_Ip_MsgBuffType mb;
    mb.cs = 0U;
    77c8:	2300      	movs	r3, #0
    77ca:	9304      	str	r3, [sp, #16]
    mb.time_stamp = 0U;
    77cc:	2300      	movs	r3, #0
    77ce:	9317      	str	r3, [sp, #92]	; 0x5c
    if (pState->mbs[u32MbIdx].isRemote)
    77d0:	9a18      	ldr	r2, [sp, #96]	; 0x60
    77d2:	9b02      	ldr	r3, [sp, #8]
    77d4:	011b      	lsls	r3, r3, #4
    77d6:	4413      	add	r3, r2
    77d8:	3309      	adds	r3, #9
    77da:	781b      	ldrb	r3, [r3, #0]
    77dc:	2b00      	cmp	r3, #0
    77de:	d01e      	beq.n	781e <FlexCAN_IRQHandlerTxMB+0x7a>
    {
        FlexCAN_LockRxMsgBuff(pBase, u32MbIdx);
    77e0:	9902      	ldr	r1, [sp, #8]
    77e2:	9819      	ldr	r0, [sp, #100]	; 0x64
    77e4:	f002 fc0f 	bl	a006 <FlexCAN_LockRxMsgBuff>
        FlexCAN_GetMsgBuff(pBase, u32MbIdx, &mb);
    77e8:	ab04      	add	r3, sp, #16
    77ea:	461a      	mov	r2, r3
    77ec:	9902      	ldr	r1, [sp, #8]
    77ee:	9819      	ldr	r0, [sp, #100]	; 0x64
    77f0:	f002 fd38 	bl	a264 <FlexCAN_GetMsgBuff>
        FlexCAN_UnlockRxMsgBuff(pBase);
    77f4:	9819      	ldr	r0, [sp, #100]	; 0x64
    77f6:	f7ff fa16 	bl	6c26 <FlexCAN_UnlockRxMsgBuff>
        pState->mbs[u32MbIdx].time_stamp = mb.time_stamp;
    77fa:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    77fc:	9918      	ldr	r1, [sp, #96]	; 0x60
    77fe:	9b02      	ldr	r3, [sp, #8]
    7800:	011b      	lsls	r3, r3, #4
    7802:	440b      	add	r3, r1
    7804:	330c      	adds	r3, #12
    7806:	601a      	str	r2, [r3, #0]
        /* If the frame was a remote frame, clear the flag only if the response was
        * not received yet. If the response was received, leave the flag set in order
        * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
        if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    7808:	9b04      	ldr	r3, [sp, #16]
    780a:	0e1b      	lsrs	r3, r3, #24
    780c:	f003 030f 	and.w	r3, r3, #15
    7810:	2b04      	cmp	r3, #4
    7812:	d116      	bne.n	7842 <FlexCAN_IRQHandlerTxMB+0x9e>
        {
            FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    7814:	9902      	ldr	r1, [sp, #8]
    7816:	9819      	ldr	r0, [sp, #100]	; 0x64
    7818:	f7ff fa0c 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
    781c:	e011      	b.n	7842 <FlexCAN_IRQHandlerTxMB+0x9e>
        }
    }
    else
    {
        pState->mbs[u32MbIdx].time_stamp = FlexCAN_GetMsgBuffTimestamp(pBase, u32MbIdx);
    781e:	9902      	ldr	r1, [sp, #8]
    7820:	9819      	ldr	r0, [sp, #100]	; 0x64
    7822:	f002 fd0b 	bl	a23c <FlexCAN_GetMsgBuffTimestamp>
    7826:	4601      	mov	r1, r0
    7828:	9a18      	ldr	r2, [sp, #96]	; 0x60
    782a:	9b02      	ldr	r3, [sp, #8]
    782c:	011b      	lsls	r3, r3, #4
    782e:	4413      	add	r3, r2
    7830:	330c      	adds	r3, #12
    7832:	6019      	str	r1, [r3, #0]
        FlexCAN_UnlockRxMsgBuff(pBase);
    7834:	9819      	ldr	r0, [sp, #100]	; 0x64
    7836:	f7ff f9f6 	bl	6c26 <FlexCAN_UnlockRxMsgBuff>
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    783a:	9902      	ldr	r1, [sp, #8]
    783c:	9819      	ldr	r0, [sp, #100]	; 0x64
    783e:	f7ff f9f9 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }

    pState->mbs[u32MbIdx].state = FLEXCAN_MB_IDLE;
    7842:	9a18      	ldr	r2, [sp, #96]	; 0x60
    7844:	9b02      	ldr	r3, [sp, #8]
    7846:	011b      	lsls	r3, r3, #4
    7848:	4413      	add	r3, r2
    784a:	3304      	adds	r3, #4
    784c:	2200      	movs	r2, #0
    784e:	601a      	str	r2, [r3, #0]

    /* Invoke callback */
    if (pState->callback != NULL_PTR)
    7850:	9b18      	ldr	r3, [sp, #96]	; 0x60
    7852:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    7856:	2b00      	cmp	r3, #0
    7858:	d008      	beq.n	786c <FlexCAN_IRQHandlerTxMB+0xc8>
    {
        pState->callback(u8Instance, FLEXCAN_EVENT_TX_COMPLETE, u32MbIdx, pState);
    785a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    785c:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    7860:	f89d 000f 	ldrb.w	r0, [sp, #15]
    7864:	9b18      	ldr	r3, [sp, #96]	; 0x60
    7866:	9a02      	ldr	r2, [sp, #8]
    7868:	2104      	movs	r1, #4
    786a:	47a0      	blx	r4
    }

    if (FLEXCAN_MB_IDLE == pState->mbs[u32MbIdx].state)
    786c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    786e:	9b02      	ldr	r3, [sp, #8]
    7870:	011b      	lsls	r3, r3, #4
    7872:	4413      	add	r3, r2
    7874:	3304      	adds	r3, #4
    7876:	681b      	ldr	r3, [r3, #0]
    7878:	2b00      	cmp	r3, #0
    787a:	d112      	bne.n	78a2 <FlexCAN_IRQHandlerTxMB+0xfe>
    {
        /* callback is not called, need to reset to default value */
        pState->mbs[u32MbIdx].isPolling = TRUE;
    787c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    787e:	9b02      	ldr	r3, [sp, #8]
    7880:	011b      	lsls	r3, r3, #4
    7882:	4413      	add	r3, r2
    7884:	3308      	adds	r3, #8
    7886:	2201      	movs	r2, #1
    7888:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    788a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    788c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7890:	f89d 100f 	ldrb.w	r1, [sp, #15]
    7894:	9300      	str	r3, [sp, #0]
    7896:	2300      	movs	r3, #0
    7898:	9a02      	ldr	r2, [sp, #8]
    789a:	9819      	ldr	r0, [sp, #100]	; 0x64
    789c:	f002 fbc2 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    78a0:	e012      	b.n	78c8 <FlexCAN_IRQHandlerTxMB+0x124>
    else if (TRUE == pState->mbs[u32MbIdx].isPolling)
    78a2:	9a18      	ldr	r2, [sp, #96]	; 0x60
    78a4:	9b02      	ldr	r3, [sp, #8]
    78a6:	011b      	lsls	r3, r3, #4
    78a8:	4413      	add	r3, r2
    78aa:	3308      	adds	r3, #8
    78ac:	781b      	ldrb	r3, [r3, #0]
    78ae:	2b00      	cmp	r3, #0
    78b0:	d00a      	beq.n	78c8 <FlexCAN_IRQHandlerTxMB+0x124>
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    78b2:	9b18      	ldr	r3, [sp, #96]	; 0x60
    78b4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    78b8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    78bc:	9300      	str	r3, [sp, #0]
    78be:	2300      	movs	r3, #0
    78c0:	9a02      	ldr	r2, [sp, #8]
    78c2:	9819      	ldr	r0, [sp, #100]	; 0x64
    78c4:	f002 fbae 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
}
    78c8:	bf00      	nop
    78ca:	b01a      	add	sp, #104	; 0x68
    78cc:	bd10      	pop	{r4, pc}
    78ce:	bf00      	nop
    78d0:	0000c650 	.word	0x0000c650
    78d4:	1fff8f64 	.word	0x1fff8f64

000078d8 <FlexCAN_IRQHandlerRxFIFO>:
 * Function Name : FlexCAN_IRQHandlerRxFIFO
 * Description   : Process IRQHandler in case of RxFIFO mode selection for CAN interface.
 *
 *END**************************************************************************/
static inline void FlexCAN_IRQHandlerRxFIFO(uint8 instance, uint32 mb_idx)
{
    78d8:	b510      	push	{r4, lr}
    78da:	b098      	sub	sp, #96	; 0x60
    78dc:	4603      	mov	r3, r0
    78de:	9100      	str	r1, [sp, #0]
    78e0:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    78e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    78e8:	4a3c      	ldr	r2, [pc, #240]	; (79dc <FlexCAN_IRQHandlerRxFIFO+0x104>)
    78ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78ee:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    78f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    78f4:	4a3a      	ldr	r2, [pc, #232]	; (79e0 <FlexCAN_IRQHandlerRxFIFO+0x108>)
    78f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78fa:	9316      	str	r3, [sp, #88]	; 0x58
    Flexcan_Ip_MsgBuffType data;

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage  */
    if (NULL_PTR == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage)
    78fc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    78fe:	681b      	ldr	r3, [r3, #0]
    7900:	2b00      	cmp	r3, #0
    7902:	d102      	bne.n	790a <FlexCAN_IRQHandlerRxFIFO+0x32>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = &data;
    7904:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7906:	aa02      	add	r2, sp, #8
    7908:	601a      	str	r2, [r3, #0]
    }
    switch (mb_idx)
    790a:	9b00      	ldr	r3, [sp, #0]
    790c:	2b07      	cmp	r3, #7
    790e:	d048      	beq.n	79a2 <FlexCAN_IRQHandlerRxFIFO+0xca>
    7910:	9b00      	ldr	r3, [sp, #0]
    7912:	2b07      	cmp	r3, #7
    7914:	d858      	bhi.n	79c8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
    7916:	9b00      	ldr	r3, [sp, #0]
    7918:	2b05      	cmp	r3, #5
    791a:	d003      	beq.n	7924 <FlexCAN_IRQHandlerRxFIFO+0x4c>
    791c:	9b00      	ldr	r3, [sp, #0]
    791e:	2b06      	cmp	r3, #6
    7920:	d02c      	beq.n	797c <FlexCAN_IRQHandlerRxFIFO+0xa4>
            }

            break;
        default:
            /* Do Nothing */
            break;
    7922:	e051      	b.n	79c8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
            if (FLEXCAN_MB_RX_BUSY == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    7924:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7926:	685b      	ldr	r3, [r3, #4]
    7928:	2b01      	cmp	r3, #1
    792a:	d14f      	bne.n	79cc <FlexCAN_IRQHandlerRxFIFO+0xf4>
                FlexCAN_ReadRxFifo(base, state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage);
    792c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    792e:	681b      	ldr	r3, [r3, #0]
    7930:	4619      	mov	r1, r3
    7932:	9817      	ldr	r0, [sp, #92]	; 0x5c
    7934:	f003 f91d 	bl	ab72 <FlexCAN_ReadRxFifo>
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    7938:	9900      	ldr	r1, [sp, #0]
    793a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    793c:	f7ff f97a 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
                state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    7940:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7942:	2200      	movs	r2, #0
    7944:	605a      	str	r2, [r3, #4]
                if (state->callback != NULL_PTR)
    7946:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7948:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    794c:	2b00      	cmp	r3, #0
    794e:	d008      	beq.n	7962 <FlexCAN_IRQHandlerRxFIFO+0x8a>
                    state->callback(instance, FLEXCAN_EVENT_RXFIFO_COMPLETE, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    7950:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7952:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    7956:	f89d 0007 	ldrb.w	r0, [sp, #7]
    795a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    795c:	2200      	movs	r2, #0
    795e:	2101      	movs	r1, #1
    7960:	47a0      	blx	r4
                if (FLEXCAN_MB_IDLE == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    7962:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7964:	685b      	ldr	r3, [r3, #4]
    7966:	2b00      	cmp	r3, #0
    7968:	d130      	bne.n	79cc <FlexCAN_IRQHandlerRxFIFO+0xf4>
                    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    796a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    796c:	2201      	movs	r2, #1
    796e:	721a      	strb	r2, [r3, #8]
                    FlexCAN_CompleteRxMessageFifoData(instance);
    7970:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7974:	4618      	mov	r0, r3
    7976:	f000 fbf1 	bl	815c <FlexCAN_CompleteRxMessageFifoData>
            break;
    797a:	e027      	b.n	79cc <FlexCAN_IRQHandlerRxFIFO+0xf4>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    797c:	9900      	ldr	r1, [sp, #0]
    797e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    7980:	f7ff f958 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    7984:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7986:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    798a:	2b00      	cmp	r3, #0
    798c:	d020      	beq.n	79d0 <FlexCAN_IRQHandlerRxFIFO+0xf8>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_WARNING, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    798e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7990:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    7994:	f89d 0007 	ldrb.w	r0, [sp, #7]
    7998:	9b16      	ldr	r3, [sp, #88]	; 0x58
    799a:	2200      	movs	r2, #0
    799c:	2102      	movs	r1, #2
    799e:	47a0      	blx	r4
            break;
    79a0:	e016      	b.n	79d0 <FlexCAN_IRQHandlerRxFIFO+0xf8>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    79a2:	9900      	ldr	r1, [sp, #0]
    79a4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    79a6:	f7ff f945 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    79aa:	9b16      	ldr	r3, [sp, #88]	; 0x58
    79ac:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    79b0:	2b00      	cmp	r3, #0
    79b2:	d00f      	beq.n	79d4 <FlexCAN_IRQHandlerRxFIFO+0xfc>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_OVERFLOW, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    79b4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    79b6:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    79ba:	f89d 0007 	ldrb.w	r0, [sp, #7]
    79be:	9b16      	ldr	r3, [sp, #88]	; 0x58
    79c0:	2200      	movs	r2, #0
    79c2:	2103      	movs	r1, #3
    79c4:	47a0      	blx	r4
            break;
    79c6:	e005      	b.n	79d4 <FlexCAN_IRQHandlerRxFIFO+0xfc>
            break;
    79c8:	bf00      	nop
    79ca:	e004      	b.n	79d6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    79cc:	bf00      	nop
    79ce:	e002      	b.n	79d6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    79d0:	bf00      	nop
    79d2:	e000      	b.n	79d6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    79d4:	bf00      	nop
    }
}
    79d6:	bf00      	nop
    79d8:	b018      	add	sp, #96	; 0x60
    79da:	bd10      	pop	{r4, pc}
    79dc:	0000c650 	.word	0x0000c650
    79e0:	1fff8f64 	.word	0x1fff8f64

000079e4 <FlexCAN_AbortTxTransfer>:
 * Description   : Abort transfer for Tx buffer.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_AbortTxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    79e4:	b500      	push	{lr}
    79e6:	b08b      	sub	sp, #44	; 0x2c
    79e8:	4603      	mov	r3, r0
    79ea:	460a      	mov	r2, r1
    79ec:	f88d 3007 	strb.w	r3, [sp, #7]
    79f0:	4613      	mov	r3, r2
    79f2:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    79f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    79fa:	4a3c      	ldr	r2, [pc, #240]	; (7aec <FlexCAN_AbortTxTransfer+0x108>)
    79fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a00:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    7a02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7a06:	4a3a      	ldr	r2, [pc, #232]	; (7af0 <FlexCAN_AbortTxTransfer+0x10c>)
    7a08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a0c:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    7a0e:	2300      	movs	r3, #0
    7a10:	9309      	str	r3, [sp, #36]	; 0x24

    uint32 timeStart = 0U;
    7a12:	2300      	movs	r3, #0
    7a14:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    7a16:	2300      	movs	r3, #0
    7a18:	9308      	str	r3, [sp, #32]
    uint32 flexcan_mb_config = 0;
    7a1a:	2300      	movs	r3, #0
    7a1c:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = 0U;
    7a1e:	2300      	movs	r3, #0
    7a20:	9304      	str	r3, [sp, #16]
    volatile uint32 * flexcan_mb = NULL_PTR;
    7a22:	2300      	movs	r3, #0
    7a24:	9303      	str	r3, [sp, #12]

    flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    7a26:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7a2a:	4619      	mov	r1, r3
    7a2c:	9807      	ldr	r0, [sp, #28]
    7a2e:	f001 ff71 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    7a32:	9003      	str	r0, [sp, #12]
    flexcan_mb_config = * flexcan_mb;
    7a34:	9b03      	ldr	r3, [sp, #12]
    7a36:	681b      	ldr	r3, [r3, #0]
    7a38:	9305      	str	r3, [sp, #20]
    /* Reset the code */
    flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    7a3a:	9b05      	ldr	r3, [sp, #20]
    7a3c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    7a40:	9305      	str	r3, [sp, #20]
    flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    7a42:	9b05      	ldr	r3, [sp, #20]
    7a44:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    7a48:	9305      	str	r3, [sp, #20]
    *flexcan_mb = flexcan_mb_config;
    7a4a:	9b03      	ldr	r3, [sp, #12]
    7a4c:	9a05      	ldr	r2, [sp, #20]
    7a4e:	601a      	str	r2, [r3, #0]

    /* Wait to finish abort operation */
    uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7a50:	2100      	movs	r1, #0
    7a52:	4828      	ldr	r0, [pc, #160]	; (7af4 <FlexCAN_AbortTxTransfer+0x110>)
    7a54:	f7f9 fb3b 	bl	10ce <OsIf_MicrosToTicks>
    7a58:	9004      	str	r0, [sp, #16]
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7a5a:	2000      	movs	r0, #0
    7a5c:	f7f9 faeb 	bl	1036 <OsIf_GetCounter>
    7a60:	4603      	mov	r3, r0
    7a62:	9302      	str	r3, [sp, #8]
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    7a64:	e00f      	b.n	7a86 <FlexCAN_AbortTxTransfer+0xa2>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7a66:	ab02      	add	r3, sp, #8
    7a68:	2100      	movs	r1, #0
    7a6a:	4618      	mov	r0, r3
    7a6c:	f7f9 fafc 	bl	1068 <OsIf_GetElapsed>
    7a70:	4602      	mov	r2, r0
    7a72:	9b08      	ldr	r3, [sp, #32]
    7a74:	4413      	add	r3, r2
    7a76:	9308      	str	r3, [sp, #32]
        if (timeElapsed >= uS2Ticks)
    7a78:	9a08      	ldr	r2, [sp, #32]
    7a7a:	9b04      	ldr	r3, [sp, #16]
    7a7c:	429a      	cmp	r2, r3
    7a7e:	d302      	bcc.n	7a86 <FlexCAN_AbortTxTransfer+0xa2>
        {
            result = FLEXCAN_STATUS_TIMEOUT;
    7a80:	2303      	movs	r3, #3
    7a82:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    7a84:	e008      	b.n	7a98 <FlexCAN_AbortTxTransfer+0xb4>
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    7a86:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7a8a:	4619      	mov	r1, r3
    7a8c:	9807      	ldr	r0, [sp, #28]
    7a8e:	f7ff f8e4 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    7a92:	4603      	mov	r3, r0
    7a94:	2b00      	cmp	r3, #0
    7a96:	d0e6      	beq.n	7a66 <FlexCAN_AbortTxTransfer+0x82>
        }
    }
    if (result != FLEXCAN_STATUS_TIMEOUT)
    7a98:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7a9a:	2b03      	cmp	r3, #3
    7a9c:	d012      	beq.n	7ac4 <FlexCAN_AbortTxTransfer+0xe0>
    {
        flexcan_mb_config = *flexcan_mb;
    7a9e:	9b03      	ldr	r3, [sp, #12]
    7aa0:	681b      	ldr	r3, [r3, #0]
    7aa2:	9305      	str	r3, [sp, #20]
        /* Check if the MBs have been safely Inactivated */
        if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    7aa4:	9b05      	ldr	r3, [sp, #20]
    7aa6:	0e1b      	lsrs	r3, r3, #24
    7aa8:	f003 030f 	and.w	r3, r3, #15
    7aac:	2b08      	cmp	r3, #8
    7aae:	d101      	bne.n	7ab4 <FlexCAN_AbortTxTransfer+0xd0>
        {
            /* Transmission have occurred */
            result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    7ab0:	2305      	movs	r3, #5
    7ab2:	9309      	str	r3, [sp, #36]	; 0x24
        }

        if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    7ab4:	9b05      	ldr	r3, [sp, #20]
    7ab6:	0e1b      	lsrs	r3, r3, #24
    7ab8:	f003 030f 	and.w	r3, r3, #15
    7abc:	2b09      	cmp	r3, #9
    7abe:	d101      	bne.n	7ac4 <FlexCAN_AbortTxTransfer+0xe0>
        {
            /* Transmission have been aborted */
            result = FLEXCAN_STATUS_SUCCESS;
    7ac0:	2300      	movs	r3, #0
    7ac2:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    7ac4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ac8:	4619      	mov	r1, r3
    7aca:	9807      	ldr	r0, [sp, #28]
    7acc:	f7ff f8b2 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    7ad0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ad4:	9a06      	ldr	r2, [sp, #24]
    7ad6:	011b      	lsls	r3, r3, #4
    7ad8:	4413      	add	r3, r2
    7ada:	3304      	adds	r3, #4
    7adc:	2200      	movs	r2, #0
    7ade:	601a      	str	r2, [r3, #0]

    return result;
    7ae0:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    7ae2:	4618      	mov	r0, r3
    7ae4:	b00b      	add	sp, #44	; 0x2c
    7ae6:	f85d fb04 	ldr.w	pc, [sp], #4
    7aea:	bf00      	nop
    7aec:	0000c650 	.word	0x0000c650
    7af0:	1fff8f64 	.word	0x1fff8f64
    7af4:	000f4240 	.word	0x000f4240

00007af8 <FlexCAN_AbortRxTransfer>:
 * Description   : Abort transfer for Rx normal or legacy fifo if enabled.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static void FlexCAN_AbortRxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    7af8:	b500      	push	{lr}
    7afa:	b089      	sub	sp, #36	; 0x24
    7afc:	4603      	mov	r3, r0
    7afe:	460a      	mov	r2, r1
    7b00:	f88d 3007 	strb.w	r3, [sp, #7]
    7b04:	4613      	mov	r3, r2
    7b06:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    7b0a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7b0e:	4a41      	ldr	r2, [pc, #260]	; (7c14 <FlexCAN_AbortRxTransfer+0x11c>)
    7b10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b14:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    7b16:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7b1a:	4a3f      	ldr	r2, [pc, #252]	; (7c18 <FlexCAN_AbortRxTransfer+0x120>)
    7b1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b20:	9306      	str	r3, [sp, #24]
    uint8 val1 = 0U;
    7b22:	2300      	movs	r3, #0
    7b24:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 val2 = 0U;
    7b28:	2300      	movs	r3, #0
    7b2a:	9304      	str	r3, [sp, #16]
    uint32 flexcan_mb_config = 0;
    7b2c:	2300      	movs	r3, #0
    7b2e:	9303      	str	r3, [sp, #12]
    volatile uint32 * flexcan_mb = NULL_PTR;
    7b30:	2300      	movs	r3, #0
    7b32:	9302      	str	r3, [sp, #8]

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    7b34:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7b38:	9a06      	ldr	r2, [sp, #24]
    7b3a:	011b      	lsls	r3, r3, #4
    7b3c:	4413      	add	r3, r2
    7b3e:	3304      	adds	r3, #4
    7b40:	2200      	movs	r2, #0
    7b42:	601a      	str	r2, [r3, #0]
    /* Check if fifo enabled */
    if (TRUE == state->bIsLegacyFifoEn)
    7b44:	9b06      	ldr	r3, [sp, #24]
    7b46:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    7b4a:	2b00      	cmp	r3, #0
    7b4c:	d03c      	beq.n	7bc8 <FlexCAN_AbortRxTransfer+0xd0>
    {
        /* Get the number of RX FIFO Filters*/
        val1 = (uint8)(((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    7b4e:	9b07      	ldr	r3, [sp, #28]
    7b50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7b52:	0e1b      	lsrs	r3, r3, #24
    7b54:	b2db      	uxtb	r3, r3
    7b56:	f003 030f 	and.w	r3, r3, #15
    7b5a:	f88d 3017 	strb.w	r3, [sp, #23]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        val2 = RxFifoOcuppiedLastMsgBuff(val1);
    7b5e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7b62:	4618      	mov	r0, r3
    7b64:	f7ff f9f3 	bl	6f4e <RxFifoOcuppiedLastMsgBuff>
    7b68:	9004      	str	r0, [sp, #16]
        if (mb_idx > val2)
    7b6a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7b6e:	9a04      	ldr	r2, [sp, #16]
    7b70:	429a      	cmp	r2, r3
    7b72:	d21b      	bcs.n	7bac <FlexCAN_AbortRxTransfer+0xb4>
        {
            /* This operation is not allowed for MB that are part of RxFIFO */
            flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    7b74:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7b78:	4619      	mov	r1, r3
    7b7a:	9807      	ldr	r0, [sp, #28]
    7b7c:	f001 feca 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    7b80:	9002      	str	r0, [sp, #8]
            flexcan_mb_config = * flexcan_mb;
    7b82:	9b02      	ldr	r3, [sp, #8]
    7b84:	681b      	ldr	r3, [r3, #0]
    7b86:	9303      	str	r3, [sp, #12]
            /* Reset the code and unlock the MB */
            flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    7b88:	9b03      	ldr	r3, [sp, #12]
    7b8a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    7b8e:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
            *flexcan_mb = flexcan_mb_config;
    7b90:	9b02      	ldr	r3, [sp, #8]
    7b92:	9a03      	ldr	r2, [sp, #12]
    7b94:	601a      	str	r2, [r3, #0]
            /* Reconfigure The MB as left by RxMBconfig */
            flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    7b96:	9b03      	ldr	r3, [sp, #12]
    7b98:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    7b9c:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    7b9e:	9b03      	ldr	r3, [sp, #12]
    7ba0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    7ba4:	9303      	str	r3, [sp, #12]
            *flexcan_mb = flexcan_mb_config;
    7ba6:	9b02      	ldr	r3, [sp, #8]
    7ba8:	9a03      	ldr	r2, [sp, #12]
    7baa:	601a      	str	r2, [r3, #0]
        }
        if (FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    7bac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7bb0:	2b00      	cmp	r3, #0
    7bb2:	d125      	bne.n	7c00 <FlexCAN_AbortRxTransfer+0x108>
        {
            FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, state->isIntActive);
    7bb4:	9b06      	ldr	r3, [sp, #24]
    7bb6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    7bba:	f89d 1007 	ldrb.w	r1, [sp, #7]
    7bbe:	2205      	movs	r2, #5
    7bc0:	9807      	ldr	r0, [sp, #28]
    7bc2:	f002 fa85 	bl	a0d0 <FLEXCAN_ClearMsgBuffIntCmd>
    7bc6:	e01b      	b.n	7c00 <FlexCAN_AbortRxTransfer+0x108>
        }
    }
    else
    {
        /* This operation is not allowed for MB that are part of RxFIFO */
        flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    7bc8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7bcc:	4619      	mov	r1, r3
    7bce:	9807      	ldr	r0, [sp, #28]
    7bd0:	f001 fea0 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    7bd4:	9002      	str	r0, [sp, #8]
        flexcan_mb_config = * flexcan_mb;
    7bd6:	9b02      	ldr	r3, [sp, #8]
    7bd8:	681b      	ldr	r3, [r3, #0]
    7bda:	9303      	str	r3, [sp, #12]
        /* Reset the code and unlock the MB */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    7bdc:	9b03      	ldr	r3, [sp, #12]
    7bde:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    7be2:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
        *flexcan_mb = flexcan_mb_config;
    7be4:	9b02      	ldr	r3, [sp, #8]
    7be6:	9a03      	ldr	r2, [sp, #12]
    7be8:	601a      	str	r2, [r3, #0]
        /* Reconfigure The MB as left by RxMBconfig */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    7bea:	9b03      	ldr	r3, [sp, #12]
    7bec:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    7bf0:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    7bf2:	9b03      	ldr	r3, [sp, #12]
    7bf4:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    7bf8:	9303      	str	r3, [sp, #12]
        *flexcan_mb = flexcan_mb_config;
    7bfa:	9b02      	ldr	r3, [sp, #8]
    7bfc:	9a03      	ldr	r2, [sp, #12]
    7bfe:	601a      	str	r2, [r3, #0]
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    7c00:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7c04:	4619      	mov	r1, r3
    7c06:	9807      	ldr	r0, [sp, #28]
    7c08:	f7ff f814 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
}
    7c0c:	bf00      	nop
    7c0e:	b009      	add	sp, #36	; 0x24
    7c10:	f85d fb04 	ldr.w	pc, [sp], #4
    7c14:	0000c650 	.word	0x0000c650
    7c18:	1fff8f64 	.word	0x1fff8f64

00007c1c <FlexCAN_Ip_Init_Privileged>:
/* implements FlexCAN_Ip_Init_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Init_Privileged(uint8 Flexcan_Ip_u8Instance,
                                                 Flexcan_Ip_StateType * Flexcan_Ip_pState,
                                                 const Flexcan_Ip_ConfigType * Flexcan_Ip_pData
                                                )
{
    7c1c:	b500      	push	{lr}
    7c1e:	b089      	sub	sp, #36	; 0x24
    7c20:	4603      	mov	r3, r0
    7c22:	9102      	str	r1, [sp, #8]
    7c24:	9201      	str	r2, [sp, #4]
    7c26:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    7c2a:	2300      	movs	r3, #0
    7c2c:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    7c2e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7c32:	4a36      	ldr	r2, [pc, #216]	; (7d0c <FlexCAN_Ip_Init_Privileged+0xf0>)
    7c34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c38:	9305      	str	r3, [sp, #20]
    {
        OsIf_Trusted_Call1param(FlexCAN_SetUserAccessAllowed, pBase);
    }
#endif

    eResult = FlexCAN_InitController(Flexcan_Ip_u8Instance, pBase, Flexcan_Ip_pData);
    7c3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7c3e:	9a01      	ldr	r2, [sp, #4]
    7c40:	9905      	ldr	r1, [sp, #20]
    7c42:	4618      	mov	r0, r3
    7c44:	f7ff fa84 	bl	7150 <FlexCAN_InitController>
    7c48:	9006      	str	r0, [sp, #24]
    if (FLEXCAN_STATUS_SUCCESS == eResult)
    7c4a:	9b06      	ldr	r3, [sp, #24]
    7c4c:	2b00      	cmp	r3, #0
    7c4e:	d158      	bne.n	7d02 <FlexCAN_Ip_Init_Privileged+0xe6>
    {
        /* Init Baudrate */
        FlexCAN_InitBaudrate(pBase, Flexcan_Ip_pData);
    7c50:	9901      	ldr	r1, [sp, #4]
    7c52:	9805      	ldr	r0, [sp, #20]
    7c54:	f7ff fad6 	bl	7204 <FlexCAN_InitBaudrate>
        /* Select mode */
        FlexCAN_SetOperationMode(pBase, Flexcan_Ip_pData->flexcanMode);
    7c58:	9b01      	ldr	r3, [sp, #4]
    7c5a:	68db      	ldr	r3, [r3, #12]
    7c5c:	4619      	mov	r1, r3
    7c5e:	9805      	ldr	r0, [sp, #20]
    7c60:	f002 fd48 	bl	a6f4 <FlexCAN_SetOperationMode>

#if (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON)
        FlexCAN_ConfigTimestamp(Flexcan_Ip_u8Instance, pBase, (const Flexcan_Ip_TimeStampConfigType *)(&Flexcan_Ip_pData->time_stamp));
#endif   /* (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON) */

        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    7c64:	2300      	movs	r3, #0
    7c66:	9307      	str	r3, [sp, #28]
    7c68:	e01d      	b.n	7ca6 <FlexCAN_Ip_Init_Privileged+0x8a>
        {
            /* Check if blocking need to be any more present in sync\async discussions */
            /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
            Flexcan_Ip_pState->mbs[i].isPolling = TRUE;
    7c6a:	9a02      	ldr	r2, [sp, #8]
    7c6c:	9b07      	ldr	r3, [sp, #28]
    7c6e:	011b      	lsls	r3, r3, #4
    7c70:	4413      	add	r3, r2
    7c72:	3308      	adds	r3, #8
    7c74:	2201      	movs	r2, #1
    7c76:	701a      	strb	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].pMBmessage = NULL_PTR;
    7c78:	9a02      	ldr	r2, [sp, #8]
    7c7a:	9b07      	ldr	r3, [sp, #28]
    7c7c:	011b      	lsls	r3, r3, #4
    7c7e:	4413      	add	r3, r2
    7c80:	2200      	movs	r2, #0
    7c82:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].state = FLEXCAN_MB_IDLE;
    7c84:	9a02      	ldr	r2, [sp, #8]
    7c86:	9b07      	ldr	r3, [sp, #28]
    7c88:	011b      	lsls	r3, r3, #4
    7c8a:	4413      	add	r3, r2
    7c8c:	3304      	adds	r3, #4
    7c8e:	2200      	movs	r2, #0
    7c90:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].time_stamp = 0U;
    7c92:	9a02      	ldr	r2, [sp, #8]
    7c94:	9b07      	ldr	r3, [sp, #28]
    7c96:	011b      	lsls	r3, r3, #4
    7c98:	4413      	add	r3, r2
    7c9a:	330c      	adds	r3, #12
    7c9c:	2200      	movs	r2, #0
    7c9e:	601a      	str	r2, [r3, #0]
        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    7ca0:	9b07      	ldr	r3, [sp, #28]
    7ca2:	3301      	adds	r3, #1
    7ca4:	9307      	str	r3, [sp, #28]
    7ca6:	9b07      	ldr	r3, [sp, #28]
    7ca8:	2b1f      	cmp	r3, #31
    7caa:	d9de      	bls.n	7c6a <FlexCAN_Ip_Init_Privileged+0x4e>
        /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
        Flexcan_Ip_pState->enhancedFifoOutput.isPolling = TRUE;
        Flexcan_Ip_pState->enhancedFifoOutput.state = FLEXCAN_MB_IDLE;
#endif

        Flexcan_Ip_pState->transferType = Flexcan_Ip_pData->transfer_type;
    7cac:	9b01      	ldr	r3, [sp, #4]
    7cae:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    7cb0:	9b02      	ldr	r3, [sp, #8]
    7cb2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        Flexcan_Ip_pState->u32NumOfMbTransferByDMA = Flexcan_Ip_pData->num_enhanced_watermark;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

        /* Clear Callbacks in case of autovariables garbage */
        Flexcan_Ip_pState->callback = Flexcan_Ip_pData->Callback;
    7cb6:	9b01      	ldr	r3, [sp, #4]
    7cb8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    7cba:	9b02      	ldr	r3, [sp, #8]
    7cbc:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        Flexcan_Ip_pState->callbackParam = NULL_PTR;
    7cc0:	9b02      	ldr	r3, [sp, #8]
    7cc2:	2200      	movs	r2, #0
    7cc4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
        Flexcan_Ip_pState->error_callback = Flexcan_Ip_pData->ErrorCallback;
    7cc8:	9b01      	ldr	r3, [sp, #4]
    7cca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    7ccc:	9b02      	ldr	r3, [sp, #8]
    7cce:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
        Flexcan_Ip_pState->errorCallbackParam = NULL_PTR;
    7cd2:	9b02      	ldr	r3, [sp, #8]
    7cd4:	2200      	movs	r2, #0
    7cd6:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
        Flexcan_Ip_pState->bIsLegacyFifoEn = Flexcan_Ip_pData->is_rx_fifo_needed;
    7cda:	9b01      	ldr	r3, [sp, #4]
    7cdc:	7a1a      	ldrb	r2, [r3, #8]
    7cde:	9b02      	ldr	r3, [sp, #8]
    7ce0:	f883 2214 	strb.w	r2, [r3, #532]	; 0x214
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
        Flexcan_Ip_pState->bIsEnhancedFifoEn = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
        Flexcan_Ip_pState->u32MaxMbNum = Flexcan_Ip_pData->max_num_mb;
    7ce4:	9b01      	ldr	r3, [sp, #4]
    7ce6:	681a      	ldr	r2, [r3, #0]
    7ce8:	9b02      	ldr	r3, [sp, #8]
    7cea:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
        Flexcan_Ip_pState->isIntActive = TRUE;
    7cee:	9b02      	ldr	r3, [sp, #8]
    7cf0:	2201      	movs	r2, #1
    7cf2:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        /* Save runtime structure pointers so irq handler can point to the correct state structure */
        Flexcan_Ip_apxState[Flexcan_Ip_u8Instance] = Flexcan_Ip_pState;
    7cf6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7cfa:	4905      	ldr	r1, [pc, #20]	; (7d10 <FlexCAN_Ip_Init_Privileged+0xf4>)
    7cfc:	9a02      	ldr	r2, [sp, #8]
    7cfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return eResult;
    7d02:	9b06      	ldr	r3, [sp, #24]
}
    7d04:	4618      	mov	r0, r3
    7d06:	b009      	add	sp, #36	; 0x24
    7d08:	f85d fb04 	ldr.w	pc, [sp], #4
    7d0c:	0000c650 	.word	0x0000c650
    7d10:	1fff8f64 	.word	0x1fff8f64

00007d14 <FlexCAN_Ip_Send>:
                                      uint8 mb_idx,
                                      const Flexcan_Ip_DataInfoType * tx_info,
                                      uint32 msg_id,
                                      const uint8 * mb_data
                                     )
{
    7d14:	b500      	push	{lr}
    7d16:	b089      	sub	sp, #36	; 0x24
    7d18:	9204      	str	r2, [sp, #16]
    7d1a:	9303      	str	r3, [sp, #12]
    7d1c:	4603      	mov	r3, r0
    7d1e:	f88d 3017 	strb.w	r3, [sp, #23]
    7d22:	460b      	mov	r3, r1
    7d24:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    7d28:	2301      	movs	r3, #1
    7d2a:	9307      	str	r3, [sp, #28]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
#else
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    7d2c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7d30:	4a0e      	ldr	r2, [pc, #56]	; (7d6c <FlexCAN_Ip_Send+0x58>)
    7d32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d36:	9306      	str	r3, [sp, #24]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif
    if (!FlexCAN_IsListenOnlyModeEnabled(base))
    7d38:	9806      	ldr	r0, [sp, #24]
    7d3a:	f7ff f8fa 	bl	6f32 <FlexCAN_IsListenOnlyModeEnabled>
    7d3e:	4603      	mov	r3, r0
    7d40:	f083 0301 	eor.w	r3, r3, #1
    7d44:	b2db      	uxtb	r3, r3
    7d46:	2b00      	cmp	r3, #0
    7d48:	d00a      	beq.n	7d60 <FlexCAN_Ip_Send+0x4c>
    {
        result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    7d4a:	f89d 1016 	ldrb.w	r1, [sp, #22]
    7d4e:	f89d 0017 	ldrb.w	r0, [sp, #23]
    7d52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7d54:	9300      	str	r3, [sp, #0]
    7d56:	9b03      	ldr	r3, [sp, #12]
    7d58:	9a04      	ldr	r2, [sp, #16]
    7d5a:	f7ff fb51 	bl	7400 <FlexCAN_StartSendData>
    7d5e:	9007      	str	r0, [sp, #28]
            /* Enable message buffer interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
        }
#endif
    }
    return result;
    7d60:	9b07      	ldr	r3, [sp, #28]
}
    7d62:	4618      	mov	r0, r3
    7d64:	b009      	add	sp, #36	; 0x24
    7d66:	f85d fb04 	ldr.w	pc, [sp], #4
    7d6a:	bf00      	nop
    7d6c:	0000c650 	.word	0x0000c650

00007d70 <FlexCAN_Ip_ConfigRxMb>:
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxMb(uint8 instance,
                                            uint8 mb_idx,
                                            const Flexcan_Ip_DataInfoType * rx_info,
                                            uint32 msg_id
                                           )
{
    7d70:	b500      	push	{lr}
    7d72:	b08b      	sub	sp, #44	; 0x2c
    7d74:	9202      	str	r2, [sp, #8]
    7d76:	9301      	str	r3, [sp, #4]
    7d78:	4603      	mov	r3, r0
    7d7a:	f88d 300f 	strb.w	r3, [sp, #15]
    7d7e:	460b      	mov	r3, r1
    7d80:	f88d 300e 	strb.w	r3, [sp, #14]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    7d84:	2300      	movs	r3, #0
    7d86:	9309      	str	r3, [sp, #36]	; 0x24
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    7d88:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7d8c:	4a19      	ldr	r2, [pc, #100]	; (7df4 <FlexCAN_Ip_ConfigRxMb+0x84>)
    7d8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d92:	9308      	str	r3, [sp, #32]
    }
    else
    {
#endif
        /* Clear the message buffer flag if previous remained triggered */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    7d94:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7d98:	4619      	mov	r1, r3
    7d9a:	9808      	ldr	r0, [sp, #32]
    7d9c:	f7fe ff4a 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>

        cs.dataLen = rx_info->data_length;
    7da0:	9b02      	ldr	r3, [sp, #8]
    7da2:	685b      	ldr	r3, [r3, #4]
    7da4:	9306      	str	r3, [sp, #24]
        cs.msgIdType = rx_info->msg_id_type;
    7da6:	9b02      	ldr	r3, [sp, #8]
    7da8:	681b      	ldr	r3, [r3, #0]
    7daa:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = rx_info->fd_enable;
    7dac:	9b02      	ldr	r3, [sp, #8]
    7dae:	7a1b      	ldrb	r3, [r3, #8]
    7db0:	f88d 301c 	strb.w	r3, [sp, #28]
    #endif

        /* Initialize rx mb*/
        cs.code = (uint32)FLEXCAN_RX_NOT_USED;
    7db4:	230f      	movs	r3, #15
    7db6:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    7db8:	f89d 100e 	ldrb.w	r1, [sp, #14]
    7dbc:	aa04      	add	r2, sp, #16
    7dbe:	9b01      	ldr	r3, [sp, #4]
    7dc0:	9808      	ldr	r0, [sp, #32]
    7dc2:	f002 f9d3 	bl	a16c <FlexCAN_SetRxMsgBuff>

        /* Initialize receive MB*/
        cs.code = (uint32)FLEXCAN_RX_INACTIVE;
    7dc6:	2300      	movs	r3, #0
    7dc8:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    7dca:	f89d 100e 	ldrb.w	r1, [sp, #14]
    7dce:	aa04      	add	r2, sp, #16
    7dd0:	9b01      	ldr	r3, [sp, #4]
    7dd2:	9808      	ldr	r0, [sp, #32]
    7dd4:	f002 f9ca 	bl	a16c <FlexCAN_SetRxMsgBuff>

        /* Set up FlexCAN message buffer fields for receiving data*/
        cs.code = (uint32)FLEXCAN_RX_EMPTY;
    7dd8:	2304      	movs	r3, #4
    7dda:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    7ddc:	f89d 100e 	ldrb.w	r1, [sp, #14]
    7de0:	aa04      	add	r2, sp, #16
    7de2:	9b01      	ldr	r3, [sp, #4]
    7de4:	9808      	ldr	r0, [sp, #32]
    7de6:	f002 f9c1 	bl	a16c <FlexCAN_SetRxMsgBuff>
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    7dea:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    7dec:	4618      	mov	r0, r3
    7dee:	b00b      	add	sp, #44	; 0x2c
    7df0:	f85d fb04 	ldr.w	pc, [sp], #4
    7df4:	0000c650 	.word	0x0000c650

00007df8 <FlexCAN_Ip_Receive>:
Flexcan_Ip_StatusType FlexCAN_Ip_Receive(uint8 instance,
                                         uint8 mb_idx,
                                         Flexcan_Ip_MsgBuffType * data,
                                         boolean isPolling
                                        )
{
    7df8:	b500      	push	{lr}
    7dfa:	b085      	sub	sp, #20
    7dfc:	9200      	str	r2, [sp, #0]
    7dfe:	461a      	mov	r2, r3
    7e00:	4603      	mov	r3, r0
    7e02:	f88d 3007 	strb.w	r3, [sp, #7]
    7e06:	460b      	mov	r3, r1
    7e08:	f88d 3006 	strb.w	r3, [sp, #6]
    7e0c:	4613      	mov	r3, r2
    7e0e:	f88d 3005 	strb.w	r3, [sp, #5]
#endif
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    #endif

    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    7e12:	f89d 3005 	ldrb.w	r3, [sp, #5]
    7e16:	f89d 1006 	ldrb.w	r1, [sp, #6]
    7e1a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    7e1e:	9a00      	ldr	r2, [sp, #0]
    7e20:	f7ff fab0 	bl	7384 <FlexCAN_StartRxMessageBufferData>
    7e24:	9003      	str	r0, [sp, #12]
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    }
#endif
    return result;
    7e26:	9b03      	ldr	r3, [sp, #12]
}
    7e28:	4618      	mov	r0, r3
    7e2a:	b005      	add	sp, #20
    7e2c:	f85d fb04 	ldr.w	pc, [sp], #4

00007e30 <FlexCAN_Ip_ReceiveBlocking>:
                                                 uint8 mb_idx,
                                                 Flexcan_Ip_MsgBuffType * data,
                                                 boolean isPolling,
                                                 uint32 u32TimeoutMs
                                                )
{
    7e30:	b500      	push	{lr}
    7e32:	b089      	sub	sp, #36	; 0x24
    7e34:	9200      	str	r2, [sp, #0]
    7e36:	461a      	mov	r2, r3
    7e38:	4603      	mov	r3, r0
    7e3a:	f88d 3007 	strb.w	r3, [sp, #7]
    7e3e:	460b      	mov	r3, r1
    7e40:	f88d 3006 	strb.w	r3, [sp, #6]
    7e44:	4613      	mov	r3, r2
    7e46:	f88d 3005 	strb.w	r3, [sp, #5]
    Flexcan_Ip_StatusType result;
    uint32 timeStart = 0U;
    7e4a:	2300      	movs	r3, #0
    7e4c:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    7e4e:	2300      	movs	r3, #0
    7e50:	9306      	str	r3, [sp, #24]
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7e52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7e54:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    7e58:	fb02 f303 	mul.w	r3, r2, r3
    7e5c:	2100      	movs	r1, #0
    7e5e:	4618      	mov	r0, r3
    7e60:	f7f9 f935 	bl	10ce <OsIf_MicrosToTicks>
    7e64:	9005      	str	r0, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    7e66:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7e6a:	4a37      	ldr	r2, [pc, #220]	; (7f48 <FlexCAN_Ip_ReceiveBlocking+0x118>)
    7e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e70:	9304      	str	r3, [sp, #16]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#else
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    7e72:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7e76:	4a35      	ldr	r2, [pc, #212]	; (7f4c <FlexCAN_Ip_ReceiveBlocking+0x11c>)
    7e78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e7c:	9303      	str	r3, [sp, #12]
#endif
    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    7e7e:	f89d 3005 	ldrb.w	r3, [sp, #5]
    7e82:	f89d 1006 	ldrb.w	r1, [sp, #6]
    7e86:	f89d 0007 	ldrb.w	r0, [sp, #7]
    7e8a:	9a00      	ldr	r2, [sp, #0]
    7e8c:	f7ff fa7a 	bl	7384 <FlexCAN_StartRxMessageBufferData>
    7e90:	9007      	str	r0, [sp, #28]
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    7e92:	9b07      	ldr	r3, [sp, #28]
    7e94:	2b00      	cmp	r3, #0
    7e96:	d133      	bne.n	7f00 <FlexCAN_Ip_ReceiveBlocking+0xd0>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7e98:	2000      	movs	r0, #0
    7e9a:	f7f9 f8cc 	bl	1036 <OsIf_GetCounter>
    7e9e:	4603      	mov	r3, r0
    7ea0:	9302      	str	r3, [sp, #8]
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    7ea2:	e024      	b.n	7eee <FlexCAN_Ip_ReceiveBlocking+0xbe>
        {
            if (TRUE == isPolling)
    7ea4:	f89d 3005 	ldrb.w	r3, [sp, #5]
    7ea8:	2b00      	cmp	r3, #0
    7eaa:	d010      	beq.n	7ece <FlexCAN_Ip_ReceiveBlocking+0x9e>
            {
                if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    7eac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7eb0:	4619      	mov	r1, r3
    7eb2:	9803      	ldr	r0, [sp, #12]
    7eb4:	f7fe fed1 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    7eb8:	4603      	mov	r3, r0
    7eba:	2b00      	cmp	r3, #0
    7ebc:	d007      	beq.n	7ece <FlexCAN_Ip_ReceiveBlocking+0x9e>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    7ebe:	f89d 2006 	ldrb.w	r2, [sp, #6]
    7ec2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7ec6:	4611      	mov	r1, r2
    7ec8:	4618      	mov	r0, r3
    7eca:	f7ff fb7d 	bl	75c8 <FlexCAN_IRQHandlerRxMB>
                }
            }
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    7ece:	ab02      	add	r3, sp, #8
    7ed0:	2100      	movs	r1, #0
    7ed2:	4618      	mov	r0, r3
    7ed4:	f7f9 f8c8 	bl	1068 <OsIf_GetElapsed>
    7ed8:	4602      	mov	r2, r0
    7eda:	9b06      	ldr	r3, [sp, #24]
    7edc:	4413      	add	r3, r2
    7ede:	9306      	str	r3, [sp, #24]
            if (timeElapsed >= mS2Ticks)
    7ee0:	9a06      	ldr	r2, [sp, #24]
    7ee2:	9b05      	ldr	r3, [sp, #20]
    7ee4:	429a      	cmp	r2, r3
    7ee6:	d302      	bcc.n	7eee <FlexCAN_Ip_ReceiveBlocking+0xbe>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    7ee8:	2303      	movs	r3, #3
    7eea:	9307      	str	r3, [sp, #28]
                break;
    7eec:	e008      	b.n	7f00 <FlexCAN_Ip_ReceiveBlocking+0xd0>
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    7eee:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7ef2:	9a04      	ldr	r2, [sp, #16]
    7ef4:	011b      	lsls	r3, r3, #4
    7ef6:	4413      	add	r3, r2
    7ef8:	3304      	adds	r3, #4
    7efa:	681b      	ldr	r3, [r3, #0]
    7efc:	2b01      	cmp	r3, #1
    7efe:	d0d1      	beq.n	7ea4 <FlexCAN_Ip_ReceiveBlocking+0x74>
            }
        }
    }

    if ((FLEXCAN_STATUS_TIMEOUT == result) && (FALSE == isPolling))
    7f00:	9b07      	ldr	r3, [sp, #28]
    7f02:	2b03      	cmp	r3, #3
        /* Disable Mb interrupt*/
       (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
#endif
    }

    if ((FLEXCAN_STATUS_BUFF_OUT_OF_RANGE != result) && (FLEXCAN_STATUS_BUSY != result))
    7f04:	9b07      	ldr	r3, [sp, #28]
    7f06:	2b04      	cmp	r3, #4
    7f08:	d018      	beq.n	7f3c <FlexCAN_Ip_ReceiveBlocking+0x10c>
    7f0a:	9b07      	ldr	r3, [sp, #28]
    7f0c:	2b02      	cmp	r3, #2
    7f0e:	d015      	beq.n	7f3c <FlexCAN_Ip_ReceiveBlocking+0x10c>
    {
        if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state))
    7f10:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7f14:	9a04      	ldr	r2, [sp, #16]
    7f16:	011b      	lsls	r3, r3, #4
    7f18:	4413      	add	r3, r2
    7f1a:	3304      	adds	r3, #4
    7f1c:	681b      	ldr	r3, [r3, #0]
    7f1e:	2b00      	cmp	r3, #0
    7f20:	d102      	bne.n	7f28 <FlexCAN_Ip_ReceiveBlocking+0xf8>
        {
            result = FLEXCAN_STATUS_SUCCESS;
    7f22:	2300      	movs	r3, #0
    7f24:	9307      	str	r3, [sp, #28]
    7f26:	e009      	b.n	7f3c <FlexCAN_Ip_ReceiveBlocking+0x10c>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    7f28:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7f2c:	9a04      	ldr	r2, [sp, #16]
    7f2e:	011b      	lsls	r3, r3, #4
    7f30:	4413      	add	r3, r2
    7f32:	3304      	adds	r3, #4
    7f34:	2200      	movs	r2, #0
    7f36:	601a      	str	r2, [r3, #0]
            result = FLEXCAN_STATUS_TIMEOUT;
    7f38:	2303      	movs	r3, #3
    7f3a:	9307      	str	r3, [sp, #28]
        }
    }
    return result;
    7f3c:	9b07      	ldr	r3, [sp, #28]
}
    7f3e:	4618      	mov	r0, r3
    7f40:	b009      	add	sp, #36	; 0x24
    7f42:	f85d fb04 	ldr.w	pc, [sp], #4
    7f46:	bf00      	nop
    7f48:	1fff8f64 	.word	0x1fff8f64
    7f4c:	0000c650 	.word	0x0000c650

00007f50 <FlexCAN_Ip_RxFifo>:
 * after the frame was received and read into the specified buffer.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_RxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifo(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    7f50:	b500      	push	{lr}
    7f52:	b085      	sub	sp, #20
    7f54:	4603      	mov	r3, r0
    7f56:	9100      	str	r1, [sp, #0]
    7f58:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    7f5c:	2300      	movs	r3, #0
    7f5e:	9303      	str	r3, [sp, #12]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    7f60:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7f64:	9900      	ldr	r1, [sp, #0]
    7f66:	4618      	mov	r0, r3
    7f68:	f7ff face 	bl	7508 <FlexCAN_StartRxMessageFifoData>
    7f6c:	9003      	str	r0, [sp, #12]
    }
    return result;
    7f6e:	9b03      	ldr	r3, [sp, #12]
}
    7f70:	4618      	mov	r0, r3
    7f72:	b005      	add	sp, #20
    7f74:	f85d fb04 	ldr.w	pc, [sp], #4

00007f78 <FlexCAN_Ip_RxFifoBlocking>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_RxFifoBlocking_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifoBlocking(uint8 instance, Flexcan_Ip_MsgBuffType *data, uint32 timeout)
{
    7f78:	b500      	push	{lr}
    7f7a:	b087      	sub	sp, #28
    7f7c:	4603      	mov	r3, r0
    7f7e:	9102      	str	r1, [sp, #8]
    7f80:	9201      	str	r2, [sp, #4]
    7f82:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    7f86:	2300      	movs	r3, #0
    7f88:	9305      	str	r3, [sp, #20]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    7f8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7f8e:	9902      	ldr	r1, [sp, #8]
    7f90:	4618      	mov	r0, r3
    7f92:	f7ff fab9 	bl	7508 <FlexCAN_StartRxMessageFifoData>
    7f96:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == result)
    7f98:	9b05      	ldr	r3, [sp, #20]
    7f9a:	2b00      	cmp	r3, #0
    7f9c:	d106      	bne.n	7fac <FlexCAN_Ip_RxFifoBlocking+0x34>
        {
            result = FlexCAN_ProccessLegacyRxFIFO(instance, timeout);
    7f9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7fa2:	9901      	ldr	r1, [sp, #4]
    7fa4:	4618      	mov	r0, r3
    7fa6:	f7ff f952 	bl	724e <FlexCAN_ProccessLegacyRxFIFO>
    7faa:	9005      	str	r0, [sp, #20]
        }
    }
    return result;
    7fac:	9b05      	ldr	r3, [sp, #20]
}
    7fae:	4618      	mov	r0, r3
    7fb0:	b007      	add	sp, #28
    7fb2:	f85d fb04 	ldr.w	pc, [sp], #4

00007fb6 <FlexCAN_Ip_ConfigRxFifo_Privileged>:
/* implements FlexCAN_Ip_ConfigRxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxFifo_Privileged(uint8 instance,
                                                         Flexcan_Ip_RxFifoIdElementFormatType id_format,
                                                         const Flexcan_Ip_IdTableType * id_filter_table
                                                        )
{
    7fb6:	b500      	push	{lr}
    7fb8:	b089      	sub	sp, #36	; 0x24
    7fba:	4603      	mov	r3, r0
    7fbc:	9102      	str	r1, [sp, #8]
    7fbe:	9201      	str	r2, [sp, #4]
    7fc0:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    7fc4:	2300      	movs	r3, #0
    7fc6:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    7fc8:	2300      	movs	r3, #0
    7fca:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    7fcc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7fd0:	4a1c      	ldr	r2, [pc, #112]	; (8044 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x8e>)
    7fd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fd6:	9305      	str	r3, [sp, #20]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    7fd8:	9805      	ldr	r0, [sp, #20]
    7fda:	f7fe fdd1 	bl	6b80 <FlexCAN_IsEnabled>
    7fde:	4603      	mov	r3, r0
    7fe0:	2b00      	cmp	r3, #0
    7fe2:	bf14      	ite	ne
    7fe4:	2301      	movne	r3, #1
    7fe6:	2300      	moveq	r3, #0
    7fe8:	b2db      	uxtb	r3, r3
    7fea:	f083 0301 	eor.w	r3, r3, #1
    7fee:	b2db      	uxtb	r3, r3
    7ff0:	f88d 3013 	strb.w	r3, [sp, #19]
    7ff4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    7ff8:	f003 0301 	and.w	r3, r3, #1
    7ffc:	f88d 3013 	strb.w	r3, [sp, #19]

    if (TRUE == disabled)
    8000:	f89d 3013 	ldrb.w	r3, [sp, #19]
    8004:	2b00      	cmp	r3, #0
    8006:	d003      	beq.n	8010 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x5a>
    {
        result = FlexCAN_Enable(pBase);
    8008:	9805      	ldr	r0, [sp, #20]
    800a:	f001 fd6b 	bl	9ae4 <FlexCAN_Enable>
    800e:	9007      	str	r0, [sp, #28]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    8010:	9b07      	ldr	r3, [sp, #28]
    8012:	2b00      	cmp	r3, #0
    8014:	d104      	bne.n	8020 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x6a>
    {
        /* Initialize rx fifo*/
        FlexCAN_SetRxFifoFilter(pBase, id_format, id_filter_table);
    8016:	9a01      	ldr	r2, [sp, #4]
    8018:	9902      	ldr	r1, [sp, #8]
    801a:	9805      	ldr	r0, [sp, #20]
    801c:	f002 fba5 	bl	a76a <FlexCAN_SetRxFifoFilter>
    }

    if (TRUE == disabled)
    8020:	f89d 3013 	ldrb.w	r3, [sp, #19]
    8024:	2b00      	cmp	r3, #0
    8026:	d008      	beq.n	803a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
    {
        status = FlexCAN_Disable(pBase);
    8028:	9805      	ldr	r0, [sp, #20]
    802a:	f001 fdd9 	bl	9be0 <FlexCAN_Disable>
    802e:	9006      	str	r0, [sp, #24]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8030:	9b06      	ldr	r3, [sp, #24]
    8032:	2b00      	cmp	r3, #0
    8034:	d001      	beq.n	803a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
        {
            result = status;
    8036:	9b06      	ldr	r3, [sp, #24]
    8038:	9307      	str	r3, [sp, #28]
        }
    }

    return result;
    803a:	9b07      	ldr	r3, [sp, #28]
}
    803c:	4618      	mov	r0, r3
    803e:	b009      	add	sp, #36	; 0x24
    8040:	f85d fb04 	ldr.w	pc, [sp], #4
    8044:	0000c650 	.word	0x0000c650

00008048 <FlexCAN_Ip_ConfigRemoteResponseMb>:
                                                        uint8 mb_idx,
                                                        const Flexcan_Ip_DataInfoType *tx_info,
                                                        uint32 msg_id,
                                                        const uint8 *mb_data
                                                       )
{
    8048:	b500      	push	{lr}
    804a:	b08f      	sub	sp, #60	; 0x3c
    804c:	9204      	str	r2, [sp, #16]
    804e:	9303      	str	r3, [sp, #12]
    8050:	4603      	mov	r3, r0
    8052:	f88d 3017 	strb.w	r3, [sp, #23]
    8056:	460b      	mov	r3, r1
    8058:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    805c:	2300      	movs	r3, #0
    805e:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8060:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8064:	4a27      	ldr	r2, [pc, #156]	; (8104 <FlexCAN_Ip_ConfigRemoteResponseMb+0xbc>)
    8066:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    806a:	930c      	str	r3, [sp, #48]	; 0x30
    const Flexcan_Ip_StateType * const state = Flexcan_Ip_apxState[instance];
    806c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8070:	4a25      	ldr	r2, [pc, #148]	; (8108 <FlexCAN_Ip_ConfigRemoteResponseMb+0xc0>)
    8072:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8076:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    8078:	2300      	movs	r3, #0
    807a:	930a      	str	r3, [sp, #40]	; 0x28
    if (TRUE == FlexCAN_IsMbOutOfRange(pBase, mb_idx, state->bIsLegacyFifoEn, state->u32MaxMbNum))
    {
        result = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    807c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    807e:	2b00      	cmp	r3, #0
    8080:	d13a      	bne.n	80f8 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
    {
        /* Initialize transmit mb*/
        cs.dataLen = tx_info->data_length;
    8082:	9b04      	ldr	r3, [sp, #16]
    8084:	685b      	ldr	r3, [r3, #4]
    8086:	9308      	str	r3, [sp, #32]
        cs.msgIdType = tx_info->msg_id_type;
    8088:	9b04      	ldr	r3, [sp, #16]
    808a:	681b      	ldr	r3, [r3, #0]
    808c:	9307      	str	r3, [sp, #28]
        cs.code = (uint32)FLEXCAN_RX_RANSWER;
    808e:	230a      	movs	r3, #10
    8090:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = FALSE;
    8092:	2300      	movs	r3, #0
    8094:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        cs.enable_brs = FALSE;
    8098:	2300      	movs	r3, #0
    809a:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        cs.fd_padding = 0x00U;
    809e:	2300      	movs	r3, #0
    80a0:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
#endif
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    80a4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    80a8:	4619      	mov	r1, r3
    80aa:	980c      	ldr	r0, [sp, #48]	; 0x30
    80ac:	f7fe fdc2 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
        pMbAddr = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    80b0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    80b4:	4619      	mov	r1, r3
    80b6:	980c      	ldr	r0, [sp, #48]	; 0x30
    80b8:	f001 fc2c 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    80bc:	900a      	str	r0, [sp, #40]	; 0x28
        FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, tx_info->is_remote);
    80be:	9b04      	ldr	r3, [sp, #16]
    80c0:	7adb      	ldrb	r3, [r3, #11]
    80c2:	a906      	add	r1, sp, #24
    80c4:	9300      	str	r3, [sp, #0]
    80c6:	9b10      	ldr	r3, [sp, #64]	; 0x40
    80c8:	9a03      	ldr	r2, [sp, #12]
    80ca:	980a      	ldr	r0, [sp, #40]	; 0x28
    80cc:	f002 f974 	bl	a3b8 <FlexCAN_SetTxMsgBuff>
        if (FALSE == tx_info->is_polling)
    80d0:	9b04      	ldr	r3, [sp, #16]
    80d2:	7b1b      	ldrb	r3, [r3, #12]
    80d4:	f083 0301 	eor.w	r3, r3, #1
    80d8:	b2db      	uxtb	r3, r3
    80da:	2b00      	cmp	r3, #0
    80dc:	d00c      	beq.n	80f8 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
        {
            /* Enable MB interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(pBase, instance, mb_idx, TRUE, state->isIntActive);
    80de:	f89d 2016 	ldrb.w	r2, [sp, #22]
    80e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    80e4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    80e8:	f89d 1017 	ldrb.w	r1, [sp, #23]
    80ec:	9300      	str	r3, [sp, #0]
    80ee:	2301      	movs	r3, #1
    80f0:	980c      	ldr	r0, [sp, #48]	; 0x30
    80f2:	f001 ff97 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
    80f6:	900d      	str	r0, [sp, #52]	; 0x34
        }
    }
    return result;
    80f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    80fa:	4618      	mov	r0, r3
    80fc:	b00f      	add	sp, #60	; 0x3c
    80fe:	f85d fb04 	ldr.w	pc, [sp], #4
    8102:	bf00      	nop
    8104:	0000c650 	.word	0x0000c650
    8108:	1fff8f64 	.word	0x1fff8f64

0000810c <FlexCAN_Ip_GetTransferStatus>:
 * or complete (success). In case Enhanced Rx Fifo, mb_idx will be 255.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetTransferStatus_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_GetTransferStatus(uint8 instance, uint8 mb_idx)
{
    810c:	b084      	sub	sp, #16
    810e:	4603      	mov	r3, r0
    8110:	460a      	mov	r2, r1
    8112:	f88d 3007 	strb.w	r3, [sp, #7]
    8116:	4613      	mov	r3, r2
    8118:	f88d 3006 	strb.w	r3, [sp, #6]

    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    811c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8120:	4a0d      	ldr	r2, [pc, #52]	; (8158 <FlexCAN_Ip_GetTransferStatus+0x4c>)
    8122:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8126:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_ERROR;
    8128:	2301      	movs	r3, #1
    812a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
#endif

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    812c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8130:	2b1f      	cmp	r3, #31
    8132:	d80d      	bhi.n	8150 <FlexCAN_Ip_GetTransferStatus+0x44>
    {
        if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    8134:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8138:	9a02      	ldr	r2, [sp, #8]
    813a:	011b      	lsls	r3, r3, #4
    813c:	4413      	add	r3, r2
    813e:	3304      	adds	r3, #4
    8140:	681b      	ldr	r3, [r3, #0]
    8142:	2b00      	cmp	r3, #0
    8144:	d102      	bne.n	814c <FlexCAN_Ip_GetTransferStatus+0x40>
        {
            status = FLEXCAN_STATUS_SUCCESS;
    8146:	2300      	movs	r3, #0
    8148:	9303      	str	r3, [sp, #12]
    814a:	e001      	b.n	8150 <FlexCAN_Ip_GetTransferStatus+0x44>
            status = FLEXCAN_STATUS_ERROR;
        }
#endif
        else
        {
            status = FLEXCAN_STATUS_BUSY;
    814c:	2302      	movs	r3, #2
    814e:	9303      	str	r3, [sp, #12]
            status = FLEXCAN_STATUS_BUSY;
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return status;
    8150:	9b03      	ldr	r3, [sp, #12]
}
    8152:	4618      	mov	r0, r3
    8154:	b004      	add	sp, #16
    8156:	4770      	bx	lr
    8158:	1fff8f64 	.word	0x1fff8f64

0000815c <FlexCAN_CompleteRxMessageFifoData>:
 * data and disabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_CompleteRxMessageFifoData(uint8 instance)
{
    815c:	b500      	push	{lr}
    815e:	b087      	sub	sp, #28
    8160:	4603      	mov	r3, r0
    8162:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8166:	f89d 300f 	ldrb.w	r3, [sp, #15]
    816a:	4a1d      	ldr	r2, [pc, #116]	; (81e0 <FlexCAN_CompleteRxMessageFifoData+0x84>)
    816c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8170:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    8172:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8176:	4a1b      	ldr	r2, [pc, #108]	; (81e4 <FlexCAN_CompleteRxMessageFifoData+0x88>)
    8178:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    817c:	9304      	str	r3, [sp, #16]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    817e:	9b04      	ldr	r3, [sp, #16]
    8180:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    8184:	2b00      	cmp	r3, #0
    8186:	d120      	bne.n	81ca <FlexCAN_CompleteRxMessageFifoData+0x6e>
    {
        /* Disable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, state->isIntActive);
    8188:	9b04      	ldr	r3, [sp, #16]
    818a:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    818e:	f89d 100f 	ldrb.w	r1, [sp, #15]
    8192:	9300      	str	r3, [sp, #0]
    8194:	2300      	movs	r3, #0
    8196:	2205      	movs	r2, #5
    8198:	9805      	ldr	r0, [sp, #20]
    819a:	f001 ff43 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, state->isIntActive);
    819e:	9b04      	ldr	r3, [sp, #16]
    81a0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    81a4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    81a8:	9300      	str	r3, [sp, #0]
    81aa:	2300      	movs	r3, #0
    81ac:	2206      	movs	r2, #6
    81ae:	9805      	ldr	r0, [sp, #20]
    81b0:	f001 ff38 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, state->isIntActive);
    81b4:	9b04      	ldr	r3, [sp, #16]
    81b6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    81ba:	f89d 100f 	ldrb.w	r1, [sp, #15]
    81be:	9300      	str	r3, [sp, #0]
    81c0:	2300      	movs	r3, #0
    81c2:	2207      	movs	r2, #7
    81c4:	9805      	ldr	r0, [sp, #20]
    81c6:	f001 ff2d 	bl	a024 <FlexCAN_SetMsgBuffIntCmd>
    {
        /* do nothing when transferType is POLLING */
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    /* Clear fifo message*/
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = NULL_PTR;
    81ca:	9b04      	ldr	r3, [sp, #16]
    81cc:	2200      	movs	r2, #0
    81ce:	601a      	str	r2, [r3, #0]
            state->callback(instance, FLEXCAN_EVENT_DMA_ERROR, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
        }
    }

#else
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    81d0:	9b04      	ldr	r3, [sp, #16]
    81d2:	2200      	movs	r2, #0
    81d4:	605a      	str	r2, [r3, #4]
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
}
    81d6:	bf00      	nop
    81d8:	b007      	add	sp, #28
    81da:	f85d fb04 	ldr.w	pc, [sp], #4
    81de:	bf00      	nop
    81e0:	0000c650 	.word	0x0000c650
    81e4:	1fff8f64 	.word	0x1fff8f64

000081e8 <FlexCAN_IRQHandler>:
    uint32 endMbIdx
    #if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    ,boolean bEnhancedFifoExisted
    #endif
)
{
    81e8:	b500      	push	{lr}
    81ea:	b08b      	sub	sp, #44	; 0x2c
    81ec:	4603      	mov	r3, r0
    81ee:	9102      	str	r1, [sp, #8]
    81f0:	9201      	str	r2, [sp, #4]
    81f2:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32MbHandle = 0U;
    81f6:	2300      	movs	r3, #0
    81f8:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 flag_reg = 0;
    81fa:	2300      	movs	r3, #0
    81fc:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    81fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8202:	4a3f      	ldr	r2, [pc, #252]	; (8300 <FlexCAN_IRQHandler+0x118>)
    8204:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8208:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    820a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    820e:	4a3d      	ldr	r2, [pc, #244]	; (8304 <FlexCAN_IRQHandler+0x11c>)
    8210:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8214:	9305      	str	r3, [sp, #20]

    /* Get the interrupts that are enabled and ready */
    uint32 mb_idx = endMbIdx;
    8216:	9b01      	ldr	r3, [sp, #4]
    8218:	9307      	str	r3, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(endMbIdx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM);
#endif
    /* Check if instance initialized */
    if (NULL_PTR != state)
    821a:	9b05      	ldr	r3, [sp, #20]
    821c:	2b00      	cmp	r3, #0
    821e:	d05c      	beq.n	82da <FlexCAN_IRQHandler+0xf2>
    {
        flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    8220:	9907      	ldr	r1, [sp, #28]
    8222:	9806      	ldr	r0, [sp, #24]
    8224:	f7fe feb7 	bl	6f96 <FlexCAN_GetMsgBuffIntStatusFlag>
    8228:	4603      	mov	r3, r0
    822a:	9308      	str	r3, [sp, #32]

        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    822c:	e008      	b.n	8240 <FlexCAN_IRQHandler+0x58>
        {
            mb_idx--;
    822e:	9b07      	ldr	r3, [sp, #28]
    8230:	3b01      	subs	r3, #1
    8232:	9307      	str	r3, [sp, #28]
            flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    8234:	9907      	ldr	r1, [sp, #28]
    8236:	9806      	ldr	r0, [sp, #24]
    8238:	f7fe fead 	bl	6f96 <FlexCAN_GetMsgBuffIntStatusFlag>
    823c:	4603      	mov	r3, r0
    823e:	9308      	str	r3, [sp, #32]
        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    8240:	9b08      	ldr	r3, [sp, #32]
    8242:	2b00      	cmp	r3, #0
    8244:	d103      	bne.n	824e <FlexCAN_IRQHandler+0x66>
    8246:	9a07      	ldr	r2, [sp, #28]
    8248:	9b02      	ldr	r3, [sp, #8]
    824a:	429a      	cmp	r2, r3
    824c:	d8ef      	bhi.n	822e <FlexCAN_IRQHandler+0x46>
        }

        /* Check Tx/Rx interrupt flag and clear the interrupt */
        if (flag_reg != 0U)
    824e:	9b08      	ldr	r3, [sp, #32]
    8250:	2b00      	cmp	r3, #0
    8252:	d050      	beq.n	82f6 <FlexCAN_IRQHandler+0x10e>
        {
            /* For legacy fifo, mb handler is FLEXCAN_IP_MB_HANDLE_RXFIFO(0) */
            u32MbHandle = mb_idx;
    8254:	9b07      	ldr	r3, [sp, #28]
    8256:	9309      	str	r3, [sp, #36]	; 0x24

            if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    8258:	9b05      	ldr	r3, [sp, #20]
    825a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    825e:	2b00      	cmp	r3, #0
    8260:	d00b      	beq.n	827a <FlexCAN_IRQHandler+0x92>
    8262:	9b07      	ldr	r3, [sp, #28]
    8264:	2b07      	cmp	r3, #7
    8266:	d808      	bhi.n	827a <FlexCAN_IRQHandler+0x92>
            {
                FlexCAN_IRQHandlerRxFIFO(instance, mb_idx);
    8268:	f89d 300f 	ldrb.w	r3, [sp, #15]
    826c:	9907      	ldr	r1, [sp, #28]
    826e:	4618      	mov	r0, r3
    8270:	f7ff fb32 	bl	78d8 <FlexCAN_IRQHandlerRxFIFO>
                u32MbHandle = (uint32)FLEXCAN_IP_MB_HANDLE_RXFIFO;
    8274:	2300      	movs	r3, #0
    8276:	9309      	str	r3, [sp, #36]	; 0x24
    8278:	e00d      	b.n	8296 <FlexCAN_IRQHandler+0xae>
            }
            else
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[u32MbHandle].state)
    827a:	9a05      	ldr	r2, [sp, #20]
    827c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    827e:	011b      	lsls	r3, r3, #4
    8280:	4413      	add	r3, r2
    8282:	3304      	adds	r3, #4
    8284:	681b      	ldr	r3, [r3, #0]
    8286:	2b01      	cmp	r3, #1
    8288:	d105      	bne.n	8296 <FlexCAN_IRQHandler+0xae>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    828a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    828e:	9907      	ldr	r1, [sp, #28]
    8290:	4618      	mov	r0, r3
    8292:	f7ff f999 	bl	75c8 <FlexCAN_IRQHandlerRxMB>
                }
            }

            /* Check mailbox completed transmission */
            if (FLEXCAN_MB_TX_BUSY == state->mbs[u32MbHandle].state)
    8296:	9a05      	ldr	r2, [sp, #20]
    8298:	9b09      	ldr	r3, [sp, #36]	; 0x24
    829a:	011b      	lsls	r3, r3, #4
    829c:	4413      	add	r3, r2
    829e:	3304      	adds	r3, #4
    82a0:	681b      	ldr	r3, [r3, #0]
    82a2:	2b02      	cmp	r3, #2
    82a4:	d105      	bne.n	82b2 <FlexCAN_IRQHandler+0xca>
            {
                FlexCAN_IRQHandlerTxMB(instance, mb_idx);
    82a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    82aa:	9907      	ldr	r1, [sp, #28]
    82ac:	4618      	mov	r0, r3
    82ae:	f7ff fa79 	bl	77a4 <FlexCAN_IRQHandlerTxMB>
            }

            /* Check for spurious interrupt */
            if (FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx) != 0U)
    82b2:	9907      	ldr	r1, [sp, #28]
    82b4:	9806      	ldr	r0, [sp, #24]
    82b6:	f7fe fe6e 	bl	6f96 <FlexCAN_GetMsgBuffIntStatusFlag>
    82ba:	4603      	mov	r3, r0
    82bc:	2b00      	cmp	r3, #0
    82be:	d01a      	beq.n	82f6 <FlexCAN_IRQHandler+0x10e>
            {
                if (state->mbs[u32MbHandle].state == FLEXCAN_MB_IDLE)
    82c0:	9a05      	ldr	r2, [sp, #20]
    82c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    82c4:	011b      	lsls	r3, r3, #4
    82c6:	4413      	add	r3, r2
    82c8:	3304      	adds	r3, #4
    82ca:	681b      	ldr	r3, [r3, #0]
    82cc:	2b00      	cmp	r3, #0
    82ce:	d112      	bne.n	82f6 <FlexCAN_IRQHandler+0x10e>
                {
                    /* In case of desynchronized status of the MB to avoid trapping in ISR
                    * clear the MB flag */
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    82d0:	9907      	ldr	r1, [sp, #28]
    82d2:	9806      	ldr	r0, [sp, #24]
    82d4:	f7fe fcae 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_UNDERFLOW);
        }
    #endif /* End of (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    }
}
    82d8:	e00d      	b.n	82f6 <FlexCAN_IRQHandler+0x10e>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    82da:	9b02      	ldr	r3, [sp, #8]
    82dc:	9307      	str	r3, [sp, #28]
    82de:	e006      	b.n	82ee <FlexCAN_IRQHandler+0x106>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    82e0:	9907      	ldr	r1, [sp, #28]
    82e2:	9806      	ldr	r0, [sp, #24]
    82e4:	f7fe fca6 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    82e8:	9b07      	ldr	r3, [sp, #28]
    82ea:	3301      	adds	r3, #1
    82ec:	9307      	str	r3, [sp, #28]
    82ee:	9a07      	ldr	r2, [sp, #28]
    82f0:	9b01      	ldr	r3, [sp, #4]
    82f2:	429a      	cmp	r2, r3
    82f4:	d9f4      	bls.n	82e0 <FlexCAN_IRQHandler+0xf8>
}
    82f6:	bf00      	nop
    82f8:	b00b      	add	sp, #44	; 0x2c
    82fa:	f85d fb04 	ldr.w	pc, [sp], #4
    82fe:	bf00      	nop
    8300:	0000c650 	.word	0x0000c650
    8304:	1fff8f64 	.word	0x1fff8f64

00008308 <FlexCAN_Ip_ClearErrorStatus>:
 *                 transmission of a CAN frame.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearErrorStatus_Activity */
void FlexCAN_Ip_ClearErrorStatus(uint8 instance, uint32 error)
{
    8308:	b084      	sub	sp, #16
    830a:	4603      	mov	r3, r0
    830c:	9100      	str	r1, [sp, #0]
    830e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8312:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8316:	4a05      	ldr	r2, [pc, #20]	; (832c <FlexCAN_Ip_ClearErrorStatus+0x24>)
    8318:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    831c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base->ESR1 = error;
    831e:	9b03      	ldr	r3, [sp, #12]
    8320:	9a00      	ldr	r2, [sp, #0]
    8322:	621a      	str	r2, [r3, #32]
}
    8324:	bf00      	nop
    8326:	b004      	add	sp, #16
    8328:	4770      	bx	lr
    832a:	bf00      	nop
    832c:	0000c650 	.word	0x0000c650

00008330 <FlexCAN_Ip_GetErrorStatus>:
 *                 transmission of a CAN frame and some general status of the device.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetErrorStatus_Activity */
uint32 FlexCAN_Ip_GetErrorStatus(uint8 instance)
{
    8330:	b084      	sub	sp, #16
    8332:	4603      	mov	r3, r0
    8334:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8338:	f89d 3007 	ldrb.w	r3, [sp, #7]
    833c:	4a04      	ldr	r2, [pc, #16]	; (8350 <FlexCAN_Ip_GetErrorStatus+0x20>)
    833e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8342:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint32)(base->ESR1);
    8344:	9b03      	ldr	r3, [sp, #12]
    8346:	6a1b      	ldr	r3, [r3, #32]
}
    8348:	4618      	mov	r0, r3
    834a:	b004      	add	sp, #16
    834c:	4770      	bx	lr
    834e:	bf00      	nop
    8350:	0000c650 	.word	0x0000c650

00008354 <FlexCAN_Ip_GetControllerTxErrorCounter>:
 *                 transmitted messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerTxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerTxErrorCounter(uint8 instance)
{
    8354:	b084      	sub	sp, #16
    8356:	4603      	mov	r3, r0
    8358:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    835c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8360:	4a04      	ldr	r2, [pc, #16]	; (8374 <FlexCAN_Ip_GetControllerTxErrorCounter+0x20>)
    8362:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8366:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_TXERRCNT_MASK) >> FLEXCAN_ECR_TXERRCNT_SHIFT);
    8368:	9b03      	ldr	r3, [sp, #12]
    836a:	69db      	ldr	r3, [r3, #28]
    836c:	b2db      	uxtb	r3, r3
}
    836e:	4618      	mov	r0, r3
    8370:	b004      	add	sp, #16
    8372:	4770      	bx	lr
    8374:	0000c650 	.word	0x0000c650

00008378 <FlexCAN_Ip_GetControllerRxErrorCounter>:
 *                 received messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerRxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerRxErrorCounter(uint8 instance)
{
    8378:	b084      	sub	sp, #16
    837a:	4603      	mov	r3, r0
    837c:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8380:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8384:	4a05      	ldr	r2, [pc, #20]	; (839c <FlexCAN_Ip_GetControllerRxErrorCounter+0x24>)
    8386:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    838a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_RXERRCNT_MASK) >> FLEXCAN_ECR_RXERRCNT_SHIFT);
    838c:	9b03      	ldr	r3, [sp, #12]
    838e:	69db      	ldr	r3, [r3, #28]
    8390:	0a1b      	lsrs	r3, r3, #8
    8392:	b2db      	uxtb	r3, r3
}
    8394:	4618      	mov	r0, r3
    8396:	b004      	add	sp, #16
    8398:	4770      	bx	lr
    839a:	bf00      	nop
    839c:	0000c650 	.word	0x0000c650

000083a0 <FlexCAN_Error_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements  CAN_X_ERROR_ISR_Activity */
void FlexCAN_Error_IRQHandler(uint8 instance)
{
    83a0:	b510      	push	{r4, lr}
    83a2:	b086      	sub	sp, #24
    83a4:	4603      	mov	r3, r0
    83a6:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    83aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    83ae:	4a29      	ldr	r2, [pc, #164]	; (8454 <FlexCAN_Error_IRQHandler+0xb4>)
    83b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83b4:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    83b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    83ba:	4a27      	ldr	r2, [pc, #156]	; (8458 <FlexCAN_Error_IRQHandler+0xb8>)
    83bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83c0:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    83c2:	2300      	movs	r3, #0
    83c4:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check if the instance initialized */
    if (NULL_PTR != state)
    83c6:	9b03      	ldr	r3, [sp, #12]
    83c8:	2b00      	cmp	r3, #0
    83ca:	d03d      	beq.n	8448 <FlexCAN_Error_IRQHandler+0xa8>
    {
        /* Get error status to get value updated */
        u32ErrStatus = pBase->ESR1;
    83cc:	9b04      	ldr	r3, [sp, #16]
    83ce:	6a1b      	ldr	r3, [r3, #32]
    83d0:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_MASK))) && ((uint32)0U != (pBase->CTRL1 & ((uint32)FLEXCAN_CTRL1_ERRMSK_MASK))))
    83d2:	9b05      	ldr	r3, [sp, #20]
    83d4:	f003 0302 	and.w	r3, r3, #2
    83d8:	2b00      	cmp	r3, #0
    83da:	d019      	beq.n	8410 <FlexCAN_Error_IRQHandler+0x70>
    83dc:	9b04      	ldr	r3, [sp, #16]
    83de:	685b      	ldr	r3, [r3, #4]
    83e0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    83e4:	2b00      	cmp	r3, #0
    83e6:	d013      	beq.n	8410 <FlexCAN_Error_IRQHandler+0x70>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_MASK;
    83e8:	9b04      	ldr	r3, [sp, #16]
    83ea:	2202      	movs	r2, #2
    83ec:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    83ee:	9b03      	ldr	r3, [sp, #12]
    83f0:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    83f4:	2b00      	cmp	r3, #0
    83f6:	d00b      	beq.n	8410 <FlexCAN_Error_IRQHandler+0x70>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR, u32ErrStatus, state);
    83f8:	9b03      	ldr	r3, [sp, #12]
    83fa:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    83fe:	f89d 0007 	ldrb.w	r0, [sp, #7]
    8402:	9b03      	ldr	r3, [sp, #12]
    8404:	9a05      	ldr	r2, [sp, #20]
    8406:	2105      	movs	r1, #5
    8408:	47a0      	blx	r4
            #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = pBase->ESR1;
    840a:	9b04      	ldr	r3, [sp, #16]
    840c:	6a1b      	ldr	r3, [r3, #32]
    840e:	9305      	str	r3, [sp, #20]
            }
        }

    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Check if this is spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_FAST_MASK))) && ((uint32)0U != (pBase->CTRL2 & ((uint32)FLEXCAN_CTRL2_ERRMSK_FAST_MASK))))
    8410:	9b05      	ldr	r3, [sp, #20]
    8412:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    8416:	2b00      	cmp	r3, #0
    8418:	d019      	beq.n	844e <FlexCAN_Error_IRQHandler+0xae>
    841a:	9b04      	ldr	r3, [sp, #16]
    841c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    841e:	2b00      	cmp	r3, #0
    8420:	da15      	bge.n	844e <FlexCAN_Error_IRQHandler+0xae>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_FAST_MASK;
    8422:	9b04      	ldr	r3, [sp, #16]
    8424:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    8428:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    842a:	9b03      	ldr	r3, [sp, #12]
    842c:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    8430:	2b00      	cmp	r3, #0
    8432:	d00c      	beq.n	844e <FlexCAN_Error_IRQHandler+0xae>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR_FAST, u32ErrStatus, state);
    8434:	9b03      	ldr	r3, [sp, #12]
    8436:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    843a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    843e:	9b03      	ldr	r3, [sp, #12]
    8440:	9a05      	ldr	r2, [sp, #20]
    8442:	2106      	movs	r1, #6
    8444:	47a0      	blx	r4
    }
    else
    {
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    }
}
    8446:	e002      	b.n	844e <FlexCAN_Error_IRQHandler+0xae>
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    8448:	9b04      	ldr	r3, [sp, #16]
    844a:	4a04      	ldr	r2, [pc, #16]	; (845c <FlexCAN_Error_IRQHandler+0xbc>)
    844c:	621a      	str	r2, [r3, #32]
}
    844e:	bf00      	nop
    8450:	b006      	add	sp, #24
    8452:	bd10      	pop	{r4, pc}
    8454:	0000c650 	.word	0x0000c650
    8458:	1fff8f64 	.word	0x1fff8f64
    845c:	00300002 	.word	0x00300002

00008460 <FlexCAN_BusOff_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements CAN_X_BUSOFF_ISR_Activity */
void FlexCAN_BusOff_IRQHandler(uint8 instance)
{
    8460:	b510      	push	{r4, lr}
    8462:	b086      	sub	sp, #24
    8464:	4603      	mov	r3, r0
    8466:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    846a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    846e:	4a3a      	ldr	r2, [pc, #232]	; (8558 <FlexCAN_BusOff_IRQHandler+0xf8>)
    8470:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8474:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    8476:	f89d 3007 	ldrb.w	r3, [sp, #7]
    847a:	4a38      	ldr	r2, [pc, #224]	; (855c <FlexCAN_BusOff_IRQHandler+0xfc>)
    847c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8480:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    8482:	2300      	movs	r3, #0
    8484:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check If Driver initialized */
    if (NULL_PTR != state)
    8486:	9b03      	ldr	r3, [sp, #12]
    8488:	2b00      	cmp	r3, #0
    848a:	d05f      	beq.n	854c <FlexCAN_BusOff_IRQHandler+0xec>
    {
        /* Get error status to get value updated */
        u32ErrStatus = base->ESR1;
    848c:	9b04      	ldr	r3, [sp, #16]
    848e:	6a1b      	ldr	r3, [r3, #32]
    8490:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_TWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_TWRNMSK_MASK))))
    8492:	9b05      	ldr	r3, [sp, #20]
    8494:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    8498:	2b00      	cmp	r3, #0
    849a:	d01a      	beq.n	84d2 <FlexCAN_BusOff_IRQHandler+0x72>
    849c:	9b04      	ldr	r3, [sp, #16]
    849e:	685b      	ldr	r3, [r3, #4]
    84a0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    84a4:	2b00      	cmp	r3, #0
    84a6:	d014      	beq.n	84d2 <FlexCAN_BusOff_IRQHandler+0x72>
        {
            base->ESR1 = FLEXCAN_ESR1_TWRNINT_MASK;
    84a8:	9b04      	ldr	r3, [sp, #16]
    84aa:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    84ae:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    84b0:	9b03      	ldr	r3, [sp, #12]
    84b2:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    84b6:	2b00      	cmp	r3, #0
    84b8:	d00b      	beq.n	84d2 <FlexCAN_BusOff_IRQHandler+0x72>
            {
                state->error_callback(instance, FLEXCAN_EVENT_TX_WARNING, u32ErrStatus, state);
    84ba:	9b03      	ldr	r3, [sp, #12]
    84bc:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    84c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
    84c4:	9b03      	ldr	r3, [sp, #12]
    84c6:	9a05      	ldr	r2, [sp, #20]
    84c8:	2109      	movs	r1, #9
    84ca:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    84cc:	9b04      	ldr	r3, [sp, #16]
    84ce:	6a1b      	ldr	r3, [r3, #32]
    84d0:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_RWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_RWRNMSK_MASK))))
    84d2:	9b05      	ldr	r3, [sp, #20]
    84d4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    84d8:	2b00      	cmp	r3, #0
    84da:	d01a      	beq.n	8512 <FlexCAN_BusOff_IRQHandler+0xb2>
    84dc:	9b04      	ldr	r3, [sp, #16]
    84de:	685b      	ldr	r3, [r3, #4]
    84e0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    84e4:	2b00      	cmp	r3, #0
    84e6:	d014      	beq.n	8512 <FlexCAN_BusOff_IRQHandler+0xb2>
        {
            base->ESR1 = FLEXCAN_ESR1_RWRNINT_MASK;
    84e8:	9b04      	ldr	r3, [sp, #16]
    84ea:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    84ee:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    84f0:	9b03      	ldr	r3, [sp, #12]
    84f2:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    84f6:	2b00      	cmp	r3, #0
    84f8:	d00b      	beq.n	8512 <FlexCAN_BusOff_IRQHandler+0xb2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_RX_WARNING, u32ErrStatus, state);
    84fa:	9b03      	ldr	r3, [sp, #12]
    84fc:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    8500:	f89d 0007 	ldrb.w	r0, [sp, #7]
    8504:	9b03      	ldr	r3, [sp, #12]
    8506:	9a05      	ldr	r2, [sp, #20]
    8508:	2108      	movs	r1, #8
    850a:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    850c:	9b04      	ldr	r3, [sp, #16]
    850e:	6a1b      	ldr	r3, [r3, #32]
    8510:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_BOFFINT_MASK))) && ((uint32)0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_BOFFMSK_MASK))))
    8512:	9b05      	ldr	r3, [sp, #20]
    8514:	f003 0304 	and.w	r3, r3, #4
    8518:	2b00      	cmp	r3, #0
    851a:	d01a      	beq.n	8552 <FlexCAN_BusOff_IRQHandler+0xf2>
    851c:	9b04      	ldr	r3, [sp, #16]
    851e:	685b      	ldr	r3, [r3, #4]
    8520:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    8524:	2b00      	cmp	r3, #0
    8526:	d014      	beq.n	8552 <FlexCAN_BusOff_IRQHandler+0xf2>
        {
            base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    8528:	9b04      	ldr	r3, [sp, #16]
    852a:	2204      	movs	r2, #4
    852c:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    852e:	9b03      	ldr	r3, [sp, #12]
    8530:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    8534:	2b00      	cmp	r3, #0
    8536:	d00c      	beq.n	8552 <FlexCAN_BusOff_IRQHandler+0xf2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    8538:	9b03      	ldr	r3, [sp, #12]
    853a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    853e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    8542:	9b03      	ldr	r3, [sp, #12]
    8544:	9a05      	ldr	r2, [sp, #20]
    8546:	2107      	movs	r1, #7
    8548:	47a0      	blx	r4
    }
    else
    {
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    }
}
    854a:	e002      	b.n	8552 <FlexCAN_BusOff_IRQHandler+0xf2>
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    854c:	9b04      	ldr	r3, [sp, #16]
    854e:	4a04      	ldr	r2, [pc, #16]	; (8560 <FlexCAN_BusOff_IRQHandler+0x100>)
    8550:	621a      	str	r2, [r3, #32]
}
    8552:	bf00      	nop
    8554:	b006      	add	sp, #24
    8556:	bd10      	pop	{r4, pc}
    8558:	0000c650 	.word	0x0000c650
    855c:	1fff8f64 	.word	0x1fff8f64
    8560:	000b0004 	.word	0x000b0004

00008564 <FlexCAN_Ip_SendBlocking>:
                                              const Flexcan_Ip_DataInfoType * tx_info,
                                              uint32 msg_id,
                                              const uint8 * mb_data,
                                              uint32 timeout_ms
                                             )
{
    8564:	b500      	push	{lr}
    8566:	b091      	sub	sp, #68	; 0x44
    8568:	9204      	str	r2, [sp, #16]
    856a:	9303      	str	r3, [sp, #12]
    856c:	4603      	mov	r3, r0
    856e:	f88d 3017 	strb.w	r3, [sp, #23]
    8572:	460b      	mov	r3, r1
    8574:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8578:	f89d 3017 	ldrb.w	r3, [sp, #23]
    857c:	4a5f      	ldr	r2, [pc, #380]	; (86fc <FlexCAN_Ip_SendBlocking+0x198>)
    857e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8582:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    8584:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8588:	4a5d      	ldr	r2, [pc, #372]	; (8700 <FlexCAN_Ip_SendBlocking+0x19c>)
    858a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    858e:	930c      	str	r3, [sp, #48]	; 0x30

    uint32 timeStart = 0U;
    8590:	2300      	movs	r3, #0
    8592:	9307      	str	r3, [sp, #28]
    uint32 timeElapsed = 0U;
    8594:	2300      	movs	r3, #0
    8596:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 mS2Ticks = OsIf_MicrosToTicks((timeout_ms * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    8598:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    859a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    859e:	fb02 f303 	mul.w	r3, r2, r3
    85a2:	2100      	movs	r1, #0
    85a4:	4618      	mov	r0, r3
    85a6:	f7f8 fd92 	bl	10ce <OsIf_MicrosToTicks>
    85aa:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32 uS2Ticks = 0U;
    85ac:	2300      	movs	r3, #0
    85ae:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 flexcan_mb_config = 0;
    85b0:	2300      	movs	r3, #0
    85b2:	9309      	str	r3, [sp, #36]	; 0x24

    volatile uint32 * flexcan_mb = NULL_PTR;
    85b4:	2300      	movs	r3, #0
    85b6:	9308      	str	r3, [sp, #32]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif

    result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    85b8:	f89d 1016 	ldrb.w	r1, [sp, #22]
    85bc:	f89d 0017 	ldrb.w	r0, [sp, #23]
    85c0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    85c2:	9300      	str	r3, [sp, #0]
    85c4:	9b03      	ldr	r3, [sp, #12]
    85c6:	9a04      	ldr	r2, [sp, #16]
    85c8:	f7fe ff1a 	bl	7400 <FlexCAN_StartSendData>
    85cc:	900f      	str	r0, [sp, #60]	; 0x3c

    if (FLEXCAN_STATUS_SUCCESS == result)
    85ce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    85d0:	2b00      	cmp	r3, #0
    85d2:	f040 808d 	bne.w	86f0 <FlexCAN_Ip_SendBlocking+0x18c>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    85d6:	2000      	movs	r0, #0
    85d8:	f7f8 fd2d 	bl	1036 <OsIf_GetCounter>
    85dc:	4603      	mov	r3, r0
    85de:	9307      	str	r3, [sp, #28]
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    85e0:	e00f      	b.n	8602 <FlexCAN_Ip_SendBlocking+0x9e>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    85e2:	ab07      	add	r3, sp, #28
    85e4:	2100      	movs	r1, #0
    85e6:	4618      	mov	r0, r3
    85e8:	f7f8 fd3e 	bl	1068 <OsIf_GetElapsed>
    85ec:	4602      	mov	r2, r0
    85ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    85f0:	4413      	add	r3, r2
    85f2:	930e      	str	r3, [sp, #56]	; 0x38
            if (timeElapsed >= mS2Ticks)
    85f4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    85f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    85f8:	429a      	cmp	r2, r3
    85fa:	d302      	bcc.n	8602 <FlexCAN_Ip_SendBlocking+0x9e>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    85fc:	2303      	movs	r3, #3
    85fe:	930f      	str	r3, [sp, #60]	; 0x3c
                break;
    8600:	e008      	b.n	8614 <FlexCAN_Ip_SendBlocking+0xb0>
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    8602:	f89d 3016 	ldrb.w	r3, [sp, #22]
    8606:	4619      	mov	r1, r3
    8608:	980d      	ldr	r0, [sp, #52]	; 0x34
    860a:	f7fe fb26 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    860e:	4603      	mov	r3, r0
    8610:	2b01      	cmp	r3, #1
    8612:	d1e6      	bne.n	85e2 <FlexCAN_Ip_SendBlocking+0x7e>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == result) && (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE))
    8614:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8616:	2b03      	cmp	r3, #3
    8618:	d15c      	bne.n	86d4 <FlexCAN_Ip_SendBlocking+0x170>
    861a:	f89d 3016 	ldrb.w	r3, [sp, #22]
    861e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    8620:	011b      	lsls	r3, r3, #4
    8622:	4413      	add	r3, r2
    8624:	3304      	adds	r3, #4
    8626:	681b      	ldr	r3, [r3, #0]
    8628:	2b00      	cmp	r3, #0
    862a:	d053      	beq.n	86d4 <FlexCAN_Ip_SendBlocking+0x170>
        {
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    862c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    8630:	4619      	mov	r1, r3
    8632:	980d      	ldr	r0, [sp, #52]	; 0x34
    8634:	f7fe fafe 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
                flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    8638:	f89d 3016 	ldrb.w	r3, [sp, #22]
    863c:	4619      	mov	r1, r3
    863e:	980d      	ldr	r0, [sp, #52]	; 0x34
    8640:	f001 f968 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    8644:	9008      	str	r0, [sp, #32]
                flexcan_mb_config = * flexcan_mb;
    8646:	9b08      	ldr	r3, [sp, #32]
    8648:	681b      	ldr	r3, [r3, #0]
    864a:	9309      	str	r3, [sp, #36]	; 0x24
                /* Reset the code */
                flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    864c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    864e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    8652:	9309      	str	r3, [sp, #36]	; 0x24
                flexcan_mb_config |= ((uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    8654:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8656:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    865a:	9309      	str	r3, [sp, #36]	; 0x24
                *flexcan_mb = flexcan_mb_config;
    865c:	9b08      	ldr	r3, [sp, #32]
    865e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8660:	601a      	str	r2, [r3, #0]

                /* Wait to finish abort operation */
                uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    8662:	2100      	movs	r1, #0
    8664:	4827      	ldr	r0, [pc, #156]	; (8704 <FlexCAN_Ip_SendBlocking+0x1a0>)
    8666:	f7f8 fd32 	bl	10ce <OsIf_MicrosToTicks>
    866a:	900a      	str	r0, [sp, #40]	; 0x28
                timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    866c:	2000      	movs	r0, #0
    866e:	f7f8 fce2 	bl	1036 <OsIf_GetCounter>
    8672:	4603      	mov	r3, r0
    8674:	9307      	str	r3, [sp, #28]
                 timeElapsed = 0U;
    8676:	2300      	movs	r3, #0
    8678:	930e      	str	r3, [sp, #56]	; 0x38
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    867a:	e00f      	b.n	869c <FlexCAN_Ip_SendBlocking+0x138>
                {
                    timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    867c:	ab07      	add	r3, sp, #28
    867e:	2100      	movs	r1, #0
    8680:	4618      	mov	r0, r3
    8682:	f7f8 fcf1 	bl	1068 <OsIf_GetElapsed>
    8686:	4602      	mov	r2, r0
    8688:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    868a:	4413      	add	r3, r2
    868c:	930e      	str	r3, [sp, #56]	; 0x38
                    if (timeElapsed >= uS2Ticks)
    868e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8690:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8692:	429a      	cmp	r2, r3
    8694:	d302      	bcc.n	869c <FlexCAN_Ip_SendBlocking+0x138>
                    {
                        result = FLEXCAN_STATUS_TIMEOUT;
    8696:	2303      	movs	r3, #3
    8698:	930f      	str	r3, [sp, #60]	; 0x3c
                        break;
    869a:	e008      	b.n	86ae <FlexCAN_Ip_SendBlocking+0x14a>
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    869c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    86a0:	4619      	mov	r1, r3
    86a2:	980d      	ldr	r0, [sp, #52]	; 0x34
    86a4:	f7fe fad9 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    86a8:	4603      	mov	r3, r0
    86aa:	2b00      	cmp	r3, #0
    86ac:	d0e6      	beq.n	867c <FlexCAN_Ip_SendBlocking+0x118>
                    }
                }

                flexcan_mb_config = *flexcan_mb;
    86ae:	9b08      	ldr	r3, [sp, #32]
    86b0:	681b      	ldr	r3, [r3, #0]
    86b2:	9309      	str	r3, [sp, #36]	; 0x24
                /* Check if the MBs have been safely Inactivated */
                if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    86b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    86b6:	0e1b      	lsrs	r3, r3, #24
    86b8:	f003 030f 	and.w	r3, r3, #15
    86bc:	2b08      	cmp	r3, #8
    86be:	d101      	bne.n	86c4 <FlexCAN_Ip_SendBlocking+0x160>
                {
                    /* Transmission have occurred */
                    result = FLEXCAN_STATUS_SUCCESS;
    86c0:	2300      	movs	r3, #0
    86c2:	930f      	str	r3, [sp, #60]	; 0x3c
                }

                if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    86c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    86c6:	0e1b      	lsrs	r3, r3, #24
    86c8:	f003 030f 	and.w	r3, r3, #15
    86cc:	2b09      	cmp	r3, #9
    86ce:	d101      	bne.n	86d4 <FlexCAN_Ip_SendBlocking+0x170>
                {
                    /* Transmission have been aborted */
                    result = FLEXCAN_STATUS_TIMEOUT;
    86d0:	2303      	movs	r3, #3
    86d2:	930f      	str	r3, [sp, #60]	; 0x3c
                }
        }

        /* Clear message buffer flag */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    86d4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    86d8:	4619      	mov	r1, r3
    86da:	980d      	ldr	r0, [sp, #52]	; 0x34
    86dc:	f7fe faaa 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>

        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    86e0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    86e4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    86e6:	011b      	lsls	r3, r3, #4
    86e8:	4413      	add	r3, r2
    86ea:	3304      	adds	r3, #4
    86ec:	2200      	movs	r2, #0
    86ee:	601a      	str	r2, [r3, #0]
    }
    return result;
    86f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
    86f2:	4618      	mov	r0, r3
    86f4:	b011      	add	sp, #68	; 0x44
    86f6:	f85d fb04 	ldr.w	pc, [sp], #4
    86fa:	bf00      	nop
    86fc:	0000c650 	.word	0x0000c650
    8700:	1fff8f64 	.word	0x1fff8f64
    8704:	000f4240 	.word	0x000f4240

00008708 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_SetRxMbGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMbGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    8708:	b500      	push	{lr}
    870a:	b087      	sub	sp, #28
    870c:	4603      	mov	r3, r0
    870e:	9100      	str	r1, [sp, #0]
    8710:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8714:	2300      	movs	r3, #0
    8716:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8718:	2300      	movs	r3, #0
    871a:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    871c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8720:	4a1c      	ldr	r2, [pc, #112]	; (8794 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x8c>)
    8722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8726:	9303      	str	r3, [sp, #12]
#endif

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    8728:	9803      	ldr	r0, [sp, #12]
    872a:	f7fe fa29 	bl	6b80 <FlexCAN_IsEnabled>
    872e:	4603      	mov	r3, r0
    8730:	2b00      	cmp	r3, #0
    8732:	bf14      	ite	ne
    8734:	2301      	movne	r3, #1
    8736:	2300      	moveq	r3, #0
    8738:	b2db      	uxtb	r3, r3
    873a:	f083 0301 	eor.w	r3, r3, #1
    873e:	b2db      	uxtb	r3, r3
    8740:	f88d 300b 	strb.w	r3, [sp, #11]
    8744:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8748:	f003 0301 	and.w	r3, r3, #1
    874c:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    8750:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8754:	2b00      	cmp	r3, #0
    8756:	d003      	beq.n	8760 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    8758:	9803      	ldr	r0, [sp, #12]
    875a:	f001 f9c3 	bl	9ae4 <FlexCAN_Enable>
    875e:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    8760:	9b05      	ldr	r3, [sp, #20]
    8762:	2b00      	cmp	r3, #0
    8764:	d103      	bne.n	876e <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxMsgBuffGlobalMask(pBase, mask);
    8766:	9900      	ldr	r1, [sp, #0]
    8768:	9803      	ldr	r0, [sp, #12]
    876a:	f7fe fc33 	bl	6fd4 <FlexCAN_SetRxMsgBuffGlobalMask>
    }

    if (TRUE == disabled)
    876e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8772:	2b00      	cmp	r3, #0
    8774:	d008      	beq.n	8788 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    8776:	9803      	ldr	r0, [sp, #12]
    8778:	f001 fa32 	bl	9be0 <FlexCAN_Disable>
    877c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    877e:	9b04      	ldr	r3, [sp, #16]
    8780:	2b00      	cmp	r3, #0
    8782:	d001      	beq.n	8788 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
        {
            result = status;
    8784:	9b04      	ldr	r3, [sp, #16]
    8786:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    8788:	9b05      	ldr	r3, [sp, #20]
}
    878a:	4618      	mov	r0, r3
    878c:	b007      	add	sp, #28
    878e:	f85d fb04 	ldr.w	pc, [sp], #4
    8792:	bf00      	nop
    8794:	0000c650 	.word	0x0000c650

00008798 <FlexCAN_Ip_EnterFreezeMode_Privileged>:
 * Description   : Enter Driver In freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnterFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnterFreezeMode_Privileged(uint8 instance)
{
    8798:	b500      	push	{lr}
    879a:	b085      	sub	sp, #20
    879c:	4603      	mov	r3, r0
    879e:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    87a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    87a6:	4a06      	ldr	r2, [pc, #24]	; (87c0 <FlexCAN_Ip_EnterFreezeMode_Privileged+0x28>)
    87a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87ac:	9303      	str	r3, [sp, #12]
        return FlexCAN_EnterFreezeMode(base);
    87ae:	9803      	ldr	r0, [sp, #12]
    87b0:	f001 f94c 	bl	9a4c <FlexCAN_EnterFreezeMode>
    87b4:	4603      	mov	r3, r0
}
    87b6:	4618      	mov	r0, r3
    87b8:	b005      	add	sp, #20
    87ba:	f85d fb04 	ldr.w	pc, [sp], #4
    87be:	bf00      	nop
    87c0:	0000c650 	.word	0x0000c650

000087c4 <FlexCAN_Ip_ExitFreezeMode_Privileged>:
 * Description   : Exit Driver from freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ExitFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ExitFreezeMode_Privileged(uint8 instance)
{
    87c4:	b500      	push	{lr}
    87c6:	b085      	sub	sp, #20
    87c8:	4603      	mov	r3, r0
    87ca:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    87ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    87d2:	4a06      	ldr	r2, [pc, #24]	; (87ec <FlexCAN_Ip_ExitFreezeMode_Privileged+0x28>)
    87d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87d8:	9303      	str	r3, [sp, #12]
        return FlexCAN_ExitFreezeMode(base);
    87da:	9803      	ldr	r0, [sp, #12]
    87dc:	f001 f9be 	bl	9b5c <FlexCAN_ExitFreezeMode>
    87e0:	4603      	mov	r3, r0
}
    87e2:	4618      	mov	r0, r3
    87e4:	b005      	add	sp, #20
    87e6:	f85d fb04 	ldr.w	pc, [sp], #4
    87ea:	bf00      	nop
    87ec:	0000c650 	.word	0x0000c650

000087f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>:
 * Description   : Set Rx individual mask as absolute value provided by mask parameter
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxIndividualMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxIndividualMask_Privileged(uint8 instance, uint8 mb_idx, uint32 mask)
{
    87f0:	b500      	push	{lr}
    87f2:	b087      	sub	sp, #28
    87f4:	4603      	mov	r3, r0
    87f6:	9200      	str	r2, [sp, #0]
    87f8:	f88d 3007 	strb.w	r3, [sp, #7]
    87fc:	460b      	mov	r3, r1
    87fe:	f88d 3006 	strb.w	r3, [sp, #6]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8802:	2300      	movs	r3, #0
    8804:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8806:	2300      	movs	r3, #0
    8808:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    880a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    880e:	4a1e      	ldr	r2, [pc, #120]	; (8888 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x98>)
    8810:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8814:	9303      	str	r3, [sp, #12]
    }
    else
    {
#endif

    boolean disabled = !FlexCAN_IsEnabled(pBase);
    8816:	9803      	ldr	r0, [sp, #12]
    8818:	f7fe f9b2 	bl	6b80 <FlexCAN_IsEnabled>
    881c:	4603      	mov	r3, r0
    881e:	2b00      	cmp	r3, #0
    8820:	bf14      	ite	ne
    8822:	2301      	movne	r3, #1
    8824:	2300      	moveq	r3, #0
    8826:	b2db      	uxtb	r3, r3
    8828:	f083 0301 	eor.w	r3, r3, #1
    882c:	b2db      	uxtb	r3, r3
    882e:	f88d 300b 	strb.w	r3, [sp, #11]
    8832:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8836:	f003 0301 	and.w	r3, r3, #1
    883a:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    883e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8842:	2b00      	cmp	r3, #0
    8844:	d003      	beq.n	884e <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    8846:	9803      	ldr	r0, [sp, #12]
    8848:	f001 f94c 	bl	9ae4 <FlexCAN_Enable>
    884c:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    884e:	9b05      	ldr	r3, [sp, #20]
    8850:	2b00      	cmp	r3, #0
    8852:	d106      	bne.n	8862 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x72>
    {
        FlexCAN_SetRxIndividualMask(pBase, mb_idx, mask);
    8854:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8858:	9a00      	ldr	r2, [sp, #0]
    885a:	4619      	mov	r1, r3
    885c:	9803      	ldr	r0, [sp, #12]
    885e:	f7fe fbc2 	bl	6fe6 <FlexCAN_SetRxIndividualMask>
    }

    if (TRUE == disabled)
    8862:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8866:	2b00      	cmp	r3, #0
    8868:	d008      	beq.n	887c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    886a:	9803      	ldr	r0, [sp, #12]
    886c:	f001 f9b8 	bl	9be0 <FlexCAN_Disable>
    8870:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8872:	9b04      	ldr	r3, [sp, #16]
    8874:	2b00      	cmp	r3, #0
    8876:	d001      	beq.n	887c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
        {
            result = status;
    8878:	9b04      	ldr	r3, [sp, #16]
    887a:	9305      	str	r3, [sp, #20]
        }
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    887c:	9b05      	ldr	r3, [sp, #20]
}
    887e:	4618      	mov	r0, r3
    8880:	b007      	add	sp, #28
    8882:	f85d fb04 	ldr.w	pc, [sp], #4
    8886:	bf00      	nop
    8888:	0000c650 	.word	0x0000c650

0000888c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>:
 * Description   : Set RxFifo Global Mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxFifoGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxFifoGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    888c:	b500      	push	{lr}
    888e:	b087      	sub	sp, #28
    8890:	4603      	mov	r3, r0
    8892:	9100      	str	r1, [sp, #0]
    8894:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8898:	2300      	movs	r3, #0
    889a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    889c:	2300      	movs	r3, #0
    889e:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    88a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    88a4:	4a1c      	ldr	r2, [pc, #112]	; (8918 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x8c>)
    88a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88aa:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    88ac:	9803      	ldr	r0, [sp, #12]
    88ae:	f7fe f967 	bl	6b80 <FlexCAN_IsEnabled>
    88b2:	4603      	mov	r3, r0
    88b4:	2b00      	cmp	r3, #0
    88b6:	bf14      	ite	ne
    88b8:	2301      	movne	r3, #1
    88ba:	2300      	moveq	r3, #0
    88bc:	b2db      	uxtb	r3, r3
    88be:	f083 0301 	eor.w	r3, r3, #1
    88c2:	b2db      	uxtb	r3, r3
    88c4:	f88d 300b 	strb.w	r3, [sp, #11]
    88c8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    88cc:	f003 0301 	and.w	r3, r3, #1
    88d0:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    88d4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    88d8:	2b00      	cmp	r3, #0
    88da:	d003      	beq.n	88e4 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    88dc:	9803      	ldr	r0, [sp, #12]
    88de:	f001 f901 	bl	9ae4 <FlexCAN_Enable>
    88e2:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    88e4:	9b05      	ldr	r3, [sp, #20]
    88e6:	2b00      	cmp	r3, #0
    88e8:	d103      	bne.n	88f2 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxFifoGlobalMask(pBase, mask);
    88ea:	9900      	ldr	r1, [sp, #0]
    88ec:	9803      	ldr	r0, [sp, #12]
    88ee:	f7fe f917 	bl	6b20 <FlexCAN_SetRxFifoGlobalMask>
    }

    if (TRUE == disabled)
    88f2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    88f6:	2b00      	cmp	r3, #0
    88f8:	d008      	beq.n	890c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    88fa:	9803      	ldr	r0, [sp, #12]
    88fc:	f001 f970 	bl	9be0 <FlexCAN_Disable>
    8900:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8902:	9b04      	ldr	r3, [sp, #16]
    8904:	2b00      	cmp	r3, #0
    8906:	d001      	beq.n	890c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
        {
            result = status;
    8908:	9b04      	ldr	r3, [sp, #16]
    890a:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    890c:	9b05      	ldr	r3, [sp, #20]
}
    890e:	4618      	mov	r0, r3
    8910:	b007      	add	sp, #28
    8912:	f85d fb04 	ldr.w	pc, [sp], #4
    8916:	bf00      	nop
    8918:	0000c650 	.word	0x0000c650

0000891c <FlexCAN_Ip_Deinit_Privileged>:
 * This function will disable all FlexCAN interrupts, and disable the FlexCAN.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_Deinit_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Deinit_Privileged(uint8 instance)
{
    891c:	b500      	push	{lr}
    891e:	b085      	sub	sp, #20
    8920:	4603      	mov	r3, r0
    8922:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8926:	f89d 3007 	ldrb.w	r3, [sp, #7]
    892a:	4a0e      	ldr	r2, [pc, #56]	; (8964 <FlexCAN_Ip_Deinit_Privileged+0x48>)
    892c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8930:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Enter Freeze Mode Required before to enter Disabled Mode */
    result = FlexCAN_EnterFreezeMode(base);
    8932:	9803      	ldr	r0, [sp, #12]
    8934:	f001 f88a 	bl	9a4c <FlexCAN_EnterFreezeMode>
    8938:	9002      	str	r0, [sp, #8]
    if (FLEXCAN_STATUS_SUCCESS == result)
    893a:	9b02      	ldr	r3, [sp, #8]
    893c:	2b00      	cmp	r3, #0
    893e:	d10b      	bne.n	8958 <FlexCAN_Ip_Deinit_Privileged+0x3c>
    {
        /* Reset registers */
        FlexCAN_SetRegDefaultVal(base);
    8940:	9803      	ldr	r0, [sp, #12]
    8942:	f7fe fb88 	bl	7056 <FlexCAN_SetRegDefaultVal>
        /* wait for disable */
        (void)FlexCAN_Disable(base);
    8946:	9803      	ldr	r0, [sp, #12]
    8948:	f001 f94a 	bl	9be0 <FlexCAN_Disable>
        /* Clear state pointer that is checked by FLEXCAN_DRV_Init */
        Flexcan_Ip_apxState[instance] = NULL_PTR;
    894c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8950:	4a05      	ldr	r2, [pc, #20]	; (8968 <FlexCAN_Ip_Deinit_Privileged+0x4c>)
    8952:	2100      	movs	r1, #0
    8954:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            OsIf_Trusted_Call1param(FlexCAN_ClrUserAccessAllowed, base);
        }
    #endif
    }

    return result;
    8958:	9b02      	ldr	r3, [sp, #8]
}
    895a:	4618      	mov	r0, r3
    895c:	b005      	add	sp, #20
    895e:	f85d fb04 	ldr.w	pc, [sp], #4
    8962:	bf00      	nop
    8964:	0000c650 	.word	0x0000c650
    8968:	1fff8f64 	.word	0x1fff8f64

0000896c <FlexCAN_Ip_MainFunctionRead>:
 * This function read the messages received as pulling or if the Interrupts are disabled.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionRead_Activity */
void FlexCAN_Ip_MainFunctionRead(uint8 instance, uint8 mb_idx)
{
    896c:	b500      	push	{lr}
    896e:	b085      	sub	sp, #20
    8970:	4603      	mov	r3, r0
    8972:	460a      	mov	r2, r1
    8974:	f88d 3007 	strb.w	r3, [sp, #7]
    8978:	4613      	mov	r3, r2
    897a:	f88d 3006 	strb.w	r3, [sp, #6]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    897e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8982:	4a22      	ldr	r2, [pc, #136]	; (8a0c <FlexCAN_Ip_MainFunctionRead+0xa0>)
    8984:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8988:	9303      	str	r3, [sp, #12]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    898a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    898e:	4a20      	ldr	r2, [pc, #128]	; (8a10 <FlexCAN_Ip_MainFunctionRead+0xa4>)
    8990:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8994:	9302      	str	r3, [sp, #8]
        }
    }
    else
    {
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
        if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    8996:	9b02      	ldr	r3, [sp, #8]
    8998:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    899c:	2b00      	cmp	r3, #0
    899e:	d015      	beq.n	89cc <FlexCAN_Ip_MainFunctionRead+0x60>
    89a0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    89a4:	2b07      	cmp	r3, #7
    89a6:	d811      	bhi.n	89cc <FlexCAN_Ip_MainFunctionRead+0x60>
        {
            /* just process available legacy fifo event only */
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    89a8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    89ac:	2b00      	cmp	r3, #0
    89ae:	d128      	bne.n	8a02 <FlexCAN_Ip_MainFunctionRead+0x96>
            {
                if (FlexCAN_GetBuffStatusFlag(base, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE) != 0U)
    89b0:	2105      	movs	r1, #5
    89b2:	9803      	ldr	r0, [sp, #12]
    89b4:	f7fe f951 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    89b8:	4603      	mov	r3, r0
    89ba:	2b00      	cmp	r3, #0
    89bc:	d021      	beq.n	8a02 <FlexCAN_Ip_MainFunctionRead+0x96>
                {
                    FlexCAN_IRQHandlerRxFIFO(instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE);
    89be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    89c2:	2105      	movs	r1, #5
    89c4:	4618      	mov	r0, r3
    89c6:	f7fe ff87 	bl	78d8 <FlexCAN_IRQHandlerRxFIFO>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    89ca:	e01a      	b.n	8a02 <FlexCAN_Ip_MainFunctionRead+0x96>
                }
            }
        }
        else
        {
            if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    89cc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    89d0:	4619      	mov	r1, r3
    89d2:	9803      	ldr	r0, [sp, #12]
    89d4:	f7fe f941 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    89d8:	4603      	mov	r3, r0
    89da:	2b00      	cmp	r3, #0
    89dc:	d012      	beq.n	8a04 <FlexCAN_Ip_MainFunctionRead+0x98>
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    89de:	f89d 3006 	ldrb.w	r3, [sp, #6]
    89e2:	9a02      	ldr	r2, [sp, #8]
    89e4:	011b      	lsls	r3, r3, #4
    89e6:	4413      	add	r3, r2
    89e8:	3304      	adds	r3, #4
    89ea:	681b      	ldr	r3, [r3, #0]
    89ec:	2b01      	cmp	r3, #1
    89ee:	d109      	bne.n	8a04 <FlexCAN_Ip_MainFunctionRead+0x98>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    89f0:	f89d 2006 	ldrb.w	r2, [sp, #6]
    89f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    89f8:	4611      	mov	r1, r2
    89fa:	4618      	mov	r0, r3
    89fc:	f7fe fde4 	bl	75c8 <FlexCAN_IRQHandlerRxMB>
            }
        }
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
}
    8a00:	e000      	b.n	8a04 <FlexCAN_Ip_MainFunctionRead+0x98>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    8a02:	bf00      	nop
}
    8a04:	bf00      	nop
    8a06:	b005      	add	sp, #20
    8a08:	f85d fb04 	ldr.w	pc, [sp], #4
    8a0c:	0000c650 	.word	0x0000c650
    8a10:	1fff8f64 	.word	0x1fff8f64

00008a14 <FlexCAN_Ip_MainFunctionBusOff_Privileged>:
 * This function check the bus off event.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionBusOff_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_MainFunctionBusOff_Privileged(uint8 instance)
{
    8a14:	b510      	push	{r4, lr}
    8a16:	b086      	sub	sp, #24
    8a18:	4603      	mov	r3, r0
    8a1a:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    8a1e:	2301      	movs	r3, #1
    8a20:	9305      	str	r3, [sp, #20]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8a22:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a26:	4a15      	ldr	r2, [pc, #84]	; (8a7c <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x68>)
    8a28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a2c:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    8a2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a32:	4a13      	ldr	r2, [pc, #76]	; (8a80 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x6c>)
    8a34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a38:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    8a3a:	2300      	movs	r3, #0
    8a3c:	9302      	str	r3, [sp, #8]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Get error status */
    u32ErrStatus = base->ESR1;
    8a3e:	9b04      	ldr	r3, [sp, #16]
    8a40:	6a1b      	ldr	r3, [r3, #32]
    8a42:	9302      	str	r3, [sp, #8]

    if (0U != (u32ErrStatus & FLEXCAN_ESR1_BOFFINT_MASK))
    8a44:	9b02      	ldr	r3, [sp, #8]
    8a46:	f003 0304 	and.w	r3, r3, #4
    8a4a:	2b00      	cmp	r3, #0
    8a4c:	d012      	beq.n	8a74 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x60>
    {
        /* Invoke callback */
        if (state->error_callback != NULL_PTR)
    8a4e:	9b03      	ldr	r3, [sp, #12]
    8a50:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    8a54:	2b00      	cmp	r3, #0
    8a56:	d008      	beq.n	8a6a <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x56>
        {
            state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    8a58:	9b03      	ldr	r3, [sp, #12]
    8a5a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    8a5e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    8a62:	9b03      	ldr	r3, [sp, #12]
    8a64:	9a02      	ldr	r2, [sp, #8]
    8a66:	2107      	movs	r1, #7
    8a68:	47a0      	blx	r4
        }
        /* Clear BusOff Status Flag */
        base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    8a6a:	9b04      	ldr	r3, [sp, #16]
    8a6c:	2204      	movs	r2, #4
    8a6e:	621a      	str	r2, [r3, #32]
        eRetVal = FLEXCAN_STATUS_SUCCESS;
    8a70:	2300      	movs	r3, #0
    8a72:	9305      	str	r3, [sp, #20]
    }
    return eRetVal;
    8a74:	9b05      	ldr	r3, [sp, #20]
}
    8a76:	4618      	mov	r0, r3
    8a78:	b006      	add	sp, #24
    8a7a:	bd10      	pop	{r4, pc}
    8a7c:	0000c650 	.word	0x0000c650
    8a80:	1fff8f64 	.word	0x1fff8f64

00008a84 <FlexCAN_Ip_MainFunctionWrite>:
 * This function check the message if have been sent.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionWrite_Activity */
void FlexCAN_Ip_MainFunctionWrite(uint8 instance, uint8 mb_idx)
{
    8a84:	b510      	push	{r4, lr}
    8a86:	b098      	sub	sp, #96	; 0x60
    8a88:	4603      	mov	r3, r0
    8a8a:	460a      	mov	r2, r1
    8a8c:	f88d 3007 	strb.w	r3, [sp, #7]
    8a90:	4613      	mov	r3, r2
    8a92:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8a96:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a9a:	4a3f      	ldr	r2, [pc, #252]	; (8b98 <FlexCAN_Ip_MainFunctionWrite+0x114>)
    8a9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aa0:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    8aa2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8aa6:	4a3d      	ldr	r2, [pc, #244]	; (8b9c <FlexCAN_Ip_MainFunctionWrite+0x118>)
    8aa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aac:	9316      	str	r3, [sp, #88]	; 0x58

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    8aae:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ab2:	4619      	mov	r1, r3
    8ab4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8ab6:	f7fe f8d0 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    8aba:	4603      	mov	r3, r0
    8abc:	2b00      	cmp	r3, #0
    8abe:	d068      	beq.n	8b92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
    {
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    8ac0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ac4:	9a16      	ldr	r2, [sp, #88]	; 0x58
    8ac6:	011b      	lsls	r3, r3, #4
    8ac8:	4413      	add	r3, r2
    8aca:	3304      	adds	r3, #4
    8acc:	681b      	ldr	r3, [r3, #0]
    8ace:	2b02      	cmp	r3, #2
    8ad0:	d15f      	bne.n	8b92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
        {
            if (state->mbs[mb_idx].isRemote)
    8ad2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ad6:	9a16      	ldr	r2, [sp, #88]	; 0x58
    8ad8:	011b      	lsls	r3, r3, #4
    8ada:	4413      	add	r3, r2
    8adc:	3309      	adds	r3, #9
    8ade:	781b      	ldrb	r3, [r3, #0]
    8ae0:	2b00      	cmp	r3, #0
    8ae2:	d028      	beq.n	8b36 <FlexCAN_Ip_MainFunctionWrite+0xb2>
            {
                Flexcan_Ip_MsgBuffType mb;
                mb.cs = 0U;
    8ae4:	2300      	movs	r3, #0
    8ae6:	9302      	str	r3, [sp, #8]
                mb.time_stamp = 0U;
    8ae8:	2300      	movs	r3, #0
    8aea:	9315      	str	r3, [sp, #84]	; 0x54
                FlexCAN_LockRxMsgBuff(base, mb_idx);
    8aec:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8af0:	4619      	mov	r1, r3
    8af2:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8af4:	f001 fa87 	bl	a006 <FlexCAN_LockRxMsgBuff>
                FlexCAN_GetMsgBuff(base, mb_idx, &mb);
    8af8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8afc:	aa02      	add	r2, sp, #8
    8afe:	4619      	mov	r1, r3
    8b00:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b02:	f001 fbaf 	bl	a264 <FlexCAN_GetMsgBuff>
                FlexCAN_UnlockRxMsgBuff(base);
    8b06:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b08:	f7fe f88d 	bl	6c26 <FlexCAN_UnlockRxMsgBuff>
                state->mbs[mb_idx].time_stamp = mb.time_stamp;
    8b0c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8b10:	9a15      	ldr	r2, [sp, #84]	; 0x54
    8b12:	9916      	ldr	r1, [sp, #88]	; 0x58
    8b14:	011b      	lsls	r3, r3, #4
    8b16:	440b      	add	r3, r1
    8b18:	330c      	adds	r3, #12
    8b1a:	601a      	str	r2, [r3, #0]
                /* If the frame was a remote frame, clear the flag only if the response was
                * not received yet. If the response was received, leave the flag set in order
                * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
                if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    8b1c:	9b02      	ldr	r3, [sp, #8]
    8b1e:	0e1b      	lsrs	r3, r3, #24
    8b20:	f003 030f 	and.w	r3, r3, #15
    8b24:	2b04      	cmp	r3, #4
    8b26:	d11d      	bne.n	8b64 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                {
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    8b28:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8b2c:	4619      	mov	r1, r3
    8b2e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b30:	f7fe f880 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
    8b34:	e016      	b.n	8b64 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                }
            }
            else
            {
                state->mbs[mb_idx].time_stamp = FlexCAN_GetMsgBuffTimestamp(base, mb_idx);
    8b36:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8b3a:	f89d 4006 	ldrb.w	r4, [sp, #6]
    8b3e:	4619      	mov	r1, r3
    8b40:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b42:	f001 fb7b 	bl	a23c <FlexCAN_GetMsgBuffTimestamp>
    8b46:	4601      	mov	r1, r0
    8b48:	9a16      	ldr	r2, [sp, #88]	; 0x58
    8b4a:	0123      	lsls	r3, r4, #4
    8b4c:	4413      	add	r3, r2
    8b4e:	330c      	adds	r3, #12
    8b50:	6019      	str	r1, [r3, #0]
                FlexCAN_UnlockRxMsgBuff(base);
    8b52:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b54:	f7fe f867 	bl	6c26 <FlexCAN_UnlockRxMsgBuff>
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    8b58:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8b5c:	4619      	mov	r1, r3
    8b5e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    8b60:	f7fe f868 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
            }

            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    8b64:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8b68:	9a16      	ldr	r2, [sp, #88]	; 0x58
    8b6a:	011b      	lsls	r3, r3, #4
    8b6c:	4413      	add	r3, r2
    8b6e:	3304      	adds	r3, #4
    8b70:	2200      	movs	r2, #0
    8b72:	601a      	str	r2, [r3, #0]

            /* Invoke callback */
            if (state->callback != NULL_PTR)
    8b74:	9b16      	ldr	r3, [sp, #88]	; 0x58
    8b76:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    8b7a:	2b00      	cmp	r3, #0
    8b7c:	d009      	beq.n	8b92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
            {
                state->callback(instance, FLEXCAN_EVENT_TX_COMPLETE, mb_idx, state);
    8b7e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    8b80:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    8b84:	f89d 2006 	ldrb.w	r2, [sp, #6]
    8b88:	f89d 0007 	ldrb.w	r0, [sp, #7]
    8b8c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    8b8e:	2104      	movs	r1, #4
    8b90:	47a0      	blx	r4
            }
        }
    }
}
    8b92:	bf00      	nop
    8b94:	b018      	add	sp, #96	; 0x60
    8b96:	bd10      	pop	{r4, pc}
    8b98:	0000c650 	.word	0x0000c650
    8b9c:	1fff8f64 	.word	0x1fff8f64

00008ba0 <FlexCAN_Ip_GetStopMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STOPPED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStopMode_Activity */
boolean FlexCAN_Ip_GetStopMode_Privileged(uint8 instance)
{
    8ba0:	b084      	sub	sp, #16
    8ba2:	4603      	mov	r3, r0
    8ba4:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8ba8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8bac:	4a08      	ldr	r2, [pc, #32]	; (8bd0 <FlexCAN_Ip_GetStopMode_Privileged+0x30>)
    8bae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bb2:	9303      	str	r3, [sp, #12]
    return ((FLEXCAN_MCR_LPMACK_MASK == (base->MCR & FLEXCAN_MCR_LPMACK_MASK)) ? TRUE : FALSE);
    8bb4:	9b03      	ldr	r3, [sp, #12]
    8bb6:	681b      	ldr	r3, [r3, #0]
    8bb8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    8bbc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    8bc0:	bf0c      	ite	eq
    8bc2:	2301      	moveq	r3, #1
    8bc4:	2300      	movne	r3, #0
    8bc6:	b2db      	uxtb	r3, r3
}
    8bc8:	4618      	mov	r0, r3
    8bca:	b004      	add	sp, #16
    8bcc:	4770      	bx	lr
    8bce:	bf00      	nop
    8bd0:	0000c650 	.word	0x0000c650

00008bd4 <FlexCAN_Ip_GetStartMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STARTED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStartMode_Activity */
boolean FlexCAN_Ip_GetStartMode_Privileged(uint8 instance)
{
    8bd4:	b084      	sub	sp, #16
    8bd6:	4603      	mov	r3, r0
    8bd8:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    8bdc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8be0:	4a07      	ldr	r2, [pc, #28]	; (8c00 <FlexCAN_Ip_GetStartMode_Privileged+0x2c>)
    8be2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8be6:	9303      	str	r3, [sp, #12]
    return ((0U == (base->MCR & (FLEXCAN_MCR_LPMACK_MASK | FLEXCAN_MCR_FRZACK_MASK))) ? TRUE : FALSE);
    8be8:	9b03      	ldr	r3, [sp, #12]
    8bea:	681b      	ldr	r3, [r3, #0]
    8bec:	f003 7388 	and.w	r3, r3, #17825792	; 0x1100000
    8bf0:	2b00      	cmp	r3, #0
    8bf2:	bf0c      	ite	eq
    8bf4:	2301      	moveq	r3, #1
    8bf6:	2300      	movne	r3, #0
    8bf8:	b2db      	uxtb	r3, r3
}
    8bfa:	4618      	mov	r0, r3
    8bfc:	b004      	add	sp, #16
    8bfe:	4770      	bx	lr
    8c00:	0000c650 	.word	0x0000c650

00008c04 <FlexCAN_Ip_SetStartMode_Privileged>:
 * Description   : Set the FlexCAN instance in START mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStartMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStartMode_Privileged(uint8 instance)
{
    8c04:	b500      	push	{lr}
    8c06:	b085      	sub	sp, #20
    8c08:	4603      	mov	r3, r0
    8c0a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8c0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8c12:	4a0b      	ldr	r2, [pc, #44]	; (8c40 <FlexCAN_Ip_SetStartMode_Privileged+0x3c>)
    8c14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c18:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    8c1a:	f002 fb31 	bl	b280 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>
    /* Enable Flexcan Module */
    pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    8c1e:	9b03      	ldr	r3, [sp, #12]
    8c20:	681b      	ldr	r3, [r3, #0]
    8c22:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    8c26:	9b03      	ldr	r3, [sp, #12]
    8c28:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    8c2a:	f002 fb55 	bl	b2d8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>

    return (FlexCAN_ExitFreezeMode(pBase));
    8c2e:	9803      	ldr	r0, [sp, #12]
    8c30:	f000 ff94 	bl	9b5c <FlexCAN_ExitFreezeMode>
    8c34:	4603      	mov	r3, r0
}
    8c36:	4618      	mov	r0, r3
    8c38:	b005      	add	sp, #20
    8c3a:	f85d fb04 	ldr.w	pc, [sp], #4
    8c3e:	bf00      	nop
    8c40:	0000c650 	.word	0x0000c650

00008c44 <FlexCAN_Ip_SetStopMode_Privileged>:
 * Description   : Set the FlexCAN instance in STOP mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStopMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStopMode_Privileged(uint8 instance)
{
    8c44:	b500      	push	{lr}
    8c46:	b085      	sub	sp, #20
    8c48:	4603      	mov	r3, r0
    8c4a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8c4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8c52:	4a0a      	ldr	r2, [pc, #40]	; (8c7c <FlexCAN_Ip_SetStopMode_Privileged+0x38>)
    8c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c58:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status;
    status = FlexCAN_EnterFreezeMode(pBase);
    8c5a:	9802      	ldr	r0, [sp, #8]
    8c5c:	f000 fef6 	bl	9a4c <FlexCAN_EnterFreezeMode>
    8c60:	9003      	str	r0, [sp, #12]
    if (FLEXCAN_STATUS_SUCCESS == status)
    8c62:	9b03      	ldr	r3, [sp, #12]
    8c64:	2b00      	cmp	r3, #0
    8c66:	d103      	bne.n	8c70 <FlexCAN_Ip_SetStopMode_Privileged+0x2c>

        /* TODO: reset MB status */

        /* TODO: disable all interrupt */

        status = FlexCAN_Disable(pBase);
    8c68:	9802      	ldr	r0, [sp, #8]
    8c6a:	f000 ffb9 	bl	9be0 <FlexCAN_Disable>
    8c6e:	9003      	str	r0, [sp, #12]
    }
    return status;
    8c70:	9b03      	ldr	r3, [sp, #12]
}
    8c72:	4618      	mov	r0, r3
    8c74:	b005      	add	sp, #20
    8c76:	f85d fb04 	ldr.w	pc, [sp], #4
    8c7a:	bf00      	nop
    8c7c:	0000c650 	.word	0x0000c650

00008c80 <FlexCAN_Ip_SetRxMaskType_Privileged>:
 * mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxMaskType_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMaskType_Privileged(uint8 instance, Flexcan_Ip_RxMaskType type)
{
    8c80:	b500      	push	{lr}
    8c82:	b087      	sub	sp, #28
    8c84:	4603      	mov	r3, r0
    8c86:	9100      	str	r1, [sp, #0]
    8c88:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8c8c:	2300      	movs	r3, #0
    8c8e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8c90:	2300      	movs	r3, #0
    8c92:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8c94:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8c98:	4a1e      	ldr	r2, [pc, #120]	; (8d14 <FlexCAN_Ip_SetRxMaskType_Privileged+0x94>)
    8c9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c9e:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    8ca0:	9803      	ldr	r0, [sp, #12]
    8ca2:	f7fd ff6d 	bl	6b80 <FlexCAN_IsEnabled>
    8ca6:	4603      	mov	r3, r0
    8ca8:	2b00      	cmp	r3, #0
    8caa:	bf14      	ite	ne
    8cac:	2301      	movne	r3, #1
    8cae:	2300      	moveq	r3, #0
    8cb0:	b2db      	uxtb	r3, r3
    8cb2:	f083 0301 	eor.w	r3, r3, #1
    8cb6:	b2db      	uxtb	r3, r3
    8cb8:	f88d 300b 	strb.w	r3, [sp, #11]
    8cbc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8cc0:	f003 0301 	and.w	r3, r3, #1
    8cc4:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    8cc8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8ccc:	2b00      	cmp	r3, #0
    8cce:	d003      	beq.n	8cd8 <FlexCAN_Ip_SetRxMaskType_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    8cd0:	9803      	ldr	r0, [sp, #12]
    8cd2:	f000 ff07 	bl	9ae4 <FlexCAN_Enable>
    8cd6:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    8cd8:	9b05      	ldr	r3, [sp, #20]
    8cda:	2b00      	cmp	r3, #0
    8cdc:	d107      	bne.n	8cee <FlexCAN_Ip_SetRxMaskType_Privileged+0x6e>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    8cde:	f002 fb21 	bl	b324 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
        FlexCAN_SetRxMaskType(pBase, type);
    8ce2:	9900      	ldr	r1, [sp, #0]
    8ce4:	9803      	ldr	r0, [sp, #12]
    8ce6:	f7fe f9a0 	bl	702a <FlexCAN_SetRxMaskType>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    8cea:	f002 fb47 	bl	b37c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
    }

    if (TRUE == disabled)
    8cee:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8cf2:	2b00      	cmp	r3, #0
    8cf4:	d008      	beq.n	8d08 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
    {
        status = FlexCAN_Disable(pBase);
    8cf6:	9803      	ldr	r0, [sp, #12]
    8cf8:	f000 ff72 	bl	9be0 <FlexCAN_Disable>
    8cfc:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8cfe:	9b04      	ldr	r3, [sp, #16]
    8d00:	2b00      	cmp	r3, #0
    8d02:	d001      	beq.n	8d08 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
        {
            result = status;
    8d04:	9b04      	ldr	r3, [sp, #16]
    8d06:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    8d08:	9b05      	ldr	r3, [sp, #20]
}
    8d0a:	4618      	mov	r0, r3
    8d0c:	b007      	add	sp, #28
    8d0e:	f85d fb04 	ldr.w	pc, [sp], #4
    8d12:	bf00      	nop
    8d14:	0000c650 	.word	0x0000c650

00008d18 <FlexCAN_Ip_SetBitrate_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrate_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrate_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
    8d18:	b500      	push	{lr}
    8d1a:	b087      	sub	sp, #28
    8d1c:	4603      	mov	r3, r0
    8d1e:	9100      	str	r1, [sp, #0]
    8d20:	f88d 3007 	strb.w	r3, [sp, #7]
    8d24:	4613      	mov	r3, r2
    8d26:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8d2a:	2300      	movs	r3, #0
    8d2c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8d2e:	2300      	movs	r3, #0
    8d30:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8d32:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8d36:	4a1c      	ldr	r2, [pc, #112]	; (8da8 <FlexCAN_Ip_SetBitrate_Privileged+0x90>)
    8d38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d3c:	9303      	str	r3, [sp, #12]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    8d3e:	9b03      	ldr	r3, [sp, #12]
    8d40:	681b      	ldr	r3, [r3, #0]
    8d42:	0fdb      	lsrs	r3, r3, #31
    8d44:	f88d 300b 	strb.w	r3, [sp, #11]
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_OFF)
    (void)enhExt;
#endif
    if (TRUE == disabled)
    8d48:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8d4c:	2b00      	cmp	r3, #0
    8d4e:	d003      	beq.n	8d58 <FlexCAN_Ip_SetBitrate_Privileged+0x40>
    {
        result = FlexCAN_Enable(pBase);
    8d50:	9803      	ldr	r0, [sp, #12]
    8d52:	f000 fec7 	bl	9ae4 <FlexCAN_Enable>
    8d56:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    8d58:	9b05      	ldr	r3, [sp, #20]
    8d5a:	2b00      	cmp	r3, #0
    8d5c:	d112      	bne.n	8d84 <FlexCAN_Ip_SetBitrate_Privileged+0x6c>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    8d5e:	f002 fccd 	bl	b6fc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
            FlexCAN_SetEnhancedNominalTimeSegments(pBase, bitrate);
        }
        else
#endif
        {
            if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    8d62:	9803      	ldr	r0, [sp, #12]
    8d64:	f7fe f8a0 	bl	6ea8 <FlexCAN_IsExCbtEnabled>
    8d68:	4603      	mov	r3, r0
    8d6a:	2b00      	cmp	r3, #0
    8d6c:	d004      	beq.n	8d78 <FlexCAN_Ip_SetBitrate_Privileged+0x60>
            {
                FlexCAN_SetExtendedTimeSegments(pBase, bitrate);
    8d6e:	9900      	ldr	r1, [sp, #0]
    8d70:	9803      	ldr	r0, [sp, #12]
    8d72:	f7fd ffef 	bl	6d54 <FlexCAN_SetExtendedTimeSegments>
    8d76:	e003      	b.n	8d80 <FlexCAN_Ip_SetBitrate_Privileged+0x68>
            }
            else
            {
                FlexCAN_SetTimeSegments(pBase, bitrate);
    8d78:	9900      	ldr	r1, [sp, #0]
    8d7a:	9803      	ldr	r0, [sp, #12]
    8d7c:	f7fd ffbe 	bl	6cfc <FlexCAN_SetTimeSegments>
            }
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    8d80:	f002 fce8 	bl	b754 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
    }

    if (TRUE == disabled)
    8d84:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8d88:	2b00      	cmp	r3, #0
    8d8a:	d008      	beq.n	8d9e <FlexCAN_Ip_SetBitrate_Privileged+0x86>
    {
        status = FlexCAN_Disable(pBase);
    8d8c:	9803      	ldr	r0, [sp, #12]
    8d8e:	f000 ff27 	bl	9be0 <FlexCAN_Disable>
    8d92:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8d94:	9b04      	ldr	r3, [sp, #16]
    8d96:	2b00      	cmp	r3, #0
    8d98:	d001      	beq.n	8d9e <FlexCAN_Ip_SetBitrate_Privileged+0x86>
        {
            result = status;
    8d9a:	9b04      	ldr	r3, [sp, #16]
    8d9c:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    8d9e:	9b05      	ldr	r3, [sp, #20]
}
    8da0:	4618      	mov	r0, r3
    8da2:	b007      	add	sp, #28
    8da4:	f85d fb04 	ldr.w	pc, [sp], #4
    8da8:	0000c650 	.word	0x0000c650

00008dac <FlexCAN_Ip_GetBitrate>:
 * or the arbitration phase of FD frames.
 *
 *END**************************************************************************/
 /* implements   FlexCAN_Ip_GetBitrate_Activity */
boolean FlexCAN_Ip_GetBitrate(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    8dac:	b500      	push	{lr}
    8dae:	b085      	sub	sp, #20
    8db0:	4603      	mov	r3, r0
    8db2:	9100      	str	r1, [sp, #0]
    8db4:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8db8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8dbc:	4a0d      	ldr	r2, [pc, #52]	; (8df4 <FlexCAN_Ip_GetBitrate+0x48>)
    8dbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dc2:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    8dc4:	2300      	movs	r3, #0
    8dc6:	f88d 300b 	strb.w	r3, [sp, #11]
        FlexCAN_GetEnhancedNominalTimeSegments(pBase, bitrate);
    }
    else
#endif
    {
        if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    8dca:	9803      	ldr	r0, [sp, #12]
    8dcc:	f7fe f86c 	bl	6ea8 <FlexCAN_IsExCbtEnabled>
    8dd0:	4603      	mov	r3, r0
    8dd2:	2b00      	cmp	r3, #0
    8dd4:	d004      	beq.n	8de0 <FlexCAN_Ip_GetBitrate+0x34>
        {
            /* Get the Extended time segments*/
            FlexCAN_GetExtendedTimeSegments(pBase, bitrate);
    8dd6:	9900      	ldr	r1, [sp, #0]
    8dd8:	9803      	ldr	r0, [sp, #12]
    8dda:	f7fd ffe9 	bl	6db0 <FlexCAN_GetExtendedTimeSegments>
    8dde:	e003      	b.n	8de8 <FlexCAN_Ip_GetBitrate+0x3c>
        }
        else
        {
            /* Get the time segments*/
            FlexCAN_GetTimeSegments(pBase, bitrate);
    8de0:	9900      	ldr	r1, [sp, #0]
    8de2:	9803      	ldr	r0, [sp, #12]
    8de4:	f7fe f80c 	bl	6e00 <FlexCAN_GetTimeSegments>
        }
    }
    return enhCbt;
    8de8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    8dec:	4618      	mov	r0, r3
    8dee:	b005      	add	sp, #20
    8df0:	f85d fb04 	ldr.w	pc, [sp], #4
    8df4:	0000c650 	.word	0x0000c650

00008df8 <FlexCAN_Ip_ClearTDCFail>:
 * Description   : This function clear the TDC Fail flag.
 *
 *END**************************************************************************/
/* implements   FlexCAN_Ip_ClearTDCFail_Activity */
void FlexCAN_Ip_ClearTDCFail(uint8 u8Instance)
{
    8df8:	b500      	push	{lr}
    8dfa:	b085      	sub	sp, #20
    8dfc:	4603      	mov	r3, r0
    8dfe:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    8e02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8e06:	4a0a      	ldr	r2, [pc, #40]	; (8e30 <FlexCAN_Ip_ClearTDCFail+0x38>)
    8e08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e0c:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    8e0e:	f002 fadb 	bl	b3c8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
        pBase->ETDC |=  FLEXCAN_ETDC_ETDCFAIL_MASK;
    }
    else
#endif
    {
        pBase->FDCTRL |= FLEXCAN_FDCTRL_TDCFAIL_MASK;
    8e12:	9b03      	ldr	r3, [sp, #12]
    8e14:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    8e18:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    8e1c:	9b03      	ldr	r3, [sp, #12]
    8e1e:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    8e22:	f002 fafd 	bl	b420 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
}
    8e26:	bf00      	nop
    8e28:	b005      	add	sp, #20
    8e2a:	f85d fb04 	ldr.w	pc, [sp], #4
    8e2e:	bf00      	nop
    8e30:	0000c650 	.word	0x0000c650

00008e34 <FlexCAN_Ip_GetTDCFail>:
 *
 *END**************************************************************************/

/* implements    FlexCAN_Ip_GetTDCFail_Activity */
boolean FlexCAN_Ip_GetTDCFail(uint8 u8Instance)
{
    8e34:	b084      	sub	sp, #16
    8e36:	4603      	mov	r3, r0
    8e38:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean value=FALSE;
    8e3c:	2300      	movs	r3, #0
    8e3e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    8e42:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8e46:	4a0a      	ldr	r2, [pc, #40]	; (8e70 <FlexCAN_Ip_GetTDCFail+0x3c>)
    8e48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e4c:	9302      	str	r3, [sp, #8]
        value = ((pBase->ETDC & FLEXCAN_ETDC_ETDCFAIL_MASK) == FLEXCAN_ETDC_ETDCFAIL_MASK) ? TRUE : FALSE;
    }
    else
#endif
    {
        value = ((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCFAIL_MASK) == FLEXCAN_FDCTRL_TDCFAIL_MASK) ? TRUE : FALSE;
    8e4e:	9b02      	ldr	r3, [sp, #8]
    8e50:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    8e54:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    8e58:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    8e5c:	bf0c      	ite	eq
    8e5e:	2301      	moveq	r3, #1
    8e60:	2300      	movne	r3, #0
    8e62:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    8e66:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    8e6a:	4618      	mov	r0, r3
    8e6c:	b004      	add	sp, #16
    8e6e:	4770      	bx	lr
    8e70:	0000c650 	.word	0x0000c650

00008e74 <FlexCAN_Ip_GetTDCValue>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_GetTDCValue_Activity */
uint8 FlexCAN_Ip_GetTDCValue(uint8 u8Instance)
{
    8e74:	b084      	sub	sp, #16
    8e76:	4603      	mov	r3, r0
    8e78:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 value = 0;
    8e7c:	2300      	movs	r3, #0
    8e7e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    8e82:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8e86:	4a08      	ldr	r2, [pc, #32]	; (8ea8 <FlexCAN_Ip_GetTDCValue+0x34>)
    8e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e8c:	9302      	str	r3, [sp, #8]
        value = (uint8)((pBase->ETDC& FLEXCAN_ETDC_ETDCVAL_MASK) >> FLEXCAN_ETDC_ETDCVAL_SHIFT);
    }
    else
#endif
    {
        value = (uint8)((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCVAL_MASK) >> FLEXCAN_FDCTRL_TDCVAL_SHIFT);
    8e8e:	9b02      	ldr	r3, [sp, #8]
    8e90:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    8e94:	b2db      	uxtb	r3, r3
    8e96:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8e9a:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    8e9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    8ea2:	4618      	mov	r0, r3
    8ea4:	b004      	add	sp, #16
    8ea6:	4770      	bx	lr
    8ea8:	0000c650 	.word	0x0000c650

00008eac <FlexCAN_Ip_SetBitrateCbt_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrateCbt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrateCbt_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
    8eac:	b500      	push	{lr}
    8eae:	b087      	sub	sp, #28
    8eb0:	4603      	mov	r3, r0
    8eb2:	9100      	str	r1, [sp, #0]
    8eb4:	f88d 3007 	strb.w	r3, [sp, #7]
    8eb8:	4613      	mov	r3, r2
    8eba:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8ebe:	2300      	movs	r3, #0
    8ec0:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8ec2:	2300      	movs	r3, #0
    8ec4:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8ec6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8eca:	4a1e      	ldr	r2, [pc, #120]	; (8f44 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x98>)
    8ecc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ed0:	9303      	str	r3, [sp, #12]
    boolean fd_enable = FlexCAN_IsFDEnabled(pBase);
    8ed2:	9803      	ldr	r0, [sp, #12]
    8ed4:	f7fe f81f 	bl	6f16 <FlexCAN_IsFDEnabled>
    8ed8:	4603      	mov	r3, r0
    8eda:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    8ede:	9b03      	ldr	r3, [sp, #12]
    8ee0:	681b      	ldr	r3, [r3, #0]
    8ee2:	0fdb      	lsrs	r3, r3, #31
    8ee4:	f88d 300a 	strb.w	r3, [sp, #10]

    if (TRUE == disabled)
    8ee8:	f89d 300a 	ldrb.w	r3, [sp, #10]
    8eec:	2b00      	cmp	r3, #0
    8eee:	d003      	beq.n	8ef8 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x4c>
    {
        result = FlexCAN_Enable(pBase);
    8ef0:	9803      	ldr	r0, [sp, #12]
    8ef2:	f000 fdf7 	bl	9ae4 <FlexCAN_Enable>
    8ef6:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    8ef8:	9b05      	ldr	r3, [sp, #20]
    8efa:	2b00      	cmp	r3, #0
    8efc:	d10f      	bne.n	8f1e <FlexCAN_Ip_SetBitrateCbt_Privileged+0x72>
    {
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_ON)
        boolean enhCbt = FlexCAN_IsEnhCbtEnabled(pBase);
#endif
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    8efe:	f002 fc4f 	bl	b7a0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
        FlexCAN_SetFDEnabled(pBase, fd_enable, bitRateSwitch);
    8f02:	f89d 2006 	ldrb.w	r2, [sp, #6]
    8f06:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8f0a:	4619      	mov	r1, r3
    8f0c:	9803      	ldr	r0, [sp, #12]
    8f0e:	f7fd fe41 	bl	6b94 <FlexCAN_SetFDEnabled>
        }
        else
#endif
        {
            /* Set time segments*/
            FlexCAN_SetFDTimeSegments(pBase, bitrate);
    8f12:	9900      	ldr	r1, [sp, #0]
    8f14:	9803      	ldr	r0, [sp, #12]
    8f16:	f7fd febc 	bl	6c92 <FlexCAN_SetFDTimeSegments>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    8f1a:	f002 fc6d 	bl	b7f8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
    }

    if (TRUE == disabled)
    8f1e:	f89d 300a 	ldrb.w	r3, [sp, #10]
    8f22:	2b00      	cmp	r3, #0
    8f24:	d008      	beq.n	8f38 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    8f26:	9803      	ldr	r0, [sp, #12]
    8f28:	f000 fe5a 	bl	9be0 <FlexCAN_Disable>
    8f2c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    8f2e:	9b04      	ldr	r3, [sp, #16]
    8f30:	2b00      	cmp	r3, #0
    8f32:	d001      	beq.n	8f38 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
        {
            result = status;
    8f34:	9b04      	ldr	r3, [sp, #16]
    8f36:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    8f38:	9b05      	ldr	r3, [sp, #20]
}
    8f3a:	4618      	mov	r0, r3
    8f3c:	b007      	add	sp, #28
    8f3e:	f85d fb04 	ldr.w	pc, [sp], #4
    8f42:	bf00      	nop
    8f44:	0000c650 	.word	0x0000c650

00008f48 <FlexCAN_Ip_GetBitrateFD>:
 * of FD frames.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBitrateFD_Activity */
boolean FlexCAN_Ip_GetBitrateFD(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    8f48:	b500      	push	{lr}
    8f4a:	b085      	sub	sp, #20
    8f4c:	4603      	mov	r3, r0
    8f4e:	9100      	str	r1, [sp, #0]
    8f50:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8f54:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8f58:	4a08      	ldr	r2, [pc, #32]	; (8f7c <FlexCAN_Ip_GetBitrateFD+0x34>)
    8f5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f5e:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    8f60:	2300      	movs	r3, #0
    8f62:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    else
#endif
    {
        /* Get the time segments*/
        FlexCAN_GetFDTimeSegments(pBase, bitrate);
    8f66:	9900      	ldr	r1, [sp, #0]
    8f68:	9803      	ldr	r0, [sp, #12]
    8f6a:	f7fd ff70 	bl	6e4e <FlexCAN_GetFDTimeSegments>
    }
    return enhCbt;
    8f6e:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    8f72:	4618      	mov	r0, r3
    8f74:	b005      	add	sp, #20
    8f76:	f85d fb04 	ldr.w	pc, [sp], #4
    8f7a:	bf00      	nop
    8f7c:	0000c650 	.word	0x0000c650

00008f80 <FlexCAN_Ip_SetTDCOffset_Privileged>:
 * the Transceiver Delay Compensation Offset.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTDCOffset_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTDCOffset_Privileged(uint8 instance, boolean enable, uint8 offset)
{
    8f80:	b500      	push	{lr}
    8f82:	b087      	sub	sp, #28
    8f84:	4603      	mov	r3, r0
    8f86:	f88d 3007 	strb.w	r3, [sp, #7]
    8f8a:	460b      	mov	r3, r1
    8f8c:	f88d 3006 	strb.w	r3, [sp, #6]
    8f90:	4613      	mov	r3, r2
    8f92:	f88d 3005 	strb.w	r3, [sp, #5]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    8f96:	2300      	movs	r3, #0
    8f98:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    8f9a:	2300      	movs	r3, #0
    8f9c:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    8f9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8fa2:	4a20      	ldr	r2, [pc, #128]	; (9024 <FlexCAN_Ip_SetTDCOffset_Privileged+0xa4>)
    8fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fa8:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    8faa:	9803      	ldr	r0, [sp, #12]
    8fac:	f7fd fde8 	bl	6b80 <FlexCAN_IsEnabled>
    8fb0:	4603      	mov	r3, r0
    8fb2:	2b00      	cmp	r3, #0
    8fb4:	bf14      	ite	ne
    8fb6:	2301      	movne	r3, #1
    8fb8:	2300      	moveq	r3, #0
    8fba:	b2db      	uxtb	r3, r3
    8fbc:	f083 0301 	eor.w	r3, r3, #1
    8fc0:	b2db      	uxtb	r3, r3
    8fc2:	f88d 300b 	strb.w	r3, [sp, #11]
    8fc6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8fca:	f003 0301 	and.w	r3, r3, #1
    8fce:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    8fd2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8fd6:	2b00      	cmp	r3, #0
    8fd8:	d003      	beq.n	8fe2 <FlexCAN_Ip_SetTDCOffset_Privileged+0x62>
    {
        result = FlexCAN_Enable(pBase);
    8fda:	9803      	ldr	r0, [sp, #12]
    8fdc:	f000 fd82 	bl	9ae4 <FlexCAN_Enable>
    8fe0:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    8fe2:	9b05      	ldr	r3, [sp, #20]
    8fe4:	2b00      	cmp	r3, #0
    8fe6:	d10b      	bne.n	9000 <FlexCAN_Ip_SetTDCOffset_Privileged+0x80>
    {
        /* Check if enhaced CBT is Enabled */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    8fe8:	f002 fc2c 	bl	b844 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        }
        else
#endif
        {
            /* Enable/Disable TDC and set the TDC Offset */
            FlexCAN_SetTDCOffset(pBase, enable, offset);
    8fec:	f89d 2005 	ldrb.w	r2, [sp, #5]
    8ff0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ff4:	4619      	mov	r1, r3
    8ff6:	9803      	ldr	r0, [sp, #12]
    8ff8:	f7fd fd9b 	bl	6b32 <FlexCAN_SetTDCOffset>
        }
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    8ffc:	f002 fc4e 	bl	b89c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        /* Check if enhaced CBT is Enabled */
    }

    if (TRUE == disabled)
    9000:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9004:	2b00      	cmp	r3, #0
    9006:	d008      	beq.n	901a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
    {
        status = FlexCAN_Disable(pBase);
    9008:	9803      	ldr	r0, [sp, #12]
    900a:	f000 fde9 	bl	9be0 <FlexCAN_Disable>
    900e:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    9010:	9b04      	ldr	r3, [sp, #16]
    9012:	2b00      	cmp	r3, #0
    9014:	d001      	beq.n	901a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
        {
            result = status;
    9016:	9b04      	ldr	r3, [sp, #16]
    9018:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    901a:	9b05      	ldr	r3, [sp, #20]
}
    901c:	4618      	mov	r0, r3
    901e:	b007      	add	sp, #28
    9020:	f85d fb04 	ldr.w	pc, [sp], #4
    9024:	0000c650 	.word	0x0000c650

00009028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>:
 * be delayed from the first bit of CRC field on CAN bus.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTxArbitrationStartDelay_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged(uint8 instance,  uint8 value)
{
    9028:	b500      	push	{lr}
    902a:	b087      	sub	sp, #28
    902c:	4603      	mov	r3, r0
    902e:	460a      	mov	r2, r1
    9030:	f88d 3007 	strb.w	r3, [sp, #7]
    9034:	4613      	mov	r3, r2
    9036:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    903a:	2300      	movs	r3, #0
    903c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    903e:	2300      	movs	r3, #0
    9040:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    9042:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9046:	4a1f      	ldr	r2, [pc, #124]	; (90c4 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x9c>)
    9048:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    904c:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    904e:	9803      	ldr	r0, [sp, #12]
    9050:	f7fd fd96 	bl	6b80 <FlexCAN_IsEnabled>
    9054:	4603      	mov	r3, r0
    9056:	2b00      	cmp	r3, #0
    9058:	bf14      	ite	ne
    905a:	2301      	movne	r3, #1
    905c:	2300      	moveq	r3, #0
    905e:	b2db      	uxtb	r3, r3
    9060:	f083 0301 	eor.w	r3, r3, #1
    9064:	b2db      	uxtb	r3, r3
    9066:	f88d 300b 	strb.w	r3, [sp, #11]
    906a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    906e:	f003 0301 	and.w	r3, r3, #1
    9072:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    9076:	f89d 300b 	ldrb.w	r3, [sp, #11]
    907a:	2b00      	cmp	r3, #0
    907c:	d003      	beq.n	9086 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    907e:	9803      	ldr	r0, [sp, #12]
    9080:	f000 fd30 	bl	9ae4 <FlexCAN_Enable>
    9084:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    9086:	9b05      	ldr	r3, [sp, #20]
    9088:	2b00      	cmp	r3, #0
    908a:	d109      	bne.n	90a0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    908c:	f002 fc2c 	bl	b8e8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
        FlexCAN_SetTxArbitrationStartDelay(pBase, value);
    9090:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9094:	4619      	mov	r1, r3
    9096:	9803      	ldr	r0, [sp, #12]
    9098:	f7fd ffb3 	bl	7002 <FlexCAN_SetTxArbitrationStartDelay>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    909c:	f002 fc50 	bl	b940 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
    }

    if (TRUE == disabled)
    90a0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    90a4:	2b00      	cmp	r3, #0
    90a6:	d008      	beq.n	90ba <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    90a8:	9803      	ldr	r0, [sp, #12]
    90aa:	f000 fd99 	bl	9be0 <FlexCAN_Disable>
    90ae:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    90b0:	9b04      	ldr	r3, [sp, #16]
    90b2:	2b00      	cmp	r3, #0
    90b4:	d001      	beq.n	90ba <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
        {
            result = status;
    90b6:	9b04      	ldr	r3, [sp, #16]
    90b8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    90ba:	9b05      	ldr	r3, [sp, #20]
}
    90bc:	4618      	mov	r0, r3
    90be:	b007      	add	sp, #28
    90c0:	f85d fb04 	ldr.w	pc, [sp], #4
    90c4:	0000c650 	.word	0x0000c650

000090c8 <FlexCAN_Ip_GetBuffStatusFlag>:
 * In case of a complete operation this flag is set.
 * In case msgBuff is 255 will return Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBuffStatusFlag_Activity */
boolean FlexCAN_Ip_GetBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    90c8:	b500      	push	{lr}
    90ca:	b085      	sub	sp, #20
    90cc:	4603      	mov	r3, r0
    90ce:	460a      	mov	r2, r1
    90d0:	f88d 3007 	strb.w	r3, [sp, #7]
    90d4:	4613      	mov	r3, r2
    90d6:	f88d 3006 	strb.w	r3, [sp, #6]
    boolean returnResult;
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    90da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    90de:	4a0b      	ldr	r2, [pc, #44]	; (910c <FlexCAN_Ip_GetBuffStatusFlag+0x44>)
    90e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90e4:	9303      	str	r3, [sp, #12]
        returnResult = ((1U == FlexCAN_GetEnhancedRxFIFOStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW)) ? TRUE : FALSE);
    }
    else
#endif
    {
        returnResult = ((1U == FlexCAN_GetBuffStatusFlag(pBase, msgBuffIdx)) ? TRUE : FALSE);
    90e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    90ea:	4619      	mov	r1, r3
    90ec:	9803      	ldr	r0, [sp, #12]
    90ee:	f7fd fdb4 	bl	6c5a <FlexCAN_GetBuffStatusFlag>
    90f2:	4603      	mov	r3, r0
    90f4:	2b01      	cmp	r3, #1
    90f6:	bf0c      	ite	eq
    90f8:	2301      	moveq	r3, #1
    90fa:	2300      	movne	r3, #0
    90fc:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    return returnResult;
    9100:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    9104:	4618      	mov	r0, r3
    9106:	b005      	add	sp, #20
    9108:	f85d fb04 	ldr.w	pc, [sp], #4
    910c:	0000c650 	.word	0x0000c650

00009110 <FlexCAN_Ip_ClearBuffStatusFlag>:
 * Description   : Clear FlexCAN Message Buffer Status Flag.
 * In case msgBuff is 255 will clear Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearBuffStatusFlag_Activity */
void FlexCAN_Ip_ClearBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    9110:	b500      	push	{lr}
    9112:	b085      	sub	sp, #20
    9114:	4603      	mov	r3, r0
    9116:	460a      	mov	r2, r1
    9118:	f88d 3007 	strb.w	r3, [sp, #7]
    911c:	4613      	mov	r3, r2
    911e:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    9122:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9126:	4a07      	ldr	r2, [pc, #28]	; (9144 <FlexCAN_Ip_ClearBuffStatusFlag+0x34>)
    9128:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    912c:	9303      	str	r3, [sp, #12]
        FlexCAN_ClearEnhancedRxFifoIntStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
    }
    else
#endif
    {
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, msgBuffIdx);
    912e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9132:	4619      	mov	r1, r3
    9134:	9803      	ldr	r0, [sp, #12]
    9136:	f7fd fd7d 	bl	6c34 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }
}
    913a:	bf00      	nop
    913c:	b005      	add	sp, #20
    913e:	f85d fb04 	ldr.w	pc, [sp], #4
    9142:	bf00      	nop
    9144:	0000c650 	.word	0x0000c650

00009148 <FlexCAN_Ip_EnableInterrupts_Privileged>:
 * Description   : Enable all mb interrupts configured.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnableInterrupts_Privileged(uint8 u8Instance)
{
    9148:	b500      	push	{lr}
    914a:	b087      	sub	sp, #28
    914c:	4603      	mov	r3, r0
    914e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    9152:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9156:	4a11      	ldr	r2, [pc, #68]	; (919c <FlexCAN_Ip_EnableInterrupts_Privileged+0x54>)
    9158:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    915c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    915e:	2301      	movs	r3, #1
    9160:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    9162:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9166:	4a0e      	ldr	r2, [pc, #56]	; (91a0 <FlexCAN_Ip_EnableInterrupts_Privileged+0x58>)
    9168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    916c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    916e:	9804      	ldr	r0, [sp, #16]
    9170:	f7fd fd06 	bl	6b80 <FlexCAN_IsEnabled>
    9174:	4603      	mov	r3, r0
    9176:	2b00      	cmp	r3, #0
    9178:	d00b      	beq.n	9192 <FlexCAN_Ip_EnableInterrupts_Privileged+0x4a>
    {
        FlexCAN_EnableInterrupts(pBase, u8Instance);
    917a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    917e:	4619      	mov	r1, r3
    9180:	9804      	ldr	r0, [sp, #16]
    9182:	f000 ffe1 	bl	a148 <FlexCAN_EnableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, TRUE);
            }
        }
    #endif
        state->isIntActive = TRUE;
    9186:	9b03      	ldr	r3, [sp, #12]
    9188:	2201      	movs	r2, #1
    918a:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    918e:	2300      	movs	r3, #0
    9190:	9305      	str	r3, [sp, #20]
    }

    return result;
    9192:	9b05      	ldr	r3, [sp, #20]
}
    9194:	4618      	mov	r0, r3
    9196:	b007      	add	sp, #28
    9198:	f85d fb04 	ldr.w	pc, [sp], #4
    919c:	0000c650 	.word	0x0000c650
    91a0:	1fff8f64 	.word	0x1fff8f64

000091a4 <FlexCAN_Ip_DisableInterrupts_Privileged>:
 * Description   : Enable all interrupts configured.
 *
 *END**************************************************************************/
 /* implements FlexCAN_Ip_DisableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_DisableInterrupts_Privileged(uint8 u8Instance)
{
    91a4:	b500      	push	{lr}
    91a6:	b087      	sub	sp, #28
    91a8:	4603      	mov	r3, r0
    91aa:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    91ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    91b2:	4a10      	ldr	r2, [pc, #64]	; (91f4 <FlexCAN_Ip_DisableInterrupts_Privileged+0x50>)
    91b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91b8:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    91ba:	2301      	movs	r3, #1
    91bc:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    91be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    91c2:	4a0d      	ldr	r2, [pc, #52]	; (91f8 <FlexCAN_Ip_DisableInterrupts_Privileged+0x54>)
    91c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91c8:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    91ca:	9804      	ldr	r0, [sp, #16]
    91cc:	f7fd fcd8 	bl	6b80 <FlexCAN_IsEnabled>
    91d0:	4603      	mov	r3, r0
    91d2:	2b00      	cmp	r3, #0
    91d4:	d008      	beq.n	91e8 <FlexCAN_Ip_DisableInterrupts_Privileged+0x44>
    {
        FlexCAN_DisableInterrupts(pBase);
    91d6:	9804      	ldr	r0, [sp, #16]
    91d8:	f000 ffae 	bl	a138 <FlexCAN_DisableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, FALSE);
            }
        }
#endif
        state->isIntActive = FALSE;
    91dc:	9b03      	ldr	r3, [sp, #12]
    91de:	2200      	movs	r2, #0
    91e0:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    91e4:	2300      	movs	r3, #0
    91e6:	9305      	str	r3, [sp, #20]
    }

    return result;
    91e8:	9b05      	ldr	r3, [sp, #20]
}
    91ea:	4618      	mov	r0, r3
    91ec:	b007      	add	sp, #28
    91ee:	f85d fb04 	ldr.w	pc, [sp], #4
    91f2:	bf00      	nop
    91f4:	0000c650 	.word	0x0000c650
    91f8:	1fff8f64 	.word	0x1fff8f64

000091fc <FlexCAN_Ip_SetErrorInt_Privileged>:
 * Description   : Enable\Disable Error or BusOff Interrupt
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetErrorInt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetErrorInt_Privileged(uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
    91fc:	b500      	push	{lr}
    91fe:	b087      	sub	sp, #28
    9200:	4603      	mov	r3, r0
    9202:	9100      	str	r1, [sp, #0]
    9204:	f88d 3007 	strb.w	r3, [sp, #7]
    9208:	4613      	mov	r3, r2
    920a:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    920e:	2300      	movs	r3, #0
    9210:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    9212:	2300      	movs	r3, #0
    9214:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    9216:	f89d 3007 	ldrb.w	r3, [sp, #7]
    921a:	4a3a      	ldr	r2, [pc, #232]	; (9304 <FlexCAN_Ip_SetErrorInt_Privileged+0x108>)
    921c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9220:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    9222:	9803      	ldr	r0, [sp, #12]
    9224:	f7fd fcac 	bl	6b80 <FlexCAN_IsEnabled>
    9228:	4603      	mov	r3, r0
    922a:	2b00      	cmp	r3, #0
    922c:	bf14      	ite	ne
    922e:	2301      	movne	r3, #1
    9230:	2300      	moveq	r3, #0
    9232:	b2db      	uxtb	r3, r3
    9234:	f083 0301 	eor.w	r3, r3, #1
    9238:	b2db      	uxtb	r3, r3
    923a:	f88d 300b 	strb.w	r3, [sp, #11]
    923e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9242:	f003 0301 	and.w	r3, r3, #1
    9246:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    924a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    924e:	2b00      	cmp	r3, #0
    9250:	d003      	beq.n	925a <FlexCAN_Ip_SetErrorInt_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    9252:	9803      	ldr	r0, [sp, #12]
    9254:	f000 fc46 	bl	9ae4 <FlexCAN_Enable>
    9258:	9005      	str	r0, [sp, #20]
    }

    if (FLEXCAN_STATUS_SUCCESS == result)
    925a:	9b05      	ldr	r3, [sp, #20]
    925c:	2b00      	cmp	r3, #0
    925e:	d13c      	bne.n	92da <FlexCAN_Ip_SetErrorInt_Privileged+0xde>
    9260:	9b00      	ldr	r3, [sp, #0]
    9262:	2b04      	cmp	r3, #4
    9264:	d83b      	bhi.n	92de <FlexCAN_Ip_SetErrorInt_Privileged+0xe2>
    9266:	a201      	add	r2, pc, #4	; (adr r2, 926c <FlexCAN_Ip_SetErrorInt_Privileged+0x70>)
    9268:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    926c:	000092b7 	.word	0x000092b7
    9270:	000092c9 	.word	0x000092c9
    9274:	00009293 	.word	0x00009293
    9278:	000092a5 	.word	0x000092a5
    927c:	00009281 	.word	0x00009281
    {
        switch (type)
        {
            case FLEXCAN_IP_INT_BUSOFF:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_BUSOFF, enable);
    9280:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9284:	461a      	mov	r2, r3
    9286:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    928a:	9803      	ldr	r0, [sp, #12]
    928c:	f000 fce8 	bl	9c60 <FlexCAN_SetErrIntCmd>
                break;
    9290:	e026      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR, enable);
    9292:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9296:	461a      	mov	r2, r3
    9298:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    929c:	9803      	ldr	r0, [sp, #12]
    929e:	f000 fcdf 	bl	9c60 <FlexCAN_SetErrIntCmd>
                break;
    92a2:	e01d      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR_FAST :
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR_FAST, enable);
    92a4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    92a8:	461a      	mov	r2, r3
    92aa:	f244 0101 	movw	r1, #16385	; 0x4001
    92ae:	9803      	ldr	r0, [sp, #12]
    92b0:	f000 fcd6 	bl	9c60 <FlexCAN_SetErrIntCmd>
                break;
    92b4:	e014      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_RX_WARNING, enable);
    92b6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    92ba:	461a      	mov	r2, r3
    92bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
    92c0:	9803      	ldr	r0, [sp, #12]
    92c2:	f000 fccd 	bl	9c60 <FlexCAN_SetErrIntCmd>
                }
                break;
    92c6:	e00b      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_TX_WARNING, enable);
    92c8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    92cc:	461a      	mov	r2, r3
    92ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
    92d2:	9803      	ldr	r0, [sp, #12]
    92d4:	f000 fcc4 	bl	9c60 <FlexCAN_SetErrIntCmd>
                }
                break;
    92d8:	e002      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    /* Should not get here */
                #endif
                break;
            }
        }
    }
    92da:	bf00      	nop
    92dc:	e000      	b.n	92e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                break;
    92de:	bf00      	nop

    if (TRUE == disabled)
    92e0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    92e4:	2b00      	cmp	r3, #0
    92e6:	d008      	beq.n	92fa <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
    {
        status = FlexCAN_Disable(pBase);
    92e8:	9803      	ldr	r0, [sp, #12]
    92ea:	f000 fc79 	bl	9be0 <FlexCAN_Disable>
    92ee:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    92f0:	9b04      	ldr	r3, [sp, #16]
    92f2:	2b00      	cmp	r3, #0
    92f4:	d001      	beq.n	92fa <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
        {
            result = status;
    92f6:	9b04      	ldr	r3, [sp, #16]
    92f8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    92fa:	9b05      	ldr	r3, [sp, #20]
}
    92fc:	4618      	mov	r0, r3
    92fe:	b007      	add	sp, #28
    9300:	f85d fb04 	ldr.w	pc, [sp], #4
    9304:	0000c650 	.word	0x0000c650

00009308 <FlexCAN_Ip_AbortTransfer>:
 * receiver.
 *
 *END**************************************************************************/
/* implements    FlexCAN_Ip_AbortTransfer_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_AbortTransfer(uint8 u8Instance, uint8 mb_idx)
{
    9308:	b500      	push	{lr}
    930a:	b087      	sub	sp, #28
    930c:	4603      	mov	r3, r0
    930e:	460a      	mov	r2, r1
    9310:	f88d 3007 	strb.w	r3, [sp, #7]
    9314:	4613      	mov	r3, r2
    9316:	f88d 3006 	strb.w	r3, [sp, #6]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
        DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
    #endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    931a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    931e:	4a27      	ldr	r2, [pc, #156]	; (93bc <FlexCAN_Ip_AbortTransfer+0xb4>)
    9320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9324:	9304      	str	r3, [sp, #16]
#if ((FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON))
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
#else
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    9326:	f89d 3007 	ldrb.w	r3, [sp, #7]
    932a:	4a25      	ldr	r2, [pc, #148]	; (93c0 <FlexCAN_Ip_AbortTransfer+0xb8>)
    932c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9330:	9303      	str	r3, [sp, #12]
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON) */
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    9332:	2300      	movs	r3, #0
    9334:	9305      	str	r3, [sp, #20]

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    9336:	f89d 3006 	ldrb.w	r3, [sp, #6]
    933a:	2b1f      	cmp	r3, #31
    933c:	d838      	bhi.n	93b0 <FlexCAN_Ip_AbortTransfer+0xa8>
    {

    if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    933e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9342:	9a03      	ldr	r2, [sp, #12]
    9344:	011b      	lsls	r3, r3, #4
    9346:	4413      	add	r3, r2
    9348:	3304      	adds	r3, #4
    934a:	681b      	ldr	r3, [r3, #0]
    934c:	2b00      	cmp	r3, #0
    934e:	d102      	bne.n	9356 <FlexCAN_Ip_AbortTransfer+0x4e>
    {
        result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    9350:	2305      	movs	r3, #5
    9352:	9305      	str	r3, [sp, #20]
    9354:	e02c      	b.n	93b0 <FlexCAN_Ip_AbortTransfer+0xa8>
    }
    else
    {
        FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, mb_idx, state->isIntActive);
    9356:	f89d 2006 	ldrb.w	r2, [sp, #6]
    935a:	9b03      	ldr	r3, [sp, #12]
    935c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    9360:	f89d 1007 	ldrb.w	r1, [sp, #7]
    9364:	9804      	ldr	r0, [sp, #16]
    9366:	f000 feb3 	bl	a0d0 <FLEXCAN_ClearMsgBuffIntCmd>
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    936a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    936e:	9a03      	ldr	r2, [sp, #12]
    9370:	011b      	lsls	r3, r3, #4
    9372:	4413      	add	r3, r2
    9374:	3304      	adds	r3, #4
    9376:	681b      	ldr	r3, [r3, #0]
    9378:	2b02      	cmp	r3, #2
    937a:	d108      	bne.n	938e <FlexCAN_Ip_AbortTransfer+0x86>
        {
            result = FlexCAN_AbortTxTransfer(u8Instance, mb_idx);
    937c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    9380:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9384:	4611      	mov	r1, r2
    9386:	4618      	mov	r0, r3
    9388:	f7fe fb2c 	bl	79e4 <FlexCAN_AbortTxTransfer>
    938c:	9005      	str	r0, [sp, #20]
        }

        if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    938e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9392:	9a03      	ldr	r2, [sp, #12]
    9394:	011b      	lsls	r3, r3, #4
    9396:	4413      	add	r3, r2
    9398:	3304      	adds	r3, #4
    939a:	681b      	ldr	r3, [r3, #0]
    939c:	2b01      	cmp	r3, #1
    939e:	d107      	bne.n	93b0 <FlexCAN_Ip_AbortTransfer+0xa8>
        {
            FlexCAN_AbortRxTransfer(u8Instance, mb_idx);
    93a0:	f89d 2006 	ldrb.w	r2, [sp, #6]
    93a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    93a8:	4611      	mov	r1, r2
    93aa:	4618      	mov	r0, r3
    93ac:	f7fe fba4 	bl	7af8 <FlexCAN_AbortRxTransfer>
        }
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
#endif /* if FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return result;
    93b0:	9b05      	ldr	r3, [sp, #20]
}
    93b2:	4618      	mov	r0, r3
    93b4:	b007      	add	sp, #28
    93b6:	f85d fb04 	ldr.w	pc, [sp], #4
    93ba:	bf00      	nop
    93bc:	0000c650 	.word	0x0000c650
    93c0:	1fff8f64 	.word	0x1fff8f64

000093c4 <FlexCAN_Ip_SetRxMb14Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb14Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb14Mask_Privileged(uint8 instance, uint32 mask)
{
    93c4:	b500      	push	{lr}
    93c6:	b087      	sub	sp, #28
    93c8:	4603      	mov	r3, r0
    93ca:	9100      	str	r1, [sp, #0]
    93cc:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    93d0:	2300      	movs	r3, #0
    93d2:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    93d4:	2300      	movs	r3, #0
    93d6:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    93d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    93dc:	4a1b      	ldr	r2, [pc, #108]	; (944c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x88>)
    93de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93e2:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    93e4:	9803      	ldr	r0, [sp, #12]
    93e6:	f7fd fbcb 	bl	6b80 <FlexCAN_IsEnabled>
    93ea:	4603      	mov	r3, r0
    93ec:	2b00      	cmp	r3, #0
    93ee:	bf14      	ite	ne
    93f0:	2301      	movne	r3, #1
    93f2:	2300      	moveq	r3, #0
    93f4:	b2db      	uxtb	r3, r3
    93f6:	f083 0301 	eor.w	r3, r3, #1
    93fa:	b2db      	uxtb	r3, r3
    93fc:	f88d 300b 	strb.w	r3, [sp, #11]
    9400:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9404:	f003 0301 	and.w	r3, r3, #1
    9408:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    940c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9410:	2b00      	cmp	r3, #0
    9412:	d003      	beq.n	941c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    9414:	9803      	ldr	r0, [sp, #12]
    9416:	f000 fb65 	bl	9ae4 <FlexCAN_Enable>
    941a:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    941c:	9b05      	ldr	r3, [sp, #20]
    941e:	2b00      	cmp	r3, #0
    9420:	d102      	bne.n	9428 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x64>
    {
        pBase->RX14MASK = mask;
    9422:	9b03      	ldr	r3, [sp, #12]
    9424:	9a00      	ldr	r2, [sp, #0]
    9426:	615a      	str	r2, [r3, #20]
    }
    if (TRUE == disabled)
    9428:	f89d 300b 	ldrb.w	r3, [sp, #11]
    942c:	2b00      	cmp	r3, #0
    942e:	d008      	beq.n	9442 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    9430:	9803      	ldr	r0, [sp, #12]
    9432:	f000 fbd5 	bl	9be0 <FlexCAN_Disable>
    9436:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    9438:	9b04      	ldr	r3, [sp, #16]
    943a:	2b00      	cmp	r3, #0
    943c:	d001      	beq.n	9442 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
        {
            result = status;
    943e:	9b04      	ldr	r3, [sp, #16]
    9440:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    9442:	9b05      	ldr	r3, [sp, #20]
}
    9444:	4618      	mov	r0, r3
    9446:	b007      	add	sp, #28
    9448:	f85d fb04 	ldr.w	pc, [sp], #4
    944c:	0000c650 	.word	0x0000c650

00009450 <FlexCAN_Ip_SetRxMb15Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb15Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb15Mask_Privileged(uint8 instance, uint32 mask)
{
    9450:	b500      	push	{lr}
    9452:	b087      	sub	sp, #28
    9454:	4603      	mov	r3, r0
    9456:	9100      	str	r1, [sp, #0]
    9458:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    945c:	2300      	movs	r3, #0
    945e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    9460:	2300      	movs	r3, #0
    9462:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    9464:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9468:	4a1b      	ldr	r2, [pc, #108]	; (94d8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x88>)
    946a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    946e:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    9470:	9803      	ldr	r0, [sp, #12]
    9472:	f7fd fb85 	bl	6b80 <FlexCAN_IsEnabled>
    9476:	4603      	mov	r3, r0
    9478:	2b00      	cmp	r3, #0
    947a:	bf14      	ite	ne
    947c:	2301      	movne	r3, #1
    947e:	2300      	moveq	r3, #0
    9480:	b2db      	uxtb	r3, r3
    9482:	f083 0301 	eor.w	r3, r3, #1
    9486:	b2db      	uxtb	r3, r3
    9488:	f88d 300b 	strb.w	r3, [sp, #11]
    948c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9490:	f003 0301 	and.w	r3, r3, #1
    9494:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    9498:	f89d 300b 	ldrb.w	r3, [sp, #11]
    949c:	2b00      	cmp	r3, #0
    949e:	d003      	beq.n	94a8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    94a0:	9803      	ldr	r0, [sp, #12]
    94a2:	f000 fb1f 	bl	9ae4 <FlexCAN_Enable>
    94a6:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    94a8:	9b05      	ldr	r3, [sp, #20]
    94aa:	2b00      	cmp	r3, #0
    94ac:	d102      	bne.n	94b4 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x64>
    {
        pBase->RX15MASK = mask;
    94ae:	9b03      	ldr	r3, [sp, #12]
    94b0:	9a00      	ldr	r2, [sp, #0]
    94b2:	619a      	str	r2, [r3, #24]
    }

    if (TRUE == disabled)
    94b4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    94b8:	2b00      	cmp	r3, #0
    94ba:	d008      	beq.n	94ce <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    94bc:	9803      	ldr	r0, [sp, #12]
    94be:	f000 fb8f 	bl	9be0 <FlexCAN_Disable>
    94c2:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    94c4:	9b04      	ldr	r3, [sp, #16]
    94c6:	2b00      	cmp	r3, #0
    94c8:	d001      	beq.n	94ce <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
        {
            result = status;
    94ca:	9b04      	ldr	r3, [sp, #16]
    94cc:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    94ce:	9b05      	ldr	r3, [sp, #20]
}
    94d0:	4618      	mov	r0, r3
    94d2:	b007      	add	sp, #28
    94d4:	f85d fb04 	ldr.w	pc, [sp], #4
    94d8:	0000c650 	.word	0x0000c650

000094dc <FlexCAN_Ip_SetListenOnlyMode_Privileged>:
 * This function will enable or disable Listen Only mode.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_SetListenOnlyMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetListenOnlyMode_Privileged(uint8 instance, const boolean enable)
{
    94dc:	b500      	push	{lr}
    94de:	b087      	sub	sp, #28
    94e0:	4603      	mov	r3, r0
    94e2:	460a      	mov	r2, r1
    94e4:	f88d 3007 	strb.w	r3, [sp, #7]
    94e8:	4613      	mov	r3, r2
    94ea:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    94ee:	2300      	movs	r3, #0
    94f0:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    94f2:	2300      	movs	r3, #0
    94f4:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    94f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    94fa:	4a1f      	ldr	r2, [pc, #124]	; (9578 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x9c>)
    94fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9500:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    9502:	9803      	ldr	r0, [sp, #12]
    9504:	f7fd fb3c 	bl	6b80 <FlexCAN_IsEnabled>
    9508:	4603      	mov	r3, r0
    950a:	2b00      	cmp	r3, #0
    950c:	bf14      	ite	ne
    950e:	2301      	movne	r3, #1
    9510:	2300      	moveq	r3, #0
    9512:	b2db      	uxtb	r3, r3
    9514:	f083 0301 	eor.w	r3, r3, #1
    9518:	b2db      	uxtb	r3, r3
    951a:	f88d 300b 	strb.w	r3, [sp, #11]
    951e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9522:	f003 0301 	and.w	r3, r3, #1
    9526:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    952a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    952e:	2b00      	cmp	r3, #0
    9530:	d003      	beq.n	953a <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    9532:	9803      	ldr	r0, [sp, #12]
    9534:	f000 fad6 	bl	9ae4 <FlexCAN_Enable>
    9538:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    953a:	9b05      	ldr	r3, [sp, #20]
    953c:	2b00      	cmp	r3, #0
    953e:	d109      	bne.n	9554 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    9540:	f001 ff94 	bl	b46c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
        FlexCAN_SetListenOnlyMode(pBase, enable);
    9544:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9548:	4619      	mov	r1, r3
    954a:	9803      	ldr	r0, [sp, #12]
    954c:	f7fd fb55 	bl	6bfa <FlexCAN_SetListenOnlyMode>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    9550:	f001 ffb8 	bl	b4c4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
    }

    if (TRUE == disabled)
    9554:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9558:	2b00      	cmp	r3, #0
    955a:	d008      	beq.n	956e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    955c:	9803      	ldr	r0, [sp, #12]
    955e:	f000 fb3f 	bl	9be0 <FlexCAN_Disable>
    9562:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    9564:	9b04      	ldr	r3, [sp, #16]
    9566:	2b00      	cmp	r3, #0
    9568:	d001      	beq.n	956e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
        {
            result = status;
    956a:	9b04      	ldr	r3, [sp, #16]
    956c:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    956e:	9b05      	ldr	r3, [sp, #20]
}
    9570:	4618      	mov	r0, r3
    9572:	b007      	add	sp, #28
    9574:	f85d fb04 	ldr.w	pc, [sp], #4
    9578:	0000c650 	.word	0x0000c650

0000957c <FlexCAN_Ip_GetListenOnlyMode>:
 * Description   : Check if Listen Only mode is ENABLE.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_GetListenOnlyMode_Activity */
boolean FlexCAN_Ip_GetListenOnlyMode(uint8 instance)
{
    957c:	b500      	push	{lr}
    957e:	b085      	sub	sp, #20
    9580:	4603      	mov	r3, r0
    9582:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    9586:	f89d 3007 	ldrb.w	r3, [sp, #7]
    958a:	4a06      	ldr	r2, [pc, #24]	; (95a4 <FlexCAN_Ip_GetListenOnlyMode+0x28>)
    958c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9590:	9303      	str	r3, [sp, #12]
    return FlexCAN_IsListenOnlyModeEnabled(base);
    9592:	9803      	ldr	r0, [sp, #12]
    9594:	f7fd fccd 	bl	6f32 <FlexCAN_IsListenOnlyModeEnabled>
    9598:	4603      	mov	r3, r0
}
    959a:	4618      	mov	r0, r3
    959c:	b005      	add	sp, #20
    959e:	f85d fb04 	ldr.w	pc, [sp], #4
    95a2:	bf00      	nop
    95a4:	0000c650 	.word	0x0000c650

000095a8 <FlexCAN_Ip_ManualBusOffRecovery>:
 * Description   : Recover manually from bus-off if possible.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_ManualBusOffRecovery_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ManualBusOffRecovery(uint8 Instance)
{
    95a8:	b500      	push	{lr}
    95aa:	b089      	sub	sp, #36	; 0x24
    95ac:	4603      	mov	r3, r0
    95ae:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * Base = Flexcan_Ip_apxBase[Instance];
    95b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    95b6:	4a27      	ldr	r2, [pc, #156]	; (9654 <FlexCAN_Ip_ManualBusOffRecovery+0xac>)
    95b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95bc:	9305      	str	r3, [sp, #20]
    uint32 timeStart = 0U;
    95be:	2300      	movs	r3, #0
    95c0:	9303      	str	r3, [sp, #12]
    uint32 timeElapsed = 0U;
    95c2:	2300      	movs	r3, #0
    95c4:	9307      	str	r3, [sp, #28]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    95c6:	2100      	movs	r1, #0
    95c8:	4823      	ldr	r0, [pc, #140]	; (9658 <FlexCAN_Ip_ManualBusOffRecovery+0xb0>)
    95ca:	f7f7 fd80 	bl	10ce <OsIf_MicrosToTicks>
    95ce:	9004      	str	r0, [sp, #16]
    Flexcan_Ip_StatusType RetVal = FLEXCAN_STATUS_ERROR;
    95d0:	2301      	movs	r3, #1
    95d2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Recover from bus-off when Automatic recovering from Bus Off state disabled. */
    if ((Base->CTRL1 & FLEXCAN_CTRL1_BOFFREC_MASK) != 0U)
    95d4:	9b05      	ldr	r3, [sp, #20]
    95d6:	685b      	ldr	r3, [r3, #4]
    95d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    95dc:	2b00      	cmp	r3, #0
    95de:	d033      	beq.n	9648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
    {
        RetVal = FLEXCAN_STATUS_SUCCESS;
    95e0:	2300      	movs	r3, #0
    95e2:	9306      	str	r3, [sp, #24]
        /* return success if the controller is not in bus-off */
        if ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    95e4:	9b05      	ldr	r3, [sp, #20]
    95e6:	6a1b      	ldr	r3, [r3, #32]
    95e8:	f003 0320 	and.w	r3, r3, #32
    95ec:	2b00      	cmp	r3, #0
    95ee:	d02b      	beq.n	9648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
        {
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    95f0:	f002 fa70 	bl	bad4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* negate to recover from bus-off */
            Base->CTRL1 &= ~FLEXCAN_CTRL1_BOFFREC_MASK;
    95f4:	9b05      	ldr	r3, [sp, #20]
    95f6:	685b      	ldr	r3, [r3, #4]
    95f8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    95fc:	9b05      	ldr	r3, [sp, #20]
    95fe:	605a      	str	r2, [r3, #4]
            /* re-assert to disable bus-off auto reocvery */
            Base->CTRL1 |= FLEXCAN_CTRL1_BOFFREC_MASK;
    9600:	9b05      	ldr	r3, [sp, #20]
    9602:	685b      	ldr	r3, [r3, #4]
    9604:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    9608:	9b05      	ldr	r3, [sp, #20]
    960a:	605a      	str	r2, [r3, #4]
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    960c:	f002 fa8e 	bl	bb2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* Wait till exit bus-off */
            timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9610:	2000      	movs	r0, #0
    9612:	f7f7 fd10 	bl	1036 <OsIf_GetCounter>
    9616:	4603      	mov	r3, r0
    9618:	9303      	str	r3, [sp, #12]

            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    961a:	e00f      	b.n	963c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
            {
                timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    961c:	ab03      	add	r3, sp, #12
    961e:	2100      	movs	r1, #0
    9620:	4618      	mov	r0, r3
    9622:	f7f7 fd21 	bl	1068 <OsIf_GetElapsed>
    9626:	4602      	mov	r2, r0
    9628:	9b07      	ldr	r3, [sp, #28]
    962a:	4413      	add	r3, r2
    962c:	9307      	str	r3, [sp, #28]
                if (timeElapsed >= uS2Ticks)
    962e:	9a07      	ldr	r2, [sp, #28]
    9630:	9b04      	ldr	r3, [sp, #16]
    9632:	429a      	cmp	r2, r3
    9634:	d302      	bcc.n	963c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
                {
                    RetVal = FLEXCAN_STATUS_TIMEOUT;
    9636:	2303      	movs	r3, #3
    9638:	9306      	str	r3, [sp, #24]
                    break;
    963a:	e005      	b.n	9648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    963c:	9b05      	ldr	r3, [sp, #20]
    963e:	6a1b      	ldr	r3, [r3, #32]
    9640:	f003 0320 	and.w	r3, r3, #32
    9644:	2b00      	cmp	r3, #0
    9646:	d1e9      	bne.n	961c <FlexCAN_Ip_ManualBusOffRecovery+0x74>
                }
            }
        }
    }

    return RetVal;
    9648:	9b06      	ldr	r3, [sp, #24]
}
    964a:	4618      	mov	r0, r3
    964c:	b009      	add	sp, #36	; 0x24
    964e:	f85d fb04 	ldr.w	pc, [sp], #4
    9652:	bf00      	nop
    9654:	0000c650 	.word	0x0000c650
    9658:	000f4240 	.word	0x000f4240

0000965c <FlexCAN_SetSelfReception>:
{
    965c:	b082      	sub	sp, #8
    965e:	9001      	str	r0, [sp, #4]
    9660:	460b      	mov	r3, r1
    9662:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    9666:	9b01      	ldr	r3, [sp, #4]
    9668:	681b      	ldr	r3, [r3, #0]
    966a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    966e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9672:	2a00      	cmp	r2, #0
    9674:	d001      	beq.n	967a <FlexCAN_SetSelfReception+0x1e>
    9676:	2200      	movs	r2, #0
    9678:	e001      	b.n	967e <FlexCAN_SetSelfReception+0x22>
    967a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    967e:	431a      	orrs	r2, r3
    9680:	9b01      	ldr	r3, [sp, #4]
    9682:	601a      	str	r2, [r3, #0]
}
    9684:	bf00      	nop
    9686:	b002      	add	sp, #8
    9688:	4770      	bx	lr

0000968a <FlexCAN_IsFDEnabled>:
{
    968a:	b082      	sub	sp, #8
    968c:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    968e:	9b01      	ldr	r3, [sp, #4]
    9690:	681b      	ldr	r3, [r3, #0]
    9692:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    9696:	2b00      	cmp	r3, #0
    9698:	bf14      	ite	ne
    969a:	2301      	movne	r3, #1
    969c:	2300      	moveq	r3, #0
    969e:	b2db      	uxtb	r3, r3
}
    96a0:	4618      	mov	r0, r3
    96a2:	b002      	add	sp, #8
    96a4:	4770      	bx	lr

000096a6 <FlexCAN_SetIsoCan>:
{
    96a6:	b082      	sub	sp, #8
    96a8:	9001      	str	r0, [sp, #4]
    96aa:	460b      	mov	r3, r1
    96ac:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ISOCANFDEN_MASK) | FLEXCAN_CTRL2_ISOCANFDEN(enable ? 1UL : 0UL);
    96b0:	9b01      	ldr	r3, [sp, #4]
    96b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    96b4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    96b8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    96bc:	2a00      	cmp	r2, #0
    96be:	d002      	beq.n	96c6 <FlexCAN_SetIsoCan+0x20>
    96c0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    96c4:	e000      	b.n	96c8 <FlexCAN_SetIsoCan+0x22>
    96c6:	2200      	movs	r2, #0
    96c8:	431a      	orrs	r2, r3
    96ca:	9b01      	ldr	r3, [sp, #4]
    96cc:	635a      	str	r2, [r3, #52]	; 0x34
}
    96ce:	bf00      	nop
    96d0:	b002      	add	sp, #8
    96d2:	4770      	bx	lr

000096d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>:
{
    96d4:	b082      	sub	sp, #8
    96d6:	9001      	str	r0, [sp, #4]
    96d8:	460b      	mov	r3, r1
    96da:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EACEN_MASK) | FLEXCAN_CTRL2_EACEN(enable ? 1UL : 0UL);
    96de:	9b01      	ldr	r3, [sp, #4]
    96e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    96e2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    96e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    96ea:	2a00      	cmp	r2, #0
    96ec:	d002      	beq.n	96f4 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x20>
    96ee:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    96f2:	e000      	b.n	96f6 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x22>
    96f4:	2200      	movs	r2, #0
    96f6:	431a      	orrs	r2, r3
    96f8:	9b01      	ldr	r3, [sp, #4]
    96fa:	635a      	str	r2, [r3, #52]	; 0x34
}
    96fc:	bf00      	nop
    96fe:	b002      	add	sp, #8
    9700:	4770      	bx	lr

00009702 <FlexCAN_SetProtocolException>:
{
    9702:	b082      	sub	sp, #8
    9704:	9001      	str	r0, [sp, #4]
    9706:	460b      	mov	r3, r1
    9708:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_PREXCEN_MASK) | FLEXCAN_CTRL2_PREXCEN(enable ? 1UL : 0UL);
    970c:	9b01      	ldr	r3, [sp, #4]
    970e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9710:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    9714:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9718:	2a00      	cmp	r2, #0
    971a:	d002      	beq.n	9722 <FlexCAN_SetProtocolException+0x20>
    971c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    9720:	e000      	b.n	9724 <FlexCAN_SetProtocolException+0x22>
    9722:	2200      	movs	r2, #0
    9724:	431a      	orrs	r2, r3
    9726:	9b01      	ldr	r3, [sp, #4]
    9728:	635a      	str	r2, [r3, #52]	; 0x34
}
    972a:	bf00      	nop
    972c:	b002      	add	sp, #8
    972e:	4770      	bx	lr

00009730 <FlexCAN_SetRemoteReqStore>:
{
    9730:	b082      	sub	sp, #8
    9732:	9001      	str	r0, [sp, #4]
    9734:	460b      	mov	r3, r1
    9736:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RRS_MASK) | FLEXCAN_CTRL2_RRS(enable ? 1UL : 0UL);
    973a:	9b01      	ldr	r3, [sp, #4]
    973c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    973e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    9742:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9746:	2a00      	cmp	r2, #0
    9748:	d002      	beq.n	9750 <FlexCAN_SetRemoteReqStore+0x20>
    974a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    974e:	e000      	b.n	9752 <FlexCAN_SetRemoteReqStore+0x22>
    9750:	2200      	movs	r2, #0
    9752:	431a      	orrs	r2, r3
    9754:	9b01      	ldr	r3, [sp, #4]
    9756:	635a      	str	r2, [r3, #52]	; 0x34
}
    9758:	bf00      	nop
    975a:	b002      	add	sp, #8
    975c:	4770      	bx	lr

0000975e <FlexCAN_SetBusOffAutorecovery>:
{
    975e:	b082      	sub	sp, #8
    9760:	9001      	str	r0, [sp, #4]
    9762:	460b      	mov	r3, r1
    9764:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_BOFFREC_MASK) | FLEXCAN_CTRL1_BOFFREC(enable ? 0UL : 1UL);
    9768:	9b01      	ldr	r3, [sp, #4]
    976a:	685b      	ldr	r3, [r3, #4]
    976c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    9770:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9774:	2a00      	cmp	r2, #0
    9776:	d001      	beq.n	977c <FlexCAN_SetBusOffAutorecovery+0x1e>
    9778:	2200      	movs	r2, #0
    977a:	e000      	b.n	977e <FlexCAN_SetBusOffAutorecovery+0x20>
    977c:	2240      	movs	r2, #64	; 0x40
    977e:	431a      	orrs	r2, r3
    9780:	9b01      	ldr	r3, [sp, #4]
    9782:	605a      	str	r2, [r3, #4]
}
    9784:	bf00      	nop
    9786:	b002      	add	sp, #8
    9788:	4770      	bx	lr

0000978a <FlexCAN_SetEdgeFilter>:
{
    978a:	b082      	sub	sp, #8
    978c:	9001      	str	r0, [sp, #4]
    978e:	460b      	mov	r3, r1
    9790:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EDFLTDIS_MASK) | FLEXCAN_CTRL2_EDFLTDIS(enable ? 0UL : 1UL);
    9794:	9b01      	ldr	r3, [sp, #4]
    9796:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9798:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    979c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    97a0:	2a00      	cmp	r2, #0
    97a2:	d001      	beq.n	97a8 <FlexCAN_SetEdgeFilter+0x1e>
    97a4:	2200      	movs	r2, #0
    97a6:	e001      	b.n	97ac <FlexCAN_SetEdgeFilter+0x22>
    97a8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    97ac:	431a      	orrs	r2, r3
    97ae:	9b01      	ldr	r3, [sp, #4]
    97b0:	635a      	str	r2, [r3, #52]	; 0x34
}
    97b2:	bf00      	nop
    97b4:	b002      	add	sp, #8
    97b6:	4770      	bx	lr

000097b8 <FlexCAN_CanBitSampling>:
{
    97b8:	b082      	sub	sp, #8
    97ba:	9001      	str	r0, [sp, #4]
    97bc:	460b      	mov	r3, r1
    97be:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_SMP_MASK) | FLEXCAN_CTRL1_SMP(enable ? 1UL : 0UL);
    97c2:	9b01      	ldr	r3, [sp, #4]
    97c4:	685b      	ldr	r3, [r3, #4]
    97c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    97ca:	f89d 2003 	ldrb.w	r2, [sp, #3]
    97ce:	2a00      	cmp	r2, #0
    97d0:	d001      	beq.n	97d6 <FlexCAN_CanBitSampling+0x1e>
    97d2:	2280      	movs	r2, #128	; 0x80
    97d4:	e000      	b.n	97d8 <FlexCAN_CanBitSampling+0x20>
    97d6:	2200      	movs	r2, #0
    97d8:	431a      	orrs	r2, r3
    97da:	9b01      	ldr	r3, [sp, #4]
    97dc:	605a      	str	r2, [r3, #4]
}
    97de:	bf00      	nop
    97e0:	b002      	add	sp, #8
    97e2:	4770      	bx	lr

000097e4 <FlexCAN_ComputeDLCValue>:
 * Function Name: FLEXCAN_ComputeDLCValue
 * Description  : Computes the DLC field value, given a payload size (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_ComputeDLCValue(uint8 payloadSize)
{
    97e4:	b084      	sub	sp, #16
    97e6:	4603      	mov	r3, r0
    97e8:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 ret = 0xFFU;                   /* 0,  1,  2,  3,  4,  5,  6,  7,  8, */
    97ec:	23ff      	movs	r3, #255	; 0xff
    97ee:	9303      	str	r3, [sp, #12]
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES
                                          };

    if (payloadSize <= 64U)
    97f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    97f4:	2b40      	cmp	r3, #64	; 0x40
    97f6:	d804      	bhi.n	9802 <FlexCAN_ComputeDLCValue+0x1e>
    {
        ret = payload_code[payloadSize];
    97f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    97fc:	4a03      	ldr	r2, [pc, #12]	; (980c <FlexCAN_ComputeDLCValue+0x28>)
    97fe:	5cd3      	ldrb	r3, [r2, r3]
    9800:	9303      	str	r3, [sp, #12]
    else
    {
        /* The argument is not a valid payload size will return 0xFF*/
    }

    return (uint8)ret;
    9802:	9b03      	ldr	r3, [sp, #12]
    9804:	b2db      	uxtb	r3, r3
}
    9806:	4618      	mov	r0, r3
    9808:	b004      	add	sp, #16
    980a:	4770      	bx	lr
    980c:	0000c65c 	.word	0x0000c65c

00009810 <FlexCAN_ClearRAM>:
 * Function Name : FLEXCAN_ClearRAM
 * Description   : Clears FlexCAN memory positions that require initialization.
 *
 *END**************************************************************************/
static void FlexCAN_ClearRAM(FLEXCAN_Type * base)
{
    9810:	b500      	push	{lr}
    9812:	b087      	sub	sp, #28
    9814:	9001      	str	r0, [sp, #4]
    uint32 databyte;
    uint32 RAM_size   = FlexCAN_GetMaxMbNum(base) * 4U;
    9816:	9801      	ldr	r0, [sp, #4]
    9818:	f000 f8f6 	bl	9a08 <FlexCAN_GetMaxMbNum>
    981c:	4603      	mov	r3, r0
    981e:	009b      	lsls	r3, r3, #2
    9820:	9304      	str	r3, [sp, #16]
    uint32 RXIMR_size = FlexCAN_GetMaxMbNum(base);
    9822:	9801      	ldr	r0, [sp, #4]
    9824:	f000 f8f0 	bl	9a08 <FlexCAN_GetMaxMbNum>
    9828:	9003      	str	r0, [sp, #12]
    /* Address of base + ram offset to point to MB start address */
    volatile uint32 * RAM = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    982a:	9b01      	ldr	r3, [sp, #4]
    982c:	3380      	adds	r3, #128	; 0x80
    982e:	9302      	str	r3, [sp, #8]
    /* Clear MB region */
    for (databyte = 0U; databyte < RAM_size; databyte++)
    9830:	2300      	movs	r3, #0
    9832:	9305      	str	r3, [sp, #20]
    9834:	e008      	b.n	9848 <FlexCAN_ClearRAM+0x38>
    {
        RAM[databyte] = 0x0U;
    9836:	9b05      	ldr	r3, [sp, #20]
    9838:	009b      	lsls	r3, r3, #2
    983a:	9a02      	ldr	r2, [sp, #8]
    983c:	4413      	add	r3, r2
    983e:	2200      	movs	r2, #0
    9840:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RAM_size; databyte++)
    9842:	9b05      	ldr	r3, [sp, #20]
    9844:	3301      	adds	r3, #1
    9846:	9305      	str	r3, [sp, #20]
    9848:	9a05      	ldr	r2, [sp, #20]
    984a:	9b04      	ldr	r3, [sp, #16]
    984c:	429a      	cmp	r2, r3
    984e:	d3f2      	bcc.n	9836 <FlexCAN_ClearRAM+0x26>
    }
    RAM = (volatile uint32 *)base->RXIMR;
    9850:	9b01      	ldr	r3, [sp, #4]
    9852:	f503 6308 	add.w	r3, r3, #2176	; 0x880
    9856:	9302      	str	r3, [sp, #8]
    /* Clear RXIMR region */
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    9858:	2300      	movs	r3, #0
    985a:	9305      	str	r3, [sp, #20]
    985c:	e008      	b.n	9870 <FlexCAN_ClearRAM+0x60>
    {
        RAM[databyte] = 0x0U;
    985e:	9b05      	ldr	r3, [sp, #20]
    9860:	009b      	lsls	r3, r3, #2
    9862:	9a02      	ldr	r2, [sp, #8]
    9864:	4413      	add	r3, r2
    9866:	2200      	movs	r2, #0
    9868:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    986a:	9b05      	ldr	r3, [sp, #20]
    986c:	3301      	adds	r3, #1
    986e:	9305      	str	r3, [sp, #20]
    9870:	9a05      	ldr	r2, [sp, #20]
    9872:	9b03      	ldr	r3, [sp, #12]
    9874:	429a      	cmp	r2, r3
    9876:	d3f2      	bcc.n	985e <FlexCAN_ClearRAM+0x4e>
    }
#endif
    /* Clear WRMFRZ bit in CTRL2 Register to restrict write access to memory */
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_WRMFRZ_MASK) | FLEXCAN_CTRL2_WRMFRZ(0U);
#endif /* if FLEXCAN_IP_FEATURE_HAS_MEM_ERR_DET */
}
    9878:	bf00      	nop
    987a:	bf00      	nop
    987c:	b007      	add	sp, #28
    987e:	f85d fb04 	ldr.w	pc, [sp], #4

00009882 <FlexCAN_ComputePayloadSize>:
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#else
static uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
{
    9882:	b084      	sub	sp, #16
    9884:	4603      	mov	r3, r0
    9886:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ret = 8U;
    988a:	2308      	movs	r3, #8
    988c:	f88d 300f 	strb.w	r3, [sp, #15]

    if (dlcValue <= 8U)
    9890:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9894:	2b08      	cmp	r3, #8
    9896:	d804      	bhi.n	98a2 <FlexCAN_ComputePayloadSize+0x20>
    {
        ret = dlcValue;
    9898:	f89d 3007 	ldrb.w	r3, [sp, #7]
    989c:	f88d 300f 	strb.w	r3, [sp, #15]
    98a0:	e033      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
    }
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    else
    {
        switch (dlcValue)
    98a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    98a6:	3b09      	subs	r3, #9
    98a8:	2b06      	cmp	r3, #6
    98aa:	d82d      	bhi.n	9908 <FlexCAN_ComputePayloadSize+0x86>
    98ac:	a201      	add	r2, pc, #4	; (adr r2, 98b4 <FlexCAN_ComputePayloadSize+0x32>)
    98ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    98b2:	bf00      	nop
    98b4:	000098d1 	.word	0x000098d1
    98b8:	000098d9 	.word	0x000098d9
    98bc:	000098e1 	.word	0x000098e1
    98c0:	000098e9 	.word	0x000098e9
    98c4:	000098f1 	.word	0x000098f1
    98c8:	000098f9 	.word	0x000098f9
    98cc:	00009901 	.word	0x00009901
        {
            case FLEXCAN_IP_DLC_VALUE_12_BYTES:
                ret = 12U;
    98d0:	230c      	movs	r3, #12
    98d2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98d6:	e018      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_16_BYTES:
                ret = 16U;
    98d8:	2310      	movs	r3, #16
    98da:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98de:	e014      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_20_BYTES:
                ret = 20U;
    98e0:	2314      	movs	r3, #20
    98e2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98e6:	e010      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_24_BYTES:
                ret = 24U;
    98e8:	2318      	movs	r3, #24
    98ea:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98ee:	e00c      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_32_BYTES:
                ret = 32U;
    98f0:	2320      	movs	r3, #32
    98f2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98f6:	e008      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_48_BYTES:
                ret = 48U;
    98f8:	2330      	movs	r3, #48	; 0x30
    98fa:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    98fe:	e004      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_64_BYTES:
                ret = 64U;
    9900:	2340      	movs	r3, #64	; 0x40
    9902:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    9906:	e000      	b.n	990a <FlexCAN_ComputePayloadSize+0x88>
            default:
                /* The argument is not a valid DLC size */
                break;
    9908:	bf00      	nop
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    return ret;
    990a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    990e:	4618      	mov	r0, r3
    9910:	b004      	add	sp, #16
    9912:	4770      	bx	lr

00009914 <FlexCAN_GetMsgBuffRegion>:
 * Function Name : FLEXCAN_GetMsgBuffRegion
 * Description   : Returns the start of a MB area, based on its index.
 *
 *END**************************************************************************/
volatile uint32 * FlexCAN_GetMsgBuffRegion(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    9914:	b500      	push	{lr}
    9916:	b08b      	sub	sp, #44	; 0x2c
    9918:	9001      	str	r0, [sp, #4]
    991a:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    991c:	2308      	movs	r3, #8
    991e:	f88d 3020 	strb.w	r3, [sp, #32]
    uint8 mb_size = 0U;
    9922:	2300      	movs	r3, #0
    9924:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ramBlockSize = 512U;
    9928:	f44f 7300 	mov.w	r3, #512	; 0x200
    992c:	9307      	str	r3, [sp, #28]
    uint16 ramBlockOffset = 0;
    992e:	2300      	movs	r3, #0
    9930:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    uint8 msgBuffIdxBackup = (uint8)msgBuffIdx;
    9934:	9b00      	ldr	r3, [sp, #0]
    9936:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint8 i=0U;
    993a:	2300      	movs	r3, #0
    993c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    uint8 maxMbNum=0U;
    9940:	2300      	movs	r3, #0
    9942:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    uint32 mb_index=0U;
    9946:	2300      	movs	r3, #0
    9948:	9306      	str	r3, [sp, #24]
    uint8 payload_size=0U;
    994a:	2300      	movs	r3, #0
    994c:	f88d 3017 	strb.w	r3, [sp, #23]
    volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    9950:	9b01      	ldr	r3, [sp, #4]
    9952:	3380      	adds	r3, #128	; 0x80
    9954:	9304      	str	r3, [sp, #16]
    volatile uint32 * pAddressRet = NULL_PTR;
    9956:	2300      	movs	r3, #0
    9958:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY == STD_ON)
    volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    995a:	2300      	movs	r3, #0
    995c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    9960:	e02d      	b.n	99be <FlexCAN_GetMsgBuffRegion+0xaa>
    {
        payload_size = FlexCAN_GetPayloadSize(base, i);
    9962:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    9966:	4619      	mov	r1, r3
    9968:	9801      	ldr	r0, [sp, #4]
    996a:	f000 fad1 	bl	9f10 <FlexCAN_GetPayloadSize>
    996e:	4603      	mov	r3, r0
    9970:	f88d 3017 	strb.w	r3, [sp, #23]
        mb_size = (uint8)(payload_size + arbitration_field_size);
    9974:	f89d 2017 	ldrb.w	r2, [sp, #23]
    9978:	f89d 3020 	ldrb.w	r3, [sp, #32]
    997c:	4413      	add	r3, r2
    997e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        maxMbNum = (uint8)(ramBlockSize / mb_size);
    9982:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    9986:	9a07      	ldr	r2, [sp, #28]
    9988:	fbb2 f3f3 	udiv	r3, r2, r3
    998c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        if (maxMbNum > msgBuffIdxBackup)
    9990:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    9994:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    9998:	429a      	cmp	r2, r3
    999a:	d815      	bhi.n	99c8 <FlexCAN_GetMsgBuffRegion+0xb4>
        {
            break;
        }
        ramBlockOffset += 128U;
    999c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    99a0:	3380      	adds	r3, #128	; 0x80
    99a2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        msgBuffIdxBackup -= maxMbNum;
    99a6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    99aa:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    99ae:	1ad3      	subs	r3, r2, r3
    99b0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    99b4:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    99b8:	3301      	adds	r3, #1
    99ba:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    99be:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    99c2:	2b00      	cmp	r3, #0
    99c4:	d0cd      	beq.n	9962 <FlexCAN_GetMsgBuffRegion+0x4e>
    99c6:	e000      	b.n	99ca <FlexCAN_GetMsgBuffRegion+0xb6>
            break;
    99c8:	bf00      	nop
    }
    else
#endif
    {
        /* Multiply the MB index by the MB size (in words) */
        mb_index = (uint32)ramBlockOffset + (((uint32)msgBuffIdxBackup % (uint32)maxMbNum) * ((uint32)mb_size >> 2U));
    99ca:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
    99ce:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    99d2:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    99d6:	fbb3 f0f2 	udiv	r0, r3, r2
    99da:	fb00 f202 	mul.w	r2, r0, r2
    99de:	1a9b      	subs	r3, r3, r2
    99e0:	b2db      	uxtb	r3, r3
    99e2:	461a      	mov	r2, r3
    99e4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    99e8:	089b      	lsrs	r3, r3, #2
    99ea:	b2db      	uxtb	r3, r3
    99ec:	fb02 f303 	mul.w	r3, r2, r3
    99f0:	440b      	add	r3, r1
    99f2:	9306      	str	r3, [sp, #24]
        pAddressRet = &(RAM[mb_index]);
    99f4:	9b06      	ldr	r3, [sp, #24]
    99f6:	009b      	lsls	r3, r3, #2
    99f8:	9a04      	ldr	r2, [sp, #16]
    99fa:	4413      	add	r3, r2
    99fc:	9303      	str	r3, [sp, #12]
    }

    return pAddressRet;
    99fe:	9b03      	ldr	r3, [sp, #12]
}
    9a00:	4618      	mov	r0, r3
    9a02:	b00b      	add	sp, #44	; 0x2c
    9a04:	f85d fb04 	ldr.w	pc, [sp], #4

00009a08 <FlexCAN_GetMaxMbNum>:
 * Function Name : FlexCAN_GetMaxMbNum
 * Description   : Computes the maximum RAM size occupied by MBs.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMaxMbNum(const FLEXCAN_Type * base)
{
    9a08:	b084      	sub	sp, #16
    9a0a:	9001      	str	r0, [sp, #4]
    uint32 i, ret = 0u;
    9a0c:	2300      	movs	r3, #0
    9a0e:	9302      	str	r3, [sp, #8]
    static FLEXCAN_Type * const flexcanBase[] = IP_FLEXCAN_BASE_PTRS;
    static const uint32 maxMbNum[] = FLEXCAN_IP_FEATURE_MAX_MB_NUM_ARRAY;

    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    9a10:	2300      	movs	r3, #0
    9a12:	9303      	str	r3, [sp, #12]
    9a14:	e00e      	b.n	9a34 <FlexCAN_GetMaxMbNum+0x2c>
    {
        if (base == flexcanBase[i])
    9a16:	4a0b      	ldr	r2, [pc, #44]	; (9a44 <FlexCAN_GetMaxMbNum+0x3c>)
    9a18:	9b03      	ldr	r3, [sp, #12]
    9a1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1e:	9a01      	ldr	r2, [sp, #4]
    9a20:	429a      	cmp	r2, r3
    9a22:	d104      	bne.n	9a2e <FlexCAN_GetMaxMbNum+0x26>
        {
            ret = maxMbNum[i];
    9a24:	4a08      	ldr	r2, [pc, #32]	; (9a48 <FlexCAN_GetMaxMbNum+0x40>)
    9a26:	9b03      	ldr	r3, [sp, #12]
    9a28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a2c:	9302      	str	r3, [sp, #8]
    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    9a2e:	9b03      	ldr	r3, [sp, #12]
    9a30:	3301      	adds	r3, #1
    9a32:	9303      	str	r3, [sp, #12]
    9a34:	9b03      	ldr	r3, [sp, #12]
    9a36:	2b02      	cmp	r3, #2
    9a38:	d9ed      	bls.n	9a16 <FlexCAN_GetMaxMbNum+0xe>
        }
    }
    return ret;
    9a3a:	9b02      	ldr	r3, [sp, #8]
}
    9a3c:	4618      	mov	r0, r3
    9a3e:	b004      	add	sp, #16
    9a40:	4770      	bx	lr
    9a42:	bf00      	nop
    9a44:	0000c6a0 	.word	0x0000c6a0
    9a48:	0000c6ac 	.word	0x0000c6ac

00009a4c <FlexCAN_EnterFreezeMode>:
 * Function Name : FLEXCAN_EnterFreezeMode
 * Description   : Enter the freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnterFreezeMode(FLEXCAN_Type * base)
{
    9a4c:	b500      	push	{lr}
    9a4e:	b087      	sub	sp, #28
    9a50:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    9a52:	2300      	movs	r3, #0
    9a54:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9a56:	2300      	movs	r3, #0
    9a58:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9a5a:	2100      	movs	r1, #0
    9a5c:	4820      	ldr	r0, [pc, #128]	; (9ae0 <FlexCAN_EnterFreezeMode+0x94>)
    9a5e:	f7f7 fb36 	bl	10ce <OsIf_MicrosToTicks>
    9a62:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    9a64:	2300      	movs	r3, #0
    9a66:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    9a68:	f001 fa70 	bl	af4c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(1U);
    9a6c:	9b01      	ldr	r3, [sp, #4]
    9a6e:	681b      	ldr	r3, [r3, #0]
    9a70:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    9a74:	9b01      	ldr	r3, [sp, #4]
    9a76:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(1U);
    9a78:	9b01      	ldr	r3, [sp, #4]
    9a7a:	681b      	ldr	r3, [r3, #0]
    9a7c:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
    9a80:	9b01      	ldr	r3, [sp, #4]
    9a82:	601a      	str	r2, [r3, #0]
    if (((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U)
    9a84:	9b01      	ldr	r3, [sp, #4]
    9a86:	681b      	ldr	r3, [r3, #0]
    9a88:	2b00      	cmp	r3, #0
    9a8a:	da05      	bge.n	9a98 <FlexCAN_EnterFreezeMode+0x4c>
    {
        base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    9a8c:	9b01      	ldr	r3, [sp, #4]
    9a8e:	681b      	ldr	r3, [r3, #0]
    9a90:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    9a94:	9b01      	ldr	r3, [sp, #4]
    9a96:	601a      	str	r2, [r3, #0]
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    9a98:	f001 fa84 	bl	afa4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9a9c:	2000      	movs	r0, #0
    9a9e:	f7f7 faca 	bl	1036 <OsIf_GetCounter>
    9aa2:	4603      	mov	r3, r0
    9aa4:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    9aa6:	e00f      	b.n	9ac8 <FlexCAN_EnterFreezeMode+0x7c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9aa8:	ab02      	add	r3, sp, #8
    9aaa:	2100      	movs	r1, #0
    9aac:	4618      	mov	r0, r3
    9aae:	f7f7 fadb 	bl	1068 <OsIf_GetElapsed>
    9ab2:	4602      	mov	r2, r0
    9ab4:	9b05      	ldr	r3, [sp, #20]
    9ab6:	4413      	add	r3, r2
    9ab8:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    9aba:	9a05      	ldr	r2, [sp, #20]
    9abc:	9b03      	ldr	r3, [sp, #12]
    9abe:	429a      	cmp	r2, r3
    9ac0:	d302      	bcc.n	9ac8 <FlexCAN_EnterFreezeMode+0x7c>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    9ac2:	2303      	movs	r3, #3
    9ac4:	9304      	str	r3, [sp, #16]
            break;
    9ac6:	e005      	b.n	9ad4 <FlexCAN_EnterFreezeMode+0x88>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    9ac8:	9b01      	ldr	r3, [sp, #4]
    9aca:	681b      	ldr	r3, [r3, #0]
    9acc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    9ad0:	2b00      	cmp	r3, #0
    9ad2:	d0e9      	beq.n	9aa8 <FlexCAN_EnterFreezeMode+0x5c>
        }
    }

    return returnResult;
    9ad4:	9b04      	ldr	r3, [sp, #16]
}
    9ad6:	4618      	mov	r0, r3
    9ad8:	b007      	add	sp, #28
    9ada:	f85d fb04 	ldr.w	pc, [sp], #4
    9ade:	bf00      	nop
    9ae0:	000f4240 	.word	0x000f4240

00009ae4 <FlexCAN_Enable>:
 * Function Name : FlexCAN_Enable
 * Description   : Enable the clock for FlexCAN Module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Enable(FLEXCAN_Type * base)
{
    9ae4:	b500      	push	{lr}
    9ae6:	b087      	sub	sp, #28
    9ae8:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    9aea:	2300      	movs	r3, #0
    9aec:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9aee:	2300      	movs	r3, #0
    9af0:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9af2:	2100      	movs	r1, #0
    9af4:	4818      	ldr	r0, [pc, #96]	; (9b58 <FlexCAN_Enable+0x74>)
    9af6:	f7f7 faea 	bl	10ce <OsIf_MicrosToTicks>
    9afa:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    9afc:	2300      	movs	r3, #0
    9afe:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    9b00:	f001 fa76 	bl	aff0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>

    /* Enable Module */
    base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    9b04:	9b01      	ldr	r3, [sp, #4]
    9b06:	681b      	ldr	r3, [r3, #0]
    9b08:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    9b0c:	9b01      	ldr	r3, [sp, #4]
    9b0e:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    9b10:	f001 fa9a 	bl	b048 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9b14:	2000      	movs	r0, #0
    9b16:	f7f7 fa8e 	bl	1036 <OsIf_GetCounter>
    9b1a:	4603      	mov	r3, r0
    9b1c:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    9b1e:	e00f      	b.n	9b40 <FlexCAN_Enable+0x5c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9b20:	ab02      	add	r3, sp, #8
    9b22:	2100      	movs	r1, #0
    9b24:	4618      	mov	r0, r3
    9b26:	f7f7 fa9f 	bl	1068 <OsIf_GetElapsed>
    9b2a:	4602      	mov	r2, r0
    9b2c:	9b05      	ldr	r3, [sp, #20]
    9b2e:	4413      	add	r3, r2
    9b30:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    9b32:	9a05      	ldr	r2, [sp, #20]
    9b34:	9b03      	ldr	r3, [sp, #12]
    9b36:	429a      	cmp	r2, r3
    9b38:	d302      	bcc.n	9b40 <FlexCAN_Enable+0x5c>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    9b3a:	2303      	movs	r3, #3
    9b3c:	9304      	str	r3, [sp, #16]
            break;
    9b3e:	e005      	b.n	9b4c <FlexCAN_Enable+0x68>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    9b40:	9b01      	ldr	r3, [sp, #4]
    9b42:	681b      	ldr	r3, [r3, #0]
    9b44:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    9b48:	2b00      	cmp	r3, #0
    9b4a:	d0e9      	beq.n	9b20 <FlexCAN_Enable+0x3c>
        }
    }
    return returnValue;
    9b4c:	9b04      	ldr	r3, [sp, #16]
}
    9b4e:	4618      	mov	r0, r3
    9b50:	b007      	add	sp, #28
    9b52:	f85d fb04 	ldr.w	pc, [sp], #4
    9b56:	bf00      	nop
    9b58:	000f4240 	.word	0x000f4240

00009b5c <FlexCAN_ExitFreezeMode>:
 * Function Name : FLEXCAN_ExitFreezeMode
 * Description   : Exit of freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_ExitFreezeMode(FLEXCAN_Type * base)
{
    9b5c:	b500      	push	{lr}
    9b5e:	b087      	sub	sp, #28
    9b60:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    9b62:	2300      	movs	r3, #0
    9b64:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9b66:	2300      	movs	r3, #0
    9b68:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9b6a:	2100      	movs	r1, #0
    9b6c:	481b      	ldr	r0, [pc, #108]	; (9bdc <FlexCAN_ExitFreezeMode+0x80>)
    9b6e:	f7f7 faae 	bl	10ce <OsIf_MicrosToTicks>
    9b72:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    9b74:	2300      	movs	r3, #0
    9b76:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    9b78:	f001 fa8c 	bl	b094 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(0U);
    9b7c:	9b01      	ldr	r3, [sp, #4]
    9b7e:	681b      	ldr	r3, [r3, #0]
    9b80:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
    9b84:	9b01      	ldr	r3, [sp, #4]
    9b86:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(0U);
    9b88:	9b01      	ldr	r3, [sp, #4]
    9b8a:	681b      	ldr	r3, [r3, #0]
    9b8c:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    9b90:	9b01      	ldr	r3, [sp, #4]
    9b92:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    9b94:	f001 faaa 	bl	b0ec <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    /* Wait till exit freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9b98:	2000      	movs	r0, #0
    9b9a:	f7f7 fa4c 	bl	1036 <OsIf_GetCounter>
    9b9e:	4603      	mov	r3, r0
    9ba0:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    9ba2:	e00f      	b.n	9bc4 <FlexCAN_ExitFreezeMode+0x68>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9ba4:	ab02      	add	r3, sp, #8
    9ba6:	2100      	movs	r1, #0
    9ba8:	4618      	mov	r0, r3
    9baa:	f7f7 fa5d 	bl	1068 <OsIf_GetElapsed>
    9bae:	4602      	mov	r2, r0
    9bb0:	9b05      	ldr	r3, [sp, #20]
    9bb2:	4413      	add	r3, r2
    9bb4:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    9bb6:	9a05      	ldr	r2, [sp, #20]
    9bb8:	9b03      	ldr	r3, [sp, #12]
    9bba:	429a      	cmp	r2, r3
    9bbc:	d302      	bcc.n	9bc4 <FlexCAN_ExitFreezeMode+0x68>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    9bbe:	2303      	movs	r3, #3
    9bc0:	9304      	str	r3, [sp, #16]
            break;
    9bc2:	e005      	b.n	9bd0 <FlexCAN_ExitFreezeMode+0x74>
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    9bc4:	9b01      	ldr	r3, [sp, #4]
    9bc6:	681b      	ldr	r3, [r3, #0]
    9bc8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    9bcc:	2b00      	cmp	r3, #0
    9bce:	d1e9      	bne.n	9ba4 <FlexCAN_ExitFreezeMode+0x48>
        }
    }
    return returnValue;
    9bd0:	9b04      	ldr	r3, [sp, #16]
}
    9bd2:	4618      	mov	r0, r3
    9bd4:	b007      	add	sp, #28
    9bd6:	f85d fb04 	ldr.w	pc, [sp], #4
    9bda:	bf00      	nop
    9bdc:	000f4240 	.word	0x000f4240

00009be0 <FlexCAN_Disable>:
 * Description   : Disable FlexCAN module.
 * This function will disable FlexCAN module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Disable(FLEXCAN_Type * base)
{
    9be0:	b500      	push	{lr}
    9be2:	b087      	sub	sp, #28
    9be4:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    9be6:	2300      	movs	r3, #0
    9be8:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9bea:	2300      	movs	r3, #0
    9bec:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9bee:	2100      	movs	r1, #0
    9bf0:	481a      	ldr	r0, [pc, #104]	; (9c5c <FlexCAN_Disable+0x7c>)
    9bf2:	f7f7 fa6c 	bl	10ce <OsIf_MicrosToTicks>
    9bf6:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    9bf8:	2300      	movs	r3, #0
    9bfa:	9304      	str	r3, [sp, #16]

    /* To access the memory mapped registers */
    /* Enter disable mode (hard reset). */
    if (0U == ((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT))
    9bfc:	9b01      	ldr	r3, [sp, #4]
    9bfe:	681b      	ldr	r3, [r3, #0]
    9c00:	2b00      	cmp	r3, #0
    9c02:	db25      	blt.n	9c50 <FlexCAN_Disable+0x70>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    9c04:	f001 fa98 	bl	b138 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Clock disable (module) */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MDIS_MASK) | FLEXCAN_MCR_MDIS(1U);
    9c08:	9b01      	ldr	r3, [sp, #4]
    9c0a:	681b      	ldr	r3, [r3, #0]
    9c0c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    9c10:	9b01      	ldr	r3, [sp, #4]
    9c12:	601a      	str	r2, [r3, #0]
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    9c14:	f001 fabc 	bl	b190 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Wait until disable mode acknowledged */
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9c18:	2000      	movs	r0, #0
    9c1a:	f7f7 fa0c 	bl	1036 <OsIf_GetCounter>
    9c1e:	4603      	mov	r3, r0
    9c20:	9302      	str	r3, [sp, #8]
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    9c22:	e00f      	b.n	9c44 <FlexCAN_Disable+0x64>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9c24:	ab02      	add	r3, sp, #8
    9c26:	2100      	movs	r1, #0
    9c28:	4618      	mov	r0, r3
    9c2a:	f7f7 fa1d 	bl	1068 <OsIf_GetElapsed>
    9c2e:	4602      	mov	r2, r0
    9c30:	9b05      	ldr	r3, [sp, #20]
    9c32:	4413      	add	r3, r2
    9c34:	9305      	str	r3, [sp, #20]
            if (timeElapsed >= uS2Ticks)
    9c36:	9a05      	ldr	r2, [sp, #20]
    9c38:	9b03      	ldr	r3, [sp, #12]
    9c3a:	429a      	cmp	r2, r3
    9c3c:	d302      	bcc.n	9c44 <FlexCAN_Disable+0x64>
            {
                returnResult = FLEXCAN_STATUS_TIMEOUT;
    9c3e:	2303      	movs	r3, #3
    9c40:	9304      	str	r3, [sp, #16]
                break;
    9c42:	e005      	b.n	9c50 <FlexCAN_Disable+0x70>
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    9c44:	9b01      	ldr	r3, [sp, #4]
    9c46:	681b      	ldr	r3, [r3, #0]
    9c48:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    9c4c:	2b00      	cmp	r3, #0
    9c4e:	d0e9      	beq.n	9c24 <FlexCAN_Disable+0x44>
            }
        }
    }
    return returnResult;
    9c50:	9b04      	ldr	r3, [sp, #16]
}
    9c52:	4618      	mov	r0, r3
    9c54:	b007      	add	sp, #28
    9c56:	f85d fb04 	ldr.w	pc, [sp], #4
    9c5a:	bf00      	nop
    9c5c:	000f4240 	.word	0x000f4240

00009c60 <FlexCAN_SetErrIntCmd>:
 * Description   : Enable the error interrupts.
 * This function will enable Error interrupt.
 *
 *END**************************************************************************/
void FlexCAN_SetErrIntCmd(FLEXCAN_Type * base, flexcan_int_type_t errType, boolean enable)
{
    9c60:	b500      	push	{lr}
    9c62:	b087      	sub	sp, #28
    9c64:	9003      	str	r0, [sp, #12]
    9c66:	9102      	str	r1, [sp, #8]
    9c68:	4613      	mov	r3, r2
    9c6a:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 temp = (uint32)errType;
    9c6e:	9b02      	ldr	r3, [sp, #8]
    9c70:	9305      	str	r3, [sp, #20]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    9c72:	f001 fab3 	bl	b1dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
    if (enable)
    9c76:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9c7a:	2b00      	cmp	r3, #0
    9c7c:	d020      	beq.n	9cc0 <FlexCAN_SetErrIntCmd+0x60>
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    9c7e:	9b02      	ldr	r3, [sp, #8]
    9c80:	f244 0201 	movw	r2, #16385	; 0x4001
    9c84:	4293      	cmp	r3, r2
    9c86:	d106      	bne.n	9c96 <FlexCAN_SetErrIntCmd+0x36>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(1U);
    9c88:	9b03      	ldr	r3, [sp, #12]
    9c8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9c8c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    9c90:	9b03      	ldr	r3, [sp, #12]
    9c92:	635a      	str	r2, [r3, #52]	; 0x34
    9c94:	e03a      	b.n	9d0c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            if ((FLEXCAN_INT_RX_WARNING == errType) || (FLEXCAN_INT_TX_WARNING == errType))
    9c96:	9b02      	ldr	r3, [sp, #8]
    9c98:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    9c9c:	d003      	beq.n	9ca6 <FlexCAN_SetErrIntCmd+0x46>
    9c9e:	9b02      	ldr	r3, [sp, #8]
    9ca0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    9ca4:	d105      	bne.n	9cb2 <FlexCAN_SetErrIntCmd+0x52>
            {
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(1U);
    9ca6:	9b03      	ldr	r3, [sp, #12]
    9ca8:	681b      	ldr	r3, [r3, #0]
    9caa:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    9cae:	9b03      	ldr	r3, [sp, #12]
    9cb0:	601a      	str	r2, [r3, #0]
            }
            (base->CTRL1) = ((base->CTRL1) | (temp));
    9cb2:	9b03      	ldr	r3, [sp, #12]
    9cb4:	685a      	ldr	r2, [r3, #4]
    9cb6:	9b05      	ldr	r3, [sp, #20]
    9cb8:	431a      	orrs	r2, r3
    9cba:	9b03      	ldr	r3, [sp, #12]
    9cbc:	605a      	str	r2, [r3, #4]
    9cbe:	e025      	b.n	9d0c <FlexCAN_SetErrIntCmd+0xac>
        }
    }
    else
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    9cc0:	9b02      	ldr	r3, [sp, #8]
    9cc2:	f244 0201 	movw	r2, #16385	; 0x4001
    9cc6:	4293      	cmp	r3, r2
    9cc8:	d106      	bne.n	9cd8 <FlexCAN_SetErrIntCmd+0x78>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(0U);
    9cca:	9b03      	ldr	r3, [sp, #12]
    9ccc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9cce:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    9cd2:	9b03      	ldr	r3, [sp, #12]
    9cd4:	635a      	str	r2, [r3, #52]	; 0x34
    9cd6:	e019      	b.n	9d0c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            (base->CTRL1) = ((base->CTRL1) & ~(temp));
    9cd8:	9b03      	ldr	r3, [sp, #12]
    9cda:	685a      	ldr	r2, [r3, #4]
    9cdc:	9b05      	ldr	r3, [sp, #20]
    9cde:	43db      	mvns	r3, r3
    9ce0:	401a      	ands	r2, r3
    9ce2:	9b03      	ldr	r3, [sp, #12]
    9ce4:	605a      	str	r2, [r3, #4]
            temp = base->CTRL1;
    9ce6:	9b03      	ldr	r3, [sp, #12]
    9ce8:	685b      	ldr	r3, [r3, #4]
    9cea:	9305      	str	r3, [sp, #20]
            if ((0U == (temp & (uint32)FLEXCAN_INT_RX_WARNING)) && (0U == (temp & (uint32)FLEXCAN_INT_TX_WARNING)))
    9cec:	9b05      	ldr	r3, [sp, #20]
    9cee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    9cf2:	2b00      	cmp	r3, #0
    9cf4:	d10a      	bne.n	9d0c <FlexCAN_SetErrIntCmd+0xac>
    9cf6:	9b05      	ldr	r3, [sp, #20]
    9cf8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    9cfc:	2b00      	cmp	r3, #0
    9cfe:	d105      	bne.n	9d0c <FlexCAN_SetErrIntCmd+0xac>
            {
                /* If WRNEN disabled then both FLEXCAN_INT_RX_WARNING and FLEXCAN_INT_TX_WARNING will be disabled */
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(0U);
    9d00:	9b03      	ldr	r3, [sp, #12]
    9d02:	681b      	ldr	r3, [r3, #0]
    9d04:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
    9d08:	9b03      	ldr	r3, [sp, #12]
    9d0a:	601a      	str	r2, [r3, #0]
            }
        }
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    9d0c:	f001 fa92 	bl	b234 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
}
    9d10:	bf00      	nop
    9d12:	b007      	add	sp, #28
    9d14:	f85d fb04 	ldr.w	pc, [sp], #4

00009d18 <FlexCAN_Init>:
 * buffers, initialize all message buffers as inactive, enable RX FIFO
 * if needed, mask all mask bits, and disable all MB interrupts.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Init(FLEXCAN_Type * base)
{
    9d18:	b500      	push	{lr}
    9d1a:	b087      	sub	sp, #28
    9d1c:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    9d1e:	2300      	movs	r3, #0
    9d20:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    9d22:	2300      	movs	r3, #0
    9d24:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9d26:	2100      	movs	r1, #0
    9d28:	4833      	ldr	r0, [pc, #204]	; (9df8 <FlexCAN_Init+0xe0>)
    9d2a:	f7f7 f9d0 	bl	10ce <OsIf_MicrosToTicks>
    9d2e:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    9d30:	2300      	movs	r3, #0
    9d32:	9304      	str	r3, [sp, #16]

    /* Reset the FLEXCAN */
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SOFTRST_MASK) | FLEXCAN_MCR_SOFTRST(1U);
    9d34:	9b01      	ldr	r3, [sp, #4]
    9d36:	681b      	ldr	r3, [r3, #0]
    9d38:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    9d3c:	9b01      	ldr	r3, [sp, #4]
    9d3e:	601a      	str	r2, [r3, #0]
    /* Wait for reset cycle to complete */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9d40:	2000      	movs	r0, #0
    9d42:	f7f7 f978 	bl	1036 <OsIf_GetCounter>
    9d46:	4603      	mov	r3, r0
    9d48:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    9d4a:	e00f      	b.n	9d6c <FlexCAN_Init+0x54>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    9d4c:	ab02      	add	r3, sp, #8
    9d4e:	2100      	movs	r1, #0
    9d50:	4618      	mov	r0, r3
    9d52:	f7f7 f989 	bl	1068 <OsIf_GetElapsed>
    9d56:	4602      	mov	r2, r0
    9d58:	9b05      	ldr	r3, [sp, #20]
    9d5a:	4413      	add	r3, r2
    9d5c:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    9d5e:	9a05      	ldr	r2, [sp, #20]
    9d60:	9b03      	ldr	r3, [sp, #12]
    9d62:	429a      	cmp	r2, r3
    9d64:	d302      	bcc.n	9d6c <FlexCAN_Init+0x54>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    9d66:	2303      	movs	r3, #3
    9d68:	9304      	str	r3, [sp, #16]
            break;
    9d6a:	e005      	b.n	9d78 <FlexCAN_Init+0x60>
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    9d6c:	9b01      	ldr	r3, [sp, #4]
    9d6e:	681b      	ldr	r3, [r3, #0]
    9d70:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    9d74:	2b00      	cmp	r3, #0
    9d76:	d1e9      	bne.n	9d4c <FlexCAN_Init+0x34>
        }
    }
    if (FLEXCAN_STATUS_SUCCESS == returnResult)
    9d78:	9b04      	ldr	r3, [sp, #16]
    9d7a:	2b00      	cmp	r3, #0
    9d7c:	d136      	bne.n	9dec <FlexCAN_Init+0xd4>
    {
        /* Avoid Abort Transmission, use Inactive MB */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_AEN_MASK) | FLEXCAN_MCR_AEN(1U);
    9d7e:	9b01      	ldr	r3, [sp, #4]
    9d80:	681b      	ldr	r3, [r3, #0]
    9d82:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    9d86:	9b01      	ldr	r3, [sp, #4]
    9d88:	601a      	str	r2, [r3, #0]
        /* Clear FlexCAN memory */
        FlexCAN_ClearRAM(base);
    9d8a:	9801      	ldr	r0, [sp, #4]
    9d8c:	f7ff fd40 	bl	9810 <FlexCAN_ClearRAM>
        /* Rx global mask*/
        (base->RXMGMASK) = (uint32)(FLEXCAN_RXMGMASK_MG_MASK);
    9d90:	9b01      	ldr	r3, [sp, #4]
    9d92:	f04f 32ff 	mov.w	r2, #4294967295
    9d96:	611a      	str	r2, [r3, #16]
        /* Rx reg 14 mask*/
        (base->RX14MASK) =  (uint32)(FLEXCAN_RX14MASK_RX14M_MASK);
    9d98:	9b01      	ldr	r3, [sp, #4]
    9d9a:	f04f 32ff 	mov.w	r2, #4294967295
    9d9e:	615a      	str	r2, [r3, #20]
        /* Rx reg 15 mask*/
        (base->RX15MASK) = (uint32)(FLEXCAN_RX15MASK_RX15M_MASK);
    9da0:	9b01      	ldr	r3, [sp, #4]
    9da2:	f04f 32ff 	mov.w	r2, #4294967295
    9da6:	619a      	str	r2, [r3, #24]
        /* Disable all MB interrupts */
        (base->IMASK1) = 0x0;
    9da8:	9b01      	ldr	r3, [sp, #4]
    9daa:	2200      	movs	r2, #0
    9dac:	629a      	str	r2, [r3, #40]	; 0x28
        /* Clear all MB interrupt flags */
        (base->IFLAG1) = FLEXCAN_IMASK1_BUF31TO0M_MASK;
    9dae:	9b01      	ldr	r3, [sp, #4]
    9db0:	f04f 32ff 	mov.w	r2, #4294967295
    9db4:	631a      	str	r2, [r3, #48]	; 0x30
            (base->IMASK4) = 0x0;
            (base->IFLAG4) = FLEXCAN_IMASK4_BUF127TO96M_MASK;
        }
#endif
        /* Clear all error interrupt flags */
        (base->ESR1) = FLEXCAN_IP_ALL_INT;
    9db6:	9b01      	ldr	r3, [sp, #4]
    9db8:	4a10      	ldr	r2, [pc, #64]	; (9dfc <FlexCAN_Init+0xe4>)
    9dba:	621a      	str	r2, [r3, #32]
        /* clear registers which are not effected by soft reset */
        base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    9dbc:	9b01      	ldr	r3, [sp, #4]
    9dbe:	2200      	movs	r2, #0
    9dc0:	605a      	str	r2, [r3, #4]
        base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    9dc2:	9b01      	ldr	r3, [sp, #4]
    9dc4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    9dc8:	635a      	str	r2, [r3, #52]	; 0x34
        base->CBT   = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    9dca:	9b01      	ldr	r3, [sp, #4]
    9dcc:	2200      	movs	r2, #0
    9dce:	651a      	str	r2, [r3, #80]	; 0x50
        base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
        base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    9dd0:	9801      	ldr	r0, [sp, #4]
    9dd2:	f000 f85b 	bl	9e8c <FlexCAN_IsFDAvailable>
    9dd6:	4603      	mov	r3, r0
    9dd8:	2b00      	cmp	r3, #0
    9dda:	d007      	beq.n	9dec <FlexCAN_Init+0xd4>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    9ddc:	9b01      	ldr	r3, [sp, #4]
    9dde:	2200      	movs	r2, #0
    9de0:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    9de4:	9b01      	ldr	r3, [sp, #4]
    9de6:	4a06      	ldr	r2, [pc, #24]	; (9e00 <FlexCAN_Init+0xe8>)
    9de8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    #if defined(CAN_FEATURE_S32K1XX)
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
#endif /* (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON) */
    }
    return returnResult;
    9dec:	9b04      	ldr	r3, [sp, #16]
}
    9dee:	4618      	mov	r0, r3
    9df0:	b007      	add	sp, #28
    9df2:	f85d fb04 	ldr.w	pc, [sp], #4
    9df6:	bf00      	nop
    9df8:	000f4240 	.word	0x000f4240
    9dfc:	003b0006 	.word	0x003b0006
    9e00:	80004100 	.word	0x80004100

00009e04 <FlexCAN_EnableRxFifo>:
 * This function will enable the Rx FIFO feature.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnableRxFifo(FLEXCAN_Type * base,
                                         uint32 numOfFilters)
{
    9e04:	b500      	push	{lr}
    9e06:	b087      	sub	sp, #28
    9e08:	9001      	str	r0, [sp, #4]
    9e0a:	9100      	str	r1, [sp, #0]
    uint32 i;
    uint16 noOfMbx = (uint16)FlexCAN_GetMaxMbNum(base);
    9e0c:	9801      	ldr	r0, [sp, #4]
    9e0e:	f7ff fdfb 	bl	9a08 <FlexCAN_GetMaxMbNum>
    9e12:	4603      	mov	r3, r0
    9e14:	f8ad 300e 	strh.w	r3, [sp, #14]
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    9e18:	2300      	movs	r3, #0
    9e1a:	9304      	str	r3, [sp, #16]

    /* RxFIFO cannot be enabled if FD is enabled */
    if (((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U)
    9e1c:	9b01      	ldr	r3, [sp, #4]
    9e1e:	681b      	ldr	r3, [r3, #0]
    9e20:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    9e24:	2b00      	cmp	r3, #0
    9e26:	d001      	beq.n	9e2c <FlexCAN_EnableRxFifo+0x28>
    {
        stat = FLEXCAN_STATUS_ERROR;
    9e28:	2301      	movs	r3, #1
    9e2a:	9304      	str	r3, [sp, #16]
    }
    if (FLEXCAN_STATUS_SUCCESS == stat)
    9e2c:	9b04      	ldr	r3, [sp, #16]
    9e2e:	2b00      	cmp	r3, #0
    9e30:	d127      	bne.n	9e82 <FlexCAN_EnableRxFifo+0x7e>
    {
        /* Enable RX FIFO */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_RFEN_MASK) | FLEXCAN_MCR_RFEN(1U);
    9e32:	9b01      	ldr	r3, [sp, #4]
    9e34:	681b      	ldr	r3, [r3, #0]
    9e36:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
    9e3a:	9b01      	ldr	r3, [sp, #4]
    9e3c:	601a      	str	r2, [r3, #0]
        /* Set the number of the RX FIFO filters needed */
        base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RFFN_MASK) | ((numOfFilters << FLEXCAN_CTRL2_RFFN_SHIFT) & FLEXCAN_CTRL2_RFFN_MASK);
    9e3e:	9b01      	ldr	r3, [sp, #4]
    9e40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    9e42:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    9e46:	9b00      	ldr	r3, [sp, #0]
    9e48:	061b      	lsls	r3, r3, #24
    9e4a:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    9e4e:	431a      	orrs	r2, r3
    9e50:	9b01      	ldr	r3, [sp, #4]
    9e52:	635a      	str	r2, [r3, #52]	; 0x34
        /* RX FIFO global mask, take in consideration all filter fields*/
        (base->RXFGMASK) = FLEXCAN_RXFGMASK_FGM_MASK;
    9e54:	9b01      	ldr	r3, [sp, #4]
    9e56:	f04f 32ff 	mov.w	r2, #4294967295
    9e5a:	649a      	str	r2, [r3, #72]	; 0x48

        for (i = 0U; i < noOfMbx; i++)
    9e5c:	2300      	movs	r3, #0
    9e5e:	9305      	str	r3, [sp, #20]
    9e60:	e00a      	b.n	9e78 <FlexCAN_EnableRxFifo+0x74>
        {
            /* RX individual mask */
            base->RXIMR[i] = (FLEXCAN_RXIMR_MI_MASK << FLEXCAN_IP_ID_EXT_SHIFT) & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    9e62:	9b01      	ldr	r3, [sp, #4]
    9e64:	9a05      	ldr	r2, [sp, #20]
    9e66:	f502 7208 	add.w	r2, r2, #544	; 0x220
    9e6a:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    9e6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0U; i < noOfMbx; i++)
    9e72:	9b05      	ldr	r3, [sp, #20]
    9e74:	3301      	adds	r3, #1
    9e76:	9305      	str	r3, [sp, #20]
    9e78:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    9e7c:	9a05      	ldr	r2, [sp, #20]
    9e7e:	429a      	cmp	r2, r3
    9e80:	d3ef      	bcc.n	9e62 <FlexCAN_EnableRxFifo+0x5e>
        }
    }
    return stat;
    9e82:	9b04      	ldr	r3, [sp, #16]
}
    9e84:	4618      	mov	r0, r3
    9e86:	b007      	add	sp, #28
    9e88:	f85d fb04 	ldr.w	pc, [sp], #4

00009e8c <FlexCAN_IsFDAvailable>:
 * Description   : Checks if FlexCAN has FD Support.
 * This function is private.
 *
 *END**************************************************************************/
boolean FlexCAN_IsFDAvailable(const FLEXCAN_Type * base)
{
    9e8c:	b084      	sub	sp, #16
    9e8e:	9001      	str	r0, [sp, #4]
    uint32 i=0U;
    9e90:	2300      	movs	r3, #0
    9e92:	9303      	str	r3, [sp, #12]
    static FLEXCAN_Type * const flexcanBase[] = CAN_BASE_PTRS_HAS_FD;
    boolean returnValue = FALSE;
    9e94:	2300      	movs	r3, #0
    9e96:	f88d 300b 	strb.w	r3, [sp, #11]
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    9e9a:	2300      	movs	r3, #0
    9e9c:	9303      	str	r3, [sp, #12]
    9e9e:	e00d      	b.n	9ebc <FlexCAN_IsFDAvailable+0x30>
    {
        if (base == flexcanBase[i])
    9ea0:	4a0a      	ldr	r2, [pc, #40]	; (9ecc <FlexCAN_IsFDAvailable+0x40>)
    9ea2:	9b03      	ldr	r3, [sp, #12]
    9ea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ea8:	9a01      	ldr	r2, [sp, #4]
    9eaa:	429a      	cmp	r2, r3
    9eac:	d103      	bne.n	9eb6 <FlexCAN_IsFDAvailable+0x2a>
        {
            returnValue = TRUE;
    9eae:	2301      	movs	r3, #1
    9eb0:	f88d 300b 	strb.w	r3, [sp, #11]
            break;
    9eb4:	e005      	b.n	9ec2 <FlexCAN_IsFDAvailable+0x36>
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    9eb6:	9b03      	ldr	r3, [sp, #12]
    9eb8:	3301      	adds	r3, #1
    9eba:	9303      	str	r3, [sp, #12]
    9ebc:	9b03      	ldr	r3, [sp, #12]
    9ebe:	2b00      	cmp	r3, #0
    9ec0:	d0ee      	beq.n	9ea0 <FlexCAN_IsFDAvailable+0x14>
        }
    }

    return returnValue;
    9ec2:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    9ec6:	4618      	mov	r0, r3
    9ec8:	b004      	add	sp, #16
    9eca:	4770      	bx	lr
    9ecc:	0000c6b8 	.word	0x0000c6b8

00009ed0 <FlexCAN_SetPayloadSize>:
 * Description   : Sets the payload size of the MBs.
 *
 *END**************************************************************************/
void FlexCAN_SetPayloadSize(FLEXCAN_Type * base,
                            const Flexcan_Ip_PayloadSizeType * payloadSize)
{
    9ed0:	b500      	push	{lr}
    9ed2:	b085      	sub	sp, #20
    9ed4:	9001      	str	r0, [sp, #4]
    9ed6:	9100      	str	r1, [sp, #0]
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
    DevAssert(FlexCAN_IsFDEnabled(base) || (FLEXCAN_PAYLOAD_SIZE_8 == payloadSize->payloadBlock3));
    #endif
#endif
    /* If FD is not enabled, only 8 bytes payload is supported */
    if (FlexCAN_IsFDEnabled(base))
    9ed8:	9801      	ldr	r0, [sp, #4]
    9eda:	f7ff fbd6 	bl	968a <FlexCAN_IsFDEnabled>
    9ede:	4603      	mov	r3, r0
    9ee0:	2b00      	cmp	r3, #0
    9ee2:	d011      	beq.n	9f08 <FlexCAN_SetPayloadSize+0x38>
    {
        tmp = base->FDCTRL;
    9ee4:	9b01      	ldr	r3, [sp, #4]
    9ee6:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9eea:	9303      	str	r3, [sp, #12]
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR0_MASK);
    9eec:	9b03      	ldr	r3, [sp, #12]
    9eee:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    9ef2:	9303      	str	r3, [sp, #12]
        tmp |= ((uint32)payloadSize->payloadBlock0) << FLEXCAN_FDCTRL_MBDSR0_SHIFT;
    9ef4:	9b00      	ldr	r3, [sp, #0]
    9ef6:	681b      	ldr	r3, [r3, #0]
    9ef8:	041b      	lsls	r3, r3, #16
    9efa:	9a03      	ldr	r2, [sp, #12]
    9efc:	4313      	orrs	r3, r2
    9efe:	9303      	str	r3, [sp, #12]
#endif
#if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR3_MASK);
        tmp |= ((uint32)payloadSize->payloadBlock3) << FLEXCAN_FDCTRL_MBDSR3_SHIFT;
#endif
        base->FDCTRL = tmp;
    9f00:	9b01      	ldr	r3, [sp, #4]
    9f02:	9a03      	ldr	r2, [sp, #12]
    9f04:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
}
    9f08:	bf00      	nop
    9f0a:	b005      	add	sp, #20
    9f0c:	f85d fb04 	ldr.w	pc, [sp], #4

00009f10 <FlexCAN_GetPayloadSize>:
 * Function Name : FLEXCAN_GetPayloadSize
 * Description   : Returns the payload size of the MBs (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_GetPayloadSize(const FLEXCAN_Type * base, uint8 mbdsrIdx)
{
    9f10:	b500      	push	{lr}
    9f12:	b085      	sub	sp, #20
    9f14:	9001      	str	r0, [sp, #4]
    9f16:	460b      	mov	r3, r1
    9f18:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 payloadSize = 0U;
    9f1c:	2300      	movs	r3, #0
    9f1e:	9303      	str	r3, [sp, #12]

#if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    9f20:	9801      	ldr	r0, [sp, #4]
    9f22:	f7ff ffb3 	bl	9e8c <FlexCAN_IsFDAvailable>
    9f26:	4603      	mov	r3, r0
    9f28:	2b00      	cmp	r3, #0
    9f2a:	d019      	beq.n	9f60 <FlexCAN_GetPayloadSize+0x50>
    {
#endif /* defined(CAN_FEATURE_S32K1XX) */
    switch (mbdsrIdx)
    9f2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9f30:	2b00      	cmp	r3, #0
    9f32:	d10a      	bne.n	9f4a <FlexCAN_GetPayloadSize+0x3a>
    {
        case 0 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    9f34:	9b01      	ldr	r3, [sp, #4]
    9f36:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9f3a:	0c1b      	lsrs	r3, r3, #16
    9f3c:	f003 0303 	and.w	r3, r3, #3
    9f40:	2208      	movs	r2, #8
    9f42:	fa02 f303 	lsl.w	r3, r2, r3
    9f46:	9303      	str	r3, [sp, #12]
    9f48:	e00c      	b.n	9f64 <FlexCAN_GetPayloadSize+0x54>
        case 2 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR2_MASK) >> FLEXCAN_FDCTRL_MBDSR2_SHIFT); } break;
    #endif
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        case 3 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR3_MASK) >> FLEXCAN_FDCTRL_MBDSR3_SHIFT); } break;
    #endif
        default :{  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    9f4a:	9b01      	ldr	r3, [sp, #4]
    9f4c:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9f50:	0c1b      	lsrs	r3, r3, #16
    9f52:	f003 0303 	and.w	r3, r3, #3
    9f56:	2208      	movs	r2, #8
    9f58:	fa02 f303 	lsl.w	r3, r2, r3
    9f5c:	9303      	str	r3, [sp, #12]
    9f5e:	e001      	b.n	9f64 <FlexCAN_GetPayloadSize+0x54>
    }
    #if defined(CAN_FEATURE_S32K1XX)
    }
    else
    {
        payloadSize = 8U;
    9f60:	2308      	movs	r3, #8
    9f62:	9303      	str	r3, [sp, #12]
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
    return (uint8)payloadSize;
    9f64:	9b03      	ldr	r3, [sp, #12]
    9f66:	b2db      	uxtb	r3, r3
}
    9f68:	4618      	mov	r0, r3
    9f6a:	b005      	add	sp, #20
    9f6c:	f85d fb04 	ldr.w	pc, [sp], #4

00009f70 <FlexCAN_GetMbPayloadSize>:



uint8 FlexCAN_GetMbPayloadSize(const FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    9f70:	b500      	push	{lr}
    9f72:	b087      	sub	sp, #28
    9f74:	9001      	str	r0, [sp, #4]
    9f76:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    9f78:	2308      	movs	r3, #8
    9f7a:	f88d 3014 	strb.w	r3, [sp, #20]
    uint32 ramBlockSize = 512U;
    9f7e:	f44f 7300 	mov.w	r3, #512	; 0x200
    9f82:	9304      	str	r3, [sp, #16]
    uint8 can_real_payload = 8U;
    9f84:	2308      	movs	r3, #8
    9f86:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 maxMbBlockNum = 0U;
    9f8a:	2300      	movs	r3, #0
    9f8c:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8 i=0U;
    9f90:	2300      	movs	r3, #0
    9f92:	f88d 3015 	strb.w	r3, [sp, #21]
    uint8 mb_size = 0U;
    9f96:	2300      	movs	r3, #0
    9f98:	f88d 300f 	strb.w	r3, [sp, #15]

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    9f9c:	2300      	movs	r3, #0
    9f9e:	f88d 3015 	strb.w	r3, [sp, #21]
    9fa2:	e024      	b.n	9fee <FlexCAN_GetMbPayloadSize+0x7e>
    {
        /* Check that the number of MBs is supported based on the payload size*/
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        can_real_payload = FlexCAN_GetPayloadSize(base, i);
    9fa4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    9fa8:	4619      	mov	r1, r3
    9faa:	9801      	ldr	r0, [sp, #4]
    9fac:	f7ff ffb0 	bl	9f10 <FlexCAN_GetPayloadSize>
    9fb0:	4603      	mov	r3, r0
    9fb2:	f88d 3017 	strb.w	r3, [sp, #23]
#endif /* Else can_real_payload will remain as 8 payload size */
        mb_size = (uint8)(can_real_payload + arbitration_field_size);
    9fb6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    9fba:	f89d 3014 	ldrb.w	r3, [sp, #20]
    9fbe:	4413      	add	r3, r2
    9fc0:	f88d 300f 	strb.w	r3, [sp, #15]
        maxMbBlockNum += (uint8)(ramBlockSize / mb_size);
    9fc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9fc8:	9a04      	ldr	r2, [sp, #16]
    9fca:	fbb2 f3f3 	udiv	r3, r2, r3
    9fce:	b2da      	uxtb	r2, r3
    9fd0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    9fd4:	4413      	add	r3, r2
    9fd6:	f88d 3016 	strb.w	r3, [sp, #22]
        if (maxMbBlockNum > maxMsgBuffNum)
    9fda:	f89d 3016 	ldrb.w	r3, [sp, #22]
    9fde:	9a00      	ldr	r2, [sp, #0]
    9fe0:	429a      	cmp	r2, r3
    9fe2:	d309      	bcc.n	9ff8 <FlexCAN_GetMbPayloadSize+0x88>
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    9fe4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    9fe8:	3301      	adds	r3, #1
    9fea:	f88d 3015 	strb.w	r3, [sp, #21]
    9fee:	f89d 3015 	ldrb.w	r3, [sp, #21]
    9ff2:	2b00      	cmp	r3, #0
    9ff4:	d0d6      	beq.n	9fa4 <FlexCAN_GetMbPayloadSize+0x34>
    9ff6:	e000      	b.n	9ffa <FlexCAN_GetMbPayloadSize+0x8a>
        {
            break;
    9ff8:	bf00      	nop
    {
        can_real_payload = 64U;
    }
 #endif

    return can_real_payload;
    9ffa:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    9ffe:	4618      	mov	r0, r3
    a000:	b007      	add	sp, #28
    a002:	f85d fb04 	ldr.w	pc, [sp], #4

0000a006 <FlexCAN_LockRxMsgBuff>:
 * Description   : Lock the RX message buffer.
 * This function will lock the RX message buffer.
 *
 *END**************************************************************************/
void FlexCAN_LockRxMsgBuff(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    a006:	b500      	push	{lr}
    a008:	b085      	sub	sp, #20
    a00a:	9001      	str	r0, [sp, #4]
    a00c:	9100      	str	r1, [sp, #0]
    volatile const uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    a00e:	9900      	ldr	r1, [sp, #0]
    a010:	9801      	ldr	r0, [sp, #4]
    a012:	f7ff fc7f 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a016:	9003      	str	r0, [sp, #12]

    /* Lock the mailbox by reading it */
    (void)*flexcan_mb;
    a018:	9b03      	ldr	r3, [sp, #12]
    a01a:	681b      	ldr	r3, [r3, #0]
}
    a01c:	bf00      	nop
    a01e:	b005      	add	sp, #20
    a020:	f85d fb04 	ldr.w	pc, [sp], #4

0000a024 <FlexCAN_SetMsgBuffIntCmd>:
                                               uint8 u8Instance,
                                               uint32 msgBuffIdx,
                                               boolean enable,
                                               boolean bIsIntActive
                                              )
{
    a024:	b500      	push	{lr}
    a026:	b087      	sub	sp, #28
    a028:	9003      	str	r0, [sp, #12]
    a02a:	9201      	str	r2, [sp, #4]
    a02c:	461a      	mov	r2, r3
    a02e:	460b      	mov	r3, r1
    a030:	f88d 300b 	strb.w	r3, [sp, #11]
    a034:	4613      	mov	r3, r2
    a036:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp;
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    a03a:	2300      	movs	r3, #0
    a03c:	9305      	str	r3, [sp, #20]

        /* Enable the corresponding message buffer Interrupt */
        temp = 1UL << (msgBuffIdx % 32U);
    a03e:	9b01      	ldr	r3, [sp, #4]
    a040:	f003 031f 	and.w	r3, r3, #31
    a044:	2201      	movs	r2, #1
    a046:	fa02 f303 	lsl.w	r3, r2, r3
    a04a:	9304      	str	r3, [sp, #16]
        if (msgBuffIdx < 32U)
    a04c:	9b01      	ldr	r3, [sp, #4]
    a04e:	2b1f      	cmp	r3, #31
    a050:	d837      	bhi.n	a0c2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
        {
            if (enable)
    a052:	f89d 300a 	ldrb.w	r3, [sp, #10]
    a056:	2b00      	cmp	r3, #0
    a058:	d01b      	beq.n	a092 <FlexCAN_SetMsgBuffIntCmd+0x6e>
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    a05a:	f001 fc97 	bl	b98c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) | (temp));
    a05e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a062:	4a1a      	ldr	r2, [pc, #104]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a064:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    a068:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a06c:	9a04      	ldr	r2, [sp, #16]
    a06e:	430a      	orrs	r2, r1
    a070:	4916      	ldr	r1, [pc, #88]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a072:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                if (TRUE == bIsIntActive)
    a076:	f89d 3020 	ldrb.w	r3, [sp, #32]
    a07a:	2b00      	cmp	r3, #0
    a07c:	d006      	beq.n	a08c <FlexCAN_SetMsgBuffIntCmd+0x68>
                {
                    base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    a07e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a082:	4a12      	ldr	r2, [pc, #72]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a084:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a088:	9b03      	ldr	r3, [sp, #12]
    a08a:	629a      	str	r2, [r3, #40]	; 0x28
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    a08c:	f001 fcaa 	bl	b9e4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
    a090:	e017      	b.n	a0c2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
            }
            else
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    a092:	f001 fc7b 	bl	b98c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) & ~(temp));
    a096:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a09a:	4a0c      	ldr	r2, [pc, #48]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a09c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    a0a0:	9b04      	ldr	r3, [sp, #16]
    a0a2:	43da      	mvns	r2, r3
    a0a4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a0a8:	400a      	ands	r2, r1
    a0aa:	4908      	ldr	r1, [pc, #32]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a0ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    a0b0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a0b4:	4a05      	ldr	r2, [pc, #20]	; (a0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    a0b6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a0ba:	9b03      	ldr	r3, [sp, #12]
    a0bc:	629a      	str	r2, [r3, #40]	; 0x28
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    a0be:	f001 fc91 	bl	b9e4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
            }
        }
#endif /* if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */

    return stat;
    a0c2:	9b05      	ldr	r3, [sp, #20]
}
    a0c4:	4618      	mov	r0, r3
    a0c6:	b007      	add	sp, #28
    a0c8:	f85d fb04 	ldr.w	pc, [sp], #4
    a0cc:	1fff8f70 	.word	0x1fff8f70

0000a0d0 <FLEXCAN_ClearMsgBuffIntCmd>:
void FLEXCAN_ClearMsgBuffIntCmd(FLEXCAN_Type * pBase,
                                uint8 u8Instance,
                                uint32 mb_idx,
                                boolean bIsIntActive
                               )
{
    a0d0:	b500      	push	{lr}
    a0d2:	b087      	sub	sp, #28
    a0d4:	9003      	str	r0, [sp, #12]
    a0d6:	9201      	str	r2, [sp, #4]
    a0d8:	461a      	mov	r2, r3
    a0da:	460b      	mov	r3, r1
    a0dc:	f88d 300b 	strb.w	r3, [sp, #11]
    a0e0:	4613      	mov	r3, r2
    a0e2:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp = (1UL << (mb_idx % 32U));
    a0e6:	9b01      	ldr	r3, [sp, #4]
    a0e8:	f003 031f 	and.w	r3, r3, #31
    a0ec:	2201      	movs	r2, #1
    a0ee:	fa02 f303 	lsl.w	r3, r2, r3
    a0f2:	9305      	str	r3, [sp, #20]

 /* Stop the running transfer. */
    if (mb_idx < 32U)
    a0f4:	9b01      	ldr	r3, [sp, #4]
    a0f6:	2b1f      	cmp	r3, #31
    a0f8:	d818      	bhi.n	a12c <FLEXCAN_ClearMsgBuffIntCmd+0x5c>
    {
          /* Start critical section: implementation depends on integrator */
          SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    a0fa:	f001 fa09 	bl	b510 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
          FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = (pBase->IMASK1 & (~temp));
    a0fe:	9b03      	ldr	r3, [sp, #12]
    a100:	6a99      	ldr	r1, [r3, #40]	; 0x28
    a102:	9b05      	ldr	r3, [sp, #20]
    a104:	43da      	mvns	r2, r3
    a106:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a10a:	400a      	ands	r2, r1
    a10c:	4909      	ldr	r1, [pc, #36]	; (a134 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    a10e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
          if (TRUE == bIsIntActive)
    a112:	f89d 300a 	ldrb.w	r3, [sp, #10]
    a116:	2b00      	cmp	r3, #0
    a118:	d006      	beq.n	a128 <FLEXCAN_ClearMsgBuffIntCmd+0x58>
          {
              pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    a11a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a11e:	4a05      	ldr	r2, [pc, #20]	; (a134 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    a120:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a124:	9b03      	ldr	r3, [sp, #12]
    a126:	629a      	str	r2, [r3, #40]	; 0x28
          }
          /* End critical section: implementation depends on integrator */
          SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    a128:	f001 fa1e 	bl	b568 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    }
#endif /* #if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */
}
    a12c:	bf00      	nop
    a12e:	b007      	add	sp, #28
    a130:	f85d fb04 	ldr.w	pc, [sp], #4
    a134:	1fff8f70 	.word	0x1fff8f70

0000a138 <FlexCAN_DisableInterrupts>:


void FlexCAN_DisableInterrupts(FLEXCAN_Type * pBase)
{
    a138:	b082      	sub	sp, #8
    a13a:	9001      	str	r0, [sp, #4]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = 0U;
    a13c:	9b01      	ldr	r3, [sp, #4]
    a13e:	2200      	movs	r2, #0
    a140:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = 0U;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    a142:	bf00      	nop
    a144:	b002      	add	sp, #8
    a146:	4770      	bx	lr

0000a148 <FlexCAN_EnableInterrupts>:

void FlexCAN_EnableInterrupts(FLEXCAN_Type * pBase, uint8 u8Instance)
{
    a148:	b082      	sub	sp, #8
    a14a:	9001      	str	r0, [sp, #4]
    a14c:	460b      	mov	r3, r1
    a14e:	f88d 3003 	strb.w	r3, [sp, #3]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    a152:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a156:	4a04      	ldr	r2, [pc, #16]	; (a168 <FlexCAN_EnableInterrupts+0x20>)
    a158:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a15c:	9b01      	ldr	r3, [sp, #4]
    a15e:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = FlexCAN_Ip_au32ImaskBuff[u8Instance][3U];
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    a160:	bf00      	nop
    a162:	b002      	add	sp, #8
    a164:	4770      	bx	lr
    a166:	bf00      	nop
    a168:	1fff8f70 	.word	0x1fff8f70

0000a16c <FlexCAN_SetRxMsgBuff>:
void FlexCAN_SetRxMsgBuff(const FLEXCAN_Type * base,
                          uint32 msgBuffIdx,
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId
                         )
{
    a16c:	b500      	push	{lr}
    a16e:	b087      	sub	sp, #28
    a170:	9003      	str	r0, [sp, #12]
    a172:	9102      	str	r1, [sp, #8]
    a174:	9201      	str	r2, [sp, #4]
    a176:	9300      	str	r3, [sp, #0]
    volatile uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    a178:	9902      	ldr	r1, [sp, #8]
    a17a:	9803      	ldr	r0, [sp, #12]
    a17c:	f7ff fbca 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a180:	9005      	str	r0, [sp, #20]
    volatile uint32 * flexcan_mb_id = &flexcan_mb[1];
    a182:	9b05      	ldr	r3, [sp, #20]
    a184:	3304      	adds	r3, #4
    a186:	9304      	str	r3, [sp, #16]
    DevAssert(cs != NULL_PTR);
#endif


    /* Clean up the arbitration field area */
    *flexcan_mb = 0;
    a188:	9b05      	ldr	r3, [sp, #20]
    a18a:	2200      	movs	r2, #0
    a18c:	601a      	str	r2, [r3, #0]
    *flexcan_mb_id = 0;
    a18e:	9b04      	ldr	r3, [sp, #16]
    a190:	2200      	movs	r2, #0
    a192:	601a      	str	r2, [r3, #0]

    /* Set the ID according the format structure */
    if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    a194:	9b01      	ldr	r3, [sp, #4]
    a196:	685b      	ldr	r3, [r3, #4]
    a198:	2b01      	cmp	r3, #1
    a19a:	d119      	bne.n	a1d0 <FlexCAN_SetRxMsgBuff+0x64>
    {
        /* Set IDE */
        *flexcan_mb |= FLEXCAN_IP_CS_IDE_MASK;
    a19c:	9b05      	ldr	r3, [sp, #20]
    a19e:	681b      	ldr	r3, [r3, #0]
    a1a0:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    a1a4:	9b05      	ldr	r3, [sp, #20]
    a1a6:	601a      	str	r2, [r3, #0]

        /* Clear SRR bit */
        *flexcan_mb &= ~FLEXCAN_IP_CS_SRR_MASK;
    a1a8:	9b05      	ldr	r3, [sp, #20]
    a1aa:	681b      	ldr	r3, [r3, #0]
    a1ac:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
    a1b0:	9b05      	ldr	r3, [sp, #20]
    a1b2:	601a      	str	r2, [r3, #0]

        /* ID [28-0] */
        *flexcan_mb_id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    a1b4:	9b04      	ldr	r3, [sp, #16]
    a1b6:	681b      	ldr	r3, [r3, #0]
    a1b8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    a1bc:	9b04      	ldr	r3, [sp, #16]
    a1be:	601a      	str	r2, [r3, #0]
        *flexcan_mb_id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    a1c0:	9b04      	ldr	r3, [sp, #16]
    a1c2:	681a      	ldr	r2, [r3, #0]
    a1c4:	9b00      	ldr	r3, [sp, #0]
    a1c6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    a1ca:	431a      	orrs	r2, r3
    a1cc:	9b04      	ldr	r3, [sp, #16]
    a1ce:	601a      	str	r2, [r3, #0]
    }

    if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    a1d0:	9b01      	ldr	r3, [sp, #4]
    a1d2:	685b      	ldr	r3, [r3, #4]
    a1d4:	2b00      	cmp	r3, #0
    a1d6:	d116      	bne.n	a206 <FlexCAN_SetRxMsgBuff+0x9a>
    {
        /* Make sure IDE and SRR are not set */
        *flexcan_mb &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    a1d8:	9b05      	ldr	r3, [sp, #20]
    a1da:	681b      	ldr	r3, [r3, #0]
    a1dc:	f423 02c0 	bic.w	r2, r3, #6291456	; 0x600000
    a1e0:	9b05      	ldr	r3, [sp, #20]
    a1e2:	601a      	str	r2, [r3, #0]

        /* ID[28-18] */
        *flexcan_mb_id &= ~FLEXCAN_IP_ID_STD_MASK;
    a1e4:	9b04      	ldr	r3, [sp, #16]
    a1e6:	681b      	ldr	r3, [r3, #0]
    a1e8:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    a1ec:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    a1f0:	9a04      	ldr	r2, [sp, #16]
    a1f2:	6013      	str	r3, [r2, #0]
        *flexcan_mb_id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    a1f4:	9b04      	ldr	r3, [sp, #16]
    a1f6:	681a      	ldr	r2, [r3, #0]
    a1f8:	9b00      	ldr	r3, [sp, #0]
    a1fa:	0499      	lsls	r1, r3, #18
    a1fc:	4b0e      	ldr	r3, [pc, #56]	; (a238 <FlexCAN_SetRxMsgBuff+0xcc>)
    a1fe:	400b      	ands	r3, r1
    a200:	431a      	orrs	r2, r3
    a202:	9b04      	ldr	r3, [sp, #16]
    a204:	601a      	str	r2, [r3, #0]
    }

    /* Set MB CODE */
    if ((uint32)FLEXCAN_RX_NOT_USED != cs->code)
    a206:	9b01      	ldr	r3, [sp, #4]
    a208:	681b      	ldr	r3, [r3, #0]
    a20a:	2b0f      	cmp	r3, #15
    a20c:	d00f      	beq.n	a22e <FlexCAN_SetRxMsgBuff+0xc2>
    {
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    a20e:	9b05      	ldr	r3, [sp, #20]
    a210:	681b      	ldr	r3, [r3, #0]
    a212:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    a216:	9b05      	ldr	r3, [sp, #20]
    a218:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    a21a:	9b05      	ldr	r3, [sp, #20]
    a21c:	681a      	ldr	r2, [r3, #0]
    a21e:	9b01      	ldr	r3, [sp, #4]
    a220:	681b      	ldr	r3, [r3, #0]
    a222:	061b      	lsls	r3, r3, #24
    a224:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    a228:	431a      	orrs	r2, r3
    a22a:	9b05      	ldr	r3, [sp, #20]
    a22c:	601a      	str	r2, [r3, #0]
    }
}
    a22e:	bf00      	nop
    a230:	b007      	add	sp, #28
    a232:	f85d fb04 	ldr.w	pc, [sp], #4
    a236:	bf00      	nop
    a238:	1ffc0000 	.word	0x1ffc0000

0000a23c <FlexCAN_GetMsgBuffTimestamp>:
 * Function Name : FlexCAN_GetMsgBuffTimestamp
 * Description   : Get a message buffer timestamp value.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMsgBuffTimestamp(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    a23c:	b500      	push	{lr}
    a23e:	b085      	sub	sp, #20
    a240:	9001      	str	r0, [sp, #4]
    a242:	9100      	str	r1, [sp, #0]
    uint32 TimeStamp = 0U;
    a244:	2300      	movs	r3, #0
    a246:	9303      	str	r3, [sp, #12]
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    a248:	9900      	ldr	r1, [sp, #0]
    a24a:	9801      	ldr	r0, [sp, #4]
    a24c:	f7ff fb62 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a250:	9002      	str	r0, [sp, #8]
        TimeStamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        TimeStamp = (uint32)((*Flexcan_Mb & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    a252:	9b02      	ldr	r3, [sp, #8]
    a254:	681b      	ldr	r3, [r3, #0]
    a256:	b29b      	uxth	r3, r3
    a258:	9303      	str	r3, [sp, #12]
    }
    return TimeStamp;
    a25a:	9b03      	ldr	r3, [sp, #12]
}
    a25c:	4618      	mov	r0, r3
    a25e:	b005      	add	sp, #20
    a260:	f85d fb04 	ldr.w	pc, [sp], #4

0000a264 <FlexCAN_GetMsgBuff>:
 *END**************************************************************************/
void FlexCAN_GetMsgBuff(const FLEXCAN_Type * base,
                        uint32 msgBuffIdx,
                        Flexcan_Ip_MsgBuffType * msgBuff
                       )
{
    a264:	b500      	push	{lr}
    a266:	b08d      	sub	sp, #52	; 0x34
    a268:	9003      	str	r0, [sp, #12]
    a26a:	9102      	str	r1, [sp, #8]
    a26c:	9201      	str	r2, [sp, #4]

    uint8 i;
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    a26e:	9902      	ldr	r1, [sp, #8]
    a270:	9803      	ldr	r0, [sp, #12]
    a272:	f7ff fb4f 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a276:	900a      	str	r0, [sp, #40]	; 0x28
    volatile const uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    a278:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a27a:	3304      	adds	r3, #4
    a27c:	9309      	str	r3, [sp, #36]	; 0x24
    volatile const uint8 * Flexcan_Mb_Data = (volatile const uint8 *)(&Flexcan_Mb[2]);
    a27e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a280:	3308      	adds	r3, #8
    a282:	9308      	str	r3, [sp, #32]
    volatile const uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    a284:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a286:	3308      	adds	r3, #8
    a288:	9307      	str	r3, [sp, #28]
    uint32 * MsgBuff_Data_32 = NULL_PTR;
    a28a:	2300      	movs	r3, #0
    a28c:	9306      	str	r3, [sp, #24]
    uint32 MbWord;

    uint8 Flexcan_Mb_Dlc_Value = (uint8)(((*Flexcan_Mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    a28e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a290:	681b      	ldr	r3, [r3, #0]
    a292:	0c1b      	lsrs	r3, r3, #16
    a294:	b2db      	uxtb	r3, r3
    a296:	f003 030f 	and.w	r3, r3, #15
    a29a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Payload_Size = FlexCAN_ComputePayloadSize(Flexcan_Mb_Dlc_Value);
    a29e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a2a2:	4618      	mov	r0, r3
    a2a4:	f7ff faed 	bl	9882 <FlexCAN_ComputePayloadSize>
    a2a8:	4603      	mov	r3, r0
    a2aa:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(msgBuff != NULL_PTR);
#endif
    /* Asign after NULL Check */
    MsgBuff_Data_32 = (uint32 *)(msgBuff->data);
    a2ae:	9b01      	ldr	r3, [sp, #4]
    a2b0:	3308      	adds	r3, #8
    a2b2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    /* Payload Size is based on MBDSR for 1 MBDSR corresponds 32 * 8Bytes MBs  */
    if (Payload_Size > FlexCAN_GetMbPayloadSize(base, msgBuffIdx))
    a2b4:	9902      	ldr	r1, [sp, #8]
    a2b6:	9803      	ldr	r0, [sp, #12]
    a2b8:	f7ff fe5a 	bl	9f70 <FlexCAN_GetMbPayloadSize>
    a2bc:	4603      	mov	r3, r0
    a2be:	461a      	mov	r2, r3
    a2c0:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    a2c4:	4293      	cmp	r3, r2
    a2c6:	d906      	bls.n	a2d6 <FlexCAN_GetMsgBuff+0x72>
    {
        Payload_Size = FlexCAN_GetMbPayloadSize(base, msgBuffIdx);
    a2c8:	9902      	ldr	r1, [sp, #8]
    a2ca:	9803      	ldr	r0, [sp, #12]
    a2cc:	f7ff fe50 	bl	9f70 <FlexCAN_GetMbPayloadSize>
    a2d0:	4603      	mov	r3, r0
    a2d2:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    msgBuff->dataLen = Payload_Size;
    a2d6:	9b01      	ldr	r3, [sp, #4]
    a2d8:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    a2dc:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Get a MB field values */
    msgBuff->cs = *Flexcan_Mb;
    a2e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a2e2:	681a      	ldr	r2, [r3, #0]
    a2e4:	9b01      	ldr	r3, [sp, #4]
    a2e6:	601a      	str	r2, [r3, #0]
    if ((msgBuff->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    a2e8:	9b01      	ldr	r3, [sp, #4]
    a2ea:	681b      	ldr	r3, [r3, #0]
    a2ec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    a2f0:	2b00      	cmp	r3, #0
    a2f2:	d004      	beq.n	a2fe <FlexCAN_GetMsgBuff+0x9a>
    {
        msgBuff->msgId = (*Flexcan_Mb_Id);
    a2f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a2f6:	681a      	ldr	r2, [r3, #0]
    a2f8:	9b01      	ldr	r3, [sp, #4]
    a2fa:	605a      	str	r2, [r3, #4]
    a2fc:	e004      	b.n	a308 <FlexCAN_GetMsgBuff+0xa4>
    }
    else
    {
        msgBuff->msgId = (*Flexcan_Mb_Id) >> FLEXCAN_IP_ID_STD_SHIFT;
    a2fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a300:	681b      	ldr	r3, [r3, #0]
    a302:	0c9a      	lsrs	r2, r3, #18
    a304:	9b01      	ldr	r3, [sp, #4]
    a306:	605a      	str	r2, [r3, #4]
        msgBuff->time_stamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        msgBuff->time_stamp = (uint32)((msgBuff->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    a308:	9b01      	ldr	r3, [sp, #4]
    a30a:	681b      	ldr	r3, [r3, #0]
    a30c:	b29a      	uxth	r2, r3
    a30e:	9b01      	ldr	r3, [sp, #4]
    a310:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, MsgBuff_Data_32[i >> 2U]);
        }
    }

#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    a312:	2300      	movs	r3, #0
    a314:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    a318:	e025      	b.n	a366 <FlexCAN_GetMsgBuff+0x102>
    {
        MbWord = Flexcan_Mb_Data_32[i >> 2U];
    a31a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a31e:	089b      	lsrs	r3, r3, #2
    a320:	b2db      	uxtb	r3, r3
    a322:	009b      	lsls	r3, r3, #2
    a324:	9a07      	ldr	r2, [sp, #28]
    a326:	4413      	add	r3, r2
    a328:	681b      	ldr	r3, [r3, #0]
    a32a:	9304      	str	r3, [sp, #16]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (MsgBuff_Data_32[i >> 2U]));
    a32c:	9b04      	ldr	r3, [sp, #16]
    a32e:	0e1a      	lsrs	r2, r3, #24
    a330:	9b04      	ldr	r3, [sp, #16]
    a332:	0a1b      	lsrs	r3, r3, #8
    a334:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    a338:	431a      	orrs	r2, r3
    a33a:	9b04      	ldr	r3, [sp, #16]
    a33c:	021b      	lsls	r3, r3, #8
    a33e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    a342:	ea42 0103 	orr.w	r1, r2, r3
    a346:	9b04      	ldr	r3, [sp, #16]
    a348:	061a      	lsls	r2, r3, #24
    a34a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a34e:	089b      	lsrs	r3, r3, #2
    a350:	b2db      	uxtb	r3, r3
    a352:	009b      	lsls	r3, r3, #2
    a354:	9806      	ldr	r0, [sp, #24]
    a356:	4403      	add	r3, r0
    a358:	430a      	orrs	r2, r1
    a35a:	601a      	str	r2, [r3, #0]
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    a35c:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a360:	3304      	adds	r3, #4
    a362:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    a366:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    a36a:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    a36e:	f023 0303 	bic.w	r3, r3, #3
    a372:	429a      	cmp	r2, r3
    a374:	d3d1      	bcc.n	a31a <FlexCAN_GetMsgBuff+0xb6>
    }

#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (; i < Payload_Size; i++)
    a376:	e014      	b.n	a3a2 <FlexCAN_GetMsgBuff+0x13e>
    {   /* Max allowed value for index is 63 */
        msgBuff->data[i] = Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(i)];
    a378:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a37c:	f083 0303 	eor.w	r3, r3, #3
    a380:	b2db      	uxtb	r3, r3
    a382:	461a      	mov	r2, r3
    a384:	9b08      	ldr	r3, [sp, #32]
    a386:	441a      	add	r2, r3
    a388:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a38c:	7812      	ldrb	r2, [r2, #0]
    a38e:	b2d1      	uxtb	r1, r2
    a390:	9a01      	ldr	r2, [sp, #4]
    a392:	4413      	add	r3, r2
    a394:	460a      	mov	r2, r1
    a396:	721a      	strb	r2, [r3, #8]
    for (; i < Payload_Size; i++)
    a398:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    a39c:	3301      	adds	r3, #1
    a39e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    a3a2:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    a3a6:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    a3aa:	429a      	cmp	r2, r3
    a3ac:	d3e4      	bcc.n	a378 <FlexCAN_GetMsgBuff+0x114>
    }
}
    a3ae:	bf00      	nop
    a3b0:	bf00      	nop
    a3b2:	b00d      	add	sp, #52	; 0x34
    a3b4:	f85d fb04 	ldr.w	pc, [sp], #4

0000a3b8 <FlexCAN_SetTxMsgBuff>:
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId,
                          const uint8 * msgData,
                          const boolean isRemote
                         )
{
    a3b8:	b500      	push	{lr}
    a3ba:	b08d      	sub	sp, #52	; 0x34
    a3bc:	9003      	str	r0, [sp, #12]
    a3be:	9102      	str	r1, [sp, #8]
    a3c0:	9201      	str	r2, [sp, #4]
    a3c2:	9300      	str	r3, [sp, #0]
    uint32 Flexcan_Mb_Config = 0;
    a3c4:	2300      	movs	r3, #0
    a3c6:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 DataByte;
    uint8 Dlc_Value;
    uint8 Payload_Size;
    volatile uint32 * Flexcan_Mb = pMbAddr;
    a3c8:	9b03      	ldr	r3, [sp, #12]
    a3ca:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    a3cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3ce:	3304      	adds	r3, #4
    a3d0:	9308      	str	r3, [sp, #32]
    volatile uint8 * Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    a3d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3d4:	3308      	adds	r3, #8
    a3d6:	9307      	str	r3, [sp, #28]
    volatile uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    a3d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3da:	3308      	adds	r3, #8
    a3dc:	9306      	str	r3, [sp, #24]
    const uint32 * MsgData_32 = (const uint32*)msgData;
    a3de:	9b00      	ldr	r3, [sp, #0]
    a3e0:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(cs != NULL_PTR);
    #endif

        /* Clean up the arbitration field area and set TxMB Inactive */
        *Flexcan_Mb = (uint32)((((uint32)FLEXCAN_TX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    a3e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3e4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    a3e8:	601a      	str	r2, [r3, #0]
        *Flexcan_Mb_Id = 0;
    a3ea:	9b08      	ldr	r3, [sp, #32]
    a3ec:	2200      	movs	r2, #0
    a3ee:	601a      	str	r2, [r3, #0]

        /* Compute the value of the DLC field */
        Dlc_Value = FlexCAN_ComputeDLCValue((uint8)cs->dataLen);
    a3f0:	9b02      	ldr	r3, [sp, #8]
    a3f2:	689b      	ldr	r3, [r3, #8]
    a3f4:	b2db      	uxtb	r3, r3
    a3f6:	4618      	mov	r0, r3
    a3f8:	f7ff f9f4 	bl	97e4 <FlexCAN_ComputeDLCValue>
    a3fc:	4603      	mov	r3, r0
    a3fe:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Copy user's buffer into the message buffer data area */
        if (msgData != NULL_PTR)
    a402:	9b00      	ldr	r3, [sp, #0]
    a404:	2b00      	cmp	r3, #0
    a406:	d065      	beq.n	a4d4 <FlexCAN_SetTxMsgBuff+0x11c>
        {
#if (defined(S32K116) || defined (S32K118))
            (void)MsgData_32;
            DataByte = FlexCAN_DataTransferTxMsgBuff(Flexcan_Mb_Data_32, cs, msgData);
#else
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    a408:	2300      	movs	r3, #0
    a40a:	930a      	str	r3, [sp, #40]	; 0x28
    a40c:	e02c      	b.n	a468 <FlexCAN_SetTxMsgBuff+0xb0>
            {
                FLEXCAN_IP_SWAP_BYTES_IN_WORD((MsgData_32[DataByte >> 2U]), (Flexcan_Mb_Data_32[DataByte >> 2U]));
    a40e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a410:	089b      	lsrs	r3, r3, #2
    a412:	009b      	lsls	r3, r3, #2
    a414:	9a05      	ldr	r2, [sp, #20]
    a416:	4413      	add	r3, r2
    a418:	681b      	ldr	r3, [r3, #0]
    a41a:	0e1a      	lsrs	r2, r3, #24
    a41c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a41e:	089b      	lsrs	r3, r3, #2
    a420:	009b      	lsls	r3, r3, #2
    a422:	9905      	ldr	r1, [sp, #20]
    a424:	440b      	add	r3, r1
    a426:	681b      	ldr	r3, [r3, #0]
    a428:	0a1b      	lsrs	r3, r3, #8
    a42a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    a42e:	431a      	orrs	r2, r3
    a430:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a432:	089b      	lsrs	r3, r3, #2
    a434:	009b      	lsls	r3, r3, #2
    a436:	9905      	ldr	r1, [sp, #20]
    a438:	440b      	add	r3, r1
    a43a:	681b      	ldr	r3, [r3, #0]
    a43c:	021b      	lsls	r3, r3, #8
    a43e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    a442:	ea42 0103 	orr.w	r1, r2, r3
    a446:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a448:	089b      	lsrs	r3, r3, #2
    a44a:	009b      	lsls	r3, r3, #2
    a44c:	9a05      	ldr	r2, [sp, #20]
    a44e:	4413      	add	r3, r2
    a450:	681b      	ldr	r3, [r3, #0]
    a452:	061a      	lsls	r2, r3, #24
    a454:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a456:	089b      	lsrs	r3, r3, #2
    a458:	009b      	lsls	r3, r3, #2
    a45a:	9806      	ldr	r0, [sp, #24]
    a45c:	4403      	add	r3, r0
    a45e:	430a      	orrs	r2, r1
    a460:	601a      	str	r2, [r3, #0]
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    a462:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a464:	3304      	adds	r3, #4
    a466:	930a      	str	r3, [sp, #40]	; 0x28
    a468:	9b02      	ldr	r3, [sp, #8]
    a46a:	689b      	ldr	r3, [r3, #8]
    a46c:	f023 0303 	bic.w	r3, r3, #3
    a470:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a472:	429a      	cmp	r2, r3
    a474:	d3cb      	bcc.n	a40e <FlexCAN_SetTxMsgBuff+0x56>
            }
#endif /* (defined(S32K116) || defined (S32K118)) */
            for ( ; DataByte < cs->dataLen; DataByte++)
    a476:	e00c      	b.n	a492 <FlexCAN_SetTxMsgBuff+0xda>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] =  msgData[DataByte];
    a478:	9a00      	ldr	r2, [sp, #0]
    a47a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a47c:	441a      	add	r2, r3
    a47e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a480:	f083 0303 	eor.w	r3, r3, #3
    a484:	9907      	ldr	r1, [sp, #28]
    a486:	440b      	add	r3, r1
    a488:	7812      	ldrb	r2, [r2, #0]
    a48a:	701a      	strb	r2, [r3, #0]
            for ( ; DataByte < cs->dataLen; DataByte++)
    a48c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a48e:	3301      	adds	r3, #1
    a490:	930a      	str	r3, [sp, #40]	; 0x28
    a492:	9b02      	ldr	r3, [sp, #8]
    a494:	689b      	ldr	r3, [r3, #8]
    a496:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a498:	429a      	cmp	r2, r3
    a49a:	d3ed      	bcc.n	a478 <FlexCAN_SetTxMsgBuff+0xc0>
            }
        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            Payload_Size = FlexCAN_ComputePayloadSize(Dlc_Value);
    a49c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    a4a0:	4618      	mov	r0, r3
    a4a2:	f7ff f9ee 	bl	9882 <FlexCAN_ComputePayloadSize>
    a4a6:	4603      	mov	r3, r0
    a4a8:	f88d 3012 	strb.w	r3, [sp, #18]
            /* Add padding, if needed */
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    a4ac:	9b02      	ldr	r3, [sp, #8]
    a4ae:	689b      	ldr	r3, [r3, #8]
    a4b0:	930a      	str	r3, [sp, #40]	; 0x28
    a4b2:	e00a      	b.n	a4ca <FlexCAN_SetTxMsgBuff+0x112>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] = cs->fd_padding;
    a4b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a4b6:	f083 0303 	eor.w	r3, r3, #3
    a4ba:	9a07      	ldr	r2, [sp, #28]
    a4bc:	4413      	add	r3, r2
    a4be:	9a02      	ldr	r2, [sp, #8]
    a4c0:	7b52      	ldrb	r2, [r2, #13]
    a4c2:	701a      	strb	r2, [r3, #0]
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    a4c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a4c6:	3301      	adds	r3, #1
    a4c8:	930a      	str	r3, [sp, #40]	; 0x28
    a4ca:	f89d 3012 	ldrb.w	r3, [sp, #18]
    a4ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a4d0:	429a      	cmp	r2, r3
    a4d2:	d3ef      	bcc.n	a4b4 <FlexCAN_SetTxMsgBuff+0xfc>
            }
        #endif /* FLEXCAN_IP_FEATURE_HAS_FD */
        }
        /* Set the ID according the format structure */
        if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    a4d4:	9b02      	ldr	r3, [sp, #8]
    a4d6:	685b      	ldr	r3, [r3, #4]
    a4d8:	2b01      	cmp	r3, #1
    a4da:	d111      	bne.n	a500 <FlexCAN_SetTxMsgBuff+0x148>
        {
            /* ID [28-0] */
            *Flexcan_Mb_Id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    a4dc:	9b08      	ldr	r3, [sp, #32]
    a4de:	681b      	ldr	r3, [r3, #0]
    a4e0:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    a4e4:	9b08      	ldr	r3, [sp, #32]
    a4e6:	601a      	str	r2, [r3, #0]
            *Flexcan_Mb_Id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    a4e8:	9b08      	ldr	r3, [sp, #32]
    a4ea:	681a      	ldr	r2, [r3, #0]
    a4ec:	9b01      	ldr	r3, [sp, #4]
    a4ee:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    a4f2:	431a      	orrs	r2, r3
    a4f4:	9b08      	ldr	r3, [sp, #32]
    a4f6:	601a      	str	r2, [r3, #0]
            /* Set IDE and SRR bit*/
            Flexcan_Mb_Config |= (FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    a4f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a4fa:	f443 03c0 	orr.w	r3, r3, #6291456	; 0x600000
    a4fe:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    a500:	9b02      	ldr	r3, [sp, #8]
    a502:	685b      	ldr	r3, [r3, #4]
    a504:	2b00      	cmp	r3, #0
    a506:	d114      	bne.n	a532 <FlexCAN_SetTxMsgBuff+0x17a>
        {
            /* ID[28-18] */
            *Flexcan_Mb_Id &= ~FLEXCAN_IP_ID_STD_MASK;
    a508:	9b08      	ldr	r3, [sp, #32]
    a50a:	681b      	ldr	r3, [r3, #0]
    a50c:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    a510:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    a514:	9a08      	ldr	r2, [sp, #32]
    a516:	6013      	str	r3, [r2, #0]
            *Flexcan_Mb_Id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    a518:	9b08      	ldr	r3, [sp, #32]
    a51a:	681a      	ldr	r2, [r3, #0]
    a51c:	9b01      	ldr	r3, [sp, #4]
    a51e:	0499      	lsls	r1, r3, #18
    a520:	4b2b      	ldr	r3, [pc, #172]	; (a5d0 <FlexCAN_SetTxMsgBuff+0x218>)
    a522:	400b      	ands	r3, r1
    a524:	431a      	orrs	r2, r3
    a526:	9b08      	ldr	r3, [sp, #32]
    a528:	601a      	str	r2, [r3, #0]
            /* make sure IDE and SRR are not set */
            Flexcan_Mb_Config &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    a52a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a52c:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
    a530:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        /* Set the length of data in bytes */
        Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_DLC_MASK;
    a532:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a534:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    a538:	930b      	str	r3, [sp, #44]	; 0x2c
        Flexcan_Mb_Config |= ((uint32)Dlc_Value << FLEXCAN_IP_CS_DLC_SHIFT) & FLEXCAN_IP_CS_DLC_MASK;
    a53a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    a53e:	041b      	lsls	r3, r3, #16
    a540:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    a544:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a546:	4313      	orrs	r3, r2
    a548:	930b      	str	r3, [sp, #44]	; 0x2c
        /* Set MB CODE */
        if (cs->code != (uint32)FLEXCAN_TX_NOT_USED)
    a54a:	9b02      	ldr	r3, [sp, #8]
    a54c:	681b      	ldr	r3, [r3, #0]
    a54e:	2b0f      	cmp	r3, #15
    a550:	d03a      	beq.n	a5c8 <FlexCAN_SetTxMsgBuff+0x210>
        {
            if ((uint32)FLEXCAN_TX_REMOTE == cs->code)
    a552:	9b02      	ldr	r3, [sp, #8]
    a554:	681b      	ldr	r3, [r3, #0]
    a556:	2b1c      	cmp	r3, #28
    a558:	d104      	bne.n	a564 <FlexCAN_SetTxMsgBuff+0x1ac>
            {
                /* Set RTR bit */
                Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    a55a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a55c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    a560:	930b      	str	r3, [sp, #44]	; 0x2c
    a562:	e007      	b.n	a574 <FlexCAN_SetTxMsgBuff+0x1bc>
            }
            else
            {
                if (TRUE == isRemote)
    a564:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    a568:	2b00      	cmp	r3, #0
    a56a:	d003      	beq.n	a574 <FlexCAN_SetTxMsgBuff+0x1bc>
                {
                    /* Set RTR bit */
                    Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    a56c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a56e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    a572:	930b      	str	r3, [sp, #44]	; 0x2c
                }
            }
            /* Reset the code */
            Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_CODE_MASK;
    a574:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a576:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    a57a:	930b      	str	r3, [sp, #44]	; 0x2c
            /* Set the code */
            if (cs->fd_enable)
    a57c:	9b02      	ldr	r3, [sp, #8]
    a57e:	7b1b      	ldrb	r3, [r3, #12]
    a580:	2b00      	cmp	r3, #0
    a582:	d00e      	beq.n	a5a2 <FlexCAN_SetTxMsgBuff+0x1ea>
            {
                Flexcan_Mb_Config |= ((cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK) | FLEXCAN_IP_MB_EDL_MASK;
    a584:	9b02      	ldr	r3, [sp, #8]
    a586:	681b      	ldr	r3, [r3, #0]
    a588:	061b      	lsls	r3, r3, #24
    a58a:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    a58e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a590:	4313      	orrs	r3, r2
    a592:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    a596:	930b      	str	r3, [sp, #44]	; 0x2c
                /* In case of FD frame not supported RTR */
                Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_RTR_MASK;
    a598:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a59a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    a59e:	930b      	str	r3, [sp, #44]	; 0x2c
    a5a0:	e007      	b.n	a5b2 <FlexCAN_SetTxMsgBuff+0x1fa>
            }
            else
            {
                Flexcan_Mb_Config |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    a5a2:	9b02      	ldr	r3, [sp, #8]
    a5a4:	681b      	ldr	r3, [r3, #0]
    a5a6:	061b      	lsls	r3, r3, #24
    a5a8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    a5ac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a5ae:	4313      	orrs	r3, r2
    a5b0:	930b      	str	r3, [sp, #44]	; 0x2c
            }

            if (cs->enable_brs)
    a5b2:	9b02      	ldr	r3, [sp, #8]
    a5b4:	7b9b      	ldrb	r3, [r3, #14]
    a5b6:	2b00      	cmp	r3, #0
    a5b8:	d003      	beq.n	a5c2 <FlexCAN_SetTxMsgBuff+0x20a>
            {
                Flexcan_Mb_Config |= FLEXCAN_IP_MB_BRS_MASK;
    a5ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a5bc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    a5c0:	930b      	str	r3, [sp, #44]	; 0x2c
            }
            *Flexcan_Mb = Flexcan_Mb_Config;
    a5c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a5c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a5c6:	601a      	str	r2, [r3, #0]
        }
}
    a5c8:	bf00      	nop
    a5ca:	b00d      	add	sp, #52	; 0x34
    a5cc:	f85d fb04 	ldr.w	pc, [sp], #4
    a5d0:	1ffc0000 	.word	0x1ffc0000

0000a5d4 <FlexCAN_SetMaxMsgBuffNum>:
 * Description   : Set the number of the last Message Buffers.
 * This function will define the number of the last Message Buffers
 *
 *END***************************************************************************/
Flexcan_Ip_StatusType FlexCAN_SetMaxMsgBuffNum(FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    a5d4:	b500      	push	{lr}
    a5d6:	b08f      	sub	sp, #60	; 0x3c
    a5d8:	9001      	str	r0, [sp, #4]
    a5da:	9100      	str	r1, [sp, #0]
    uint32 MsgBuffIdx;
    uint32 DataByte;
    const volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    a5dc:	9b01      	ldr	r3, [sp, #4]
    a5de:	3380      	adds	r3, #128	; 0x80
    a5e0:	930a      	str	r3, [sp, #40]	; 0x28
#if (STD_ON == FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY)
    const volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */
    const volatile uint32 * ValEndMbPointer = NULL_PTR;
    a5e2:	2300      	movs	r3, #0
    a5e4:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 *Flexcan_Mb = NULL_PTR;
    a5e6:	2300      	movs	r3, #0
    a5e8:	9308      	str	r3, [sp, #32]
    volatile uint32 *Flexcan_Mb_Id   = NULL_PTR ;
    a5ea:	2300      	movs	r3, #0
    a5ec:	9307      	str	r3, [sp, #28]
    volatile uint8  *Flexcan_Mb_Data = NULL_PTR;
    a5ee:	2300      	movs	r3, #0
    a5f0:	9306      	str	r3, [sp, #24]
    uint8 Arbitration_Field_Size = 8U;
    a5f2:	2308      	movs	r3, #8
    a5f4:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, maxMsgBuffNum - (uint32)1U);
    a5f8:	9b00      	ldr	r3, [sp, #0]
    a5fa:	3b01      	subs	r3, #1
    a5fc:	4619      	mov	r1, r3
    a5fe:	9801      	ldr	r0, [sp, #4]
    a600:	f7ff fcb6 	bl	9f70 <FlexCAN_GetMbPayloadSize>
    a604:	4603      	mov	r3, r0
    a606:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_PtrSizeType ValEndMb = 0U;
    a60a:	2300      	movs	r3, #0
    a60c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_PtrSizeType ValEndRam = 0U;
    a60e:	2300      	movs	r3, #0
    a610:	9303      	str	r3, [sp, #12]
    Flexcan_Ip_StatusType Status = FLEXCAN_STATUS_SUCCESS;
    a612:	2300      	movs	r3, #0
    a614:	930b      	str	r3, [sp, #44]	; 0x2c

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(maxMsgBuffNum>0U);
    #endif

    ValEndMbPointer = FlexCAN_GetMsgBuffRegion(base, (maxMsgBuffNum - (uint32)1U));
    a616:	9b00      	ldr	r3, [sp, #0]
    a618:	3b01      	subs	r3, #1
    a61a:	4619      	mov	r1, r3
    a61c:	9801      	ldr	r0, [sp, #4]
    a61e:	f7ff f979 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a622:	9009      	str	r0, [sp, #36]	; 0x24

    ValEndMb = (Flexcan_Ip_PtrSizeType)ValEndMbPointer + Can_Real_Payload + Arbitration_Field_Size;
    a624:	f89d 2016 	ldrb.w	r2, [sp, #22]
    a628:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a62a:	441a      	add	r2, r3
    a62c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a630:	4413      	add	r3, r2
    a632:	9304      	str	r3, [sp, #16]
    else
    {
        ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    }
#else
    ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    a634:	9801      	ldr	r0, [sp, #4]
    a636:	f7ff f9e7 	bl	9a08 <FlexCAN_GetMaxMbNum>
    a63a:	4603      	mov	r3, r0
    a63c:	011b      	lsls	r3, r3, #4
    a63e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a640:	4413      	add	r3, r2
    a642:	9303      	str	r3, [sp, #12]
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */

    if ((ValEndMb > ValEndRam) || (maxMsgBuffNum > FlexCAN_GetMaxMbNum(base)))
    a644:	9a04      	ldr	r2, [sp, #16]
    a646:	9b03      	ldr	r3, [sp, #12]
    a648:	429a      	cmp	r2, r3
    a64a:	d806      	bhi.n	a65a <FlexCAN_SetMaxMsgBuffNum+0x86>
    a64c:	9801      	ldr	r0, [sp, #4]
    a64e:	f7ff f9db 	bl	9a08 <FlexCAN_GetMaxMbNum>
    a652:	4602      	mov	r2, r0
    a654:	9b00      	ldr	r3, [sp, #0]
    a656:	4293      	cmp	r3, r2
    a658:	d901      	bls.n	a65e <FlexCAN_SetMaxMsgBuffNum+0x8a>
    {
        Status = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    a65a:	2304      	movs	r3, #4
    a65c:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    if (FLEXCAN_STATUS_SUCCESS == Status)
    a65e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a660:	2b00      	cmp	r3, #0
    a662:	d142      	bne.n	a6ea <FlexCAN_SetMaxMsgBuffNum+0x116>
    {
        /* Set the maximum number of MBs*/
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MAXMB_MASK) | (((maxMsgBuffNum-1U) << FLEXCAN_MCR_MAXMB_SHIFT) & FLEXCAN_MCR_MAXMB_MASK);
    a664:	9b01      	ldr	r3, [sp, #4]
    a666:	681b      	ldr	r3, [r3, #0]
    a668:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
    a66c:	9b00      	ldr	r3, [sp, #0]
    a66e:	3b01      	subs	r3, #1
    a670:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    a674:	431a      	orrs	r2, r3
    a676:	9b01      	ldr	r3, [sp, #4]
    a678:	601a      	str	r2, [r3, #0]
        if (!(((base->MCR & FLEXCAN_MCR_RFEN_MASK) >> FLEXCAN_MCR_RFEN_SHIFT) != 0U))
    a67a:	9b01      	ldr	r3, [sp, #4]
    a67c:	681b      	ldr	r3, [r3, #0]
    a67e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
    a682:	2b00      	cmp	r3, #0
    a684:	d131      	bne.n	a6ea <FlexCAN_SetMaxMsgBuffNum+0x116>
        {
            /* Initialize all message buffers as inactive */
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    a686:	2300      	movs	r3, #0
    a688:	930d      	str	r3, [sp, #52]	; 0x34
    a68a:	e02a      	b.n	a6e2 <FlexCAN_SetMaxMsgBuffNum+0x10e>
            {
                Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, MsgBuffIdx);
    a68c:	990d      	ldr	r1, [sp, #52]	; 0x34
    a68e:	9801      	ldr	r0, [sp, #4]
    a690:	f7ff f940 	bl	9914 <FlexCAN_GetMsgBuffRegion>
    a694:	9008      	str	r0, [sp, #32]
                Flexcan_Mb_Id   = &Flexcan_Mb[1];
    a696:	9b08      	ldr	r3, [sp, #32]
    a698:	3304      	adds	r3, #4
    a69a:	9307      	str	r3, [sp, #28]
                Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    a69c:	9b08      	ldr	r3, [sp, #32]
    a69e:	3308      	adds	r3, #8
    a6a0:	9306      	str	r3, [sp, #24]
                *Flexcan_Mb = 0x0U;
    a6a2:	9b08      	ldr	r3, [sp, #32]
    a6a4:	2200      	movs	r2, #0
    a6a6:	601a      	str	r2, [r3, #0]
                *Flexcan_Mb_Id = 0x0U;
    a6a8:	9b07      	ldr	r3, [sp, #28]
    a6aa:	2200      	movs	r2, #0
    a6ac:	601a      	str	r2, [r3, #0]
                Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, MsgBuffIdx);
    a6ae:	990d      	ldr	r1, [sp, #52]	; 0x34
    a6b0:	9801      	ldr	r0, [sp, #4]
    a6b2:	f7ff fc5d 	bl	9f70 <FlexCAN_GetMbPayloadSize>
    a6b6:	4603      	mov	r3, r0
    a6b8:	f88d 3016 	strb.w	r3, [sp, #22]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    a6bc:	2300      	movs	r3, #0
    a6be:	930c      	str	r3, [sp, #48]	; 0x30
    a6c0:	e007      	b.n	a6d2 <FlexCAN_SetMaxMsgBuffNum+0xfe>
                {
                   Flexcan_Mb_Data[DataByte] = 0x0U;
    a6c2:	9a06      	ldr	r2, [sp, #24]
    a6c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a6c6:	4413      	add	r3, r2
    a6c8:	2200      	movs	r2, #0
    a6ca:	701a      	strb	r2, [r3, #0]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    a6cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a6ce:	3301      	adds	r3, #1
    a6d0:	930c      	str	r3, [sp, #48]	; 0x30
    a6d2:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a6d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a6d8:	429a      	cmp	r2, r3
    a6da:	d3f2      	bcc.n	a6c2 <FlexCAN_SetMaxMsgBuffNum+0xee>
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    a6dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a6de:	3301      	adds	r3, #1
    a6e0:	930d      	str	r3, [sp, #52]	; 0x34
    a6e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a6e4:	9b00      	ldr	r3, [sp, #0]
    a6e6:	429a      	cmp	r2, r3
    a6e8:	d3d0      	bcc.n	a68c <FlexCAN_SetMaxMsgBuffNum+0xb8>
                }
            }
        }
    }
    return Status;
    a6ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    a6ec:	4618      	mov	r0, r3
    a6ee:	b00f      	add	sp, #60	; 0x3c
    a6f0:	f85d fb04 	ldr.w	pc, [sp], #4

0000a6f4 <FlexCAN_SetOperationMode>:
 * Description   : Enable a FlexCAN operation mode.
 * This function will enable one of the modes listed in flexcan_operation_modes_t.
 *
 *END**************************************************************************/
void FlexCAN_SetOperationMode(FLEXCAN_Type * base, Flexcan_Ip_ModesType mode)
{
    a6f4:	b500      	push	{lr}
    a6f6:	b083      	sub	sp, #12
    a6f8:	9001      	str	r0, [sp, #4]
    a6fa:	9100      	str	r1, [sp, #0]
    switch (mode)
    a6fc:	9b00      	ldr	r3, [sp, #0]
    a6fe:	2b02      	cmp	r3, #2
    a700:	d01d      	beq.n	a73e <FlexCAN_SetOperationMode+0x4a>
    a702:	9b00      	ldr	r3, [sp, #0]
    a704:	2b02      	cmp	r3, #2
    a706:	d82b      	bhi.n	a760 <FlexCAN_SetOperationMode+0x6c>
    a708:	9b00      	ldr	r3, [sp, #0]
    a70a:	2b00      	cmp	r3, #0
    a70c:	d003      	beq.n	a716 <FlexCAN_SetOperationMode+0x22>
    a70e:	9b00      	ldr	r3, [sp, #0]
    a710:	2b01      	cmp	r3, #1
    a712:	d00d      	beq.n	a730 <FlexCAN_SetOperationMode+0x3c>
            /* Enable Self Reception */
            FlexCAN_SetSelfReception(base, TRUE);
            break;
        default:
            /* Should not get here */
            break;
    a714:	e024      	b.n	a760 <FlexCAN_SetOperationMode+0x6c>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    a716:	9b01      	ldr	r3, [sp, #4]
    a718:	685b      	ldr	r3, [r3, #4]
    a71a:	f023 0208 	bic.w	r2, r3, #8
    a71e:	9b01      	ldr	r3, [sp, #4]
    a720:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(0U);
    a722:	9b01      	ldr	r3, [sp, #4]
    a724:	685b      	ldr	r3, [r3, #4]
    a726:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
    a72a:	9b01      	ldr	r3, [sp, #4]
    a72c:	605a      	str	r2, [r3, #4]
            break;
    a72e:	e018      	b.n	a762 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(1U);
    a730:	9b01      	ldr	r3, [sp, #4]
    a732:	685b      	ldr	r3, [r3, #4]
    a734:	f043 0208 	orr.w	r2, r3, #8
    a738:	9b01      	ldr	r3, [sp, #4]
    a73a:	605a      	str	r2, [r3, #4]
            break;
    a73c:	e011      	b.n	a762 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(1U);
    a73e:	9b01      	ldr	r3, [sp, #4]
    a740:	685b      	ldr	r3, [r3, #4]
    a742:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    a746:	9b01      	ldr	r3, [sp, #4]
    a748:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    a74a:	9b01      	ldr	r3, [sp, #4]
    a74c:	685b      	ldr	r3, [r3, #4]
    a74e:	f023 0208 	bic.w	r2, r3, #8
    a752:	9b01      	ldr	r3, [sp, #4]
    a754:	605a      	str	r2, [r3, #4]
            FlexCAN_SetSelfReception(base, TRUE);
    a756:	2101      	movs	r1, #1
    a758:	9801      	ldr	r0, [sp, #4]
    a75a:	f7fe ff7f 	bl	965c <FlexCAN_SetSelfReception>
            break;
    a75e:	e000      	b.n	a762 <FlexCAN_SetOperationMode+0x6e>
            break;
    a760:	bf00      	nop
    }
}
    a762:	bf00      	nop
    a764:	b003      	add	sp, #12
    a766:	f85d fb04 	ldr.w	pc, [sp], #4

0000a76a <FlexCAN_SetRxFifoFilter>:
 *END**************************************************************************/
void FlexCAN_SetRxFifoFilter(FLEXCAN_Type * base,
                             Flexcan_Ip_RxFifoIdElementFormatType idFormat,
                             const Flexcan_Ip_IdTableType * idFilterTable
                            )
{
    a76a:	b500      	push	{lr}
    a76c:	b08d      	sub	sp, #52	; 0x34
    a76e:	9003      	str	r0, [sp, #12]
    a770:	9102      	str	r1, [sp, #8]
    a772:	9201      	str	r2, [sp, #4]

    /* Set RX FIFO ID filter table elements*/
    uint32 i, j, NumOfFilters;
    uint32 Val1 = 0UL, Val2 = 0UL, Val = 0UL;
    a774:	2300      	movs	r3, #0
    a776:	9309      	str	r3, [sp, #36]	; 0x24
    a778:	2300      	movs	r3, #0
    a77a:	9308      	str	r3, [sp, #32]
    a77c:	2300      	movs	r3, #0
    a77e:	9307      	str	r3, [sp, #28]
    volatile uint32 * FilterTable = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_RX_FIFO_FILTER_TABLE_OFFSET);
    a780:	9b03      	ldr	r3, [sp, #12]
    a782:	33e0      	adds	r3, #224	; 0xe0
    a784:	9306      	str	r3, [sp, #24]

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert((idFilterTable != NULL_PTR) || (FLEXCAN_RX_FIFO_ID_FORMAT_D == idFormat));
    #endif

    NumOfFilters = (((base->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    a786:	9b03      	ldr	r3, [sp, #12]
    a788:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a78a:	0e1b      	lsrs	r3, r3, #24
    a78c:	f003 030f 	and.w	r3, r3, #15
    a790:	9305      	str	r3, [sp, #20]
    a792:	9b02      	ldr	r3, [sp, #8]
    a794:	2b03      	cmp	r3, #3
    a796:	f200 81e7 	bhi.w	ab68 <FlexCAN_SetRxFifoFilter+0x3fe>
    a79a:	a201      	add	r2, pc, #4	; (adr r2, a7a0 <FlexCAN_SetRxFifoFilter+0x36>)
    a79c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    a7a0:	0000a7b1 	.word	0x0000a7b1
    a7a4:	0000a84b 	.word	0x0000a84b
    a7a8:	0000a985 	.word	0x0000a985
    a7ac:	0000ab53 	.word	0x0000ab53
    switch (idFormat)
    {
        case (FLEXCAN_RX_FIFO_ID_FORMAT_A):
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a7b0:	f000 ff52 	bl	b658 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            /* One full ID (standard and extended) per ID Filter Table element.*/
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    a7b4:	9b03      	ldr	r3, [sp, #12]
    a7b6:	681b      	ldr	r3, [r3, #0]
    a7b8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
            (base->MCR) =
    a7bc:	9b03      	ldr	r3, [sp, #12]
    a7be:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_A)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a7c0:	f000 ff76 	bl	b6b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    a7c4:	2300      	movs	r3, #0
    a7c6:	930b      	str	r3, [sp, #44]	; 0x2c
    a7c8:	e038      	b.n	a83c <FlexCAN_SetRxFifoFilter+0xd2>
            {
                Val = 0UL;
    a7ca:	2300      	movs	r3, #0
    a7cc:	9307      	str	r3, [sp, #28]

                if (idFilterTable[i].isRemoteFrame)
    a7ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a7d0:	00db      	lsls	r3, r3, #3
    a7d2:	9a01      	ldr	r2, [sp, #4]
    a7d4:	4413      	add	r3, r2
    a7d6:	781b      	ldrb	r3, [r3, #0]
    a7d8:	2b00      	cmp	r3, #0
    a7da:	d002      	beq.n	a7e2 <FlexCAN_SetRxFifoFilter+0x78>
                {
                    Val = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    a7dc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    a7e0:	9307      	str	r3, [sp, #28]
                }

                if (idFilterTable[i].isExtendedFrame)
    a7e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a7e4:	00db      	lsls	r3, r3, #3
    a7e6:	9a01      	ldr	r2, [sp, #4]
    a7e8:	4413      	add	r3, r2
    a7ea:	785b      	ldrb	r3, [r3, #1]
    a7ec:	2b00      	cmp	r3, #0
    a7ee:	d013      	beq.n	a818 <FlexCAN_SetRxFifoFilter+0xae>
                {
                    Val |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    a7f0:	9b07      	ldr	r3, [sp, #28]
    a7f2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    a7f6:	9307      	str	r3, [sp, #28]
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) &
    a7f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a7fa:	00db      	lsls	r3, r3, #3
    a7fc:	9a01      	ldr	r2, [sp, #4]
    a7fe:	4413      	add	r3, r2
    a800:	685b      	ldr	r3, [r3, #4]
    a802:	005b      	lsls	r3, r3, #1
    a804:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
    a808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a80a:	009b      	lsls	r3, r3, #2
    a80c:	9a06      	ldr	r2, [sp, #24]
    a80e:	4413      	add	r3, r2
    a810:	9a07      	ldr	r2, [sp, #28]
    a812:	440a      	add	r2, r1
    a814:	601a      	str	r2, [r3, #0]
    a816:	e00e      	b.n	a836 <FlexCAN_SetRxFifoFilter+0xcc>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK
                                           );
                }
                else
                {
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) &
    a818:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a81a:	00db      	lsls	r3, r3, #3
    a81c:	9a01      	ldr	r2, [sp, #4]
    a81e:	4413      	add	r3, r2
    a820:	685b      	ldr	r3, [r3, #4]
    a822:	04da      	lsls	r2, r3, #19
    a824:	4b9d      	ldr	r3, [pc, #628]	; (aa9c <FlexCAN_SetRxFifoFilter+0x332>)
    a826:	4013      	ands	r3, r2
    a828:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a82a:	0092      	lsls	r2, r2, #2
    a82c:	9906      	ldr	r1, [sp, #24]
    a82e:	440a      	add	r2, r1
    a830:	9907      	ldr	r1, [sp, #28]
    a832:	440b      	add	r3, r1
    a834:	6013      	str	r3, [r2, #0]
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    a836:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a838:	3301      	adds	r3, #1
    a83a:	930b      	str	r3, [sp, #44]	; 0x2c
    a83c:	9b05      	ldr	r3, [sp, #20]
    a83e:	3301      	adds	r3, #1
    a840:	00db      	lsls	r3, r3, #3
    a842:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a844:	429a      	cmp	r2, r3
    a846:	d3c0      	bcc.n	a7ca <FlexCAN_SetRxFifoFilter+0x60>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_MASK
                                           );
                }
            }
            break;
    a848:	e18f      	b.n	ab6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_B):
            /* Two full standard IDs or two partial 14-bit (standard and extended) IDs*/
            /* per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a84a:	f000 ff05 	bl	b658 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) | ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_B)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
    a84e:	9b03      	ldr	r3, [sp, #12]
    a850:	681b      	ldr	r3, [r3, #0]
    a852:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    a856:	f443 7280 	orr.w	r2, r3, #256	; 0x100
            (base->MCR) =
    a85a:	9b03      	ldr	r3, [sp, #12]
    a85c:	601a      	str	r2, [r3, #0]
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a85e:	f000 ff27 	bl	b6b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    a862:	2300      	movs	r3, #0
    a864:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    a866:	2300      	movs	r3, #0
    a868:	930b      	str	r3, [sp, #44]	; 0x2c
    a86a:	e083      	b.n	a974 <FlexCAN_SetRxFifoFilter+0x20a>
            {
                Val1 = 0U;
    a86c:	2300      	movs	r3, #0
    a86e:	9309      	str	r3, [sp, #36]	; 0x24
                Val2 = 0U;
    a870:	2300      	movs	r3, #0
    a872:	9308      	str	r3, [sp, #32]

                if (idFilterTable[j].isRemoteFrame)
    a874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a876:	00db      	lsls	r3, r3, #3
    a878:	9a01      	ldr	r2, [sp, #4]
    a87a:	4413      	add	r3, r2
    a87c:	781b      	ldrb	r3, [r3, #0]
    a87e:	2b00      	cmp	r3, #0
    a880:	d002      	beq.n	a888 <FlexCAN_SetRxFifoFilter+0x11e>
                {
                    Val1 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    a882:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    a886:	9309      	str	r3, [sp, #36]	; 0x24
                }

                if (idFilterTable[j + 1U].isRemoteFrame)
    a888:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a88a:	3301      	adds	r3, #1
    a88c:	00db      	lsls	r3, r3, #3
    a88e:	9a01      	ldr	r2, [sp, #4]
    a890:	4413      	add	r3, r2
    a892:	781b      	ldrb	r3, [r3, #0]
    a894:	2b00      	cmp	r3, #0
    a896:	d002      	beq.n	a89e <FlexCAN_SetRxFifoFilter+0x134>
                {
                    Val2 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;
    a898:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    a89c:	9308      	str	r3, [sp, #32]
                }

                if (idFilterTable[j].isExtendedFrame)
    a89e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a8a0:	00db      	lsls	r3, r3, #3
    a8a2:	9a01      	ldr	r2, [sp, #4]
    a8a4:	4413      	add	r3, r2
    a8a6:	785b      	ldrb	r3, [r3, #1]
    a8a8:	2b00      	cmp	r3, #0
    a8aa:	d014      	beq.n	a8d6 <FlexCAN_SetRxFifoFilter+0x16c>
                {
                    Val1 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    a8ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a8ae:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    a8b2:	9309      	str	r3, [sp, #36]	; 0x24

                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    a8b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a8b6:	00db      	lsls	r3, r3, #3
    a8b8:	9a01      	ldr	r2, [sp, #4]
    a8ba:	4413      	add	r3, r2
    a8bc:	685b      	ldr	r3, [r3, #4]
    a8be:	0bdb      	lsrs	r3, r3, #15
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1
    a8c0:	041a      	lsls	r2, r3, #16
    a8c2:	4b77      	ldr	r3, [pc, #476]	; (aaa0 <FlexCAN_SetRxFifoFilter+0x336>)
    a8c4:	4013      	ands	r3, r2
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    a8c6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a8c8:	0092      	lsls	r2, r2, #2
    a8ca:	9906      	ldr	r1, [sp, #24]
    a8cc:	440a      	add	r2, r1
    a8ce:	9909      	ldr	r1, [sp, #36]	; 0x24
    a8d0:	440b      	add	r3, r1
    a8d2:	6013      	str	r3, [r2, #0]
    a8d4:	e00e      	b.n	a8f4 <FlexCAN_SetRxFifoFilter+0x18a>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + ((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    a8d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a8d8:	00db      	lsls	r3, r3, #3
    a8da:	9a01      	ldr	r2, [sp, #4]
    a8dc:	4413      	add	r3, r2
    a8de:	685b      	ldr	r3, [r3, #4]
    a8e0:	04da      	lsls	r2, r3, #19
    a8e2:	4b6e      	ldr	r3, [pc, #440]	; (aa9c <FlexCAN_SetRxFifoFilter+0x332>)
    a8e4:	4013      	ands	r3, r2
    a8e6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a8e8:	0092      	lsls	r2, r2, #2
    a8ea:	9906      	ldr	r1, [sp, #24]
    a8ec:	440a      	add	r2, r1
    a8ee:	9909      	ldr	r1, [sp, #36]	; 0x24
    a8f0:	440b      	add	r3, r1
    a8f2:	6013      	str	r3, [r2, #0]
                                              FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    a8f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a8f6:	3301      	adds	r3, #1
    a8f8:	00db      	lsls	r3, r3, #3
    a8fa:	9a01      	ldr	r2, [sp, #4]
    a8fc:	4413      	add	r3, r2
    a8fe:	785b      	ldrb	r3, [r3, #1]
    a900:	2b00      	cmp	r3, #0
    a902:	d01a      	beq.n	a93a <FlexCAN_SetRxFifoFilter+0x1d0>
                {
                    Val2 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;
    a904:	9b08      	ldr	r3, [sp, #32]
    a906:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    a90a:	9308      	str	r3, [sp, #32]

                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    a90c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a90e:	009b      	lsls	r3, r3, #2
    a910:	9a06      	ldr	r2, [sp, #24]
    a912:	4413      	add	r3, r2
    a914:	6819      	ldr	r1, [r3, #0]
    a916:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a918:	3301      	adds	r3, #1
    a91a:	00db      	lsls	r3, r3, #3
    a91c:	9a01      	ldr	r2, [sp, #4]
    a91e:	4413      	add	r3, r2
    a920:	685b      	ldr	r3, [r3, #4]
    a922:	0bdb      	lsrs	r3, r3, #15
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2
    a924:	f3c3 020d 	ubfx	r2, r3, #0, #14
                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    a928:	9b08      	ldr	r3, [sp, #32]
    a92a:	441a      	add	r2, r3
    a92c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a92e:	009b      	lsls	r3, r3, #2
    a930:	9806      	ldr	r0, [sp, #24]
    a932:	4403      	add	r3, r0
    a934:	430a      	orrs	r2, r1
    a936:	601a      	str	r2, [r3, #0]
    a938:	e016      	b.n	a968 <FlexCAN_SetRxFifoFilter+0x1fe>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val2 + ((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    a93a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a93c:	009b      	lsls	r3, r3, #2
    a93e:	9a06      	ldr	r2, [sp, #24]
    a940:	4413      	add	r3, r2
    a942:	6819      	ldr	r1, [r3, #0]
    a944:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a946:	3301      	adds	r3, #1
    a948:	00db      	lsls	r3, r3, #3
    a94a:	9a01      	ldr	r2, [sp, #4]
    a94c:	4413      	add	r3, r2
    a94e:	685b      	ldr	r3, [r3, #4]
    a950:	00da      	lsls	r2, r3, #3
    a952:	f643 73f8 	movw	r3, #16376	; 0x3ff8
    a956:	4013      	ands	r3, r2
    a958:	9a08      	ldr	r2, [sp, #32]
    a95a:	441a      	add	r2, r3
    a95c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a95e:	009b      	lsls	r3, r3, #2
    a960:	9806      	ldr	r0, [sp, #24]
    a962:	4403      	add	r3, r0
    a964:	430a      	orrs	r2, r1
    a966:	601a      	str	r2, [r3, #0]
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2
                                             );
                }

                j = j + 2U;
    a968:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a96a:	3302      	adds	r3, #2
    a96c:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    a96e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a970:	3301      	adds	r3, #1
    a972:	930b      	str	r3, [sp, #44]	; 0x2c
    a974:	9b05      	ldr	r3, [sp, #20]
    a976:	3301      	adds	r3, #1
    a978:	00db      	lsls	r3, r3, #3
    a97a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a97c:	429a      	cmp	r2, r3
    a97e:	f4ff af75 	bcc.w	a86c <FlexCAN_SetRxFifoFilter+0x102>
            }
            break;
    a982:	e0f2      	b.n	ab6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_C):
            /* Four partial 8-bit Standard IDs per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a984:	f000 fe68 	bl	b658 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    a988:	9b03      	ldr	r3, [sp, #12]
    a98a:	681b      	ldr	r3, [r3, #0]
    a98c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    a990:	f443 7200 	orr.w	r2, r3, #512	; 0x200
            (base->MCR) =
    a994:	9b03      	ldr	r3, [sp, #12]
    a996:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_C)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    a998:	f000 fe8a 	bl	b6b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    a99c:	2300      	movs	r3, #0
    a99e:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    a9a0:	2300      	movs	r3, #0
    a9a2:	930b      	str	r3, [sp, #44]	; 0x2c
    a9a4:	e0cd      	b.n	ab42 <FlexCAN_SetRxFifoFilter+0x3d8>
            {
                if (idFilterTable[j].isExtendedFrame)
    a9a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9a8:	00db      	lsls	r3, r3, #3
    a9aa:	9a01      	ldr	r2, [sp, #4]
    a9ac:	4413      	add	r3, r2
    a9ae:	785b      	ldrb	r3, [r3, #1]
    a9b0:	2b00      	cmp	r3, #0
    a9b2:	d00e      	beq.n	a9d2 <FlexCAN_SetRxFifoFilter+0x268>
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    a9b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9b6:	00db      	lsls	r3, r3, #3
    a9b8:	9a01      	ldr	r2, [sp, #4]
    a9ba:	4413      	add	r3, r2
    a9bc:	685b      	ldr	r3, [r3, #4]
    a9be:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    a9c0:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    a9c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a9c4:	009b      	lsls	r3, r3, #2
    a9c6:	9a06      	ldr	r2, [sp, #24]
    a9c8:	4413      	add	r3, r2
    a9ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a9cc:	440a      	add	r2, r1
    a9ce:	601a      	str	r2, [r3, #0]
    a9d0:	e00d      	b.n	a9ee <FlexCAN_SetRxFifoFilter+0x284>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    a9d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9d4:	00db      	lsls	r3, r3, #3
    a9d6:	9a01      	ldr	r2, [sp, #4]
    a9d8:	4413      	add	r3, r2
    a9da:	685b      	ldr	r3, [r3, #4]
    a9dc:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    a9de:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    a9e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a9e2:	009b      	lsls	r3, r3, #2
    a9e4:	9a06      	ldr	r2, [sp, #24]
    a9e6:	4413      	add	r3, r2
    a9e8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a9ea:	440a      	add	r2, r1
    a9ec:	601a      	str	r2, [r3, #0]
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    a9ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9f0:	3301      	adds	r3, #1
    a9f2:	00db      	lsls	r3, r3, #3
    a9f4:	9a01      	ldr	r2, [sp, #4]
    a9f6:	4413      	add	r3, r2
    a9f8:	785b      	ldrb	r3, [r3, #1]
    a9fa:	2b00      	cmp	r3, #0
    a9fc:	d017      	beq.n	aa2e <FlexCAN_SetRxFifoFilter+0x2c4>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    a9fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa00:	009b      	lsls	r3, r3, #2
    aa02:	9a06      	ldr	r2, [sp, #24]
    aa04:	4413      	add	r3, r2
    aa06:	6819      	ldr	r1, [r3, #0]
    aa08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aa0a:	3301      	adds	r3, #1
    aa0c:	00db      	lsls	r3, r3, #3
    aa0e:	9a01      	ldr	r2, [sp, #4]
    aa10:	4413      	add	r3, r2
    aa12:	685b      	ldr	r3, [r3, #4]
    aa14:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    aa16:	041b      	lsls	r3, r3, #16
    aa18:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    aa1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aa1e:	441a      	add	r2, r3
    aa20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa22:	009b      	lsls	r3, r3, #2
    aa24:	9806      	ldr	r0, [sp, #24]
    aa26:	4403      	add	r3, r0
    aa28:	430a      	orrs	r2, r1
    aa2a:	601a      	str	r2, [r3, #0]
    aa2c:	e016      	b.n	aa5c <FlexCAN_SetRxFifoFilter+0x2f2>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    aa2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa30:	009b      	lsls	r3, r3, #2
    aa32:	9a06      	ldr	r2, [sp, #24]
    aa34:	4413      	add	r3, r2
    aa36:	6819      	ldr	r1, [r3, #0]
    aa38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aa3a:	3301      	adds	r3, #1
    aa3c:	00db      	lsls	r3, r3, #3
    aa3e:	9a01      	ldr	r2, [sp, #4]
    aa40:	4413      	add	r3, r2
    aa42:	685b      	ldr	r3, [r3, #4]
    aa44:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    aa46:	041b      	lsls	r3, r3, #16
    aa48:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    aa4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aa4e:	441a      	add	r2, r3
    aa50:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa52:	009b      	lsls	r3, r3, #2
    aa54:	9806      	ldr	r0, [sp, #24]
    aa56:	4403      	add	r3, r0
    aa58:	430a      	orrs	r2, r1
    aa5a:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 2U].isExtendedFrame)
    aa5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aa5e:	3302      	adds	r3, #2
    aa60:	00db      	lsls	r3, r3, #3
    aa62:	9a01      	ldr	r2, [sp, #4]
    aa64:	4413      	add	r3, r2
    aa66:	785b      	ldrb	r3, [r3, #1]
    aa68:	2b00      	cmp	r3, #0
    aa6a:	d01b      	beq.n	aaa4 <FlexCAN_SetRxFifoFilter+0x33a>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    aa6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa6e:	009b      	lsls	r3, r3, #2
    aa70:	9a06      	ldr	r2, [sp, #24]
    aa72:	4413      	add	r3, r2
    aa74:	6819      	ldr	r1, [r3, #0]
    aa76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aa78:	3302      	adds	r3, #2
    aa7a:	00db      	lsls	r3, r3, #3
    aa7c:	9a01      	ldr	r2, [sp, #4]
    aa7e:	4413      	add	r3, r2
    aa80:	685b      	ldr	r3, [r3, #4]
    aa82:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    aa84:	021b      	lsls	r3, r3, #8
    aa86:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    aa88:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aa8a:	441a      	add	r2, r3
    aa8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aa8e:	009b      	lsls	r3, r3, #2
    aa90:	9806      	ldr	r0, [sp, #24]
    aa92:	4403      	add	r3, r0
    aa94:	430a      	orrs	r2, r1
    aa96:	601a      	str	r2, [r3, #0]
    aa98:	e01a      	b.n	aad0 <FlexCAN_SetRxFifoFilter+0x366>
    aa9a:	bf00      	nop
    aa9c:	3ff80000 	.word	0x3ff80000
    aaa0:	3fff0000 	.word	0x3fff0000
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    aaa4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aaa6:	009b      	lsls	r3, r3, #2
    aaa8:	9a06      	ldr	r2, [sp, #24]
    aaaa:	4413      	add	r3, r2
    aaac:	6819      	ldr	r1, [r3, #0]
    aaae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aab0:	3302      	adds	r3, #2
    aab2:	00db      	lsls	r3, r3, #3
    aab4:	9a01      	ldr	r2, [sp, #4]
    aab6:	4413      	add	r3, r2
    aab8:	685b      	ldr	r3, [r3, #4]
    aaba:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    aabc:	021b      	lsls	r3, r3, #8
    aabe:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    aac0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aac2:	441a      	add	r2, r3
    aac4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aac6:	009b      	lsls	r3, r3, #2
    aac8:	9806      	ldr	r0, [sp, #24]
    aaca:	4403      	add	r3, r0
    aacc:	430a      	orrs	r2, r1
    aace:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 3U].isExtendedFrame)
    aad0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aad2:	3303      	adds	r3, #3
    aad4:	00db      	lsls	r3, r3, #3
    aad6:	9a01      	ldr	r2, [sp, #4]
    aad8:	4413      	add	r3, r2
    aada:	785b      	ldrb	r3, [r3, #1]
    aadc:	2b00      	cmp	r3, #0
    aade:	d015      	beq.n	ab0c <FlexCAN_SetRxFifoFilter+0x3a2>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    aae0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aae2:	009b      	lsls	r3, r3, #2
    aae4:	9a06      	ldr	r2, [sp, #24]
    aae6:	4413      	add	r3, r2
    aae8:	6819      	ldr	r1, [r3, #0]
    aaea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    aaec:	3303      	adds	r3, #3
    aaee:	00db      	lsls	r3, r3, #3
    aaf0:	9a01      	ldr	r2, [sp, #4]
    aaf2:	4413      	add	r3, r2
    aaf4:	685b      	ldr	r3, [r3, #4]
    aaf6:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    aaf8:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    aafa:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aafc:	441a      	add	r2, r3
    aafe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab00:	009b      	lsls	r3, r3, #2
    ab02:	9806      	ldr	r0, [sp, #24]
    ab04:	4403      	add	r3, r0
    ab06:	430a      	orrs	r2, r1
    ab08:	601a      	str	r2, [r3, #0]
    ab0a:	e014      	b.n	ab36 <FlexCAN_SetRxFifoFilter+0x3cc>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 +
    ab0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab0e:	009b      	lsls	r3, r3, #2
    ab10:	9a06      	ldr	r2, [sp, #24]
    ab12:	4413      	add	r3, r2
    ab14:	6819      	ldr	r1, [r3, #0]
                                      (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    ab16:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ab18:	3303      	adds	r3, #3
    ab1a:	00db      	lsls	r3, r3, #3
    ab1c:	9a01      	ldr	r2, [sp, #4]
    ab1e:	4413      	add	r3, r2
    ab20:	685b      	ldr	r3, [r3, #4]
    ab22:	08db      	lsrs	r3, r3, #3
                                        FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                       ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    ab24:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 +
    ab26:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ab28:	441a      	add	r2, r3
    ab2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab2c:	009b      	lsls	r3, r3, #2
    ab2e:	9806      	ldr	r0, [sp, #24]
    ab30:	4403      	add	r3, r0
    ab32:	430a      	orrs	r2, r1
    ab34:	601a      	str	r2, [r3, #0]
                                      );
                }

                j = j + 4U;
    ab36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ab38:	3304      	adds	r3, #4
    ab3a:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    ab3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab3e:	3301      	adds	r3, #1
    ab40:	930b      	str	r3, [sp, #44]	; 0x2c
    ab42:	9b05      	ldr	r3, [sp, #20]
    ab44:	3301      	adds	r3, #1
    ab46:	00db      	lsls	r3, r3, #3
    ab48:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ab4a:	429a      	cmp	r2, r3
    ab4c:	f4ff af2b 	bcc.w	a9a6 <FlexCAN_SetRxFifoFilter+0x23c>
            }
            break;
    ab50:	e00b      	b.n	ab6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_D):
            /* All frames rejected.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    ab52:	f000 fd81 	bl	b658 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    ab56:	9b03      	ldr	r3, [sp, #12]
    ab58:	681b      	ldr	r3, [r3, #0]
    ab5a:	f443 7240 	orr.w	r2, r3, #768	; 0x300
            (base->MCR) =
    ab5e:	9b03      	ldr	r3, [sp, #12]
    ab60:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_D)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    ab62:	f000 fda5 	bl	b6b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            break;
    ab66:	e000      	b.n	ab6a <FlexCAN_SetRxFifoFilter+0x400>
        default:
            /* Should not get here */
            break;
    ab68:	bf00      	nop
    }
}
    ab6a:	bf00      	nop
    ab6c:	b00d      	add	sp, #52	; 0x34
    ab6e:	f85d fb04 	ldr.w	pc, [sp], #4

0000ab72 <FlexCAN_ReadRxFifo>:
 * Description   : Read Rx FIFO data.
 * This function will copy MB[0] data field into user's buffer.
 *
 *END**************************************************************************/
void FlexCAN_ReadRxFifo(const FLEXCAN_Type * base, Flexcan_Ip_MsgBuffType * rxFifo)
{
    ab72:	b500      	push	{lr}
    ab74:	b08b      	sub	sp, #44	; 0x2c
    ab76:	9001      	str	r0, [sp, #4]
    ab78:	9100      	str	r1, [sp, #0]
    uint32 x;
    uint8 Index;
    const uint8 * p;
    #endif

    volatile const uint32 * flexcan_mb = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    ab7a:	9b01      	ldr	r3, [sp, #4]
    ab7c:	3380      	adds	r3, #128	; 0x80
    ab7e:	9307      	str	r3, [sp, #28]
    volatile const uint32 * flexcan_mb_id = &flexcan_mb[1];
    ab80:	9b07      	ldr	r3, [sp, #28]
    ab82:	3304      	adds	r3, #4
    ab84:	9306      	str	r3, [sp, #24]
    volatile const uint32 * flexcan_mb_data_32 = &flexcan_mb[2];
    ab86:	9b07      	ldr	r3, [sp, #28]
    ab88:	3308      	adds	r3, #8
    ab8a:	9305      	str	r3, [sp, #20]
    uint32 * msgData_32 = NULL_PTR;
    ab8c:	2300      	movs	r3, #0
    ab8e:	9304      	str	r3, [sp, #16]
    uint8 flexcan_mb_dlc_value = (uint8)(((*flexcan_mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    ab90:	9b07      	ldr	r3, [sp, #28]
    ab92:	681b      	ldr	r3, [r3, #0]
    ab94:	0c1b      	lsrs	r3, r3, #16
    ab96:	b2db      	uxtb	r3, r3
    ab98:	f003 030f 	and.w	r3, r3, #15
    ab9c:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 can_real_payload = FlexCAN_ComputePayloadSize(flexcan_mb_dlc_value);
    aba0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    aba4:	4618      	mov	r0, r3
    aba6:	f7fe fe6c 	bl	9882 <FlexCAN_ComputePayloadSize>
    abaa:	4603      	mov	r3, r0
    abac:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(rxFifo != NULL_PTR);
    #endif
    msgData_32 = (uint32 *)(rxFifo->data);
    abb0:	9b00      	ldr	r3, [sp, #0]
    abb2:	3308      	adds	r3, #8
    abb4:	9304      	str	r3, [sp, #16]
       Check if the length of received data packet bigger than the maximum length accepted,
       then processing flow shall continue with the maximum length defined by configuration.
       Legacy FIFO just support in normal mode.
    */
    /* no need to check if FD enabled or not because this function just is invoked when legacy fifo enabled only ! */
    if (can_real_payload > 8U)
    abb6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    abba:	2b08      	cmp	r3, #8
    abbc:	d902      	bls.n	abc4 <FlexCAN_ReadRxFifo+0x52>
    {
        can_real_payload = 8U;
    abbe:	2308      	movs	r3, #8
    abc0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    }

    rxFifo->dataLen = can_real_payload;
    abc4:	9b00      	ldr	r3, [sp, #0]
    abc6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    abca:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    rxFifo->cs = *flexcan_mb;
    abce:	9b07      	ldr	r3, [sp, #28]
    abd0:	681a      	ldr	r2, [r3, #0]
    abd2:	9b00      	ldr	r3, [sp, #0]
    abd4:	601a      	str	r2, [r3, #0]
    if ((rxFifo->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    abd6:	9b00      	ldr	r3, [sp, #0]
    abd8:	681b      	ldr	r3, [r3, #0]
    abda:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    abde:	2b00      	cmp	r3, #0
    abe0:	d004      	beq.n	abec <FlexCAN_ReadRxFifo+0x7a>
    {
        rxFifo->msgId = *flexcan_mb_id;
    abe2:	9b06      	ldr	r3, [sp, #24]
    abe4:	681a      	ldr	r2, [r3, #0]
    abe6:	9b00      	ldr	r3, [sp, #0]
    abe8:	605a      	str	r2, [r3, #4]
    abea:	e004      	b.n	abf6 <FlexCAN_ReadRxFifo+0x84>
    }
    else
    {
        rxFifo->msgId = (*flexcan_mb_id) >> FLEXCAN_IP_ID_STD_SHIFT;
    abec:	9b06      	ldr	r3, [sp, #24]
    abee:	681b      	ldr	r3, [r3, #0]
    abf0:	0c9a      	lsrs	r2, r3, #18
    abf2:	9b00      	ldr	r3, [sp, #0]
    abf4:	605a      	str	r2, [r3, #4]
    }
    /* Extract the IDHIT */
    rxFifo->id_hit = (uint8)base->RXFIR;
    abf6:	9b01      	ldr	r3, [sp, #4]
    abf8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    abfa:	b2da      	uxtb	r2, r3
    abfc:	9b00      	ldr	r3, [sp, #0]
    abfe:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
    /* Extract the Time Stamp */
    rxFifo->time_stamp = (uint32)((rxFifo->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    ac02:	9b00      	ldr	r3, [sp, #0]
    ac04:	681b      	ldr	r3, [r3, #0]
    ac06:	b29a      	uxth	r2, r3
    ac08:	9b00      	ldr	r3, [sp, #0]
    ac0a:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, msgData_32[DataByte >> 2U]);
        }
    }
#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
      /* Copy MB[0] data field into user's buffer */
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    ac0c:	2300      	movs	r3, #0
    ac0e:	9309      	str	r3, [sp, #36]	; 0x24
    ac10:	e01f      	b.n	ac52 <FlexCAN_ReadRxFifo+0xe0>
    {
        MbWord = flexcan_mb_data_32[DataByte >> 2U];
    ac12:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac14:	089b      	lsrs	r3, r3, #2
    ac16:	009b      	lsls	r3, r3, #2
    ac18:	9a05      	ldr	r2, [sp, #20]
    ac1a:	4413      	add	r3, r2
    ac1c:	681b      	ldr	r3, [r3, #0]
    ac1e:	9302      	str	r3, [sp, #8]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (msgData_32[DataByte >> 2U]));
    ac20:	9b02      	ldr	r3, [sp, #8]
    ac22:	0e1a      	lsrs	r2, r3, #24
    ac24:	9b02      	ldr	r3, [sp, #8]
    ac26:	0a1b      	lsrs	r3, r3, #8
    ac28:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    ac2c:	431a      	orrs	r2, r3
    ac2e:	9b02      	ldr	r3, [sp, #8]
    ac30:	021b      	lsls	r3, r3, #8
    ac32:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    ac36:	ea42 0103 	orr.w	r1, r2, r3
    ac3a:	9b02      	ldr	r3, [sp, #8]
    ac3c:	061a      	lsls	r2, r3, #24
    ac3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac40:	089b      	lsrs	r3, r3, #2
    ac42:	009b      	lsls	r3, r3, #2
    ac44:	9804      	ldr	r0, [sp, #16]
    ac46:	4403      	add	r3, r0
    ac48:	430a      	orrs	r2, r1
    ac4a:	601a      	str	r2, [r3, #0]
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    ac4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac4e:	3304      	adds	r3, #4
    ac50:	9309      	str	r3, [sp, #36]	; 0x24
    ac52:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    ac56:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ac58:	429a      	cmp	r2, r3
    ac5a:	d3da      	bcc.n	ac12 <FlexCAN_ReadRxFifo+0xa0>
    }
#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
}
    ac5c:	bf00      	nop
    ac5e:	bf00      	nop
    ac60:	b00b      	add	sp, #44	; 0x2c
    ac62:	f85d fb04 	ldr.w	pc, [sp], #4

0000ac66 <FlexCAN_IsMbOutOfRange>:
    const FLEXCAN_Type * pBase,
    uint8 u8MbIndex,
    boolean bIsLegacyFifoEn,
    uint32 u32MaxMbNum
)
{
    ac66:	b088      	sub	sp, #32
    ac68:	9003      	str	r0, [sp, #12]
    ac6a:	9301      	str	r3, [sp, #4]
    ac6c:	460b      	mov	r3, r1
    ac6e:	f88d 300b 	strb.w	r3, [sp, #11]
    ac72:	4613      	mov	r3, r2
    ac74:	f88d 300a 	strb.w	r3, [sp, #10]
    boolean ReturnValue = FALSE;
    ac78:	2300      	movs	r3, #0
    ac7a:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32NumOfFiFoElement = 0U;
    ac7e:	2300      	movs	r3, #0
    ac80:	9306      	str	r3, [sp, #24]
    uint32 u32NumOfMbOccupiedByFiFo = 0U;
    ac82:	2300      	movs	r3, #0
    ac84:	9305      	str	r3, [sp, #20]

    if (u8MbIndex >= (uint8)u32MaxMbNum)
    ac86:	9b01      	ldr	r3, [sp, #4]
    ac88:	b2db      	uxtb	r3, r3
    ac8a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    ac8e:	429a      	cmp	r2, r3
    ac90:	d303      	bcc.n	ac9a <FlexCAN_IsMbOutOfRange+0x34>
    {
       ReturnValue = TRUE;
    ac92:	2301      	movs	r3, #1
    ac94:	f88d 301f 	strb.w	r3, [sp, #31]
    ac98:	e01b      	b.n	acd2 <FlexCAN_IsMbOutOfRange+0x6c>
    }
    /* Check if RX FIFO is enabled*/
    else if (TRUE == bIsLegacyFifoEn)
    ac9a:	f89d 300a 	ldrb.w	r3, [sp, #10]
    ac9e:	2b00      	cmp	r3, #0
    aca0:	d014      	beq.n	accc <FlexCAN_IsMbOutOfRange+0x66>
    {
        /* Get the number of RX FIFO Filters*/
        u32NumOfFiFoElement = (((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    aca2:	9b03      	ldr	r3, [sp, #12]
    aca4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    aca6:	0e1b      	lsrs	r3, r3, #24
    aca8:	f003 030f 	and.w	r3, r3, #15
    acac:	9306      	str	r3, [sp, #24]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        u32NumOfMbOccupiedByFiFo = 5U + ((((u32NumOfFiFoElement) + 1U) * 8U) / 4U);
    acae:	9b06      	ldr	r3, [sp, #24]
    acb0:	3301      	adds	r3, #1
    acb2:	00db      	lsls	r3, r3, #3
    acb4:	089b      	lsrs	r3, r3, #2
    acb6:	3305      	adds	r3, #5
    acb8:	9305      	str	r3, [sp, #20]
        if (u8MbIndex <= u32NumOfMbOccupiedByFiFo)
    acba:	f89d 300b 	ldrb.w	r3, [sp, #11]
    acbe:	9a05      	ldr	r2, [sp, #20]
    acc0:	429a      	cmp	r2, r3
    acc2:	d306      	bcc.n	acd2 <FlexCAN_IsMbOutOfRange+0x6c>
        {
            ReturnValue = TRUE;
    acc4:	2301      	movs	r3, #1
    acc6:	f88d 301f 	strb.w	r3, [sp, #31]
    acca:	e002      	b.n	acd2 <FlexCAN_IsMbOutOfRange+0x6c>
        }
    }
    else
    {
        ReturnValue = FALSE;
    accc:	2300      	movs	r3, #0
    acce:	f88d 301f 	strb.w	r3, [sp, #31]
    }

    return ReturnValue;
    acd2:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    acd6:	4618      	mov	r0, r3
    acd8:	b008      	add	sp, #32
    acda:	4770      	bx	lr

0000acdc <FlexCAN_ConfigCtrlOptions>:
 * Description   : configure controller depending on options
 * note: should be call after FD configuration.
 *
 *END**************************************************************************/
void FlexCAN_ConfigCtrlOptions(FLEXCAN_Type * pBase, uint32 u32Options)
{
    acdc:	b500      	push	{lr}
    acde:	b083      	sub	sp, #12
    ace0:	9001      	str	r0, [sp, #4]
    ace2:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON)
    /* If the FD feature is enabled, in order to be ISO-compliant. */
    if ((u32Options & FLEXCAN_IP_ISO_U32) != 0U)
    ace4:	9b00      	ldr	r3, [sp, #0]
    ace6:	f003 0320 	and.w	r3, r3, #32
    acea:	2b00      	cmp	r3, #0
    acec:	d004      	beq.n	acf8 <FlexCAN_ConfigCtrlOptions+0x1c>
    {
        FlexCAN_SetIsoCan(pBase, TRUE);
    acee:	2101      	movs	r1, #1
    acf0:	9801      	ldr	r0, [sp, #4]
    acf2:	f7fe fcd8 	bl	96a6 <FlexCAN_SetIsoCan>
    acf6:	e003      	b.n	ad00 <FlexCAN_ConfigCtrlOptions+0x24>
    }
    else
    {
        /* This maybe don't have sense if the Deinit returns the state of registers at init values */
        FlexCAN_SetIsoCan(pBase, FALSE);
    acf8:	2100      	movs	r1, #0
    acfa:	9801      	ldr	r0, [sp, #4]
    acfc:	f7fe fcd3 	bl	96a6 <FlexCAN_SetIsoCan>
    }
#endif /*(FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON) */
    /* Set Entire Frame Arbitration Field Comparison. */
    if ((u32Options & FLEXCAN_IP_EACEN_U32) != 0U)
    ad00:	9b00      	ldr	r3, [sp, #0]
    ad02:	f003 0340 	and.w	r3, r3, #64	; 0x40
    ad06:	2b00      	cmp	r3, #0
    ad08:	d004      	beq.n	ad14 <FlexCAN_ConfigCtrlOptions+0x38>
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, TRUE);
    ad0a:	2101      	movs	r1, #1
    ad0c:	9801      	ldr	r0, [sp, #4]
    ad0e:	f7fe fce1 	bl	96d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    ad12:	e003      	b.n	ad1c <FlexCAN_ConfigCtrlOptions+0x40>
    }
    else
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, FALSE);
    ad14:	2100      	movs	r1, #0
    ad16:	9801      	ldr	r0, [sp, #4]
    ad18:	f7fe fcdc 	bl	96d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    }
#if (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)
    /* Set protocol Exception */
    if ((u32Options & FLEXCAN_IP_PROTOCOL_EXCEPTION_U32) != 0U)
    ad1c:	9b00      	ldr	r3, [sp, #0]
    ad1e:	f003 0308 	and.w	r3, r3, #8
    ad22:	2b00      	cmp	r3, #0
    ad24:	d004      	beq.n	ad30 <FlexCAN_ConfigCtrlOptions+0x54>
    {
        FlexCAN_SetProtocolException(pBase, TRUE);
    ad26:	2101      	movs	r1, #1
    ad28:	9801      	ldr	r0, [sp, #4]
    ad2a:	f7fe fcea 	bl	9702 <FlexCAN_SetProtocolException>
    ad2e:	e003      	b.n	ad38 <FlexCAN_ConfigCtrlOptions+0x5c>
    }
    else
    {
        FlexCAN_SetProtocolException(pBase, FALSE);
    ad30:	2100      	movs	r1, #0
    ad32:	9801      	ldr	r0, [sp, #4]
    ad34:	f7fe fce5 	bl	9702 <FlexCAN_SetProtocolException>
    }
#endif /* Endif  (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)  */
    /* Set CAN Bit Sampling */
    if (((u32Options & FLEXCAN_IP_THREE_SAMPLES_U32) != 0U) && (0U == (pBase->MCR & FLEXCAN_MCR_FDEN_MASK)))
    ad38:	9b00      	ldr	r3, [sp, #0]
    ad3a:	f003 0302 	and.w	r3, r3, #2
    ad3e:	2b00      	cmp	r3, #0
    ad40:	d00a      	beq.n	ad58 <FlexCAN_ConfigCtrlOptions+0x7c>
    ad42:	9b01      	ldr	r3, [sp, #4]
    ad44:	681b      	ldr	r3, [r3, #0]
    ad46:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    ad4a:	2b00      	cmp	r3, #0
    ad4c:	d104      	bne.n	ad58 <FlexCAN_ConfigCtrlOptions+0x7c>
    {
        FlexCAN_CanBitSampling(pBase, TRUE);
    ad4e:	2101      	movs	r1, #1
    ad50:	9801      	ldr	r0, [sp, #4]
    ad52:	f7fe fd31 	bl	97b8 <FlexCAN_CanBitSampling>
    ad56:	e003      	b.n	ad60 <FlexCAN_ConfigCtrlOptions+0x84>
    }
    else
    {
        FlexCAN_CanBitSampling(pBase, FALSE);
    ad58:	2100      	movs	r1, #0
    ad5a:	9801      	ldr	r0, [sp, #4]
    ad5c:	f7fe fd2c 	bl	97b8 <FlexCAN_CanBitSampling>
    }

    /* Set AutoBusOff Recovery */
    if ((u32Options & FLEXCAN_IP_BUSOFF_RECOVERY_U32) != 0U)
    ad60:	9b00      	ldr	r3, [sp, #0]
    ad62:	f003 0304 	and.w	r3, r3, #4
    ad66:	2b00      	cmp	r3, #0
    ad68:	d004      	beq.n	ad74 <FlexCAN_ConfigCtrlOptions+0x98>
    {
        FlexCAN_SetBusOffAutorecovery(pBase, TRUE);
    ad6a:	2101      	movs	r1, #1
    ad6c:	9801      	ldr	r0, [sp, #4]
    ad6e:	f7fe fcf6 	bl	975e <FlexCAN_SetBusOffAutorecovery>
    ad72:	e003      	b.n	ad7c <FlexCAN_ConfigCtrlOptions+0xa0>
    }
    else
    {
        FlexCAN_SetBusOffAutorecovery(pBase, FALSE);
    ad74:	2100      	movs	r1, #0
    ad76:	9801      	ldr	r0, [sp, #4]
    ad78:	f7fe fcf1 	bl	975e <FlexCAN_SetBusOffAutorecovery>
    }
    /* Set Remote Request Store for received of Remote Request Frames */
    if ((u32Options & FLEXCAN_IP_REM_STORE_U32) != 0U)
    ad7c:	9b00      	ldr	r3, [sp, #0]
    ad7e:	f003 0301 	and.w	r3, r3, #1
    ad82:	2b00      	cmp	r3, #0
    ad84:	d004      	beq.n	ad90 <FlexCAN_ConfigCtrlOptions+0xb4>
    {
        FlexCAN_SetRemoteReqStore(pBase, TRUE);
    ad86:	2101      	movs	r1, #1
    ad88:	9801      	ldr	r0, [sp, #4]
    ad8a:	f7fe fcd1 	bl	9730 <FlexCAN_SetRemoteReqStore>
    ad8e:	e003      	b.n	ad98 <FlexCAN_ConfigCtrlOptions+0xbc>
    }
    else
    {
        FlexCAN_SetRemoteReqStore(pBase, FALSE);
    ad90:	2100      	movs	r1, #0
    ad92:	9801      	ldr	r0, [sp, #4]
    ad94:	f7fe fccc 	bl	9730 <FlexCAN_SetRemoteReqStore>
    }
#if (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)
    /* Set Edge Filter */
    if ((u32Options & FLEXCAN_IP_EDGE_FILTER_U32) != 0U)
    ad98:	9b00      	ldr	r3, [sp, #0]
    ad9a:	f003 0310 	and.w	r3, r3, #16
    ad9e:	2b00      	cmp	r3, #0
    ada0:	d004      	beq.n	adac <FlexCAN_ConfigCtrlOptions+0xd0>
    {
        FlexCAN_SetEdgeFilter(pBase, TRUE);
    ada2:	2101      	movs	r1, #1
    ada4:	9801      	ldr	r0, [sp, #4]
    ada6:	f7fe fcf0 	bl	978a <FlexCAN_SetEdgeFilter>
    else
    {
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    }
#endif /* End of (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)  */
}
    adaa:	e003      	b.n	adb4 <FlexCAN_ConfigCtrlOptions+0xd8>
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    adac:	2100      	movs	r1, #0
    adae:	9801      	ldr	r0, [sp, #4]
    adb0:	f7fe fceb 	bl	978a <FlexCAN_SetEdgeFilter>
}
    adb4:	bf00      	nop
    adb6:	b003      	add	sp, #12
    adb8:	f85d fb04 	ldr.w	pc, [sp], #4

0000adbc <FlexCAN_ResetImaskBuff>:
 * Function Name : FlexCAN_ResetImaskBuff (uses in FlexCAN_Ip_Init function only)
 * Description   : Reset Imask Buffers.
 *
 *END**************************************************************************/
void FlexCAN_ResetImaskBuff(uint8 Instance)
{
    adbc:	b084      	sub	sp, #16
    adbe:	4603      	mov	r3, r0
    adc0:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ImaskCnt = 0U;
    adc4:	2300      	movs	r3, #0
    adc6:	f88d 300f 	strb.w	r3, [sp, #15]

    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    adca:	2300      	movs	r3, #0
    adcc:	f88d 300f 	strb.w	r3, [sp, #15]
    add0:	e00d      	b.n	adee <FlexCAN_ResetImaskBuff+0x32>
    {
        FlexCAN_Ip_au32ImaskBuff[Instance][ImaskCnt] = 0U;
    add2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    add6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    adda:	4909      	ldr	r1, [pc, #36]	; (ae00 <FlexCAN_ResetImaskBuff+0x44>)
    addc:	4413      	add	r3, r2
    adde:	2200      	movs	r2, #0
    ade0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    ade4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ade8:	3301      	adds	r3, #1
    adea:	f88d 300f 	strb.w	r3, [sp, #15]
    adee:	f89d 300f 	ldrb.w	r3, [sp, #15]
    adf2:	2b00      	cmp	r3, #0
    adf4:	d0ed      	beq.n	add2 <FlexCAN_ResetImaskBuff+0x16>
    }
}
    adf6:	bf00      	nop
    adf8:	bf00      	nop
    adfa:	b004      	add	sp, #16
    adfc:	4770      	bx	lr
    adfe:	bf00      	nop
    ae00:	1fff8f70 	.word	0x1fff8f70

0000ae04 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
    ae04:	b500      	push	{lr}
    ae06:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ae08:	f7f6 f8ec 	bl	fe4 <Sys_GetCoreID>
    ae0c:	4603      	mov	r3, r0
    ae0e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId])
    ae10:	4a10      	ldr	r2, [pc, #64]	; (ae54 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    ae12:	9b01      	ldr	r3, [sp, #4]
    ae14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae18:	2b00      	cmp	r3, #0
    ae1a:	d10d      	bne.n	ae38 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ae1c:	f7f5 fe08 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    ae20:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ae22:	9b00      	ldr	r3, [sp, #0]
    ae24:	f003 0301 	and.w	r3, r3, #1
    ae28:	2b00      	cmp	r3, #0
    ae2a:	d100      	bne.n	ae2e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ae2c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    ae2e:	490a      	ldr	r1, [pc, #40]	; (ae58 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x54>)
    ae30:	9b01      	ldr	r3, [sp, #4]
    ae32:	9a00      	ldr	r2, [sp, #0]
    ae34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]++;
    ae38:	4a06      	ldr	r2, [pc, #24]	; (ae54 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    ae3a:	9b01      	ldr	r3, [sp, #4]
    ae3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae40:	1c5a      	adds	r2, r3, #1
    ae42:	4904      	ldr	r1, [pc, #16]	; (ae54 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
    ae44:	9b01      	ldr	r3, [sp, #4]
    ae46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ae4a:	bf00      	nop
    ae4c:	b003      	add	sp, #12
    ae4e:	f85d fb04 	ldr.w	pc, [sp], #4
    ae52:	bf00      	nop
    ae54:	1fff8f80 	.word	0x1fff8f80
    ae58:	1fff8f7c 	.word	0x1fff8f7c

0000ae5c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
    ae5c:	b500      	push	{lr}
    ae5e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ae60:	f7f6 f8c0 	bl	fe4 <Sys_GetCoreID>
    ae64:	4603      	mov	r3, r0
    ae66:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]--;
    ae68:	4a0d      	ldr	r2, [pc, #52]	; (aea0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    ae6a:	9b01      	ldr	r3, [sp, #4]
    ae6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae70:	1e5a      	subs	r2, r3, #1
    ae72:	490b      	ldr	r1, [pc, #44]	; (aea0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    ae74:	9b01      	ldr	r3, [sp, #4]
    ae76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    ae7a:	4a0a      	ldr	r2, [pc, #40]	; (aea4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x48>)
    ae7c:	9b01      	ldr	r3, [sp, #4]
    ae7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae82:	f003 0301 	and.w	r3, r3, #1
    ae86:	2b00      	cmp	r3, #0
    ae88:	d106      	bne.n	ae98 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    ae8a:	4a05      	ldr	r2, [pc, #20]	; (aea0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
    ae8c:	9b01      	ldr	r3, [sp, #4]
    ae8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae92:	2b00      	cmp	r3, #0
    ae94:	d100      	bne.n	ae98 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ae96:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ae98:	bf00      	nop
    ae9a:	b003      	add	sp, #12
    ae9c:	f85d fb04 	ldr.w	pc, [sp], #4
    aea0:	1fff8f80 	.word	0x1fff8f80
    aea4:	1fff8f7c 	.word	0x1fff8f7c

0000aea8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
    aea8:	b500      	push	{lr}
    aeaa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aeac:	f7f6 f89a 	bl	fe4 <Sys_GetCoreID>
    aeb0:	4603      	mov	r3, r0
    aeb2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId])
    aeb4:	4a10      	ldr	r2, [pc, #64]	; (aef8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    aeb6:	9b01      	ldr	r3, [sp, #4]
    aeb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aebc:	2b00      	cmp	r3, #0
    aebe:	d10d      	bne.n	aedc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    aec0:	f7f5 fdb6 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    aec4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    aec6:	9b00      	ldr	r3, [sp, #0]
    aec8:	f003 0301 	and.w	r3, r3, #1
    aecc:	2b00      	cmp	r3, #0
    aece:	d100      	bne.n	aed2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    aed0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    aed2:	490a      	ldr	r1, [pc, #40]	; (aefc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x54>)
    aed4:	9b01      	ldr	r3, [sp, #4]
    aed6:	9a00      	ldr	r2, [sp, #0]
    aed8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]++;
    aedc:	4a06      	ldr	r2, [pc, #24]	; (aef8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    aede:	9b01      	ldr	r3, [sp, #4]
    aee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aee4:	1c5a      	adds	r2, r3, #1
    aee6:	4904      	ldr	r1, [pc, #16]	; (aef8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
    aee8:	9b01      	ldr	r3, [sp, #4]
    aeea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    aeee:	bf00      	nop
    aef0:	b003      	add	sp, #12
    aef2:	f85d fb04 	ldr.w	pc, [sp], #4
    aef6:	bf00      	nop
    aef8:	1fff8f88 	.word	0x1fff8f88
    aefc:	1fff8f84 	.word	0x1fff8f84

0000af00 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
    af00:	b500      	push	{lr}
    af02:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    af04:	f7f6 f86e 	bl	fe4 <Sys_GetCoreID>
    af08:	4603      	mov	r3, r0
    af0a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]--;
    af0c:	4a0d      	ldr	r2, [pc, #52]	; (af44 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    af0e:	9b01      	ldr	r3, [sp, #4]
    af10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af14:	1e5a      	subs	r2, r3, #1
    af16:	490b      	ldr	r1, [pc, #44]	; (af44 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    af18:	9b01      	ldr	r3, [sp, #4]
    af1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    af1e:	4a0a      	ldr	r2, [pc, #40]	; (af48 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x48>)
    af20:	9b01      	ldr	r3, [sp, #4]
    af22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af26:	f003 0301 	and.w	r3, r3, #1
    af2a:	2b00      	cmp	r3, #0
    af2c:	d106      	bne.n	af3c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    af2e:	4a05      	ldr	r2, [pc, #20]	; (af44 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
    af30:	9b01      	ldr	r3, [sp, #4]
    af32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af36:	2b00      	cmp	r3, #0
    af38:	d100      	bne.n	af3c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    af3a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    af3c:	bf00      	nop
    af3e:	b003      	add	sp, #12
    af40:	f85d fb04 	ldr.w	pc, [sp], #4
    af44:	1fff8f88 	.word	0x1fff8f88
    af48:	1fff8f84 	.word	0x1fff8f84

0000af4c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
    af4c:	b500      	push	{lr}
    af4e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    af50:	f7f6 f848 	bl	fe4 <Sys_GetCoreID>
    af54:	4603      	mov	r3, r0
    af56:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId])
    af58:	4a10      	ldr	r2, [pc, #64]	; (af9c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    af5a:	9b01      	ldr	r3, [sp, #4]
    af5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af60:	2b00      	cmp	r3, #0
    af62:	d10d      	bne.n	af80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    af64:	f7f5 fd64 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    af68:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    af6a:	9b00      	ldr	r3, [sp, #0]
    af6c:	f003 0301 	and.w	r3, r3, #1
    af70:	2b00      	cmp	r3, #0
    af72:	d100      	bne.n	af76 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    af74:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    af76:	490a      	ldr	r1, [pc, #40]	; (afa0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x54>)
    af78:	9b01      	ldr	r3, [sp, #4]
    af7a:	9a00      	ldr	r2, [sp, #0]
    af7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]++;
    af80:	4a06      	ldr	r2, [pc, #24]	; (af9c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    af82:	9b01      	ldr	r3, [sp, #4]
    af84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af88:	1c5a      	adds	r2, r3, #1
    af8a:	4904      	ldr	r1, [pc, #16]	; (af9c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
    af8c:	9b01      	ldr	r3, [sp, #4]
    af8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    af92:	bf00      	nop
    af94:	b003      	add	sp, #12
    af96:	f85d fb04 	ldr.w	pc, [sp], #4
    af9a:	bf00      	nop
    af9c:	1fff8f90 	.word	0x1fff8f90
    afa0:	1fff8f8c 	.word	0x1fff8f8c

0000afa4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
    afa4:	b500      	push	{lr}
    afa6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    afa8:	f7f6 f81c 	bl	fe4 <Sys_GetCoreID>
    afac:	4603      	mov	r3, r0
    afae:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]--;
    afb0:	4a0d      	ldr	r2, [pc, #52]	; (afe8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    afb2:	9b01      	ldr	r3, [sp, #4]
    afb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afb8:	1e5a      	subs	r2, r3, #1
    afba:	490b      	ldr	r1, [pc, #44]	; (afe8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    afbc:	9b01      	ldr	r3, [sp, #4]
    afbe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    afc2:	4a0a      	ldr	r2, [pc, #40]	; (afec <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x48>)
    afc4:	9b01      	ldr	r3, [sp, #4]
    afc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afca:	f003 0301 	and.w	r3, r3, #1
    afce:	2b00      	cmp	r3, #0
    afd0:	d106      	bne.n	afe0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    afd2:	4a05      	ldr	r2, [pc, #20]	; (afe8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
    afd4:	9b01      	ldr	r3, [sp, #4]
    afd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afda:	2b00      	cmp	r3, #0
    afdc:	d100      	bne.n	afe0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    afde:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    afe0:	bf00      	nop
    afe2:	b003      	add	sp, #12
    afe4:	f85d fb04 	ldr.w	pc, [sp], #4
    afe8:	1fff8f90 	.word	0x1fff8f90
    afec:	1fff8f8c 	.word	0x1fff8f8c

0000aff0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
    aff0:	b500      	push	{lr}
    aff2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aff4:	f7f5 fff6 	bl	fe4 <Sys_GetCoreID>
    aff8:	4603      	mov	r3, r0
    affa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId])
    affc:	4a10      	ldr	r2, [pc, #64]	; (b040 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    affe:	9b01      	ldr	r3, [sp, #4]
    b000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b004:	2b00      	cmp	r3, #0
    b006:	d10d      	bne.n	b024 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b008:	f7f5 fd12 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b00c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b00e:	9b00      	ldr	r3, [sp, #0]
    b010:	f003 0301 	and.w	r3, r3, #1
    b014:	2b00      	cmp	r3, #0
    b016:	d100      	bne.n	b01a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b018:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    b01a:	490a      	ldr	r1, [pc, #40]	; (b044 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x54>)
    b01c:	9b01      	ldr	r3, [sp, #4]
    b01e:	9a00      	ldr	r2, [sp, #0]
    b020:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]++;
    b024:	4a06      	ldr	r2, [pc, #24]	; (b040 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    b026:	9b01      	ldr	r3, [sp, #4]
    b028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b02c:	1c5a      	adds	r2, r3, #1
    b02e:	4904      	ldr	r1, [pc, #16]	; (b040 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
    b030:	9b01      	ldr	r3, [sp, #4]
    b032:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b036:	bf00      	nop
    b038:	b003      	add	sp, #12
    b03a:	f85d fb04 	ldr.w	pc, [sp], #4
    b03e:	bf00      	nop
    b040:	1fff8f98 	.word	0x1fff8f98
    b044:	1fff8f94 	.word	0x1fff8f94

0000b048 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
    b048:	b500      	push	{lr}
    b04a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b04c:	f7f5 ffca 	bl	fe4 <Sys_GetCoreID>
    b050:	4603      	mov	r3, r0
    b052:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]--;
    b054:	4a0d      	ldr	r2, [pc, #52]	; (b08c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    b056:	9b01      	ldr	r3, [sp, #4]
    b058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b05c:	1e5a      	subs	r2, r3, #1
    b05e:	490b      	ldr	r1, [pc, #44]	; (b08c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    b060:	9b01      	ldr	r3, [sp, #4]
    b062:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    b066:	4a0a      	ldr	r2, [pc, #40]	; (b090 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x48>)
    b068:	9b01      	ldr	r3, [sp, #4]
    b06a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b06e:	f003 0301 	and.w	r3, r3, #1
    b072:	2b00      	cmp	r3, #0
    b074:	d106      	bne.n	b084 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    b076:	4a05      	ldr	r2, [pc, #20]	; (b08c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
    b078:	9b01      	ldr	r3, [sp, #4]
    b07a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b07e:	2b00      	cmp	r3, #0
    b080:	d100      	bne.n	b084 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b082:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b084:	bf00      	nop
    b086:	b003      	add	sp, #12
    b088:	f85d fb04 	ldr.w	pc, [sp], #4
    b08c:	1fff8f98 	.word	0x1fff8f98
    b090:	1fff8f94 	.word	0x1fff8f94

0000b094 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
    b094:	b500      	push	{lr}
    b096:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b098:	f7f5 ffa4 	bl	fe4 <Sys_GetCoreID>
    b09c:	4603      	mov	r3, r0
    b09e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId])
    b0a0:	4a10      	ldr	r2, [pc, #64]	; (b0e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    b0a2:	9b01      	ldr	r3, [sp, #4]
    b0a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b0a8:	2b00      	cmp	r3, #0
    b0aa:	d10d      	bne.n	b0c8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b0ac:	f7f5 fcc0 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b0b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b0b2:	9b00      	ldr	r3, [sp, #0]
    b0b4:	f003 0301 	and.w	r3, r3, #1
    b0b8:	2b00      	cmp	r3, #0
    b0ba:	d100      	bne.n	b0be <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b0bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    b0be:	490a      	ldr	r1, [pc, #40]	; (b0e8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x54>)
    b0c0:	9b01      	ldr	r3, [sp, #4]
    b0c2:	9a00      	ldr	r2, [sp, #0]
    b0c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]++;
    b0c8:	4a06      	ldr	r2, [pc, #24]	; (b0e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    b0ca:	9b01      	ldr	r3, [sp, #4]
    b0cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b0d0:	1c5a      	adds	r2, r3, #1
    b0d2:	4904      	ldr	r1, [pc, #16]	; (b0e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
    b0d4:	9b01      	ldr	r3, [sp, #4]
    b0d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b0da:	bf00      	nop
    b0dc:	b003      	add	sp, #12
    b0de:	f85d fb04 	ldr.w	pc, [sp], #4
    b0e2:	bf00      	nop
    b0e4:	1fff8fa0 	.word	0x1fff8fa0
    b0e8:	1fff8f9c 	.word	0x1fff8f9c

0000b0ec <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
    b0ec:	b500      	push	{lr}
    b0ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b0f0:	f7f5 ff78 	bl	fe4 <Sys_GetCoreID>
    b0f4:	4603      	mov	r3, r0
    b0f6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]--;
    b0f8:	4a0d      	ldr	r2, [pc, #52]	; (b130 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    b0fa:	9b01      	ldr	r3, [sp, #4]
    b0fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b100:	1e5a      	subs	r2, r3, #1
    b102:	490b      	ldr	r1, [pc, #44]	; (b130 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    b104:	9b01      	ldr	r3, [sp, #4]
    b106:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    b10a:	4a0a      	ldr	r2, [pc, #40]	; (b134 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x48>)
    b10c:	9b01      	ldr	r3, [sp, #4]
    b10e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b112:	f003 0301 	and.w	r3, r3, #1
    b116:	2b00      	cmp	r3, #0
    b118:	d106      	bne.n	b128 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    b11a:	4a05      	ldr	r2, [pc, #20]	; (b130 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
    b11c:	9b01      	ldr	r3, [sp, #4]
    b11e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b122:	2b00      	cmp	r3, #0
    b124:	d100      	bne.n	b128 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b126:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b128:	bf00      	nop
    b12a:	b003      	add	sp, #12
    b12c:	f85d fb04 	ldr.w	pc, [sp], #4
    b130:	1fff8fa0 	.word	0x1fff8fa0
    b134:	1fff8f9c 	.word	0x1fff8f9c

0000b138 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
    b138:	b500      	push	{lr}
    b13a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b13c:	f7f5 ff52 	bl	fe4 <Sys_GetCoreID>
    b140:	4603      	mov	r3, r0
    b142:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId])
    b144:	4a10      	ldr	r2, [pc, #64]	; (b188 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    b146:	9b01      	ldr	r3, [sp, #4]
    b148:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b14c:	2b00      	cmp	r3, #0
    b14e:	d10d      	bne.n	b16c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b150:	f7f5 fc6e 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b154:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b156:	9b00      	ldr	r3, [sp, #0]
    b158:	f003 0301 	and.w	r3, r3, #1
    b15c:	2b00      	cmp	r3, #0
    b15e:	d100      	bne.n	b162 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b160:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    b162:	490a      	ldr	r1, [pc, #40]	; (b18c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x54>)
    b164:	9b01      	ldr	r3, [sp, #4]
    b166:	9a00      	ldr	r2, [sp, #0]
    b168:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]++;
    b16c:	4a06      	ldr	r2, [pc, #24]	; (b188 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    b16e:	9b01      	ldr	r3, [sp, #4]
    b170:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b174:	1c5a      	adds	r2, r3, #1
    b176:	4904      	ldr	r1, [pc, #16]	; (b188 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
    b178:	9b01      	ldr	r3, [sp, #4]
    b17a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b17e:	bf00      	nop
    b180:	b003      	add	sp, #12
    b182:	f85d fb04 	ldr.w	pc, [sp], #4
    b186:	bf00      	nop
    b188:	1fff8fa8 	.word	0x1fff8fa8
    b18c:	1fff8fa4 	.word	0x1fff8fa4

0000b190 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
    b190:	b500      	push	{lr}
    b192:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b194:	f7f5 ff26 	bl	fe4 <Sys_GetCoreID>
    b198:	4603      	mov	r3, r0
    b19a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]--;
    b19c:	4a0d      	ldr	r2, [pc, #52]	; (b1d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    b19e:	9b01      	ldr	r3, [sp, #4]
    b1a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b1a4:	1e5a      	subs	r2, r3, #1
    b1a6:	490b      	ldr	r1, [pc, #44]	; (b1d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    b1a8:	9b01      	ldr	r3, [sp, #4]
    b1aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    b1ae:	4a0a      	ldr	r2, [pc, #40]	; (b1d8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x48>)
    b1b0:	9b01      	ldr	r3, [sp, #4]
    b1b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b1b6:	f003 0301 	and.w	r3, r3, #1
    b1ba:	2b00      	cmp	r3, #0
    b1bc:	d106      	bne.n	b1cc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    b1be:	4a05      	ldr	r2, [pc, #20]	; (b1d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
    b1c0:	9b01      	ldr	r3, [sp, #4]
    b1c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b1c6:	2b00      	cmp	r3, #0
    b1c8:	d100      	bne.n	b1cc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b1ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b1cc:	bf00      	nop
    b1ce:	b003      	add	sp, #12
    b1d0:	f85d fb04 	ldr.w	pc, [sp], #4
    b1d4:	1fff8fa8 	.word	0x1fff8fa8
    b1d8:	1fff8fa4 	.word	0x1fff8fa4

0000b1dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
    b1dc:	b500      	push	{lr}
    b1de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b1e0:	f7f5 ff00 	bl	fe4 <Sys_GetCoreID>
    b1e4:	4603      	mov	r3, r0
    b1e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId])
    b1e8:	4a10      	ldr	r2, [pc, #64]	; (b22c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    b1ea:	9b01      	ldr	r3, [sp, #4]
    b1ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b1f0:	2b00      	cmp	r3, #0
    b1f2:	d10d      	bne.n	b210 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b1f4:	f7f5 fc1c 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b1f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b1fa:	9b00      	ldr	r3, [sp, #0]
    b1fc:	f003 0301 	and.w	r3, r3, #1
    b200:	2b00      	cmp	r3, #0
    b202:	d100      	bne.n	b206 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b204:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    b206:	490a      	ldr	r1, [pc, #40]	; (b230 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x54>)
    b208:	9b01      	ldr	r3, [sp, #4]
    b20a:	9a00      	ldr	r2, [sp, #0]
    b20c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]++;
    b210:	4a06      	ldr	r2, [pc, #24]	; (b22c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    b212:	9b01      	ldr	r3, [sp, #4]
    b214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b218:	1c5a      	adds	r2, r3, #1
    b21a:	4904      	ldr	r1, [pc, #16]	; (b22c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
    b21c:	9b01      	ldr	r3, [sp, #4]
    b21e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b222:	bf00      	nop
    b224:	b003      	add	sp, #12
    b226:	f85d fb04 	ldr.w	pc, [sp], #4
    b22a:	bf00      	nop
    b22c:	1fff8fb0 	.word	0x1fff8fb0
    b230:	1fff8fac 	.word	0x1fff8fac

0000b234 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
    b234:	b500      	push	{lr}
    b236:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b238:	f7f5 fed4 	bl	fe4 <Sys_GetCoreID>
    b23c:	4603      	mov	r3, r0
    b23e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]--;
    b240:	4a0d      	ldr	r2, [pc, #52]	; (b278 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    b242:	9b01      	ldr	r3, [sp, #4]
    b244:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b248:	1e5a      	subs	r2, r3, #1
    b24a:	490b      	ldr	r1, [pc, #44]	; (b278 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    b24c:	9b01      	ldr	r3, [sp, #4]
    b24e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    b252:	4a0a      	ldr	r2, [pc, #40]	; (b27c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x48>)
    b254:	9b01      	ldr	r3, [sp, #4]
    b256:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b25a:	f003 0301 	and.w	r3, r3, #1
    b25e:	2b00      	cmp	r3, #0
    b260:	d106      	bne.n	b270 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    b262:	4a05      	ldr	r2, [pc, #20]	; (b278 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
    b264:	9b01      	ldr	r3, [sp, #4]
    b266:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b26a:	2b00      	cmp	r3, #0
    b26c:	d100      	bne.n	b270 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b26e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b270:	bf00      	nop
    b272:	b003      	add	sp, #12
    b274:	f85d fb04 	ldr.w	pc, [sp], #4
    b278:	1fff8fb0 	.word	0x1fff8fb0
    b27c:	1fff8fac 	.word	0x1fff8fac

0000b280 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
    b280:	b500      	push	{lr}
    b282:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b284:	f7f5 feae 	bl	fe4 <Sys_GetCoreID>
    b288:	4603      	mov	r3, r0
    b28a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId])
    b28c:	4a10      	ldr	r2, [pc, #64]	; (b2d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    b28e:	9b01      	ldr	r3, [sp, #4]
    b290:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b294:	2b00      	cmp	r3, #0
    b296:	d10d      	bne.n	b2b4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b298:	f7f5 fbca 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b29c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b29e:	9b00      	ldr	r3, [sp, #0]
    b2a0:	f003 0301 	and.w	r3, r3, #1
    b2a4:	2b00      	cmp	r3, #0
    b2a6:	d100      	bne.n	b2aa <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b2a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    b2aa:	490a      	ldr	r1, [pc, #40]	; (b2d4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x54>)
    b2ac:	9b01      	ldr	r3, [sp, #4]
    b2ae:	9a00      	ldr	r2, [sp, #0]
    b2b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]++;
    b2b4:	4a06      	ldr	r2, [pc, #24]	; (b2d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    b2b6:	9b01      	ldr	r3, [sp, #4]
    b2b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b2bc:	1c5a      	adds	r2, r3, #1
    b2be:	4904      	ldr	r1, [pc, #16]	; (b2d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
    b2c0:	9b01      	ldr	r3, [sp, #4]
    b2c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b2c6:	bf00      	nop
    b2c8:	b003      	add	sp, #12
    b2ca:	f85d fb04 	ldr.w	pc, [sp], #4
    b2ce:	bf00      	nop
    b2d0:	1fff8fb8 	.word	0x1fff8fb8
    b2d4:	1fff8fb4 	.word	0x1fff8fb4

0000b2d8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
    b2d8:	b500      	push	{lr}
    b2da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b2dc:	f7f5 fe82 	bl	fe4 <Sys_GetCoreID>
    b2e0:	4603      	mov	r3, r0
    b2e2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]--;
    b2e4:	4a0d      	ldr	r2, [pc, #52]	; (b31c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    b2e6:	9b01      	ldr	r3, [sp, #4]
    b2e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b2ec:	1e5a      	subs	r2, r3, #1
    b2ee:	490b      	ldr	r1, [pc, #44]	; (b31c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    b2f0:	9b01      	ldr	r3, [sp, #4]
    b2f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    b2f6:	4a0a      	ldr	r2, [pc, #40]	; (b320 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x48>)
    b2f8:	9b01      	ldr	r3, [sp, #4]
    b2fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b2fe:	f003 0301 	and.w	r3, r3, #1
    b302:	2b00      	cmp	r3, #0
    b304:	d106      	bne.n	b314 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    b306:	4a05      	ldr	r2, [pc, #20]	; (b31c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
    b308:	9b01      	ldr	r3, [sp, #4]
    b30a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b30e:	2b00      	cmp	r3, #0
    b310:	d100      	bne.n	b314 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b312:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b314:	bf00      	nop
    b316:	b003      	add	sp, #12
    b318:	f85d fb04 	ldr.w	pc, [sp], #4
    b31c:	1fff8fb8 	.word	0x1fff8fb8
    b320:	1fff8fb4 	.word	0x1fff8fb4

0000b324 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
    b324:	b500      	push	{lr}
    b326:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b328:	f7f5 fe5c 	bl	fe4 <Sys_GetCoreID>
    b32c:	4603      	mov	r3, r0
    b32e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId])
    b330:	4a10      	ldr	r2, [pc, #64]	; (b374 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    b332:	9b01      	ldr	r3, [sp, #4]
    b334:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b338:	2b00      	cmp	r3, #0
    b33a:	d10d      	bne.n	b358 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b33c:	f7f5 fb78 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b340:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b342:	9b00      	ldr	r3, [sp, #0]
    b344:	f003 0301 	and.w	r3, r3, #1
    b348:	2b00      	cmp	r3, #0
    b34a:	d100      	bne.n	b34e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b34c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    b34e:	490a      	ldr	r1, [pc, #40]	; (b378 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x54>)
    b350:	9b01      	ldr	r3, [sp, #4]
    b352:	9a00      	ldr	r2, [sp, #0]
    b354:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]++;
    b358:	4a06      	ldr	r2, [pc, #24]	; (b374 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    b35a:	9b01      	ldr	r3, [sp, #4]
    b35c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b360:	1c5a      	adds	r2, r3, #1
    b362:	4904      	ldr	r1, [pc, #16]	; (b374 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
    b364:	9b01      	ldr	r3, [sp, #4]
    b366:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b36a:	bf00      	nop
    b36c:	b003      	add	sp, #12
    b36e:	f85d fb04 	ldr.w	pc, [sp], #4
    b372:	bf00      	nop
    b374:	1fff8fc0 	.word	0x1fff8fc0
    b378:	1fff8fbc 	.word	0x1fff8fbc

0000b37c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
    b37c:	b500      	push	{lr}
    b37e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b380:	f7f5 fe30 	bl	fe4 <Sys_GetCoreID>
    b384:	4603      	mov	r3, r0
    b386:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]--;
    b388:	4a0d      	ldr	r2, [pc, #52]	; (b3c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    b38a:	9b01      	ldr	r3, [sp, #4]
    b38c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b390:	1e5a      	subs	r2, r3, #1
    b392:	490b      	ldr	r1, [pc, #44]	; (b3c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    b394:	9b01      	ldr	r3, [sp, #4]
    b396:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    b39a:	4a0a      	ldr	r2, [pc, #40]	; (b3c4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x48>)
    b39c:	9b01      	ldr	r3, [sp, #4]
    b39e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3a2:	f003 0301 	and.w	r3, r3, #1
    b3a6:	2b00      	cmp	r3, #0
    b3a8:	d106      	bne.n	b3b8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    b3aa:	4a05      	ldr	r2, [pc, #20]	; (b3c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
    b3ac:	9b01      	ldr	r3, [sp, #4]
    b3ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3b2:	2b00      	cmp	r3, #0
    b3b4:	d100      	bne.n	b3b8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b3b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b3b8:	bf00      	nop
    b3ba:	b003      	add	sp, #12
    b3bc:	f85d fb04 	ldr.w	pc, [sp], #4
    b3c0:	1fff8fc0 	.word	0x1fff8fc0
    b3c4:	1fff8fbc 	.word	0x1fff8fbc

0000b3c8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
    b3c8:	b500      	push	{lr}
    b3ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b3cc:	f7f5 fe0a 	bl	fe4 <Sys_GetCoreID>
    b3d0:	4603      	mov	r3, r0
    b3d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId])
    b3d4:	4a10      	ldr	r2, [pc, #64]	; (b418 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    b3d6:	9b01      	ldr	r3, [sp, #4]
    b3d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3dc:	2b00      	cmp	r3, #0
    b3de:	d10d      	bne.n	b3fc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b3e0:	f7f5 fb26 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b3e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b3e6:	9b00      	ldr	r3, [sp, #0]
    b3e8:	f003 0301 	and.w	r3, r3, #1
    b3ec:	2b00      	cmp	r3, #0
    b3ee:	d100      	bne.n	b3f2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b3f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    b3f2:	490a      	ldr	r1, [pc, #40]	; (b41c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x54>)
    b3f4:	9b01      	ldr	r3, [sp, #4]
    b3f6:	9a00      	ldr	r2, [sp, #0]
    b3f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]++;
    b3fc:	4a06      	ldr	r2, [pc, #24]	; (b418 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    b3fe:	9b01      	ldr	r3, [sp, #4]
    b400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b404:	1c5a      	adds	r2, r3, #1
    b406:	4904      	ldr	r1, [pc, #16]	; (b418 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
    b408:	9b01      	ldr	r3, [sp, #4]
    b40a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b40e:	bf00      	nop
    b410:	b003      	add	sp, #12
    b412:	f85d fb04 	ldr.w	pc, [sp], #4
    b416:	bf00      	nop
    b418:	1fff8fc8 	.word	0x1fff8fc8
    b41c:	1fff8fc4 	.word	0x1fff8fc4

0000b420 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
    b420:	b500      	push	{lr}
    b422:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b424:	f7f5 fdde 	bl	fe4 <Sys_GetCoreID>
    b428:	4603      	mov	r3, r0
    b42a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]--;
    b42c:	4a0d      	ldr	r2, [pc, #52]	; (b464 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    b42e:	9b01      	ldr	r3, [sp, #4]
    b430:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b434:	1e5a      	subs	r2, r3, #1
    b436:	490b      	ldr	r1, [pc, #44]	; (b464 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    b438:	9b01      	ldr	r3, [sp, #4]
    b43a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    b43e:	4a0a      	ldr	r2, [pc, #40]	; (b468 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x48>)
    b440:	9b01      	ldr	r3, [sp, #4]
    b442:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b446:	f003 0301 	and.w	r3, r3, #1
    b44a:	2b00      	cmp	r3, #0
    b44c:	d106      	bne.n	b45c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    b44e:	4a05      	ldr	r2, [pc, #20]	; (b464 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
    b450:	9b01      	ldr	r3, [sp, #4]
    b452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b456:	2b00      	cmp	r3, #0
    b458:	d100      	bne.n	b45c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b45a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b45c:	bf00      	nop
    b45e:	b003      	add	sp, #12
    b460:	f85d fb04 	ldr.w	pc, [sp], #4
    b464:	1fff8fc8 	.word	0x1fff8fc8
    b468:	1fff8fc4 	.word	0x1fff8fc4

0000b46c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
    b46c:	b500      	push	{lr}
    b46e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b470:	f7f5 fdb8 	bl	fe4 <Sys_GetCoreID>
    b474:	4603      	mov	r3, r0
    b476:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId])
    b478:	4a10      	ldr	r2, [pc, #64]	; (b4bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    b47a:	9b01      	ldr	r3, [sp, #4]
    b47c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b480:	2b00      	cmp	r3, #0
    b482:	d10d      	bne.n	b4a0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b484:	f7f5 fad4 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b488:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b48a:	9b00      	ldr	r3, [sp, #0]
    b48c:	f003 0301 	and.w	r3, r3, #1
    b490:	2b00      	cmp	r3, #0
    b492:	d100      	bne.n	b496 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b494:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    b496:	490a      	ldr	r1, [pc, #40]	; (b4c0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x54>)
    b498:	9b01      	ldr	r3, [sp, #4]
    b49a:	9a00      	ldr	r2, [sp, #0]
    b49c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]++;
    b4a0:	4a06      	ldr	r2, [pc, #24]	; (b4bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    b4a2:	9b01      	ldr	r3, [sp, #4]
    b4a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4a8:	1c5a      	adds	r2, r3, #1
    b4aa:	4904      	ldr	r1, [pc, #16]	; (b4bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
    b4ac:	9b01      	ldr	r3, [sp, #4]
    b4ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b4b2:	bf00      	nop
    b4b4:	b003      	add	sp, #12
    b4b6:	f85d fb04 	ldr.w	pc, [sp], #4
    b4ba:	bf00      	nop
    b4bc:	1fff8fd0 	.word	0x1fff8fd0
    b4c0:	1fff8fcc 	.word	0x1fff8fcc

0000b4c4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
    b4c4:	b500      	push	{lr}
    b4c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b4c8:	f7f5 fd8c 	bl	fe4 <Sys_GetCoreID>
    b4cc:	4603      	mov	r3, r0
    b4ce:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]--;
    b4d0:	4a0d      	ldr	r2, [pc, #52]	; (b508 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    b4d2:	9b01      	ldr	r3, [sp, #4]
    b4d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4d8:	1e5a      	subs	r2, r3, #1
    b4da:	490b      	ldr	r1, [pc, #44]	; (b508 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    b4dc:	9b01      	ldr	r3, [sp, #4]
    b4de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    b4e2:	4a0a      	ldr	r2, [pc, #40]	; (b50c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x48>)
    b4e4:	9b01      	ldr	r3, [sp, #4]
    b4e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4ea:	f003 0301 	and.w	r3, r3, #1
    b4ee:	2b00      	cmp	r3, #0
    b4f0:	d106      	bne.n	b500 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    b4f2:	4a05      	ldr	r2, [pc, #20]	; (b508 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
    b4f4:	9b01      	ldr	r3, [sp, #4]
    b4f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4fa:	2b00      	cmp	r3, #0
    b4fc:	d100      	bne.n	b500 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b4fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b500:	bf00      	nop
    b502:	b003      	add	sp, #12
    b504:	f85d fb04 	ldr.w	pc, [sp], #4
    b508:	1fff8fd0 	.word	0x1fff8fd0
    b50c:	1fff8fcc 	.word	0x1fff8fcc

0000b510 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
    b510:	b500      	push	{lr}
    b512:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b514:	f7f5 fd66 	bl	fe4 <Sys_GetCoreID>
    b518:	4603      	mov	r3, r0
    b51a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId])
    b51c:	4a10      	ldr	r2, [pc, #64]	; (b560 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    b51e:	9b01      	ldr	r3, [sp, #4]
    b520:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b524:	2b00      	cmp	r3, #0
    b526:	d10d      	bne.n	b544 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b528:	f7f5 fa82 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b52c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b52e:	9b00      	ldr	r3, [sp, #0]
    b530:	f003 0301 	and.w	r3, r3, #1
    b534:	2b00      	cmp	r3, #0
    b536:	d100      	bne.n	b53a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b538:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    b53a:	490a      	ldr	r1, [pc, #40]	; (b564 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x54>)
    b53c:	9b01      	ldr	r3, [sp, #4]
    b53e:	9a00      	ldr	r2, [sp, #0]
    b540:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]++;
    b544:	4a06      	ldr	r2, [pc, #24]	; (b560 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    b546:	9b01      	ldr	r3, [sp, #4]
    b548:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b54c:	1c5a      	adds	r2, r3, #1
    b54e:	4904      	ldr	r1, [pc, #16]	; (b560 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
    b550:	9b01      	ldr	r3, [sp, #4]
    b552:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b556:	bf00      	nop
    b558:	b003      	add	sp, #12
    b55a:	f85d fb04 	ldr.w	pc, [sp], #4
    b55e:	bf00      	nop
    b560:	1fff8fd8 	.word	0x1fff8fd8
    b564:	1fff8fd4 	.word	0x1fff8fd4

0000b568 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
    b568:	b500      	push	{lr}
    b56a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b56c:	f7f5 fd3a 	bl	fe4 <Sys_GetCoreID>
    b570:	4603      	mov	r3, r0
    b572:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]--;
    b574:	4a0d      	ldr	r2, [pc, #52]	; (b5ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    b576:	9b01      	ldr	r3, [sp, #4]
    b578:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b57c:	1e5a      	subs	r2, r3, #1
    b57e:	490b      	ldr	r1, [pc, #44]	; (b5ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    b580:	9b01      	ldr	r3, [sp, #4]
    b582:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    b586:	4a0a      	ldr	r2, [pc, #40]	; (b5b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x48>)
    b588:	9b01      	ldr	r3, [sp, #4]
    b58a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b58e:	f003 0301 	and.w	r3, r3, #1
    b592:	2b00      	cmp	r3, #0
    b594:	d106      	bne.n	b5a4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    b596:	4a05      	ldr	r2, [pc, #20]	; (b5ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
    b598:	9b01      	ldr	r3, [sp, #4]
    b59a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b59e:	2b00      	cmp	r3, #0
    b5a0:	d100      	bne.n	b5a4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b5a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b5a4:	bf00      	nop
    b5a6:	b003      	add	sp, #12
    b5a8:	f85d fb04 	ldr.w	pc, [sp], #4
    b5ac:	1fff8fd8 	.word	0x1fff8fd8
    b5b0:	1fff8fd4 	.word	0x1fff8fd4

0000b5b4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
    b5b4:	b500      	push	{lr}
    b5b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b5b8:	f7f5 fd14 	bl	fe4 <Sys_GetCoreID>
    b5bc:	4603      	mov	r3, r0
    b5be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId])
    b5c0:	4a10      	ldr	r2, [pc, #64]	; (b604 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    b5c2:	9b01      	ldr	r3, [sp, #4]
    b5c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b5c8:	2b00      	cmp	r3, #0
    b5ca:	d10d      	bne.n	b5e8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b5cc:	f7f5 fa30 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b5d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b5d2:	9b00      	ldr	r3, [sp, #0]
    b5d4:	f003 0301 	and.w	r3, r3, #1
    b5d8:	2b00      	cmp	r3, #0
    b5da:	d100      	bne.n	b5de <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b5dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    b5de:	490a      	ldr	r1, [pc, #40]	; (b608 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x54>)
    b5e0:	9b01      	ldr	r3, [sp, #4]
    b5e2:	9a00      	ldr	r2, [sp, #0]
    b5e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]++;
    b5e8:	4a06      	ldr	r2, [pc, #24]	; (b604 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    b5ea:	9b01      	ldr	r3, [sp, #4]
    b5ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b5f0:	1c5a      	adds	r2, r3, #1
    b5f2:	4904      	ldr	r1, [pc, #16]	; (b604 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
    b5f4:	9b01      	ldr	r3, [sp, #4]
    b5f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b5fa:	bf00      	nop
    b5fc:	b003      	add	sp, #12
    b5fe:	f85d fb04 	ldr.w	pc, [sp], #4
    b602:	bf00      	nop
    b604:	1fff8fe0 	.word	0x1fff8fe0
    b608:	1fff8fdc 	.word	0x1fff8fdc

0000b60c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
    b60c:	b500      	push	{lr}
    b60e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b610:	f7f5 fce8 	bl	fe4 <Sys_GetCoreID>
    b614:	4603      	mov	r3, r0
    b616:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]--;
    b618:	4a0d      	ldr	r2, [pc, #52]	; (b650 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    b61a:	9b01      	ldr	r3, [sp, #4]
    b61c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b620:	1e5a      	subs	r2, r3, #1
    b622:	490b      	ldr	r1, [pc, #44]	; (b650 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    b624:	9b01      	ldr	r3, [sp, #4]
    b626:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    b62a:	4a0a      	ldr	r2, [pc, #40]	; (b654 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x48>)
    b62c:	9b01      	ldr	r3, [sp, #4]
    b62e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b632:	f003 0301 	and.w	r3, r3, #1
    b636:	2b00      	cmp	r3, #0
    b638:	d106      	bne.n	b648 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    b63a:	4a05      	ldr	r2, [pc, #20]	; (b650 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
    b63c:	9b01      	ldr	r3, [sp, #4]
    b63e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b642:	2b00      	cmp	r3, #0
    b644:	d100      	bne.n	b648 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b646:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b648:	bf00      	nop
    b64a:	b003      	add	sp, #12
    b64c:	f85d fb04 	ldr.w	pc, [sp], #4
    b650:	1fff8fe0 	.word	0x1fff8fe0
    b654:	1fff8fdc 	.word	0x1fff8fdc

0000b658 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
    b658:	b500      	push	{lr}
    b65a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b65c:	f7f5 fcc2 	bl	fe4 <Sys_GetCoreID>
    b660:	4603      	mov	r3, r0
    b662:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId])
    b664:	4a10      	ldr	r2, [pc, #64]	; (b6a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    b666:	9b01      	ldr	r3, [sp, #4]
    b668:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b66c:	2b00      	cmp	r3, #0
    b66e:	d10d      	bne.n	b68c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b670:	f7f5 f9de 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b674:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b676:	9b00      	ldr	r3, [sp, #0]
    b678:	f003 0301 	and.w	r3, r3, #1
    b67c:	2b00      	cmp	r3, #0
    b67e:	d100      	bne.n	b682 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b680:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    b682:	490a      	ldr	r1, [pc, #40]	; (b6ac <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x54>)
    b684:	9b01      	ldr	r3, [sp, #4]
    b686:	9a00      	ldr	r2, [sp, #0]
    b688:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]++;
    b68c:	4a06      	ldr	r2, [pc, #24]	; (b6a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    b68e:	9b01      	ldr	r3, [sp, #4]
    b690:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b694:	1c5a      	adds	r2, r3, #1
    b696:	4904      	ldr	r1, [pc, #16]	; (b6a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
    b698:	9b01      	ldr	r3, [sp, #4]
    b69a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b69e:	bf00      	nop
    b6a0:	b003      	add	sp, #12
    b6a2:	f85d fb04 	ldr.w	pc, [sp], #4
    b6a6:	bf00      	nop
    b6a8:	1fff8fe8 	.word	0x1fff8fe8
    b6ac:	1fff8fe4 	.word	0x1fff8fe4

0000b6b0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
    b6b0:	b500      	push	{lr}
    b6b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b6b4:	f7f5 fc96 	bl	fe4 <Sys_GetCoreID>
    b6b8:	4603      	mov	r3, r0
    b6ba:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]--;
    b6bc:	4a0d      	ldr	r2, [pc, #52]	; (b6f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    b6be:	9b01      	ldr	r3, [sp, #4]
    b6c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b6c4:	1e5a      	subs	r2, r3, #1
    b6c6:	490b      	ldr	r1, [pc, #44]	; (b6f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    b6c8:	9b01      	ldr	r3, [sp, #4]
    b6ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    b6ce:	4a0a      	ldr	r2, [pc, #40]	; (b6f8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x48>)
    b6d0:	9b01      	ldr	r3, [sp, #4]
    b6d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b6d6:	f003 0301 	and.w	r3, r3, #1
    b6da:	2b00      	cmp	r3, #0
    b6dc:	d106      	bne.n	b6ec <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    b6de:	4a05      	ldr	r2, [pc, #20]	; (b6f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
    b6e0:	9b01      	ldr	r3, [sp, #4]
    b6e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b6e6:	2b00      	cmp	r3, #0
    b6e8:	d100      	bne.n	b6ec <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b6ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b6ec:	bf00      	nop
    b6ee:	b003      	add	sp, #12
    b6f0:	f85d fb04 	ldr.w	pc, [sp], #4
    b6f4:	1fff8fe8 	.word	0x1fff8fe8
    b6f8:	1fff8fe4 	.word	0x1fff8fe4

0000b6fc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
    b6fc:	b500      	push	{lr}
    b6fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b700:	f7f5 fc70 	bl	fe4 <Sys_GetCoreID>
    b704:	4603      	mov	r3, r0
    b706:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId])
    b708:	4a10      	ldr	r2, [pc, #64]	; (b74c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    b70a:	9b01      	ldr	r3, [sp, #4]
    b70c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b710:	2b00      	cmp	r3, #0
    b712:	d10d      	bne.n	b730 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b714:	f7f5 f98c 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b718:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b71a:	9b00      	ldr	r3, [sp, #0]
    b71c:	f003 0301 	and.w	r3, r3, #1
    b720:	2b00      	cmp	r3, #0
    b722:	d100      	bne.n	b726 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b724:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    b726:	490a      	ldr	r1, [pc, #40]	; (b750 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x54>)
    b728:	9b01      	ldr	r3, [sp, #4]
    b72a:	9a00      	ldr	r2, [sp, #0]
    b72c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]++;
    b730:	4a06      	ldr	r2, [pc, #24]	; (b74c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    b732:	9b01      	ldr	r3, [sp, #4]
    b734:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b738:	1c5a      	adds	r2, r3, #1
    b73a:	4904      	ldr	r1, [pc, #16]	; (b74c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
    b73c:	9b01      	ldr	r3, [sp, #4]
    b73e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b742:	bf00      	nop
    b744:	b003      	add	sp, #12
    b746:	f85d fb04 	ldr.w	pc, [sp], #4
    b74a:	bf00      	nop
    b74c:	1fff8ff0 	.word	0x1fff8ff0
    b750:	1fff8fec 	.word	0x1fff8fec

0000b754 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
    b754:	b500      	push	{lr}
    b756:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b758:	f7f5 fc44 	bl	fe4 <Sys_GetCoreID>
    b75c:	4603      	mov	r3, r0
    b75e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]--;
    b760:	4a0d      	ldr	r2, [pc, #52]	; (b798 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    b762:	9b01      	ldr	r3, [sp, #4]
    b764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b768:	1e5a      	subs	r2, r3, #1
    b76a:	490b      	ldr	r1, [pc, #44]	; (b798 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    b76c:	9b01      	ldr	r3, [sp, #4]
    b76e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    b772:	4a0a      	ldr	r2, [pc, #40]	; (b79c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x48>)
    b774:	9b01      	ldr	r3, [sp, #4]
    b776:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b77a:	f003 0301 	and.w	r3, r3, #1
    b77e:	2b00      	cmp	r3, #0
    b780:	d106      	bne.n	b790 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    b782:	4a05      	ldr	r2, [pc, #20]	; (b798 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
    b784:	9b01      	ldr	r3, [sp, #4]
    b786:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b78a:	2b00      	cmp	r3, #0
    b78c:	d100      	bne.n	b790 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b78e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b790:	bf00      	nop
    b792:	b003      	add	sp, #12
    b794:	f85d fb04 	ldr.w	pc, [sp], #4
    b798:	1fff8ff0 	.word	0x1fff8ff0
    b79c:	1fff8fec 	.word	0x1fff8fec

0000b7a0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
    b7a0:	b500      	push	{lr}
    b7a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b7a4:	f7f5 fc1e 	bl	fe4 <Sys_GetCoreID>
    b7a8:	4603      	mov	r3, r0
    b7aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId])
    b7ac:	4a10      	ldr	r2, [pc, #64]	; (b7f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    b7ae:	9b01      	ldr	r3, [sp, #4]
    b7b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b7b4:	2b00      	cmp	r3, #0
    b7b6:	d10d      	bne.n	b7d4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b7b8:	f7f5 f93a 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b7bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b7be:	9b00      	ldr	r3, [sp, #0]
    b7c0:	f003 0301 	and.w	r3, r3, #1
    b7c4:	2b00      	cmp	r3, #0
    b7c6:	d100      	bne.n	b7ca <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b7c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    b7ca:	490a      	ldr	r1, [pc, #40]	; (b7f4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x54>)
    b7cc:	9b01      	ldr	r3, [sp, #4]
    b7ce:	9a00      	ldr	r2, [sp, #0]
    b7d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]++;
    b7d4:	4a06      	ldr	r2, [pc, #24]	; (b7f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    b7d6:	9b01      	ldr	r3, [sp, #4]
    b7d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b7dc:	1c5a      	adds	r2, r3, #1
    b7de:	4904      	ldr	r1, [pc, #16]	; (b7f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
    b7e0:	9b01      	ldr	r3, [sp, #4]
    b7e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b7e6:	bf00      	nop
    b7e8:	b003      	add	sp, #12
    b7ea:	f85d fb04 	ldr.w	pc, [sp], #4
    b7ee:	bf00      	nop
    b7f0:	1fff8ff8 	.word	0x1fff8ff8
    b7f4:	1fff8ff4 	.word	0x1fff8ff4

0000b7f8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
    b7f8:	b500      	push	{lr}
    b7fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b7fc:	f7f5 fbf2 	bl	fe4 <Sys_GetCoreID>
    b800:	4603      	mov	r3, r0
    b802:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]--;
    b804:	4a0d      	ldr	r2, [pc, #52]	; (b83c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    b806:	9b01      	ldr	r3, [sp, #4]
    b808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b80c:	1e5a      	subs	r2, r3, #1
    b80e:	490b      	ldr	r1, [pc, #44]	; (b83c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    b810:	9b01      	ldr	r3, [sp, #4]
    b812:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    b816:	4a0a      	ldr	r2, [pc, #40]	; (b840 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x48>)
    b818:	9b01      	ldr	r3, [sp, #4]
    b81a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b81e:	f003 0301 	and.w	r3, r3, #1
    b822:	2b00      	cmp	r3, #0
    b824:	d106      	bne.n	b834 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    b826:	4a05      	ldr	r2, [pc, #20]	; (b83c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
    b828:	9b01      	ldr	r3, [sp, #4]
    b82a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b82e:	2b00      	cmp	r3, #0
    b830:	d100      	bne.n	b834 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b832:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b834:	bf00      	nop
    b836:	b003      	add	sp, #12
    b838:	f85d fb04 	ldr.w	pc, [sp], #4
    b83c:	1fff8ff8 	.word	0x1fff8ff8
    b840:	1fff8ff4 	.word	0x1fff8ff4

0000b844 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
    b844:	b500      	push	{lr}
    b846:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b848:	f7f5 fbcc 	bl	fe4 <Sys_GetCoreID>
    b84c:	4603      	mov	r3, r0
    b84e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId])
    b850:	4a10      	ldr	r2, [pc, #64]	; (b894 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    b852:	9b01      	ldr	r3, [sp, #4]
    b854:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b858:	2b00      	cmp	r3, #0
    b85a:	d10d      	bne.n	b878 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b85c:	f7f5 f8e8 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b860:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b862:	9b00      	ldr	r3, [sp, #0]
    b864:	f003 0301 	and.w	r3, r3, #1
    b868:	2b00      	cmp	r3, #0
    b86a:	d100      	bne.n	b86e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b86c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    b86e:	490a      	ldr	r1, [pc, #40]	; (b898 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x54>)
    b870:	9b01      	ldr	r3, [sp, #4]
    b872:	9a00      	ldr	r2, [sp, #0]
    b874:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]++;
    b878:	4a06      	ldr	r2, [pc, #24]	; (b894 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    b87a:	9b01      	ldr	r3, [sp, #4]
    b87c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b880:	1c5a      	adds	r2, r3, #1
    b882:	4904      	ldr	r1, [pc, #16]	; (b894 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
    b884:	9b01      	ldr	r3, [sp, #4]
    b886:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b88a:	bf00      	nop
    b88c:	b003      	add	sp, #12
    b88e:	f85d fb04 	ldr.w	pc, [sp], #4
    b892:	bf00      	nop
    b894:	1fff9000 	.word	0x1fff9000
    b898:	1fff8ffc 	.word	0x1fff8ffc

0000b89c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
    b89c:	b500      	push	{lr}
    b89e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b8a0:	f7f5 fba0 	bl	fe4 <Sys_GetCoreID>
    b8a4:	4603      	mov	r3, r0
    b8a6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]--;
    b8a8:	4a0d      	ldr	r2, [pc, #52]	; (b8e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    b8aa:	9b01      	ldr	r3, [sp, #4]
    b8ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8b0:	1e5a      	subs	r2, r3, #1
    b8b2:	490b      	ldr	r1, [pc, #44]	; (b8e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    b8b4:	9b01      	ldr	r3, [sp, #4]
    b8b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    b8ba:	4a0a      	ldr	r2, [pc, #40]	; (b8e4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x48>)
    b8bc:	9b01      	ldr	r3, [sp, #4]
    b8be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8c2:	f003 0301 	and.w	r3, r3, #1
    b8c6:	2b00      	cmp	r3, #0
    b8c8:	d106      	bne.n	b8d8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    b8ca:	4a05      	ldr	r2, [pc, #20]	; (b8e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
    b8cc:	9b01      	ldr	r3, [sp, #4]
    b8ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8d2:	2b00      	cmp	r3, #0
    b8d4:	d100      	bne.n	b8d8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b8d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b8d8:	bf00      	nop
    b8da:	b003      	add	sp, #12
    b8dc:	f85d fb04 	ldr.w	pc, [sp], #4
    b8e0:	1fff9000 	.word	0x1fff9000
    b8e4:	1fff8ffc 	.word	0x1fff8ffc

0000b8e8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
    b8e8:	b500      	push	{lr}
    b8ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b8ec:	f7f5 fb7a 	bl	fe4 <Sys_GetCoreID>
    b8f0:	4603      	mov	r3, r0
    b8f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId])
    b8f4:	4a10      	ldr	r2, [pc, #64]	; (b938 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    b8f6:	9b01      	ldr	r3, [sp, #4]
    b8f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8fc:	2b00      	cmp	r3, #0
    b8fe:	d10d      	bne.n	b91c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b900:	f7f5 f896 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b904:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b906:	9b00      	ldr	r3, [sp, #0]
    b908:	f003 0301 	and.w	r3, r3, #1
    b90c:	2b00      	cmp	r3, #0
    b90e:	d100      	bne.n	b912 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b910:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    b912:	490a      	ldr	r1, [pc, #40]	; (b93c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x54>)
    b914:	9b01      	ldr	r3, [sp, #4]
    b916:	9a00      	ldr	r2, [sp, #0]
    b918:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]++;
    b91c:	4a06      	ldr	r2, [pc, #24]	; (b938 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    b91e:	9b01      	ldr	r3, [sp, #4]
    b920:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b924:	1c5a      	adds	r2, r3, #1
    b926:	4904      	ldr	r1, [pc, #16]	; (b938 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
    b928:	9b01      	ldr	r3, [sp, #4]
    b92a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b92e:	bf00      	nop
    b930:	b003      	add	sp, #12
    b932:	f85d fb04 	ldr.w	pc, [sp], #4
    b936:	bf00      	nop
    b938:	1fff9008 	.word	0x1fff9008
    b93c:	1fff9004 	.word	0x1fff9004

0000b940 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
    b940:	b500      	push	{lr}
    b942:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b944:	f7f5 fb4e 	bl	fe4 <Sys_GetCoreID>
    b948:	4603      	mov	r3, r0
    b94a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]--;
    b94c:	4a0d      	ldr	r2, [pc, #52]	; (b984 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    b94e:	9b01      	ldr	r3, [sp, #4]
    b950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b954:	1e5a      	subs	r2, r3, #1
    b956:	490b      	ldr	r1, [pc, #44]	; (b984 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    b958:	9b01      	ldr	r3, [sp, #4]
    b95a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    b95e:	4a0a      	ldr	r2, [pc, #40]	; (b988 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x48>)
    b960:	9b01      	ldr	r3, [sp, #4]
    b962:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b966:	f003 0301 	and.w	r3, r3, #1
    b96a:	2b00      	cmp	r3, #0
    b96c:	d106      	bne.n	b97c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    b96e:	4a05      	ldr	r2, [pc, #20]	; (b984 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
    b970:	9b01      	ldr	r3, [sp, #4]
    b972:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b976:	2b00      	cmp	r3, #0
    b978:	d100      	bne.n	b97c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    b97a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    b97c:	bf00      	nop
    b97e:	b003      	add	sp, #12
    b980:	f85d fb04 	ldr.w	pc, [sp], #4
    b984:	1fff9008 	.word	0x1fff9008
    b988:	1fff9004 	.word	0x1fff9004

0000b98c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
    b98c:	b500      	push	{lr}
    b98e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b990:	f7f5 fb28 	bl	fe4 <Sys_GetCoreID>
    b994:	4603      	mov	r3, r0
    b996:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId])
    b998:	4a10      	ldr	r2, [pc, #64]	; (b9dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    b99a:	9b01      	ldr	r3, [sp, #4]
    b99c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b9a0:	2b00      	cmp	r3, #0
    b9a2:	d10d      	bne.n	b9c0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    b9a4:	f7f5 f844 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    b9a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    b9aa:	9b00      	ldr	r3, [sp, #0]
    b9ac:	f003 0301 	and.w	r3, r3, #1
    b9b0:	2b00      	cmp	r3, #0
    b9b2:	d100      	bne.n	b9b6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    b9b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    b9b6:	490a      	ldr	r1, [pc, #40]	; (b9e0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x54>)
    b9b8:	9b01      	ldr	r3, [sp, #4]
    b9ba:	9a00      	ldr	r2, [sp, #0]
    b9bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]++;
    b9c0:	4a06      	ldr	r2, [pc, #24]	; (b9dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    b9c2:	9b01      	ldr	r3, [sp, #4]
    b9c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b9c8:	1c5a      	adds	r2, r3, #1
    b9ca:	4904      	ldr	r1, [pc, #16]	; (b9dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
    b9cc:	9b01      	ldr	r3, [sp, #4]
    b9ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    b9d2:	bf00      	nop
    b9d4:	b003      	add	sp, #12
    b9d6:	f85d fb04 	ldr.w	pc, [sp], #4
    b9da:	bf00      	nop
    b9dc:	1fff9010 	.word	0x1fff9010
    b9e0:	1fff900c 	.word	0x1fff900c

0000b9e4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
    b9e4:	b500      	push	{lr}
    b9e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    b9e8:	f7f5 fafc 	bl	fe4 <Sys_GetCoreID>
    b9ec:	4603      	mov	r3, r0
    b9ee:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]--;
    b9f0:	4a0d      	ldr	r2, [pc, #52]	; (ba28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    b9f2:	9b01      	ldr	r3, [sp, #4]
    b9f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b9f8:	1e5a      	subs	r2, r3, #1
    b9fa:	490b      	ldr	r1, [pc, #44]	; (ba28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    b9fc:	9b01      	ldr	r3, [sp, #4]
    b9fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    ba02:	4a0a      	ldr	r2, [pc, #40]	; (ba2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x48>)
    ba04:	9b01      	ldr	r3, [sp, #4]
    ba06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba0a:	f003 0301 	and.w	r3, r3, #1
    ba0e:	2b00      	cmp	r3, #0
    ba10:	d106      	bne.n	ba20 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    ba12:	4a05      	ldr	r2, [pc, #20]	; (ba28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
    ba14:	9b01      	ldr	r3, [sp, #4]
    ba16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba1a:	2b00      	cmp	r3, #0
    ba1c:	d100      	bne.n	ba20 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ba1e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ba20:	bf00      	nop
    ba22:	b003      	add	sp, #12
    ba24:	f85d fb04 	ldr.w	pc, [sp], #4
    ba28:	1fff9010 	.word	0x1fff9010
    ba2c:	1fff900c 	.word	0x1fff900c

0000ba30 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
    ba30:	b500      	push	{lr}
    ba32:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ba34:	f7f5 fad6 	bl	fe4 <Sys_GetCoreID>
    ba38:	4603      	mov	r3, r0
    ba3a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId])
    ba3c:	4a10      	ldr	r2, [pc, #64]	; (ba80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    ba3e:	9b01      	ldr	r3, [sp, #4]
    ba40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba44:	2b00      	cmp	r3, #0
    ba46:	d10d      	bne.n	ba64 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ba48:	f7f4 fff2 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    ba4c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ba4e:	9b00      	ldr	r3, [sp, #0]
    ba50:	f003 0301 	and.w	r3, r3, #1
    ba54:	2b00      	cmp	r3, #0
    ba56:	d100      	bne.n	ba5a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ba58:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    ba5a:	490a      	ldr	r1, [pc, #40]	; (ba84 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x54>)
    ba5c:	9b01      	ldr	r3, [sp, #4]
    ba5e:	9a00      	ldr	r2, [sp, #0]
    ba60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]++;
    ba64:	4a06      	ldr	r2, [pc, #24]	; (ba80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    ba66:	9b01      	ldr	r3, [sp, #4]
    ba68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba6c:	1c5a      	adds	r2, r3, #1
    ba6e:	4904      	ldr	r1, [pc, #16]	; (ba80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
    ba70:	9b01      	ldr	r3, [sp, #4]
    ba72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ba76:	bf00      	nop
    ba78:	b003      	add	sp, #12
    ba7a:	f85d fb04 	ldr.w	pc, [sp], #4
    ba7e:	bf00      	nop
    ba80:	1fff9018 	.word	0x1fff9018
    ba84:	1fff9014 	.word	0x1fff9014

0000ba88 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
    ba88:	b500      	push	{lr}
    ba8a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ba8c:	f7f5 faaa 	bl	fe4 <Sys_GetCoreID>
    ba90:	4603      	mov	r3, r0
    ba92:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]--;
    ba94:	4a0d      	ldr	r2, [pc, #52]	; (bacc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    ba96:	9b01      	ldr	r3, [sp, #4]
    ba98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba9c:	1e5a      	subs	r2, r3, #1
    ba9e:	490b      	ldr	r1, [pc, #44]	; (bacc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    baa0:	9b01      	ldr	r3, [sp, #4]
    baa2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    baa6:	4a0a      	ldr	r2, [pc, #40]	; (bad0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x48>)
    baa8:	9b01      	ldr	r3, [sp, #4]
    baaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    baae:	f003 0301 	and.w	r3, r3, #1
    bab2:	2b00      	cmp	r3, #0
    bab4:	d106      	bne.n	bac4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    bab6:	4a05      	ldr	r2, [pc, #20]	; (bacc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
    bab8:	9b01      	ldr	r3, [sp, #4]
    baba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    babe:	2b00      	cmp	r3, #0
    bac0:	d100      	bne.n	bac4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    bac2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    bac4:	bf00      	nop
    bac6:	b003      	add	sp, #12
    bac8:	f85d fb04 	ldr.w	pc, [sp], #4
    bacc:	1fff9018 	.word	0x1fff9018
    bad0:	1fff9014 	.word	0x1fff9014

0000bad4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
    bad4:	b500      	push	{lr}
    bad6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bad8:	f7f5 fa84 	bl	fe4 <Sys_GetCoreID>
    badc:	4603      	mov	r3, r0
    bade:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId])
    bae0:	4a10      	ldr	r2, [pc, #64]	; (bb24 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    bae2:	9b01      	ldr	r3, [sp, #4]
    bae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bae8:	2b00      	cmp	r3, #0
    baea:	d10d      	bne.n	bb08 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
    baec:	f7f4 ffa0 	bl	a30 <Can_43_FLEXCAN_schm_read_msr>
    baf0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    baf2:	9b00      	ldr	r3, [sp, #0]
    baf4:	f003 0301 	and.w	r3, r3, #1
    baf8:	2b00      	cmp	r3, #0
    bafa:	d100      	bne.n	bafe <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    bafc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    bafe:	490a      	ldr	r1, [pc, #40]	; (bb28 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x54>)
    bb00:	9b01      	ldr	r3, [sp, #4]
    bb02:	9a00      	ldr	r2, [sp, #0]
    bb04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]++;
    bb08:	4a06      	ldr	r2, [pc, #24]	; (bb24 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    bb0a:	9b01      	ldr	r3, [sp, #4]
    bb0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb10:	1c5a      	adds	r2, r3, #1
    bb12:	4904      	ldr	r1, [pc, #16]	; (bb24 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
    bb14:	9b01      	ldr	r3, [sp, #4]
    bb16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    bb1a:	bf00      	nop
    bb1c:	b003      	add	sp, #12
    bb1e:	f85d fb04 	ldr.w	pc, [sp], #4
    bb22:	bf00      	nop
    bb24:	1fff9020 	.word	0x1fff9020
    bb28:	1fff901c 	.word	0x1fff901c

0000bb2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
    bb2c:	b500      	push	{lr}
    bb2e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bb30:	f7f5 fa58 	bl	fe4 <Sys_GetCoreID>
    bb34:	4603      	mov	r3, r0
    bb36:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]--;
    bb38:	4a0d      	ldr	r2, [pc, #52]	; (bb70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    bb3a:	9b01      	ldr	r3, [sp, #4]
    bb3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb40:	1e5a      	subs	r2, r3, #1
    bb42:	490b      	ldr	r1, [pc, #44]	; (bb70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    bb44:	9b01      	ldr	r3, [sp, #4]
    bb46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    bb4a:	4a0a      	ldr	r2, [pc, #40]	; (bb74 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x48>)
    bb4c:	9b01      	ldr	r3, [sp, #4]
    bb4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb52:	f003 0301 	and.w	r3, r3, #1
    bb56:	2b00      	cmp	r3, #0
    bb58:	d106      	bne.n	bb68 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    bb5a:	4a05      	ldr	r2, [pc, #20]	; (bb70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
    bb5c:	9b01      	ldr	r3, [sp, #4]
    bb5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb62:	2b00      	cmp	r3, #0
    bb64:	d100      	bne.n	bb68 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    bb66:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    bb68:	bf00      	nop
    bb6a:	b003      	add	sp, #12
    bb6c:	f85d fb04 	ldr.w	pc, [sp], #4
    bb70:	1fff9020 	.word	0x1fff9020
    bb74:	1fff901c 	.word	0x1fff901c

0000bb78 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    bb78:	b500      	push	{lr}
    bb7a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bb7c:	f7f5 fa32 	bl	fe4 <Sys_GetCoreID>
    bb80:	4603      	mov	r3, r0
    bb82:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    bb84:	4a10      	ldr	r2, [pc, #64]	; (bbc8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    bb86:	9b01      	ldr	r3, [sp, #4]
    bb88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb8c:	2b00      	cmp	r3, #0
    bb8e:	d10d      	bne.n	bbac <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    bb90:	f7f4 ff57 	bl	a42 <Mcu_schm_read_msr>
    bb94:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    bb96:	9b00      	ldr	r3, [sp, #0]
    bb98:	f003 0301 	and.w	r3, r3, #1
    bb9c:	2b00      	cmp	r3, #0
    bb9e:	d100      	bne.n	bba2 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    bba0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    bba2:	490a      	ldr	r1, [pc, #40]	; (bbcc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    bba4:	9b01      	ldr	r3, [sp, #4]
    bba6:	9a00      	ldr	r2, [sp, #0]
    bba8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    bbac:	4a06      	ldr	r2, [pc, #24]	; (bbc8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    bbae:	9b01      	ldr	r3, [sp, #4]
    bbb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bbb4:	1c5a      	adds	r2, r3, #1
    bbb6:	4904      	ldr	r1, [pc, #16]	; (bbc8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    bbb8:	9b01      	ldr	r3, [sp, #4]
    bbba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    bbbe:	bf00      	nop
    bbc0:	b003      	add	sp, #12
    bbc2:	f85d fb04 	ldr.w	pc, [sp], #4
    bbc6:	bf00      	nop
    bbc8:	1fff9028 	.word	0x1fff9028
    bbcc:	1fff9024 	.word	0x1fff9024

0000bbd0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    bbd0:	b500      	push	{lr}
    bbd2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bbd4:	f7f5 fa06 	bl	fe4 <Sys_GetCoreID>
    bbd8:	4603      	mov	r3, r0
    bbda:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    bbdc:	4a0d      	ldr	r2, [pc, #52]	; (bc14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    bbde:	9b01      	ldr	r3, [sp, #4]
    bbe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bbe4:	1e5a      	subs	r2, r3, #1
    bbe6:	490b      	ldr	r1, [pc, #44]	; (bc14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    bbe8:	9b01      	ldr	r3, [sp, #4]
    bbea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    bbee:	4a0a      	ldr	r2, [pc, #40]	; (bc18 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    bbf0:	9b01      	ldr	r3, [sp, #4]
    bbf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bbf6:	f003 0301 	and.w	r3, r3, #1
    bbfa:	2b00      	cmp	r3, #0
    bbfc:	d106      	bne.n	bc0c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    bbfe:	4a05      	ldr	r2, [pc, #20]	; (bc14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    bc00:	9b01      	ldr	r3, [sp, #4]
    bc02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc06:	2b00      	cmp	r3, #0
    bc08:	d100      	bne.n	bc0c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    bc0a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    bc0c:	bf00      	nop
    bc0e:	b003      	add	sp, #12
    bc10:	f85d fb04 	ldr.w	pc, [sp], #4
    bc14:	1fff9028 	.word	0x1fff9028
    bc18:	1fff9024 	.word	0x1fff9024

0000bc1c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    bc1c:	b500      	push	{lr}
    bc1e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bc20:	f7f5 f9e0 	bl	fe4 <Sys_GetCoreID>
    bc24:	4603      	mov	r3, r0
    bc26:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    bc28:	4a10      	ldr	r2, [pc, #64]	; (bc6c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    bc2a:	9b01      	ldr	r3, [sp, #4]
    bc2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc30:	2b00      	cmp	r3, #0
    bc32:	d10d      	bne.n	bc50 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    bc34:	f7f4 ff05 	bl	a42 <Mcu_schm_read_msr>
    bc38:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    bc3a:	9b00      	ldr	r3, [sp, #0]
    bc3c:	f003 0301 	and.w	r3, r3, #1
    bc40:	2b00      	cmp	r3, #0
    bc42:	d100      	bne.n	bc46 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    bc44:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    bc46:	490a      	ldr	r1, [pc, #40]	; (bc70 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    bc48:	9b01      	ldr	r3, [sp, #4]
    bc4a:	9a00      	ldr	r2, [sp, #0]
    bc4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    bc50:	4a06      	ldr	r2, [pc, #24]	; (bc6c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    bc52:	9b01      	ldr	r3, [sp, #4]
    bc54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc58:	1c5a      	adds	r2, r3, #1
    bc5a:	4904      	ldr	r1, [pc, #16]	; (bc6c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    bc5c:	9b01      	ldr	r3, [sp, #4]
    bc5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    bc62:	bf00      	nop
    bc64:	b003      	add	sp, #12
    bc66:	f85d fb04 	ldr.w	pc, [sp], #4
    bc6a:	bf00      	nop
    bc6c:	1fff9030 	.word	0x1fff9030
    bc70:	1fff902c 	.word	0x1fff902c

0000bc74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    bc74:	b500      	push	{lr}
    bc76:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bc78:	f7f5 f9b4 	bl	fe4 <Sys_GetCoreID>
    bc7c:	4603      	mov	r3, r0
    bc7e:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    bc80:	4a0d      	ldr	r2, [pc, #52]	; (bcb8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    bc82:	9b01      	ldr	r3, [sp, #4]
    bc84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc88:	1e5a      	subs	r2, r3, #1
    bc8a:	490b      	ldr	r1, [pc, #44]	; (bcb8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    bc8c:	9b01      	ldr	r3, [sp, #4]
    bc8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    bc92:	4a0a      	ldr	r2, [pc, #40]	; (bcbc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    bc94:	9b01      	ldr	r3, [sp, #4]
    bc96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc9a:	f003 0301 	and.w	r3, r3, #1
    bc9e:	2b00      	cmp	r3, #0
    bca0:	d106      	bne.n	bcb0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    bca2:	4a05      	ldr	r2, [pc, #20]	; (bcb8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    bca4:	9b01      	ldr	r3, [sp, #4]
    bca6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bcaa:	2b00      	cmp	r3, #0
    bcac:	d100      	bne.n	bcb0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    bcae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    bcb0:	bf00      	nop
    bcb2:	b003      	add	sp, #12
    bcb4:	f85d fb04 	ldr.w	pc, [sp], #4
    bcb8:	1fff9030 	.word	0x1fff9030
    bcbc:	1fff902c 	.word	0x1fff902c

0000bcc0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    bcc0:	b500      	push	{lr}
    bcc2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bcc4:	f7f5 f98e 	bl	fe4 <Sys_GetCoreID>
    bcc8:	4603      	mov	r3, r0
    bcca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    bccc:	4a10      	ldr	r2, [pc, #64]	; (bd10 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    bcce:	9b01      	ldr	r3, [sp, #4]
    bcd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bcd4:	2b00      	cmp	r3, #0
    bcd6:	d10d      	bne.n	bcf4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    bcd8:	f7f4 feb3 	bl	a42 <Mcu_schm_read_msr>
    bcdc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    bcde:	9b00      	ldr	r3, [sp, #0]
    bce0:	f003 0301 	and.w	r3, r3, #1
    bce4:	2b00      	cmp	r3, #0
    bce6:	d100      	bne.n	bcea <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    bce8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    bcea:	490a      	ldr	r1, [pc, #40]	; (bd14 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    bcec:	9b01      	ldr	r3, [sp, #4]
    bcee:	9a00      	ldr	r2, [sp, #0]
    bcf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    bcf4:	4a06      	ldr	r2, [pc, #24]	; (bd10 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    bcf6:	9b01      	ldr	r3, [sp, #4]
    bcf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bcfc:	1c5a      	adds	r2, r3, #1
    bcfe:	4904      	ldr	r1, [pc, #16]	; (bd10 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    bd00:	9b01      	ldr	r3, [sp, #4]
    bd02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    bd06:	bf00      	nop
    bd08:	b003      	add	sp, #12
    bd0a:	f85d fb04 	ldr.w	pc, [sp], #4
    bd0e:	bf00      	nop
    bd10:	1fff9038 	.word	0x1fff9038
    bd14:	1fff9034 	.word	0x1fff9034

0000bd18 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    bd18:	b500      	push	{lr}
    bd1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bd1c:	f7f5 f962 	bl	fe4 <Sys_GetCoreID>
    bd20:	4603      	mov	r3, r0
    bd22:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    bd24:	4a0d      	ldr	r2, [pc, #52]	; (bd5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    bd26:	9b01      	ldr	r3, [sp, #4]
    bd28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bd2c:	1e5a      	subs	r2, r3, #1
    bd2e:	490b      	ldr	r1, [pc, #44]	; (bd5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    bd30:	9b01      	ldr	r3, [sp, #4]
    bd32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    bd36:	4a0a      	ldr	r2, [pc, #40]	; (bd60 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    bd38:	9b01      	ldr	r3, [sp, #4]
    bd3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bd3e:	f003 0301 	and.w	r3, r3, #1
    bd42:	2b00      	cmp	r3, #0
    bd44:	d106      	bne.n	bd54 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    bd46:	4a05      	ldr	r2, [pc, #20]	; (bd5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    bd48:	9b01      	ldr	r3, [sp, #4]
    bd4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bd4e:	2b00      	cmp	r3, #0
    bd50:	d100      	bne.n	bd54 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    bd52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    bd54:	bf00      	nop
    bd56:	b003      	add	sp, #12
    bd58:	f85d fb04 	ldr.w	pc, [sp], #4
    bd5c:	1fff9038 	.word	0x1fff9038
    bd60:	1fff9034 	.word	0x1fff9034

0000bd64 <Det_Init>:
*
*/
void Det_Init(void)
{
    /* Do nothing */
}
    bd64:	bf00      	nop
    bd66:	4770      	bx	lr

0000bd68 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
    bd68:	b510      	push	{r4, lr}
    bd6a:	b084      	sub	sp, #16
    bd6c:	4604      	mov	r4, r0
    bd6e:	4608      	mov	r0, r1
    bd70:	4611      	mov	r1, r2
    bd72:	461a      	mov	r2, r3
    bd74:	4623      	mov	r3, r4
    bd76:	f8ad 3006 	strh.w	r3, [sp, #6]
    bd7a:	4603      	mov	r3, r0
    bd7c:	f88d 3005 	strb.w	r3, [sp, #5]
    bd80:	460b      	mov	r3, r1
    bd82:	f88d 3004 	strb.w	r3, [sp, #4]
    bd86:	4613      	mov	r3, r2
    bd88:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    bd8c:	f7f5 f92a 	bl	fe4 <Sys_GetCoreID>
    bd90:	4603      	mov	r3, r0
    bd92:	9303      	str	r3, [sp, #12]

    Det_ModuleId[u32CoreId] = ModuleId;
    bd94:	490d      	ldr	r1, [pc, #52]	; (bdcc <Det_ReportError+0x64>)
    bd96:	9b03      	ldr	r3, [sp, #12]
    bd98:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    bd9c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
    bda0:	4a0b      	ldr	r2, [pc, #44]	; (bdd0 <Det_ReportError+0x68>)
    bda2:	9b03      	ldr	r3, [sp, #12]
    bda4:	4413      	add	r3, r2
    bda6:	f89d 2005 	ldrb.w	r2, [sp, #5]
    bdaa:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
    bdac:	4a09      	ldr	r2, [pc, #36]	; (bdd4 <Det_ReportError+0x6c>)
    bdae:	9b03      	ldr	r3, [sp, #12]
    bdb0:	4413      	add	r3, r2
    bdb2:	f89d 2004 	ldrb.w	r2, [sp, #4]
    bdb6:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
    bdb8:	4a07      	ldr	r2, [pc, #28]	; (bdd8 <Det_ReportError+0x70>)
    bdba:	9b03      	ldr	r3, [sp, #12]
    bdbc:	4413      	add	r3, r2
    bdbe:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bdc2:	701a      	strb	r2, [r3, #0]

    return E_OK;
    bdc4:	2300      	movs	r3, #0
}
    bdc6:	4618      	mov	r0, r3
    bdc8:	b004      	add	sp, #16
    bdca:	bd10      	pop	{r4, pc}
    bdcc:	1fff9064 	.word	0x1fff9064
    bdd0:	1fff903c 	.word	0x1fff903c
    bdd4:	1fff9040 	.word	0x1fff9040
    bdd8:	1fff9044 	.word	0x1fff9044

0000bddc <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
    bddc:	b510      	push	{r4, lr}
    bdde:	b084      	sub	sp, #16
    bde0:	4604      	mov	r4, r0
    bde2:	4608      	mov	r0, r1
    bde4:	4611      	mov	r1, r2
    bde6:	461a      	mov	r2, r3
    bde8:	4623      	mov	r3, r4
    bdea:	f8ad 3006 	strh.w	r3, [sp, #6]
    bdee:	4603      	mov	r3, r0
    bdf0:	f88d 3005 	strb.w	r3, [sp, #5]
    bdf4:	460b      	mov	r3, r1
    bdf6:	f88d 3004 	strb.w	r3, [sp, #4]
    bdfa:	4613      	mov	r3, r2
    bdfc:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    be00:	f7f5 f8f0 	bl	fe4 <Sys_GetCoreID>
    be04:	4603      	mov	r3, r0
    be06:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
    be08:	490d      	ldr	r1, [pc, #52]	; (be40 <Det_ReportRuntimeError+0x64>)
    be0a:	9b03      	ldr	r3, [sp, #12]
    be0c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    be10:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
    be14:	4a0b      	ldr	r2, [pc, #44]	; (be44 <Det_ReportRuntimeError+0x68>)
    be16:	9b03      	ldr	r3, [sp, #12]
    be18:	4413      	add	r3, r2
    be1a:	f89d 2005 	ldrb.w	r2, [sp, #5]
    be1e:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
    be20:	4a09      	ldr	r2, [pc, #36]	; (be48 <Det_ReportRuntimeError+0x6c>)
    be22:	9b03      	ldr	r3, [sp, #12]
    be24:	4413      	add	r3, r2
    be26:	f89d 2004 	ldrb.w	r2, [sp, #4]
    be2a:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
    be2c:	4a07      	ldr	r2, [pc, #28]	; (be4c <Det_ReportRuntimeError+0x70>)
    be2e:	9b03      	ldr	r3, [sp, #12]
    be30:	4413      	add	r3, r2
    be32:	f89d 2003 	ldrb.w	r2, [sp, #3]
    be36:	701a      	strb	r2, [r3, #0]

    return E_OK;
    be38:	2300      	movs	r3, #0
}
    be3a:	4618      	mov	r0, r3
    be3c:	b004      	add	sp, #16
    be3e:	bd10      	pop	{r4, pc}
    be40:	1fff9068 	.word	0x1fff9068
    be44:	1fff9048 	.word	0x1fff9048
    be48:	1fff904c 	.word	0x1fff904c
    be4c:	1fff9050 	.word	0x1fff9050

0000be50 <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
    be50:	b510      	push	{r4, lr}
    be52:	b084      	sub	sp, #16
    be54:	4604      	mov	r4, r0
    be56:	4608      	mov	r0, r1
    be58:	4611      	mov	r1, r2
    be5a:	461a      	mov	r2, r3
    be5c:	4623      	mov	r3, r4
    be5e:	f8ad 3006 	strh.w	r3, [sp, #6]
    be62:	4603      	mov	r3, r0
    be64:	f88d 3005 	strb.w	r3, [sp, #5]
    be68:	460b      	mov	r3, r1
    be6a:	f88d 3004 	strb.w	r3, [sp, #4]
    be6e:	4613      	mov	r3, r2
    be70:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    be74:	f7f5 f8b6 	bl	fe4 <Sys_GetCoreID>
    be78:	4603      	mov	r3, r0
    be7a:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
    be7c:	490d      	ldr	r1, [pc, #52]	; (beb4 <Det_ReportTransientFault+0x64>)
    be7e:	9b03      	ldr	r3, [sp, #12]
    be80:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    be84:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
    be88:	4a0b      	ldr	r2, [pc, #44]	; (beb8 <Det_ReportTransientFault+0x68>)
    be8a:	9b03      	ldr	r3, [sp, #12]
    be8c:	4413      	add	r3, r2
    be8e:	f89d 2005 	ldrb.w	r2, [sp, #5]
    be92:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
    be94:	4a09      	ldr	r2, [pc, #36]	; (bebc <Det_ReportTransientFault+0x6c>)
    be96:	9b03      	ldr	r3, [sp, #12]
    be98:	4413      	add	r3, r2
    be9a:	f89d 2004 	ldrb.w	r2, [sp, #4]
    be9e:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
    bea0:	4a07      	ldr	r2, [pc, #28]	; (bec0 <Det_ReportTransientFault+0x70>)
    bea2:	9b03      	ldr	r3, [sp, #12]
    bea4:	4413      	add	r3, r2
    bea6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    beaa:	701a      	strb	r2, [r3, #0]

    return E_OK;
    beac:	2300      	movs	r3, #0
}
    beae:	4618      	mov	r0, r3
    beb0:	b004      	add	sp, #16
    beb2:	bd10      	pop	{r4, pc}
    beb4:	1fff9060 	.word	0x1fff9060
    beb8:	1fff9054 	.word	0x1fff9054
    bebc:	1fff9058 	.word	0x1fff9058
    bec0:	1fff905c 	.word	0x1fff905c

0000bec4 <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
    bec4:	bf00      	nop
    bec6:	4770      	bx	lr

0000bec8 <Clock_Ip_au8DividerCallbackIndex>:
    bec8:	0c00 0e0d 0201 0603 0409 0a07 0805 000b     ................

0000bed8 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

0000bee8 <Clock_Ip_au8XoscCallbackIndex>:
    bee8:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000bef8 <Clock_Ip_au8IrcoscCallbackIndex>:
    bef8:	0100 0302 0004 0000 0000 0000 0000 0000     ................

0000bf08 <Clock_Ip_au8GateCallbackIndex>:
    bf08:	0200 0601 0301 0104 0500 0000 0000 0000     ................

0000bf18 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

0000bf28 <Clock_Ip_au8PllCallbackIndex>:
    bf28:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000bf38 <Clock_Ip_au8SelectorCallbackIndex>:
    bf38:	0800 0a09 0109 0302 0504 0706 0000 0000     ................

0000bf48 <Clock_Ip_au8PcfsCallbackIndex>:
	...

0000bf58 <Clock_Ip_au8CmuCallbackIndex>:
	...

0000bf68 <Clock_Ip_au8ClockFeatures>:
	...
    bf78:	0000 0100 0000 0000 0000 0000 0002 0000     ................
    bf88:	0000 0000 0300 0000 0000 0000 0000 0004     ................
    bf98:	0000 0000 0000 0500 0000 0000 0000 0000     ................
    bfa8:	0006 0000 0000 0000 0100 0000 0000 0000     ................
    bfb8:	0000 0001 0000 0000 0000 0400 0000 0000     ................
    bfc8:	0000 0000 0005 0000 0001 0000 0401 0000     ................
    bfd8:	0200 0000 0100 0005 0000 0003 0000 0402     ................
    bfe8:	0000 0400 0000 0200 0005 0000 0005 0000     ................
    bff8:	0403 0000 0600 0000 0300 0005 0000 0007     ................
    c008:	0000 0500 0000 0000 0000 0000 0006 0000     ................
	...
    c048:	0000 0005 0000 0000 0000 0600 0100 0000     ................
    c058:	0000 0000 0007 0003 0000 0000 0000 0000     ................
    c068:	0000 0000 0000 0006 0000 0000 0000 0700     ................
    c078:	0100 0000 0000 0000 0008 0003 0000 0000     ................
	...
    c090:	0000 0009 0000 0000 0000 0a00 0100 0000     ................
    c0a0:	0000 0000 000b 0003 0000 0000 0000 0000     ................
    c0b0:	0000 0000 0000 000c 0000 0000 0000 0d00     ................
    c0c0:	0100 0000 0000 0000 000e 0003 0000 0000     ................
    c0d0:	0800 0000 0000 0000 0000 0009 0000 0000     ................
    c0e0:	0000 0a00 0000 0000 0000 0000 000b 0000     ................
    c0f0:	0000 0000 0b01 0000 0000 0000 0200 000b     ................
    c100:	0000 0000 0000 0b03 0000 0000 0000 0000     ................
	...
    c118:	0400 0000 003b 003b 0000 0004 2700 2700     ....;.;......'.'
    c128:	0000 0100 0000 0000 0000 0000 0007 0000     ................
    c138:	7300 0000 0700 0000 0000 0032 0000 0009     .s........2.....
    c148:	0000 0200 0000 0700 0000 0000 0021 0000     ............!...
    c158:	0009 0000 0400 0000 0900 0000 0000 0003     ................
    c168:	0000 0007 0000 6100 0000 0700 0000 0000     .......a........
    c178:	0024 0000 0007 0000 2500 0000 0700 0000     $........%......
    c188:	0000 002b 0000 0004 5a00 5a00 0000 0700     ..+......Z.Z....
    c198:	0000 0000 0020 0000 0004 3800 3800 0000     .... ......8.8..
    c1a8:	0400 0000 0039 0039 0000 0004 3a00 3a00     ....9.9......:.:
    c1b8:	0000 0400 0000 0026 0026 0000 0004 6600     ......&.&......f
    c1c8:	6600 0000 0400 0000 0037 0037 0000 0004     .f......7.7.....
    c1d8:	2c00 2c00 0000 0400 0000 002d 002d 0000     .,.,......-.-...
    c1e8:	0004 2e00 2e00 0000 0200 0000 4040 0040     ............@@@.
    c1f8:	0000 0004 6a00 6a00 0000 0400 0000 006b     .....j.j......k.
    c208:	006b 0000 0004 6c00 6c00 0000 0900 0000     k......l.l......
    c218:	0000 0001 0000 0009 0000 0000 0000 0700     ................
    c228:	0000 0000 0036 0000 0007 0000 3100 0000     ....6........1..
    c238:	0700 0000 0000 0049 0000 0007 0000 4a00     ......I........J
    c248:	0000 0700 0000 0000 004b 0000 0007 0000     ........K.......
    c258:	4c00 0000 0700 0000 0000 004d 0000 0007     .L........M.....
    c268:	0000 3d00 0000 0300 0000 0000 0000 0000     ...=............

0000c278 <Clock_Ip_au16SelectorEntryHardwareValue>:
    c278:	0a03 0101 0001 0101 0002 0404 0603 0200     ................
    c288:	0810 0001 0100 0202 0000 0000 0007 0000     ................
    c298:	0009 0000 0000 0000 0c0e 0000 0000 0000     ................
	...

0000c2d0 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    c2d0:	0000 0002 0300 0000 0601 0000 0000 0000     ................
	...

0000c300 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    c300:	0700 0000 0000 0000 0000 0202 0303 0101     ................
    c310:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000c330 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    c330:	0001 0000 0000 0000 0000 0202 0303 0101     ................
    c340:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000c360 <Clock_Ip_au8DividerValueHardwareValue>:
    c360:	0100 0002 0003 0000 0004 0000 0000 0000     ................
    c370:	0005 0000 0000 0000 0000 0000 0000 0000     ................
    c380:	0006 0000 0000 0000 0000 0000 0000 0000     ................
	...
    c3a0:	0007 0000                                   ....

0000c3a4 <Clock_Ip_apxScgPeriphAsyncDivs>:
    c3a4:	4204 4006 4304 4006 4104 4006 4604 4006     .B.@.C.@.A.@.F.@

0000c3b4 <Clock_Ip_aeSourceTypeClockName>:
    c3b4:	0000 0000 0001 0000 0001 0000 0001 0000     ................
    c3c4:	0001 0000 0001 0000 0001 0000 0001 0000     ................
    c3d4:	0002 0000 0003 0000 0001 0000 0001 0000     ................
    c3e4:	0001 0000 0001 0000 0002 0000 0002 0000     ................
    c3f4:	0003 0000 0003 0000 0001 0000 0001 0000     ................
    c404:	0004 0000 0004 0000 0004 0000 0004 0000     ................
	...

0000c470 <Clock_Ip_aeHwPllName>:
    c470:	0009 0000                                   ....

0000c474 <Clock_Ip_aeHwDfsName>:
    c474:	0057 0000                                   W...

0000c478 <Clock_Ip_axDividerCallbacks>:
    c478:	20f9 0000 2103 0000 211d 0000 2137 0000     . ...!...!..7!..
    c488:	2151 0000 216b 0000 2185 0000 219f 0000     Q!..k!...!...!..
    c498:	21b9 0000 21d3 0000 21ed 0000 2207 0000     .!...!...!..."..
    c4a8:	2221 0000 223b 0000 2255 0000               !"..;"..U"..

0000c4b4 <Clock_Ip_axDividerTriggerCallbacks>:
    c4b4:	25c9 0000 25c9 0000                         .%...%..

0000c4bc <Clock_Ip_axExtOscCallbacks>:
    c4bc:	25d5 0000 25d5 0000 25d5 0000 25df 0000     .%...%...%...%..
    c4cc:	25d5 0000 25e9 0000 2603 0000 261d 0000     .%...%...&...&..
    c4dc:	26a1 0000 26b5 0000                         .&...&..

0000c4e4 <Clock_Ip_axFracDivCallbacks>:
    c4e4:	2875 0000 2875 0000 287f 0000               u(..u(...(..

0000c4f0 <Clock_Ip_axGateCallbacks>:
    c4f0:	2899 0000 28a3 0000 29a3 0000 29bd 0000     .(...(...)...)..
    c500:	2953 0000 296d 0000 2903 0000 291d 0000     S)..m)...)...)..
    c510:	28b3 0000 28cd 0000 29f3 0000 2a0d 0000     .(...(...)...*..
    c520:	2a43 0000 2a5d 0000                         C*..]*..

0000c528 <Clock_Ip_axIntOscCallbacks>:
    c528:	2c09 0000 2c09 0000 2c13 0000 2c1d 0000     .,...,...,...,..
    c538:	2c37 0000 2c51 0000 2c65 0000 2c7f 0000     7,..Q,..e,...,..
    c548:	2c99 0000 2cad 0000 2cc7 0000 2ce1 0000     .,...,...,...,..
    c558:	2d89 0000 2da3 0000 2dbd 0000               .-...-...-..

0000c564 <Clock_Ip_axCmuCallbacks>:
    c564:	3359 0000 3363 0000 336f 0000 3359 0000     Y3..c3..o3..Y3..

0000c574 <Clock_Ip_axPllCallbacks>:
    c574:	3379 0000 3379 0000 3383 0000 3379 0000     y3..y3...3..y3..
    c584:	338f 0000 3399 0000 33b3 0000 33cd 0000     .3...3...3...3..
    c594:	3471 0000 345d 0000                         q4..]4..

0000c59c <Clock_Ip_axPcfsCallbacks>:
    c59c:	35cd 0000                                   .5..

0000c5a0 <Clock_Ip_axSelectorCallbacks>:
    c5a0:	35d9 0000 35d9 0000 35e3 0000 35fd 0000     .5...5...5...5..
    c5b0:	35d9 0000 3617 0000 3631 0000 364b 0000     .5...6..16..K6..
    c5c0:	3665 0000 367f 0000 3699 0000 36b3 0000     e6...6...6...6..
    c5d0:	36cd 0000 36e7 0000 3701 0000 371b 0000     .6...6...7...7..
    c5e0:	3735 0000 374f 0000 3769 0000 3783 0000     57..O7..i7...7..
    c5f0:	379d 0000 37b7 0000                         .7...7..

0000c5f8 <ClockSource>:
    c5f8:	0000 0000 0008 0000 0002 0000 0005 0000     ................
	...
    c610:	0009 0000                                   ....

0000c614 <ResetReasonArray>:
    c614:	0000 0000 0001 0000 0002 0000 0003 0000     ................
    c624:	0004 0000 0005 0000 0006 0000 0007 0000     ................
    c634:	0008 0000 0009 0000 000a 0000 000b 0000     ................
    c644:	000c 0000 000d 0000 000e 0000               ............

0000c650 <Flexcan_Ip_apxBase>:
    c650:	4000 4002 5000 4002 b000 4002               .@.@.P.@...@

0000c65c <payload_code.3>:
    c65c:	0100 0302 0504 0706 0908 0909 0a09 0a0a     ................
    c66c:	0b0a 0b0b 0c0b 0c0c 0d0c 0d0d 0d0d 0d0d     ................
    c67c:	0e0d 0e0e 0e0e 0e0e 0e0e 0e0e 0e0e 0e0e     ................
    c68c:	0f0e 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f     ................
    c69c:	000f 0000                                   ....

0000c6a0 <flexcanBase.2>:
    c6a0:	4000 4002 5000 4002 b000 4002               .@.@.P.@...@

0000c6ac <maxMbNum.1>:
    c6ac:	0020 0000 0010 0000 0010 0000                ...........

0000c6b8 <flexcanBase.0>:
    c6b8:	4000 4002                                   .@.@

0000c6bc <Task_Config>:
    c6bc:	0032 0000 0001 0000 09b9 0000 0064 0000     2...........d...
    c6cc:	0000 0000 0e55 0000 03e8 0000 0000 0000     ....U...........
    c6dc:	0e49 0000 0bb8 0000 0000 0000 0e4d 0000     I...........M...
    c6ec:	0005 0000 0001 0000 09e9 0000 0bb8 0000     ................
    c6fc:	0000 0000 0e51 0000                         ....Q...

0000c704 <Timer_Config>:
	...

0000c710 <Queue_Config>:
    c710:	0002 0000 000a 0000 0000 0000               ............

0000c71c <Scheduler_Config>:
    c71c:	000a 0000 0006 0000 c6bc 0000 0001 0000     ................
    c72c:	c704 0000 0001 0000 c710 0000               ............

0000c738 <Can_43_FLEXCANIpwHwChannelConfig0>:
    c738:	cc00 0000                                   ....

0000c73c <Can_au32HwBufferAddr_Ctrl0>:
    c73c:	4080 4002 4090 4002                         .@.@.@.@

0000c744 <Can_aHwFilter_Object0>:
    c744:	0000 0000 0000 c000                         ........

0000c74c <Can_aCtrlOffsetToCtrlIDMap>:
    c74c:	ff00 00ff                                   ....

0000c750 <Can_aHwObjIDToCtrlIDMap>:
    c750:	0000 0000                                   ....

0000c754 <Can_aHwObjectConfig>:
	...
    c760:	0001 0001 0008 0001 c744 0000 0000 0000     ........D.......
    c770:	0000 0000 c73c 0000 0001 0000 0001 0000     ....<...........
    c780:	0000 0000 0001 0001 0008 0000 0000 0000     ................
    c790:	0003 0000 0001 0000 c740 0000               ........@...

0000c79c <Can_aBaudrateConfig_Ctrl0>:
    c79c:	0000 0403 0005 001d 0000 0000 0000 0000     ................
	...

0000c7b4 <Can_apHwObject_Ctrl0>:
    c7b4:	c754 0000 c778 0000                         T...x...

0000c7bc <Can_aControllerConfig>:
    c7bc:	0000 0000 4000 4002 0101 0000 ffff ffff     .....@.@........
	...
    c7d8:	0000 0001 c79c 0000 c738 0000 0002 0000     ........8.......
    c7e8:	c7b4 0000                                   ....

0000c7ec <Can_apController>:
    c7ec:	c7bc 0000                                   ....

0000c7f0 <Can_43_FLEXCAN_Config>:
    c7f0:	0000 0000 0001 0000 c74c 0000 c750 0000     ........L...P...
    c800:	c754 0000 c7ec 0000                         T.......

0000c808 <Mcu_aClockConfigPB>:
	...
    c810:	0101 1c00 0010 0400 0029 0100 0005 0000     ........).......
    c820:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    c830:	0000 0000 0008 0000 1200 007a 0001 0000     ..........z.....
    c840:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    c850:	0057 0000 0000 0000 0000 0000 0000 0000     W...............
	...
    c870:	0019 0000 0005 0000 001a 0000 0002 0000     ................
    c880:	001b 0000 0005 0000 002a 0000 0005 0000     ........*.......
    c890:	0028 0000 000e 0000 0029 0000 0001 0000     (.......).......
    c8a0:	0056 0000 001c 0000 0032 0000 002a 0000     V.......2...*...
    c8b0:	002b 0000 0014 0000 002c 0000 0014 0000     +.......,.......
    c8c0:	002d 0000 0014 0000 002e 0000 0014 0000     -...............
    c8d0:	003f 0000 0000 0000 0040 0000 0000 0000     ?.......@.......
    c8e0:	0041 0000 0000 0000 0042 0000 0000 0000     A.......B.......
    c8f0:	0031 0000 0000 0000 0045 0000 0000 0000     1.......E.......
    c900:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    c910:	0044 0000 0000 0000 0030 0000 0000 0000     D.......0.......
    c920:	003d 0000 0000 0000 0043 0000 0000 0000     =.......C.......
    c930:	0049 0000 0000 0000 004a 0000 0000 0000     I.......J.......
    c940:	004b 0000 0000 0000 0048 0000 0000 0000     K.......H.......
    c950:	000c 0000 0001 0000 0000 0000 000d 0000     ................
    c960:	0002 0000 0000 0000 000e 0000 0001 0000     ................
    c970:	0000 0000 000f 0000 0001 0000 0000 0000     ................
    c980:	001d 0000 0001 0000 0000 0000 001e 0000     ................
    c990:	0008 0000 0000 0000 001f 0000 0001 0000     ................
    c9a0:	0000 0000 0021 0000 0001 0000 0000 0000     ....!...........
    c9b0:	0022 0000 0002 0000 0000 0000 0023 0000     "...........#...
    c9c0:	0001 0000 0000 0000 0025 0000 0003 0000     ........%.......
    c9d0:	0000 0000 0026 0000 0004 0000 0000 0000     ....&...........
    c9e0:	0027 0000 0002 0000 0000 0000 0032 0000     '...........2...
    c9f0:	0001 0000 0000 0000 0048 0000 0001 0000     ........H.......
    ca00:	0001 0000 0056 0000 0001 0000 0001 0000     ....V...........
    ca10:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    ca28:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    ca40:	0057 0000 0000 0000 0057 0000 0057 0000     W.......W...W...
	...
    ca5c:	0014 0000 7d00 0000 0015 0000 7d00 0000     .....}.......}..
    ca6c:	0016 0000 7d00 0000 0017 0000 8000 0000     .....}..........
    ca7c:	0012 0000 0001 0000 0013 0000 0001 0000     ................
    ca8c:	0030 0000 0000 0000 0031 0000 0000 0000     0.......1.......
    ca9c:	0032 0000 0000 0000 0033 0000 0000 0000     2.......3.......
    caac:	0034 0000 0000 0000 0035 0000 0001 0000     4.......5.......
    cabc:	0036 0000 0000 0000 0037 0000 0001 0000     6.......7.......
    cacc:	0038 0000 0001 0000 0039 0000 0000 0000     8.......9.......
    cadc:	003a 0000 0001 0000 003b 0000 0000 0000     :.......;.......
    caec:	003c 0000 0000 0000 003d 0000 0000 0000     <.......=.......
    cafc:	003e 0000 0000 0000 003f 0000 0000 0000     >.......?.......
    cb0c:	0040 0000 0000 0000 0041 0000 0000 0000     @.......A.......
    cb1c:	0042 0000 0000 0000 0043 0000 0000 0000     B.......C.......
    cb2c:	0044 0000 0000 0000 0045 0000 0000 0000     D.......E.......
    cb3c:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    cb4c:	0048 0000 0000 0000 0049 0000 0000 0000     H.......I.......
    cb5c:	004a 0000 0000 0000 004b 0000 0000 0000     J.......K.......
    cb6c:	004c 0000 0001 0000 004d 0000 0001 0000     L.......M.......
    cb7c:	004e 0000 0000 0000 004f 0000 0000 0000     N.......O.......
    cb8c:	0050 0000 0001 0000 0051 0000 0001 0000     P.......Q.......
    cb9c:	0052 0000 0001 0000 0053 0000 0001 0000     R.......S.......
    cbac:	0054 0000 0001 0000 0055 0000 0000 0000     T.......U.......
    cbbc:	0056 0000 0001 0000 0057 0000 0000 0000     V.......W.......
    cbcc:	0000 0000 0057 0000 0000 0000 0057 0000     ....W.......W...
	...

0000cc00 <Flexcan_aCtrlConfigPB>:
    cc00:	0002 0000 0000 0000 0000 0000 0002 0000     ................
    cc10:	0040 0000 0000 0000 0100 0000 0003 0000     @...............
    cc20:	0004 0000 0005 0000 001d 0000 0000 0000     ................
    cc30:	0004 0000 0004 0000 0005 0000 001d 0000     ................
	...
    cc4c:	6af5 0000                                   .j..

0000cc50 <Mcu_Config>:
    cc50:	005a 0000 0000 0000 0001 0000 0001 0000     Z...............
    cc60:	cc88 0000 c808 0000 cc94 0000               ............

0000cc6c <OsIf_xPredefinedConfig>:
    cc6c:	0000 0000 6c00 02dc                         .....l..

0000cc74 <OsIf_apxPredefinedConfig>:
    cc74:	cc6c 0000                                   l...

0000cc78 <Power_Ip_RCM_ConfigPB>:
	...

0000cc80 <Power_Ip_PMC_ConfigPB>:
    cc80:	0000 0000                                   ....

0000cc84 <Power_Ip_SMC_ConfigPB>:
    cc84:	0000 0000                                   ....

0000cc88 <Power_Ip_aModeConfigPB>:
	...

0000cc94 <Power_Ip_HwIPsConfigPB>:
    cc94:	cc78 0000 cc80 0000 cc84 0000               x...........

0000cca0 <__INIT_TABLE>:
    cca0:	00000002 	.word	0x00000002
    cca4:	1fff8b10 	.word	0x1fff8b10
    cca8:	0000ccc8 	.word	0x0000ccc8
    ccac:	0000cce4 	.word	0x0000cce4
    ccb0:	1fff8800 	.word	0x1fff8800
    ccb4:	00000000 	.word	0x00000000
    ccb8:	00000310 	.word	0x00000310

0000ccbc <__ZERO_TABLE>:
    ccbc:	00000001 	.word	0x00000001
    ccc0:	1fff8b30 	.word	0x1fff8b30
    ccc4:	1fff90d0 	.word	0x1fff90d0
