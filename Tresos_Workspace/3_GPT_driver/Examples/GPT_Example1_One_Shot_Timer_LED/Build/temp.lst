
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000bb3 	.word	0x00000bb3
  10:	00000bb5 	.word	0x00000bb5
  14:	00000bb7 	.word	0x00000bb7
  18:	00000bb9 	.word	0x00000bb9
	...
  2c:	00000bbb 	.word	0x00000bbb
  30:	00000bbd 	.word	0x00000bbd
  34:	00000000 	.word	0x00000000
  38:	00000bbf 	.word	0x00000bbf
  3c:	00000bc1 	.word	0x00000bc1
  40:	00000bc3 	.word	0x00000bc3
  44:	00000bc3 	.word	0x00000bc3
  48:	00000bc3 	.word	0x00000bc3
  4c:	00000bc3 	.word	0x00000bc3
  50:	00000bc3 	.word	0x00000bc3
  54:	00000bc3 	.word	0x00000bc3
  58:	00000bc3 	.word	0x00000bc3
  5c:	00000bc3 	.word	0x00000bc3
  60:	00000bc3 	.word	0x00000bc3
  64:	00000bc3 	.word	0x00000bc3
  68:	00000bc3 	.word	0x00000bc3
  6c:	00000bc3 	.word	0x00000bc3
  70:	00000bc3 	.word	0x00000bc3
  74:	00000bc3 	.word	0x00000bc3
  78:	00000bc3 	.word	0x00000bc3
  7c:	00000bc3 	.word	0x00000bc3
  80:	00000bc3 	.word	0x00000bc3
  84:	00000bc3 	.word	0x00000bc3
  88:	00000bc3 	.word	0x00000bc3
  8c:	00000bc3 	.word	0x00000bc3
  90:	00000bc3 	.word	0x00000bc3
  94:	00000bc3 	.word	0x00000bc3
  98:	00000bc3 	.word	0x00000bc3
  9c:	00000bc3 	.word	0x00000bc3
  a0:	00000bc3 	.word	0x00000bc3
  a4:	00000bc3 	.word	0x00000bc3
  a8:	00000bc3 	.word	0x00000bc3
  ac:	00000bc3 	.word	0x00000bc3
  b0:	00000bc3 	.word	0x00000bc3
  b4:	00000bc3 	.word	0x00000bc3
  b8:	00000bc3 	.word	0x00000bc3
  bc:	00000bc3 	.word	0x00000bc3
  c0:	00000bc3 	.word	0x00000bc3
  c4:	00000bc3 	.word	0x00000bc3
  c8:	00000bc3 	.word	0x00000bc3
  cc:	00000bc3 	.word	0x00000bc3
  d0:	00000bc3 	.word	0x00000bc3
  d4:	00000bc3 	.word	0x00000bc3
  d8:	00000bc3 	.word	0x00000bc3
  dc:	00000bc3 	.word	0x00000bc3
  e0:	00000bc3 	.word	0x00000bc3
  e4:	00000bc3 	.word	0x00000bc3
  e8:	00000bc3 	.word	0x00000bc3
  ec:	00000bc3 	.word	0x00000bc3
  f0:	00000bc3 	.word	0x00000bc3
  f4:	00000bc3 	.word	0x00000bc3
  f8:	00000bc3 	.word	0x00000bc3
  fc:	00000bc3 	.word	0x00000bc3
 100:	00000bc3 	.word	0x00000bc3
 104:	00000bc3 	.word	0x00000bc3
 108:	00000bc3 	.word	0x00000bc3
 10c:	00000bc3 	.word	0x00000bc3
 110:	00000bc3 	.word	0x00000bc3
 114:	00000bc3 	.word	0x00000bc3
 118:	00000bc3 	.word	0x00000bc3
 11c:	00000bc3 	.word	0x00000bc3
 120:	00000bc3 	.word	0x00000bc3
 124:	00000bc3 	.word	0x00000bc3
 128:	00000bc3 	.word	0x00000bc3
 12c:	00000bc3 	.word	0x00000bc3
 130:	00000bc3 	.word	0x00000bc3
 134:	00000bc3 	.word	0x00000bc3
 138:	00000bc3 	.word	0x00000bc3
 13c:	00000bc3 	.word	0x00000bc3
 140:	00000bc3 	.word	0x00000bc3
 144:	00000bc3 	.word	0x00000bc3
 148:	00000bc3 	.word	0x00000bc3
 14c:	00000bc3 	.word	0x00000bc3
 150:	00000bc3 	.word	0x00000bc3
 154:	00000bc3 	.word	0x00000bc3
 158:	00000bc3 	.word	0x00000bc3
 15c:	00000bc3 	.word	0x00000bc3
 160:	00000bc3 	.word	0x00000bc3
 164:	00000bc3 	.word	0x00000bc3
 168:	00000bc3 	.word	0x00000bc3
 16c:	00000bc3 	.word	0x00000bc3
 170:	00000bc3 	.word	0x00000bc3
 174:	00000bc3 	.word	0x00000bc3
 178:	00000bc3 	.word	0x00000bc3
 17c:	00000bc3 	.word	0x00000bc3
 180:	00000bc3 	.word	0x00000bc3
 184:	00000bc3 	.word	0x00000bc3
 188:	00000bc3 	.word	0x00000bc3
 18c:	00000bc3 	.word	0x00000bc3
 190:	00000bc3 	.word	0x00000bc3
 194:	00000bc3 	.word	0x00000bc3
 198:	00000bc3 	.word	0x00000bc3
 19c:	00000bc3 	.word	0x00000bc3
 1a0:	00000bc3 	.word	0x00000bc3
 1a4:	00000bc3 	.word	0x00000bc3
 1a8:	00000bc3 	.word	0x00000bc3
 1ac:	00000bc3 	.word	0x00000bc3
 1b0:	00000bc3 	.word	0x00000bc3
 1b4:	00000bc3 	.word	0x00000bc3
 1b8:	00000bc3 	.word	0x00000bc3
 1bc:	00000bc3 	.word	0x00000bc3
 1c0:	00000bc3 	.word	0x00000bc3
 1c4:	00000bc3 	.word	0x00000bc3
 1c8:	00000bc3 	.word	0x00000bc3
 1cc:	00000bc3 	.word	0x00000bc3
 1d0:	00000bc3 	.word	0x00000bc3
 1d4:	00000bc3 	.word	0x00000bc3
 1d8:	00000bc3 	.word	0x00000bc3
 1dc:	00000bc3 	.word	0x00000bc3
 1e0:	00000bc3 	.word	0x00000bc3
 1e4:	00000bc3 	.word	0x00000bc3
 1e8:	00000bc3 	.word	0x00000bc3
 1ec:	00000bc3 	.word	0x00000bc3
 1f0:	00000bc3 	.word	0x00000bc3
 1f4:	00000bc3 	.word	0x00000bc3
 1f8:	00000bc3 	.word	0x00000bc3
 1fc:	00000bc3 	.word	0x00000bc3
 200:	00000bc3 	.word	0x00000bc3
 204:	00000bc3 	.word	0x00000bc3
 208:	00000bc3 	.word	0x00000bc3
 20c:	00000bc3 	.word	0x00000bc3
 210:	00000bc3 	.word	0x00000bc3
 214:	00000bc3 	.word	0x00000bc3
 218:	00000bc3 	.word	0x00000bc3
 21c:	00000bc3 	.word	0x00000bc3
 220:	00000bc3 	.word	0x00000bc3
 224:	00000bc3 	.word	0x00000bc3
 228:	00000bc3 	.word	0x00000bc3
 22c:	00000bc3 	.word	0x00000bc3
 230:	00000bc3 	.word	0x00000bc3
 234:	00000bc3 	.word	0x00000bc3
 238:	00000bc3 	.word	0x00000bc3
 23c:	00000bc3 	.word	0x00000bc3
 240:	00000bc3 	.word	0x00000bc3
 244:	00000bc3 	.word	0x00000bc3
 248:	00000bc3 	.word	0x00000bc3
 24c:	00000bc3 	.word	0x00000bc3
 250:	00000bc3 	.word	0x00000bc3
 254:	00000bc3 	.word	0x00000bc3
 258:	00000bc3 	.word	0x00000bc3
 25c:	00000bc3 	.word	0x00000bc3
 260:	00000bc3 	.word	0x00000bc3
 264:	00000bc3 	.word	0x00000bc3
 268:	00000bc3 	.word	0x00000bc3
 26c:	00000bc3 	.word	0x00000bc3
 270:	00000bc3 	.word	0x00000bc3
 274:	00000bc3 	.word	0x00000bc3
 278:	00000bc3 	.word	0x00000bc3
 27c:	00000bc3 	.word	0x00000bc3
 280:	00000bc3 	.word	0x00000bc3
 284:	00000bc3 	.word	0x00000bc3
 288:	00000bc3 	.word	0x00000bc3
 28c:	00000bc3 	.word	0x00000bc3
 290:	00000bc3 	.word	0x00000bc3
 294:	00000bc3 	.word	0x00000bc3
 298:	00000bc3 	.word	0x00000bc3
 29c:	00000bc3 	.word	0x00000bc3
 2a0:	00000bc3 	.word	0x00000bc3
 2a4:	00000bc3 	.word	0x00000bc3
 2a8:	00000bc3 	.word	0x00000bc3
 2ac:	00000bc3 	.word	0x00000bc3
 2b0:	00000bc3 	.word	0x00000bc3
 2b4:	00000bc3 	.word	0x00000bc3
 2b8:	00000bc3 	.word	0x00000bc3
 2bc:	00000bc3 	.word	0x00000bc3
 2c0:	00000bc3 	.word	0x00000bc3
 2c4:	00000bc3 	.word	0x00000bc3
 2c8:	00000bc3 	.word	0x00000bc3
 2cc:	00000bc3 	.word	0x00000bc3
 2d0:	00000bc3 	.word	0x00000bc3
 2d4:	00000bc3 	.word	0x00000bc3
 2d8:	00000bc3 	.word	0x00000bc3
 2dc:	00000bc3 	.word	0x00000bc3
 2e0:	00000bc3 	.word	0x00000bc3
 2e4:	00000bc3 	.word	0x00000bc3
 2e8:	00000bc3 	.word	0x00000bc3
 2ec:	00000bc3 	.word	0x00000bc3
 2f0:	00000bc3 	.word	0x00000bc3
 2f4:	00000bc3 	.word	0x00000bc3
 2f8:	00000bc3 	.word	0x00000bc3
 2fc:	00000bc3 	.word	0x00000bc3
 300:	00000bc3 	.word	0x00000bc3
 304:	00000bc3 	.word	0x00000bc3
 308:	00000bc3 	.word	0x00000bc3
 30c:	00000bc3 	.word	0x00000bc3

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 facd 	bl	a20 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fb8c 	bl	ba8 <startup_go_to_user_mode>
     490:	f000 fa0e 	bl	8b0 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff9098 	.word	0x1fff9098

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fad7 	bl	b4c <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     8b0:	b508      	push	{r3, lr}
    EcuM_Init();
     8b2:	f000 f817 	bl	8e4 <EcuM_Init>
    /*Start the timer and set it to Running state*/
    /*  Counter = ( Timeout * Tfrec ) / Preescler
        Counter = ( 0.100 * 48MHz ) / 128 = 37,500      */
    Gpt_StartTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0, 37500u );
     8b6:	f249 217c 	movw	r1, #37500	; 0x927c
     8ba:	2000      	movs	r0, #0
     8bc:	f006 fa38 	bl	6d30 <Gpt_StartTimer>

    while( 1u )
    {
        if( Gpt_GetTimeRemaining( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 ) == 0u )
     8c0:	2000      	movs	r0, #0
     8c2:	f006 f9b9 	bl	6c38 <Gpt_GetTimeRemaining>
     8c6:	4603      	mov	r3, r0
     8c8:	2b00      	cmp	r3, #0
     8ca:	d1f9      	bne.n	8c0 <main+0x10>
        {
            /*if we are not using notifications it is neceseary to change the channel status from running
            manually, we can use the Stop function for that purpose, otherwise the Start function will 
            never reload the timer with a new count again */
            Gpt_StopTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 );
     8cc:	2000      	movs	r0, #0
     8ce:	f006 fa9d 	bl	6e0c <Gpt_StopTimer>
            //Dio_FlipChannel( DioConf_DioChannel_D16_GREEN_LED );
            Dio_FlipChannel( DioConf_DioChannel_D0_BLUE_LED );
     8d2:	2060      	movs	r0, #96	; 0x60
     8d4:	f005 f861 	bl	599a <Dio_FlipChannel>
            /*start the timer again*/
            Gpt_StartTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0, 37500u );
     8d8:	f249 217c 	movw	r1, #37500	; 0x927c
     8dc:	2000      	movs	r0, #0
     8de:	f006 fa27 	bl	6d30 <Gpt_StartTimer>
        if( Gpt_GetTimeRemaining( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 ) == 0u )
     8e2:	e7ed      	b.n	8c0 <main+0x10>

000008e4 <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     8e4:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );
     8e6:	4808      	ldr	r0, [pc, #32]	; (908 <EcuM_Init+0x24>)
     8e8:	f003 ff16 	bl	4718 <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     8ec:	2000      	movs	r0, #0
     8ee:	f003 ff67 	bl	47c0 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     8f2:	2000      	movs	r0, #0
     8f4:	f003 ff88 	bl	4808 <Mcu_SetMode>
    /*Apply all the Pin Port microcontroller configuration, for this case
    ports D16 and D0 are configured as output*/
    Port_Init( &Port_Config );
     8f8:	4804      	ldr	r0, [pc, #16]	; (90c <EcuM_Init+0x28>)
     8fa:	f004 fb0f 	bl	4f1c <Port_Init>
    /*Apply Gpt configuration for FTM0 channel 0*/
    Gpt_Init( &Gpt_Config );
     8fe:	4804      	ldr	r0, [pc, #16]	; (910 <EcuM_Init+0x2c>)
     900:	f005 fffa 	bl	68f8 <Gpt_Init>
}
     904:	bf00      	nop
     906:	bd08      	pop	{r3, pc}
     908:	0000bb3c 	.word	0x0000bb3c
     90c:	0000bc98 	.word	0x0000bc98
     910:	0000bb24 	.word	0x0000bb24

00000914 <Gpt_Ipw_FtmGetTimeElapsed>:
#define GPT_START_SEC_CODE
#include "Gpt_MemMap.h"

#if (FTM_GPT_IP_USED == STD_ON)
static Gpt_ValueType Gpt_Ipw_FtmGetTimeElapsed(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig, Gpt_HwChannelInfoType * pReturnHwChannelInfo)
{
     914:	b500      	push	{lr}
     916:	b087      	sub	sp, #28
     918:	9001      	str	r0, [sp, #4]
     91a:	9100      	str	r1, [sp, #0]
    Gpt_ValueType returnValue;
    boolean HasChEvOccurred;

    /* Read compare and counter registers */
    uint32 counterValue = Ftm_Gpt_Ip_GetCntValue(pHwChannelConfig->instance);
     91c:	9b01      	ldr	r3, [sp, #4]
     91e:	791b      	ldrb	r3, [r3, #4]
     920:	4618      	mov	r0, r3
     922:	f006 fd79 	bl	7418 <Ftm_Gpt_Ip_GetCntValue>
     926:	9004      	str	r0, [sp, #16]
    uint32 compareValue = Ftm_Gpt_Ip_GetCompareValue(pHwChannelConfig->instance, pHwChannelConfig->channel);
     928:	9b01      	ldr	r3, [sp, #4]
     92a:	791a      	ldrb	r2, [r3, #4]
     92c:	9b01      	ldr	r3, [sp, #4]
     92e:	795b      	ldrb	r3, [r3, #5]
     930:	4619      	mov	r1, r3
     932:	4610      	mov	r0, r2
     934:	f006 fd80 	bl	7438 <Ftm_Gpt_Ip_GetCompareValue>
     938:	9003      	str	r0, [sp, #12]

    pReturnHwChannelInfo->uTargetTime = Ftm_Gpt_Ip_u32TargetValue[pHwChannelConfig->instance][pHwChannelConfig->channel];
     93a:	9b01      	ldr	r3, [sp, #4]
     93c:	791b      	ldrb	r3, [r3, #4]
     93e:	4618      	mov	r0, r3
     940:	9b01      	ldr	r3, [sp, #4]
     942:	795b      	ldrb	r3, [r3, #5]
     944:	4619      	mov	r1, r3
     946:	4a23      	ldr	r2, [pc, #140]	; (9d4 <Gpt_Ipw_FtmGetTimeElapsed+0xc0>)
     948:	00c3      	lsls	r3, r0, #3
     94a:	440b      	add	r3, r1
     94c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     950:	9b00      	ldr	r3, [sp, #0]
     952:	605a      	str	r2, [r3, #4]

    /* Calculate the elapsed time */
    if (counterValue > compareValue)
     954:	9a04      	ldr	r2, [sp, #16]
     956:	9b03      	ldr	r3, [sp, #12]
     958:	429a      	cmp	r2, r3
     95a:	d918      	bls.n	98e <Gpt_Ipw_FtmGetTimeElapsed+0x7a>
    {
        /* Counter value passed the set-up Target value - might have roll-over */
        if(((FTM_CNT_MAX_VALUE_U32 - counterValue) + compareValue) <= pReturnHwChannelInfo->uTargetTime)
     95c:	9a03      	ldr	r2, [sp, #12]
     95e:	9b04      	ldr	r3, [sp, #16]
     960:	1ad3      	subs	r3, r2, r3
     962:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
     966:	33ff      	adds	r3, #255	; 0xff
     968:	9a00      	ldr	r2, [sp, #0]
     96a:	6852      	ldr	r2, [r2, #4]
     96c:	4293      	cmp	r3, r2
     96e:	d80a      	bhi.n	986 <Gpt_Ipw_FtmGetTimeElapsed+0x72>
        {
            /* New compare value was read by register read - isr served in time - we have roll-over */
            returnValue =   (Gpt_ValueType)(    (   pReturnHwChannelInfo->uTargetTime - \
     970:	9b00      	ldr	r3, [sp, #0]
     972:	685a      	ldr	r2, [r3, #4]
                                                    ((FTM_CNT_MAX_VALUE_U32 - counterValue) + compareValue) ) + \
     974:	9904      	ldr	r1, [sp, #16]
     976:	9b03      	ldr	r3, [sp, #12]
     978:	1acb      	subs	r3, r1, r3
            returnValue =   (Gpt_ValueType)(    (   pReturnHwChannelInfo->uTargetTime - \
     97a:	4413      	add	r3, r2
     97c:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
     980:	3bfe      	subs	r3, #254	; 0xfe
     982:	9305      	str	r3, [sp, #20]
     984:	e00a      	b.n	99c <Gpt_Ipw_FtmGetTimeElapsed+0x88>
                                                FTM_OVERFLOW_PAD_U32 );
        }
        else
        {
            /* There is an delay in serving ISR or updating u32CompareValue - report last timer time */
            returnValue = (Gpt_ValueType)(pReturnHwChannelInfo->uTargetTime);
     986:	9b00      	ldr	r3, [sp, #0]
     988:	685b      	ldr	r3, [r3, #4]
     98a:	9305      	str	r3, [sp, #20]
     98c:	e006      	b.n	99c <Gpt_Ipw_FtmGetTimeElapsed+0x88>
        }
    }
    else
    {
        /* Timer in between ISRs period */
        returnValue = (Gpt_ValueType)(pReturnHwChannelInfo->uTargetTime - (compareValue - counterValue));
     98e:	9b00      	ldr	r3, [sp, #0]
     990:	685a      	ldr	r2, [r3, #4]
     992:	9904      	ldr	r1, [sp, #16]
     994:	9b03      	ldr	r3, [sp, #12]
     996:	1acb      	subs	r3, r1, r3
     998:	4413      	add	r3, r2
     99a:	9305      	str	r3, [sp, #20]
    }

    /* check if channel event has occurred */
    HasChEvOccurred = Ftm_Gpt_Ip_GetChInterruptStatusFlag(pHwChannelConfig->instance, pHwChannelConfig->channel);
     99c:	9b01      	ldr	r3, [sp, #4]
     99e:	791a      	ldrb	r2, [r3, #4]
     9a0:	9b01      	ldr	r3, [sp, #4]
     9a2:	795b      	ldrb	r3, [r3, #5]
     9a4:	4619      	mov	r1, r3
     9a6:	4610      	mov	r0, r2
     9a8:	f006 fd16 	bl	73d8 <Ftm_Gpt_Ip_GetChInterruptStatusFlag>
     9ac:	4603      	mov	r3, r0
     9ae:	f88d 300b 	strb.w	r3, [sp, #11]

    /*Check interrupt status flag*/
    if (HasChEvOccurred)
     9b2:	f89d 300b 	ldrb.w	r3, [sp, #11]
     9b6:	2b00      	cmp	r3, #0
     9b8:	d003      	beq.n	9c2 <Gpt_Ipw_FtmGetTimeElapsed+0xae>
    {
        /* Channel counter was roll-over */
        pReturnHwChannelInfo->bChannelRollover = TRUE;
     9ba:	9b00      	ldr	r3, [sp, #0]
     9bc:	2201      	movs	r2, #1
     9be:	701a      	strb	r2, [r3, #0]
     9c0:	e002      	b.n	9c8 <Gpt_Ipw_FtmGetTimeElapsed+0xb4>
    }
    else
    {
        /* Channel counter was not rollover */
        pReturnHwChannelInfo->bChannelRollover = FALSE;
     9c2:	9b00      	ldr	r3, [sp, #0]
     9c4:	2200      	movs	r2, #0
     9c6:	701a      	strb	r2, [r3, #0]
    }
    return returnValue;
     9c8:	9b05      	ldr	r3, [sp, #20]
}
     9ca:	4618      	mov	r0, r3
     9cc:	b007      	add	sp, #28
     9ce:	f85d fb04 	ldr.w	pc, [sp], #4
     9d2:	bf00      	nop
     9d4:	1fff8d18 	.word	0x1fff8d18

000009d8 <Dio_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Dio_schm_read_msr(void)
{
     9d8:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9da:	f3ef 8310 	mrs	r3, PRIMASK
     9de:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9e0:	4623      	mov	r3, r4
}
     9e2:	4618      	mov	r0, r3
     9e4:	f85d 4b04 	ldr.w	r4, [sp], #4
     9e8:	4770      	bx	lr

000009ea <Gpt_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Gpt_schm_read_msr(void)
{
     9ea:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9ec:	f3ef 8310 	mrs	r3, PRIMASK
     9f0:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9f2:	4623      	mov	r3, r4
}
     9f4:	4618      	mov	r0, r3
     9f6:	f85d 4b04 	ldr.w	r4, [sp], #4
     9fa:	4770      	bx	lr

000009fc <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     9fc:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9fe:	f3ef 8310 	mrs	r3, PRIMASK
     a02:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a04:	4623      	mov	r3, r4
}
     a06:	4618      	mov	r0, r3
     a08:	f85d 4b04 	ldr.w	r4, [sp], #4
     a0c:	4770      	bx	lr

00000a0e <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     a0e:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     a10:	f3ef 8310 	mrs	r3, PRIMASK
     a14:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a16:	4623      	mov	r3, r4
}
     a18:	4618      	mov	r0, r3
     a1a:	f85d 4b04 	ldr.w	r4, [sp], #4
     a1e:	4770      	bx	lr

00000a20 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     a20:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     a22:	2300      	movs	r3, #0
     a24:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     a26:	2300      	movs	r3, #0
     a28:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     a2a:	2300      	movs	r3, #0
     a2c:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     a2e:	2300      	movs	r3, #0
     a30:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     a32:	4b44      	ldr	r3, [pc, #272]	; (b44 <init_data_bss+0x124>)
     a34:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     a36:	4b44      	ldr	r3, [pc, #272]	; (b48 <init_data_bss+0x128>)
     a38:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     a3a:	9b05      	ldr	r3, [sp, #20]
     a3c:	681b      	ldr	r3, [r3, #0]
     a3e:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     a40:	9b05      	ldr	r3, [sp, #20]
     a42:	3304      	adds	r3, #4
     a44:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     a46:	9b05      	ldr	r3, [sp, #20]
     a48:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     a4a:	2300      	movs	r3, #0
     a4c:	9309      	str	r3, [sp, #36]	; 0x24
     a4e:	e03d      	b.n	acc <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     a50:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a52:	4613      	mov	r3, r2
     a54:	005b      	lsls	r3, r3, #1
     a56:	4413      	add	r3, r2
     a58:	009b      	lsls	r3, r3, #2
     a5a:	461a      	mov	r2, r3
     a5c:	9b03      	ldr	r3, [sp, #12]
     a5e:	4413      	add	r3, r2
     a60:	685b      	ldr	r3, [r3, #4]
     a62:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     a64:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a66:	4613      	mov	r3, r2
     a68:	005b      	lsls	r3, r3, #1
     a6a:	4413      	add	r3, r2
     a6c:	009b      	lsls	r3, r3, #2
     a6e:	461a      	mov	r2, r3
     a70:	9b03      	ldr	r3, [sp, #12]
     a72:	4413      	add	r3, r2
     a74:	681b      	ldr	r3, [r3, #0]
     a76:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     a78:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a7a:	4613      	mov	r3, r2
     a7c:	005b      	lsls	r3, r3, #1
     a7e:	4413      	add	r3, r2
     a80:	009b      	lsls	r3, r3, #2
     a82:	461a      	mov	r2, r3
     a84:	9b03      	ldr	r3, [sp, #12]
     a86:	4413      	add	r3, r2
     a88:	689b      	ldr	r3, [r3, #8]
     a8a:	4619      	mov	r1, r3
     a8c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a8e:	4613      	mov	r3, r2
     a90:	005b      	lsls	r3, r3, #1
     a92:	4413      	add	r3, r2
     a94:	009b      	lsls	r3, r3, #2
     a96:	461a      	mov	r2, r3
     a98:	9b03      	ldr	r3, [sp, #12]
     a9a:	4413      	add	r3, r2
     a9c:	685b      	ldr	r3, [r3, #4]
     a9e:	1acb      	subs	r3, r1, r3
     aa0:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     aa2:	2300      	movs	r3, #0
     aa4:	9308      	str	r3, [sp, #32]
     aa6:	e00a      	b.n	abe <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     aa8:	9a00      	ldr	r2, [sp, #0]
     aaa:	9b08      	ldr	r3, [sp, #32]
     aac:	441a      	add	r2, r3
     aae:	9901      	ldr	r1, [sp, #4]
     ab0:	9b08      	ldr	r3, [sp, #32]
     ab2:	440b      	add	r3, r1
     ab4:	7812      	ldrb	r2, [r2, #0]
     ab6:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     ab8:	9b08      	ldr	r3, [sp, #32]
     aba:	3301      	adds	r3, #1
     abc:	9308      	str	r3, [sp, #32]
     abe:	9a08      	ldr	r2, [sp, #32]
     ac0:	9b06      	ldr	r3, [sp, #24]
     ac2:	429a      	cmp	r2, r3
     ac4:	d3f0      	bcc.n	aa8 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     ac6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ac8:	3301      	adds	r3, #1
     aca:	9309      	str	r3, [sp, #36]	; 0x24
     acc:	9a09      	ldr	r2, [sp, #36]	; 0x24
     ace:	9b07      	ldr	r3, [sp, #28]
     ad0:	429a      	cmp	r2, r3
     ad2:	d3bd      	bcc.n	a50 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     ad4:	9b04      	ldr	r3, [sp, #16]
     ad6:	681b      	ldr	r3, [r3, #0]
     ad8:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     ada:	9b04      	ldr	r3, [sp, #16]
     adc:	3304      	adds	r3, #4
     ade:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     ae0:	9b04      	ldr	r3, [sp, #16]
     ae2:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     ae4:	2300      	movs	r3, #0
     ae6:	9309      	str	r3, [sp, #36]	; 0x24
     ae8:	e024      	b.n	b34 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     aea:	9b09      	ldr	r3, [sp, #36]	; 0x24
     aec:	00db      	lsls	r3, r3, #3
     aee:	9a02      	ldr	r2, [sp, #8]
     af0:	4413      	add	r3, r2
     af2:	681b      	ldr	r3, [r3, #0]
     af4:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     af6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     af8:	00db      	lsls	r3, r3, #3
     afa:	9a02      	ldr	r2, [sp, #8]
     afc:	4413      	add	r3, r2
     afe:	685b      	ldr	r3, [r3, #4]
     b00:	4619      	mov	r1, r3
     b02:	9b09      	ldr	r3, [sp, #36]	; 0x24
     b04:	00db      	lsls	r3, r3, #3
     b06:	9a02      	ldr	r2, [sp, #8]
     b08:	4413      	add	r3, r2
     b0a:	681b      	ldr	r3, [r3, #0]
     b0c:	1acb      	subs	r3, r1, r3
     b0e:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     b10:	2300      	movs	r3, #0
     b12:	9308      	str	r3, [sp, #32]
     b14:	e007      	b.n	b26 <init_data_bss+0x106>
        {
            ram[j] = 0U;
     b16:	9a01      	ldr	r2, [sp, #4]
     b18:	9b08      	ldr	r3, [sp, #32]
     b1a:	4413      	add	r3, r2
     b1c:	2200      	movs	r2, #0
     b1e:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     b20:	9b08      	ldr	r3, [sp, #32]
     b22:	3301      	adds	r3, #1
     b24:	9308      	str	r3, [sp, #32]
     b26:	9a08      	ldr	r2, [sp, #32]
     b28:	9b06      	ldr	r3, [sp, #24]
     b2a:	429a      	cmp	r2, r3
     b2c:	d3f3      	bcc.n	b16 <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     b2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
     b30:	3301      	adds	r3, #1
     b32:	9309      	str	r3, [sp, #36]	; 0x24
     b34:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b36:	9b07      	ldr	r3, [sp, #28]
     b38:	429a      	cmp	r2, r3
     b3a:	d3d6      	bcc.n	aea <init_data_bss+0xca>
        }
    }
}
     b3c:	bf00      	nop
     b3e:	bf00      	nop
     b40:	b00a      	add	sp, #40	; 0x28
     b42:	4770      	bx	lr
     b44:	0000bce4 	.word	0x0000bce4
     b48:	0000bd00 	.word	0x0000bd00

00000b4c <sys_m4_cache_init>:
{
     b4c:	b084      	sub	sp, #16
     b4e:	4603      	mov	r3, r0
     b50:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     b54:	2300      	movs	r3, #0
     b56:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     b5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
     b5e:	2b00      	cmp	r3, #0
     b60:	d118      	bne.n	b94 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     b62:	4b10      	ldr	r3, [pc, #64]	; (ba4 <sys_m4_cache_init+0x58>)
     b64:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     b68:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     b6a:	4b0e      	ldr	r3, [pc, #56]	; (ba4 <sys_m4_cache_init+0x58>)
     b6c:	681b      	ldr	r3, [r3, #0]
     b6e:	4a0d      	ldr	r2, [pc, #52]	; (ba4 <sys_m4_cache_init+0x58>)
     b70:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     b74:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     b76:	bf00      	nop
     b78:	4b0a      	ldr	r3, [pc, #40]	; (ba4 <sys_m4_cache_init+0x58>)
     b7a:	681b      	ldr	r3, [r3, #0]
     b7c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     b80:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     b84:	d0f8      	beq.n	b78 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     b86:	4b07      	ldr	r3, [pc, #28]	; (ba4 <sys_m4_cache_init+0x58>)
     b88:	681b      	ldr	r3, [r3, #0]
     b8a:	4a06      	ldr	r2, [pc, #24]	; (ba4 <sys_m4_cache_init+0x58>)
     b8c:	f043 0301 	orr.w	r3, r3, #1
     b90:	6013      	str	r3, [r2, #0]
     b92:	e002      	b.n	b9a <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     b94:	2301      	movs	r3, #1
     b96:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     b9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     b9e:	4618      	mov	r0, r3
     ba0:	b004      	add	sp, #16
     ba2:	4770      	bx	lr
     ba4:	e0082000 	.word	0xe0082000

00000ba8 <startup_go_to_user_mode>:
}
     ba8:	bf00      	nop
     baa:	4770      	bx	lr

00000bac <Sys_GetCoreID>:
    return 0U;
     bac:	2300      	movs	r3, #0
}
     bae:	4618      	mov	r0, r3
     bb0:	4770      	bx	lr

00000bb2 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     bb2:	e7fe      	b.n	bb2 <HardFault_Handler>

00000bb4 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     bb4:	e7fe      	b.n	bb4 <MemManage_Handler>

00000bb6 <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     bb6:	e7fe      	b.n	bb6 <BusFault_Handler>

00000bb8 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     bb8:	e7fe      	b.n	bb8 <UsageFault_Handler>

00000bba <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     bba:	e7fe      	b.n	bba <SVC_Handler>

00000bbc <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     bbc:	e7fe      	b.n	bbc <DebugMon_Handler>

00000bbe <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     bbe:	e7fe      	b.n	bbe <PendSV_Handler>

00000bc0 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     bc0:	e7fe      	b.n	bc0 <SysTick_Handler>

00000bc2 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     bc2:	e7fe      	b.n	bc2 <undefined_handler>

00000bc4 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
     bc4:	2300      	movs	r3, #0
}
     bc6:	4618      	mov	r0, r3
     bc8:	4770      	bx	lr

00000bca <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
     bca:	b082      	sub	sp, #8
     bcc:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
     bce:	2301      	movs	r3, #1
}
     bd0:	4618      	mov	r0, r3
     bd2:	b002      	add	sp, #8
     bd4:	4770      	bx	lr

00000bd6 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
     bd6:	b082      	sub	sp, #8
     bd8:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
     bda:	bf00      	nop
     bdc:	b002      	add	sp, #8
     bde:	4770      	bx	lr

00000be0 <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
     be0:	b082      	sub	sp, #8
     be2:	9001      	str	r0, [sp, #4]
    return Micros;
     be4:	9b01      	ldr	r3, [sp, #4]
}
     be6:	4618      	mov	r0, r3
     be8:	b002      	add	sp, #8
     bea:	4770      	bx	lr

00000bec <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
     bec:	b500      	push	{lr}
     bee:	b083      	sub	sp, #12
     bf0:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
     bf2:	f000 f86d 	bl	cd0 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
     bf6:	bf00      	nop
     bf8:	b003      	add	sp, #12
     bfa:	f85d fb04 	ldr.w	pc, [sp], #4

00000bfe <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
     bfe:	b500      	push	{lr}
     c00:	b085      	sub	sp, #20
     c02:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
     c04:	2300      	movs	r3, #0
     c06:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     c08:	9b01      	ldr	r3, [sp, #4]
     c0a:	2b00      	cmp	r3, #0
     c0c:	d003      	beq.n	c16 <OsIf_GetCounter+0x18>
     c0e:	9b01      	ldr	r3, [sp, #4]
     c10:	2b01      	cmp	r3, #1
     c12:	d004      	beq.n	c1e <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     c14:	e007      	b.n	c26 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
     c16:	f7ff ffd5 	bl	bc4 <OsIf_Timer_Dummy_GetCounter>
     c1a:	9003      	str	r0, [sp, #12]
            break;
     c1c:	e003      	b.n	c26 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
     c1e:	f000 f873 	bl	d08 <OsIf_Timer_System_GetCounter>
     c22:	9003      	str	r0, [sp, #12]
            break;
     c24:	bf00      	nop
    }

    return Value;
     c26:	9b03      	ldr	r3, [sp, #12]
}
     c28:	4618      	mov	r0, r3
     c2a:	b005      	add	sp, #20
     c2c:	f85d fb04 	ldr.w	pc, [sp], #4

00000c30 <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
     c30:	b500      	push	{lr}
     c32:	b085      	sub	sp, #20
     c34:	9001      	str	r0, [sp, #4]
     c36:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     c38:	2300      	movs	r3, #0
     c3a:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     c3c:	9b00      	ldr	r3, [sp, #0]
     c3e:	2b00      	cmp	r3, #0
     c40:	d003      	beq.n	c4a <OsIf_GetElapsed+0x1a>
     c42:	9b00      	ldr	r3, [sp, #0]
     c44:	2b01      	cmp	r3, #1
     c46:	d005      	beq.n	c54 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     c48:	e009      	b.n	c5e <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
     c4a:	9801      	ldr	r0, [sp, #4]
     c4c:	f7ff ffbd 	bl	bca <OsIf_Timer_Dummy_GetElapsed>
     c50:	9003      	str	r0, [sp, #12]
            break;
     c52:	e004      	b.n	c5e <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
     c54:	9801      	ldr	r0, [sp, #4]
     c56:	f000 f865 	bl	d24 <OsIf_Timer_System_GetElapsed>
     c5a:	9003      	str	r0, [sp, #12]
            break;
     c5c:	bf00      	nop
    }

    return Value;
     c5e:	9b03      	ldr	r3, [sp, #12]
}
     c60:	4618      	mov	r0, r3
     c62:	b005      	add	sp, #20
     c64:	f85d fb04 	ldr.w	pc, [sp], #4

00000c68 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
     c68:	b500      	push	{lr}
     c6a:	b083      	sub	sp, #12
     c6c:	9001      	str	r0, [sp, #4]
     c6e:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
     c70:	9b00      	ldr	r3, [sp, #0]
     c72:	2b00      	cmp	r3, #0
     c74:	d003      	beq.n	c7e <OsIf_SetTimerFrequency+0x16>
     c76:	9b00      	ldr	r3, [sp, #0]
     c78:	2b01      	cmp	r3, #1
     c7a:	d004      	beq.n	c86 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     c7c:	e007      	b.n	c8e <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
     c7e:	9801      	ldr	r0, [sp, #4]
     c80:	f7ff ffa9 	bl	bd6 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
     c84:	e003      	b.n	c8e <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
     c86:	9801      	ldr	r0, [sp, #4]
     c88:	f000 f85c 	bl	d44 <OsIf_Timer_System_SetTimerFrequency>
            break;
     c8c:	bf00      	nop
    }
}
     c8e:	bf00      	nop
     c90:	b003      	add	sp, #12
     c92:	f85d fb04 	ldr.w	pc, [sp], #4

00000c96 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
     c96:	b500      	push	{lr}
     c98:	b085      	sub	sp, #20
     c9a:	9001      	str	r0, [sp, #4]
     c9c:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     c9e:	2300      	movs	r3, #0
     ca0:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     ca2:	9b00      	ldr	r3, [sp, #0]
     ca4:	2b00      	cmp	r3, #0
     ca6:	d003      	beq.n	cb0 <OsIf_MicrosToTicks+0x1a>
     ca8:	9b00      	ldr	r3, [sp, #0]
     caa:	2b01      	cmp	r3, #1
     cac:	d005      	beq.n	cba <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     cae:	e009      	b.n	cc4 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
     cb0:	9801      	ldr	r0, [sp, #4]
     cb2:	f7ff ff95 	bl	be0 <OsIf_Timer_Dummy_MicrosToTicks>
     cb6:	9003      	str	r0, [sp, #12]
            break;
     cb8:	e004      	b.n	cc4 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
     cba:	9801      	ldr	r0, [sp, #4]
     cbc:	f000 f850 	bl	d60 <OsIf_Timer_System_MicrosToTicks>
     cc0:	9003      	str	r0, [sp, #12]
            break;
     cc2:	bf00      	nop
    }

    return Value;
     cc4:	9b03      	ldr	r3, [sp, #12]
}
     cc6:	4618      	mov	r0, r3
     cc8:	b005      	add	sp, #20
     cca:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000cd0 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
     cd0:	b500      	push	{lr}
     cd2:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
     cd4:	2300      	movs	r3, #0
     cd6:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
     cd8:	4a09      	ldr	r2, [pc, #36]	; (d00 <OsIf_Timer_System_Init+0x30>)
     cda:	9b01      	ldr	r3, [sp, #4]
     cdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     ce0:	685a      	ldr	r2, [r3, #4]
     ce2:	4908      	ldr	r1, [pc, #32]	; (d04 <OsIf_Timer_System_Init+0x34>)
     ce4:	9b01      	ldr	r3, [sp, #4]
     ce6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
     cea:	4a06      	ldr	r2, [pc, #24]	; (d04 <OsIf_Timer_System_Init+0x34>)
     cec:	9b01      	ldr	r3, [sp, #4]
     cee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     cf2:	4618      	mov	r0, r3
     cf4:	f000 f868 	bl	dc8 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
     cf8:	bf00      	nop
     cfa:	b003      	add	sp, #12
     cfc:	f85d fb04 	ldr.w	pc, [sp], #4
     d00:	0000bb60 	.word	0x0000bb60
     d04:	1fff8b60 	.word	0x1fff8b60

00000d08 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
     d08:	b500      	push	{lr}
     d0a:	b083      	sub	sp, #12
    uint32 Counter = 0U;
     d0c:	2300      	movs	r3, #0
     d0e:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     d10:	2300      	movs	r3, #0
     d12:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
     d14:	f000 f86c 	bl	df0 <OsIf_Timer_System_Internal_GetCounter>
     d18:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
     d1a:	9b01      	ldr	r3, [sp, #4]
}
     d1c:	4618      	mov	r0, r3
     d1e:	b003      	add	sp, #12
     d20:	f85d fb04 	ldr.w	pc, [sp], #4

00000d24 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
     d24:	b500      	push	{lr}
     d26:	b085      	sub	sp, #20
     d28:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
     d2a:	2300      	movs	r3, #0
     d2c:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
     d2e:	2300      	movs	r3, #0
     d30:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
     d32:	9801      	ldr	r0, [sp, #4]
     d34:	f000 f864 	bl	e00 <OsIf_Timer_System_Internal_GetElapsed>
     d38:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
     d3a:	9b03      	ldr	r3, [sp, #12]
}
     d3c:	4618      	mov	r0, r3
     d3e:	b005      	add	sp, #20
     d40:	f85d fb04 	ldr.w	pc, [sp], #4

00000d44 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
     d44:	b084      	sub	sp, #16
     d46:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     d48:	2300      	movs	r3, #0
     d4a:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
     d4c:	4903      	ldr	r1, [pc, #12]	; (d5c <OsIf_Timer_System_SetTimerFrequency+0x18>)
     d4e:	9b03      	ldr	r3, [sp, #12]
     d50:	9a01      	ldr	r2, [sp, #4]
     d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
     d56:	bf00      	nop
     d58:	b004      	add	sp, #16
     d5a:	4770      	bx	lr
     d5c:	1fff8b60 	.word	0x1fff8b60

00000d60 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
     d60:	b5f0      	push	{r4, r5, r6, r7, lr}
     d62:	b087      	sub	sp, #28
     d64:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
     d66:	2100      	movs	r1, #0
     d68:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
     d6a:	2100      	movs	r1, #0
     d6c:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
     d6e:	9901      	ldr	r1, [sp, #4]
     d70:	2000      	movs	r0, #0
     d72:	460e      	mov	r6, r1
     d74:	4607      	mov	r7, r0
     d76:	4812      	ldr	r0, [pc, #72]	; (dc0 <OsIf_Timer_System_MicrosToTicks+0x60>)
     d78:	9904      	ldr	r1, [sp, #16]
     d7a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
     d7e:	2000      	movs	r0, #0
     d80:	460c      	mov	r4, r1
     d82:	4605      	mov	r5, r0
     d84:	fb04 f007 	mul.w	r0, r4, r7
     d88:	fb06 f105 	mul.w	r1, r6, r5
     d8c:	4401      	add	r1, r0
     d8e:	fba6 2304 	umull	r2, r3, r6, r4
     d92:	4419      	add	r1, r3
     d94:	460b      	mov	r3, r1
     d96:	e9cd 2302 	strd	r2, r3, [sp, #8]
     d9a:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
     d9e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
     da2:	4a08      	ldr	r2, [pc, #32]	; (dc4 <OsIf_Timer_System_MicrosToTicks+0x64>)
     da4:	f04f 0300 	mov.w	r3, #0
     da8:	f7ff fbfc 	bl	5a4 <__aeabi_uldivmod>
     dac:	4602      	mov	r2, r0
     dae:	460b      	mov	r3, r1
     db0:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
     db4:	9b02      	ldr	r3, [sp, #8]
     db6:	9305      	str	r3, [sp, #20]
    }

    return ticks;
     db8:	9b05      	ldr	r3, [sp, #20]
}
     dba:	4618      	mov	r0, r3
     dbc:	b007      	add	sp, #28
     dbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
     dc0:	1fff8b60 	.word	0x1fff8b60
     dc4:	000f4240 	.word	0x000f4240

00000dc8 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
     dc8:	b082      	sub	sp, #8
     dca:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
     dcc:	4b07      	ldr	r3, [pc, #28]	; (dec <OsIf_Timer_System_Internal_Init+0x24>)
     dce:	2200      	movs	r2, #0
     dd0:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
     dd2:	4b06      	ldr	r3, [pc, #24]	; (dec <OsIf_Timer_System_Internal_Init+0x24>)
     dd4:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
     dd8:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
     dda:	4b04      	ldr	r3, [pc, #16]	; (dec <OsIf_Timer_System_Internal_Init+0x24>)
     ddc:	2200      	movs	r2, #0
     dde:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
     de0:	4b02      	ldr	r3, [pc, #8]	; (dec <OsIf_Timer_System_Internal_Init+0x24>)
     de2:	2205      	movs	r2, #5
     de4:	601a      	str	r2, [r3, #0]
}
     de6:	bf00      	nop
     de8:	b002      	add	sp, #8
     dea:	4770      	bx	lr
     dec:	e000e010 	.word	0xe000e010

00000df0 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
     df0:	4b02      	ldr	r3, [pc, #8]	; (dfc <OsIf_Timer_System_Internal_GetCounter+0xc>)
     df2:	689b      	ldr	r3, [r3, #8]
     df4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
     df8:	4618      	mov	r0, r3
     dfa:	4770      	bx	lr
     dfc:	e000e010 	.word	0xe000e010

00000e00 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
     e00:	b084      	sub	sp, #16
     e02:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
     e04:	4b10      	ldr	r3, [pc, #64]	; (e48 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
     e06:	689b      	ldr	r3, [r3, #8]
     e08:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     e0c:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
     e0e:	2300      	movs	r3, #0
     e10:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
     e12:	9b01      	ldr	r3, [sp, #4]
     e14:	681b      	ldr	r3, [r3, #0]
     e16:	9a02      	ldr	r2, [sp, #8]
     e18:	429a      	cmp	r2, r3
     e1a:	d909      	bls.n	e30 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
     e1c:	9b01      	ldr	r3, [sp, #4]
     e1e:	681a      	ldr	r2, [r3, #0]
     e20:	9b02      	ldr	r3, [sp, #8]
     e22:	1ad3      	subs	r3, r2, r3
     e24:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
     e28:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
     e2c:	9303      	str	r3, [sp, #12]
     e2e:	e004      	b.n	e3a <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
     e30:	9b01      	ldr	r3, [sp, #4]
     e32:	681a      	ldr	r2, [r3, #0]
     e34:	9b02      	ldr	r3, [sp, #8]
     e36:	1ad3      	subs	r3, r2, r3
     e38:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
     e3a:	9b01      	ldr	r3, [sp, #4]
     e3c:	9a02      	ldr	r2, [sp, #8]
     e3e:	601a      	str	r2, [r3, #0]

    return dif;
     e40:	9b03      	ldr	r3, [sp, #12]
}
     e42:	4618      	mov	r0, r3
     e44:	b004      	add	sp, #16
     e46:	4770      	bx	lr
     e48:	e000e010 	.word	0xe000e010

00000e4c <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
     e4c:	b082      	sub	sp, #8
     e4e:	9001      	str	r0, [sp, #4]
     e50:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
     e52:	bf00      	nop
     e54:	b002      	add	sp, #8
     e56:	4770      	bx	lr

00000e58 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
     e58:	b500      	push	{lr}
     e5a:	b085      	sub	sp, #20
     e5c:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
     e5e:	4b24      	ldr	r3, [pc, #144]	; (ef0 <Clock_Ip_UpdateDriverContext+0x98>)
     e60:	2201      	movs	r2, #1
     e62:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
     e64:	4b23      	ldr	r3, [pc, #140]	; (ef4 <Clock_Ip_UpdateDriverContext+0x9c>)
     e66:	681b      	ldr	r3, [r3, #0]
     e68:	2102      	movs	r1, #2
     e6a:	4618      	mov	r0, r3
     e6c:	f003 fc32 	bl	46d4 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
     e70:	2300      	movs	r3, #0
     e72:	f88d 300f 	strb.w	r3, [sp, #15]
     e76:	e015      	b.n	ea4 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
     e78:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e7c:	9a01      	ldr	r2, [sp, #4]
     e7e:	334a      	adds	r3, #74	; 0x4a
     e80:	00db      	lsls	r3, r3, #3
     e82:	4413      	add	r3, r2
     e84:	6858      	ldr	r0, [r3, #4]
     e86:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e8a:	9a01      	ldr	r2, [sp, #4]
     e8c:	334a      	adds	r3, #74	; 0x4a
     e8e:	00db      	lsls	r3, r3, #3
     e90:	4413      	add	r3, r2
     e92:	689b      	ldr	r3, [r3, #8]
     e94:	4619      	mov	r1, r3
     e96:	f001 fadc 	bl	2452 <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
     e9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e9e:	3301      	adds	r3, #1
     ea0:	f88d 300f 	strb.w	r3, [sp, #15]
     ea4:	9b01      	ldr	r3, [sp, #4]
     ea6:	7bdb      	ldrb	r3, [r3, #15]
     ea8:	f89d 200f 	ldrb.w	r2, [sp, #15]
     eac:	429a      	cmp	r2, r3
     eae:	d3e3      	bcc.n	e78 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
     eb0:	f000 f824 	bl	efc <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
     eb4:	2301      	movs	r3, #1
     eb6:	f88d 300f 	strb.w	r3, [sp, #15]
     eba:	e00e      	b.n	eda <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
     ebc:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ec0:	9b01      	ldr	r3, [sp, #4]
     ec2:	327e      	adds	r2, #126	; 0x7e
     ec4:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
     ec8:	490b      	ldr	r1, [pc, #44]	; (ef8 <Clock_Ip_UpdateDriverContext+0xa0>)
     eca:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ece:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
     ed0:	f89d 300f 	ldrb.w	r3, [sp, #15]
     ed4:	3301      	adds	r3, #1
     ed6:	f88d 300f 	strb.w	r3, [sp, #15]
     eda:	9b01      	ldr	r3, [sp, #4]
     edc:	7cdb      	ldrb	r3, [r3, #19]
     ede:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ee2:	429a      	cmp	r2, r3
     ee4:	d3ea      	bcc.n	ebc <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
     ee6:	bf00      	nop
     ee8:	bf00      	nop
     eea:	b005      	add	sp, #20
     eec:	f85d fb04 	ldr.w	pc, [sp], #4
     ef0:	1fff8b10 	.word	0x1fff8b10
     ef4:	1fff8b64 	.word	0x1fff8b64
     ef8:	1fff8b70 	.word	0x1fff8b70

00000efc <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
     efc:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
     efe:	4b23      	ldr	r3, [pc, #140]	; (f8c <Clock_Ip_CallEmptyCallbacks+0x90>)
     f00:	781b      	ldrb	r3, [r3, #0]
     f02:	f083 0301 	eor.w	r3, r3, #1
     f06:	b2db      	uxtb	r3, r3
     f08:	2b00      	cmp	r3, #0
     f0a:	d03d      	beq.n	f88 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
     f0c:	4b1f      	ldr	r3, [pc, #124]	; (f8c <Clock_Ip_CallEmptyCallbacks+0x90>)
     f0e:	2201      	movs	r2, #1
     f10:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
     f12:	4b1f      	ldr	r3, [pc, #124]	; (f90 <Clock_Ip_CallEmptyCallbacks+0x94>)
     f14:	685b      	ldr	r3, [r3, #4]
     f16:	2100      	movs	r1, #0
     f18:	2000      	movs	r0, #0
     f1a:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
     f1c:	4b1c      	ldr	r3, [pc, #112]	; (f90 <Clock_Ip_CallEmptyCallbacks+0x94>)
     f1e:	689b      	ldr	r3, [r3, #8]
     f20:	2057      	movs	r0, #87	; 0x57
     f22:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f24:	4b1b      	ldr	r3, [pc, #108]	; (f94 <Clock_Ip_CallEmptyCallbacks+0x98>)
     f26:	681b      	ldr	r3, [r3, #0]
     f28:	2000      	movs	r0, #0
     f2a:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
     f2c:	4b1a      	ldr	r3, [pc, #104]	; (f98 <Clock_Ip_CallEmptyCallbacks+0x9c>)
     f2e:	681b      	ldr	r3, [r3, #0]
     f30:	2000      	movs	r0, #0
     f32:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
     f34:	4b19      	ldr	r3, [pc, #100]	; (f9c <Clock_Ip_CallEmptyCallbacks+0xa0>)
     f36:	681b      	ldr	r3, [r3, #0]
     f38:	2000      	movs	r0, #0
     f3a:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f3c:	4b18      	ldr	r3, [pc, #96]	; (fa0 <Clock_Ip_CallEmptyCallbacks+0xa4>)
     f3e:	685b      	ldr	r3, [r3, #4]
     f40:	2000      	movs	r0, #0
     f42:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
     f44:	4b16      	ldr	r3, [pc, #88]	; (fa0 <Clock_Ip_CallEmptyCallbacks+0xa4>)
     f46:	689b      	ldr	r3, [r3, #8]
     f48:	2057      	movs	r0, #87	; 0x57
     f4a:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f4c:	4b15      	ldr	r3, [pc, #84]	; (fa4 <Clock_Ip_CallEmptyCallbacks+0xa8>)
     f4e:	681b      	ldr	r3, [r3, #0]
     f50:	2000      	movs	r0, #0
     f52:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
     f54:	4b13      	ldr	r3, [pc, #76]	; (fa4 <Clock_Ip_CallEmptyCallbacks+0xa8>)
     f56:	685b      	ldr	r3, [r3, #4]
     f58:	2100      	movs	r1, #0
     f5a:	2057      	movs	r0, #87	; 0x57
     f5c:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f5e:	4b12      	ldr	r3, [pc, #72]	; (fa8 <Clock_Ip_CallEmptyCallbacks+0xac>)
     f60:	681b      	ldr	r3, [r3, #0]
     f62:	2000      	movs	r0, #0
     f64:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f66:	4b11      	ldr	r3, [pc, #68]	; (fac <Clock_Ip_CallEmptyCallbacks+0xb0>)
     f68:	685b      	ldr	r3, [r3, #4]
     f6a:	2000      	movs	r0, #0
     f6c:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
     f6e:	4b0f      	ldr	r3, [pc, #60]	; (fac <Clock_Ip_CallEmptyCallbacks+0xb0>)
     f70:	689b      	ldr	r3, [r3, #8]
     f72:	2057      	movs	r0, #87	; 0x57
     f74:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     f76:	4b0e      	ldr	r3, [pc, #56]	; (fb0 <Clock_Ip_CallEmptyCallbacks+0xb4>)
     f78:	685b      	ldr	r3, [r3, #4]
     f7a:	2000      	movs	r0, #0
     f7c:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
     f7e:	4b0d      	ldr	r3, [pc, #52]	; (fb4 <Clock_Ip_CallEmptyCallbacks+0xb8>)
     f80:	681b      	ldr	r3, [r3, #0]
     f82:	2100      	movs	r1, #0
     f84:	2000      	movs	r0, #0
     f86:	4798      	blx	r3
    }
}
     f88:	bf00      	nop
     f8a:	bd08      	pop	{r3, pc}
     f8c:	1fff8b68 	.word	0x1fff8b68
     f90:	0000b5bc 	.word	0x0000b5bc
     f94:	0000b4d0 	.word	0x0000b4d0
     f98:	0000b50c 	.word	0x0000b50c
     f9c:	0000b514 	.word	0x0000b514
     fa0:	0000b53c 	.word	0x0000b53c
     fa4:	0000b548 	.word	0x0000b548
     fa8:	0000b580 	.word	0x0000b580
     fac:	0000b5cc 	.word	0x0000b5cc
     fb0:	0000b5f8 	.word	0x0000b5f8
     fb4:	0000b5f4 	.word	0x0000b5f4

00000fb8 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
     fb8:	b500      	push	{lr}
     fba:	b085      	sub	sp, #20
     fbc:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
     fbe:	9b01      	ldr	r3, [sp, #4]
     fc0:	7adb      	ldrb	r3, [r3, #11]
     fc2:	9303      	str	r3, [sp, #12]
     fc4:	e01f      	b.n	1006 <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
     fc6:	9b03      	ldr	r3, [sp, #12]
     fc8:	1e5a      	subs	r2, r3, #1
     fca:	9b01      	ldr	r3, [sp, #4]
     fcc:	320d      	adds	r2, #13
     fce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
     fd2:	495a      	ldr	r1, [pc, #360]	; (113c <Clock_Ip_ResetClockConfiguration+0x184>)
     fd4:	4613      	mov	r3, r2
     fd6:	00db      	lsls	r3, r3, #3
     fd8:	4413      	add	r3, r2
     fda:	440b      	add	r3, r1
     fdc:	3301      	adds	r3, #1
     fde:	781b      	ldrb	r3, [r3, #0]
     fe0:	461a      	mov	r2, r3
     fe2:	4b57      	ldr	r3, [pc, #348]	; (1140 <Clock_Ip_ResetClockConfiguration+0x188>)
     fe4:	5c9b      	ldrb	r3, [r3, r2]
     fe6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
     fe8:	4a56      	ldr	r2, [pc, #344]	; (1144 <Clock_Ip_ResetClockConfiguration+0x18c>)
     fea:	9b02      	ldr	r3, [sp, #8]
     fec:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
     ff0:	9a03      	ldr	r2, [sp, #12]
     ff2:	3a01      	subs	r2, #1
     ff4:	320d      	adds	r2, #13
     ff6:	00d2      	lsls	r2, r2, #3
     ff8:	9901      	ldr	r1, [sp, #4]
     ffa:	440a      	add	r2, r1
     ffc:	4610      	mov	r0, r2
     ffe:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    1000:	9b03      	ldr	r3, [sp, #12]
    1002:	3b01      	subs	r3, #1
    1004:	9303      	str	r3, [sp, #12]
    1006:	9b03      	ldr	r3, [sp, #12]
    1008:	2b00      	cmp	r3, #0
    100a:	d1dc      	bne.n	fc6 <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    100c:	9b01      	ldr	r3, [sp, #4]
    100e:	7b9b      	ldrb	r3, [r3, #14]
    1010:	9303      	str	r3, [sp, #12]
    1012:	e026      	b.n	1062 <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    1014:	9b03      	ldr	r3, [sp, #12]
    1016:	3b01      	subs	r3, #1
    1018:	9a01      	ldr	r2, [sp, #4]
    101a:	3324      	adds	r3, #36	; 0x24
    101c:	011b      	lsls	r3, r3, #4
    101e:	4413      	add	r3, r2
    1020:	3304      	adds	r3, #4
    1022:	681a      	ldr	r2, [r3, #0]
    1024:	4945      	ldr	r1, [pc, #276]	; (113c <Clock_Ip_ResetClockConfiguration+0x184>)
    1026:	4613      	mov	r3, r2
    1028:	00db      	lsls	r3, r3, #3
    102a:	4413      	add	r3, r2
    102c:	440b      	add	r3, r1
    102e:	3301      	adds	r3, #1
    1030:	781b      	ldrb	r3, [r3, #0]
    1032:	461a      	mov	r2, r3
    1034:	4b44      	ldr	r3, [pc, #272]	; (1148 <Clock_Ip_ResetClockConfiguration+0x190>)
    1036:	5c9b      	ldrb	r3, [r3, r2]
    1038:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    103a:	4944      	ldr	r1, [pc, #272]	; (114c <Clock_Ip_ResetClockConfiguration+0x194>)
    103c:	9a02      	ldr	r2, [sp, #8]
    103e:	4613      	mov	r3, r2
    1040:	005b      	lsls	r3, r3, #1
    1042:	4413      	add	r3, r2
    1044:	009b      	lsls	r3, r3, #2
    1046:	440b      	add	r3, r1
    1048:	681b      	ldr	r3, [r3, #0]
    104a:	9a03      	ldr	r2, [sp, #12]
    104c:	3a01      	subs	r2, #1
    104e:	3224      	adds	r2, #36	; 0x24
    1050:	0112      	lsls	r2, r2, #4
    1052:	9901      	ldr	r1, [sp, #4]
    1054:	440a      	add	r2, r1
    1056:	3204      	adds	r2, #4
    1058:	4610      	mov	r0, r2
    105a:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    105c:	9b03      	ldr	r3, [sp, #12]
    105e:	3b01      	subs	r3, #1
    1060:	9303      	str	r3, [sp, #12]
    1062:	9b03      	ldr	r3, [sp, #12]
    1064:	2b00      	cmp	r3, #0
    1066:	d1d5      	bne.n	1014 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    1068:	9b01      	ldr	r3, [sp, #4]
    106a:	7a9b      	ldrb	r3, [r3, #10]
    106c:	9303      	str	r3, [sp, #12]
    106e:	e02a      	b.n	10c6 <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    1070:	9b03      	ldr	r3, [sp, #12]
    1072:	1e5a      	subs	r2, r3, #1
    1074:	9901      	ldr	r1, [sp, #4]
    1076:	4613      	mov	r3, r2
    1078:	009b      	lsls	r3, r3, #2
    107a:	4413      	add	r3, r2
    107c:	00db      	lsls	r3, r3, #3
    107e:	440b      	add	r3, r1
    1080:	3340      	adds	r3, #64	; 0x40
    1082:	681a      	ldr	r2, [r3, #0]
    1084:	492d      	ldr	r1, [pc, #180]	; (113c <Clock_Ip_ResetClockConfiguration+0x184>)
    1086:	4613      	mov	r3, r2
    1088:	00db      	lsls	r3, r3, #3
    108a:	4413      	add	r3, r2
    108c:	440b      	add	r3, r1
    108e:	3301      	adds	r3, #1
    1090:	781b      	ldrb	r3, [r3, #0]
    1092:	461a      	mov	r2, r3
    1094:	4b2e      	ldr	r3, [pc, #184]	; (1150 <Clock_Ip_ResetClockConfiguration+0x198>)
    1096:	5c9b      	ldrb	r3, [r3, r2]
    1098:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    109a:	492e      	ldr	r1, [pc, #184]	; (1154 <Clock_Ip_ResetClockConfiguration+0x19c>)
    109c:	9a02      	ldr	r2, [sp, #8]
    109e:	4613      	mov	r3, r2
    10a0:	009b      	lsls	r3, r3, #2
    10a2:	4413      	add	r3, r2
    10a4:	009b      	lsls	r3, r3, #2
    10a6:	440b      	add	r3, r1
    10a8:	6819      	ldr	r1, [r3, #0]
    10aa:	9b03      	ldr	r3, [sp, #12]
    10ac:	1e5a      	subs	r2, r3, #1
    10ae:	4613      	mov	r3, r2
    10b0:	009b      	lsls	r3, r3, #2
    10b2:	4413      	add	r3, r2
    10b4:	00db      	lsls	r3, r3, #3
    10b6:	3340      	adds	r3, #64	; 0x40
    10b8:	9a01      	ldr	r2, [sp, #4]
    10ba:	4413      	add	r3, r2
    10bc:	4618      	mov	r0, r3
    10be:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    10c0:	9b03      	ldr	r3, [sp, #12]
    10c2:	3b01      	subs	r3, #1
    10c4:	9303      	str	r3, [sp, #12]
    10c6:	9b03      	ldr	r3, [sp, #12]
    10c8:	2b00      	cmp	r3, #0
    10ca:	d1d1      	bne.n	1070 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    10cc:	9b01      	ldr	r3, [sp, #4]
    10ce:	7a5b      	ldrb	r3, [r3, #9]
    10d0:	9303      	str	r3, [sp, #12]
    10d2:	e02b      	b.n	112c <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    10d4:	9b03      	ldr	r3, [sp, #12]
    10d6:	1e5a      	subs	r2, r3, #1
    10d8:	9901      	ldr	r1, [sp, #4]
    10da:	4613      	mov	r3, r2
    10dc:	009b      	lsls	r3, r3, #2
    10de:	4413      	add	r3, r2
    10e0:	009b      	lsls	r3, r3, #2
    10e2:	440b      	add	r3, r1
    10e4:	332c      	adds	r3, #44	; 0x2c
    10e6:	681a      	ldr	r2, [r3, #0]
    10e8:	4914      	ldr	r1, [pc, #80]	; (113c <Clock_Ip_ResetClockConfiguration+0x184>)
    10ea:	4613      	mov	r3, r2
    10ec:	00db      	lsls	r3, r3, #3
    10ee:	4413      	add	r3, r2
    10f0:	440b      	add	r3, r1
    10f2:	3301      	adds	r3, #1
    10f4:	781b      	ldrb	r3, [r3, #0]
    10f6:	461a      	mov	r2, r3
    10f8:	4b17      	ldr	r3, [pc, #92]	; (1158 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    10fa:	5c9b      	ldrb	r3, [r3, r2]
    10fc:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    10fe:	4917      	ldr	r1, [pc, #92]	; (115c <Clock_Ip_ResetClockConfiguration+0x1a4>)
    1100:	9a02      	ldr	r2, [sp, #8]
    1102:	4613      	mov	r3, r2
    1104:	009b      	lsls	r3, r3, #2
    1106:	4413      	add	r3, r2
    1108:	009b      	lsls	r3, r3, #2
    110a:	440b      	add	r3, r1
    110c:	6819      	ldr	r1, [r3, #0]
    110e:	9b03      	ldr	r3, [sp, #12]
    1110:	1e5a      	subs	r2, r3, #1
    1112:	4613      	mov	r3, r2
    1114:	009b      	lsls	r3, r3, #2
    1116:	4413      	add	r3, r2
    1118:	009b      	lsls	r3, r3, #2
    111a:	3328      	adds	r3, #40	; 0x28
    111c:	9a01      	ldr	r2, [sp, #4]
    111e:	4413      	add	r3, r2
    1120:	3304      	adds	r3, #4
    1122:	4618      	mov	r0, r3
    1124:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    1126:	9b03      	ldr	r3, [sp, #12]
    1128:	3b01      	subs	r3, #1
    112a:	9303      	str	r3, [sp, #12]
    112c:	9b03      	ldr	r3, [sp, #12]
    112e:	2b00      	cmp	r3, #0
    1130:	d1d0      	bne.n	10d4 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    1132:	bf00      	nop
    1134:	bf00      	nop
    1136:	b005      	add	sp, #20
    1138:	f85d fb04 	ldr.w	pc, [sp], #4
    113c:	0000afc0 	.word	0x0000afc0
    1140:	0000af90 	.word	0x0000af90
    1144:	0000b5f8 	.word	0x0000b5f8
    1148:	0000af70 	.word	0x0000af70
    114c:	0000b53c 	.word	0x0000b53c
    1150:	0000af80 	.word	0x0000af80
    1154:	0000b5cc 	.word	0x0000b5cc
    1158:	0000af40 	.word	0x0000af40
    115c:	0000b514 	.word	0x0000b514

00001160 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    1160:	b500      	push	{lr}
    1162:	b085      	sub	sp, #20
    1164:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    1166:	2301      	movs	r3, #1
    1168:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    116a:	9801      	ldr	r0, [sp, #4]
    116c:	f000 f818 	bl	11a0 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    1170:	4b0a      	ldr	r3, [pc, #40]	; (119c <Clock_Ip_Init+0x3c>)
    1172:	781b      	ldrb	r3, [r3, #0]
    1174:	2b00      	cmp	r3, #0
    1176:	d00a      	beq.n	118e <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    1178:	f000 fb74 	bl	1864 <Clock_Ip_GetPllStatus>
    117c:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    117e:	9b02      	ldr	r3, [sp, #8]
    1180:	2b00      	cmp	r3, #0
    1182:	d106      	bne.n	1192 <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    1184:	f000 fbf2 	bl	196c <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    1188:	2300      	movs	r3, #0
    118a:	9303      	str	r3, [sp, #12]
    118c:	e001      	b.n	1192 <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    118e:	2300      	movs	r3, #0
    1190:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    1192:	9b03      	ldr	r3, [sp, #12]
}
    1194:	4618      	mov	r0, r3
    1196:	b005      	add	sp, #20
    1198:	f85d fb04 	ldr.w	pc, [sp], #4
    119c:	1fff8b6c 	.word	0x1fff8b6c

000011a0 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    11a0:	b510      	push	{r4, lr}
    11a2:	b084      	sub	sp, #16
    11a4:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    11a6:	4a9f      	ldr	r2, [pc, #636]	; (1424 <Clock_Ip_InitClock+0x284>)
    11a8:	9b01      	ldr	r3, [sp, #4]
    11aa:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    11ac:	2101      	movs	r1, #1
    11ae:	9801      	ldr	r0, [sp, #4]
    11b0:	f003 fa90 	bl	46d4 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    11b4:	4b9b      	ldr	r3, [pc, #620]	; (1424 <Clock_Ip_InitClock+0x284>)
    11b6:	681b      	ldr	r3, [r3, #0]
    11b8:	2b00      	cmp	r3, #0
    11ba:	d030      	beq.n	121e <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    11bc:	2300      	movs	r3, #0
    11be:	9303      	str	r3, [sp, #12]
    11c0:	e027      	b.n	1212 <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    11c2:	9901      	ldr	r1, [sp, #4]
    11c4:	9a03      	ldr	r2, [sp, #12]
    11c6:	4613      	mov	r3, r2
    11c8:	009b      	lsls	r3, r3, #2
    11ca:	4413      	add	r3, r2
    11cc:	009b      	lsls	r3, r3, #2
    11ce:	440b      	add	r3, r1
    11d0:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    11d4:	681a      	ldr	r2, [r3, #0]
    11d6:	4994      	ldr	r1, [pc, #592]	; (1428 <Clock_Ip_InitClock+0x288>)
    11d8:	4613      	mov	r3, r2
    11da:	00db      	lsls	r3, r3, #3
    11dc:	4413      	add	r3, r2
    11de:	440b      	add	r3, r1
    11e0:	3301      	adds	r3, #1
    11e2:	781b      	ldrb	r3, [r3, #0]
    11e4:	461a      	mov	r2, r3
    11e6:	4b91      	ldr	r3, [pc, #580]	; (142c <Clock_Ip_InitClock+0x28c>)
    11e8:	5c9b      	ldrb	r3, [r3, r2]
    11ea:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    11ec:	4a90      	ldr	r2, [pc, #576]	; (1430 <Clock_Ip_InitClock+0x290>)
    11ee:	9b02      	ldr	r3, [sp, #8]
    11f0:	011b      	lsls	r3, r3, #4
    11f2:	4413      	add	r3, r2
    11f4:	6819      	ldr	r1, [r3, #0]
    11f6:	9a03      	ldr	r2, [sp, #12]
    11f8:	4613      	mov	r3, r2
    11fa:	009b      	lsls	r3, r3, #2
    11fc:	4413      	add	r3, r2
    11fe:	009b      	lsls	r3, r3, #2
    1200:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1204:	9a01      	ldr	r2, [sp, #4]
    1206:	4413      	add	r3, r2
    1208:	4618      	mov	r0, r3
    120a:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    120c:	9b03      	ldr	r3, [sp, #12]
    120e:	3301      	adds	r3, #1
    1210:	9303      	str	r3, [sp, #12]
    1212:	9b01      	ldr	r3, [sp, #4]
    1214:	7c9b      	ldrb	r3, [r3, #18]
    1216:	461a      	mov	r2, r3
    1218:	9b03      	ldr	r3, [sp, #12]
    121a:	4293      	cmp	r3, r2
    121c:	d3d1      	bcc.n	11c2 <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    121e:	9801      	ldr	r0, [sp, #4]
    1220:	f7ff feca 	bl	fb8 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    1224:	2300      	movs	r3, #0
    1226:	9303      	str	r3, [sp, #12]
    1228:	e029      	b.n	127e <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    122a:	9901      	ldr	r1, [sp, #4]
    122c:	9a03      	ldr	r2, [sp, #12]
    122e:	4613      	mov	r3, r2
    1230:	005b      	lsls	r3, r3, #1
    1232:	4413      	add	r3, r2
    1234:	009b      	lsls	r3, r3, #2
    1236:	440b      	add	r3, r1
    1238:	3314      	adds	r3, #20
    123a:	681a      	ldr	r2, [r3, #0]
    123c:	497a      	ldr	r1, [pc, #488]	; (1428 <Clock_Ip_InitClock+0x288>)
    123e:	4613      	mov	r3, r2
    1240:	00db      	lsls	r3, r3, #3
    1242:	4413      	add	r3, r2
    1244:	440b      	add	r3, r1
    1246:	3301      	adds	r3, #1
    1248:	781b      	ldrb	r3, [r3, #0]
    124a:	461a      	mov	r2, r3
    124c:	4b79      	ldr	r3, [pc, #484]	; (1434 <Clock_Ip_InitClock+0x294>)
    124e:	5c9b      	ldrb	r3, [r3, r2]
    1250:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    1252:	4979      	ldr	r1, [pc, #484]	; (1438 <Clock_Ip_InitClock+0x298>)
    1254:	9a02      	ldr	r2, [sp, #8]
    1256:	4613      	mov	r3, r2
    1258:	005b      	lsls	r3, r3, #1
    125a:	4413      	add	r3, r2
    125c:	009b      	lsls	r3, r3, #2
    125e:	440b      	add	r3, r1
    1260:	6819      	ldr	r1, [r3, #0]
    1262:	9a03      	ldr	r2, [sp, #12]
    1264:	4613      	mov	r3, r2
    1266:	005b      	lsls	r3, r3, #1
    1268:	4413      	add	r3, r2
    126a:	009b      	lsls	r3, r3, #2
    126c:	3310      	adds	r3, #16
    126e:	9a01      	ldr	r2, [sp, #4]
    1270:	4413      	add	r3, r2
    1272:	3304      	adds	r3, #4
    1274:	4618      	mov	r0, r3
    1276:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    1278:	9b03      	ldr	r3, [sp, #12]
    127a:	3301      	adds	r3, #1
    127c:	9303      	str	r3, [sp, #12]
    127e:	9b01      	ldr	r3, [sp, #4]
    1280:	7a1b      	ldrb	r3, [r3, #8]
    1282:	461a      	mov	r2, r3
    1284:	9b03      	ldr	r3, [sp, #12]
    1286:	4293      	cmp	r3, r2
    1288:	d3cf      	bcc.n	122a <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    128a:	2300      	movs	r3, #0
    128c:	9303      	str	r3, [sp, #12]
    128e:	e02a      	b.n	12e6 <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    1290:	9901      	ldr	r1, [sp, #4]
    1292:	9a03      	ldr	r2, [sp, #12]
    1294:	4613      	mov	r3, r2
    1296:	009b      	lsls	r3, r3, #2
    1298:	4413      	add	r3, r2
    129a:	009b      	lsls	r3, r3, #2
    129c:	440b      	add	r3, r1
    129e:	332c      	adds	r3, #44	; 0x2c
    12a0:	681a      	ldr	r2, [r3, #0]
    12a2:	4961      	ldr	r1, [pc, #388]	; (1428 <Clock_Ip_InitClock+0x288>)
    12a4:	4613      	mov	r3, r2
    12a6:	00db      	lsls	r3, r3, #3
    12a8:	4413      	add	r3, r2
    12aa:	440b      	add	r3, r1
    12ac:	3301      	adds	r3, #1
    12ae:	781b      	ldrb	r3, [r3, #0]
    12b0:	461a      	mov	r2, r3
    12b2:	4b62      	ldr	r3, [pc, #392]	; (143c <Clock_Ip_InitClock+0x29c>)
    12b4:	5c9b      	ldrb	r3, [r3, r2]
    12b6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    12b8:	4961      	ldr	r1, [pc, #388]	; (1440 <Clock_Ip_InitClock+0x2a0>)
    12ba:	9a02      	ldr	r2, [sp, #8]
    12bc:	4613      	mov	r3, r2
    12be:	009b      	lsls	r3, r3, #2
    12c0:	4413      	add	r3, r2
    12c2:	009b      	lsls	r3, r3, #2
    12c4:	440b      	add	r3, r1
    12c6:	3304      	adds	r3, #4
    12c8:	6819      	ldr	r1, [r3, #0]
    12ca:	9a03      	ldr	r2, [sp, #12]
    12cc:	4613      	mov	r3, r2
    12ce:	009b      	lsls	r3, r3, #2
    12d0:	4413      	add	r3, r2
    12d2:	009b      	lsls	r3, r3, #2
    12d4:	3328      	adds	r3, #40	; 0x28
    12d6:	9a01      	ldr	r2, [sp, #4]
    12d8:	4413      	add	r3, r2
    12da:	3304      	adds	r3, #4
    12dc:	4618      	mov	r0, r3
    12de:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    12e0:	9b03      	ldr	r3, [sp, #12]
    12e2:	3301      	adds	r3, #1
    12e4:	9303      	str	r3, [sp, #12]
    12e6:	9b01      	ldr	r3, [sp, #4]
    12e8:	7a5b      	ldrb	r3, [r3, #9]
    12ea:	461a      	mov	r2, r3
    12ec:	9b03      	ldr	r3, [sp, #12]
    12ee:	4293      	cmp	r3, r2
    12f0:	d3ce      	bcc.n	1290 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    12f2:	9801      	ldr	r0, [sp, #4]
    12f4:	f7ff fdb0 	bl	e58 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    12f8:	2300      	movs	r3, #0
    12fa:	9303      	str	r3, [sp, #12]
    12fc:	e028      	b.n	1350 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    12fe:	9901      	ldr	r1, [sp, #4]
    1300:	9a03      	ldr	r2, [sp, #12]
    1302:	4613      	mov	r3, r2
    1304:	009b      	lsls	r3, r3, #2
    1306:	4413      	add	r3, r2
    1308:	009b      	lsls	r3, r3, #2
    130a:	440b      	add	r3, r1
    130c:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    1310:	681a      	ldr	r2, [r3, #0]
    1312:	4945      	ldr	r1, [pc, #276]	; (1428 <Clock_Ip_InitClock+0x288>)
    1314:	4613      	mov	r3, r2
    1316:	00db      	lsls	r3, r3, #3
    1318:	4413      	add	r3, r2
    131a:	440b      	add	r3, r1
    131c:	3301      	adds	r3, #1
    131e:	781b      	ldrb	r3, [r3, #0]
    1320:	461a      	mov	r2, r3
    1322:	4b48      	ldr	r3, [pc, #288]	; (1444 <Clock_Ip_InitClock+0x2a4>)
    1324:	5c9b      	ldrb	r3, [r3, r2]
    1326:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    1328:	4a47      	ldr	r2, [pc, #284]	; (1448 <Clock_Ip_InitClock+0x2a8>)
    132a:	9b02      	ldr	r3, [sp, #8]
    132c:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    1330:	9a03      	ldr	r2, [sp, #12]
    1332:	4613      	mov	r3, r2
    1334:	009b      	lsls	r3, r3, #2
    1336:	4413      	add	r3, r2
    1338:	009b      	lsls	r3, r3, #2
    133a:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    133e:	9a01      	ldr	r2, [sp, #4]
    1340:	4413      	add	r3, r2
    1342:	3304      	adds	r3, #4
    1344:	9903      	ldr	r1, [sp, #12]
    1346:	4618      	mov	r0, r3
    1348:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    134a:	9b03      	ldr	r3, [sp, #12]
    134c:	3301      	adds	r3, #1
    134e:	9303      	str	r3, [sp, #12]
    1350:	9b01      	ldr	r3, [sp, #4]
    1352:	7c5b      	ldrb	r3, [r3, #17]
    1354:	461a      	mov	r2, r3
    1356:	9b03      	ldr	r3, [sp, #12]
    1358:	4293      	cmp	r3, r2
    135a:	d3d0      	bcc.n	12fe <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    135c:	2300      	movs	r3, #0
    135e:	9303      	str	r3, [sp, #12]
    1360:	e026      	b.n	13b0 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    1362:	9901      	ldr	r1, [sp, #4]
    1364:	9a03      	ldr	r2, [sp, #12]
    1366:	4613      	mov	r3, r2
    1368:	005b      	lsls	r3, r3, #1
    136a:	4413      	add	r3, r2
    136c:	009b      	lsls	r3, r3, #2
    136e:	440b      	add	r3, r1
    1370:	f503 730e 	add.w	r3, r3, #568	; 0x238
    1374:	681a      	ldr	r2, [r3, #0]
    1376:	492c      	ldr	r1, [pc, #176]	; (1428 <Clock_Ip_InitClock+0x288>)
    1378:	4613      	mov	r3, r2
    137a:	00db      	lsls	r3, r3, #3
    137c:	4413      	add	r3, r2
    137e:	440b      	add	r3, r1
    1380:	3301      	adds	r3, #1
    1382:	781b      	ldrb	r3, [r3, #0]
    1384:	461a      	mov	r2, r3
    1386:	4b31      	ldr	r3, [pc, #196]	; (144c <Clock_Ip_InitClock+0x2ac>)
    1388:	5c9b      	ldrb	r3, [r3, r2]
    138a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    138c:	4a30      	ldr	r2, [pc, #192]	; (1450 <Clock_Ip_InitClock+0x2b0>)
    138e:	9b02      	ldr	r3, [sp, #8]
    1390:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    1394:	9a03      	ldr	r2, [sp, #12]
    1396:	4613      	mov	r3, r2
    1398:	005b      	lsls	r3, r3, #1
    139a:	4413      	add	r3, r2
    139c:	009b      	lsls	r3, r3, #2
    139e:	f503 730e 	add.w	r3, r3, #568	; 0x238
    13a2:	9a01      	ldr	r2, [sp, #4]
    13a4:	4413      	add	r3, r2
    13a6:	4618      	mov	r0, r3
    13a8:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    13aa:	9b03      	ldr	r3, [sp, #12]
    13ac:	3301      	adds	r3, #1
    13ae:	9303      	str	r3, [sp, #12]
    13b0:	9b01      	ldr	r3, [sp, #4]
    13b2:	7b5b      	ldrb	r3, [r3, #13]
    13b4:	461a      	mov	r2, r3
    13b6:	9b03      	ldr	r3, [sp, #12]
    13b8:	4293      	cmp	r3, r2
    13ba:	d3d2      	bcc.n	1362 <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    13bc:	2300      	movs	r3, #0
    13be:	9303      	str	r3, [sp, #12]
    13c0:	e026      	b.n	1410 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    13c2:	9901      	ldr	r1, [sp, #4]
    13c4:	9a03      	ldr	r2, [sp, #12]
    13c6:	4613      	mov	r3, r2
    13c8:	005b      	lsls	r3, r3, #1
    13ca:	4413      	add	r3, r2
    13cc:	009b      	lsls	r3, r3, #2
    13ce:	440b      	add	r3, r1
    13d0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    13d4:	681a      	ldr	r2, [r3, #0]
    13d6:	4914      	ldr	r1, [pc, #80]	; (1428 <Clock_Ip_InitClock+0x288>)
    13d8:	4613      	mov	r3, r2
    13da:	00db      	lsls	r3, r3, #3
    13dc:	4413      	add	r3, r2
    13de:	440b      	add	r3, r1
    13e0:	3301      	adds	r3, #1
    13e2:	781b      	ldrb	r3, [r3, #0]
    13e4:	461a      	mov	r2, r3
    13e6:	4b1b      	ldr	r3, [pc, #108]	; (1454 <Clock_Ip_InitClock+0x2b4>)
    13e8:	5c9b      	ldrb	r3, [r3, r2]
    13ea:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    13ec:	4a1a      	ldr	r2, [pc, #104]	; (1458 <Clock_Ip_InitClock+0x2b8>)
    13ee:	9b02      	ldr	r3, [sp, #8]
    13f0:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    13f4:	9a03      	ldr	r2, [sp, #12]
    13f6:	4613      	mov	r3, r2
    13f8:	005b      	lsls	r3, r3, #1
    13fa:	4413      	add	r3, r2
    13fc:	009b      	lsls	r3, r3, #2
    13fe:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1402:	9a01      	ldr	r2, [sp, #4]
    1404:	4413      	add	r3, r2
    1406:	4618      	mov	r0, r3
    1408:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    140a:	9b03      	ldr	r3, [sp, #12]
    140c:	3301      	adds	r3, #1
    140e:	9303      	str	r3, [sp, #12]
    1410:	9b01      	ldr	r3, [sp, #4]
    1412:	7b1b      	ldrb	r3, [r3, #12]
    1414:	461a      	mov	r2, r3
    1416:	9b03      	ldr	r3, [sp, #12]
    1418:	4293      	cmp	r3, r2
    141a:	d3d2      	bcc.n	13c2 <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    141c:	2300      	movs	r3, #0
    141e:	9303      	str	r3, [sp, #12]
    1420:	e044      	b.n	14ac <Clock_Ip_InitClock+0x30c>
    1422:	bf00      	nop
    1424:	1fff8b64 	.word	0x1fff8b64
    1428:	0000afc0 	.word	0x0000afc0
    142c:	0000afb0 	.word	0x0000afb0
    1430:	0000b5bc 	.word	0x0000b5bc
    1434:	0000af50 	.word	0x0000af50
    1438:	0000b580 	.word	0x0000b580
    143c:	0000af40 	.word	0x0000af40
    1440:	0000b514 	.word	0x0000b514
    1444:	0000afa0 	.word	0x0000afa0
    1448:	0000b5f4 	.word	0x0000b5f4
    144c:	0000af30 	.word	0x0000af30
    1450:	0000b50c 	.word	0x0000b50c
    1454:	0000af20 	.word	0x0000af20
    1458:	0000b4d0 	.word	0x0000b4d0
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    145c:	9901      	ldr	r1, [sp, #4]
    145e:	9a03      	ldr	r2, [sp, #12]
    1460:	4613      	mov	r3, r2
    1462:	005b      	lsls	r3, r3, #1
    1464:	4413      	add	r3, r2
    1466:	009b      	lsls	r3, r3, #2
    1468:	440b      	add	r3, r1
    146a:	f503 730e 	add.w	r3, r3, #568	; 0x238
    146e:	681a      	ldr	r2, [r3, #0]
    1470:	49ac      	ldr	r1, [pc, #688]	; (1724 <Clock_Ip_InitClock+0x584>)
    1472:	4613      	mov	r3, r2
    1474:	00db      	lsls	r3, r3, #3
    1476:	4413      	add	r3, r2
    1478:	440b      	add	r3, r1
    147a:	3301      	adds	r3, #1
    147c:	781b      	ldrb	r3, [r3, #0]
    147e:	461a      	mov	r2, r3
    1480:	4ba9      	ldr	r3, [pc, #676]	; (1728 <Clock_Ip_InitClock+0x588>)
    1482:	5c9b      	ldrb	r3, [r3, r2]
    1484:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    1486:	4aa9      	ldr	r2, [pc, #676]	; (172c <Clock_Ip_InitClock+0x58c>)
    1488:	9b02      	ldr	r3, [sp, #8]
    148a:	00db      	lsls	r3, r3, #3
    148c:	4413      	add	r3, r2
    148e:	6859      	ldr	r1, [r3, #4]
    1490:	9a03      	ldr	r2, [sp, #12]
    1492:	4613      	mov	r3, r2
    1494:	005b      	lsls	r3, r3, #1
    1496:	4413      	add	r3, r2
    1498:	009b      	lsls	r3, r3, #2
    149a:	f503 730e 	add.w	r3, r3, #568	; 0x238
    149e:	9a01      	ldr	r2, [sp, #4]
    14a0:	4413      	add	r3, r2
    14a2:	4618      	mov	r0, r3
    14a4:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    14a6:	9b03      	ldr	r3, [sp, #12]
    14a8:	3301      	adds	r3, #1
    14aa:	9303      	str	r3, [sp, #12]
    14ac:	9b01      	ldr	r3, [sp, #4]
    14ae:	7b5b      	ldrb	r3, [r3, #13]
    14b0:	461a      	mov	r2, r3
    14b2:	9b03      	ldr	r3, [sp, #12]
    14b4:	4293      	cmp	r3, r2
    14b6:	d3d1      	bcc.n	145c <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    14b8:	2300      	movs	r3, #0
    14ba:	9303      	str	r3, [sp, #12]
    14bc:	e029      	b.n	1512 <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    14be:	9901      	ldr	r1, [sp, #4]
    14c0:	9a03      	ldr	r2, [sp, #12]
    14c2:	4613      	mov	r3, r2
    14c4:	009b      	lsls	r3, r3, #2
    14c6:	4413      	add	r3, r2
    14c8:	00db      	lsls	r3, r3, #3
    14ca:	440b      	add	r3, r1
    14cc:	3340      	adds	r3, #64	; 0x40
    14ce:	681a      	ldr	r2, [r3, #0]
    14d0:	4994      	ldr	r1, [pc, #592]	; (1724 <Clock_Ip_InitClock+0x584>)
    14d2:	4613      	mov	r3, r2
    14d4:	00db      	lsls	r3, r3, #3
    14d6:	4413      	add	r3, r2
    14d8:	440b      	add	r3, r1
    14da:	3301      	adds	r3, #1
    14dc:	781b      	ldrb	r3, [r3, #0]
    14de:	461a      	mov	r2, r3
    14e0:	4b93      	ldr	r3, [pc, #588]	; (1730 <Clock_Ip_InitClock+0x590>)
    14e2:	5c9b      	ldrb	r3, [r3, r2]
    14e4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    14e6:	4993      	ldr	r1, [pc, #588]	; (1734 <Clock_Ip_InitClock+0x594>)
    14e8:	9a02      	ldr	r2, [sp, #8]
    14ea:	4613      	mov	r3, r2
    14ec:	009b      	lsls	r3, r3, #2
    14ee:	4413      	add	r3, r2
    14f0:	009b      	lsls	r3, r3, #2
    14f2:	440b      	add	r3, r1
    14f4:	3304      	adds	r3, #4
    14f6:	6819      	ldr	r1, [r3, #0]
    14f8:	9a03      	ldr	r2, [sp, #12]
    14fa:	4613      	mov	r3, r2
    14fc:	009b      	lsls	r3, r3, #2
    14fe:	4413      	add	r3, r2
    1500:	00db      	lsls	r3, r3, #3
    1502:	3340      	adds	r3, #64	; 0x40
    1504:	9a01      	ldr	r2, [sp, #4]
    1506:	4413      	add	r3, r2
    1508:	4618      	mov	r0, r3
    150a:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    150c:	9b03      	ldr	r3, [sp, #12]
    150e:	3301      	adds	r3, #1
    1510:	9303      	str	r3, [sp, #12]
    1512:	9b01      	ldr	r3, [sp, #4]
    1514:	7a9b      	ldrb	r3, [r3, #10]
    1516:	461a      	mov	r2, r3
    1518:	9b03      	ldr	r3, [sp, #12]
    151a:	4293      	cmp	r3, r2
    151c:	d3cf      	bcc.n	14be <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    151e:	2300      	movs	r3, #0
    1520:	9303      	str	r3, [sp, #12]
    1522:	e029      	b.n	1578 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1524:	9901      	ldr	r1, [sp, #4]
    1526:	9a03      	ldr	r2, [sp, #12]
    1528:	4613      	mov	r3, r2
    152a:	009b      	lsls	r3, r3, #2
    152c:	4413      	add	r3, r2
    152e:	009b      	lsls	r3, r3, #2
    1530:	440b      	add	r3, r1
    1532:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1536:	681a      	ldr	r2, [r3, #0]
    1538:	497a      	ldr	r1, [pc, #488]	; (1724 <Clock_Ip_InitClock+0x584>)
    153a:	4613      	mov	r3, r2
    153c:	00db      	lsls	r3, r3, #3
    153e:	4413      	add	r3, r2
    1540:	440b      	add	r3, r1
    1542:	3301      	adds	r3, #1
    1544:	781b      	ldrb	r3, [r3, #0]
    1546:	461a      	mov	r2, r3
    1548:	4b7b      	ldr	r3, [pc, #492]	; (1738 <Clock_Ip_InitClock+0x598>)
    154a:	5c9b      	ldrb	r3, [r3, r2]
    154c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    154e:	4a7b      	ldr	r2, [pc, #492]	; (173c <Clock_Ip_InitClock+0x59c>)
    1550:	9b02      	ldr	r3, [sp, #8]
    1552:	011b      	lsls	r3, r3, #4
    1554:	4413      	add	r3, r2
    1556:	3304      	adds	r3, #4
    1558:	681c      	ldr	r4, [r3, #0]
    155a:	9a03      	ldr	r2, [sp, #12]
    155c:	4613      	mov	r3, r2
    155e:	009b      	lsls	r3, r3, #2
    1560:	4413      	add	r3, r2
    1562:	009b      	lsls	r3, r3, #2
    1564:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1568:	9a01      	ldr	r2, [sp, #4]
    156a:	4413      	add	r3, r2
    156c:	9903      	ldr	r1, [sp, #12]
    156e:	4618      	mov	r0, r3
    1570:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    1572:	9b03      	ldr	r3, [sp, #12]
    1574:	3301      	adds	r3, #1
    1576:	9303      	str	r3, [sp, #12]
    1578:	9b01      	ldr	r3, [sp, #4]
    157a:	7c9b      	ldrb	r3, [r3, #18]
    157c:	461a      	mov	r2, r3
    157e:	9b03      	ldr	r3, [sp, #12]
    1580:	4293      	cmp	r3, r2
    1582:	d3cf      	bcc.n	1524 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    1584:	2300      	movs	r3, #0
    1586:	9303      	str	r3, [sp, #12]
    1588:	e02a      	b.n	15e0 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    158a:	9901      	ldr	r1, [sp, #4]
    158c:	9a03      	ldr	r2, [sp, #12]
    158e:	4613      	mov	r3, r2
    1590:	009b      	lsls	r3, r3, #2
    1592:	4413      	add	r3, r2
    1594:	009b      	lsls	r3, r3, #2
    1596:	440b      	add	r3, r1
    1598:	332c      	adds	r3, #44	; 0x2c
    159a:	681a      	ldr	r2, [r3, #0]
    159c:	4961      	ldr	r1, [pc, #388]	; (1724 <Clock_Ip_InitClock+0x584>)
    159e:	4613      	mov	r3, r2
    15a0:	00db      	lsls	r3, r3, #3
    15a2:	4413      	add	r3, r2
    15a4:	440b      	add	r3, r1
    15a6:	3301      	adds	r3, #1
    15a8:	781b      	ldrb	r3, [r3, #0]
    15aa:	461a      	mov	r2, r3
    15ac:	4b64      	ldr	r3, [pc, #400]	; (1740 <Clock_Ip_InitClock+0x5a0>)
    15ae:	5c9b      	ldrb	r3, [r3, r2]
    15b0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    15b2:	4964      	ldr	r1, [pc, #400]	; (1744 <Clock_Ip_InitClock+0x5a4>)
    15b4:	9a02      	ldr	r2, [sp, #8]
    15b6:	4613      	mov	r3, r2
    15b8:	009b      	lsls	r3, r3, #2
    15ba:	4413      	add	r3, r2
    15bc:	009b      	lsls	r3, r3, #2
    15be:	440b      	add	r3, r1
    15c0:	3308      	adds	r3, #8
    15c2:	6819      	ldr	r1, [r3, #0]
    15c4:	9a03      	ldr	r2, [sp, #12]
    15c6:	4613      	mov	r3, r2
    15c8:	009b      	lsls	r3, r3, #2
    15ca:	4413      	add	r3, r2
    15cc:	009b      	lsls	r3, r3, #2
    15ce:	3328      	adds	r3, #40	; 0x28
    15d0:	9a01      	ldr	r2, [sp, #4]
    15d2:	4413      	add	r3, r2
    15d4:	3304      	adds	r3, #4
    15d6:	4618      	mov	r0, r3
    15d8:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    15da:	9b03      	ldr	r3, [sp, #12]
    15dc:	3301      	adds	r3, #1
    15de:	9303      	str	r3, [sp, #12]
    15e0:	9b01      	ldr	r3, [sp, #4]
    15e2:	7a5b      	ldrb	r3, [r3, #9]
    15e4:	461a      	mov	r2, r3
    15e6:	9b03      	ldr	r3, [sp, #12]
    15e8:	4293      	cmp	r3, r2
    15ea:	d3ce      	bcc.n	158a <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    15ec:	2300      	movs	r3, #0
    15ee:	9303      	str	r3, [sp, #12]
    15f0:	e029      	b.n	1646 <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    15f2:	9901      	ldr	r1, [sp, #4]
    15f4:	9a03      	ldr	r2, [sp, #12]
    15f6:	4613      	mov	r3, r2
    15f8:	009b      	lsls	r3, r3, #2
    15fa:	4413      	add	r3, r2
    15fc:	00db      	lsls	r3, r3, #3
    15fe:	440b      	add	r3, r1
    1600:	3340      	adds	r3, #64	; 0x40
    1602:	681a      	ldr	r2, [r3, #0]
    1604:	4947      	ldr	r1, [pc, #284]	; (1724 <Clock_Ip_InitClock+0x584>)
    1606:	4613      	mov	r3, r2
    1608:	00db      	lsls	r3, r3, #3
    160a:	4413      	add	r3, r2
    160c:	440b      	add	r3, r1
    160e:	3301      	adds	r3, #1
    1610:	781b      	ldrb	r3, [r3, #0]
    1612:	461a      	mov	r2, r3
    1614:	4b46      	ldr	r3, [pc, #280]	; (1730 <Clock_Ip_InitClock+0x590>)
    1616:	5c9b      	ldrb	r3, [r3, r2]
    1618:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    161a:	4946      	ldr	r1, [pc, #280]	; (1734 <Clock_Ip_InitClock+0x594>)
    161c:	9a02      	ldr	r2, [sp, #8]
    161e:	4613      	mov	r3, r2
    1620:	009b      	lsls	r3, r3, #2
    1622:	4413      	add	r3, r2
    1624:	009b      	lsls	r3, r3, #2
    1626:	440b      	add	r3, r1
    1628:	330c      	adds	r3, #12
    162a:	6819      	ldr	r1, [r3, #0]
    162c:	9a03      	ldr	r2, [sp, #12]
    162e:	4613      	mov	r3, r2
    1630:	009b      	lsls	r3, r3, #2
    1632:	4413      	add	r3, r2
    1634:	00db      	lsls	r3, r3, #3
    1636:	3340      	adds	r3, #64	; 0x40
    1638:	9a01      	ldr	r2, [sp, #4]
    163a:	4413      	add	r3, r2
    163c:	4618      	mov	r0, r3
    163e:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1640:	9b03      	ldr	r3, [sp, #12]
    1642:	3301      	adds	r3, #1
    1644:	9303      	str	r3, [sp, #12]
    1646:	9b01      	ldr	r3, [sp, #4]
    1648:	7a9b      	ldrb	r3, [r3, #10]
    164a:	461a      	mov	r2, r3
    164c:	9b03      	ldr	r3, [sp, #12]
    164e:	4293      	cmp	r3, r2
    1650:	d3cf      	bcc.n	15f2 <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1652:	2300      	movs	r3, #0
    1654:	9303      	str	r3, [sp, #12]
    1656:	e025      	b.n	16a4 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    1658:	9a01      	ldr	r2, [sp, #4]
    165a:	9b03      	ldr	r3, [sp, #12]
    165c:	3324      	adds	r3, #36	; 0x24
    165e:	011b      	lsls	r3, r3, #4
    1660:	4413      	add	r3, r2
    1662:	3304      	adds	r3, #4
    1664:	681a      	ldr	r2, [r3, #0]
    1666:	492f      	ldr	r1, [pc, #188]	; (1724 <Clock_Ip_InitClock+0x584>)
    1668:	4613      	mov	r3, r2
    166a:	00db      	lsls	r3, r3, #3
    166c:	4413      	add	r3, r2
    166e:	440b      	add	r3, r1
    1670:	3301      	adds	r3, #1
    1672:	781b      	ldrb	r3, [r3, #0]
    1674:	461a      	mov	r2, r3
    1676:	4b34      	ldr	r3, [pc, #208]	; (1748 <Clock_Ip_InitClock+0x5a8>)
    1678:	5c9b      	ldrb	r3, [r3, r2]
    167a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    167c:	4933      	ldr	r1, [pc, #204]	; (174c <Clock_Ip_InitClock+0x5ac>)
    167e:	9a02      	ldr	r2, [sp, #8]
    1680:	4613      	mov	r3, r2
    1682:	005b      	lsls	r3, r3, #1
    1684:	4413      	add	r3, r2
    1686:	009b      	lsls	r3, r3, #2
    1688:	440b      	add	r3, r1
    168a:	3304      	adds	r3, #4
    168c:	681b      	ldr	r3, [r3, #0]
    168e:	9a03      	ldr	r2, [sp, #12]
    1690:	3224      	adds	r2, #36	; 0x24
    1692:	0112      	lsls	r2, r2, #4
    1694:	9901      	ldr	r1, [sp, #4]
    1696:	440a      	add	r2, r1
    1698:	3204      	adds	r2, #4
    169a:	4610      	mov	r0, r2
    169c:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    169e:	9b03      	ldr	r3, [sp, #12]
    16a0:	3301      	adds	r3, #1
    16a2:	9303      	str	r3, [sp, #12]
    16a4:	9b01      	ldr	r3, [sp, #4]
    16a6:	7b9b      	ldrb	r3, [r3, #14]
    16a8:	461a      	mov	r2, r3
    16aa:	9b03      	ldr	r3, [sp, #12]
    16ac:	4293      	cmp	r3, r2
    16ae:	d3d3      	bcc.n	1658 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    16b0:	4b27      	ldr	r3, [pc, #156]	; (1750 <Clock_Ip_InitClock+0x5b0>)
    16b2:	2200      	movs	r2, #0
    16b4:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    16b6:	4b26      	ldr	r3, [pc, #152]	; (1750 <Clock_Ip_InitClock+0x5b0>)
    16b8:	2200      	movs	r2, #0
    16ba:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    16bc:	4b24      	ldr	r3, [pc, #144]	; (1750 <Clock_Ip_InitClock+0x5b0>)
    16be:	2201      	movs	r2, #1
    16c0:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    16c2:	4b23      	ldr	r3, [pc, #140]	; (1750 <Clock_Ip_InitClock+0x5b0>)
    16c4:	2200      	movs	r2, #0
    16c6:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    16c8:	f000 fa9c 	bl	1c04 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    16cc:	2300      	movs	r3, #0
    16ce:	9303      	str	r3, [sp, #12]
    16d0:	e04c      	b.n	176c <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    16d2:	9a01      	ldr	r2, [sp, #4]
    16d4:	9b03      	ldr	r3, [sp, #12]
    16d6:	330d      	adds	r3, #13
    16d8:	00db      	lsls	r3, r3, #3
    16da:	4413      	add	r3, r2
    16dc:	685b      	ldr	r3, [r3, #4]
    16de:	4a1d      	ldr	r2, [pc, #116]	; (1754 <Clock_Ip_InitClock+0x5b4>)
    16e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    16e4:	2b03      	cmp	r3, #3
    16e6:	d03b      	beq.n	1760 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    16e8:	9b01      	ldr	r3, [sp, #4]
    16ea:	9a03      	ldr	r2, [sp, #12]
    16ec:	320d      	adds	r2, #13
    16ee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    16f2:	490c      	ldr	r1, [pc, #48]	; (1724 <Clock_Ip_InitClock+0x584>)
    16f4:	4613      	mov	r3, r2
    16f6:	00db      	lsls	r3, r3, #3
    16f8:	4413      	add	r3, r2
    16fa:	440b      	add	r3, r1
    16fc:	3301      	adds	r3, #1
    16fe:	781b      	ldrb	r3, [r3, #0]
    1700:	461a      	mov	r2, r3
    1702:	4b15      	ldr	r3, [pc, #84]	; (1758 <Clock_Ip_InitClock+0x5b8>)
    1704:	5c9b      	ldrb	r3, [r3, r2]
    1706:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    1708:	4a14      	ldr	r2, [pc, #80]	; (175c <Clock_Ip_InitClock+0x5bc>)
    170a:	9b02      	ldr	r3, [sp, #8]
    170c:	00db      	lsls	r3, r3, #3
    170e:	4413      	add	r3, r2
    1710:	685b      	ldr	r3, [r3, #4]
    1712:	9a03      	ldr	r2, [sp, #12]
    1714:	320d      	adds	r2, #13
    1716:	00d2      	lsls	r2, r2, #3
    1718:	9901      	ldr	r1, [sp, #4]
    171a:	440a      	add	r2, r1
    171c:	4610      	mov	r0, r2
    171e:	4798      	blx	r3
    1720:	e021      	b.n	1766 <Clock_Ip_InitClock+0x5c6>
    1722:	bf00      	nop
    1724:	0000afc0 	.word	0x0000afc0
    1728:	0000af30 	.word	0x0000af30
    172c:	0000b50c 	.word	0x0000b50c
    1730:	0000af80 	.word	0x0000af80
    1734:	0000b5cc 	.word	0x0000b5cc
    1738:	0000afb0 	.word	0x0000afb0
    173c:	0000b5bc 	.word	0x0000b5bc
    1740:	0000af40 	.word	0x0000af40
    1744:	0000b514 	.word	0x0000b514
    1748:	0000af70 	.word	0x0000af70
    174c:	0000b53c 	.word	0x0000b53c
    1750:	1fff8b6c 	.word	0x1fff8b6c
    1754:	0000b40c 	.word	0x0000b40c
    1758:	0000af90 	.word	0x0000af90
    175c:	0000b5f8 	.word	0x0000b5f8
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    1760:	4b3a      	ldr	r3, [pc, #232]	; (184c <Clock_Ip_InitClock+0x6ac>)
    1762:	2201      	movs	r2, #1
    1764:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    1766:	9b03      	ldr	r3, [sp, #12]
    1768:	3301      	adds	r3, #1
    176a:	9303      	str	r3, [sp, #12]
    176c:	9b01      	ldr	r3, [sp, #4]
    176e:	7adb      	ldrb	r3, [r3, #11]
    1770:	461a      	mov	r2, r3
    1772:	9b03      	ldr	r3, [sp, #12]
    1774:	4293      	cmp	r3, r2
    1776:	d3ac      	bcc.n	16d2 <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    1778:	4b34      	ldr	r3, [pc, #208]	; (184c <Clock_Ip_InitClock+0x6ac>)
    177a:	781b      	ldrb	r3, [r3, #0]
    177c:	f083 0301 	eor.w	r3, r3, #1
    1780:	b2db      	uxtb	r3, r3
    1782:	2b00      	cmp	r3, #0
    1784:	d05e      	beq.n	1844 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1786:	2300      	movs	r3, #0
    1788:	9303      	str	r3, [sp, #12]
    178a:	e01f      	b.n	17cc <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    178c:	9a01      	ldr	r2, [sp, #4]
    178e:	9b03      	ldr	r3, [sp, #12]
    1790:	334e      	adds	r3, #78	; 0x4e
    1792:	00db      	lsls	r3, r3, #3
    1794:	4413      	add	r3, r2
    1796:	685a      	ldr	r2, [r3, #4]
    1798:	492d      	ldr	r1, [pc, #180]	; (1850 <Clock_Ip_InitClock+0x6b0>)
    179a:	4613      	mov	r3, r2
    179c:	00db      	lsls	r3, r3, #3
    179e:	4413      	add	r3, r2
    17a0:	440b      	add	r3, r1
    17a2:	3301      	adds	r3, #1
    17a4:	781b      	ldrb	r3, [r3, #0]
    17a6:	461a      	mov	r2, r3
    17a8:	4b2a      	ldr	r3, [pc, #168]	; (1854 <Clock_Ip_InitClock+0x6b4>)
    17aa:	5c9b      	ldrb	r3, [r3, r2]
    17ac:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    17ae:	4a2a      	ldr	r2, [pc, #168]	; (1858 <Clock_Ip_InitClock+0x6b8>)
    17b0:	9b02      	ldr	r3, [sp, #8]
    17b2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    17b6:	9a03      	ldr	r2, [sp, #12]
    17b8:	324e      	adds	r2, #78	; 0x4e
    17ba:	00d2      	lsls	r2, r2, #3
    17bc:	9901      	ldr	r1, [sp, #4]
    17be:	440a      	add	r2, r1
    17c0:	3204      	adds	r2, #4
    17c2:	4610      	mov	r0, r2
    17c4:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    17c6:	9b03      	ldr	r3, [sp, #12]
    17c8:	3301      	adds	r3, #1
    17ca:	9303      	str	r3, [sp, #12]
    17cc:	9b01      	ldr	r3, [sp, #4]
    17ce:	7c1b      	ldrb	r3, [r3, #16]
    17d0:	461a      	mov	r2, r3
    17d2:	9b03      	ldr	r3, [sp, #12]
    17d4:	4293      	cmp	r3, r2
    17d6:	d3d9      	bcc.n	178c <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    17d8:	2300      	movs	r3, #0
    17da:	9303      	str	r3, [sp, #12]
    17dc:	e028      	b.n	1830 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    17de:	9901      	ldr	r1, [sp, #4]
    17e0:	9a03      	ldr	r2, [sp, #12]
    17e2:	4613      	mov	r3, r2
    17e4:	009b      	lsls	r3, r3, #2
    17e6:	4413      	add	r3, r2
    17e8:	009b      	lsls	r3, r3, #2
    17ea:	440b      	add	r3, r1
    17ec:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    17f0:	681a      	ldr	r2, [r3, #0]
    17f2:	4917      	ldr	r1, [pc, #92]	; (1850 <Clock_Ip_InitClock+0x6b0>)
    17f4:	4613      	mov	r3, r2
    17f6:	00db      	lsls	r3, r3, #3
    17f8:	4413      	add	r3, r2
    17fa:	440b      	add	r3, r1
    17fc:	3301      	adds	r3, #1
    17fe:	781b      	ldrb	r3, [r3, #0]
    1800:	461a      	mov	r2, r3
    1802:	4b16      	ldr	r3, [pc, #88]	; (185c <Clock_Ip_InitClock+0x6bc>)
    1804:	5c9b      	ldrb	r3, [r3, r2]
    1806:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    1808:	4a15      	ldr	r2, [pc, #84]	; (1860 <Clock_Ip_InitClock+0x6c0>)
    180a:	9b02      	ldr	r3, [sp, #8]
    180c:	011b      	lsls	r3, r3, #4
    180e:	4413      	add	r3, r2
    1810:	330c      	adds	r3, #12
    1812:	6819      	ldr	r1, [r3, #0]
    1814:	9a03      	ldr	r2, [sp, #12]
    1816:	4613      	mov	r3, r2
    1818:	009b      	lsls	r3, r3, #2
    181a:	4413      	add	r3, r2
    181c:	009b      	lsls	r3, r3, #2
    181e:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1822:	9a01      	ldr	r2, [sp, #4]
    1824:	4413      	add	r3, r2
    1826:	4618      	mov	r0, r3
    1828:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    182a:	9b03      	ldr	r3, [sp, #12]
    182c:	3301      	adds	r3, #1
    182e:	9303      	str	r3, [sp, #12]
    1830:	9b01      	ldr	r3, [sp, #4]
    1832:	7c9b      	ldrb	r3, [r3, #18]
    1834:	461a      	mov	r2, r3
    1836:	9b03      	ldr	r3, [sp, #12]
    1838:	4293      	cmp	r3, r2
    183a:	d3d0      	bcc.n	17de <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    183c:	2104      	movs	r1, #4
    183e:	9801      	ldr	r0, [sp, #4]
    1840:	f002 ff48 	bl	46d4 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    1844:	bf00      	nop
    1846:	b004      	add	sp, #16
    1848:	bd10      	pop	{r4, pc}
    184a:	bf00      	nop
    184c:	1fff8b6c 	.word	0x1fff8b6c
    1850:	0000afc0 	.word	0x0000afc0
    1854:	0000af60 	.word	0x0000af60
    1858:	0000b548 	.word	0x0000b548
    185c:	0000afb0 	.word	0x0000afb0
    1860:	0000b5bc 	.word	0x0000b5bc

00001864 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    1864:	b500      	push	{lr}
    1866:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    1868:	2302      	movs	r3, #2
    186a:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    186c:	2300      	movs	r3, #0
    186e:	9304      	str	r3, [sp, #16]
    1870:	e02c      	b.n	18cc <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    1872:	4a36      	ldr	r2, [pc, #216]	; (194c <Clock_Ip_GetPllStatus+0xe8>)
    1874:	9b04      	ldr	r3, [sp, #16]
    1876:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    187a:	4935      	ldr	r1, [pc, #212]	; (1950 <Clock_Ip_GetPllStatus+0xec>)
    187c:	4613      	mov	r3, r2
    187e:	00db      	lsls	r3, r3, #3
    1880:	4413      	add	r3, r2
    1882:	440b      	add	r3, r1
    1884:	3301      	adds	r3, #1
    1886:	781b      	ldrb	r3, [r3, #0]
    1888:	461a      	mov	r2, r3
    188a:	4b32      	ldr	r3, [pc, #200]	; (1954 <Clock_Ip_GetPllStatus+0xf0>)
    188c:	5c9b      	ldrb	r3, [r3, r2]
    188e:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    1890:	4931      	ldr	r1, [pc, #196]	; (1958 <Clock_Ip_GetPllStatus+0xf4>)
    1892:	9a03      	ldr	r2, [sp, #12]
    1894:	4613      	mov	r3, r2
    1896:	009b      	lsls	r3, r3, #2
    1898:	4413      	add	r3, r2
    189a:	009b      	lsls	r3, r3, #2
    189c:	440b      	add	r3, r1
    189e:	3308      	adds	r3, #8
    18a0:	681b      	ldr	r3, [r3, #0]
    18a2:	492a      	ldr	r1, [pc, #168]	; (194c <Clock_Ip_GetPllStatus+0xe8>)
    18a4:	9a04      	ldr	r2, [sp, #16]
    18a6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    18aa:	4610      	mov	r0, r2
    18ac:	4798      	blx	r3
    18ae:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    18b0:	9b02      	ldr	r3, [sp, #8]
    18b2:	2b01      	cmp	r3, #1
    18b4:	d102      	bne.n	18bc <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    18b6:	2301      	movs	r3, #1
    18b8:	9305      	str	r3, [sp, #20]
            break;
    18ba:	e00d      	b.n	18d8 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    18bc:	9b02      	ldr	r3, [sp, #8]
    18be:	2b02      	cmp	r3, #2
    18c0:	d101      	bne.n	18c6 <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    18c2:	2300      	movs	r3, #0
    18c4:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    18c6:	9b04      	ldr	r3, [sp, #16]
    18c8:	3301      	adds	r3, #1
    18ca:	9304      	str	r3, [sp, #16]
    18cc:	4b23      	ldr	r3, [pc, #140]	; (195c <Clock_Ip_GetPllStatus+0xf8>)
    18ce:	789b      	ldrb	r3, [r3, #2]
    18d0:	461a      	mov	r2, r3
    18d2:	9b04      	ldr	r3, [sp, #16]
    18d4:	4293      	cmp	r3, r2
    18d6:	d3cc      	bcc.n	1872 <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    18d8:	9b05      	ldr	r3, [sp, #20]
    18da:	2b00      	cmp	r3, #0
    18dc:	d130      	bne.n	1940 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    18de:	2300      	movs	r3, #0
    18e0:	9304      	str	r3, [sp, #16]
    18e2:	e027      	b.n	1934 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    18e4:	4a1e      	ldr	r2, [pc, #120]	; (1960 <Clock_Ip_GetPllStatus+0xfc>)
    18e6:	9b04      	ldr	r3, [sp, #16]
    18e8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    18ec:	4918      	ldr	r1, [pc, #96]	; (1950 <Clock_Ip_GetPllStatus+0xec>)
    18ee:	4613      	mov	r3, r2
    18f0:	00db      	lsls	r3, r3, #3
    18f2:	4413      	add	r3, r2
    18f4:	440b      	add	r3, r1
    18f6:	3301      	adds	r3, #1
    18f8:	781b      	ldrb	r3, [r3, #0]
    18fa:	461a      	mov	r2, r3
    18fc:	4b19      	ldr	r3, [pc, #100]	; (1964 <Clock_Ip_GetPllStatus+0x100>)
    18fe:	5c9b      	ldrb	r3, [r3, r2]
    1900:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    1902:	4919      	ldr	r1, [pc, #100]	; (1968 <Clock_Ip_GetPllStatus+0x104>)
    1904:	9a03      	ldr	r2, [sp, #12]
    1906:	4613      	mov	r3, r2
    1908:	005b      	lsls	r3, r3, #1
    190a:	4413      	add	r3, r2
    190c:	009b      	lsls	r3, r3, #2
    190e:	440b      	add	r3, r1
    1910:	3308      	adds	r3, #8
    1912:	681b      	ldr	r3, [r3, #0]
    1914:	4912      	ldr	r1, [pc, #72]	; (1960 <Clock_Ip_GetPllStatus+0xfc>)
    1916:	9a04      	ldr	r2, [sp, #16]
    1918:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    191c:	4610      	mov	r0, r2
    191e:	4798      	blx	r3
    1920:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    1922:	9b01      	ldr	r3, [sp, #4]
    1924:	2b01      	cmp	r3, #1
    1926:	d102      	bne.n	192e <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    1928:	2301      	movs	r3, #1
    192a:	9305      	str	r3, [sp, #20]
                break;
    192c:	e008      	b.n	1940 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    192e:	9b04      	ldr	r3, [sp, #16]
    1930:	3301      	adds	r3, #1
    1932:	9304      	str	r3, [sp, #16]
    1934:	4b09      	ldr	r3, [pc, #36]	; (195c <Clock_Ip_GetPllStatus+0xf8>)
    1936:	78db      	ldrb	r3, [r3, #3]
    1938:	461a      	mov	r2, r3
    193a:	9b04      	ldr	r3, [sp, #16]
    193c:	4293      	cmp	r3, r2
    193e:	d3d1      	bcc.n	18e4 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    1940:	9b05      	ldr	r3, [sp, #20]
}
    1942:	4618      	mov	r0, r3
    1944:	b007      	add	sp, #28
    1946:	f85d fb04 	ldr.w	pc, [sp], #4
    194a:	bf00      	nop
    194c:	0000b4c8 	.word	0x0000b4c8
    1950:	0000afc0 	.word	0x0000afc0
    1954:	0000af80 	.word	0x0000af80
    1958:	0000b5cc 	.word	0x0000b5cc
    195c:	1fff8b6c 	.word	0x1fff8b6c
    1960:	0000b4cc 	.word	0x0000b4cc
    1964:	0000af70 	.word	0x0000af70
    1968:	0000b53c 	.word	0x0000b53c

0000196c <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    196c:	b500      	push	{lr}
    196e:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    1970:	4b55      	ldr	r3, [pc, #340]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1972:	681b      	ldr	r3, [r3, #0]
    1974:	2b00      	cmp	r3, #0
    1976:	f000 80a2 	beq.w	1abe <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    197a:	2300      	movs	r3, #0
    197c:	9301      	str	r3, [sp, #4]
    197e:	e02c      	b.n	19da <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    1980:	4b51      	ldr	r3, [pc, #324]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1982:	681a      	ldr	r2, [r3, #0]
    1984:	9b01      	ldr	r3, [sp, #4]
    1986:	330d      	adds	r3, #13
    1988:	00db      	lsls	r3, r3, #3
    198a:	4413      	add	r3, r2
    198c:	685b      	ldr	r3, [r3, #4]
    198e:	4a4f      	ldr	r2, [pc, #316]	; (1acc <Clock_Ip_DistributePll+0x160>)
    1990:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1994:	2b03      	cmp	r3, #3
    1996:	d11d      	bne.n	19d4 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    1998:	4b4b      	ldr	r3, [pc, #300]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    199a:	681b      	ldr	r3, [r3, #0]
    199c:	9a01      	ldr	r2, [sp, #4]
    199e:	320d      	adds	r2, #13
    19a0:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    19a4:	494a      	ldr	r1, [pc, #296]	; (1ad0 <Clock_Ip_DistributePll+0x164>)
    19a6:	4613      	mov	r3, r2
    19a8:	00db      	lsls	r3, r3, #3
    19aa:	4413      	add	r3, r2
    19ac:	440b      	add	r3, r1
    19ae:	3301      	adds	r3, #1
    19b0:	781b      	ldrb	r3, [r3, #0]
    19b2:	461a      	mov	r2, r3
    19b4:	4b47      	ldr	r3, [pc, #284]	; (1ad4 <Clock_Ip_DistributePll+0x168>)
    19b6:	5c9b      	ldrb	r3, [r3, r2]
    19b8:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    19ba:	4a47      	ldr	r2, [pc, #284]	; (1ad8 <Clock_Ip_DistributePll+0x16c>)
    19bc:	9b00      	ldr	r3, [sp, #0]
    19be:	00db      	lsls	r3, r3, #3
    19c0:	4413      	add	r3, r2
    19c2:	685b      	ldr	r3, [r3, #4]
    19c4:	4a40      	ldr	r2, [pc, #256]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    19c6:	6811      	ldr	r1, [r2, #0]
    19c8:	9a01      	ldr	r2, [sp, #4]
    19ca:	320d      	adds	r2, #13
    19cc:	00d2      	lsls	r2, r2, #3
    19ce:	440a      	add	r2, r1
    19d0:	4610      	mov	r0, r2
    19d2:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    19d4:	9b01      	ldr	r3, [sp, #4]
    19d6:	3301      	adds	r3, #1
    19d8:	9301      	str	r3, [sp, #4]
    19da:	4b3b      	ldr	r3, [pc, #236]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    19dc:	681b      	ldr	r3, [r3, #0]
    19de:	7adb      	ldrb	r3, [r3, #11]
    19e0:	461a      	mov	r2, r3
    19e2:	9b01      	ldr	r3, [sp, #4]
    19e4:	4293      	cmp	r3, r2
    19e6:	d3cb      	bcc.n	1980 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    19e8:	4b3c      	ldr	r3, [pc, #240]	; (1adc <Clock_Ip_DistributePll+0x170>)
    19ea:	781b      	ldrb	r3, [r3, #0]
    19ec:	2b00      	cmp	r3, #0
    19ee:	d066      	beq.n	1abe <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    19f0:	2300      	movs	r3, #0
    19f2:	9301      	str	r3, [sp, #4]
    19f4:	e021      	b.n	1a3a <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    19f6:	4b34      	ldr	r3, [pc, #208]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    19f8:	681a      	ldr	r2, [r3, #0]
    19fa:	9b01      	ldr	r3, [sp, #4]
    19fc:	334e      	adds	r3, #78	; 0x4e
    19fe:	00db      	lsls	r3, r3, #3
    1a00:	4413      	add	r3, r2
    1a02:	685a      	ldr	r2, [r3, #4]
    1a04:	4932      	ldr	r1, [pc, #200]	; (1ad0 <Clock_Ip_DistributePll+0x164>)
    1a06:	4613      	mov	r3, r2
    1a08:	00db      	lsls	r3, r3, #3
    1a0a:	4413      	add	r3, r2
    1a0c:	440b      	add	r3, r1
    1a0e:	3301      	adds	r3, #1
    1a10:	781b      	ldrb	r3, [r3, #0]
    1a12:	461a      	mov	r2, r3
    1a14:	4b32      	ldr	r3, [pc, #200]	; (1ae0 <Clock_Ip_DistributePll+0x174>)
    1a16:	5c9b      	ldrb	r3, [r3, r2]
    1a18:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    1a1a:	4a32      	ldr	r2, [pc, #200]	; (1ae4 <Clock_Ip_DistributePll+0x178>)
    1a1c:	9b00      	ldr	r3, [sp, #0]
    1a1e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1a22:	4a29      	ldr	r2, [pc, #164]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1a24:	6811      	ldr	r1, [r2, #0]
    1a26:	9a01      	ldr	r2, [sp, #4]
    1a28:	324e      	adds	r2, #78	; 0x4e
    1a2a:	00d2      	lsls	r2, r2, #3
    1a2c:	440a      	add	r2, r1
    1a2e:	3204      	adds	r2, #4
    1a30:	4610      	mov	r0, r2
    1a32:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1a34:	9b01      	ldr	r3, [sp, #4]
    1a36:	3301      	adds	r3, #1
    1a38:	9301      	str	r3, [sp, #4]
    1a3a:	4b23      	ldr	r3, [pc, #140]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1a3c:	681b      	ldr	r3, [r3, #0]
    1a3e:	7c1b      	ldrb	r3, [r3, #16]
    1a40:	461a      	mov	r2, r3
    1a42:	9b01      	ldr	r3, [sp, #4]
    1a44:	4293      	cmp	r3, r2
    1a46:	d3d6      	bcc.n	19f6 <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1a48:	2300      	movs	r3, #0
    1a4a:	9301      	str	r3, [sp, #4]
    1a4c:	e02a      	b.n	1aa4 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1a4e:	4b1e      	ldr	r3, [pc, #120]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1a50:	6819      	ldr	r1, [r3, #0]
    1a52:	9a01      	ldr	r2, [sp, #4]
    1a54:	4613      	mov	r3, r2
    1a56:	009b      	lsls	r3, r3, #2
    1a58:	4413      	add	r3, r2
    1a5a:	009b      	lsls	r3, r3, #2
    1a5c:	440b      	add	r3, r1
    1a5e:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1a62:	681a      	ldr	r2, [r3, #0]
    1a64:	491a      	ldr	r1, [pc, #104]	; (1ad0 <Clock_Ip_DistributePll+0x164>)
    1a66:	4613      	mov	r3, r2
    1a68:	00db      	lsls	r3, r3, #3
    1a6a:	4413      	add	r3, r2
    1a6c:	440b      	add	r3, r1
    1a6e:	3301      	adds	r3, #1
    1a70:	781b      	ldrb	r3, [r3, #0]
    1a72:	461a      	mov	r2, r3
    1a74:	4b1c      	ldr	r3, [pc, #112]	; (1ae8 <Clock_Ip_DistributePll+0x17c>)
    1a76:	5c9b      	ldrb	r3, [r3, r2]
    1a78:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    1a7a:	4a1c      	ldr	r2, [pc, #112]	; (1aec <Clock_Ip_DistributePll+0x180>)
    1a7c:	9b00      	ldr	r3, [sp, #0]
    1a7e:	011b      	lsls	r3, r3, #4
    1a80:	4413      	add	r3, r2
    1a82:	330c      	adds	r3, #12
    1a84:	6819      	ldr	r1, [r3, #0]
    1a86:	4b10      	ldr	r3, [pc, #64]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1a88:	6818      	ldr	r0, [r3, #0]
    1a8a:	9a01      	ldr	r2, [sp, #4]
    1a8c:	4613      	mov	r3, r2
    1a8e:	009b      	lsls	r3, r3, #2
    1a90:	4413      	add	r3, r2
    1a92:	009b      	lsls	r3, r3, #2
    1a94:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1a98:	4403      	add	r3, r0
    1a9a:	4618      	mov	r0, r3
    1a9c:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1a9e:	9b01      	ldr	r3, [sp, #4]
    1aa0:	3301      	adds	r3, #1
    1aa2:	9301      	str	r3, [sp, #4]
    1aa4:	4b08      	ldr	r3, [pc, #32]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1aa6:	681b      	ldr	r3, [r3, #0]
    1aa8:	7c9b      	ldrb	r3, [r3, #18]
    1aaa:	461a      	mov	r2, r3
    1aac:	9b01      	ldr	r3, [sp, #4]
    1aae:	4293      	cmp	r3, r2
    1ab0:	d3cd      	bcc.n	1a4e <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1ab2:	4b05      	ldr	r3, [pc, #20]	; (1ac8 <Clock_Ip_DistributePll+0x15c>)
    1ab4:	681b      	ldr	r3, [r3, #0]
    1ab6:	2104      	movs	r1, #4
    1ab8:	4618      	mov	r0, r3
    1aba:	f002 fe0b 	bl	46d4 <Clock_Ip_Command>
        }
    }
}
    1abe:	bf00      	nop
    1ac0:	b003      	add	sp, #12
    1ac2:	f85d fb04 	ldr.w	pc, [sp], #4
    1ac6:	bf00      	nop
    1ac8:	1fff8b64 	.word	0x1fff8b64
    1acc:	0000b40c 	.word	0x0000b40c
    1ad0:	0000afc0 	.word	0x0000afc0
    1ad4:	0000af90 	.word	0x0000af90
    1ad8:	0000b5f8 	.word	0x0000b5f8
    1adc:	1fff8b6c 	.word	0x1fff8b6c
    1ae0:	0000af60 	.word	0x0000af60
    1ae4:	0000b548 	.word	0x0000b548
    1ae8:	0000afb0 	.word	0x0000afb0
    1aec:	0000b5bc 	.word	0x0000b5bc

00001af0 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    1af0:	b500      	push	{lr}
    1af2:	b085      	sub	sp, #20
    1af4:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1af6:	490c      	ldr	r1, [pc, #48]	; (1b28 <Clock_Ip_DisableClockMonitor+0x38>)
    1af8:	9a01      	ldr	r2, [sp, #4]
    1afa:	4613      	mov	r3, r2
    1afc:	00db      	lsls	r3, r3, #3
    1afe:	4413      	add	r3, r2
    1b00:	440b      	add	r3, r1
    1b02:	3301      	adds	r3, #1
    1b04:	781b      	ldrb	r3, [r3, #0]
    1b06:	461a      	mov	r2, r3
    1b08:	4b08      	ldr	r3, [pc, #32]	; (1b2c <Clock_Ip_DisableClockMonitor+0x3c>)
    1b0a:	5c9b      	ldrb	r3, [r3, r2]
    1b0c:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    1b0e:	4a08      	ldr	r2, [pc, #32]	; (1b30 <Clock_Ip_DisableClockMonitor+0x40>)
    1b10:	9b03      	ldr	r3, [sp, #12]
    1b12:	011b      	lsls	r3, r3, #4
    1b14:	4413      	add	r3, r2
    1b16:	3308      	adds	r3, #8
    1b18:	681b      	ldr	r3, [r3, #0]
    1b1a:	9801      	ldr	r0, [sp, #4]
    1b1c:	4798      	blx	r3
}
    1b1e:	bf00      	nop
    1b20:	b005      	add	sp, #20
    1b22:	f85d fb04 	ldr.w	pc, [sp], #4
    1b26:	bf00      	nop
    1b28:	0000afc0 	.word	0x0000afc0
    1b2c:	0000afb0 	.word	0x0000afb0
    1b30:	0000b5bc 	.word	0x0000b5bc

00001b34 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    1b34:	b082      	sub	sp, #8
    1b36:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    1b38:	4a02      	ldr	r2, [pc, #8]	; (1b44 <Clock_Ip_InstallNotificationsCallback+0x10>)
    1b3a:	9b01      	ldr	r3, [sp, #4]
    1b3c:	6013      	str	r3, [r2, #0]
}
    1b3e:	bf00      	nop
    1b40:	b002      	add	sp, #8
    1b42:	4770      	bx	lr
    1b44:	1fff8b14 	.word	0x1fff8b14

00001b48 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    1b48:	b500      	push	{lr}
    1b4a:	b085      	sub	sp, #20
    1b4c:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1b4e:	490c      	ldr	r1, [pc, #48]	; (1b80 <Clock_Ip_DisableModuleClock+0x38>)
    1b50:	9a01      	ldr	r2, [sp, #4]
    1b52:	4613      	mov	r3, r2
    1b54:	00db      	lsls	r3, r3, #3
    1b56:	4413      	add	r3, r2
    1b58:	440b      	add	r3, r1
    1b5a:	3301      	adds	r3, #1
    1b5c:	781b      	ldrb	r3, [r3, #0]
    1b5e:	461a      	mov	r2, r3
    1b60:	4b08      	ldr	r3, [pc, #32]	; (1b84 <Clock_Ip_DisableModuleClock+0x3c>)
    1b62:	5c9b      	ldrb	r3, [r3, r2]
    1b64:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    1b66:	4a08      	ldr	r2, [pc, #32]	; (1b88 <Clock_Ip_DisableModuleClock+0x40>)
    1b68:	9b03      	ldr	r3, [sp, #12]
    1b6a:	00db      	lsls	r3, r3, #3
    1b6c:	4413      	add	r3, r2
    1b6e:	685b      	ldr	r3, [r3, #4]
    1b70:	2101      	movs	r1, #1
    1b72:	9801      	ldr	r0, [sp, #4]
    1b74:	4798      	blx	r3
}
    1b76:	bf00      	nop
    1b78:	b005      	add	sp, #20
    1b7a:	f85d fb04 	ldr.w	pc, [sp], #4
    1b7e:	bf00      	nop
    1b80:	0000afc0 	.word	0x0000afc0
    1b84:	0000af60 	.word	0x0000af60
    1b88:	0000b548 	.word	0x0000b548

00001b8c <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    1b8c:	b500      	push	{lr}
    1b8e:	b085      	sub	sp, #20
    1b90:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1b92:	490c      	ldr	r1, [pc, #48]	; (1bc4 <Clock_Ip_EnableModuleClock+0x38>)
    1b94:	9a01      	ldr	r2, [sp, #4]
    1b96:	4613      	mov	r3, r2
    1b98:	00db      	lsls	r3, r3, #3
    1b9a:	4413      	add	r3, r2
    1b9c:	440b      	add	r3, r1
    1b9e:	3301      	adds	r3, #1
    1ba0:	781b      	ldrb	r3, [r3, #0]
    1ba2:	461a      	mov	r2, r3
    1ba4:	4b08      	ldr	r3, [pc, #32]	; (1bc8 <Clock_Ip_EnableModuleClock+0x3c>)
    1ba6:	5c9b      	ldrb	r3, [r3, r2]
    1ba8:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    1baa:	4a08      	ldr	r2, [pc, #32]	; (1bcc <Clock_Ip_EnableModuleClock+0x40>)
    1bac:	9b03      	ldr	r3, [sp, #12]
    1bae:	00db      	lsls	r3, r3, #3
    1bb0:	4413      	add	r3, r2
    1bb2:	685b      	ldr	r3, [r3, #4]
    1bb4:	2100      	movs	r1, #0
    1bb6:	9801      	ldr	r0, [sp, #4]
    1bb8:	4798      	blx	r3
}
    1bba:	bf00      	nop
    1bbc:	b005      	add	sp, #20
    1bbe:	f85d fb04 	ldr.w	pc, [sp], #4
    1bc2:	bf00      	nop
    1bc4:	0000afc0 	.word	0x0000afc0
    1bc8:	0000af60 	.word	0x0000af60
    1bcc:	0000b548 	.word	0x0000b548

00001bd0 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    1bd0:	b500      	push	{lr}
    1bd2:	b083      	sub	sp, #12
    1bd4:	9001      	str	r0, [sp, #4]
    1bd6:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    1bd8:	4b08      	ldr	r3, [pc, #32]	; (1bfc <Clock_Ip_PowerModeChangeNotification+0x2c>)
    1bda:	2200      	movs	r2, #0
    1bdc:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    1bde:	4b08      	ldr	r3, [pc, #32]	; (1c00 <Clock_Ip_PowerModeChangeNotification+0x30>)
    1be0:	681b      	ldr	r3, [r3, #0]
    1be2:	2102      	movs	r1, #2
    1be4:	4618      	mov	r0, r3
    1be6:	f002 fd75 	bl	46d4 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    1bea:	9900      	ldr	r1, [sp, #0]
    1bec:	9801      	ldr	r0, [sp, #4]
    1bee:	f002 fc51 	bl	4494 <Clock_Ip_ClockPowerModeChangeNotification>
}
    1bf2:	bf00      	nop
    1bf4:	b003      	add	sp, #12
    1bf6:	f85d fb04 	ldr.w	pc, [sp], #4
    1bfa:	bf00      	nop
    1bfc:	1fff8b10 	.word	0x1fff8b10
    1c00:	1fff8b64 	.word	0x1fff8b64

00001c04 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    1c04:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    1c06:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    1c0a:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    1c0c:	4b06      	ldr	r3, [pc, #24]	; (1c28 <Clock_Ip_SetWaitStates+0x24>)
    1c0e:	785b      	ldrb	r3, [r3, #1]
    1c10:	2b00      	cmp	r3, #0
    1c12:	d005      	beq.n	1c20 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    1c14:	9b01      	ldr	r3, [sp, #4]
    1c16:	3b01      	subs	r3, #1
    1c18:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    1c1a:	9b01      	ldr	r3, [sp, #4]
    1c1c:	2b00      	cmp	r3, #0
    1c1e:	d1f9      	bne.n	1c14 <Clock_Ip_SetWaitStates+0x10>
    }
}
    1c20:	bf00      	nop
    1c22:	b002      	add	sp, #8
    1c24:	4770      	bx	lr
    1c26:	bf00      	nop
    1c28:	1fff8b6c 	.word	0x1fff8b6c

00001c2c <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    1c2c:	b500      	push	{lr}
    1c2e:	b083      	sub	sp, #12
    1c30:	9001      	str	r0, [sp, #4]
    1c32:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    1c34:	4b04      	ldr	r3, [pc, #16]	; (1c48 <Clock_Ip_ReportClockErrors+0x1c>)
    1c36:	681b      	ldr	r3, [r3, #0]
    1c38:	9900      	ldr	r1, [sp, #0]
    1c3a:	9801      	ldr	r0, [sp, #4]
    1c3c:	4798      	blx	r3
}
    1c3e:	bf00      	nop
    1c40:	b003      	add	sp, #12
    1c42:	f85d fb04 	ldr.w	pc, [sp], #4
    1c46:	bf00      	nop
    1c48:	1fff8b14 	.word	0x1fff8b14

00001c4c <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    1c4c:	b500      	push	{lr}
    1c4e:	b085      	sub	sp, #20
    1c50:	9003      	str	r0, [sp, #12]
    1c52:	9102      	str	r1, [sp, #8]
    1c54:	9201      	str	r2, [sp, #4]
    1c56:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    1c58:	2000      	movs	r0, #0
    1c5a:	f7fe ffd0 	bl	bfe <OsIf_GetCounter>
    1c5e:	4602      	mov	r2, r0
    1c60:	9b03      	ldr	r3, [sp, #12]
    1c62:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    1c64:	9b02      	ldr	r3, [sp, #8]
    1c66:	2200      	movs	r2, #0
    1c68:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    1c6a:	2100      	movs	r1, #0
    1c6c:	9800      	ldr	r0, [sp, #0]
    1c6e:	f7ff f812 	bl	c96 <OsIf_MicrosToTicks>
    1c72:	4602      	mov	r2, r0
    1c74:	9b01      	ldr	r3, [sp, #4]
    1c76:	601a      	str	r2, [r3, #0]
}
    1c78:	bf00      	nop
    1c7a:	b005      	add	sp, #20
    1c7c:	f85d fb04 	ldr.w	pc, [sp], #4

00001c80 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    1c80:	b500      	push	{lr}
    1c82:	b087      	sub	sp, #28
    1c84:	9003      	str	r0, [sp, #12]
    1c86:	9102      	str	r1, [sp, #8]
    1c88:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    1c8a:	2300      	movs	r3, #0
    1c8c:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    1c90:	2100      	movs	r1, #0
    1c92:	9803      	ldr	r0, [sp, #12]
    1c94:	f7fe ffcc 	bl	c30 <OsIf_GetElapsed>
    1c98:	4602      	mov	r2, r0
    1c9a:	9b02      	ldr	r3, [sp, #8]
    1c9c:	681b      	ldr	r3, [r3, #0]
    1c9e:	441a      	add	r2, r3
    1ca0:	9b02      	ldr	r3, [sp, #8]
    1ca2:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    1ca4:	9b02      	ldr	r3, [sp, #8]
    1ca6:	681b      	ldr	r3, [r3, #0]
    1ca8:	9a01      	ldr	r2, [sp, #4]
    1caa:	429a      	cmp	r2, r3
    1cac:	d802      	bhi.n	1cb4 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    1cae:	2301      	movs	r3, #1
    1cb0:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    1cb4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    1cb8:	4618      	mov	r0, r3
    1cba:	b007      	add	sp, #28
    1cbc:	f85d fb04 	ldr.w	pc, [sp], #4

00001cc0 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    1cc0:	b082      	sub	sp, #8
    1cc2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    1cc4:	bf00      	nop
    1cc6:	b002      	add	sp, #8
    1cc8:	4770      	bx	lr

00001cca <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    1cca:	b500      	push	{lr}
    1ccc:	b083      	sub	sp, #12
    1cce:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1cd0:	9b01      	ldr	r3, [sp, #4]
    1cd2:	2b00      	cmp	r3, #0
    1cd4:	d002      	beq.n	1cdc <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    1cd6:	9801      	ldr	r0, [sp, #4]
    1cd8:	f000 f8ad 	bl	1e36 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1cdc:	bf00      	nop
    1cde:	b003      	add	sp, #12
    1ce0:	f85d fb04 	ldr.w	pc, [sp], #4

00001ce4 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    1ce4:	b500      	push	{lr}
    1ce6:	b083      	sub	sp, #12
    1ce8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1cea:	9b01      	ldr	r3, [sp, #4]
    1cec:	2b00      	cmp	r3, #0
    1cee:	d002      	beq.n	1cf6 <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    1cf0:	9801      	ldr	r0, [sp, #4]
    1cf2:	f000 f8cd 	bl	1e90 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1cf6:	bf00      	nop
    1cf8:	b003      	add	sp, #12
    1cfa:	f85d fb04 	ldr.w	pc, [sp], #4

00001cfe <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1cfe:	b500      	push	{lr}
    1d00:	b083      	sub	sp, #12
    1d02:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d04:	9b01      	ldr	r3, [sp, #4]
    1d06:	2b00      	cmp	r3, #0
    1d08:	d002      	beq.n	1d10 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    1d0a:	9801      	ldr	r0, [sp, #4]
    1d0c:	f000 f8ee 	bl	1eec <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d10:	bf00      	nop
    1d12:	b003      	add	sp, #12
    1d14:	f85d fb04 	ldr.w	pc, [sp], #4

00001d18 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1d18:	b500      	push	{lr}
    1d1a:	b083      	sub	sp, #12
    1d1c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d1e:	9b01      	ldr	r3, [sp, #4]
    1d20:	2b00      	cmp	r3, #0
    1d22:	d002      	beq.n	1d2a <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    1d24:	9801      	ldr	r0, [sp, #4]
    1d26:	f000 f8f9 	bl	1f1c <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d2a:	bf00      	nop
    1d2c:	b003      	add	sp, #12
    1d2e:	f85d fb04 	ldr.w	pc, [sp], #4

00001d32 <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1d32:	b500      	push	{lr}
    1d34:	b083      	sub	sp, #12
    1d36:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d38:	9b01      	ldr	r3, [sp, #4]
    1d3a:	2b00      	cmp	r3, #0
    1d3c:	d002      	beq.n	1d44 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    1d3e:	9801      	ldr	r0, [sp, #4]
    1d40:	f000 f904 	bl	1f4c <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d44:	bf00      	nop
    1d46:	b003      	add	sp, #12
    1d48:	f85d fb04 	ldr.w	pc, [sp], #4

00001d4c <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1d4c:	b500      	push	{lr}
    1d4e:	b083      	sub	sp, #12
    1d50:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d52:	9b01      	ldr	r3, [sp, #4]
    1d54:	2b00      	cmp	r3, #0
    1d56:	d002      	beq.n	1d5e <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    1d58:	9801      	ldr	r0, [sp, #4]
    1d5a:	f000 f90f 	bl	1f7c <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d5e:	bf00      	nop
    1d60:	b003      	add	sp, #12
    1d62:	f85d fb04 	ldr.w	pc, [sp], #4

00001d66 <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1d66:	b500      	push	{lr}
    1d68:	b083      	sub	sp, #12
    1d6a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d6c:	9b01      	ldr	r3, [sp, #4]
    1d6e:	2b00      	cmp	r3, #0
    1d70:	d002      	beq.n	1d78 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    1d72:	9801      	ldr	r0, [sp, #4]
    1d74:	f000 f91a 	bl	1fac <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d78:	bf00      	nop
    1d7a:	b003      	add	sp, #12
    1d7c:	f85d fb04 	ldr.w	pc, [sp], #4

00001d80 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1d80:	b500      	push	{lr}
    1d82:	b083      	sub	sp, #12
    1d84:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d86:	9b01      	ldr	r3, [sp, #4]
    1d88:	2b00      	cmp	r3, #0
    1d8a:	d002      	beq.n	1d92 <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    1d8c:	9801      	ldr	r0, [sp, #4]
    1d8e:	f000 f925 	bl	1fdc <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d92:	bf00      	nop
    1d94:	b003      	add	sp, #12
    1d96:	f85d fb04 	ldr.w	pc, [sp], #4

00001d9a <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1d9a:	b500      	push	{lr}
    1d9c:	b083      	sub	sp, #12
    1d9e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1da0:	9b01      	ldr	r3, [sp, #4]
    1da2:	2b00      	cmp	r3, #0
    1da4:	d002      	beq.n	1dac <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    1da6:	9801      	ldr	r0, [sp, #4]
    1da8:	f000 f930 	bl	200c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1dac:	bf00      	nop
    1dae:	b003      	add	sp, #12
    1db0:	f85d fb04 	ldr.w	pc, [sp], #4

00001db4 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1db4:	b500      	push	{lr}
    1db6:	b083      	sub	sp, #12
    1db8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1dba:	9b01      	ldr	r3, [sp, #4]
    1dbc:	2b00      	cmp	r3, #0
    1dbe:	d002      	beq.n	1dc6 <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    1dc0:	9801      	ldr	r0, [sp, #4]
    1dc2:	f000 f93b 	bl	203c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1dc6:	bf00      	nop
    1dc8:	b003      	add	sp, #12
    1dca:	f85d fb04 	ldr.w	pc, [sp], #4

00001dce <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1dce:	b500      	push	{lr}
    1dd0:	b083      	sub	sp, #12
    1dd2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1dd4:	9b01      	ldr	r3, [sp, #4]
    1dd6:	2b00      	cmp	r3, #0
    1dd8:	d002      	beq.n	1de0 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    1dda:	9801      	ldr	r0, [sp, #4]
    1ddc:	f000 f946 	bl	206c <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1de0:	bf00      	nop
    1de2:	b003      	add	sp, #12
    1de4:	f85d fb04 	ldr.w	pc, [sp], #4

00001de8 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    1de8:	b500      	push	{lr}
    1dea:	b083      	sub	sp, #12
    1dec:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1dee:	9b01      	ldr	r3, [sp, #4]
    1df0:	2b00      	cmp	r3, #0
    1df2:	d002      	beq.n	1dfa <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    1df4:	9801      	ldr	r0, [sp, #4]
    1df6:	f000 f951 	bl	209c <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1dfa:	bf00      	nop
    1dfc:	b003      	add	sp, #12
    1dfe:	f85d fb04 	ldr.w	pc, [sp], #4

00001e02 <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    1e02:	b500      	push	{lr}
    1e04:	b083      	sub	sp, #12
    1e06:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1e08:	9b01      	ldr	r3, [sp, #4]
    1e0a:	2b00      	cmp	r3, #0
    1e0c:	d002      	beq.n	1e14 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    1e0e:	9801      	ldr	r0, [sp, #4]
    1e10:	f000 f95e 	bl	20d0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1e14:	bf00      	nop
    1e16:	b003      	add	sp, #12
    1e18:	f85d fb04 	ldr.w	pc, [sp], #4

00001e1c <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    1e1c:	b500      	push	{lr}
    1e1e:	b083      	sub	sp, #12
    1e20:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1e22:	9b01      	ldr	r3, [sp, #4]
    1e24:	2b00      	cmp	r3, #0
    1e26:	d002      	beq.n	1e2e <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    1e28:	9801      	ldr	r0, [sp, #4]
    1e2a:	f000 f98b 	bl	2144 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1e2e:	bf00      	nop
    1e30:	b003      	add	sp, #12
    1e32:	f85d fb04 	ldr.w	pc, [sp], #4

00001e36 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1e36:	b086      	sub	sp, #24
    1e38:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    1e3a:	9b01      	ldr	r3, [sp, #4]
    1e3c:	681a      	ldr	r2, [r3, #0]
    1e3e:	4911      	ldr	r1, [pc, #68]	; (1e84 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    1e40:	4613      	mov	r3, r2
    1e42:	00db      	lsls	r3, r3, #3
    1e44:	4413      	add	r3, r2
    1e46:	440b      	add	r3, r1
    1e48:	781b      	ldrb	r3, [r3, #0]
    1e4a:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    1e4c:	9b01      	ldr	r3, [sp, #4]
    1e4e:	685b      	ldr	r3, [r3, #4]
    1e50:	4a0d      	ldr	r2, [pc, #52]	; (1e88 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    1e52:	5cd3      	ldrb	r3, [r2, r3]
    1e54:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    1e56:	4a0d      	ldr	r2, [pc, #52]	; (1e8c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    1e58:	9b05      	ldr	r3, [sp, #20]
    1e5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1e5e:	681b      	ldr	r3, [r3, #0]
    1e60:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    1e62:	9b03      	ldr	r3, [sp, #12]
    1e64:	f023 0307 	bic.w	r3, r3, #7
    1e68:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    1e6a:	9a03      	ldr	r2, [sp, #12]
    1e6c:	9b04      	ldr	r3, [sp, #16]
    1e6e:	4313      	orrs	r3, r2
    1e70:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    1e72:	4a06      	ldr	r2, [pc, #24]	; (1e8c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    1e74:	9b05      	ldr	r3, [sp, #20]
    1e76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1e7a:	9a03      	ldr	r2, [sp, #12]
    1e7c:	601a      	str	r2, [r3, #0]
}
    1e7e:	bf00      	nop
    1e80:	b006      	add	sp, #24
    1e82:	4770      	bx	lr
    1e84:	0000afc0 	.word	0x0000afc0
    1e88:	0000b3b8 	.word	0x0000b3b8
    1e8c:	0000b3fc 	.word	0x0000b3fc

00001e90 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1e90:	b086      	sub	sp, #24
    1e92:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    1e94:	9b01      	ldr	r3, [sp, #4]
    1e96:	681a      	ldr	r2, [r3, #0]
    1e98:	4911      	ldr	r1, [pc, #68]	; (1ee0 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    1e9a:	4613      	mov	r3, r2
    1e9c:	00db      	lsls	r3, r3, #3
    1e9e:	4413      	add	r3, r2
    1ea0:	440b      	add	r3, r1
    1ea2:	781b      	ldrb	r3, [r3, #0]
    1ea4:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    1ea6:	9b01      	ldr	r3, [sp, #4]
    1ea8:	685b      	ldr	r3, [r3, #4]
    1eaa:	4a0e      	ldr	r2, [pc, #56]	; (1ee4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    1eac:	5cd3      	ldrb	r3, [r2, r3]
    1eae:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    1eb0:	4a0d      	ldr	r2, [pc, #52]	; (1ee8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    1eb2:	9b05      	ldr	r3, [sp, #20]
    1eb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1eb8:	681b      	ldr	r3, [r3, #0]
    1eba:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    1ebc:	9b03      	ldr	r3, [sp, #12]
    1ebe:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    1ec2:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    1ec4:	9b04      	ldr	r3, [sp, #16]
    1ec6:	021b      	lsls	r3, r3, #8
    1ec8:	9a03      	ldr	r2, [sp, #12]
    1eca:	4313      	orrs	r3, r2
    1ecc:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    1ece:	4a06      	ldr	r2, [pc, #24]	; (1ee8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    1ed0:	9b05      	ldr	r3, [sp, #20]
    1ed2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1ed6:	9a03      	ldr	r2, [sp, #12]
    1ed8:	601a      	str	r2, [r3, #0]
}
    1eda:	bf00      	nop
    1edc:	b006      	add	sp, #24
    1ede:	4770      	bx	lr
    1ee0:	0000afc0 	.word	0x0000afc0
    1ee4:	0000b3b8 	.word	0x0000b3b8
    1ee8:	0000b3fc 	.word	0x0000b3fc

00001eec <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1eec:	b084      	sub	sp, #16
    1eee:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1ef0:	4b09      	ldr	r3, [pc, #36]	; (1f18 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    1ef2:	695b      	ldr	r3, [r3, #20]
    1ef4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    1ef6:	9b03      	ldr	r3, [sp, #12]
    1ef8:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1efc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    1efe:	9b01      	ldr	r3, [sp, #4]
    1f00:	685b      	ldr	r3, [r3, #4]
    1f02:	3b01      	subs	r3, #1
    1f04:	041b      	lsls	r3, r3, #16
    1f06:	9a03      	ldr	r2, [sp, #12]
    1f08:	4313      	orrs	r3, r2
    1f0a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1f0c:	4a02      	ldr	r2, [pc, #8]	; (1f18 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    1f0e:	9b03      	ldr	r3, [sp, #12]
    1f10:	6153      	str	r3, [r2, #20]
}
    1f12:	bf00      	nop
    1f14:	b004      	add	sp, #16
    1f16:	4770      	bx	lr
    1f18:	40064000 	.word	0x40064000

00001f1c <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f1c:	b084      	sub	sp, #16
    1f1e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1f20:	4b09      	ldr	r3, [pc, #36]	; (1f48 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    1f22:	695b      	ldr	r3, [r3, #20]
    1f24:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    1f26:	9b03      	ldr	r3, [sp, #12]
    1f28:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1f2c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    1f2e:	9b01      	ldr	r3, [sp, #4]
    1f30:	685b      	ldr	r3, [r3, #4]
    1f32:	3b01      	subs	r3, #1
    1f34:	011b      	lsls	r3, r3, #4
    1f36:	9a03      	ldr	r2, [sp, #12]
    1f38:	4313      	orrs	r3, r2
    1f3a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1f3c:	4a02      	ldr	r2, [pc, #8]	; (1f48 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    1f3e:	9b03      	ldr	r3, [sp, #12]
    1f40:	6153      	str	r3, [r2, #20]
}
    1f42:	bf00      	nop
    1f44:	b004      	add	sp, #16
    1f46:	4770      	bx	lr
    1f48:	40064000 	.word	0x40064000

00001f4c <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f4c:	b084      	sub	sp, #16
    1f4e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1f50:	4b09      	ldr	r3, [pc, #36]	; (1f78 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    1f52:	695b      	ldr	r3, [r3, #20]
    1f54:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    1f56:	9b03      	ldr	r3, [sp, #12]
    1f58:	f023 030f 	bic.w	r3, r3, #15
    1f5c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    1f5e:	9b01      	ldr	r3, [sp, #4]
    1f60:	685b      	ldr	r3, [r3, #4]
    1f62:	3b01      	subs	r3, #1
    1f64:	9a03      	ldr	r2, [sp, #12]
    1f66:	4313      	orrs	r3, r2
    1f68:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1f6a:	4a03      	ldr	r2, [pc, #12]	; (1f78 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    1f6c:	9b03      	ldr	r3, [sp, #12]
    1f6e:	6153      	str	r3, [r2, #20]
}
    1f70:	bf00      	nop
    1f72:	b004      	add	sp, #16
    1f74:	4770      	bx	lr
    1f76:	bf00      	nop
    1f78:	40064000 	.word	0x40064000

00001f7c <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f7c:	b084      	sub	sp, #16
    1f7e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1f80:	4b09      	ldr	r3, [pc, #36]	; (1fa8 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    1f82:	699b      	ldr	r3, [r3, #24]
    1f84:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    1f86:	9b03      	ldr	r3, [sp, #12]
    1f88:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1f8c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    1f8e:	9b01      	ldr	r3, [sp, #4]
    1f90:	685b      	ldr	r3, [r3, #4]
    1f92:	3b01      	subs	r3, #1
    1f94:	041b      	lsls	r3, r3, #16
    1f96:	9a03      	ldr	r2, [sp, #12]
    1f98:	4313      	orrs	r3, r2
    1f9a:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1f9c:	4a02      	ldr	r2, [pc, #8]	; (1fa8 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    1f9e:	9b03      	ldr	r3, [sp, #12]
    1fa0:	6193      	str	r3, [r2, #24]
}
    1fa2:	bf00      	nop
    1fa4:	b004      	add	sp, #16
    1fa6:	4770      	bx	lr
    1fa8:	40064000 	.word	0x40064000

00001fac <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1fac:	b084      	sub	sp, #16
    1fae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1fb0:	4b09      	ldr	r3, [pc, #36]	; (1fd8 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    1fb2:	699b      	ldr	r3, [r3, #24]
    1fb4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    1fb6:	9b03      	ldr	r3, [sp, #12]
    1fb8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1fbc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    1fbe:	9b01      	ldr	r3, [sp, #4]
    1fc0:	685b      	ldr	r3, [r3, #4]
    1fc2:	3b01      	subs	r3, #1
    1fc4:	011b      	lsls	r3, r3, #4
    1fc6:	9a03      	ldr	r2, [sp, #12]
    1fc8:	4313      	orrs	r3, r2
    1fca:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1fcc:	4a02      	ldr	r2, [pc, #8]	; (1fd8 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    1fce:	9b03      	ldr	r3, [sp, #12]
    1fd0:	6193      	str	r3, [r2, #24]
}
    1fd2:	bf00      	nop
    1fd4:	b004      	add	sp, #16
    1fd6:	4770      	bx	lr
    1fd8:	40064000 	.word	0x40064000

00001fdc <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1fdc:	b084      	sub	sp, #16
    1fde:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1fe0:	4b09      	ldr	r3, [pc, #36]	; (2008 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    1fe2:	699b      	ldr	r3, [r3, #24]
    1fe4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    1fe6:	9b03      	ldr	r3, [sp, #12]
    1fe8:	f023 030f 	bic.w	r3, r3, #15
    1fec:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    1fee:	9b01      	ldr	r3, [sp, #4]
    1ff0:	685b      	ldr	r3, [r3, #4]
    1ff2:	3b01      	subs	r3, #1
    1ff4:	9a03      	ldr	r2, [sp, #12]
    1ff6:	4313      	orrs	r3, r2
    1ff8:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1ffa:	4a03      	ldr	r2, [pc, #12]	; (2008 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    1ffc:	9b03      	ldr	r3, [sp, #12]
    1ffe:	6193      	str	r3, [r2, #24]
}
    2000:	bf00      	nop
    2002:	b004      	add	sp, #16
    2004:	4770      	bx	lr
    2006:	bf00      	nop
    2008:	40064000 	.word	0x40064000

0000200c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    200c:	b084      	sub	sp, #16
    200e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2010:	4b09      	ldr	r3, [pc, #36]	; (2038 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    2012:	69db      	ldr	r3, [r3, #28]
    2014:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    2016:	9b03      	ldr	r3, [sp, #12]
    2018:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    201c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    201e:	9b01      	ldr	r3, [sp, #4]
    2020:	685b      	ldr	r3, [r3, #4]
    2022:	3b01      	subs	r3, #1
    2024:	041b      	lsls	r3, r3, #16
    2026:	9a03      	ldr	r2, [sp, #12]
    2028:	4313      	orrs	r3, r2
    202a:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    202c:	4a02      	ldr	r2, [pc, #8]	; (2038 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    202e:	9b03      	ldr	r3, [sp, #12]
    2030:	61d3      	str	r3, [r2, #28]
}
    2032:	bf00      	nop
    2034:	b004      	add	sp, #16
    2036:	4770      	bx	lr
    2038:	40064000 	.word	0x40064000

0000203c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    203c:	b084      	sub	sp, #16
    203e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2040:	4b09      	ldr	r3, [pc, #36]	; (2068 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    2042:	69db      	ldr	r3, [r3, #28]
    2044:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    2046:	9b03      	ldr	r3, [sp, #12]
    2048:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    204c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    204e:	9b01      	ldr	r3, [sp, #4]
    2050:	685b      	ldr	r3, [r3, #4]
    2052:	3b01      	subs	r3, #1
    2054:	011b      	lsls	r3, r3, #4
    2056:	9a03      	ldr	r2, [sp, #12]
    2058:	4313      	orrs	r3, r2
    205a:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    205c:	4a02      	ldr	r2, [pc, #8]	; (2068 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    205e:	9b03      	ldr	r3, [sp, #12]
    2060:	61d3      	str	r3, [r2, #28]
}
    2062:	bf00      	nop
    2064:	b004      	add	sp, #16
    2066:	4770      	bx	lr
    2068:	40064000 	.word	0x40064000

0000206c <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    206c:	b084      	sub	sp, #16
    206e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    2070:	4b09      	ldr	r3, [pc, #36]	; (2098 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    2072:	69db      	ldr	r3, [r3, #28]
    2074:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    2076:	9b03      	ldr	r3, [sp, #12]
    2078:	f023 030f 	bic.w	r3, r3, #15
    207c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    207e:	9b01      	ldr	r3, [sp, #4]
    2080:	685b      	ldr	r3, [r3, #4]
    2082:	3b01      	subs	r3, #1
    2084:	9a03      	ldr	r2, [sp, #12]
    2086:	4313      	orrs	r3, r2
    2088:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    208a:	4a03      	ldr	r2, [pc, #12]	; (2098 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    208c:	9b03      	ldr	r3, [sp, #12]
    208e:	61d3      	str	r3, [r2, #28]
}
    2090:	bf00      	nop
    2092:	b004      	add	sp, #16
    2094:	4770      	bx	lr
    2096:	bf00      	nop
    2098:	40064000 	.word	0x40064000

0000209c <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    209c:	b084      	sub	sp, #16
    209e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    20a0:	4b0a      	ldr	r3, [pc, #40]	; (20cc <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    20a2:	685b      	ldr	r3, [r3, #4]
    20a4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    20a6:	9b03      	ldr	r3, [sp, #12]
    20a8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    20ac:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    20ae:	9b01      	ldr	r3, [sp, #4]
    20b0:	685b      	ldr	r3, [r3, #4]
    20b2:	3b01      	subs	r3, #1
    20b4:	021b      	lsls	r3, r3, #8
    20b6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    20ba:	9a03      	ldr	r2, [sp, #12]
    20bc:	4313      	orrs	r3, r2
    20be:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    20c0:	4a02      	ldr	r2, [pc, #8]	; (20cc <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    20c2:	9b03      	ldr	r3, [sp, #12]
    20c4:	6053      	str	r3, [r2, #4]
}
    20c6:	bf00      	nop
    20c8:	b004      	add	sp, #16
    20ca:	4770      	bx	lr
    20cc:	40048000 	.word	0x40048000

000020d0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    20d0:	b084      	sub	sp, #16
    20d2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    20d4:	4919      	ldr	r1, [pc, #100]	; (213c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    20d6:	9b01      	ldr	r3, [sp, #4]
    20d8:	681a      	ldr	r2, [r3, #0]
    20da:	4819      	ldr	r0, [pc, #100]	; (2140 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    20dc:	4613      	mov	r3, r2
    20de:	00db      	lsls	r3, r3, #3
    20e0:	4413      	add	r3, r2
    20e2:	4403      	add	r3, r0
    20e4:	3305      	adds	r3, #5
    20e6:	781b      	ldrb	r3, [r3, #0]
    20e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    20ec:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    20ee:	9b03      	ldr	r3, [sp, #12]
    20f0:	f023 030f 	bic.w	r3, r3, #15
    20f4:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    20f6:	9b01      	ldr	r3, [sp, #4]
    20f8:	685b      	ldr	r3, [r3, #4]
    20fa:	3b01      	subs	r3, #1
    20fc:	f003 0307 	and.w	r3, r3, #7
    2100:	9a03      	ldr	r2, [sp, #12]
    2102:	4313      	orrs	r3, r2
    2104:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    2106:	9b01      	ldr	r3, [sp, #4]
    2108:	7a1b      	ldrb	r3, [r3, #8]
    210a:	3b01      	subs	r3, #1
    210c:	00db      	lsls	r3, r3, #3
    210e:	f003 0308 	and.w	r3, r3, #8
    2112:	9a03      	ldr	r2, [sp, #12]
    2114:	4313      	orrs	r3, r2
    2116:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    2118:	4908      	ldr	r1, [pc, #32]	; (213c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    211a:	9b01      	ldr	r3, [sp, #4]
    211c:	681a      	ldr	r2, [r3, #0]
    211e:	4808      	ldr	r0, [pc, #32]	; (2140 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2120:	4613      	mov	r3, r2
    2122:	00db      	lsls	r3, r3, #3
    2124:	4413      	add	r3, r2
    2126:	4403      	add	r3, r0
    2128:	3305      	adds	r3, #5
    212a:	781b      	ldrb	r3, [r3, #0]
    212c:	461a      	mov	r2, r3
    212e:	9b03      	ldr	r3, [sp, #12]
    2130:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    2134:	bf00      	nop
    2136:	b004      	add	sp, #16
    2138:	4770      	bx	lr
    213a:	bf00      	nop
    213c:	40065000 	.word	0x40065000
    2140:	0000afc0 	.word	0x0000afc0

00002144 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2144:	b084      	sub	sp, #16
    2146:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    2148:	4b10      	ldr	r3, [pc, #64]	; (218c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    214a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    214c:	4a0f      	ldr	r2, [pc, #60]	; (218c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    214e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2152:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    2154:	4b0d      	ldr	r3, [pc, #52]	; (218c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2156:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2158:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    215a:	9b03      	ldr	r3, [sp, #12]
    215c:	f023 030f 	bic.w	r3, r3, #15
    2160:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    2162:	9b01      	ldr	r3, [sp, #4]
    2164:	685b      	ldr	r3, [r3, #4]
    2166:	3b01      	subs	r3, #1
    2168:	005b      	lsls	r3, r3, #1
    216a:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    216e:	9b01      	ldr	r3, [sp, #4]
    2170:	7a1b      	ldrb	r3, [r3, #8]
    2172:	3b01      	subs	r3, #1
    2174:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    2178:	4313      	orrs	r3, r2
    217a:	9a03      	ldr	r2, [sp, #12]
    217c:	4313      	orrs	r3, r2
    217e:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    2180:	4a02      	ldr	r2, [pc, #8]	; (218c <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2182:	9b03      	ldr	r3, [sp, #12]
    2184:	6693      	str	r3, [r2, #104]	; 0x68
}
    2186:	bf00      	nop
    2188:	b004      	add	sp, #16
    218a:	4770      	bx	lr
    218c:	40048000 	.word	0x40048000

00002190 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    2190:	b082      	sub	sp, #8
    2192:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2194:	bf00      	nop
    2196:	b002      	add	sp, #8
    2198:	4770      	bx	lr
	...

0000219c <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    219c:	b082      	sub	sp, #8
    219e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    21a0:	bf00      	nop
    21a2:	b002      	add	sp, #8
    21a4:	4770      	bx	lr

000021a6 <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    21a6:	b082      	sub	sp, #8
    21a8:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    21aa:	bf00      	nop
    21ac:	b002      	add	sp, #8
    21ae:	4770      	bx	lr

000021b0 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    21b0:	b500      	push	{lr}
    21b2:	b083      	sub	sp, #12
    21b4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21b6:	9b01      	ldr	r3, [sp, #4]
    21b8:	2b00      	cmp	r3, #0
    21ba:	d002      	beq.n	21c2 <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    21bc:	9801      	ldr	r0, [sp, #4]
    21be:	f000 f86a 	bl	2296 <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    21c2:	bf00      	nop
    21c4:	b003      	add	sp, #12
    21c6:	f85d fb04 	ldr.w	pc, [sp], #4

000021ca <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    21ca:	b500      	push	{lr}
    21cc:	b083      	sub	sp, #12
    21ce:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    21d0:	9b01      	ldr	r3, [sp, #4]
    21d2:	2b00      	cmp	r3, #0
    21d4:	d002      	beq.n	21dc <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    21d6:	9801      	ldr	r0, [sp, #4]
    21d8:	f000 f884 	bl	22e4 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    21dc:	bf00      	nop
    21de:	b003      	add	sp, #12
    21e0:	f85d fb04 	ldr.w	pc, [sp], #4

000021e4 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    21e4:	b500      	push	{lr}
    21e6:	b089      	sub	sp, #36	; 0x24
    21e8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    21ea:	2300      	movs	r3, #0
    21ec:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    21f0:	9b01      	ldr	r3, [sp, #4]
    21f2:	2b00      	cmp	r3, #0
    21f4:	d031      	beq.n	225a <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    21f6:	4b1b      	ldr	r3, [pc, #108]	; (2264 <Clock_Ip_CompleteSOSC+0x80>)
    21f8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    21fc:	f003 0301 	and.w	r3, r3, #1
    2200:	2b00      	cmp	r3, #0
    2202:	d02a      	beq.n	225a <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2204:	aa03      	add	r2, sp, #12
    2206:	a904      	add	r1, sp, #16
    2208:	a805      	add	r0, sp, #20
    220a:	f24c 3350 	movw	r3, #50000	; 0xc350
    220e:	f7ff fd1d 	bl	1c4c <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    2212:	4b14      	ldr	r3, [pc, #80]	; (2264 <Clock_Ip_CompleteSOSC+0x80>)
    2214:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2218:	0e1b      	lsrs	r3, r3, #24
    221a:	f003 0301 	and.w	r3, r3, #1
    221e:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2220:	9a03      	ldr	r2, [sp, #12]
    2222:	a904      	add	r1, sp, #16
    2224:	ab05      	add	r3, sp, #20
    2226:	4618      	mov	r0, r3
    2228:	f7ff fd2a 	bl	1c80 <Clock_Ip_TimeoutExpired>
    222c:	4603      	mov	r3, r0
    222e:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    2232:	9b06      	ldr	r3, [sp, #24]
    2234:	2b00      	cmp	r3, #0
    2236:	d106      	bne.n	2246 <Clock_Ip_CompleteSOSC+0x62>
    2238:	f89d 301f 	ldrb.w	r3, [sp, #31]
    223c:	f083 0301 	eor.w	r3, r3, #1
    2240:	b2db      	uxtb	r3, r3
    2242:	2b00      	cmp	r3, #0
    2244:	d1e5      	bne.n	2212 <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    2246:	f89d 301f 	ldrb.w	r3, [sp, #31]
    224a:	2b00      	cmp	r3, #0
    224c:	d005      	beq.n	225a <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    224e:	9b01      	ldr	r3, [sp, #4]
    2250:	681b      	ldr	r3, [r3, #0]
    2252:	4619      	mov	r1, r3
    2254:	2001      	movs	r0, #1
    2256:	f7ff fce9 	bl	1c2c <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    225a:	bf00      	nop
    225c:	b009      	add	sp, #36	; 0x24
    225e:	f85d fb04 	ldr.w	pc, [sp], #4
    2262:	bf00      	nop
    2264:	40064000 	.word	0x40064000

00002268 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    2268:	b500      	push	{lr}
    226a:	b083      	sub	sp, #12
    226c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    226e:	9801      	ldr	r0, [sp, #4]
    2270:	f000 f8c0 	bl	23f4 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2274:	bf00      	nop
    2276:	b003      	add	sp, #12
    2278:	f85d fb04 	ldr.w	pc, [sp], #4

0000227c <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    227c:	b500      	push	{lr}
    227e:	b083      	sub	sp, #12
    2280:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2282:	9b01      	ldr	r3, [sp, #4]
    2284:	2b00      	cmp	r3, #0
    2286:	d002      	beq.n	228e <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    2288:	9801      	ldr	r0, [sp, #4]
    228a:	f000 f8c3 	bl	2414 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    228e:	bf00      	nop
    2290:	b003      	add	sp, #12
    2292:	f85d fb04 	ldr.w	pc, [sp], #4

00002296 <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    2296:	b082      	sub	sp, #8
    2298:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    229a:	4b11      	ldr	r3, [pc, #68]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    229c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22a0:	4a0f      	ldr	r2, [pc, #60]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22a2:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    22a6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    22aa:	4b0d      	ldr	r3, [pc, #52]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22ac:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22b0:	4a0b      	ldr	r2, [pc, #44]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22b2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    22b6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    22ba:	4b09      	ldr	r3, [pc, #36]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22bc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22c0:	4a07      	ldr	r2, [pc, #28]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22c2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    22c6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    22ca:	4b05      	ldr	r3, [pc, #20]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22cc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22d0:	4a03      	ldr	r2, [pc, #12]	; (22e0 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    22d2:	f023 0301 	bic.w	r3, r3, #1
    22d6:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    22da:	bf00      	nop
    22dc:	b002      	add	sp, #8
    22de:	4770      	bx	lr
    22e0:	40064000 	.word	0x40064000

000022e4 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    22e4:	b082      	sub	sp, #8
    22e6:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    22e8:	9b01      	ldr	r3, [sp, #4]
    22ea:	891b      	ldrh	r3, [r3, #8]
    22ec:	2b01      	cmp	r3, #1
    22ee:	d174      	bne.n	23da <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    22f0:	9b01      	ldr	r3, [sp, #4]
    22f2:	7bdb      	ldrb	r3, [r3, #15]
    22f4:	2b00      	cmp	r3, #0
    22f6:	d002      	beq.n	22fe <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    22f8:	2b01      	cmp	r3, #1
    22fa:	d009      	beq.n	2310 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    22fc:	e011      	b.n	2322 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    22fe:	4b39      	ldr	r3, [pc, #228]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2300:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2304:	4a37      	ldr	r2, [pc, #220]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2306:	f023 0308 	bic.w	r3, r3, #8
    230a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    230e:	e008      	b.n	2322 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    2310:	4b34      	ldr	r3, [pc, #208]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2312:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2316:	4a33      	ldr	r2, [pc, #204]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2318:	f043 0308 	orr.w	r3, r3, #8
    231c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2320:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    2322:	4b30      	ldr	r3, [pc, #192]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2324:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2328:	4a2e      	ldr	r2, [pc, #184]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    232a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    232e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    2332:	9b01      	ldr	r3, [sp, #4]
    2334:	685b      	ldr	r3, [r3, #4]
    2336:	4a2c      	ldr	r2, [pc, #176]	; (23e8 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    2338:	4293      	cmp	r3, r2
    233a:	d90d      	bls.n	2358 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    233c:	9b01      	ldr	r3, [sp, #4]
    233e:	685b      	ldr	r3, [r3, #4]
    2340:	4a2a      	ldr	r2, [pc, #168]	; (23ec <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    2342:	4293      	cmp	r3, r2
    2344:	d208      	bcs.n	2358 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    2346:	4b27      	ldr	r3, [pc, #156]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2348:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    234c:	4a25      	ldr	r2, [pc, #148]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    234e:	f043 0320 	orr.w	r3, r3, #32
    2352:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    2356:	e007      	b.n	2368 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    2358:	4b22      	ldr	r3, [pc, #136]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    235a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    235e:	4a21      	ldr	r2, [pc, #132]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2360:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    2364:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    2368:	9b01      	ldr	r3, [sp, #4]
    236a:	7b1b      	ldrb	r3, [r3, #12]
    236c:	2b00      	cmp	r3, #0
    236e:	d108      	bne.n	2382 <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    2370:	4b1c      	ldr	r3, [pc, #112]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2372:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2376:	4a1b      	ldr	r2, [pc, #108]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2378:	f043 0304 	orr.w	r3, r3, #4
    237c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    2380:	e007      	b.n	2392 <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    2382:	4b18      	ldr	r3, [pc, #96]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2384:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2388:	4a16      	ldr	r2, [pc, #88]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    238a:	f023 0304 	bic.w	r3, r3, #4
    238e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    2392:	9b01      	ldr	r3, [sp, #4]
    2394:	7c1b      	ldrb	r3, [r3, #16]
    2396:	2b02      	cmp	r3, #2
    2398:	d011      	beq.n	23be <Clock_Ip_SetSOSC_TrustedCall+0xda>
    239a:	2b02      	cmp	r3, #2
    239c:	dc14      	bgt.n	23c8 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    239e:	2b00      	cmp	r3, #0
    23a0:	d002      	beq.n	23a8 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    23a2:	2b01      	cmp	r3, #1
    23a4:	d005      	beq.n	23b2 <Clock_Ip_SetSOSC_TrustedCall+0xce>
    23a6:	e00f      	b.n	23c8 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    23a8:	4b0e      	ldr	r3, [pc, #56]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    23aa:	2201      	movs	r2, #1
    23ac:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    23b0:	e014      	b.n	23dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    23b2:	4b0c      	ldr	r3, [pc, #48]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    23b4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    23b8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    23bc:	e00e      	b.n	23dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    23be:	4b09      	ldr	r3, [pc, #36]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    23c0:	4a0b      	ldr	r2, [pc, #44]	; (23f0 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    23c2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    23c6:	e009      	b.n	23dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    23c8:	4b06      	ldr	r3, [pc, #24]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    23ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    23ce:	4a05      	ldr	r2, [pc, #20]	; (23e4 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    23d0:	f043 0301 	orr.w	r3, r3, #1
    23d4:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    23d8:	e000      	b.n	23dc <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    23da:	bf00      	nop
}
    23dc:	bf00      	nop
    23de:	b002      	add	sp, #8
    23e0:	4770      	bx	lr
    23e2:	bf00      	nop
    23e4:	40064000 	.word	0x40064000
    23e8:	003d08ff 	.word	0x003d08ff
    23ec:	007a1200 	.word	0x007a1200
    23f0:	00030001 	.word	0x00030001

000023f4 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    23f4:	b082      	sub	sp, #8
    23f6:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    23f8:	4b05      	ldr	r3, [pc, #20]	; (2410 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    23fa:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    23fe:	4a04      	ldr	r2, [pc, #16]	; (2410 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2400:	f023 0301 	bic.w	r3, r3, #1
    2404:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2408:	bf00      	nop
    240a:	b002      	add	sp, #8
    240c:	4770      	bx	lr
    240e:	bf00      	nop
    2410:	40064000 	.word	0x40064000

00002414 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    2414:	b082      	sub	sp, #8
    2416:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2418:	9b01      	ldr	r3, [sp, #4]
    241a:	891b      	ldrh	r3, [r3, #8]
    241c:	2b01      	cmp	r3, #1
    241e:	d107      	bne.n	2430 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2420:	4b05      	ldr	r3, [pc, #20]	; (2438 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2422:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2426:	4a04      	ldr	r2, [pc, #16]	; (2438 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2428:	f043 0301 	orr.w	r3, r3, #1
    242c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    2430:	bf00      	nop
    2432:	b002      	add	sp, #8
    2434:	4770      	bx	lr
    2436:	bf00      	nop
    2438:	40064000 	.word	0x40064000

0000243c <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    243c:	b082      	sub	sp, #8
    243e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2440:	bf00      	nop
    2442:	b002      	add	sp, #8
    2444:	4770      	bx	lr

00002446 <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    2446:	b082      	sub	sp, #8
    2448:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    244a:	2300      	movs	r3, #0
}
    244c:	4618      	mov	r0, r3
    244e:	b002      	add	sp, #8
    2450:	4770      	bx	lr

00002452 <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    2452:	b082      	sub	sp, #8
    2454:	9001      	str	r0, [sp, #4]
    2456:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    2458:	bf00      	nop
    245a:	b002      	add	sp, #8
    245c:	4770      	bx	lr
	...

00002460 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    2460:	b082      	sub	sp, #8
    2462:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2464:	bf00      	nop
    2466:	b002      	add	sp, #8
    2468:	4770      	bx	lr

0000246a <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    246a:	b082      	sub	sp, #8
    246c:	9001      	str	r0, [sp, #4]
    246e:	460b      	mov	r3, r1
    2470:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    2474:	bf00      	nop
    2476:	b002      	add	sp, #8
    2478:	4770      	bx	lr

0000247a <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    247a:	b500      	push	{lr}
    247c:	b083      	sub	sp, #12
    247e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2480:	9b01      	ldr	r3, [sp, #4]
    2482:	2b00      	cmp	r3, #0
    2484:	d002      	beq.n	248c <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    2486:	9801      	ldr	r0, [sp, #4]
    2488:	f000 f8e7 	bl	265a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    248c:	bf00      	nop
    248e:	b003      	add	sp, #12
    2490:	f85d fb04 	ldr.w	pc, [sp], #4

00002494 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2494:	b500      	push	{lr}
    2496:	b085      	sub	sp, #20
    2498:	9001      	str	r0, [sp, #4]
    249a:	460b      	mov	r3, r1
    249c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    24a0:	9b01      	ldr	r3, [sp, #4]
    24a2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    24a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    24a8:	2b00      	cmp	r3, #0
    24aa:	d003      	beq.n	24b4 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    24ac:	2300      	movs	r3, #0
    24ae:	f8ad 300c 	strh.w	r3, [sp, #12]
    24b2:	e002      	b.n	24ba <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    24b4:	2301      	movs	r3, #1
    24b6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    24ba:	ab02      	add	r3, sp, #8
    24bc:	4618      	mov	r0, r3
    24be:	f7ff ffdc 	bl	247a <Clock_Ip_ClockSetSimLPO1KEnable>
}
    24c2:	bf00      	nop
    24c4:	b005      	add	sp, #20
    24c6:	f85d fb04 	ldr.w	pc, [sp], #4

000024ca <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    24ca:	b500      	push	{lr}
    24cc:	b083      	sub	sp, #12
    24ce:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    24d0:	9b01      	ldr	r3, [sp, #4]
    24d2:	2b00      	cmp	r3, #0
    24d4:	d002      	beq.n	24dc <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    24d6:	9801      	ldr	r0, [sp, #4]
    24d8:	f000 f8d6 	bl	2688 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    24dc:	bf00      	nop
    24de:	b003      	add	sp, #12
    24e0:	f85d fb04 	ldr.w	pc, [sp], #4

000024e4 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    24e4:	b500      	push	{lr}
    24e6:	b085      	sub	sp, #20
    24e8:	9001      	str	r0, [sp, #4]
    24ea:	460b      	mov	r3, r1
    24ec:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    24f0:	9b01      	ldr	r3, [sp, #4]
    24f2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    24f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    24f8:	2b00      	cmp	r3, #0
    24fa:	d003      	beq.n	2504 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    24fc:	2300      	movs	r3, #0
    24fe:	f8ad 300c 	strh.w	r3, [sp, #12]
    2502:	e002      	b.n	250a <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2504:	2301      	movs	r3, #1
    2506:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    250a:	ab02      	add	r3, sp, #8
    250c:	4618      	mov	r0, r3
    250e:	f7ff ffdc 	bl	24ca <Clock_Ip_ClockSetSimLPO32KEnable>
}
    2512:	bf00      	nop
    2514:	b005      	add	sp, #20
    2516:	f85d fb04 	ldr.w	pc, [sp], #4

0000251a <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    251a:	b500      	push	{lr}
    251c:	b083      	sub	sp, #12
    251e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2520:	9b01      	ldr	r3, [sp, #4]
    2522:	2b00      	cmp	r3, #0
    2524:	d002      	beq.n	252c <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    2526:	9801      	ldr	r0, [sp, #4]
    2528:	f000 f8c6 	bl	26b8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    252c:	bf00      	nop
    252e:	b003      	add	sp, #12
    2530:	f85d fb04 	ldr.w	pc, [sp], #4

00002534 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2534:	b500      	push	{lr}
    2536:	b085      	sub	sp, #20
    2538:	9001      	str	r0, [sp, #4]
    253a:	460b      	mov	r3, r1
    253c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2540:	9b01      	ldr	r3, [sp, #4]
    2542:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2544:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2548:	2b00      	cmp	r3, #0
    254a:	d003      	beq.n	2554 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    254c:	2300      	movs	r3, #0
    254e:	f8ad 300c 	strh.w	r3, [sp, #12]
    2552:	e002      	b.n	255a <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2554:	2301      	movs	r3, #1
    2556:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    255a:	ab02      	add	r3, sp, #8
    255c:	4618      	mov	r0, r3
    255e:	f7ff ffdc 	bl	251a <Clock_Ip_ClockSetSimClkoutEnable>
}
    2562:	bf00      	nop
    2564:	b005      	add	sp, #20
    2566:	f85d fb04 	ldr.w	pc, [sp], #4

0000256a <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    256a:	b500      	push	{lr}
    256c:	b083      	sub	sp, #12
    256e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2570:	9b01      	ldr	r3, [sp, #4]
    2572:	2b00      	cmp	r3, #0
    2574:	d002      	beq.n	257c <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    2576:	9801      	ldr	r0, [sp, #4]
    2578:	f000 f8b6 	bl	26e8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    257c:	bf00      	nop
    257e:	b003      	add	sp, #12
    2580:	f85d fb04 	ldr.w	pc, [sp], #4

00002584 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2584:	b500      	push	{lr}
    2586:	b085      	sub	sp, #20
    2588:	9001      	str	r0, [sp, #4]
    258a:	460b      	mov	r3, r1
    258c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2590:	9b01      	ldr	r3, [sp, #4]
    2592:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2594:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2598:	2b00      	cmp	r3, #0
    259a:	d003      	beq.n	25a4 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    259c:	2300      	movs	r3, #0
    259e:	f8ad 300c 	strh.w	r3, [sp, #12]
    25a2:	e002      	b.n	25aa <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    25a4:	2301      	movs	r3, #1
    25a6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    25aa:	ab02      	add	r3, sp, #8
    25ac:	4618      	mov	r0, r3
    25ae:	f7ff ffdc 	bl	256a <Clock_Ip_ClockSetPccCgcEnable>
}
    25b2:	bf00      	nop
    25b4:	b005      	add	sp, #20
    25b6:	f85d fb04 	ldr.w	pc, [sp], #4

000025ba <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    25ba:	b500      	push	{lr}
    25bc:	b083      	sub	sp, #12
    25be:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    25c0:	9b01      	ldr	r3, [sp, #4]
    25c2:	2b00      	cmp	r3, #0
    25c4:	d002      	beq.n	25cc <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    25c6:	9801      	ldr	r0, [sp, #4]
    25c8:	f000 f8bc 	bl	2744 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    25cc:	bf00      	nop
    25ce:	b003      	add	sp, #12
    25d0:	f85d fb04 	ldr.w	pc, [sp], #4

000025d4 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    25d4:	b500      	push	{lr}
    25d6:	b085      	sub	sp, #20
    25d8:	9001      	str	r0, [sp, #4]
    25da:	460b      	mov	r3, r1
    25dc:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    25e0:	9b01      	ldr	r3, [sp, #4]
    25e2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    25e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    25e8:	2b00      	cmp	r3, #0
    25ea:	d003      	beq.n	25f4 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    25ec:	2300      	movs	r3, #0
    25ee:	f8ad 300c 	strh.w	r3, [sp, #12]
    25f2:	e002      	b.n	25fa <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    25f4:	2301      	movs	r3, #1
    25f6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    25fa:	ab02      	add	r3, sp, #8
    25fc:	4618      	mov	r0, r3
    25fe:	f7ff ffdc 	bl	25ba <Clock_Ip_ClockSetSimGate>
}
    2602:	bf00      	nop
    2604:	b005      	add	sp, #20
    2606:	f85d fb04 	ldr.w	pc, [sp], #4

0000260a <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    260a:	b500      	push	{lr}
    260c:	b083      	sub	sp, #12
    260e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2610:	9b01      	ldr	r3, [sp, #4]
    2612:	2b00      	cmp	r3, #0
    2614:	d002      	beq.n	261c <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    2616:	9801      	ldr	r0, [sp, #4]
    2618:	f000 f8c0 	bl	279c <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    261c:	bf00      	nop
    261e:	b003      	add	sp, #12
    2620:	f85d fb04 	ldr.w	pc, [sp], #4

00002624 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2624:	b500      	push	{lr}
    2626:	b085      	sub	sp, #20
    2628:	9001      	str	r0, [sp, #4]
    262a:	460b      	mov	r3, r1
    262c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2630:	9b01      	ldr	r3, [sp, #4]
    2632:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2634:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2638:	2b00      	cmp	r3, #0
    263a:	d003      	beq.n	2644 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    263c:	2300      	movs	r3, #0
    263e:	f8ad 300c 	strh.w	r3, [sp, #12]
    2642:	e002      	b.n	264a <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2644:	2301      	movs	r3, #1
    2646:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    264a:	ab02      	add	r3, sp, #8
    264c:	4618      	mov	r0, r3
    264e:	f7ff ffdc 	bl	260a <Clock_Ip_ClockSetSimTraceEnable>
}
    2652:	bf00      	nop
    2654:	b005      	add	sp, #20
    2656:	f85d fb04 	ldr.w	pc, [sp], #4

0000265a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    265a:	b084      	sub	sp, #16
    265c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    265e:	4b09      	ldr	r3, [pc, #36]	; (2684 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2660:	691b      	ldr	r3, [r3, #16]
    2662:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    2664:	9b03      	ldr	r3, [sp, #12]
    2666:	f023 0301 	bic.w	r3, r3, #1
    266a:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    266c:	9b01      	ldr	r3, [sp, #4]
    266e:	889b      	ldrh	r3, [r3, #4]
    2670:	461a      	mov	r2, r3
    2672:	9b03      	ldr	r3, [sp, #12]
    2674:	4313      	orrs	r3, r2
    2676:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    2678:	4a02      	ldr	r2, [pc, #8]	; (2684 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    267a:	9b03      	ldr	r3, [sp, #12]
    267c:	6113      	str	r3, [r2, #16]
}
    267e:	bf00      	nop
    2680:	b004      	add	sp, #16
    2682:	4770      	bx	lr
    2684:	40048000 	.word	0x40048000

00002688 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2688:	b084      	sub	sp, #16
    268a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    268c:	4b09      	ldr	r3, [pc, #36]	; (26b4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    268e:	691b      	ldr	r3, [r3, #16]
    2690:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    2692:	9b03      	ldr	r3, [sp, #12]
    2694:	f023 0302 	bic.w	r3, r3, #2
    2698:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    269a:	9b01      	ldr	r3, [sp, #4]
    269c:	889b      	ldrh	r3, [r3, #4]
    269e:	005b      	lsls	r3, r3, #1
    26a0:	9a03      	ldr	r2, [sp, #12]
    26a2:	4313      	orrs	r3, r2
    26a4:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    26a6:	4a03      	ldr	r2, [pc, #12]	; (26b4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    26a8:	9b03      	ldr	r3, [sp, #12]
    26aa:	6113      	str	r3, [r2, #16]
}
    26ac:	bf00      	nop
    26ae:	b004      	add	sp, #16
    26b0:	4770      	bx	lr
    26b2:	bf00      	nop
    26b4:	40048000 	.word	0x40048000

000026b8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    26b8:	b084      	sub	sp, #16
    26ba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    26bc:	4b09      	ldr	r3, [pc, #36]	; (26e4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    26be:	685b      	ldr	r3, [r3, #4]
    26c0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    26c2:	9b03      	ldr	r3, [sp, #12]
    26c4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    26c8:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    26ca:	9b01      	ldr	r3, [sp, #4]
    26cc:	889b      	ldrh	r3, [r3, #4]
    26ce:	02db      	lsls	r3, r3, #11
    26d0:	9a03      	ldr	r2, [sp, #12]
    26d2:	4313      	orrs	r3, r2
    26d4:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    26d6:	4a03      	ldr	r2, [pc, #12]	; (26e4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    26d8:	9b03      	ldr	r3, [sp, #12]
    26da:	6053      	str	r3, [r2, #4]
}
    26dc:	bf00      	nop
    26de:	b004      	add	sp, #16
    26e0:	4770      	bx	lr
    26e2:	bf00      	nop
    26e4:	40048000 	.word	0x40048000

000026e8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    26e8:	b084      	sub	sp, #16
    26ea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    26ec:	4913      	ldr	r1, [pc, #76]	; (273c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    26ee:	9b01      	ldr	r3, [sp, #4]
    26f0:	681a      	ldr	r2, [r3, #0]
    26f2:	4813      	ldr	r0, [pc, #76]	; (2740 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    26f4:	4613      	mov	r3, r2
    26f6:	00db      	lsls	r3, r3, #3
    26f8:	4413      	add	r3, r2
    26fa:	4403      	add	r3, r0
    26fc:	3306      	adds	r3, #6
    26fe:	781b      	ldrb	r3, [r3, #0]
    2700:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    2704:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    2706:	9b03      	ldr	r3, [sp, #12]
    2708:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    270c:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    270e:	9b01      	ldr	r3, [sp, #4]
    2710:	889b      	ldrh	r3, [r3, #4]
    2712:	079b      	lsls	r3, r3, #30
    2714:	9a03      	ldr	r2, [sp, #12]
    2716:	4313      	orrs	r3, r2
    2718:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    271a:	4908      	ldr	r1, [pc, #32]	; (273c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    271c:	9b01      	ldr	r3, [sp, #4]
    271e:	681a      	ldr	r2, [r3, #0]
    2720:	4807      	ldr	r0, [pc, #28]	; (2740 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2722:	4613      	mov	r3, r2
    2724:	00db      	lsls	r3, r3, #3
    2726:	4413      	add	r3, r2
    2728:	4403      	add	r3, r0
    272a:	3306      	adds	r3, #6
    272c:	781b      	ldrb	r3, [r3, #0]
    272e:	461a      	mov	r2, r3
    2730:	9b03      	ldr	r3, [sp, #12]
    2732:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    2736:	bf00      	nop
    2738:	b004      	add	sp, #16
    273a:	4770      	bx	lr
    273c:	40065000 	.word	0x40065000
    2740:	0000afc0 	.word	0x0000afc0

00002744 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2744:	b086      	sub	sp, #24
    2746:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    2748:	9b01      	ldr	r3, [sp, #4]
    274a:	889b      	ldrh	r3, [r3, #4]
    274c:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    274e:	9b01      	ldr	r3, [sp, #4]
    2750:	681a      	ldr	r2, [r3, #0]
    2752:	4910      	ldr	r1, [pc, #64]	; (2794 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    2754:	4613      	mov	r3, r2
    2756:	00db      	lsls	r3, r3, #3
    2758:	4413      	add	r3, r2
    275a:	440b      	add	r3, r1
    275c:	3306      	adds	r3, #6
    275e:	781b      	ldrb	r3, [r3, #0]
    2760:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    2762:	4b0d      	ldr	r3, [pc, #52]	; (2798 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2764:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2766:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    2768:	2201      	movs	r2, #1
    276a:	9b04      	ldr	r3, [sp, #16]
    276c:	fa02 f303 	lsl.w	r3, r2, r3
    2770:	43db      	mvns	r3, r3
    2772:	9a03      	ldr	r2, [sp, #12]
    2774:	4013      	ands	r3, r2
    2776:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    2778:	9a05      	ldr	r2, [sp, #20]
    277a:	9b04      	ldr	r3, [sp, #16]
    277c:	fa02 f303 	lsl.w	r3, r2, r3
    2780:	9a03      	ldr	r2, [sp, #12]
    2782:	4313      	orrs	r3, r2
    2784:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    2786:	4a04      	ldr	r2, [pc, #16]	; (2798 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2788:	9b03      	ldr	r3, [sp, #12]
    278a:	6413      	str	r3, [r2, #64]	; 0x40
}
    278c:	bf00      	nop
    278e:	b006      	add	sp, #24
    2790:	4770      	bx	lr
    2792:	bf00      	nop
    2794:	0000afc0 	.word	0x0000afc0
    2798:	40048000 	.word	0x40048000

0000279c <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    279c:	b084      	sub	sp, #16
    279e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    27a0:	4b0a      	ldr	r3, [pc, #40]	; (27cc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    27a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    27a4:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    27a6:	9b01      	ldr	r3, [sp, #4]
    27a8:	889b      	ldrh	r3, [r3, #4]
    27aa:	2b01      	cmp	r3, #1
    27ac:	d104      	bne.n	27b8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    27ae:	9b03      	ldr	r3, [sp, #12]
    27b0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    27b4:	9303      	str	r3, [sp, #12]
    27b6:	e003      	b.n	27c0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    27b8:	9b03      	ldr	r3, [sp, #12]
    27ba:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    27be:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    27c0:	4a02      	ldr	r2, [pc, #8]	; (27cc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    27c2:	9b03      	ldr	r3, [sp, #12]
    27c4:	6693      	str	r3, [r2, #104]	; 0x68
}
    27c6:	bf00      	nop
    27c8:	b004      	add	sp, #16
    27ca:	4770      	bx	lr
    27cc:	40048000 	.word	0x40048000

000027d0 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    27d0:	b082      	sub	sp, #8
    27d2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    27d4:	bf00      	nop
    27d6:	b002      	add	sp, #8
    27d8:	4770      	bx	lr

000027da <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    27da:	b082      	sub	sp, #8
    27dc:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    27de:	bf00      	nop
    27e0:	b002      	add	sp, #8
    27e2:	4770      	bx	lr

000027e4 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    27e4:	b500      	push	{lr}
    27e6:	b083      	sub	sp, #12
    27e8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    27ea:	9b01      	ldr	r3, [sp, #4]
    27ec:	2b00      	cmp	r3, #0
    27ee:	d002      	beq.n	27f6 <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    27f0:	9801      	ldr	r0, [sp, #4]
    27f2:	f000 f8d1 	bl	2998 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    27f6:	bf00      	nop
    27f8:	b003      	add	sp, #12
    27fa:	f85d fb04 	ldr.w	pc, [sp], #4

000027fe <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    27fe:	b500      	push	{lr}
    2800:	b083      	sub	sp, #12
    2802:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2804:	9b01      	ldr	r3, [sp, #4]
    2806:	2b00      	cmp	r3, #0
    2808:	d002      	beq.n	2810 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    280a:	9801      	ldr	r0, [sp, #4]
    280c:	f000 f950 	bl	2ab0 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2810:	bf00      	nop
    2812:	b003      	add	sp, #12
    2814:	f85d fb04 	ldr.w	pc, [sp], #4

00002818 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    2818:	b500      	push	{lr}
    281a:	b083      	sub	sp, #12
    281c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    281e:	9801      	ldr	r0, [sp, #4]
    2820:	f000 f98e 	bl	2b40 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2824:	bf00      	nop
    2826:	b003      	add	sp, #12
    2828:	f85d fb04 	ldr.w	pc, [sp], #4

0000282c <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    282c:	b500      	push	{lr}
    282e:	b083      	sub	sp, #12
    2830:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2832:	9b01      	ldr	r3, [sp, #4]
    2834:	2b00      	cmp	r3, #0
    2836:	d002      	beq.n	283e <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    2838:	9801      	ldr	r0, [sp, #4]
    283a:	f000 f999 	bl	2b70 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    283e:	bf00      	nop
    2840:	b003      	add	sp, #12
    2842:	f85d fb04 	ldr.w	pc, [sp], #4

00002846 <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2846:	b500      	push	{lr}
    2848:	b083      	sub	sp, #12
    284a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    284c:	9b01      	ldr	r3, [sp, #4]
    284e:	2b00      	cmp	r3, #0
    2850:	d002      	beq.n	2858 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    2852:	9801      	ldr	r0, [sp, #4]
    2854:	f000 f9b0 	bl	2bb8 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2858:	bf00      	nop
    285a:	b003      	add	sp, #12
    285c:	f85d fb04 	ldr.w	pc, [sp], #4

00002860 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    2860:	b500      	push	{lr}
    2862:	b083      	sub	sp, #12
    2864:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    2866:	9801      	ldr	r0, [sp, #4]
    2868:	f000 f9ba 	bl	2be0 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    286c:	bf00      	nop
    286e:	b003      	add	sp, #12
    2870:	f85d fb04 	ldr.w	pc, [sp], #4

00002874 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2874:	b500      	push	{lr}
    2876:	b083      	sub	sp, #12
    2878:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    287a:	9b01      	ldr	r3, [sp, #4]
    287c:	2b00      	cmp	r3, #0
    287e:	d002      	beq.n	2886 <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    2880:	9801      	ldr	r0, [sp, #4]
    2882:	f000 f9bd 	bl	2c00 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2886:	bf00      	nop
    2888:	b003      	add	sp, #12
    288a:	f85d fb04 	ldr.w	pc, [sp], #4

0000288e <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    288e:	b500      	push	{lr}
    2890:	b083      	sub	sp, #12
    2892:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2894:	9b01      	ldr	r3, [sp, #4]
    2896:	2b00      	cmp	r3, #0
    2898:	d002      	beq.n	28a0 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    289a:	9801      	ldr	r0, [sp, #4]
    289c:	f000 f9d4 	bl	2c48 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    28a0:	bf00      	nop
    28a2:	b003      	add	sp, #12
    28a4:	f85d fb04 	ldr.w	pc, [sp], #4

000028a8 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    28a8:	b500      	push	{lr}
    28aa:	b083      	sub	sp, #12
    28ac:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    28ae:	9801      	ldr	r0, [sp, #4]
    28b0:	f000 f9de 	bl	2c70 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    28b4:	bf00      	nop
    28b6:	b003      	add	sp, #12
    28b8:	f85d fb04 	ldr.w	pc, [sp], #4

000028bc <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    28bc:	b500      	push	{lr}
    28be:	b089      	sub	sp, #36	; 0x24
    28c0:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    28c2:	2300      	movs	r3, #0
    28c4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    28c8:	4b20      	ldr	r3, [pc, #128]	; (294c <SetInputSouceSytemClock+0x90>)
    28ca:	695b      	ldr	r3, [r3, #20]
    28cc:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    28ce:	9b06      	ldr	r3, [sp, #24]
    28d0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    28d4:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    28d6:	9b01      	ldr	r3, [sp, #4]
    28d8:	061b      	lsls	r3, r3, #24
    28da:	9a06      	ldr	r2, [sp, #24]
    28dc:	4313      	orrs	r3, r2
    28de:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    28e0:	4a1a      	ldr	r2, [pc, #104]	; (294c <SetInputSouceSytemClock+0x90>)
    28e2:	9b06      	ldr	r3, [sp, #24]
    28e4:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    28e6:	aa02      	add	r2, sp, #8
    28e8:	a903      	add	r1, sp, #12
    28ea:	a804      	add	r0, sp, #16
    28ec:	f24c 3350 	movw	r3, #50000	; 0xc350
    28f0:	f7ff f9ac 	bl	1c4c <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    28f4:	4b15      	ldr	r3, [pc, #84]	; (294c <SetInputSouceSytemClock+0x90>)
    28f6:	691b      	ldr	r3, [r3, #16]
    28f8:	0e1b      	lsrs	r3, r3, #24
    28fa:	f003 030f 	and.w	r3, r3, #15
    28fe:	9a01      	ldr	r2, [sp, #4]
    2900:	429a      	cmp	r2, r3
    2902:	bf0c      	ite	eq
    2904:	2301      	moveq	r3, #1
    2906:	2300      	movne	r3, #0
    2908:	b2db      	uxtb	r3, r3
    290a:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    290c:	9a02      	ldr	r2, [sp, #8]
    290e:	a903      	add	r1, sp, #12
    2910:	ab04      	add	r3, sp, #16
    2912:	4618      	mov	r0, r3
    2914:	f7ff f9b4 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2918:	4603      	mov	r3, r0
    291a:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    291e:	9b05      	ldr	r3, [sp, #20]
    2920:	2b00      	cmp	r3, #0
    2922:	d106      	bne.n	2932 <SetInputSouceSytemClock+0x76>
    2924:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2928:	f083 0301 	eor.w	r3, r3, #1
    292c:	b2db      	uxtb	r3, r3
    292e:	2b00      	cmp	r3, #0
    2930:	d1e0      	bne.n	28f4 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    2932:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2936:	2b00      	cmp	r3, #0
    2938:	d003      	beq.n	2942 <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    293a:	2105      	movs	r1, #5
    293c:	2001      	movs	r0, #1
    293e:	f7ff f975 	bl	1c2c <Clock_Ip_ReportClockErrors>
    }
}
    2942:	bf00      	nop
    2944:	b009      	add	sp, #36	; 0x24
    2946:	f85d fb04 	ldr.w	pc, [sp], #4
    294a:	bf00      	nop
    294c:	40064000 	.word	0x40064000

00002950 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2950:	b500      	push	{lr}
    2952:	b083      	sub	sp, #12
    2954:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2956:	9b01      	ldr	r3, [sp, #4]
    2958:	2b00      	cmp	r3, #0
    295a:	d002      	beq.n	2962 <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    295c:	9801      	ldr	r0, [sp, #4]
    295e:	f000 f997 	bl	2c90 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2962:	bf00      	nop
    2964:	b003      	add	sp, #12
    2966:	f85d fb04 	ldr.w	pc, [sp], #4

0000296a <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    296a:	b500      	push	{lr}
    296c:	b083      	sub	sp, #12
    296e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2970:	9b01      	ldr	r3, [sp, #4]
    2972:	2b00      	cmp	r3, #0
    2974:	d002      	beq.n	297c <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    2976:	9801      	ldr	r0, [sp, #4]
    2978:	f000 fa7e 	bl	2e78 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    297c:	bf00      	nop
    297e:	b003      	add	sp, #12
    2980:	f85d fb04 	ldr.w	pc, [sp], #4

00002984 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    2984:	b500      	push	{lr}
    2986:	b083      	sub	sp, #12
    2988:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    298a:	9801      	ldr	r0, [sp, #4]
    298c:	f000 fab8 	bl	2f00 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2990:	bf00      	nop
    2992:	b003      	add	sp, #12
    2994:	f85d fb04 	ldr.w	pc, [sp], #4

00002998 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2998:	b500      	push	{lr}
    299a:	b08b      	sub	sp, #44	; 0x2c
    299c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    299e:	2300      	movs	r3, #0
    29a0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    29a4:	9b01      	ldr	r3, [sp, #4]
    29a6:	2b00      	cmp	r3, #0
    29a8:	d10b      	bne.n	29c2 <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    29aa:	2305      	movs	r3, #5
    29ac:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    29ae:	2301      	movs	r3, #1
    29b0:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    29b4:	2301      	movs	r3, #1
    29b6:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    29ba:	2301      	movs	r3, #1
    29bc:	f88d 3010 	strb.w	r3, [sp, #16]
    29c0:	e00e      	b.n	29e0 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    29c2:	9b01      	ldr	r3, [sp, #4]
    29c4:	681b      	ldr	r3, [r3, #0]
    29c6:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    29c8:	9b01      	ldr	r3, [sp, #4]
    29ca:	79db      	ldrb	r3, [r3, #7]
    29cc:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    29d0:	9b01      	ldr	r3, [sp, #4]
    29d2:	889b      	ldrh	r3, [r3, #4]
    29d4:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    29d8:	9b01      	ldr	r3, [sp, #4]
    29da:	7a1b      	ldrb	r3, [r3, #8]
    29dc:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    29e0:	4b32      	ldr	r3, [pc, #200]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    29e2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    29e6:	4a31      	ldr	r2, [pc, #196]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    29e8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    29ec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    29f0:	4b2e      	ldr	r3, [pc, #184]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    29f2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    29f6:	4a2d      	ldr	r2, [pc, #180]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    29f8:	f023 0301 	bic.w	r3, r3, #1
    29fc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2a00:	4b2a      	ldr	r3, [pc, #168]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a02:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a06:	4a29      	ldr	r2, [pc, #164]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a08:	f023 0304 	bic.w	r3, r3, #4
    2a0c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    2a10:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    2a14:	2b01      	cmp	r3, #1
    2a16:	d144      	bne.n	2aa2 <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    2a18:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2a1c:	4a23      	ldr	r2, [pc, #140]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a1e:	f003 0301 	and.w	r3, r3, #1
    2a22:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2a26:	4b21      	ldr	r3, [pc, #132]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a28:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a2c:	4a1f      	ldr	r2, [pc, #124]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a2e:	f043 0301 	orr.w	r3, r3, #1
    2a32:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    2a36:	4b1d      	ldr	r3, [pc, #116]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a38:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2a3c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    2a40:	009b      	lsls	r3, r3, #2
    2a42:	f003 0304 	and.w	r3, r3, #4
    2a46:	4919      	ldr	r1, [pc, #100]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a48:	4313      	orrs	r3, r2
    2a4a:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2a4e:	aa05      	add	r2, sp, #20
    2a50:	a906      	add	r1, sp, #24
    2a52:	a807      	add	r0, sp, #28
    2a54:	f24c 3350 	movw	r3, #50000	; 0xc350
    2a58:	f7ff f8f8 	bl	1c4c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2a5c:	4b13      	ldr	r3, [pc, #76]	; (2aac <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2a5e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a62:	0e1b      	lsrs	r3, r3, #24
    2a64:	f003 0301 	and.w	r3, r3, #1
    2a68:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2a6a:	9a05      	ldr	r2, [sp, #20]
    2a6c:	a906      	add	r1, sp, #24
    2a6e:	ab07      	add	r3, sp, #28
    2a70:	4618      	mov	r0, r3
    2a72:	f7ff f905 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2a76:	4603      	mov	r3, r0
    2a78:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2a7c:	9b08      	ldr	r3, [sp, #32]
    2a7e:	2b00      	cmp	r3, #0
    2a80:	d106      	bne.n	2a90 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    2a82:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2a86:	f083 0301 	eor.w	r3, r3, #1
    2a8a:	b2db      	uxtb	r3, r3
    2a8c:	2b00      	cmp	r3, #0
    2a8e:	d1e5      	bne.n	2a5c <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    2a90:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2a94:	2b00      	cmp	r3, #0
    2a96:	d004      	beq.n	2aa2 <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    2a98:	9b02      	ldr	r3, [sp, #8]
    2a9a:	4619      	mov	r1, r3
    2a9c:	2001      	movs	r0, #1
    2a9e:	f7ff f8c5 	bl	1c2c <Clock_Ip_ReportClockErrors>
        }
    }
}
    2aa2:	bf00      	nop
    2aa4:	b00b      	add	sp, #44	; 0x2c
    2aa6:	f85d fb04 	ldr.w	pc, [sp], #4
    2aaa:	bf00      	nop
    2aac:	40064000 	.word	0x40064000

00002ab0 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2ab0:	b500      	push	{lr}
    2ab2:	b089      	sub	sp, #36	; 0x24
    2ab4:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2ab6:	2300      	movs	r3, #0
    2ab8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    2abc:	4b1f      	ldr	r3, [pc, #124]	; (2b3c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2abe:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2ac2:	4a1e      	ldr	r2, [pc, #120]	; (2b3c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2ac4:	f043 0301 	orr.w	r3, r3, #1
    2ac8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    2acc:	4b1b      	ldr	r3, [pc, #108]	; (2b3c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2ace:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2ad2:	4a1a      	ldr	r2, [pc, #104]	; (2b3c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2ad4:	f043 0304 	orr.w	r3, r3, #4
    2ad8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2adc:	aa03      	add	r2, sp, #12
    2ade:	a904      	add	r1, sp, #16
    2ae0:	a805      	add	r0, sp, #20
    2ae2:	f24c 3350 	movw	r3, #50000	; 0xc350
    2ae6:	f7ff f8b1 	bl	1c4c <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2aea:	4b14      	ldr	r3, [pc, #80]	; (2b3c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    2aec:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2af0:	0e1b      	lsrs	r3, r3, #24
    2af2:	f003 0301 	and.w	r3, r3, #1
    2af6:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2af8:	9a03      	ldr	r2, [sp, #12]
    2afa:	a904      	add	r1, sp, #16
    2afc:	ab05      	add	r3, sp, #20
    2afe:	4618      	mov	r0, r3
    2b00:	f7ff f8be 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2b04:	4603      	mov	r3, r0
    2b06:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2b0a:	9b06      	ldr	r3, [sp, #24]
    2b0c:	2b00      	cmp	r3, #0
    2b0e:	d106      	bne.n	2b1e <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    2b10:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2b14:	f083 0301 	eor.w	r3, r3, #1
    2b18:	b2db      	uxtb	r3, r3
    2b1a:	2b00      	cmp	r3, #0
    2b1c:	d1e5      	bne.n	2aea <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    2b1e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2b22:	2b00      	cmp	r3, #0
    2b24:	d005      	beq.n	2b32 <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2b26:	9b01      	ldr	r3, [sp, #4]
    2b28:	681b      	ldr	r3, [r3, #0]
    2b2a:	4619      	mov	r1, r3
    2b2c:	2001      	movs	r0, #1
    2b2e:	f7ff f87d 	bl	1c2c <Clock_Ip_ReportClockErrors>
    }
}
    2b32:	bf00      	nop
    2b34:	b009      	add	sp, #36	; 0x24
    2b36:	f85d fb04 	ldr.w	pc, [sp], #4
    2b3a:	bf00      	nop
    2b3c:	40064000 	.word	0x40064000

00002b40 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    2b40:	b082      	sub	sp, #8
    2b42:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    2b44:	4b09      	ldr	r3, [pc, #36]	; (2b6c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2b46:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b4a:	4a08      	ldr	r2, [pc, #32]	; (2b6c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2b4c:	f023 0301 	bic.w	r3, r3, #1
    2b50:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2b54:	4b05      	ldr	r3, [pc, #20]	; (2b6c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2b56:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b5a:	4a04      	ldr	r2, [pc, #16]	; (2b6c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2b5c:	f023 0304 	bic.w	r3, r3, #4
    2b60:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2b64:	bf00      	nop
    2b66:	b002      	add	sp, #8
    2b68:	4770      	bx	lr
    2b6a:	bf00      	nop
    2b6c:	40064000 	.word	0x40064000

00002b70 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2b70:	b082      	sub	sp, #8
    2b72:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2b74:	4b0f      	ldr	r3, [pc, #60]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2b76:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b7a:	4a0e      	ldr	r2, [pc, #56]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2b7c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2b80:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2b84:	4b0b      	ldr	r3, [pc, #44]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2b86:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b8a:	4a0a      	ldr	r2, [pc, #40]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2b8c:	f023 0304 	bic.w	r3, r3, #4
    2b90:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    2b94:	4b07      	ldr	r3, [pc, #28]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2b96:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2b9a:	9b01      	ldr	r3, [sp, #4]
    2b9c:	7a1b      	ldrb	r3, [r3, #8]
    2b9e:	009b      	lsls	r3, r3, #2
    2ba0:	f003 0304 	and.w	r3, r3, #4
    2ba4:	4903      	ldr	r1, [pc, #12]	; (2bb4 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2ba6:	4313      	orrs	r3, r2
    2ba8:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    2bac:	bf00      	nop
    2bae:	b002      	add	sp, #8
    2bb0:	4770      	bx	lr
    2bb2:	bf00      	nop
    2bb4:	40064000 	.word	0x40064000

00002bb8 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2bb8:	b082      	sub	sp, #8
    2bba:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2bbc:	9b01      	ldr	r3, [sp, #4]
    2bbe:	889b      	ldrh	r3, [r3, #4]
    2bc0:	2b01      	cmp	r3, #1
    2bc2:	d107      	bne.n	2bd4 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    2bc4:	4b05      	ldr	r3, [pc, #20]	; (2bdc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    2bc6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2bca:	4a04      	ldr	r2, [pc, #16]	; (2bdc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    2bcc:	f043 0304 	orr.w	r3, r3, #4
    2bd0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    2bd4:	bf00      	nop
    2bd6:	b002      	add	sp, #8
    2bd8:	4770      	bx	lr
    2bda:	bf00      	nop
    2bdc:	40064000 	.word	0x40064000

00002be0 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    2be0:	b082      	sub	sp, #8
    2be2:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2be4:	4b05      	ldr	r3, [pc, #20]	; (2bfc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    2be6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2bea:	4a04      	ldr	r2, [pc, #16]	; (2bfc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    2bec:	f023 0304 	bic.w	r3, r3, #4
    2bf0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2bf4:	bf00      	nop
    2bf6:	b002      	add	sp, #8
    2bf8:	4770      	bx	lr
    2bfa:	bf00      	nop
    2bfc:	40064000 	.word	0x40064000

00002c00 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2c00:	b082      	sub	sp, #8
    2c02:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2c04:	4b0f      	ldr	r3, [pc, #60]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c06:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2c0a:	4a0e      	ldr	r2, [pc, #56]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c0c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2c10:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    2c14:	4b0b      	ldr	r3, [pc, #44]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c16:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2c1a:	4a0a      	ldr	r2, [pc, #40]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c1c:	f023 0302 	bic.w	r3, r3, #2
    2c20:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    2c24:	4b07      	ldr	r3, [pc, #28]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c26:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2c2a:	9b01      	ldr	r3, [sp, #4]
    2c2c:	7a5b      	ldrb	r3, [r3, #9]
    2c2e:	005b      	lsls	r3, r3, #1
    2c30:	f003 0302 	and.w	r3, r3, #2
    2c34:	4903      	ldr	r1, [pc, #12]	; (2c44 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2c36:	4313      	orrs	r3, r2
    2c38:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    2c3c:	bf00      	nop
    2c3e:	b002      	add	sp, #8
    2c40:	4770      	bx	lr
    2c42:	bf00      	nop
    2c44:	40064000 	.word	0x40064000

00002c48 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2c48:	b082      	sub	sp, #8
    2c4a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2c4c:	9b01      	ldr	r3, [sp, #4]
    2c4e:	889b      	ldrh	r3, [r3, #4]
    2c50:	2b01      	cmp	r3, #1
    2c52:	d107      	bne.n	2c64 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    2c54:	4b05      	ldr	r3, [pc, #20]	; (2c6c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    2c56:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2c5a:	4a04      	ldr	r2, [pc, #16]	; (2c6c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    2c5c:	f043 0302 	orr.w	r3, r3, #2
    2c60:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    2c64:	bf00      	nop
    2c66:	b002      	add	sp, #8
    2c68:	4770      	bx	lr
    2c6a:	bf00      	nop
    2c6c:	40064000 	.word	0x40064000

00002c70 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    2c70:	b082      	sub	sp, #8
    2c72:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    2c74:	4b05      	ldr	r3, [pc, #20]	; (2c8c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    2c76:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2c7a:	4a04      	ldr	r2, [pc, #16]	; (2c8c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    2c7c:	f023 0302 	bic.w	r3, r3, #2
    2c80:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2c84:	bf00      	nop
    2c86:	b002      	add	sp, #8
    2c88:	4770      	bx	lr
    2c8a:	bf00      	nop
    2c8c:	40064000 	.word	0x40064000

00002c90 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2c90:	b500      	push	{lr}
    2c92:	b08b      	sub	sp, #44	; 0x2c
    2c94:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2c96:	9b01      	ldr	r3, [sp, #4]
    2c98:	681a      	ldr	r2, [r3, #0]
    2c9a:	4975      	ldr	r1, [pc, #468]	; (2e70 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    2c9c:	4613      	mov	r3, r2
    2c9e:	00db      	lsls	r3, r3, #3
    2ca0:	4413      	add	r3, r2
    2ca2:	440b      	add	r3, r1
    2ca4:	781b      	ldrb	r3, [r3, #0]
    2ca6:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    2ca8:	2300      	movs	r3, #0
    2caa:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    2cae:	2300      	movs	r3, #0
    2cb0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    2cb4:	4b6f      	ldr	r3, [pc, #444]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cb6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2cba:	4a6e      	ldr	r2, [pc, #440]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cbc:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2cc0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    2cc4:	4b6b      	ldr	r3, [pc, #428]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cc6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2cca:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    2cce:	2b00      	cmp	r3, #0
    2cd0:	d07d      	beq.n	2dce <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    2cd2:	9b01      	ldr	r3, [sp, #4]
    2cd4:	79db      	ldrb	r3, [r3, #7]
    2cd6:	461a      	mov	r2, r3
    2cd8:	4b66      	ldr	r3, [pc, #408]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cda:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    2cde:	f003 0303 	and.w	r3, r3, #3
    2ce2:	429a      	cmp	r2, r3
    2ce4:	d10b      	bne.n	2cfe <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    2ce6:	9b01      	ldr	r3, [sp, #4]
    2ce8:	799b      	ldrb	r3, [r3, #6]
    2cea:	461a      	mov	r2, r3
    2cec:	4b61      	ldr	r3, [pc, #388]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cee:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2cf2:	08db      	lsrs	r3, r3, #3
    2cf4:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    2cf8:	429a      	cmp	r2, r3
    2cfa:	f000 80b4 	beq.w	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    2cfe:	4b5d      	ldr	r3, [pc, #372]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d00:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2d04:	f003 0301 	and.w	r3, r3, #1
    2d08:	2b00      	cmp	r3, #0
    2d0a:	d105      	bne.n	2d18 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    2d0c:	2301      	movs	r3, #1
    2d0e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    2d12:	2000      	movs	r0, #0
    2d14:	f7ff fd66 	bl	27e4 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    2d18:	2002      	movs	r0, #2
    2d1a:	f7ff fdcf 	bl	28bc <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    2d1e:	4b55      	ldr	r3, [pc, #340]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d20:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2d24:	4a53      	ldr	r2, [pc, #332]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d26:	f023 0301 	bic.w	r3, r3, #1
    2d2a:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    2d2e:	9b01      	ldr	r3, [sp, #4]
    2d30:	889b      	ldrh	r3, [r3, #4]
    2d32:	2b01      	cmp	r3, #1
    2d34:	f040 8097 	bne.w	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    2d38:	9b01      	ldr	r3, [sp, #4]
    2d3a:	79db      	ldrb	r3, [r3, #7]
    2d3c:	4a4d      	ldr	r2, [pc, #308]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d3e:	f003 0303 	and.w	r3, r3, #3
    2d42:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    2d46:	4b4b      	ldr	r3, [pc, #300]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d48:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    2d4c:	9b01      	ldr	r3, [sp, #4]
    2d4e:	799b      	ldrb	r3, [r3, #6]
    2d50:	00db      	lsls	r3, r3, #3
    2d52:	f003 0308 	and.w	r3, r3, #8
    2d56:	4313      	orrs	r3, r2
    2d58:	4a46      	ldr	r2, [pc, #280]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d5a:	f043 0301 	orr.w	r3, r3, #1
    2d5e:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2d62:	aa03      	add	r2, sp, #12
    2d64:	a904      	add	r1, sp, #16
    2d66:	a805      	add	r0, sp, #20
    2d68:	f24c 3350 	movw	r3, #50000	; 0xc350
    2d6c:	f7fe ff6e 	bl	1c4c <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2d70:	4b40      	ldr	r3, [pc, #256]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d72:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2d76:	0e1b      	lsrs	r3, r3, #24
    2d78:	f003 0301 	and.w	r3, r3, #1
    2d7c:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2d7e:	9a03      	ldr	r2, [sp, #12]
    2d80:	a904      	add	r1, sp, #16
    2d82:	ab05      	add	r3, sp, #20
    2d84:	4618      	mov	r0, r3
    2d86:	f7fe ff7b 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2d8a:	4603      	mov	r3, r0
    2d8c:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2d90:	9b06      	ldr	r3, [sp, #24]
    2d92:	2b00      	cmp	r3, #0
    2d94:	d106      	bne.n	2da4 <Clock_Ip_SetFirc_TrustedCall+0x114>
    2d96:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d9a:	f083 0301 	eor.w	r3, r3, #1
    2d9e:	b2db      	uxtb	r3, r3
    2da0:	2b00      	cmp	r3, #0
    2da2:	d1e5      	bne.n	2d70 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    2da4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2da8:	2b00      	cmp	r3, #0
    2daa:	d005      	beq.n	2db8 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2dac:	9b01      	ldr	r3, [sp, #4]
    2dae:	681b      	ldr	r3, [r3, #0]
    2db0:	4619      	mov	r1, r3
    2db2:	2001      	movs	r0, #1
    2db4:	f7fe ff3a 	bl	1c2c <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    2db8:	2003      	movs	r0, #3
    2dba:	f7ff fd7f 	bl	28bc <SetInputSouceSytemClock>

                if (SircWasDisabled)
    2dbe:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2dc2:	2b00      	cmp	r3, #0
    2dc4:	d04f      	beq.n	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    2dc6:	2002      	movs	r0, #2
    2dc8:	f7ff fd26 	bl	2818 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    2dcc:	e04b      	b.n	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    2dce:	4b29      	ldr	r3, [pc, #164]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2dd0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2dd4:	4a27      	ldr	r2, [pc, #156]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2dd6:	f023 0301 	bic.w	r3, r3, #1
    2dda:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    2dde:	9b01      	ldr	r3, [sp, #4]
    2de0:	889b      	ldrh	r3, [r3, #4]
    2de2:	2b01      	cmp	r3, #1
    2de4:	d13f      	bne.n	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    2de6:	9b01      	ldr	r3, [sp, #4]
    2de8:	79db      	ldrb	r3, [r3, #7]
    2dea:	4a22      	ldr	r2, [pc, #136]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2dec:	f003 0303 	and.w	r3, r3, #3
    2df0:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    2df4:	4b1f      	ldr	r3, [pc, #124]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2df6:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    2dfa:	9b01      	ldr	r3, [sp, #4]
    2dfc:	799b      	ldrb	r3, [r3, #6]
    2dfe:	00db      	lsls	r3, r3, #3
    2e00:	f003 0308 	and.w	r3, r3, #8
    2e04:	4313      	orrs	r3, r2
    2e06:	4a1b      	ldr	r2, [pc, #108]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2e08:	f043 0301 	orr.w	r3, r3, #1
    2e0c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2e10:	aa03      	add	r2, sp, #12
    2e12:	a904      	add	r1, sp, #16
    2e14:	a805      	add	r0, sp, #20
    2e16:	f24c 3350 	movw	r3, #50000	; 0xc350
    2e1a:	f7fe ff17 	bl	1c4c <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2e1e:	4b15      	ldr	r3, [pc, #84]	; (2e74 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2e20:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2e24:	0e1b      	lsrs	r3, r3, #24
    2e26:	f003 0301 	and.w	r3, r3, #1
    2e2a:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2e2c:	9a03      	ldr	r2, [sp, #12]
    2e2e:	a904      	add	r1, sp, #16
    2e30:	ab05      	add	r3, sp, #20
    2e32:	4618      	mov	r0, r3
    2e34:	f7fe ff24 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2e38:	4603      	mov	r3, r0
    2e3a:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2e3e:	9b06      	ldr	r3, [sp, #24]
    2e40:	2b00      	cmp	r3, #0
    2e42:	d106      	bne.n	2e52 <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    2e44:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2e48:	f083 0301 	eor.w	r3, r3, #1
    2e4c:	b2db      	uxtb	r3, r3
    2e4e:	2b00      	cmp	r3, #0
    2e50:	d1e5      	bne.n	2e1e <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    2e52:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2e56:	2b00      	cmp	r3, #0
    2e58:	d005      	beq.n	2e66 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2e5a:	9b01      	ldr	r3, [sp, #4]
    2e5c:	681b      	ldr	r3, [r3, #0]
    2e5e:	4619      	mov	r1, r3
    2e60:	2001      	movs	r0, #1
    2e62:	f7fe fee3 	bl	1c2c <Clock_Ip_ReportClockErrors>
}
    2e66:	bf00      	nop
    2e68:	b00b      	add	sp, #44	; 0x2c
    2e6a:	f85d fb04 	ldr.w	pc, [sp], #4
    2e6e:	bf00      	nop
    2e70:	0000afc0 	.word	0x0000afc0
    2e74:	40064000 	.word	0x40064000

00002e78 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2e78:	b500      	push	{lr}
    2e7a:	b089      	sub	sp, #36	; 0x24
    2e7c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2e7e:	2300      	movs	r3, #0
    2e80:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    2e84:	9b01      	ldr	r3, [sp, #4]
    2e86:	889b      	ldrh	r3, [r3, #4]
    2e88:	2b01      	cmp	r3, #1
    2e8a:	d132      	bne.n	2ef2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    2e8c:	4b1b      	ldr	r3, [pc, #108]	; (2efc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2e8e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2e92:	4a1a      	ldr	r2, [pc, #104]	; (2efc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2e94:	f043 0301 	orr.w	r3, r3, #1
    2e98:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2e9c:	aa03      	add	r2, sp, #12
    2e9e:	a904      	add	r1, sp, #16
    2ea0:	a805      	add	r0, sp, #20
    2ea2:	f24c 3350 	movw	r3, #50000	; 0xc350
    2ea6:	f7fe fed1 	bl	1c4c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2eaa:	4b14      	ldr	r3, [pc, #80]	; (2efc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2eac:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2eb0:	0e1b      	lsrs	r3, r3, #24
    2eb2:	f003 0301 	and.w	r3, r3, #1
    2eb6:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2eb8:	9a03      	ldr	r2, [sp, #12]
    2eba:	a904      	add	r1, sp, #16
    2ebc:	ab05      	add	r3, sp, #20
    2ebe:	4618      	mov	r0, r3
    2ec0:	f7fe fede 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2ec4:	4603      	mov	r3, r0
    2ec6:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2eca:	9b06      	ldr	r3, [sp, #24]
    2ecc:	2b00      	cmp	r3, #0
    2ece:	d106      	bne.n	2ede <Clock_Ip_EnableFirc_TrustedCall+0x66>
    2ed0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2ed4:	f083 0301 	eor.w	r3, r3, #1
    2ed8:	b2db      	uxtb	r3, r3
    2eda:	2b00      	cmp	r3, #0
    2edc:	d1e5      	bne.n	2eaa <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    2ede:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2ee2:	2b00      	cmp	r3, #0
    2ee4:	d005      	beq.n	2ef2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2ee6:	9b01      	ldr	r3, [sp, #4]
    2ee8:	681b      	ldr	r3, [r3, #0]
    2eea:	4619      	mov	r1, r3
    2eec:	2001      	movs	r0, #1
    2eee:	f7fe fe9d 	bl	1c2c <Clock_Ip_ReportClockErrors>
        }
    }
}
    2ef2:	bf00      	nop
    2ef4:	b009      	add	sp, #36	; 0x24
    2ef6:	f85d fb04 	ldr.w	pc, [sp], #4
    2efa:	bf00      	nop
    2efc:	40064000 	.word	0x40064000

00002f00 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    2f00:	b082      	sub	sp, #8
    2f02:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    2f04:	4b05      	ldr	r3, [pc, #20]	; (2f1c <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    2f06:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2f0a:	4a04      	ldr	r2, [pc, #16]	; (2f1c <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    2f0c:	f023 0301 	bic.w	r3, r3, #1
    2f10:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    2f14:	bf00      	nop
    2f16:	b002      	add	sp, #8
    2f18:	4770      	bx	lr
    2f1a:	bf00      	nop
    2f1c:	40064000 	.word	0x40064000

00002f20 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    2f20:	b082      	sub	sp, #8
    2f22:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2f24:	bf00      	nop
    2f26:	b002      	add	sp, #8
    2f28:	4770      	bx	lr

00002f2a <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    2f2a:	b082      	sub	sp, #8
    2f2c:	9001      	str	r0, [sp, #4]
    2f2e:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    2f30:	bf00      	nop
    2f32:	b002      	add	sp, #8
    2f34:	4770      	bx	lr

00002f36 <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    2f36:	b082      	sub	sp, #8
    2f38:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    2f3a:	bf00      	nop
    2f3c:	b002      	add	sp, #8
    2f3e:	4770      	bx	lr

00002f40 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    2f40:	b082      	sub	sp, #8
    2f42:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2f44:	bf00      	nop
    2f46:	b002      	add	sp, #8
    2f48:	4770      	bx	lr

00002f4a <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    2f4a:	b082      	sub	sp, #8
    2f4c:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    2f4e:	2302      	movs	r3, #2
}
    2f50:	4618      	mov	r0, r3
    2f52:	b002      	add	sp, #8
    2f54:	4770      	bx	lr

00002f56 <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    2f56:	b082      	sub	sp, #8
    2f58:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    2f5a:	bf00      	nop
    2f5c:	b002      	add	sp, #8
    2f5e:	4770      	bx	lr

00002f60 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    2f60:	b500      	push	{lr}
    2f62:	b083      	sub	sp, #12
    2f64:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f66:	9b01      	ldr	r3, [sp, #4]
    2f68:	2b00      	cmp	r3, #0
    2f6a:	d002      	beq.n	2f72 <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    2f6c:	9801      	ldr	r0, [sp, #4]
    2f6e:	f000 f870 	bl	3052 <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f72:	bf00      	nop
    2f74:	b003      	add	sp, #12
    2f76:	f85d fb04 	ldr.w	pc, [sp], #4

00002f7a <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    2f7a:	b500      	push	{lr}
    2f7c:	b083      	sub	sp, #12
    2f7e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f80:	9b01      	ldr	r3, [sp, #4]
    2f82:	2b00      	cmp	r3, #0
    2f84:	d002      	beq.n	2f8c <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    2f86:	9801      	ldr	r0, [sp, #4]
    2f88:	f000 f89a 	bl	30c0 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f8c:	bf00      	nop
    2f8e:	b003      	add	sp, #12
    2f90:	f85d fb04 	ldr.w	pc, [sp], #4

00002f94 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    2f94:	b500      	push	{lr}
    2f96:	b089      	sub	sp, #36	; 0x24
    2f98:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    2f9a:	2301      	movs	r3, #1
    2f9c:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    2f9e:	2300      	movs	r3, #0
    2fa0:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    2fa4:	4b1e      	ldr	r3, [pc, #120]	; (3020 <Clock_Ip_CompleteSpll+0x8c>)
    2fa6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2faa:	f003 0301 	and.w	r3, r3, #1
    2fae:	2b00      	cmp	r3, #0
    2fb0:	d02f      	beq.n	3012 <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2fb2:	aa02      	add	r2, sp, #8
    2fb4:	a903      	add	r1, sp, #12
    2fb6:	a804      	add	r0, sp, #16
    2fb8:	f24c 3350 	movw	r3, #50000	; 0xc350
    2fbc:	f7fe fe46 	bl	1c4c <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    2fc0:	4b17      	ldr	r3, [pc, #92]	; (3020 <Clock_Ip_CompleteSpll+0x8c>)
    2fc2:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2fc6:	0e1b      	lsrs	r3, r3, #24
    2fc8:	f003 0301 	and.w	r3, r3, #1
    2fcc:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2fce:	9a02      	ldr	r2, [sp, #8]
    2fd0:	a903      	add	r1, sp, #12
    2fd2:	ab04      	add	r3, sp, #16
    2fd4:	4618      	mov	r0, r3
    2fd6:	f7fe fe53 	bl	1c80 <Clock_Ip_TimeoutExpired>
    2fda:	4603      	mov	r3, r0
    2fdc:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    2fe0:	9b05      	ldr	r3, [sp, #20]
    2fe2:	2b00      	cmp	r3, #0
    2fe4:	d106      	bne.n	2ff4 <Clock_Ip_CompleteSpll+0x60>
    2fe6:	f89d 301b 	ldrb.w	r3, [sp, #27]
    2fea:	f083 0301 	eor.w	r3, r3, #1
    2fee:	b2db      	uxtb	r3, r3
    2ff0:	2b00      	cmp	r3, #0
    2ff2:	d1e5      	bne.n	2fc0 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    2ff4:	f89d 301b 	ldrb.w	r3, [sp, #27]
    2ff8:	f083 0301 	eor.w	r3, r3, #1
    2ffc:	b2db      	uxtb	r3, r3
    2ffe:	2b00      	cmp	r3, #0
    3000:	d002      	beq.n	3008 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    3002:	2302      	movs	r3, #2
    3004:	9307      	str	r3, [sp, #28]
    3006:	e006      	b.n	3016 <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    3008:	9901      	ldr	r1, [sp, #4]
    300a:	2001      	movs	r0, #1
    300c:	f7fe fe0e 	bl	1c2c <Clock_Ip_ReportClockErrors>
    3010:	e001      	b.n	3016 <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    3012:	2300      	movs	r3, #0
    3014:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    3016:	9b07      	ldr	r3, [sp, #28]
}
    3018:	4618      	mov	r0, r3
    301a:	b009      	add	sp, #36	; 0x24
    301c:	f85d fb04 	ldr.w	pc, [sp], #4
    3020:	40064000 	.word	0x40064000

00003024 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    3024:	b500      	push	{lr}
    3026:	b083      	sub	sp, #12
    3028:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    302a:	9801      	ldr	r0, [sp, #4]
    302c:	f000 f886 	bl	313c <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3030:	bf00      	nop
    3032:	b003      	add	sp, #12
    3034:	f85d fb04 	ldr.w	pc, [sp], #4

00003038 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    3038:	b500      	push	{lr}
    303a:	b083      	sub	sp, #12
    303c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    303e:	9b01      	ldr	r3, [sp, #4]
    3040:	2b00      	cmp	r3, #0
    3042:	d002      	beq.n	304a <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    3044:	9801      	ldr	r0, [sp, #4]
    3046:	f000 f891 	bl	316c <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    304a:	bf00      	nop
    304c:	b003      	add	sp, #12
    304e:	f85d fb04 	ldr.w	pc, [sp], #4

00003052 <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    3052:	b082      	sub	sp, #8
    3054:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    3056:	4b19      	ldr	r3, [pc, #100]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3058:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    305c:	4a17      	ldr	r2, [pc, #92]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    305e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3062:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    3066:	4b15      	ldr	r3, [pc, #84]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3068:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    306c:	4a13      	ldr	r2, [pc, #76]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    306e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    3072:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    3076:	4b11      	ldr	r3, [pc, #68]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3078:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    307c:	4a0f      	ldr	r2, [pc, #60]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    307e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    3082:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    3086:	4b0d      	ldr	r3, [pc, #52]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3088:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    308c:	4a0b      	ldr	r2, [pc, #44]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    308e:	f023 0301 	bic.w	r3, r3, #1
    3092:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    3096:	4b09      	ldr	r3, [pc, #36]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    3098:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    309c:	4a07      	ldr	r2, [pc, #28]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    309e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    30a2:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    30a6:	4b05      	ldr	r3, [pc, #20]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    30a8:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    30ac:	4a03      	ldr	r2, [pc, #12]	; (30bc <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    30ae:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    30b2:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    30b6:	bf00      	nop
    30b8:	b002      	add	sp, #8
    30ba:	4770      	bx	lr
    30bc:	40064000 	.word	0x40064000

000030c0 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    30c0:	b082      	sub	sp, #8
    30c2:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    30c4:	9b01      	ldr	r3, [sp, #4]
    30c6:	889b      	ldrh	r3, [r3, #4]
    30c8:	2b01      	cmp	r3, #1
    30ca:	d12f      	bne.n	312c <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    30cc:	4b1a      	ldr	r3, [pc, #104]	; (3138 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    30ce:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    30d2:	9b01      	ldr	r3, [sp, #4]
    30d4:	7b5b      	ldrb	r3, [r3, #13]
    30d6:	3b01      	subs	r3, #1
    30d8:	021b      	lsls	r3, r3, #8
    30da:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    30de:	9b01      	ldr	r3, [sp, #4]
    30e0:	7d1b      	ldrb	r3, [r3, #20]
    30e2:	3b10      	subs	r3, #16
    30e4:	041b      	lsls	r3, r3, #16
    30e6:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    30ea:	430b      	orrs	r3, r1
    30ec:	4912      	ldr	r1, [pc, #72]	; (3138 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    30ee:	4313      	orrs	r3, r2
    30f0:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    30f4:	9b01      	ldr	r3, [sp, #4]
    30f6:	7fdb      	ldrb	r3, [r3, #31]
    30f8:	2b02      	cmp	r3, #2
    30fa:	d011      	beq.n	3120 <Clock_Ip_SetSpll_TrustedCall+0x60>
    30fc:	2b02      	cmp	r3, #2
    30fe:	dc17      	bgt.n	3130 <Clock_Ip_SetSpll_TrustedCall+0x70>
    3100:	2b00      	cmp	r3, #0
    3102:	d002      	beq.n	310a <Clock_Ip_SetSpll_TrustedCall+0x4a>
    3104:	2b01      	cmp	r3, #1
    3106:	d005      	beq.n	3114 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    3108:	e012      	b.n	3130 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    310a:	4b0b      	ldr	r3, [pc, #44]	; (3138 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    310c:	2200      	movs	r2, #0
    310e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3112:	e00e      	b.n	3132 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3114:	4b08      	ldr	r3, [pc, #32]	; (3138 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3116:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    311a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    311e:	e008      	b.n	3132 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3120:	4b05      	ldr	r3, [pc, #20]	; (3138 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3122:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    3126:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    312a:	e002      	b.n	3132 <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    312c:	bf00      	nop
    312e:	e000      	b.n	3132 <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    3130:	bf00      	nop
}
    3132:	bf00      	nop
    3134:	b002      	add	sp, #8
    3136:	4770      	bx	lr
    3138:	40064000 	.word	0x40064000

0000313c <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    313c:	b082      	sub	sp, #8
    313e:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    3140:	4b09      	ldr	r3, [pc, #36]	; (3168 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3142:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3146:	4a08      	ldr	r2, [pc, #32]	; (3168 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3148:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    314c:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    3150:	4b05      	ldr	r3, [pc, #20]	; (3168 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3152:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3156:	4a04      	ldr	r2, [pc, #16]	; (3168 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3158:	f023 0301 	bic.w	r3, r3, #1
    315c:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    3160:	bf00      	nop
    3162:	b002      	add	sp, #8
    3164:	4770      	bx	lr
    3166:	bf00      	nop
    3168:	40064000 	.word	0x40064000

0000316c <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    316c:	b082      	sub	sp, #8
    316e:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    3170:	9b01      	ldr	r3, [sp, #4]
    3172:	889b      	ldrh	r3, [r3, #4]
    3174:	2b01      	cmp	r3, #1
    3176:	d107      	bne.n	3188 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    3178:	4b05      	ldr	r3, [pc, #20]	; (3190 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    317a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    317e:	4a04      	ldr	r2, [pc, #16]	; (3190 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    3180:	f043 0301 	orr.w	r3, r3, #1
    3184:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    3188:	bf00      	nop
    318a:	b002      	add	sp, #8
    318c:	4770      	bx	lr
    318e:	bf00      	nop
    3190:	40064000 	.word	0x40064000

00003194 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    3194:	b082      	sub	sp, #8
    3196:	9001      	str	r0, [sp, #4]
    3198:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    319a:	bf00      	nop
    319c:	b002      	add	sp, #8
    319e:	4770      	bx	lr

000031a0 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    31a0:	b082      	sub	sp, #8
    31a2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    31a4:	bf00      	nop
    31a6:	b002      	add	sp, #8
    31a8:	4770      	bx	lr

000031aa <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    31aa:	b500      	push	{lr}
    31ac:	b083      	sub	sp, #12
    31ae:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31b0:	9b01      	ldr	r3, [sp, #4]
    31b2:	2b00      	cmp	r3, #0
    31b4:	d002      	beq.n	31bc <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    31b6:	9801      	ldr	r0, [sp, #4]
    31b8:	f000 f8ee 	bl	3398 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31bc:	bf00      	nop
    31be:	b003      	add	sp, #12
    31c0:	f85d fb04 	ldr.w	pc, [sp], #4

000031c4 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    31c4:	b500      	push	{lr}
    31c6:	b083      	sub	sp, #12
    31c8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31ca:	9b01      	ldr	r3, [sp, #4]
    31cc:	2b00      	cmp	r3, #0
    31ce:	d002      	beq.n	31d6 <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    31d0:	9801      	ldr	r0, [sp, #4]
    31d2:	f000 f8ff 	bl	33d4 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31d6:	bf00      	nop
    31d8:	b003      	add	sp, #12
    31da:	f85d fb04 	ldr.w	pc, [sp], #4

000031de <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    31de:	b500      	push	{lr}
    31e0:	b083      	sub	sp, #12
    31e2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31e4:	9b01      	ldr	r3, [sp, #4]
    31e6:	2b00      	cmp	r3, #0
    31e8:	d002      	beq.n	31f0 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    31ea:	9801      	ldr	r0, [sp, #4]
    31ec:	f000 f912 	bl	3414 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31f0:	bf00      	nop
    31f2:	b003      	add	sp, #12
    31f4:	f85d fb04 	ldr.w	pc, [sp], #4

000031f8 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    31f8:	b500      	push	{lr}
    31fa:	b083      	sub	sp, #12
    31fc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31fe:	9b01      	ldr	r3, [sp, #4]
    3200:	2b00      	cmp	r3, #0
    3202:	d002      	beq.n	320a <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    3204:	9801      	ldr	r0, [sp, #4]
    3206:	f000 f925 	bl	3454 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    320a:	bf00      	nop
    320c:	b003      	add	sp, #12
    320e:	f85d fb04 	ldr.w	pc, [sp], #4

00003212 <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    3212:	b500      	push	{lr}
    3214:	b083      	sub	sp, #12
    3216:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3218:	9b01      	ldr	r3, [sp, #4]
    321a:	2b00      	cmp	r3, #0
    321c:	d002      	beq.n	3224 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    321e:	9801      	ldr	r0, [sp, #4]
    3220:	f000 f936 	bl	3490 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3224:	bf00      	nop
    3226:	b003      	add	sp, #12
    3228:	f85d fb04 	ldr.w	pc, [sp], #4

0000322c <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    322c:	b500      	push	{lr}
    322e:	b083      	sub	sp, #12
    3230:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3232:	9b01      	ldr	r3, [sp, #4]
    3234:	2b00      	cmp	r3, #0
    3236:	d002      	beq.n	323e <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    3238:	9801      	ldr	r0, [sp, #4]
    323a:	f000 f949 	bl	34d0 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    323e:	bf00      	nop
    3240:	b003      	add	sp, #12
    3242:	f85d fb04 	ldr.w	pc, [sp], #4

00003246 <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    3246:	b500      	push	{lr}
    3248:	b083      	sub	sp, #12
    324a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    324c:	9b01      	ldr	r3, [sp, #4]
    324e:	2b00      	cmp	r3, #0
    3250:	d002      	beq.n	3258 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    3252:	9801      	ldr	r0, [sp, #4]
    3254:	f000 f958 	bl	3508 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3258:	bf00      	nop
    325a:	b003      	add	sp, #12
    325c:	f85d fb04 	ldr.w	pc, [sp], #4

00003260 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    3260:	b500      	push	{lr}
    3262:	b083      	sub	sp, #12
    3264:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3266:	9b01      	ldr	r3, [sp, #4]
    3268:	2b00      	cmp	r3, #0
    326a:	d002      	beq.n	3272 <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    326c:	9801      	ldr	r0, [sp, #4]
    326e:	f000 f969 	bl	3544 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3272:	bf00      	nop
    3274:	b003      	add	sp, #12
    3276:	f85d fb04 	ldr.w	pc, [sp], #4

0000327a <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    327a:	b500      	push	{lr}
    327c:	b083      	sub	sp, #12
    327e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3280:	9b01      	ldr	r3, [sp, #4]
    3282:	2b00      	cmp	r3, #0
    3284:	d002      	beq.n	328c <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    3286:	9801      	ldr	r0, [sp, #4]
    3288:	f000 f978 	bl	357c <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    328c:	bf00      	nop
    328e:	b003      	add	sp, #12
    3290:	f85d fb04 	ldr.w	pc, [sp], #4

00003294 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3294:	b500      	push	{lr}
    3296:	b083      	sub	sp, #12
    3298:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    329a:	9b01      	ldr	r3, [sp, #4]
    329c:	2b00      	cmp	r3, #0
    329e:	d002      	beq.n	32a6 <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    32a0:	9801      	ldr	r0, [sp, #4]
    32a2:	f000 f989 	bl	35b8 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32a6:	bf00      	nop
    32a8:	b003      	add	sp, #12
    32aa:	f85d fb04 	ldr.w	pc, [sp], #4

000032ae <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    32ae:	b500      	push	{lr}
    32b0:	b083      	sub	sp, #12
    32b2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    32b4:	9b01      	ldr	r3, [sp, #4]
    32b6:	2b00      	cmp	r3, #0
    32b8:	d002      	beq.n	32c0 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    32ba:	9801      	ldr	r0, [sp, #4]
    32bc:	f000 f998 	bl	35f0 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32c0:	bf00      	nop
    32c2:	b003      	add	sp, #12
    32c4:	f85d fb04 	ldr.w	pc, [sp], #4

000032c8 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    32c8:	b500      	push	{lr}
    32ca:	b083      	sub	sp, #12
    32cc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    32ce:	9b01      	ldr	r3, [sp, #4]
    32d0:	2b00      	cmp	r3, #0
    32d2:	d002      	beq.n	32da <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    32d4:	9801      	ldr	r0, [sp, #4]
    32d6:	f000 f9a9 	bl	362c <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32da:	bf00      	nop
    32dc:	b003      	add	sp, #12
    32de:	f85d fb04 	ldr.w	pc, [sp], #4

000032e2 <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    32e2:	b500      	push	{lr}
    32e4:	b083      	sub	sp, #12
    32e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    32e8:	9b01      	ldr	r3, [sp, #4]
    32ea:	2b00      	cmp	r3, #0
    32ec:	d002      	beq.n	32f4 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    32ee:	9801      	ldr	r0, [sp, #4]
    32f0:	f000 f9e6 	bl	36c0 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    32f4:	bf00      	nop
    32f6:	b003      	add	sp, #12
    32f8:	f85d fb04 	ldr.w	pc, [sp], #4

000032fc <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    32fc:	b500      	push	{lr}
    32fe:	b083      	sub	sp, #12
    3300:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3302:	9b01      	ldr	r3, [sp, #4]
    3304:	2b00      	cmp	r3, #0
    3306:	d002      	beq.n	330e <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    3308:	9801      	ldr	r0, [sp, #4]
    330a:	f000 fa25 	bl	3758 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    330e:	bf00      	nop
    3310:	b003      	add	sp, #12
    3312:	f85d fb04 	ldr.w	pc, [sp], #4

00003316 <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3316:	b500      	push	{lr}
    3318:	b083      	sub	sp, #12
    331a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    331c:	9b01      	ldr	r3, [sp, #4]
    331e:	2b00      	cmp	r3, #0
    3320:	d002      	beq.n	3328 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    3322:	9801      	ldr	r0, [sp, #4]
    3324:	f000 fa2a 	bl	377c <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3328:	bf00      	nop
    332a:	b003      	add	sp, #12
    332c:	f85d fb04 	ldr.w	pc, [sp], #4

00003330 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    3330:	b500      	push	{lr}
    3332:	b083      	sub	sp, #12
    3334:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3336:	9b01      	ldr	r3, [sp, #4]
    3338:	2b00      	cmp	r3, #0
    333a:	d002      	beq.n	3342 <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    333c:	9801      	ldr	r0, [sp, #4]
    333e:	f000 fa3b 	bl	37b8 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3342:	bf00      	nop
    3344:	b003      	add	sp, #12
    3346:	f85d fb04 	ldr.w	pc, [sp], #4

0000334a <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    334a:	b500      	push	{lr}
    334c:	b083      	sub	sp, #12
    334e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3350:	9b01      	ldr	r3, [sp, #4]
    3352:	2b00      	cmp	r3, #0
    3354:	d002      	beq.n	335c <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    3356:	9801      	ldr	r0, [sp, #4]
    3358:	f000 fa56 	bl	3808 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    335c:	bf00      	nop
    335e:	b003      	add	sp, #12
    3360:	f85d fb04 	ldr.w	pc, [sp], #4

00003364 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    3364:	b500      	push	{lr}
    3366:	b083      	sub	sp, #12
    3368:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    336a:	9b01      	ldr	r3, [sp, #4]
    336c:	2b00      	cmp	r3, #0
    336e:	d002      	beq.n	3376 <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    3370:	9801      	ldr	r0, [sp, #4]
    3372:	f000 fa79 	bl	3868 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3376:	bf00      	nop
    3378:	b003      	add	sp, #12
    337a:	f85d fb04 	ldr.w	pc, [sp], #4

0000337e <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    337e:	b500      	push	{lr}
    3380:	b083      	sub	sp, #12
    3382:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3384:	9b01      	ldr	r3, [sp, #4]
    3386:	2b00      	cmp	r3, #0
    3388:	d002      	beq.n	3390 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    338a:	9801      	ldr	r0, [sp, #4]
    338c:	f000 fa8a 	bl	38a4 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3390:	bf00      	nop
    3392:	b003      	add	sp, #12
    3394:	f85d fb04 	ldr.w	pc, [sp], #4

00003398 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3398:	b084      	sub	sp, #16
    339a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    339c:	4b0b      	ldr	r3, [pc, #44]	; (33cc <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    339e:	795b      	ldrb	r3, [r3, #5]
    33a0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    33a2:	4b0b      	ldr	r3, [pc, #44]	; (33d0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    33a4:	695b      	ldr	r3, [r3, #20]
    33a6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    33a8:	9b02      	ldr	r3, [sp, #8]
    33aa:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    33ae:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    33b0:	9b03      	ldr	r3, [sp, #12]
    33b2:	061b      	lsls	r3, r3, #24
    33b4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    33b8:	9a02      	ldr	r2, [sp, #8]
    33ba:	4313      	orrs	r3, r2
    33bc:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    33be:	4a04      	ldr	r2, [pc, #16]	; (33d0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    33c0:	9b02      	ldr	r3, [sp, #8]
    33c2:	6153      	str	r3, [r2, #20]
}
    33c4:	bf00      	nop
    33c6:	b004      	add	sp, #16
    33c8:	4770      	bx	lr
    33ca:	bf00      	nop
    33cc:	0000b328 	.word	0x0000b328
    33d0:	40064000 	.word	0x40064000

000033d4 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    33d4:	b084      	sub	sp, #16
    33d6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    33d8:	9b01      	ldr	r3, [sp, #4]
    33da:	685b      	ldr	r3, [r3, #4]
    33dc:	4a0b      	ldr	r2, [pc, #44]	; (340c <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    33de:	5cd3      	ldrb	r3, [r2, r3]
    33e0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    33e2:	4b0b      	ldr	r3, [pc, #44]	; (3410 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    33e4:	695b      	ldr	r3, [r3, #20]
    33e6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    33e8:	9b02      	ldr	r3, [sp, #8]
    33ea:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    33ee:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    33f0:	9b03      	ldr	r3, [sp, #12]
    33f2:	061b      	lsls	r3, r3, #24
    33f4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    33f8:	9a02      	ldr	r2, [sp, #8]
    33fa:	4313      	orrs	r3, r2
    33fc:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    33fe:	4a04      	ldr	r2, [pc, #16]	; (3410 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    3400:	9b02      	ldr	r3, [sp, #8]
    3402:	6153      	str	r3, [r2, #20]
}
    3404:	bf00      	nop
    3406:	b004      	add	sp, #16
    3408:	4770      	bx	lr
    340a:	bf00      	nop
    340c:	0000b328 	.word	0x0000b328
    3410:	40064000 	.word	0x40064000

00003414 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3414:	b084      	sub	sp, #16
    3416:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3418:	9b01      	ldr	r3, [sp, #4]
    341a:	685b      	ldr	r3, [r3, #4]
    341c:	4a0b      	ldr	r2, [pc, #44]	; (344c <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    341e:	5cd3      	ldrb	r3, [r2, r3]
    3420:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    3422:	4b0b      	ldr	r3, [pc, #44]	; (3450 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3424:	699b      	ldr	r3, [r3, #24]
    3426:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    3428:	9b02      	ldr	r3, [sp, #8]
    342a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    342e:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    3430:	9b03      	ldr	r3, [sp, #12]
    3432:	061b      	lsls	r3, r3, #24
    3434:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3438:	9a02      	ldr	r2, [sp, #8]
    343a:	4313      	orrs	r3, r2
    343c:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    343e:	4a04      	ldr	r2, [pc, #16]	; (3450 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3440:	9b02      	ldr	r3, [sp, #8]
    3442:	6193      	str	r3, [r2, #24]
}
    3444:	bf00      	nop
    3446:	b004      	add	sp, #16
    3448:	4770      	bx	lr
    344a:	bf00      	nop
    344c:	0000b328 	.word	0x0000b328
    3450:	40064000 	.word	0x40064000

00003454 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3454:	b084      	sub	sp, #16
    3456:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3458:	4b0b      	ldr	r3, [pc, #44]	; (3488 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    345a:	795b      	ldrb	r3, [r3, #5]
    345c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    345e:	4b0b      	ldr	r3, [pc, #44]	; (348c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    3460:	69db      	ldr	r3, [r3, #28]
    3462:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    3464:	9b02      	ldr	r3, [sp, #8]
    3466:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    346a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    346c:	9b03      	ldr	r3, [sp, #12]
    346e:	061b      	lsls	r3, r3, #24
    3470:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3474:	9a02      	ldr	r2, [sp, #8]
    3476:	4313      	orrs	r3, r2
    3478:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    347a:	4a04      	ldr	r2, [pc, #16]	; (348c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    347c:	9b02      	ldr	r3, [sp, #8]
    347e:	61d3      	str	r3, [r2, #28]
}
    3480:	bf00      	nop
    3482:	b004      	add	sp, #16
    3484:	4770      	bx	lr
    3486:	bf00      	nop
    3488:	0000b328 	.word	0x0000b328
    348c:	40064000 	.word	0x40064000

00003490 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3490:	b084      	sub	sp, #16
    3492:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3494:	9b01      	ldr	r3, [sp, #4]
    3496:	685b      	ldr	r3, [r3, #4]
    3498:	4a0b      	ldr	r2, [pc, #44]	; (34c8 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    349a:	5cd3      	ldrb	r3, [r2, r3]
    349c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    349e:	4b0b      	ldr	r3, [pc, #44]	; (34cc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    34a0:	69db      	ldr	r3, [r3, #28]
    34a2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    34a4:	9b02      	ldr	r3, [sp, #8]
    34a6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    34aa:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    34ac:	9b03      	ldr	r3, [sp, #12]
    34ae:	061b      	lsls	r3, r3, #24
    34b0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    34b4:	9a02      	ldr	r2, [sp, #8]
    34b6:	4313      	orrs	r3, r2
    34b8:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    34ba:	4a04      	ldr	r2, [pc, #16]	; (34cc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    34bc:	9b02      	ldr	r3, [sp, #8]
    34be:	61d3      	str	r3, [r2, #28]
}
    34c0:	bf00      	nop
    34c2:	b004      	add	sp, #16
    34c4:	4770      	bx	lr
    34c6:	bf00      	nop
    34c8:	0000b328 	.word	0x0000b328
    34cc:	40064000 	.word	0x40064000

000034d0 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    34d0:	b084      	sub	sp, #16
    34d2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    34d4:	4b0a      	ldr	r3, [pc, #40]	; (3500 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    34d6:	7b9b      	ldrb	r3, [r3, #14]
    34d8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    34da:	4b0a      	ldr	r3, [pc, #40]	; (3504 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    34dc:	691b      	ldr	r3, [r3, #16]
    34de:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    34e0:	9b02      	ldr	r3, [sp, #8]
    34e2:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    34e6:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    34e8:	9b03      	ldr	r3, [sp, #12]
    34ea:	011b      	lsls	r3, r3, #4
    34ec:	9a02      	ldr	r2, [sp, #8]
    34ee:	4313      	orrs	r3, r2
    34f0:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    34f2:	4a04      	ldr	r2, [pc, #16]	; (3504 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    34f4:	9b02      	ldr	r3, [sp, #8]
    34f6:	6113      	str	r3, [r2, #16]
}
    34f8:	bf00      	nop
    34fa:	b004      	add	sp, #16
    34fc:	4770      	bx	lr
    34fe:	bf00      	nop
    3500:	0000b2d0 	.word	0x0000b2d0
    3504:	40048000 	.word	0x40048000

00003508 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3508:	b084      	sub	sp, #16
    350a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    350c:	9b01      	ldr	r3, [sp, #4]
    350e:	685b      	ldr	r3, [r3, #4]
    3510:	4a0a      	ldr	r2, [pc, #40]	; (353c <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    3512:	5cd3      	ldrb	r3, [r2, r3]
    3514:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    3516:	4b0a      	ldr	r3, [pc, #40]	; (3540 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3518:	691b      	ldr	r3, [r3, #16]
    351a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    351c:	9b02      	ldr	r3, [sp, #8]
    351e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    3522:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3524:	9b03      	ldr	r3, [sp, #12]
    3526:	011b      	lsls	r3, r3, #4
    3528:	9a02      	ldr	r2, [sp, #8]
    352a:	4313      	orrs	r3, r2
    352c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    352e:	4a04      	ldr	r2, [pc, #16]	; (3540 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3530:	9b02      	ldr	r3, [sp, #8]
    3532:	6113      	str	r3, [r2, #16]
}
    3534:	bf00      	nop
    3536:	b004      	add	sp, #16
    3538:	4770      	bx	lr
    353a:	bf00      	nop
    353c:	0000b2d0 	.word	0x0000b2d0
    3540:	40048000 	.word	0x40048000

00003544 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3544:	b084      	sub	sp, #16
    3546:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3548:	4b0a      	ldr	r3, [pc, #40]	; (3574 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    354a:	785b      	ldrb	r3, [r3, #1]
    354c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    354e:	4b0a      	ldr	r3, [pc, #40]	; (3578 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    3550:	691b      	ldr	r3, [r3, #16]
    3552:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    3554:	9b02      	ldr	r3, [sp, #8]
    3556:	f023 030c 	bic.w	r3, r3, #12
    355a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    355c:	9b03      	ldr	r3, [sp, #12]
    355e:	009b      	lsls	r3, r3, #2
    3560:	9a02      	ldr	r2, [sp, #8]
    3562:	4313      	orrs	r3, r2
    3564:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    3566:	4a04      	ldr	r2, [pc, #16]	; (3578 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    3568:	9b02      	ldr	r3, [sp, #8]
    356a:	6113      	str	r3, [r2, #16]
}
    356c:	bf00      	nop
    356e:	b004      	add	sp, #16
    3570:	4770      	bx	lr
    3572:	bf00      	nop
    3574:	0000b388 	.word	0x0000b388
    3578:	40048000 	.word	0x40048000

0000357c <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    357c:	b084      	sub	sp, #16
    357e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3580:	9b01      	ldr	r3, [sp, #4]
    3582:	685b      	ldr	r3, [r3, #4]
    3584:	4a0a      	ldr	r2, [pc, #40]	; (35b0 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    3586:	5cd3      	ldrb	r3, [r2, r3]
    3588:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    358a:	4b0a      	ldr	r3, [pc, #40]	; (35b4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    358c:	691b      	ldr	r3, [r3, #16]
    358e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    3590:	9b02      	ldr	r3, [sp, #8]
    3592:	f023 030c 	bic.w	r3, r3, #12
    3596:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3598:	9b03      	ldr	r3, [sp, #12]
    359a:	009b      	lsls	r3, r3, #2
    359c:	9a02      	ldr	r2, [sp, #8]
    359e:	4313      	orrs	r3, r2
    35a0:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    35a2:	4a04      	ldr	r2, [pc, #16]	; (35b4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    35a4:	9b02      	ldr	r3, [sp, #8]
    35a6:	6113      	str	r3, [r2, #16]
}
    35a8:	bf00      	nop
    35aa:	b004      	add	sp, #16
    35ac:	4770      	bx	lr
    35ae:	bf00      	nop
    35b0:	0000b388 	.word	0x0000b388
    35b4:	40048000 	.word	0x40048000

000035b8 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    35b8:	b084      	sub	sp, #16
    35ba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    35bc:	4b0a      	ldr	r3, [pc, #40]	; (35e8 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    35be:	795b      	ldrb	r3, [r3, #5]
    35c0:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    35c2:	4b0a      	ldr	r3, [pc, #40]	; (35ec <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    35c4:	6a1b      	ldr	r3, [r3, #32]
    35c6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    35c8:	9b02      	ldr	r3, [sp, #8]
    35ca:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    35ce:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    35d0:	9b03      	ldr	r3, [sp, #12]
    35d2:	061b      	lsls	r3, r3, #24
    35d4:	9a02      	ldr	r2, [sp, #8]
    35d6:	4313      	orrs	r3, r2
    35d8:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    35da:	4a04      	ldr	r2, [pc, #16]	; (35ec <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    35dc:	9b02      	ldr	r3, [sp, #8]
    35de:	6213      	str	r3, [r2, #32]
}
    35e0:	bf00      	nop
    35e2:	b004      	add	sp, #16
    35e4:	4770      	bx	lr
    35e6:	bf00      	nop
    35e8:	0000b328 	.word	0x0000b328
    35ec:	40064000 	.word	0x40064000

000035f0 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    35f0:	b084      	sub	sp, #16
    35f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    35f4:	9b01      	ldr	r3, [sp, #4]
    35f6:	685b      	ldr	r3, [r3, #4]
    35f8:	4a0a      	ldr	r2, [pc, #40]	; (3624 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    35fa:	5cd3      	ldrb	r3, [r2, r3]
    35fc:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    35fe:	4b0a      	ldr	r3, [pc, #40]	; (3628 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3600:	6a1b      	ldr	r3, [r3, #32]
    3602:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    3604:	9b02      	ldr	r3, [sp, #8]
    3606:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    360a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    360c:	9b03      	ldr	r3, [sp, #12]
    360e:	061b      	lsls	r3, r3, #24
    3610:	9a02      	ldr	r2, [sp, #8]
    3612:	4313      	orrs	r3, r2
    3614:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    3616:	4a04      	ldr	r2, [pc, #16]	; (3628 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    3618:	9b02      	ldr	r3, [sp, #8]
    361a:	6213      	str	r3, [r2, #32]
}
    361c:	bf00      	nop
    361e:	b004      	add	sp, #16
    3620:	4770      	bx	lr
    3622:	bf00      	nop
    3624:	0000b328 	.word	0x0000b328
    3628:	40064000 	.word	0x40064000

0000362c <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    362c:	b086      	sub	sp, #24
    362e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3630:	4b20      	ldr	r3, [pc, #128]	; (36b4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    3632:	795b      	ldrb	r3, [r3, #5]
    3634:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3636:	9b01      	ldr	r3, [sp, #4]
    3638:	681a      	ldr	r2, [r3, #0]
    363a:	491f      	ldr	r1, [pc, #124]	; (36b8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    363c:	4613      	mov	r3, r2
    363e:	00db      	lsls	r3, r3, #3
    3640:	4413      	add	r3, r2
    3642:	440b      	add	r3, r1
    3644:	781b      	ldrb	r3, [r3, #0]
    3646:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    3648:	4b1c      	ldr	r3, [pc, #112]	; (36bc <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    364a:	68db      	ldr	r3, [r3, #12]
    364c:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    364e:	9b03      	ldr	r3, [sp, #12]
    3650:	2b03      	cmp	r3, #3
    3652:	d813      	bhi.n	367c <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3654:	9b03      	ldr	r3, [sp, #12]
    3656:	005b      	lsls	r3, r3, #1
    3658:	3318      	adds	r3, #24
    365a:	2203      	movs	r2, #3
    365c:	fa02 f303 	lsl.w	r3, r2, r3
    3660:	43db      	mvns	r3, r3
    3662:	9a05      	ldr	r2, [sp, #20]
    3664:	4013      	ands	r3, r2
    3666:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3668:	9b03      	ldr	r3, [sp, #12]
    366a:	005b      	lsls	r3, r3, #1
    366c:	3318      	adds	r3, #24
    366e:	9a04      	ldr	r2, [sp, #16]
    3670:	fa02 f303 	lsl.w	r3, r2, r3
    3674:	9a05      	ldr	r2, [sp, #20]
    3676:	4313      	orrs	r3, r2
    3678:	9305      	str	r3, [sp, #20]
    367a:	e014      	b.n	36a6 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    367c:	9b03      	ldr	r3, [sp, #12]
    367e:	3b04      	subs	r3, #4
    3680:	005b      	lsls	r3, r3, #1
    3682:	3310      	adds	r3, #16
    3684:	2203      	movs	r2, #3
    3686:	fa02 f303 	lsl.w	r3, r2, r3
    368a:	43db      	mvns	r3, r3
    368c:	9a05      	ldr	r2, [sp, #20]
    368e:	4013      	ands	r3, r2
    3690:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3692:	9b03      	ldr	r3, [sp, #12]
    3694:	3b04      	subs	r3, #4
    3696:	005b      	lsls	r3, r3, #1
    3698:	3310      	adds	r3, #16
    369a:	9a04      	ldr	r2, [sp, #16]
    369c:	fa02 f303 	lsl.w	r3, r2, r3
    36a0:	9a05      	ldr	r2, [sp, #20]
    36a2:	4313      	orrs	r3, r2
    36a4:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    36a6:	4a05      	ldr	r2, [pc, #20]	; (36bc <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    36a8:	9b05      	ldr	r3, [sp, #20]
    36aa:	60d3      	str	r3, [r2, #12]
}
    36ac:	bf00      	nop
    36ae:	b006      	add	sp, #24
    36b0:	4770      	bx	lr
    36b2:	bf00      	nop
    36b4:	0000b2d0 	.word	0x0000b2d0
    36b8:	0000afc0 	.word	0x0000afc0
    36bc:	40048000 	.word	0x40048000

000036c0 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    36c0:	b086      	sub	sp, #24
    36c2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    36c4:	9b01      	ldr	r3, [sp, #4]
    36c6:	685b      	ldr	r3, [r3, #4]
    36c8:	4a20      	ldr	r2, [pc, #128]	; (374c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    36ca:	5cd3      	ldrb	r3, [r2, r3]
    36cc:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    36ce:	9b01      	ldr	r3, [sp, #4]
    36d0:	681a      	ldr	r2, [r3, #0]
    36d2:	491f      	ldr	r1, [pc, #124]	; (3750 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    36d4:	4613      	mov	r3, r2
    36d6:	00db      	lsls	r3, r3, #3
    36d8:	4413      	add	r3, r2
    36da:	440b      	add	r3, r1
    36dc:	781b      	ldrb	r3, [r3, #0]
    36de:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    36e0:	4b1c      	ldr	r3, [pc, #112]	; (3754 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    36e2:	68db      	ldr	r3, [r3, #12]
    36e4:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    36e6:	9b03      	ldr	r3, [sp, #12]
    36e8:	2b03      	cmp	r3, #3
    36ea:	d813      	bhi.n	3714 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    36ec:	9b03      	ldr	r3, [sp, #12]
    36ee:	005b      	lsls	r3, r3, #1
    36f0:	3318      	adds	r3, #24
    36f2:	2203      	movs	r2, #3
    36f4:	fa02 f303 	lsl.w	r3, r2, r3
    36f8:	43db      	mvns	r3, r3
    36fa:	9a05      	ldr	r2, [sp, #20]
    36fc:	4013      	ands	r3, r2
    36fe:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    3700:	9b03      	ldr	r3, [sp, #12]
    3702:	005b      	lsls	r3, r3, #1
    3704:	3318      	adds	r3, #24
    3706:	9a04      	ldr	r2, [sp, #16]
    3708:	fa02 f303 	lsl.w	r3, r2, r3
    370c:	9a05      	ldr	r2, [sp, #20]
    370e:	4313      	orrs	r3, r2
    3710:	9305      	str	r3, [sp, #20]
    3712:	e014      	b.n	373e <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3714:	9b03      	ldr	r3, [sp, #12]
    3716:	3b04      	subs	r3, #4
    3718:	005b      	lsls	r3, r3, #1
    371a:	3310      	adds	r3, #16
    371c:	2203      	movs	r2, #3
    371e:	fa02 f303 	lsl.w	r3, r2, r3
    3722:	43db      	mvns	r3, r3
    3724:	9a05      	ldr	r2, [sp, #20]
    3726:	4013      	ands	r3, r2
    3728:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    372a:	9b03      	ldr	r3, [sp, #12]
    372c:	3b04      	subs	r3, #4
    372e:	005b      	lsls	r3, r3, #1
    3730:	3310      	adds	r3, #16
    3732:	9a04      	ldr	r2, [sp, #16]
    3734:	fa02 f303 	lsl.w	r3, r2, r3
    3738:	9a05      	ldr	r2, [sp, #20]
    373a:	4313      	orrs	r3, r2
    373c:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    373e:	4a05      	ldr	r2, [pc, #20]	; (3754 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3740:	9b05      	ldr	r3, [sp, #20]
    3742:	60d3      	str	r3, [r2, #12]
}
    3744:	bf00      	nop
    3746:	b006      	add	sp, #24
    3748:	4770      	bx	lr
    374a:	bf00      	nop
    374c:	0000b2d0 	.word	0x0000b2d0
    3750:	0000afc0 	.word	0x0000afc0
    3754:	40048000 	.word	0x40048000

00003758 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3758:	b084      	sub	sp, #16
    375a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    375c:	4b06      	ldr	r3, [pc, #24]	; (3778 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    375e:	685b      	ldr	r3, [r3, #4]
    3760:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    3762:	9b03      	ldr	r3, [sp, #12]
    3764:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    3768:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    376a:	4a03      	ldr	r2, [pc, #12]	; (3778 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    376c:	9b03      	ldr	r3, [sp, #12]
    376e:	6053      	str	r3, [r2, #4]
}
    3770:	bf00      	nop
    3772:	b004      	add	sp, #16
    3774:	4770      	bx	lr
    3776:	bf00      	nop
    3778:	40048000 	.word	0x40048000

0000377c <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    377c:	b084      	sub	sp, #16
    377e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3780:	9b01      	ldr	r3, [sp, #4]
    3782:	685b      	ldr	r3, [r3, #4]
    3784:	4a0a      	ldr	r2, [pc, #40]	; (37b0 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    3786:	5cd3      	ldrb	r3, [r2, r3]
    3788:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    378a:	4b0a      	ldr	r3, [pc, #40]	; (37b4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    378c:	685b      	ldr	r3, [r3, #4]
    378e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    3790:	9b02      	ldr	r3, [sp, #8]
    3792:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3796:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    3798:	9b03      	ldr	r3, [sp, #12]
    379a:	011b      	lsls	r3, r3, #4
    379c:	9a02      	ldr	r2, [sp, #8]
    379e:	4313      	orrs	r3, r2
    37a0:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    37a2:	4a04      	ldr	r2, [pc, #16]	; (37b4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    37a4:	9b02      	ldr	r3, [sp, #8]
    37a6:	6053      	str	r3, [r2, #4]
}
    37a8:	bf00      	nop
    37aa:	b004      	add	sp, #16
    37ac:	4770      	bx	lr
    37ae:	bf00      	nop
    37b0:	0000b2d0 	.word	0x0000b2d0
    37b4:	40048000 	.word	0x40048000

000037b8 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    37b8:	b084      	sub	sp, #16
    37ba:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    37bc:	9b01      	ldr	r3, [sp, #4]
    37be:	681a      	ldr	r2, [r3, #0]
    37c0:	490f      	ldr	r1, [pc, #60]	; (3800 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    37c2:	4613      	mov	r3, r2
    37c4:	00db      	lsls	r3, r3, #3
    37c6:	4413      	add	r3, r2
    37c8:	440b      	add	r3, r1
    37ca:	3304      	adds	r3, #4
    37cc:	781b      	ldrb	r3, [r3, #0]
    37ce:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    37d0:	4a0c      	ldr	r2, [pc, #48]	; (3804 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    37d2:	9b03      	ldr	r3, [sp, #12]
    37d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    37d8:	490a      	ldr	r1, [pc, #40]	; (3804 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    37da:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    37de:	9b03      	ldr	r3, [sp, #12]
    37e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    37e4:	4a07      	ldr	r2, [pc, #28]	; (3804 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    37e6:	9b03      	ldr	r3, [sp, #12]
    37e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    37ec:	4905      	ldr	r1, [pc, #20]	; (3804 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    37ee:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    37f2:	9b03      	ldr	r3, [sp, #12]
    37f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    37f8:	bf00      	nop
    37fa:	b004      	add	sp, #16
    37fc:	4770      	bx	lr
    37fe:	bf00      	nop
    3800:	0000afc0 	.word	0x0000afc0
    3804:	40065000 	.word	0x40065000

00003808 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3808:	b086      	sub	sp, #24
    380a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    380c:	9b01      	ldr	r3, [sp, #4]
    380e:	681a      	ldr	r2, [r3, #0]
    3810:	4912      	ldr	r1, [pc, #72]	; (385c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    3812:	4613      	mov	r3, r2
    3814:	00db      	lsls	r3, r3, #3
    3816:	4413      	add	r3, r2
    3818:	440b      	add	r3, r1
    381a:	3304      	adds	r3, #4
    381c:	781b      	ldrb	r3, [r3, #0]
    381e:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3820:	9b01      	ldr	r3, [sp, #4]
    3822:	685b      	ldr	r3, [r3, #4]
    3824:	4a0e      	ldr	r2, [pc, #56]	; (3860 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    3826:	5cd3      	ldrb	r3, [r2, r3]
    3828:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    382a:	4a0e      	ldr	r2, [pc, #56]	; (3864 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    382c:	9b05      	ldr	r3, [sp, #20]
    382e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3832:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    3834:	9b03      	ldr	r3, [sp, #12]
    3836:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    383a:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    383c:	9b04      	ldr	r3, [sp, #16]
    383e:	061b      	lsls	r3, r3, #24
    3840:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    3844:	9a03      	ldr	r2, [sp, #12]
    3846:	4313      	orrs	r3, r2
    3848:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    384a:	4906      	ldr	r1, [pc, #24]	; (3864 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    384c:	9b05      	ldr	r3, [sp, #20]
    384e:	9a03      	ldr	r2, [sp, #12]
    3850:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3854:	bf00      	nop
    3856:	b006      	add	sp, #24
    3858:	4770      	bx	lr
    385a:	bf00      	nop
    385c:	0000afc0 	.word	0x0000afc0
    3860:	0000b358 	.word	0x0000b358
    3864:	40065000 	.word	0x40065000

00003868 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3868:	b084      	sub	sp, #16
    386a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    386c:	4b0b      	ldr	r3, [pc, #44]	; (389c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    386e:	7f1b      	ldrb	r3, [r3, #28]
    3870:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    3872:	4b0b      	ldr	r3, [pc, #44]	; (38a0 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3874:	685b      	ldr	r3, [r3, #4]
    3876:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    3878:	9b02      	ldr	r3, [sp, #8]
    387a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    387e:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3880:	9b03      	ldr	r3, [sp, #12]
    3882:	031b      	lsls	r3, r3, #12
    3884:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    3888:	9a02      	ldr	r2, [sp, #8]
    388a:	4313      	orrs	r3, r2
    388c:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    388e:	4a04      	ldr	r2, [pc, #16]	; (38a0 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3890:	9b02      	ldr	r3, [sp, #8]
    3892:	6053      	str	r3, [r2, #4]
}
    3894:	bf00      	nop
    3896:	b004      	add	sp, #16
    3898:	4770      	bx	lr
    389a:	bf00      	nop
    389c:	0000b2d0 	.word	0x0000b2d0
    38a0:	40048000 	.word	0x40048000

000038a4 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    38a4:	b084      	sub	sp, #16
    38a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    38a8:	9b01      	ldr	r3, [sp, #4]
    38aa:	685b      	ldr	r3, [r3, #4]
    38ac:	4a0b      	ldr	r2, [pc, #44]	; (38dc <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    38ae:	5cd3      	ldrb	r3, [r2, r3]
    38b0:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    38b2:	4b0b      	ldr	r3, [pc, #44]	; (38e0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    38b4:	685b      	ldr	r3, [r3, #4]
    38b6:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    38b8:	9b02      	ldr	r3, [sp, #8]
    38ba:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    38be:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    38c0:	9b03      	ldr	r3, [sp, #12]
    38c2:	031b      	lsls	r3, r3, #12
    38c4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    38c8:	9a02      	ldr	r2, [sp, #8]
    38ca:	4313      	orrs	r3, r2
    38cc:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    38ce:	4a04      	ldr	r2, [pc, #16]	; (38e0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    38d0:	9b02      	ldr	r3, [sp, #8]
    38d2:	6053      	str	r3, [r2, #4]
}
    38d4:	bf00      	nop
    38d6:	b004      	add	sp, #16
    38d8:	4770      	bx	lr
    38da:	bf00      	nop
    38dc:	0000b2d0 	.word	0x0000b2d0
    38e0:	40048000 	.word	0x40048000

000038e4 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    38e4:	b500      	push	{lr}
    38e6:	b085      	sub	sp, #20
    38e8:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    38ea:	2300      	movs	r3, #0
    38ec:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    38f0:	9b01      	ldr	r3, [sp, #4]
    38f2:	2b00      	cmp	r3, #0
    38f4:	d037      	beq.n	3966 <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    38f6:	2300      	movs	r3, #0
    38f8:	9303      	str	r3, [sp, #12]
    38fa:	e02b      	b.n	3954 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    38fc:	4b29      	ldr	r3, [pc, #164]	; (39a4 <DisableSafeClock+0xc0>)
    38fe:	6819      	ldr	r1, [r3, #0]
    3900:	9a03      	ldr	r2, [sp, #12]
    3902:	4613      	mov	r3, r2
    3904:	005b      	lsls	r3, r3, #1
    3906:	4413      	add	r3, r2
    3908:	009b      	lsls	r3, r3, #2
    390a:	440b      	add	r3, r1
    390c:	3314      	adds	r3, #20
    390e:	681b      	ldr	r3, [r3, #0]
    3910:	2b05      	cmp	r3, #5
    3912:	d11c      	bne.n	394e <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    3914:	2301      	movs	r3, #1
    3916:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    391a:	4b22      	ldr	r3, [pc, #136]	; (39a4 <DisableSafeClock+0xc0>)
    391c:	6819      	ldr	r1, [r3, #0]
    391e:	9a03      	ldr	r2, [sp, #12]
    3920:	4613      	mov	r3, r2
    3922:	005b      	lsls	r3, r3, #1
    3924:	4413      	add	r3, r2
    3926:	009b      	lsls	r3, r3, #2
    3928:	440b      	add	r3, r1
    392a:	3318      	adds	r3, #24
    392c:	881b      	ldrh	r3, [r3, #0]
    392e:	2b00      	cmp	r3, #0
    3930:	d118      	bne.n	3964 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3932:	4b1d      	ldr	r3, [pc, #116]	; (39a8 <DisableSafeClock+0xc4>)
    3934:	791b      	ldrb	r3, [r3, #4]
    3936:	4619      	mov	r1, r3
    3938:	4a1c      	ldr	r2, [pc, #112]	; (39ac <DisableSafeClock+0xc8>)
    393a:	460b      	mov	r3, r1
    393c:	005b      	lsls	r3, r3, #1
    393e:	440b      	add	r3, r1
    3940:	009b      	lsls	r3, r3, #2
    3942:	4413      	add	r3, r2
    3944:	3308      	adds	r3, #8
    3946:	681b      	ldr	r3, [r3, #0]
    3948:	2005      	movs	r0, #5
    394a:	4798      	blx	r3
                }
                break;
    394c:	e00a      	b.n	3964 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    394e:	9b03      	ldr	r3, [sp, #12]
    3950:	3301      	adds	r3, #1
    3952:	9303      	str	r3, [sp, #12]
    3954:	4b13      	ldr	r3, [pc, #76]	; (39a4 <DisableSafeClock+0xc0>)
    3956:	681b      	ldr	r3, [r3, #0]
    3958:	7a1b      	ldrb	r3, [r3, #8]
    395a:	461a      	mov	r2, r3
    395c:	9b03      	ldr	r3, [sp, #12]
    395e:	4293      	cmp	r3, r2
    3960:	d3cc      	bcc.n	38fc <DisableSafeClock+0x18>
    3962:	e000      	b.n	3966 <DisableSafeClock+0x82>
                break;
    3964:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    3966:	f89d 300b 	ldrb.w	r3, [sp, #11]
    396a:	f083 0301 	eor.w	r3, r3, #1
    396e:	b2db      	uxtb	r3, r3
    3970:	2b00      	cmp	r3, #0
    3972:	d013      	beq.n	399c <DisableSafeClock+0xb8>
    3974:	4b0e      	ldr	r3, [pc, #56]	; (39b0 <DisableSafeClock+0xcc>)
    3976:	781b      	ldrb	r3, [r3, #0]
    3978:	f083 0301 	eor.w	r3, r3, #1
    397c:	b2db      	uxtb	r3, r3
    397e:	2b00      	cmp	r3, #0
    3980:	d00c      	beq.n	399c <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3982:	4b09      	ldr	r3, [pc, #36]	; (39a8 <DisableSafeClock+0xc4>)
    3984:	791b      	ldrb	r3, [r3, #4]
    3986:	4619      	mov	r1, r3
    3988:	4a08      	ldr	r2, [pc, #32]	; (39ac <DisableSafeClock+0xc8>)
    398a:	460b      	mov	r3, r1
    398c:	005b      	lsls	r3, r3, #1
    398e:	440b      	add	r3, r1
    3990:	009b      	lsls	r3, r3, #2
    3992:	4413      	add	r3, r2
    3994:	3308      	adds	r3, #8
    3996:	681b      	ldr	r3, [r3, #0]
    3998:	2005      	movs	r0, #5
    399a:	4798      	blx	r3
    }
}
    399c:	bf00      	nop
    399e:	b005      	add	sp, #20
    39a0:	f85d fb04 	ldr.w	pc, [sp], #4
    39a4:	1fff8bc8 	.word	0x1fff8bc8
    39a8:	0000af50 	.word	0x0000af50
    39ac:	0000b580 	.word	0x0000b580
    39b0:	1fff8b18 	.word	0x1fff8b18

000039b4 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    39b4:	4b06      	ldr	r3, [pc, #24]	; (39d0 <SetFircToResetValue_TrustedCall+0x1c>)
    39b6:	2200      	movs	r2, #0
    39b8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    39bc:	4b04      	ldr	r3, [pc, #16]	; (39d0 <SetFircToResetValue_TrustedCall+0x1c>)
    39be:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    39c2:	4a03      	ldr	r2, [pc, #12]	; (39d0 <SetFircToResetValue_TrustedCall+0x1c>)
    39c4:	f043 0301 	orr.w	r3, r3, #1
    39c8:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    39cc:	bf00      	nop
    39ce:	4770      	bx	lr
    39d0:	40064000 	.word	0x40064000

000039d4 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    39d4:	b084      	sub	sp, #16
    39d6:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    39d8:	2303      	movs	r3, #3
    39da:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    39dc:	2300      	movs	r3, #0
    39de:	9302      	str	r3, [sp, #8]
    39e0:	e028      	b.n	3a34 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    39e2:	9b01      	ldr	r3, [sp, #4]
    39e4:	9a02      	ldr	r2, [sp, #8]
    39e6:	320d      	adds	r2, #13
    39e8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    39ec:	2b28      	cmp	r3, #40	; 0x28
    39ee:	d10b      	bne.n	3a08 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    39f0:	9a01      	ldr	r2, [sp, #4]
    39f2:	9b02      	ldr	r3, [sp, #8]
    39f4:	330d      	adds	r3, #13
    39f6:	00db      	lsls	r3, r3, #3
    39f8:	4413      	add	r3, r2
    39fa:	685b      	ldr	r3, [r3, #4]
    39fc:	4a2b      	ldr	r2, [pc, #172]	; (3aac <SetSimLpoclksRegister_TrustedCall+0xd8>)
    39fe:	5cd3      	ldrb	r3, [r2, r3]
    3a00:	011b      	lsls	r3, r3, #4
    3a02:	9a03      	ldr	r2, [sp, #12]
    3a04:	4313      	orrs	r3, r2
    3a06:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    3a08:	9b01      	ldr	r3, [sp, #4]
    3a0a:	9a02      	ldr	r2, [sp, #8]
    3a0c:	320d      	adds	r2, #13
    3a0e:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3a12:	2b29      	cmp	r3, #41	; 0x29
    3a14:	d10b      	bne.n	3a2e <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3a16:	9a01      	ldr	r2, [sp, #4]
    3a18:	9b02      	ldr	r3, [sp, #8]
    3a1a:	330d      	adds	r3, #13
    3a1c:	00db      	lsls	r3, r3, #3
    3a1e:	4413      	add	r3, r2
    3a20:	685b      	ldr	r3, [r3, #4]
    3a22:	4a23      	ldr	r2, [pc, #140]	; (3ab0 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    3a24:	5cd3      	ldrb	r3, [r2, r3]
    3a26:	009b      	lsls	r3, r3, #2
    3a28:	9a03      	ldr	r2, [sp, #12]
    3a2a:	4313      	orrs	r3, r2
    3a2c:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3a2e:	9b02      	ldr	r3, [sp, #8]
    3a30:	3301      	adds	r3, #1
    3a32:	9302      	str	r3, [sp, #8]
    3a34:	9b01      	ldr	r3, [sp, #4]
    3a36:	7adb      	ldrb	r3, [r3, #11]
    3a38:	461a      	mov	r2, r3
    3a3a:	9b02      	ldr	r3, [sp, #8]
    3a3c:	4293      	cmp	r3, r2
    3a3e:	d3d0      	bcc.n	39e2 <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3a40:	2300      	movs	r3, #0
    3a42:	9302      	str	r3, [sp, #8]
    3a44:	e026      	b.n	3a94 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    3a46:	9a01      	ldr	r2, [sp, #4]
    3a48:	9b02      	ldr	r3, [sp, #8]
    3a4a:	334e      	adds	r3, #78	; 0x4e
    3a4c:	00db      	lsls	r3, r3, #3
    3a4e:	4413      	add	r3, r2
    3a50:	685b      	ldr	r3, [r3, #4]
    3a52:	2b12      	cmp	r3, #18
    3a54:	d109      	bne.n	3a6a <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3a56:	9a01      	ldr	r2, [sp, #4]
    3a58:	9b02      	ldr	r3, [sp, #8]
    3a5a:	334e      	adds	r3, #78	; 0x4e
    3a5c:	00db      	lsls	r3, r3, #3
    3a5e:	4413      	add	r3, r2
    3a60:	891b      	ldrh	r3, [r3, #8]
    3a62:	005b      	lsls	r3, r3, #1
    3a64:	9a03      	ldr	r2, [sp, #12]
    3a66:	4313      	orrs	r3, r2
    3a68:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    3a6a:	9a01      	ldr	r2, [sp, #4]
    3a6c:	9b02      	ldr	r3, [sp, #8]
    3a6e:	334e      	adds	r3, #78	; 0x4e
    3a70:	00db      	lsls	r3, r3, #3
    3a72:	4413      	add	r3, r2
    3a74:	685b      	ldr	r3, [r3, #4]
    3a76:	2b13      	cmp	r3, #19
    3a78:	d109      	bne.n	3a8e <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3a7a:	9a01      	ldr	r2, [sp, #4]
    3a7c:	9b02      	ldr	r3, [sp, #8]
    3a7e:	334e      	adds	r3, #78	; 0x4e
    3a80:	00db      	lsls	r3, r3, #3
    3a82:	4413      	add	r3, r2
    3a84:	891b      	ldrh	r3, [r3, #8]
    3a86:	461a      	mov	r2, r3
    3a88:	9b03      	ldr	r3, [sp, #12]
    3a8a:	4313      	orrs	r3, r2
    3a8c:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3a8e:	9b02      	ldr	r3, [sp, #8]
    3a90:	3301      	adds	r3, #1
    3a92:	9302      	str	r3, [sp, #8]
    3a94:	9b01      	ldr	r3, [sp, #4]
    3a96:	7c1b      	ldrb	r3, [r3, #16]
    3a98:	461a      	mov	r2, r3
    3a9a:	9b02      	ldr	r3, [sp, #8]
    3a9c:	4293      	cmp	r3, r2
    3a9e:	d3d2      	bcc.n	3a46 <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    3aa0:	4a04      	ldr	r2, [pc, #16]	; (3ab4 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    3aa2:	9b03      	ldr	r3, [sp, #12]
    3aa4:	6113      	str	r3, [r2, #16]
}
    3aa6:	bf00      	nop
    3aa8:	b004      	add	sp, #16
    3aaa:	4770      	bx	lr
    3aac:	0000b2d0 	.word	0x0000b2d0
    3ab0:	0000b388 	.word	0x0000b388
    3ab4:	40048000 	.word	0x40048000

00003ab8 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    3ab8:	b500      	push	{lr}
    3aba:	b089      	sub	sp, #36	; 0x24
    3abc:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3abe:	2300      	movs	r3, #0
    3ac0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    3ac4:	4a21      	ldr	r2, [pc, #132]	; (3b4c <Clock_Ip_SpecificPlatformInitClock+0x94>)
    3ac6:	9b01      	ldr	r3, [sp, #4]
    3ac8:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    3aca:	4b21      	ldr	r3, [pc, #132]	; (3b50 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3acc:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ad0:	f003 0301 	and.w	r3, r3, #1
    3ad4:	2b00      	cmp	r3, #0
    3ad6:	d12e      	bne.n	3b36 <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    3ad8:	4b1e      	ldr	r3, [pc, #120]	; (3b54 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3ada:	2200      	movs	r2, #0
    3adc:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    3ade:	f7ff ff69 	bl	39b4 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3ae2:	aa03      	add	r2, sp, #12
    3ae4:	a904      	add	r1, sp, #16
    3ae6:	a805      	add	r0, sp, #20
    3ae8:	f24c 3350 	movw	r3, #50000	; 0xc350
    3aec:	f7fe f8ae 	bl	1c4c <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3af0:	4b17      	ldr	r3, [pc, #92]	; (3b50 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    3af2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3af6:	0e1b      	lsrs	r3, r3, #24
    3af8:	f003 0301 	and.w	r3, r3, #1
    3afc:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3afe:	9a03      	ldr	r2, [sp, #12]
    3b00:	a904      	add	r1, sp, #16
    3b02:	ab05      	add	r3, sp, #20
    3b04:	4618      	mov	r0, r3
    3b06:	f7fe f8bb 	bl	1c80 <Clock_Ip_TimeoutExpired>
    3b0a:	4603      	mov	r3, r0
    3b0c:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    3b10:	9b06      	ldr	r3, [sp, #24]
    3b12:	2b00      	cmp	r3, #0
    3b14:	d106      	bne.n	3b24 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    3b16:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3b1a:	f083 0301 	eor.w	r3, r3, #1
    3b1e:	b2db      	uxtb	r3, r3
    3b20:	2b00      	cmp	r3, #0
    3b22:	d1e5      	bne.n	3af0 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    3b24:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3b28:	2b00      	cmp	r3, #0
    3b2a:	d007      	beq.n	3b3c <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3b2c:	2105      	movs	r1, #5
    3b2e:	2001      	movs	r0, #1
    3b30:	f7fe f87c 	bl	1c2c <Clock_Ip_ReportClockErrors>
    3b34:	e002      	b.n	3b3c <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    3b36:	4b07      	ldr	r3, [pc, #28]	; (3b54 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3b38:	2201      	movs	r2, #1
    3b3a:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    3b3c:	9801      	ldr	r0, [sp, #4]
    3b3e:	f7ff ff49 	bl	39d4 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    3b42:	bf00      	nop
    3b44:	b009      	add	sp, #36	; 0x24
    3b46:	f85d fb04 	ldr.w	pc, [sp], #4
    3b4a:	bf00      	nop
    3b4c:	1fff8bc8 	.word	0x1fff8bc8
    3b50:	40064000 	.word	0x40064000
    3b54:	1fff8b18 	.word	0x1fff8b18

00003b58 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    3b58:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    3b5a:	2300      	movs	r3, #0
    3b5c:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3b5e:	4b29      	ldr	r3, [pc, #164]	; (3c04 <getFircConfig+0xac>)
    3b60:	681b      	ldr	r3, [r3, #0]
    3b62:	2b00      	cmp	r3, #0
    3b64:	d024      	beq.n	3bb0 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3b66:	2300      	movs	r3, #0
    3b68:	9301      	str	r3, [sp, #4]
    3b6a:	e01a      	b.n	3ba2 <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3b6c:	4b25      	ldr	r3, [pc, #148]	; (3c04 <getFircConfig+0xac>)
    3b6e:	6819      	ldr	r1, [r3, #0]
    3b70:	9a01      	ldr	r2, [sp, #4]
    3b72:	4613      	mov	r3, r2
    3b74:	005b      	lsls	r3, r3, #1
    3b76:	4413      	add	r3, r2
    3b78:	009b      	lsls	r3, r3, #2
    3b7a:	440b      	add	r3, r1
    3b7c:	3314      	adds	r3, #20
    3b7e:	681b      	ldr	r3, [r3, #0]
    3b80:	2b05      	cmp	r3, #5
    3b82:	d10b      	bne.n	3b9c <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    3b84:	4b1f      	ldr	r3, [pc, #124]	; (3c04 <getFircConfig+0xac>)
    3b86:	6819      	ldr	r1, [r3, #0]
    3b88:	9a01      	ldr	r2, [sp, #4]
    3b8a:	4613      	mov	r3, r2
    3b8c:	005b      	lsls	r3, r3, #1
    3b8e:	4413      	add	r3, r2
    3b90:	009b      	lsls	r3, r3, #2
    3b92:	3310      	adds	r3, #16
    3b94:	440b      	add	r3, r1
    3b96:	3304      	adds	r3, #4
    3b98:	9300      	str	r3, [sp, #0]
                break;
    3b9a:	e009      	b.n	3bb0 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3b9c:	9b01      	ldr	r3, [sp, #4]
    3b9e:	3301      	adds	r3, #1
    3ba0:	9301      	str	r3, [sp, #4]
    3ba2:	4b18      	ldr	r3, [pc, #96]	; (3c04 <getFircConfig+0xac>)
    3ba4:	681b      	ldr	r3, [r3, #0]
    3ba6:	7a1b      	ldrb	r3, [r3, #8]
    3ba8:	461a      	mov	r2, r3
    3baa:	9b01      	ldr	r3, [sp, #4]
    3bac:	4293      	cmp	r3, r2
    3bae:	d3dd      	bcc.n	3b6c <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3bb0:	9b00      	ldr	r3, [sp, #0]
    3bb2:	2b00      	cmp	r3, #0
    3bb4:	d121      	bne.n	3bfa <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    3bb6:	4b14      	ldr	r3, [pc, #80]	; (3c08 <getFircConfig+0xb0>)
    3bb8:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    3bba:	4b13      	ldr	r3, [pc, #76]	; (3c08 <getFircConfig+0xb0>)
    3bbc:	2205      	movs	r2, #5
    3bbe:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    3bc0:	4b12      	ldr	r3, [pc, #72]	; (3c0c <getFircConfig+0xb4>)
    3bc2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3bc6:	b29b      	uxth	r3, r3
    3bc8:	f003 0301 	and.w	r3, r3, #1
    3bcc:	b29a      	uxth	r2, r3
    3bce:	4b0e      	ldr	r3, [pc, #56]	; (3c08 <getFircConfig+0xb0>)
    3bd0:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    3bd2:	4b0e      	ldr	r3, [pc, #56]	; (3c0c <getFircConfig+0xb4>)
    3bd4:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3bd8:	b2db      	uxtb	r3, r3
    3bda:	f003 0303 	and.w	r3, r3, #3
    3bde:	b2da      	uxtb	r2, r3
    3be0:	4b09      	ldr	r3, [pc, #36]	; (3c08 <getFircConfig+0xb0>)
    3be2:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    3be4:	4b09      	ldr	r3, [pc, #36]	; (3c0c <getFircConfig+0xb4>)
    3be6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3bea:	b2db      	uxtb	r3, r3
    3bec:	10db      	asrs	r3, r3, #3
    3bee:	b2db      	uxtb	r3, r3
    3bf0:	f003 0301 	and.w	r3, r3, #1
    3bf4:	b2da      	uxtb	r2, r3
    3bf6:	4b04      	ldr	r3, [pc, #16]	; (3c08 <getFircConfig+0xb0>)
    3bf8:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    3bfa:	9b00      	ldr	r3, [sp, #0]
}
    3bfc:	4618      	mov	r0, r3
    3bfe:	b002      	add	sp, #8
    3c00:	4770      	bx	lr
    3c02:	bf00      	nop
    3c04:	1fff8bc8 	.word	0x1fff8bc8
    3c08:	1fff8c34 	.word	0x1fff8c34
    3c0c:	40064000 	.word	0x40064000

00003c10 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    3c10:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    3c12:	2300      	movs	r3, #0
    3c14:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3c16:	4b20      	ldr	r3, [pc, #128]	; (3c98 <getSoscConfig+0x88>)
    3c18:	681b      	ldr	r3, [r3, #0]
    3c1a:	2b00      	cmp	r3, #0
    3c1c:	d024      	beq.n	3c68 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    3c1e:	2300      	movs	r3, #0
    3c20:	9301      	str	r3, [sp, #4]
    3c22:	e01a      	b.n	3c5a <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    3c24:	4b1c      	ldr	r3, [pc, #112]	; (3c98 <getSoscConfig+0x88>)
    3c26:	6819      	ldr	r1, [r3, #0]
    3c28:	9a01      	ldr	r2, [sp, #4]
    3c2a:	4613      	mov	r3, r2
    3c2c:	009b      	lsls	r3, r3, #2
    3c2e:	4413      	add	r3, r2
    3c30:	009b      	lsls	r3, r3, #2
    3c32:	440b      	add	r3, r1
    3c34:	332c      	adds	r3, #44	; 0x2c
    3c36:	681b      	ldr	r3, [r3, #0]
    3c38:	2b08      	cmp	r3, #8
    3c3a:	d10b      	bne.n	3c54 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    3c3c:	4b16      	ldr	r3, [pc, #88]	; (3c98 <getSoscConfig+0x88>)
    3c3e:	6819      	ldr	r1, [r3, #0]
    3c40:	9a01      	ldr	r2, [sp, #4]
    3c42:	4613      	mov	r3, r2
    3c44:	009b      	lsls	r3, r3, #2
    3c46:	4413      	add	r3, r2
    3c48:	009b      	lsls	r3, r3, #2
    3c4a:	3328      	adds	r3, #40	; 0x28
    3c4c:	440b      	add	r3, r1
    3c4e:	3304      	adds	r3, #4
    3c50:	9300      	str	r3, [sp, #0]
                break;
    3c52:	e009      	b.n	3c68 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    3c54:	9b01      	ldr	r3, [sp, #4]
    3c56:	3301      	adds	r3, #1
    3c58:	9301      	str	r3, [sp, #4]
    3c5a:	4b0f      	ldr	r3, [pc, #60]	; (3c98 <getSoscConfig+0x88>)
    3c5c:	681b      	ldr	r3, [r3, #0]
    3c5e:	7a5b      	ldrb	r3, [r3, #9]
    3c60:	461a      	mov	r2, r3
    3c62:	9b01      	ldr	r3, [sp, #4]
    3c64:	4293      	cmp	r3, r2
    3c66:	d3dd      	bcc.n	3c24 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3c68:	9b00      	ldr	r3, [sp, #0]
    3c6a:	2b00      	cmp	r3, #0
    3c6c:	d110      	bne.n	3c90 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    3c6e:	4b0b      	ldr	r3, [pc, #44]	; (3c9c <getSoscConfig+0x8c>)
    3c70:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    3c72:	4b0a      	ldr	r3, [pc, #40]	; (3c9c <getSoscConfig+0x8c>)
    3c74:	2208      	movs	r2, #8
    3c76:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    3c78:	4b09      	ldr	r3, [pc, #36]	; (3ca0 <getSoscConfig+0x90>)
    3c7a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3c7e:	b29b      	uxth	r3, r3
    3c80:	f003 0301 	and.w	r3, r3, #1
    3c84:	b29a      	uxth	r2, r3
    3c86:	4b05      	ldr	r3, [pc, #20]	; (3c9c <getSoscConfig+0x8c>)
    3c88:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    3c8a:	4b04      	ldr	r3, [pc, #16]	; (3c9c <getSoscConfig+0x8c>)
    3c8c:	4a05      	ldr	r2, [pc, #20]	; (3ca4 <getSoscConfig+0x94>)
    3c8e:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    3c90:	9b00      	ldr	r3, [sp, #0]
}
    3c92:	4618      	mov	r0, r3
    3c94:	b002      	add	sp, #8
    3c96:	4770      	bx	lr
    3c98:	1fff8bc8 	.word	0x1fff8bc8
    3c9c:	1fff8c40 	.word	0x1fff8c40
    3ca0:	40064000 	.word	0x40064000
    3ca4:	02625a00 	.word	0x02625a00

00003ca8 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    3ca8:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    3caa:	2300      	movs	r3, #0
    3cac:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3cae:	4b28      	ldr	r3, [pc, #160]	; (3d50 <getSpllConfig+0xa8>)
    3cb0:	681b      	ldr	r3, [r3, #0]
    3cb2:	2b00      	cmp	r3, #0
    3cb4:	d023      	beq.n	3cfe <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    3cb6:	2300      	movs	r3, #0
    3cb8:	9301      	str	r3, [sp, #4]
    3cba:	e019      	b.n	3cf0 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    3cbc:	4b24      	ldr	r3, [pc, #144]	; (3d50 <getSpllConfig+0xa8>)
    3cbe:	6819      	ldr	r1, [r3, #0]
    3cc0:	9a01      	ldr	r2, [sp, #4]
    3cc2:	4613      	mov	r3, r2
    3cc4:	009b      	lsls	r3, r3, #2
    3cc6:	4413      	add	r3, r2
    3cc8:	00db      	lsls	r3, r3, #3
    3cca:	440b      	add	r3, r1
    3ccc:	3340      	adds	r3, #64	; 0x40
    3cce:	681b      	ldr	r3, [r3, #0]
    3cd0:	2b09      	cmp	r3, #9
    3cd2:	d10a      	bne.n	3cea <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    3cd4:	4b1e      	ldr	r3, [pc, #120]	; (3d50 <getSpllConfig+0xa8>)
    3cd6:	6819      	ldr	r1, [r3, #0]
    3cd8:	9a01      	ldr	r2, [sp, #4]
    3cda:	4613      	mov	r3, r2
    3cdc:	009b      	lsls	r3, r3, #2
    3cde:	4413      	add	r3, r2
    3ce0:	00db      	lsls	r3, r3, #3
    3ce2:	3340      	adds	r3, #64	; 0x40
    3ce4:	440b      	add	r3, r1
    3ce6:	9300      	str	r3, [sp, #0]
                break;
    3ce8:	e009      	b.n	3cfe <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    3cea:	9b01      	ldr	r3, [sp, #4]
    3cec:	3301      	adds	r3, #1
    3cee:	9301      	str	r3, [sp, #4]
    3cf0:	4b17      	ldr	r3, [pc, #92]	; (3d50 <getSpllConfig+0xa8>)
    3cf2:	681b      	ldr	r3, [r3, #0]
    3cf4:	7a9b      	ldrb	r3, [r3, #10]
    3cf6:	461a      	mov	r2, r3
    3cf8:	9b01      	ldr	r3, [sp, #4]
    3cfa:	4293      	cmp	r3, r2
    3cfc:	d3de      	bcc.n	3cbc <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3cfe:	9b00      	ldr	r3, [sp, #0]
    3d00:	2b00      	cmp	r3, #0
    3d02:	d121      	bne.n	3d48 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    3d04:	4b13      	ldr	r3, [pc, #76]	; (3d54 <getSpllConfig+0xac>)
    3d06:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    3d08:	4b12      	ldr	r3, [pc, #72]	; (3d54 <getSpllConfig+0xac>)
    3d0a:	2209      	movs	r2, #9
    3d0c:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    3d0e:	4b12      	ldr	r3, [pc, #72]	; (3d58 <getSpllConfig+0xb0>)
    3d10:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3d14:	b29b      	uxth	r3, r3
    3d16:	f003 0301 	and.w	r3, r3, #1
    3d1a:	b29a      	uxth	r2, r3
    3d1c:	4b0d      	ldr	r3, [pc, #52]	; (3d54 <getSpllConfig+0xac>)
    3d1e:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    3d20:	4b0d      	ldr	r3, [pc, #52]	; (3d58 <getSpllConfig+0xb0>)
    3d22:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3d26:	0a1b      	lsrs	r3, r3, #8
    3d28:	b2db      	uxtb	r3, r3
    3d2a:	f003 0307 	and.w	r3, r3, #7
    3d2e:	b2da      	uxtb	r2, r3
    3d30:	4b08      	ldr	r3, [pc, #32]	; (3d54 <getSpllConfig+0xac>)
    3d32:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    3d34:	4b08      	ldr	r3, [pc, #32]	; (3d58 <getSpllConfig+0xb0>)
    3d36:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3d3a:	0c1b      	lsrs	r3, r3, #16
    3d3c:	b2db      	uxtb	r3, r3
    3d3e:	f003 031f 	and.w	r3, r3, #31
    3d42:	b2da      	uxtb	r2, r3
    3d44:	4b03      	ldr	r3, [pc, #12]	; (3d54 <getSpllConfig+0xac>)
    3d46:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    3d48:	9b00      	ldr	r3, [sp, #0]
}
    3d4a:	4618      	mov	r0, r3
    3d4c:	b002      	add	sp, #8
    3d4e:	4770      	bx	lr
    3d50:	1fff8bc8 	.word	0x1fff8bc8
    3d54:	1fff8c54 	.word	0x1fff8c54
    3d58:	40064000 	.word	0x40064000

00003d5c <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    3d5c:	b086      	sub	sp, #24
    3d5e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    3d60:	2300      	movs	r3, #0
    3d62:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    3d64:	9b01      	ldr	r3, [sp, #4]
    3d66:	2b1b      	cmp	r3, #27
    3d68:	d00f      	beq.n	3d8a <getSelectorConfig+0x2e>
    3d6a:	9b01      	ldr	r3, [sp, #4]
    3d6c:	2b1b      	cmp	r3, #27
    3d6e:	d80f      	bhi.n	3d90 <getSelectorConfig+0x34>
    3d70:	9b01      	ldr	r3, [sp, #4]
    3d72:	2b19      	cmp	r3, #25
    3d74:	d003      	beq.n	3d7e <getSelectorConfig+0x22>
    3d76:	9b01      	ldr	r3, [sp, #4]
    3d78:	2b1a      	cmp	r3, #26
    3d7a:	d003      	beq.n	3d84 <getSelectorConfig+0x28>
    3d7c:	e008      	b.n	3d90 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    3d7e:	2300      	movs	r3, #0
    3d80:	9304      	str	r3, [sp, #16]
            break;
    3d82:	e008      	b.n	3d96 <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    3d84:	2301      	movs	r3, #1
    3d86:	9304      	str	r3, [sp, #16]
            break;
    3d88:	e005      	b.n	3d96 <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    3d8a:	2302      	movs	r3, #2
    3d8c:	9304      	str	r3, [sp, #16]
            break;
    3d8e:	e002      	b.n	3d96 <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    3d90:	2300      	movs	r3, #0
    3d92:	9304      	str	r3, [sp, #16]
            break;
    3d94:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    3d96:	4b36      	ldr	r3, [pc, #216]	; (3e70 <getSelectorConfig+0x114>)
    3d98:	681b      	ldr	r3, [r3, #0]
    3d9a:	2b00      	cmp	r3, #0
    3d9c:	d01d      	beq.n	3dda <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    3d9e:	2300      	movs	r3, #0
    3da0:	9303      	str	r3, [sp, #12]
    3da2:	e013      	b.n	3dcc <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    3da4:	4b32      	ldr	r3, [pc, #200]	; (3e70 <getSelectorConfig+0x114>)
    3da6:	681b      	ldr	r3, [r3, #0]
    3da8:	9a03      	ldr	r2, [sp, #12]
    3daa:	320d      	adds	r2, #13
    3dac:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3db0:	9a01      	ldr	r2, [sp, #4]
    3db2:	429a      	cmp	r2, r3
    3db4:	d107      	bne.n	3dc6 <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    3db6:	4b2e      	ldr	r3, [pc, #184]	; (3e70 <getSelectorConfig+0x114>)
    3db8:	681a      	ldr	r2, [r3, #0]
    3dba:	9b03      	ldr	r3, [sp, #12]
    3dbc:	330d      	adds	r3, #13
    3dbe:	00db      	lsls	r3, r3, #3
    3dc0:	4413      	add	r3, r2
    3dc2:	9305      	str	r3, [sp, #20]
                break;
    3dc4:	e009      	b.n	3dda <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    3dc6:	9b03      	ldr	r3, [sp, #12]
    3dc8:	3301      	adds	r3, #1
    3dca:	9303      	str	r3, [sp, #12]
    3dcc:	4b28      	ldr	r3, [pc, #160]	; (3e70 <getSelectorConfig+0x114>)
    3dce:	681b      	ldr	r3, [r3, #0]
    3dd0:	7adb      	ldrb	r3, [r3, #11]
    3dd2:	461a      	mov	r2, r3
    3dd4:	9b03      	ldr	r3, [sp, #12]
    3dd6:	4293      	cmp	r3, r2
    3dd8:	d3e4      	bcc.n	3da4 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3dda:	9b05      	ldr	r3, [sp, #20]
    3ddc:	2b00      	cmp	r3, #0
    3dde:	d140      	bne.n	3e62 <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    3de0:	9b04      	ldr	r3, [sp, #16]
    3de2:	00db      	lsls	r3, r3, #3
    3de4:	4a23      	ldr	r2, [pc, #140]	; (3e74 <getSelectorConfig+0x118>)
    3de6:	4413      	add	r3, r2
    3de8:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    3dea:	4922      	ldr	r1, [pc, #136]	; (3e74 <getSelectorConfig+0x118>)
    3dec:	9b04      	ldr	r3, [sp, #16]
    3dee:	9a01      	ldr	r2, [sp, #4]
    3df0:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    3df4:	9b01      	ldr	r3, [sp, #4]
    3df6:	2b1b      	cmp	r3, #27
    3df8:	d025      	beq.n	3e46 <getSelectorConfig+0xea>
    3dfa:	9b01      	ldr	r3, [sp, #4]
    3dfc:	2b1b      	cmp	r3, #27
    3dfe:	d832      	bhi.n	3e66 <getSelectorConfig+0x10a>
    3e00:	9b01      	ldr	r3, [sp, #4]
    3e02:	2b19      	cmp	r3, #25
    3e04:	d003      	beq.n	3e0e <getSelectorConfig+0xb2>
    3e06:	9b01      	ldr	r3, [sp, #4]
    3e08:	2b1a      	cmp	r3, #26
    3e0a:	d00e      	beq.n	3e2a <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    3e0c:	e02b      	b.n	3e66 <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    3e0e:	4b1a      	ldr	r3, [pc, #104]	; (3e78 <getSelectorConfig+0x11c>)
    3e10:	695b      	ldr	r3, [r3, #20]
    3e12:	0e1b      	lsrs	r3, r3, #24
    3e14:	f003 030f 	and.w	r3, r3, #15
    3e18:	4a18      	ldr	r2, [pc, #96]	; (3e7c <getSelectorConfig+0x120>)
    3e1a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3e1e:	4915      	ldr	r1, [pc, #84]	; (3e74 <getSelectorConfig+0x118>)
    3e20:	9b04      	ldr	r3, [sp, #16]
    3e22:	00db      	lsls	r3, r3, #3
    3e24:	440b      	add	r3, r1
    3e26:	605a      	str	r2, [r3, #4]
                break;
    3e28:	e01e      	b.n	3e68 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    3e2a:	4b13      	ldr	r3, [pc, #76]	; (3e78 <getSelectorConfig+0x11c>)
    3e2c:	699b      	ldr	r3, [r3, #24]
    3e2e:	0e1b      	lsrs	r3, r3, #24
    3e30:	f003 030f 	and.w	r3, r3, #15
    3e34:	4a11      	ldr	r2, [pc, #68]	; (3e7c <getSelectorConfig+0x120>)
    3e36:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3e3a:	490e      	ldr	r1, [pc, #56]	; (3e74 <getSelectorConfig+0x118>)
    3e3c:	9b04      	ldr	r3, [sp, #16]
    3e3e:	00db      	lsls	r3, r3, #3
    3e40:	440b      	add	r3, r1
    3e42:	605a      	str	r2, [r3, #4]
                break;
    3e44:	e010      	b.n	3e68 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    3e46:	4b0c      	ldr	r3, [pc, #48]	; (3e78 <getSelectorConfig+0x11c>)
    3e48:	69db      	ldr	r3, [r3, #28]
    3e4a:	0e1b      	lsrs	r3, r3, #24
    3e4c:	f003 030f 	and.w	r3, r3, #15
    3e50:	4a0a      	ldr	r2, [pc, #40]	; (3e7c <getSelectorConfig+0x120>)
    3e52:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3e56:	4907      	ldr	r1, [pc, #28]	; (3e74 <getSelectorConfig+0x118>)
    3e58:	9b04      	ldr	r3, [sp, #16]
    3e5a:	00db      	lsls	r3, r3, #3
    3e5c:	440b      	add	r3, r1
    3e5e:	605a      	str	r2, [r3, #4]
                break;
    3e60:	e002      	b.n	3e68 <getSelectorConfig+0x10c>
        }
    }
    3e62:	bf00      	nop
    3e64:	e000      	b.n	3e68 <getSelectorConfig+0x10c>
                break;
    3e66:	bf00      	nop

    return ReturnValue;
    3e68:	9b05      	ldr	r3, [sp, #20]
}
    3e6a:	4618      	mov	r0, r3
    3e6c:	b006      	add	sp, #24
    3e6e:	4770      	bx	lr
    3e70:	1fff8bc8 	.word	0x1fff8bc8
    3e74:	1fff8c7c 	.word	0x1fff8c7c
    3e78:	40064000 	.word	0x40064000
    3e7c:	0000b650 	.word	0x0000b650

00003e80 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    3e80:	b086      	sub	sp, #24
    3e82:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    3e84:	2300      	movs	r3, #0
    3e86:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    3e88:	2300      	movs	r3, #0
    3e8a:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    3e8c:	9b01      	ldr	r3, [sp, #4]
    3e8e:	2b1f      	cmp	r3, #31
    3e90:	d00f      	beq.n	3eb2 <getCoreDividerConfig+0x32>
    3e92:	9b01      	ldr	r3, [sp, #4]
    3e94:	2b1f      	cmp	r3, #31
    3e96:	d80f      	bhi.n	3eb8 <getCoreDividerConfig+0x38>
    3e98:	9b01      	ldr	r3, [sp, #4]
    3e9a:	2b1d      	cmp	r3, #29
    3e9c:	d003      	beq.n	3ea6 <getCoreDividerConfig+0x26>
    3e9e:	9b01      	ldr	r3, [sp, #4]
    3ea0:	2b1e      	cmp	r3, #30
    3ea2:	d003      	beq.n	3eac <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    3ea4:	e008      	b.n	3eb8 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    3ea6:	2300      	movs	r3, #0
    3ea8:	9304      	str	r3, [sp, #16]
            break;
    3eaa:	e006      	b.n	3eba <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    3eac:	2301      	movs	r3, #1
    3eae:	9304      	str	r3, [sp, #16]
            break;
    3eb0:	e003      	b.n	3eba <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    3eb2:	2302      	movs	r3, #2
    3eb4:	9304      	str	r3, [sp, #16]
            break;
    3eb6:	e000      	b.n	3eba <getCoreDividerConfig+0x3a>
                break;
    3eb8:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    3eba:	4b41      	ldr	r3, [pc, #260]	; (3fc0 <getCoreDividerConfig+0x140>)
    3ebc:	681b      	ldr	r3, [r3, #0]
    3ebe:	2b00      	cmp	r3, #0
    3ec0:	d026      	beq.n	3f10 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3ec2:	2300      	movs	r3, #0
    3ec4:	9303      	str	r3, [sp, #12]
    3ec6:	e01c      	b.n	3f02 <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    3ec8:	4b3d      	ldr	r3, [pc, #244]	; (3fc0 <getCoreDividerConfig+0x140>)
    3eca:	6819      	ldr	r1, [r3, #0]
    3ecc:	9a03      	ldr	r2, [sp, #12]
    3ece:	4613      	mov	r3, r2
    3ed0:	005b      	lsls	r3, r3, #1
    3ed2:	4413      	add	r3, r2
    3ed4:	009b      	lsls	r3, r3, #2
    3ed6:	440b      	add	r3, r1
    3ed8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3edc:	681b      	ldr	r3, [r3, #0]
    3ede:	9a01      	ldr	r2, [sp, #4]
    3ee0:	429a      	cmp	r2, r3
    3ee2:	d10b      	bne.n	3efc <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    3ee4:	4b36      	ldr	r3, [pc, #216]	; (3fc0 <getCoreDividerConfig+0x140>)
    3ee6:	6819      	ldr	r1, [r3, #0]
    3ee8:	9a03      	ldr	r2, [sp, #12]
    3eea:	4613      	mov	r3, r2
    3eec:	005b      	lsls	r3, r3, #1
    3eee:	4413      	add	r3, r2
    3ef0:	009b      	lsls	r3, r3, #2
    3ef2:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3ef6:	440b      	add	r3, r1
    3ef8:	9305      	str	r3, [sp, #20]
                break;
    3efa:	e009      	b.n	3f10 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3efc:	9b03      	ldr	r3, [sp, #12]
    3efe:	3301      	adds	r3, #1
    3f00:	9303      	str	r3, [sp, #12]
    3f02:	4b2f      	ldr	r3, [pc, #188]	; (3fc0 <getCoreDividerConfig+0x140>)
    3f04:	681b      	ldr	r3, [r3, #0]
    3f06:	7b1b      	ldrb	r3, [r3, #12]
    3f08:	461a      	mov	r2, r3
    3f0a:	9b03      	ldr	r3, [sp, #12]
    3f0c:	4293      	cmp	r3, r2
    3f0e:	d3db      	bcc.n	3ec8 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3f10:	9b05      	ldr	r3, [sp, #20]
    3f12:	2b00      	cmp	r3, #0
    3f14:	d14d      	bne.n	3fb2 <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    3f16:	9a04      	ldr	r2, [sp, #16]
    3f18:	4613      	mov	r3, r2
    3f1a:	005b      	lsls	r3, r3, #1
    3f1c:	4413      	add	r3, r2
    3f1e:	009b      	lsls	r3, r3, #2
    3f20:	4a28      	ldr	r2, [pc, #160]	; (3fc4 <getCoreDividerConfig+0x144>)
    3f22:	4413      	add	r3, r2
    3f24:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    3f26:	4927      	ldr	r1, [pc, #156]	; (3fc4 <getCoreDividerConfig+0x144>)
    3f28:	9a04      	ldr	r2, [sp, #16]
    3f2a:	4613      	mov	r3, r2
    3f2c:	005b      	lsls	r3, r3, #1
    3f2e:	4413      	add	r3, r2
    3f30:	009b      	lsls	r3, r3, #2
    3f32:	440b      	add	r3, r1
    3f34:	9a01      	ldr	r2, [sp, #4]
    3f36:	601a      	str	r2, [r3, #0]
        switch(Name)
    3f38:	9b01      	ldr	r3, [sp, #4]
    3f3a:	2b1f      	cmp	r3, #31
    3f3c:	d029      	beq.n	3f92 <getCoreDividerConfig+0x112>
    3f3e:	9b01      	ldr	r3, [sp, #4]
    3f40:	2b1f      	cmp	r3, #31
    3f42:	d838      	bhi.n	3fb6 <getCoreDividerConfig+0x136>
    3f44:	9b01      	ldr	r3, [sp, #4]
    3f46:	2b1d      	cmp	r3, #29
    3f48:	d003      	beq.n	3f52 <getCoreDividerConfig+0xd2>
    3f4a:	9b01      	ldr	r3, [sp, #4]
    3f4c:	2b1e      	cmp	r3, #30
    3f4e:	d010      	beq.n	3f72 <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    3f50:	e031      	b.n	3fb6 <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    3f52:	4b1d      	ldr	r3, [pc, #116]	; (3fc8 <getCoreDividerConfig+0x148>)
    3f54:	695b      	ldr	r3, [r3, #20]
    3f56:	0c1b      	lsrs	r3, r3, #16
    3f58:	f003 030f 	and.w	r3, r3, #15
    3f5c:	1c59      	adds	r1, r3, #1
    3f5e:	4819      	ldr	r0, [pc, #100]	; (3fc4 <getCoreDividerConfig+0x144>)
    3f60:	9a04      	ldr	r2, [sp, #16]
    3f62:	4613      	mov	r3, r2
    3f64:	005b      	lsls	r3, r3, #1
    3f66:	4413      	add	r3, r2
    3f68:	009b      	lsls	r3, r3, #2
    3f6a:	4403      	add	r3, r0
    3f6c:	3304      	adds	r3, #4
    3f6e:	6019      	str	r1, [r3, #0]
                break;
    3f70:	e022      	b.n	3fb8 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    3f72:	4b15      	ldr	r3, [pc, #84]	; (3fc8 <getCoreDividerConfig+0x148>)
    3f74:	699b      	ldr	r3, [r3, #24]
    3f76:	0c1b      	lsrs	r3, r3, #16
    3f78:	f003 030f 	and.w	r3, r3, #15
    3f7c:	1c59      	adds	r1, r3, #1
    3f7e:	4811      	ldr	r0, [pc, #68]	; (3fc4 <getCoreDividerConfig+0x144>)
    3f80:	9a04      	ldr	r2, [sp, #16]
    3f82:	4613      	mov	r3, r2
    3f84:	005b      	lsls	r3, r3, #1
    3f86:	4413      	add	r3, r2
    3f88:	009b      	lsls	r3, r3, #2
    3f8a:	4403      	add	r3, r0
    3f8c:	3304      	adds	r3, #4
    3f8e:	6019      	str	r1, [r3, #0]
                break;
    3f90:	e012      	b.n	3fb8 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    3f92:	4b0d      	ldr	r3, [pc, #52]	; (3fc8 <getCoreDividerConfig+0x148>)
    3f94:	69db      	ldr	r3, [r3, #28]
    3f96:	0c1b      	lsrs	r3, r3, #16
    3f98:	f003 030f 	and.w	r3, r3, #15
    3f9c:	1c59      	adds	r1, r3, #1
    3f9e:	4809      	ldr	r0, [pc, #36]	; (3fc4 <getCoreDividerConfig+0x144>)
    3fa0:	9a04      	ldr	r2, [sp, #16]
    3fa2:	4613      	mov	r3, r2
    3fa4:	005b      	lsls	r3, r3, #1
    3fa6:	4413      	add	r3, r2
    3fa8:	009b      	lsls	r3, r3, #2
    3faa:	4403      	add	r3, r0
    3fac:	3304      	adds	r3, #4
    3fae:	6019      	str	r1, [r3, #0]
                break;
    3fb0:	e002      	b.n	3fb8 <getCoreDividerConfig+0x138>
        }
    }
    3fb2:	bf00      	nop
    3fb4:	e000      	b.n	3fb8 <getCoreDividerConfig+0x138>
                break;
    3fb6:	bf00      	nop

    return ReturnValue;
    3fb8:	9b05      	ldr	r3, [sp, #20]
}
    3fba:	4618      	mov	r0, r3
    3fbc:	b006      	add	sp, #24
    3fbe:	4770      	bx	lr
    3fc0:	1fff8bc8 	.word	0x1fff8bc8
    3fc4:	1fff8c94 	.word	0x1fff8c94
    3fc8:	40064000 	.word	0x40064000

00003fcc <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    3fcc:	b086      	sub	sp, #24
    3fce:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    3fd0:	2300      	movs	r3, #0
    3fd2:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    3fd4:	2300      	movs	r3, #0
    3fd6:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    3fd8:	9b01      	ldr	r3, [sp, #4]
    3fda:	2b23      	cmp	r3, #35	; 0x23
    3fdc:	d00f      	beq.n	3ffe <getBusDividerConfig+0x32>
    3fde:	9b01      	ldr	r3, [sp, #4]
    3fe0:	2b23      	cmp	r3, #35	; 0x23
    3fe2:	d80f      	bhi.n	4004 <getBusDividerConfig+0x38>
    3fe4:	9b01      	ldr	r3, [sp, #4]
    3fe6:	2b21      	cmp	r3, #33	; 0x21
    3fe8:	d003      	beq.n	3ff2 <getBusDividerConfig+0x26>
    3fea:	9b01      	ldr	r3, [sp, #4]
    3fec:	2b22      	cmp	r3, #34	; 0x22
    3fee:	d003      	beq.n	3ff8 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    3ff0:	e008      	b.n	4004 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    3ff2:	2300      	movs	r3, #0
    3ff4:	9304      	str	r3, [sp, #16]
            break;
    3ff6:	e006      	b.n	4006 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    3ff8:	2301      	movs	r3, #1
    3ffa:	9304      	str	r3, [sp, #16]
            break;
    3ffc:	e003      	b.n	4006 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    3ffe:	2302      	movs	r3, #2
    4000:	9304      	str	r3, [sp, #16]
            break;
    4002:	e000      	b.n	4006 <getBusDividerConfig+0x3a>
                break;
    4004:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4006:	4b41      	ldr	r3, [pc, #260]	; (410c <getBusDividerConfig+0x140>)
    4008:	681b      	ldr	r3, [r3, #0]
    400a:	2b00      	cmp	r3, #0
    400c:	d026      	beq.n	405c <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    400e:	2300      	movs	r3, #0
    4010:	9303      	str	r3, [sp, #12]
    4012:	e01c      	b.n	404e <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4014:	4b3d      	ldr	r3, [pc, #244]	; (410c <getBusDividerConfig+0x140>)
    4016:	6819      	ldr	r1, [r3, #0]
    4018:	9a03      	ldr	r2, [sp, #12]
    401a:	4613      	mov	r3, r2
    401c:	005b      	lsls	r3, r3, #1
    401e:	4413      	add	r3, r2
    4020:	009b      	lsls	r3, r3, #2
    4022:	440b      	add	r3, r1
    4024:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4028:	681b      	ldr	r3, [r3, #0]
    402a:	9a01      	ldr	r2, [sp, #4]
    402c:	429a      	cmp	r2, r3
    402e:	d10b      	bne.n	4048 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    4030:	4b36      	ldr	r3, [pc, #216]	; (410c <getBusDividerConfig+0x140>)
    4032:	6819      	ldr	r1, [r3, #0]
    4034:	9a03      	ldr	r2, [sp, #12]
    4036:	4613      	mov	r3, r2
    4038:	005b      	lsls	r3, r3, #1
    403a:	4413      	add	r3, r2
    403c:	009b      	lsls	r3, r3, #2
    403e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4042:	440b      	add	r3, r1
    4044:	9305      	str	r3, [sp, #20]
                break;
    4046:	e009      	b.n	405c <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4048:	9b03      	ldr	r3, [sp, #12]
    404a:	3301      	adds	r3, #1
    404c:	9303      	str	r3, [sp, #12]
    404e:	4b2f      	ldr	r3, [pc, #188]	; (410c <getBusDividerConfig+0x140>)
    4050:	681b      	ldr	r3, [r3, #0]
    4052:	7b1b      	ldrb	r3, [r3, #12]
    4054:	461a      	mov	r2, r3
    4056:	9b03      	ldr	r3, [sp, #12]
    4058:	4293      	cmp	r3, r2
    405a:	d3db      	bcc.n	4014 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    405c:	9b05      	ldr	r3, [sp, #20]
    405e:	2b00      	cmp	r3, #0
    4060:	d14d      	bne.n	40fe <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    4062:	9a04      	ldr	r2, [sp, #16]
    4064:	4613      	mov	r3, r2
    4066:	005b      	lsls	r3, r3, #1
    4068:	4413      	add	r3, r2
    406a:	009b      	lsls	r3, r3, #2
    406c:	4a28      	ldr	r2, [pc, #160]	; (4110 <getBusDividerConfig+0x144>)
    406e:	4413      	add	r3, r2
    4070:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    4072:	4927      	ldr	r1, [pc, #156]	; (4110 <getBusDividerConfig+0x144>)
    4074:	9a04      	ldr	r2, [sp, #16]
    4076:	4613      	mov	r3, r2
    4078:	005b      	lsls	r3, r3, #1
    407a:	4413      	add	r3, r2
    407c:	009b      	lsls	r3, r3, #2
    407e:	440b      	add	r3, r1
    4080:	9a01      	ldr	r2, [sp, #4]
    4082:	601a      	str	r2, [r3, #0]
        switch(Name)
    4084:	9b01      	ldr	r3, [sp, #4]
    4086:	2b23      	cmp	r3, #35	; 0x23
    4088:	d029      	beq.n	40de <getBusDividerConfig+0x112>
    408a:	9b01      	ldr	r3, [sp, #4]
    408c:	2b23      	cmp	r3, #35	; 0x23
    408e:	d838      	bhi.n	4102 <getBusDividerConfig+0x136>
    4090:	9b01      	ldr	r3, [sp, #4]
    4092:	2b21      	cmp	r3, #33	; 0x21
    4094:	d003      	beq.n	409e <getBusDividerConfig+0xd2>
    4096:	9b01      	ldr	r3, [sp, #4]
    4098:	2b22      	cmp	r3, #34	; 0x22
    409a:	d010      	beq.n	40be <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    409c:	e031      	b.n	4102 <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    409e:	4b1d      	ldr	r3, [pc, #116]	; (4114 <getBusDividerConfig+0x148>)
    40a0:	695b      	ldr	r3, [r3, #20]
    40a2:	091b      	lsrs	r3, r3, #4
    40a4:	f003 030f 	and.w	r3, r3, #15
    40a8:	1c59      	adds	r1, r3, #1
    40aa:	4819      	ldr	r0, [pc, #100]	; (4110 <getBusDividerConfig+0x144>)
    40ac:	9a04      	ldr	r2, [sp, #16]
    40ae:	4613      	mov	r3, r2
    40b0:	005b      	lsls	r3, r3, #1
    40b2:	4413      	add	r3, r2
    40b4:	009b      	lsls	r3, r3, #2
    40b6:	4403      	add	r3, r0
    40b8:	3304      	adds	r3, #4
    40ba:	6019      	str	r1, [r3, #0]
                break;
    40bc:	e022      	b.n	4104 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    40be:	4b15      	ldr	r3, [pc, #84]	; (4114 <getBusDividerConfig+0x148>)
    40c0:	699b      	ldr	r3, [r3, #24]
    40c2:	091b      	lsrs	r3, r3, #4
    40c4:	f003 030f 	and.w	r3, r3, #15
    40c8:	1c59      	adds	r1, r3, #1
    40ca:	4811      	ldr	r0, [pc, #68]	; (4110 <getBusDividerConfig+0x144>)
    40cc:	9a04      	ldr	r2, [sp, #16]
    40ce:	4613      	mov	r3, r2
    40d0:	005b      	lsls	r3, r3, #1
    40d2:	4413      	add	r3, r2
    40d4:	009b      	lsls	r3, r3, #2
    40d6:	4403      	add	r3, r0
    40d8:	3304      	adds	r3, #4
    40da:	6019      	str	r1, [r3, #0]
                break;
    40dc:	e012      	b.n	4104 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    40de:	4b0d      	ldr	r3, [pc, #52]	; (4114 <getBusDividerConfig+0x148>)
    40e0:	69db      	ldr	r3, [r3, #28]
    40e2:	091b      	lsrs	r3, r3, #4
    40e4:	f003 030f 	and.w	r3, r3, #15
    40e8:	1c59      	adds	r1, r3, #1
    40ea:	4809      	ldr	r0, [pc, #36]	; (4110 <getBusDividerConfig+0x144>)
    40ec:	9a04      	ldr	r2, [sp, #16]
    40ee:	4613      	mov	r3, r2
    40f0:	005b      	lsls	r3, r3, #1
    40f2:	4413      	add	r3, r2
    40f4:	009b      	lsls	r3, r3, #2
    40f6:	4403      	add	r3, r0
    40f8:	3304      	adds	r3, #4
    40fa:	6019      	str	r1, [r3, #0]
                break;
    40fc:	e002      	b.n	4104 <getBusDividerConfig+0x138>
        }
    }
    40fe:	bf00      	nop
    4100:	e000      	b.n	4104 <getBusDividerConfig+0x138>
                break;
    4102:	bf00      	nop

    return ReturnValue;
    4104:	9b05      	ldr	r3, [sp, #20]
}
    4106:	4618      	mov	r0, r3
    4108:	b006      	add	sp, #24
    410a:	4770      	bx	lr
    410c:	1fff8bc8 	.word	0x1fff8bc8
    4110:	1fff8cb8 	.word	0x1fff8cb8
    4114:	40064000 	.word	0x40064000

00004118 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    4118:	b086      	sub	sp, #24
    411a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    411c:	2300      	movs	r3, #0
    411e:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4120:	2300      	movs	r3, #0
    4122:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4124:	9b01      	ldr	r3, [sp, #4]
    4126:	2b27      	cmp	r3, #39	; 0x27
    4128:	d00f      	beq.n	414a <getSlowDividerConfig+0x32>
    412a:	9b01      	ldr	r3, [sp, #4]
    412c:	2b27      	cmp	r3, #39	; 0x27
    412e:	d80f      	bhi.n	4150 <getSlowDividerConfig+0x38>
    4130:	9b01      	ldr	r3, [sp, #4]
    4132:	2b25      	cmp	r3, #37	; 0x25
    4134:	d003      	beq.n	413e <getSlowDividerConfig+0x26>
    4136:	9b01      	ldr	r3, [sp, #4]
    4138:	2b26      	cmp	r3, #38	; 0x26
    413a:	d003      	beq.n	4144 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    413c:	e008      	b.n	4150 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    413e:	2300      	movs	r3, #0
    4140:	9304      	str	r3, [sp, #16]
            break;
    4142:	e006      	b.n	4152 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4144:	2301      	movs	r3, #1
    4146:	9304      	str	r3, [sp, #16]
            break;
    4148:	e003      	b.n	4152 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    414a:	2302      	movs	r3, #2
    414c:	9304      	str	r3, [sp, #16]
            break;
    414e:	e000      	b.n	4152 <getSlowDividerConfig+0x3a>
                break;
    4150:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4152:	4b40      	ldr	r3, [pc, #256]	; (4254 <getSlowDividerConfig+0x13c>)
    4154:	681b      	ldr	r3, [r3, #0]
    4156:	2b00      	cmp	r3, #0
    4158:	d026      	beq.n	41a8 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    415a:	2300      	movs	r3, #0
    415c:	9303      	str	r3, [sp, #12]
    415e:	e01c      	b.n	419a <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4160:	4b3c      	ldr	r3, [pc, #240]	; (4254 <getSlowDividerConfig+0x13c>)
    4162:	6819      	ldr	r1, [r3, #0]
    4164:	9a03      	ldr	r2, [sp, #12]
    4166:	4613      	mov	r3, r2
    4168:	005b      	lsls	r3, r3, #1
    416a:	4413      	add	r3, r2
    416c:	009b      	lsls	r3, r3, #2
    416e:	440b      	add	r3, r1
    4170:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4174:	681b      	ldr	r3, [r3, #0]
    4176:	9a01      	ldr	r2, [sp, #4]
    4178:	429a      	cmp	r2, r3
    417a:	d10b      	bne.n	4194 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    417c:	4b35      	ldr	r3, [pc, #212]	; (4254 <getSlowDividerConfig+0x13c>)
    417e:	6819      	ldr	r1, [r3, #0]
    4180:	9a03      	ldr	r2, [sp, #12]
    4182:	4613      	mov	r3, r2
    4184:	005b      	lsls	r3, r3, #1
    4186:	4413      	add	r3, r2
    4188:	009b      	lsls	r3, r3, #2
    418a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    418e:	440b      	add	r3, r1
    4190:	9305      	str	r3, [sp, #20]
                break;
    4192:	e009      	b.n	41a8 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4194:	9b03      	ldr	r3, [sp, #12]
    4196:	3301      	adds	r3, #1
    4198:	9303      	str	r3, [sp, #12]
    419a:	4b2e      	ldr	r3, [pc, #184]	; (4254 <getSlowDividerConfig+0x13c>)
    419c:	681b      	ldr	r3, [r3, #0]
    419e:	7b1b      	ldrb	r3, [r3, #12]
    41a0:	461a      	mov	r2, r3
    41a2:	9b03      	ldr	r3, [sp, #12]
    41a4:	4293      	cmp	r3, r2
    41a6:	d3db      	bcc.n	4160 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    41a8:	9b05      	ldr	r3, [sp, #20]
    41aa:	2b00      	cmp	r3, #0
    41ac:	d14a      	bne.n	4244 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    41ae:	9a04      	ldr	r2, [sp, #16]
    41b0:	4613      	mov	r3, r2
    41b2:	005b      	lsls	r3, r3, #1
    41b4:	4413      	add	r3, r2
    41b6:	009b      	lsls	r3, r3, #2
    41b8:	4a27      	ldr	r2, [pc, #156]	; (4258 <getSlowDividerConfig+0x140>)
    41ba:	4413      	add	r3, r2
    41bc:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    41be:	4926      	ldr	r1, [pc, #152]	; (4258 <getSlowDividerConfig+0x140>)
    41c0:	9a04      	ldr	r2, [sp, #16]
    41c2:	4613      	mov	r3, r2
    41c4:	005b      	lsls	r3, r3, #1
    41c6:	4413      	add	r3, r2
    41c8:	009b      	lsls	r3, r3, #2
    41ca:	440b      	add	r3, r1
    41cc:	9a01      	ldr	r2, [sp, #4]
    41ce:	601a      	str	r2, [r3, #0]
        switch(Name)
    41d0:	9b01      	ldr	r3, [sp, #4]
    41d2:	2b27      	cmp	r3, #39	; 0x27
    41d4:	d027      	beq.n	4226 <getSlowDividerConfig+0x10e>
    41d6:	9b01      	ldr	r3, [sp, #4]
    41d8:	2b27      	cmp	r3, #39	; 0x27
    41da:	d835      	bhi.n	4248 <getSlowDividerConfig+0x130>
    41dc:	9b01      	ldr	r3, [sp, #4]
    41de:	2b25      	cmp	r3, #37	; 0x25
    41e0:	d003      	beq.n	41ea <getSlowDividerConfig+0xd2>
    41e2:	9b01      	ldr	r3, [sp, #4]
    41e4:	2b26      	cmp	r3, #38	; 0x26
    41e6:	d00f      	beq.n	4208 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    41e8:	e02e      	b.n	4248 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    41ea:	4b1c      	ldr	r3, [pc, #112]	; (425c <getSlowDividerConfig+0x144>)
    41ec:	695b      	ldr	r3, [r3, #20]
    41ee:	f003 030f 	and.w	r3, r3, #15
    41f2:	1c59      	adds	r1, r3, #1
    41f4:	4818      	ldr	r0, [pc, #96]	; (4258 <getSlowDividerConfig+0x140>)
    41f6:	9a04      	ldr	r2, [sp, #16]
    41f8:	4613      	mov	r3, r2
    41fa:	005b      	lsls	r3, r3, #1
    41fc:	4413      	add	r3, r2
    41fe:	009b      	lsls	r3, r3, #2
    4200:	4403      	add	r3, r0
    4202:	3304      	adds	r3, #4
    4204:	6019      	str	r1, [r3, #0]
                break;
    4206:	e020      	b.n	424a <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    4208:	4b14      	ldr	r3, [pc, #80]	; (425c <getSlowDividerConfig+0x144>)
    420a:	699b      	ldr	r3, [r3, #24]
    420c:	f003 030f 	and.w	r3, r3, #15
    4210:	1c59      	adds	r1, r3, #1
    4212:	4811      	ldr	r0, [pc, #68]	; (4258 <getSlowDividerConfig+0x140>)
    4214:	9a04      	ldr	r2, [sp, #16]
    4216:	4613      	mov	r3, r2
    4218:	005b      	lsls	r3, r3, #1
    421a:	4413      	add	r3, r2
    421c:	009b      	lsls	r3, r3, #2
    421e:	4403      	add	r3, r0
    4220:	3304      	adds	r3, #4
    4222:	6019      	str	r1, [r3, #0]
                break;
    4224:	e011      	b.n	424a <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    4226:	4b0d      	ldr	r3, [pc, #52]	; (425c <getSlowDividerConfig+0x144>)
    4228:	69db      	ldr	r3, [r3, #28]
    422a:	f003 030f 	and.w	r3, r3, #15
    422e:	1c59      	adds	r1, r3, #1
    4230:	4809      	ldr	r0, [pc, #36]	; (4258 <getSlowDividerConfig+0x140>)
    4232:	9a04      	ldr	r2, [sp, #16]
    4234:	4613      	mov	r3, r2
    4236:	005b      	lsls	r3, r3, #1
    4238:	4413      	add	r3, r2
    423a:	009b      	lsls	r3, r3, #2
    423c:	4403      	add	r3, r0
    423e:	3304      	adds	r3, #4
    4240:	6019      	str	r1, [r3, #0]
                break;
    4242:	e002      	b.n	424a <getSlowDividerConfig+0x132>
        }
    }
    4244:	bf00      	nop
    4246:	e000      	b.n	424a <getSlowDividerConfig+0x132>
                break;
    4248:	bf00      	nop

    return ReturnValue;
    424a:	9b05      	ldr	r3, [sp, #20]
}
    424c:	4618      	mov	r0, r3
    424e:	b006      	add	sp, #24
    4250:	4770      	bx	lr
    4252:	bf00      	nop
    4254:	1fff8bc8 	.word	0x1fff8bc8
    4258:	1fff8cdc 	.word	0x1fff8cdc
    425c:	40064000 	.word	0x40064000

00004260 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    4260:	b500      	push	{lr}
    4262:	b083      	sub	sp, #12
    4264:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    4266:	4b64      	ldr	r3, [pc, #400]	; (43f8 <Clock_Ip_ClockInitializeObjects+0x198>)
    4268:	781b      	ldrb	r3, [r3, #0]
    426a:	f083 0301 	eor.w	r3, r3, #1
    426e:	b2db      	uxtb	r3, r3
    4270:	2b00      	cmp	r3, #0
    4272:	d05b      	beq.n	432c <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    4274:	4b60      	ldr	r3, [pc, #384]	; (43f8 <Clock_Ip_ClockInitializeObjects+0x198>)
    4276:	2201      	movs	r2, #1
    4278:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    427a:	4b60      	ldr	r3, [pc, #384]	; (43fc <Clock_Ip_ClockInitializeObjects+0x19c>)
    427c:	785b      	ldrb	r3, [r3, #1]
    427e:	461a      	mov	r2, r3
    4280:	4613      	mov	r3, r2
    4282:	009b      	lsls	r3, r3, #2
    4284:	4413      	add	r3, r2
    4286:	009b      	lsls	r3, r3, #2
    4288:	4a5d      	ldr	r2, [pc, #372]	; (4400 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    428a:	4413      	add	r3, r2
    428c:	4a5d      	ldr	r2, [pc, #372]	; (4404 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    428e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    4290:	4b5d      	ldr	r3, [pc, #372]	; (4408 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    4292:	785b      	ldrb	r3, [r3, #1]
    4294:	461a      	mov	r2, r3
    4296:	4613      	mov	r3, r2
    4298:	009b      	lsls	r3, r3, #2
    429a:	4413      	add	r3, r2
    429c:	009b      	lsls	r3, r3, #2
    429e:	4a5b      	ldr	r2, [pc, #364]	; (440c <Clock_Ip_ClockInitializeObjects+0x1ac>)
    42a0:	4413      	add	r3, r2
    42a2:	4a5b      	ldr	r2, [pc, #364]	; (4410 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    42a4:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    42a6:	4b5b      	ldr	r3, [pc, #364]	; (4414 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    42a8:	791b      	ldrb	r3, [r3, #4]
    42aa:	461a      	mov	r2, r3
    42ac:	4613      	mov	r3, r2
    42ae:	005b      	lsls	r3, r3, #1
    42b0:	4413      	add	r3, r2
    42b2:	009b      	lsls	r3, r3, #2
    42b4:	4a58      	ldr	r2, [pc, #352]	; (4418 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    42b6:	4413      	add	r3, r2
    42b8:	4a58      	ldr	r2, [pc, #352]	; (441c <Clock_Ip_ClockInitializeObjects+0x1bc>)
    42ba:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    42bc:	4b58      	ldr	r3, [pc, #352]	; (4420 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    42be:	795b      	ldrb	r3, [r3, #5]
    42c0:	00db      	lsls	r3, r3, #3
    42c2:	4a58      	ldr	r2, [pc, #352]	; (4424 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    42c4:	4413      	add	r3, r2
    42c6:	4a58      	ldr	r2, [pc, #352]	; (4428 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    42c8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    42ca:	4b55      	ldr	r3, [pc, #340]	; (4420 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    42cc:	79db      	ldrb	r3, [r3, #7]
    42ce:	00db      	lsls	r3, r3, #3
    42d0:	4a54      	ldr	r2, [pc, #336]	; (4424 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    42d2:	4413      	add	r3, r2
    42d4:	4a55      	ldr	r2, [pc, #340]	; (442c <Clock_Ip_ClockInitializeObjects+0x1cc>)
    42d6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    42d8:	4b55      	ldr	r3, [pc, #340]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    42da:	799b      	ldrb	r3, [r3, #6]
    42dc:	009b      	lsls	r3, r3, #2
    42de:	4a55      	ldr	r2, [pc, #340]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    42e0:	4413      	add	r3, r2
    42e2:	4a55      	ldr	r2, [pc, #340]	; (4438 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    42e4:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    42e6:	4b52      	ldr	r3, [pc, #328]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    42e8:	7a1b      	ldrb	r3, [r3, #8]
    42ea:	009b      	lsls	r3, r3, #2
    42ec:	4a51      	ldr	r2, [pc, #324]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    42ee:	4413      	add	r3, r2
    42f0:	4a52      	ldr	r2, [pc, #328]	; (443c <Clock_Ip_ClockInitializeObjects+0x1dc>)
    42f2:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    42f4:	4b4e      	ldr	r3, [pc, #312]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    42f6:	7a5b      	ldrb	r3, [r3, #9]
    42f8:	009b      	lsls	r3, r3, #2
    42fa:	4a4e      	ldr	r2, [pc, #312]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    42fc:	4413      	add	r3, r2
    42fe:	4a50      	ldr	r2, [pc, #320]	; (4440 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    4300:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    4302:	4b4b      	ldr	r3, [pc, #300]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4304:	7adb      	ldrb	r3, [r3, #11]
    4306:	009b      	lsls	r3, r3, #2
    4308:	4a4a      	ldr	r2, [pc, #296]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    430a:	4413      	add	r3, r2
    430c:	4a4d      	ldr	r2, [pc, #308]	; (4444 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    430e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    4310:	4b47      	ldr	r3, [pc, #284]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4312:	7b1b      	ldrb	r3, [r3, #12]
    4314:	009b      	lsls	r3, r3, #2
    4316:	4a47      	ldr	r2, [pc, #284]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4318:	4413      	add	r3, r2
    431a:	4a4b      	ldr	r2, [pc, #300]	; (4448 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    431c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    431e:	4b44      	ldr	r3, [pc, #272]	; (4430 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4320:	7b9b      	ldrb	r3, [r3, #14]
    4322:	009b      	lsls	r3, r3, #2
    4324:	4a43      	ldr	r2, [pc, #268]	; (4434 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    4326:	4413      	add	r3, r2
    4328:	4a48      	ldr	r2, [pc, #288]	; (444c <Clock_Ip_ClockInitializeObjects+0x1ec>)
    432a:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    432c:	4b48      	ldr	r3, [pc, #288]	; (4450 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    432e:	781b      	ldrb	r3, [r3, #0]
    4330:	2b00      	cmp	r3, #0
    4332:	d002      	beq.n	433a <Clock_Ip_ClockInitializeObjects+0xda>
    4334:	9b01      	ldr	r3, [sp, #4]
    4336:	2b00      	cmp	r3, #0
    4338:	d003      	beq.n	4342 <Clock_Ip_ClockInitializeObjects+0xe2>
    433a:	4b46      	ldr	r3, [pc, #280]	; (4454 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    433c:	781b      	ldrb	r3, [r3, #0]
    433e:	2b00      	cmp	r3, #0
    4340:	d056      	beq.n	43f0 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    4342:	f7ff fc09 	bl	3b58 <getFircConfig>
    4346:	4603      	mov	r3, r0
    4348:	4a43      	ldr	r2, [pc, #268]	; (4458 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    434a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    434c:	f7ff fc60 	bl	3c10 <getSoscConfig>
    4350:	4603      	mov	r3, r0
    4352:	4a42      	ldr	r2, [pc, #264]	; (445c <Clock_Ip_ClockInitializeObjects+0x1fc>)
    4354:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    4356:	f7ff fca7 	bl	3ca8 <getSpllConfig>
    435a:	4603      	mov	r3, r0
    435c:	4a40      	ldr	r2, [pc, #256]	; (4460 <Clock_Ip_ClockInitializeObjects+0x200>)
    435e:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    4360:	2019      	movs	r0, #25
    4362:	f7ff fcfb 	bl	3d5c <getSelectorConfig>
    4366:	4603      	mov	r3, r0
    4368:	4a3e      	ldr	r2, [pc, #248]	; (4464 <Clock_Ip_ClockInitializeObjects+0x204>)
    436a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    436c:	201a      	movs	r0, #26
    436e:	f7ff fcf5 	bl	3d5c <getSelectorConfig>
    4372:	4603      	mov	r3, r0
    4374:	4a3c      	ldr	r2, [pc, #240]	; (4468 <Clock_Ip_ClockInitializeObjects+0x208>)
    4376:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    4378:	201b      	movs	r0, #27
    437a:	f7ff fcef 	bl	3d5c <getSelectorConfig>
    437e:	4603      	mov	r3, r0
    4380:	4a3a      	ldr	r2, [pc, #232]	; (446c <Clock_Ip_ClockInitializeObjects+0x20c>)
    4382:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    4384:	201d      	movs	r0, #29
    4386:	f7ff fd7b 	bl	3e80 <getCoreDividerConfig>
    438a:	4603      	mov	r3, r0
    438c:	4a38      	ldr	r2, [pc, #224]	; (4470 <Clock_Ip_ClockInitializeObjects+0x210>)
    438e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    4390:	201e      	movs	r0, #30
    4392:	f7ff fd75 	bl	3e80 <getCoreDividerConfig>
    4396:	4603      	mov	r3, r0
    4398:	4a36      	ldr	r2, [pc, #216]	; (4474 <Clock_Ip_ClockInitializeObjects+0x214>)
    439a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    439c:	201f      	movs	r0, #31
    439e:	f7ff fd6f 	bl	3e80 <getCoreDividerConfig>
    43a2:	4603      	mov	r3, r0
    43a4:	4a34      	ldr	r2, [pc, #208]	; (4478 <Clock_Ip_ClockInitializeObjects+0x218>)
    43a6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    43a8:	2021      	movs	r0, #33	; 0x21
    43aa:	f7ff fe0f 	bl	3fcc <getBusDividerConfig>
    43ae:	4603      	mov	r3, r0
    43b0:	4a32      	ldr	r2, [pc, #200]	; (447c <Clock_Ip_ClockInitializeObjects+0x21c>)
    43b2:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    43b4:	2022      	movs	r0, #34	; 0x22
    43b6:	f7ff fe09 	bl	3fcc <getBusDividerConfig>
    43ba:	4603      	mov	r3, r0
    43bc:	4a30      	ldr	r2, [pc, #192]	; (4480 <Clock_Ip_ClockInitializeObjects+0x220>)
    43be:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    43c0:	2023      	movs	r0, #35	; 0x23
    43c2:	f7ff fe03 	bl	3fcc <getBusDividerConfig>
    43c6:	4603      	mov	r3, r0
    43c8:	4a2e      	ldr	r2, [pc, #184]	; (4484 <Clock_Ip_ClockInitializeObjects+0x224>)
    43ca:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    43cc:	2025      	movs	r0, #37	; 0x25
    43ce:	f7ff fea3 	bl	4118 <getSlowDividerConfig>
    43d2:	4603      	mov	r3, r0
    43d4:	4a2c      	ldr	r2, [pc, #176]	; (4488 <Clock_Ip_ClockInitializeObjects+0x228>)
    43d6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    43d8:	2026      	movs	r0, #38	; 0x26
    43da:	f7ff fe9d 	bl	4118 <getSlowDividerConfig>
    43de:	4603      	mov	r3, r0
    43e0:	4a2a      	ldr	r2, [pc, #168]	; (448c <Clock_Ip_ClockInitializeObjects+0x22c>)
    43e2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    43e4:	2027      	movs	r0, #39	; 0x27
    43e6:	f7ff fe97 	bl	4118 <getSlowDividerConfig>
    43ea:	4603      	mov	r3, r0
    43ec:	4a28      	ldr	r2, [pc, #160]	; (4490 <Clock_Ip_ClockInitializeObjects+0x230>)
    43ee:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    43f0:	bf00      	nop
    43f2:	b003      	add	sp, #12
    43f4:	f85d fb04 	ldr.w	pc, [sp], #4
    43f8:	1fff8d00 	.word	0x1fff8d00
    43fc:	0000af80 	.word	0x0000af80
    4400:	0000b5cc 	.word	0x0000b5cc
    4404:	1fff8bcc 	.word	0x1fff8bcc
    4408:	0000af40 	.word	0x0000af40
    440c:	0000b514 	.word	0x0000b514
    4410:	1fff8bd0 	.word	0x1fff8bd0
    4414:	0000af50 	.word	0x0000af50
    4418:	0000b580 	.word	0x0000b580
    441c:	1fff8bd4 	.word	0x1fff8bd4
    4420:	0000af90 	.word	0x0000af90
    4424:	0000b5f8 	.word	0x0000b5f8
    4428:	1fff8bd8 	.word	0x1fff8bd8
    442c:	1fff8c14 	.word	0x1fff8c14
    4430:	0000af20 	.word	0x0000af20
    4434:	0000b4d0 	.word	0x0000b4d0
    4438:	1fff8bdc 	.word	0x1fff8bdc
    443c:	1fff8c18 	.word	0x1fff8c18
    4440:	1fff8be0 	.word	0x1fff8be0
    4444:	1fff8c1c 	.word	0x1fff8c1c
    4448:	1fff8be4 	.word	0x1fff8be4
    444c:	1fff8c20 	.word	0x1fff8c20
    4450:	1fff8b19 	.word	0x1fff8b19
    4454:	1fff8b10 	.word	0x1fff8b10
    4458:	1fff8be8 	.word	0x1fff8be8
    445c:	1fff8bec 	.word	0x1fff8bec
    4460:	1fff8bf0 	.word	0x1fff8bf0
    4464:	1fff8bf4 	.word	0x1fff8bf4
    4468:	1fff8bf8 	.word	0x1fff8bf8
    446c:	1fff8c24 	.word	0x1fff8c24
    4470:	1fff8bfc 	.word	0x1fff8bfc
    4474:	1fff8c00 	.word	0x1fff8c00
    4478:	1fff8c28 	.word	0x1fff8c28
    447c:	1fff8c04 	.word	0x1fff8c04
    4480:	1fff8c08 	.word	0x1fff8c08
    4484:	1fff8c2c 	.word	0x1fff8c2c
    4488:	1fff8c0c 	.word	0x1fff8c0c
    448c:	1fff8c10 	.word	0x1fff8c10
    4490:	1fff8c30 	.word	0x1fff8c30

00004494 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    4494:	b500      	push	{lr}
    4496:	b083      	sub	sp, #12
    4498:	9001      	str	r0, [sp, #4]
    449a:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    449c:	9b01      	ldr	r3, [sp, #4]
    449e:	2b03      	cmp	r3, #3
    44a0:	f000 8090 	beq.w	45c4 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    44a4:	9b01      	ldr	r3, [sp, #4]
    44a6:	2b03      	cmp	r3, #3
    44a8:	f200 80d3 	bhi.w	4652 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    44ac:	9b01      	ldr	r3, [sp, #4]
    44ae:	2b00      	cmp	r3, #0
    44b0:	d040      	beq.n	4534 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    44b2:	9b01      	ldr	r3, [sp, #4]
    44b4:	3b01      	subs	r3, #1
    44b6:	2b01      	cmp	r3, #1
    44b8:	f200 80cb 	bhi.w	4652 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    44bc:	9b00      	ldr	r3, [sp, #0]
    44be:	2b00      	cmp	r3, #0
    44c0:	f040 80c9 	bne.w	4656 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    44c4:	4b68      	ldr	r3, [pc, #416]	; (4668 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    44c6:	2200      	movs	r2, #0
    44c8:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    44ca:	4b68      	ldr	r3, [pc, #416]	; (466c <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    44cc:	681b      	ldr	r3, [r3, #0]
    44ce:	685b      	ldr	r3, [r3, #4]
    44d0:	4a67      	ldr	r2, [pc, #412]	; (4670 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    44d2:	6812      	ldr	r2, [r2, #0]
    44d4:	4610      	mov	r0, r2
    44d6:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    44d8:	4b66      	ldr	r3, [pc, #408]	; (4674 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    44da:	681b      	ldr	r3, [r3, #0]
    44dc:	681b      	ldr	r3, [r3, #0]
    44de:	4a66      	ldr	r2, [pc, #408]	; (4678 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    44e0:	6812      	ldr	r2, [r2, #0]
    44e2:	4610      	mov	r0, r2
    44e4:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    44e6:	4b65      	ldr	r3, [pc, #404]	; (467c <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    44e8:	681b      	ldr	r3, [r3, #0]
    44ea:	681b      	ldr	r3, [r3, #0]
    44ec:	4a64      	ldr	r2, [pc, #400]	; (4680 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    44ee:	6812      	ldr	r2, [r2, #0]
    44f0:	4610      	mov	r0, r2
    44f2:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    44f4:	4b63      	ldr	r3, [pc, #396]	; (4684 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    44f6:	681b      	ldr	r3, [r3, #0]
    44f8:	681b      	ldr	r3, [r3, #0]
    44fa:	4a63      	ldr	r2, [pc, #396]	; (4688 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    44fc:	6812      	ldr	r2, [r2, #0]
    44fe:	4610      	mov	r0, r2
    4500:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    4502:	4b62      	ldr	r3, [pc, #392]	; (468c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4504:	681b      	ldr	r3, [r3, #0]
    4506:	691b      	ldr	r3, [r3, #16]
    4508:	4a61      	ldr	r2, [pc, #388]	; (4690 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    450a:	6812      	ldr	r2, [r2, #0]
    450c:	6812      	ldr	r2, [r2, #0]
    450e:	4610      	mov	r0, r2
    4510:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    4512:	4b60      	ldr	r3, [pc, #384]	; (4694 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4514:	681b      	ldr	r3, [r3, #0]
    4516:	68db      	ldr	r3, [r3, #12]
    4518:	4a5f      	ldr	r2, [pc, #380]	; (4698 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    451a:	6812      	ldr	r2, [r2, #0]
    451c:	6812      	ldr	r2, [r2, #0]
    451e:	4610      	mov	r0, r2
    4520:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    4522:	4b5e      	ldr	r3, [pc, #376]	; (469c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4524:	681b      	ldr	r3, [r3, #0]
    4526:	689b      	ldr	r3, [r3, #8]
    4528:	4a5d      	ldr	r2, [pc, #372]	; (46a0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    452a:	6812      	ldr	r2, [r2, #0]
    452c:	6812      	ldr	r2, [r2, #0]
    452e:	4610      	mov	r0, r2
    4530:	4798      	blx	r3
            }
        }
        break;
    4532:	e090      	b.n	4656 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    4534:	9b00      	ldr	r3, [sp, #0]
    4536:	2b02      	cmp	r3, #2
    4538:	f040 808f 	bne.w	465a <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    453c:	4b4a      	ldr	r3, [pc, #296]	; (4668 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    453e:	2201      	movs	r2, #1
    4540:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    4542:	4b56      	ldr	r3, [pc, #344]	; (469c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4544:	681b      	ldr	r3, [r3, #0]
    4546:	685b      	ldr	r3, [r3, #4]
    4548:	4a55      	ldr	r2, [pc, #340]	; (46a0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    454a:	6812      	ldr	r2, [r2, #0]
    454c:	4610      	mov	r0, r2
    454e:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    4550:	4b50      	ldr	r3, [pc, #320]	; (4694 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4552:	681b      	ldr	r3, [r3, #0]
    4554:	691b      	ldr	r3, [r3, #16]
    4556:	4a50      	ldr	r2, [pc, #320]	; (4698 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4558:	6812      	ldr	r2, [r2, #0]
    455a:	4610      	mov	r0, r2
    455c:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    455e:	4b4d      	ldr	r3, [pc, #308]	; (4694 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4560:	681b      	ldr	r3, [r3, #0]
    4562:	689b      	ldr	r3, [r3, #8]
    4564:	4a4c      	ldr	r2, [pc, #304]	; (4698 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    4566:	6812      	ldr	r2, [r2, #0]
    4568:	4610      	mov	r0, r2
    456a:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    456c:	4b47      	ldr	r3, [pc, #284]	; (468c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    456e:	681b      	ldr	r3, [r3, #0]
    4570:	68db      	ldr	r3, [r3, #12]
    4572:	4a47      	ldr	r2, [pc, #284]	; (4690 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4574:	6812      	ldr	r2, [r2, #0]
    4576:	4610      	mov	r0, r2
    4578:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    457a:	4b44      	ldr	r3, [pc, #272]	; (468c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    457c:	681b      	ldr	r3, [r3, #0]
    457e:	689b      	ldr	r3, [r3, #8]
    4580:	4a43      	ldr	r2, [pc, #268]	; (4690 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4582:	6812      	ldr	r2, [r2, #0]
    4584:	6812      	ldr	r2, [r2, #0]
    4586:	4610      	mov	r0, r2
    4588:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    458a:	4b38      	ldr	r3, [pc, #224]	; (466c <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    458c:	681b      	ldr	r3, [r3, #0]
    458e:	685b      	ldr	r3, [r3, #4]
    4590:	4a44      	ldr	r2, [pc, #272]	; (46a4 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    4592:	6812      	ldr	r2, [r2, #0]
    4594:	4610      	mov	r0, r2
    4596:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    4598:	4b36      	ldr	r3, [pc, #216]	; (4674 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    459a:	681b      	ldr	r3, [r3, #0]
    459c:	681b      	ldr	r3, [r3, #0]
    459e:	4a42      	ldr	r2, [pc, #264]	; (46a8 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    45a0:	6812      	ldr	r2, [r2, #0]
    45a2:	4610      	mov	r0, r2
    45a4:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    45a6:	4b35      	ldr	r3, [pc, #212]	; (467c <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    45a8:	681b      	ldr	r3, [r3, #0]
    45aa:	681b      	ldr	r3, [r3, #0]
    45ac:	4a3f      	ldr	r2, [pc, #252]	; (46ac <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    45ae:	6812      	ldr	r2, [r2, #0]
    45b0:	4610      	mov	r0, r2
    45b2:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    45b4:	4b33      	ldr	r3, [pc, #204]	; (4684 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    45b6:	681b      	ldr	r3, [r3, #0]
    45b8:	681b      	ldr	r3, [r3, #0]
    45ba:	4a3d      	ldr	r2, [pc, #244]	; (46b0 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    45bc:	6812      	ldr	r2, [r2, #0]
    45be:	4610      	mov	r0, r2
    45c0:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    45c2:	e04a      	b.n	465a <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    45c4:	9b00      	ldr	r3, [sp, #0]
    45c6:	2b02      	cmp	r3, #2
    45c8:	d149      	bne.n	465e <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    45ca:	4b27      	ldr	r3, [pc, #156]	; (4668 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    45cc:	2201      	movs	r2, #1
    45ce:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    45d0:	4b32      	ldr	r3, [pc, #200]	; (469c <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    45d2:	681b      	ldr	r3, [r3, #0]
    45d4:	685b      	ldr	r3, [r3, #4]
    45d6:	4a32      	ldr	r2, [pc, #200]	; (46a0 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    45d8:	6812      	ldr	r2, [r2, #0]
    45da:	4610      	mov	r0, r2
    45dc:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    45de:	4b2d      	ldr	r3, [pc, #180]	; (4694 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    45e0:	681b      	ldr	r3, [r3, #0]
    45e2:	691b      	ldr	r3, [r3, #16]
    45e4:	4a2c      	ldr	r2, [pc, #176]	; (4698 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    45e6:	6812      	ldr	r2, [r2, #0]
    45e8:	4610      	mov	r0, r2
    45ea:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    45ec:	4b29      	ldr	r3, [pc, #164]	; (4694 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    45ee:	681b      	ldr	r3, [r3, #0]
    45f0:	689b      	ldr	r3, [r3, #8]
    45f2:	4a29      	ldr	r2, [pc, #164]	; (4698 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    45f4:	6812      	ldr	r2, [r2, #0]
    45f6:	4610      	mov	r0, r2
    45f8:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    45fa:	4b24      	ldr	r3, [pc, #144]	; (468c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    45fc:	681b      	ldr	r3, [r3, #0]
    45fe:	68db      	ldr	r3, [r3, #12]
    4600:	4a23      	ldr	r2, [pc, #140]	; (4690 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4602:	6812      	ldr	r2, [r2, #0]
    4604:	4610      	mov	r0, r2
    4606:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    4608:	4b20      	ldr	r3, [pc, #128]	; (468c <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    460a:	681b      	ldr	r3, [r3, #0]
    460c:	689b      	ldr	r3, [r3, #8]
    460e:	4a20      	ldr	r2, [pc, #128]	; (4690 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4610:	6812      	ldr	r2, [r2, #0]
    4612:	6812      	ldr	r2, [r2, #0]
    4614:	4610      	mov	r0, r2
    4616:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    4618:	4b26      	ldr	r3, [pc, #152]	; (46b4 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    461a:	681b      	ldr	r3, [r3, #0]
    461c:	685b      	ldr	r3, [r3, #4]
    461e:	4a26      	ldr	r2, [pc, #152]	; (46b8 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    4620:	6812      	ldr	r2, [r2, #0]
    4622:	4610      	mov	r0, r2
    4624:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    4626:	4b25      	ldr	r3, [pc, #148]	; (46bc <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    4628:	681b      	ldr	r3, [r3, #0]
    462a:	681b      	ldr	r3, [r3, #0]
    462c:	4a24      	ldr	r2, [pc, #144]	; (46c0 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    462e:	6812      	ldr	r2, [r2, #0]
    4630:	4610      	mov	r0, r2
    4632:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    4634:	4b23      	ldr	r3, [pc, #140]	; (46c4 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    4636:	681b      	ldr	r3, [r3, #0]
    4638:	681b      	ldr	r3, [r3, #0]
    463a:	4a23      	ldr	r2, [pc, #140]	; (46c8 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    463c:	6812      	ldr	r2, [r2, #0]
    463e:	4610      	mov	r0, r2
    4640:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    4642:	4b22      	ldr	r3, [pc, #136]	; (46cc <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    4644:	681b      	ldr	r3, [r3, #0]
    4646:	681b      	ldr	r3, [r3, #0]
    4648:	4a21      	ldr	r2, [pc, #132]	; (46d0 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    464a:	6812      	ldr	r2, [r2, #0]
    464c:	4610      	mov	r0, r2
    464e:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    4650:	e005      	b.n	465e <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    4652:	bf00      	nop
    4654:	e004      	b.n	4660 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4656:	bf00      	nop
    4658:	e002      	b.n	4660 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    465a:	bf00      	nop
    465c:	e000      	b.n	4660 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    465e:	bf00      	nop
    }

}
    4660:	bf00      	nop
    4662:	b003      	add	sp, #12
    4664:	f85d fb04 	ldr.w	pc, [sp], #4
    4668:	1fff8b19 	.word	0x1fff8b19
    466c:	1fff8bd8 	.word	0x1fff8bd8
    4670:	1fff8bf8 	.word	0x1fff8bf8
    4674:	1fff8bdc 	.word	0x1fff8bdc
    4678:	1fff8c00 	.word	0x1fff8c00
    467c:	1fff8be0 	.word	0x1fff8be0
    4680:	1fff8c08 	.word	0x1fff8c08
    4684:	1fff8be4 	.word	0x1fff8be4
    4688:	1fff8c10 	.word	0x1fff8c10
    468c:	1fff8bcc 	.word	0x1fff8bcc
    4690:	1fff8bf0 	.word	0x1fff8bf0
    4694:	1fff8bd0 	.word	0x1fff8bd0
    4698:	1fff8bec 	.word	0x1fff8bec
    469c:	1fff8bd4 	.word	0x1fff8bd4
    46a0:	1fff8be8 	.word	0x1fff8be8
    46a4:	1fff8bf4 	.word	0x1fff8bf4
    46a8:	1fff8bfc 	.word	0x1fff8bfc
    46ac:	1fff8c04 	.word	0x1fff8c04
    46b0:	1fff8c0c 	.word	0x1fff8c0c
    46b4:	1fff8c14 	.word	0x1fff8c14
    46b8:	1fff8c24 	.word	0x1fff8c24
    46bc:	1fff8c18 	.word	0x1fff8c18
    46c0:	1fff8c28 	.word	0x1fff8c28
    46c4:	1fff8c1c 	.word	0x1fff8c1c
    46c8:	1fff8c2c 	.word	0x1fff8c2c
    46cc:	1fff8c20 	.word	0x1fff8c20
    46d0:	1fff8c30 	.word	0x1fff8c30

000046d4 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    46d4:	b500      	push	{lr}
    46d6:	b083      	sub	sp, #12
    46d8:	9001      	str	r0, [sp, #4]
    46da:	9100      	str	r1, [sp, #0]
    switch(Command)
    46dc:	9b00      	ldr	r3, [sp, #0]
    46de:	2b04      	cmp	r3, #4
    46e0:	d010      	beq.n	4704 <Clock_Ip_Command+0x30>
    46e2:	9b00      	ldr	r3, [sp, #0]
    46e4:	2b04      	cmp	r3, #4
    46e6:	d811      	bhi.n	470c <Clock_Ip_Command+0x38>
    46e8:	9b00      	ldr	r3, [sp, #0]
    46ea:	2b01      	cmp	r3, #1
    46ec:	d006      	beq.n	46fc <Clock_Ip_Command+0x28>
    46ee:	9b00      	ldr	r3, [sp, #0]
    46f0:	2b02      	cmp	r3, #2
    46f2:	d10b      	bne.n	470c <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    46f4:	9801      	ldr	r0, [sp, #4]
    46f6:	f7ff fdb3 	bl	4260 <Clock_Ip_ClockInitializeObjects>
            break;
    46fa:	e008      	b.n	470e <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    46fc:	9801      	ldr	r0, [sp, #4]
    46fe:	f7ff f9db 	bl	3ab8 <Clock_Ip_SpecificPlatformInitClock>
            break;
    4702:	e004      	b.n	470e <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    4704:	9801      	ldr	r0, [sp, #4]
    4706:	f7ff f8ed 	bl	38e4 <DisableSafeClock>
            break;
    470a:	e000      	b.n	470e <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    470c:	bf00      	nop
    }
}
    470e:	bf00      	nop
    4710:	b003      	add	sp, #12
    4712:	f85d fb04 	ldr.w	pc, [sp], #4
    4716:	bf00      	nop

00004718 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    4718:	b500      	push	{lr}
    471a:	b085      	sub	sp, #20
    471c:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    471e:	4a20      	ldr	r2, [pc, #128]	; (47a0 <Mcu_Init+0x88>)
    4720:	9b01      	ldr	r3, [sp, #4]
    4722:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4724:	2300      	movs	r3, #0
    4726:	9303      	str	r3, [sp, #12]
    4728:	e010      	b.n	474c <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    472a:	4b1d      	ldr	r3, [pc, #116]	; (47a0 <Mcu_Init+0x88>)
    472c:	681b      	ldr	r3, [r3, #0]
    472e:	6919      	ldr	r1, [r3, #16]
    4730:	9a03      	ldr	r2, [sp, #12]
    4732:	4613      	mov	r3, r2
    4734:	005b      	lsls	r3, r3, #1
    4736:	4413      	add	r3, r2
    4738:	009b      	lsls	r3, r3, #2
    473a:	440b      	add	r3, r1
    473c:	681b      	ldr	r3, [r3, #0]
    473e:	9a03      	ldr	r2, [sp, #12]
    4740:	b2d1      	uxtb	r1, r2
    4742:	4a18      	ldr	r2, [pc, #96]	; (47a4 <Mcu_Init+0x8c>)
    4744:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4746:	9b03      	ldr	r3, [sp, #12]
    4748:	3301      	adds	r3, #1
    474a:	9303      	str	r3, [sp, #12]
    474c:	4b14      	ldr	r3, [pc, #80]	; (47a0 <Mcu_Init+0x88>)
    474e:	681b      	ldr	r3, [r3, #0]
    4750:	689b      	ldr	r3, [r3, #8]
    4752:	9a03      	ldr	r2, [sp, #12]
    4754:	429a      	cmp	r2, r3
    4756:	d3e8      	bcc.n	472a <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    4758:	2300      	movs	r3, #0
    475a:	9303      	str	r3, [sp, #12]
    475c:	e010      	b.n	4780 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    475e:	4b10      	ldr	r3, [pc, #64]	; (47a0 <Mcu_Init+0x88>)
    4760:	681b      	ldr	r3, [r3, #0]
    4762:	6959      	ldr	r1, [r3, #20]
    4764:	9a03      	ldr	r2, [sp, #12]
    4766:	4613      	mov	r3, r2
    4768:	01db      	lsls	r3, r3, #7
    476a:	1a9b      	subs	r3, r3, r2
    476c:	00db      	lsls	r3, r3, #3
    476e:	440b      	add	r3, r1
    4770:	681b      	ldr	r3, [r3, #0]
    4772:	9a03      	ldr	r2, [sp, #12]
    4774:	b2d1      	uxtb	r1, r2
    4776:	4a0c      	ldr	r2, [pc, #48]	; (47a8 <Mcu_Init+0x90>)
    4778:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    477a:	9b03      	ldr	r3, [sp, #12]
    477c:	3301      	adds	r3, #1
    477e:	9303      	str	r3, [sp, #12]
    4780:	4b07      	ldr	r3, [pc, #28]	; (47a0 <Mcu_Init+0x88>)
    4782:	681b      	ldr	r3, [r3, #0]
    4784:	68db      	ldr	r3, [r3, #12]
    4786:	9a03      	ldr	r2, [sp, #12]
    4788:	429a      	cmp	r2, r3
    478a:	d3e8      	bcc.n	475e <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    478c:	4b04      	ldr	r3, [pc, #16]	; (47a0 <Mcu_Init+0x88>)
    478e:	681b      	ldr	r3, [r3, #0]
    4790:	699b      	ldr	r3, [r3, #24]
    4792:	4618      	mov	r0, r3
    4794:	f000 f88a 	bl	48ac <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4798:	bf00      	nop
    479a:	b005      	add	sp, #20
    479c:	f85d fb04 	ldr.w	pc, [sp], #4
    47a0:	1fff8d0c 	.word	0x1fff8d0c
    47a4:	1fff8d08 	.word	0x1fff8d08
    47a8:	1fff8d04 	.word	0x1fff8d04

000047ac <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    47ac:	b084      	sub	sp, #16
    47ae:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    47b0:	2301      	movs	r3, #1
    47b2:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    47b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    47ba:	4618      	mov	r0, r3
    47bc:	b004      	add	sp, #16
    47be:	4770      	bx	lr

000047c0 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    47c0:	b500      	push	{lr}
    47c2:	b085      	sub	sp, #20
    47c4:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    47c6:	4a0e      	ldr	r2, [pc, #56]	; (4800 <Mcu_InitClock+0x40>)
    47c8:	9b01      	ldr	r3, [sp, #4]
    47ca:	4413      	add	r3, r2
    47cc:	781b      	ldrb	r3, [r3, #0]
    47ce:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    47d2:	4b0c      	ldr	r3, [pc, #48]	; (4804 <Mcu_InitClock+0x44>)
    47d4:	681b      	ldr	r3, [r3, #0]
    47d6:	6959      	ldr	r1, [r3, #20]
    47d8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    47dc:	4613      	mov	r3, r2
    47de:	01db      	lsls	r3, r3, #7
    47e0:	1a9b      	subs	r3, r3, r2
    47e2:	00db      	lsls	r3, r3, #3
    47e4:	440b      	add	r3, r1
    47e6:	4618      	mov	r0, r3
    47e8:	f000 f86a 	bl	48c0 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    47ec:	2300      	movs	r3, #0
    47ee:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    47f2:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    47f6:	4618      	mov	r0, r3
    47f8:	b005      	add	sp, #20
    47fa:	f85d fb04 	ldr.w	pc, [sp], #4
    47fe:	bf00      	nop
    4800:	1fff8d04 	.word	0x1fff8d04
    4804:	1fff8d0c 	.word	0x1fff8d0c

00004808 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    4808:	b500      	push	{lr}
    480a:	b085      	sub	sp, #20
    480c:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    480e:	4a0d      	ldr	r2, [pc, #52]	; (4844 <Mcu_SetMode+0x3c>)
    4810:	9b01      	ldr	r3, [sp, #4]
    4812:	4413      	add	r3, r2
    4814:	781b      	ldrb	r3, [r3, #0]
    4816:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    481a:	f005 f8e1 	bl	99e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    481e:	4b0a      	ldr	r3, [pc, #40]	; (4848 <Mcu_SetMode+0x40>)
    4820:	681b      	ldr	r3, [r3, #0]
    4822:	6919      	ldr	r1, [r3, #16]
    4824:	f89d 200f 	ldrb.w	r2, [sp, #15]
    4828:	4613      	mov	r3, r2
    482a:	005b      	lsls	r3, r3, #1
    482c:	4413      	add	r3, r2
    482e:	009b      	lsls	r3, r3, #2
    4830:	440b      	add	r3, r1
    4832:	4618      	mov	r0, r3
    4834:	f000 f84e 	bl	48d4 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    4838:	f005 f8fe 	bl	9a38 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    483c:	bf00      	nop
    483e:	b005      	add	sp, #20
    4840:	f85d fb04 	ldr.w	pc, [sp], #4
    4844:	1fff8d08 	.word	0x1fff8d08
    4848:	1fff8d0c 	.word	0x1fff8d0c

0000484c <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    484c:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    484e:	2302      	movs	r3, #2
    4850:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    4852:	9b01      	ldr	r3, [sp, #4]
}
    4854:	4618      	mov	r0, r3
    4856:	b002      	add	sp, #8
    4858:	4770      	bx	lr

0000485a <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    485a:	b500      	push	{lr}
    485c:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    485e:	f000 f843 	bl	48e8 <Mcu_Ipw_GetResetReason>
    4862:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    4864:	9b01      	ldr	r3, [sp, #4]
}
    4866:	4618      	mov	r0, r3
    4868:	b003      	add	sp, #12
    486a:	f85d fb04 	ldr.w	pc, [sp], #4

0000486e <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    486e:	b500      	push	{lr}
    4870:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    4872:	f000 f83f 	bl	48f4 <Mcu_Ipw_GetResetRawValue>
    4876:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    4878:	9b01      	ldr	r3, [sp, #4]
}
    487a:	4618      	mov	r0, r3
    487c:	b003      	add	sp, #12
    487e:	f85d fb04 	ldr.w	pc, [sp], #4

00004882 <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4882:	b500      	push	{lr}
    4884:	b083      	sub	sp, #12
    4886:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    4888:	9801      	ldr	r0, [sp, #4]
    488a:	f000 f839 	bl	4900 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    488e:	bf00      	nop
    4890:	b003      	add	sp, #12
    4892:	f85d fb04 	ldr.w	pc, [sp], #4

00004896 <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    4896:	b082      	sub	sp, #8
    4898:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    489a:	4b03      	ldr	r3, [pc, #12]	; (48a8 <Mcu_ClkSrcFailureNotification+0x12>)
    489c:	681b      	ldr	r3, [r3, #0]
    489e:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    48a0:	bf00      	nop
    48a2:	b002      	add	sp, #8
    48a4:	4770      	bx	lr
    48a6:	bf00      	nop
    48a8:	1fff8d0c 	.word	0x1fff8d0c

000048ac <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    48ac:	b500      	push	{lr}
    48ae:	b083      	sub	sp, #12
    48b0:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    48b2:	9801      	ldr	r0, [sp, #4]
    48b4:	f000 f882 	bl	49bc <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    48b8:	bf00      	nop
    48ba:	b003      	add	sp, #12
    48bc:	f85d fb04 	ldr.w	pc, [sp], #4

000048c0 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    48c0:	b500      	push	{lr}
    48c2:	b083      	sub	sp, #12
    48c4:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    48c6:	9801      	ldr	r0, [sp, #4]
    48c8:	f7fc fc6a 	bl	11a0 <Clock_Ip_InitClock>
}
    48cc:	bf00      	nop
    48ce:	b003      	add	sp, #12
    48d0:	f85d fb04 	ldr.w	pc, [sp], #4

000048d4 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    48d4:	b500      	push	{lr}
    48d6:	b083      	sub	sp, #12
    48d8:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    48da:	9801      	ldr	r0, [sp, #4]
    48dc:	f000 f820 	bl	4920 <Power_Ip_SetMode>
}
    48e0:	bf00      	nop
    48e2:	b003      	add	sp, #12
    48e4:	f85d fb04 	ldr.w	pc, [sp], #4

000048e8 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    48e8:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    48ea:	f000 f84f 	bl	498c <Power_Ip_GetResetReason>
    48ee:	4603      	mov	r3, r0
}
    48f0:	4618      	mov	r0, r3
    48f2:	bd08      	pop	{r3, pc}

000048f4 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    48f4:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    48f6:	f000 f857 	bl	49a8 <Power_Ip_GetResetRawValue>
    48fa:	4603      	mov	r3, r0
}
    48fc:	4618      	mov	r0, r3
    48fe:	bd08      	pop	{r3, pc}

00004900 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4900:	b500      	push	{lr}
    4902:	b083      	sub	sp, #12
    4904:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    4906:	9b01      	ldr	r3, [sp, #4]
    4908:	2b00      	cmp	r3, #0
    490a:	d102      	bne.n	4912 <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    490c:	f000 f86c 	bl	49e8 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    4910:	e001      	b.n	4916 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    4912:	f000 f86e 	bl	49f2 <Power_Ip_EnableSleepOnExit>
}
    4916:	bf00      	nop
    4918:	b003      	add	sp, #12
    491a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004920 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4920:	b500      	push	{lr}
    4922:	b085      	sub	sp, #20
    4924:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    4926:	9b01      	ldr	r3, [sp, #4]
    4928:	685b      	ldr	r3, [r3, #4]
    492a:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    492c:	9802      	ldr	r0, [sp, #8]
    492e:	f000 f9f5 	bl	4d1c <Power_Ip_SMC_ModeCheckEntry>
    4932:	4603      	mov	r3, r0
    4934:	2b00      	cmp	r3, #0
    4936:	d002      	beq.n	493e <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4938:	2301      	movs	r3, #1
    493a:	9303      	str	r3, [sp, #12]
    493c:	e003      	b.n	4946 <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    493e:	9801      	ldr	r0, [sp, #4]
    4940:	f000 fa1e 	bl	4d80 <Power_Ip_SMC_ModeConfig>
    4944:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    4946:	9b03      	ldr	r3, [sp, #12]
    4948:	2b01      	cmp	r3, #1
    494a:	d103      	bne.n	4954 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    494c:	21ff      	movs	r1, #255	; 0xff
    494e:	2003      	movs	r0, #3
    4950:	f000 f8f4 	bl	4b3c <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    4954:	bf00      	nop
    4956:	b005      	add	sp, #20
    4958:	f85d fb04 	ldr.w	pc, [sp], #4

0000495c <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    495c:	b084      	sub	sp, #16
    495e:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    4960:	230c      	movs	r3, #12
    4962:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    4964:	4a08      	ldr	r2, [pc, #32]	; (4988 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4966:	9b01      	ldr	r3, [sp, #4]
    4968:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    496c:	2b0e      	cmp	r3, #14
    496e:	d805      	bhi.n	497c <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    4970:	4a05      	ldr	r2, [pc, #20]	; (4988 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    4972:	9b01      	ldr	r3, [sp, #4]
    4974:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4978:	9303      	str	r3, [sp, #12]
    497a:	e001      	b.n	4980 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    497c:	230c      	movs	r3, #12
    497e:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    4980:	9b03      	ldr	r3, [sp, #12]
}
    4982:	4618      	mov	r0, r3
    4984:	b004      	add	sp, #16
    4986:	4770      	bx	lr
    4988:	0000b66c 	.word	0x0000b66c

0000498c <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    498c:	b500      	push	{lr}
    498e:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    4990:	f000 f940 	bl	4c14 <Power_Ip_RCM_GetResetReason>
    4994:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    4996:	9801      	ldr	r0, [sp, #4]
    4998:	f7ff ffe0 	bl	495c <Power_Ip_ConvertIntergeToResetType>
    499c:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    499e:	9b00      	ldr	r3, [sp, #0]
}
    49a0:	4618      	mov	r0, r3
    49a2:	b003      	add	sp, #12
    49a4:	f85d fb04 	ldr.w	pc, [sp], #4

000049a8 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    49a8:	b500      	push	{lr}
    49aa:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    49ac:	f000 f98a 	bl	4cc4 <Power_Ip_RCM_GetResetRawValue>
    49b0:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    49b2:	9b01      	ldr	r3, [sp, #4]
}
    49b4:	4618      	mov	r0, r3
    49b6:	b003      	add	sp, #12
    49b8:	f85d fb04 	ldr.w	pc, [sp], #4

000049bc <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    49bc:	b500      	push	{lr}
    49be:	b083      	sub	sp, #12
    49c0:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    49c2:	9b01      	ldr	r3, [sp, #4]
    49c4:	681b      	ldr	r3, [r3, #0]
    49c6:	4618      	mov	r0, r3
    49c8:	f000 f90e 	bl	4be8 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    49cc:	9b01      	ldr	r3, [sp, #4]
    49ce:	685b      	ldr	r3, [r3, #4]
    49d0:	4618      	mov	r0, r3
    49d2:	f000 f86d 	bl	4ab0 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    49d6:	9b01      	ldr	r3, [sp, #4]
    49d8:	689b      	ldr	r3, [r3, #8]
    49da:	4618      	mov	r0, r3
    49dc:	f000 f990 	bl	4d00 <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    49e0:	bf00      	nop
    49e2:	b003      	add	sp, #12
    49e4:	f85d fb04 	ldr.w	pc, [sp], #4

000049e8 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    49e8:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    49ea:	f000 f811 	bl	4a10 <Power_Ip_CM4_DisableSleepOnExit>
}
    49ee:	bf00      	nop
    49f0:	bd08      	pop	{r3, pc}

000049f2 <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    49f2:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    49f4:	f000 f820 	bl	4a38 <Power_Ip_CM4_EnableSleepOnExit>
}
    49f8:	bf00      	nop
    49fa:	bd08      	pop	{r3, pc}

000049fc <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    49fc:	b082      	sub	sp, #8
    49fe:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    4a00:	4a02      	ldr	r2, [pc, #8]	; (4a0c <Power_Ip_InstallNotificationsCallback+0x10>)
    4a02:	9b01      	ldr	r3, [sp, #4]
    4a04:	6013      	str	r3, [r2, #0]
}
    4a06:	bf00      	nop
    4a08:	b002      	add	sp, #8
    4a0a:	4770      	bx	lr
    4a0c:	1fff8b1c 	.word	0x1fff8b1c

00004a10 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    4a10:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4a12:	2300      	movs	r3, #0
    4a14:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4a16:	4b07      	ldr	r3, [pc, #28]	; (4a34 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4a18:	681b      	ldr	r3, [r3, #0]
    4a1a:	685b      	ldr	r3, [r3, #4]
    4a1c:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    4a1e:	9b01      	ldr	r3, [sp, #4]
    4a20:	f023 0302 	bic.w	r3, r3, #2
    4a24:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4a26:	4b03      	ldr	r3, [pc, #12]	; (4a34 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4a28:	681b      	ldr	r3, [r3, #0]
    4a2a:	9a01      	ldr	r2, [sp, #4]
    4a2c:	605a      	str	r2, [r3, #4]
}
    4a2e:	bf00      	nop
    4a30:	b002      	add	sp, #8
    4a32:	4770      	bx	lr
    4a34:	1fff8b20 	.word	0x1fff8b20

00004a38 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    4a38:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4a3a:	2300      	movs	r3, #0
    4a3c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4a3e:	4b07      	ldr	r3, [pc, #28]	; (4a5c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4a40:	681b      	ldr	r3, [r3, #0]
    4a42:	685b      	ldr	r3, [r3, #4]
    4a44:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    4a46:	9b01      	ldr	r3, [sp, #4]
    4a48:	f043 0302 	orr.w	r3, r3, #2
    4a4c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4a4e:	4b03      	ldr	r3, [pc, #12]	; (4a5c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    4a50:	681b      	ldr	r3, [r3, #0]
    4a52:	9a01      	ldr	r2, [sp, #4]
    4a54:	605a      	str	r2, [r3, #4]
}
    4a56:	bf00      	nop
    4a58:	b002      	add	sp, #8
    4a5a:	4770      	bx	lr
    4a5c:	1fff8b20 	.word	0x1fff8b20

00004a60 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    4a60:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4a62:	2300      	movs	r3, #0
    4a64:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4a66:	4b07      	ldr	r3, [pc, #28]	; (4a84 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4a68:	681b      	ldr	r3, [r3, #0]
    4a6a:	685b      	ldr	r3, [r3, #4]
    4a6c:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    4a6e:	9b01      	ldr	r3, [sp, #4]
    4a70:	f043 0304 	orr.w	r3, r3, #4
    4a74:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4a76:	4b03      	ldr	r3, [pc, #12]	; (4a84 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    4a78:	681b      	ldr	r3, [r3, #0]
    4a7a:	9a01      	ldr	r2, [sp, #4]
    4a7c:	605a      	str	r2, [r3, #4]
}
    4a7e:	bf00      	nop
    4a80:	b002      	add	sp, #8
    4a82:	4770      	bx	lr
    4a84:	1fff8b20 	.word	0x1fff8b20

00004a88 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    4a88:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4a8a:	2300      	movs	r3, #0
    4a8c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4a8e:	4b07      	ldr	r3, [pc, #28]	; (4aac <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4a90:	681b      	ldr	r3, [r3, #0]
    4a92:	685b      	ldr	r3, [r3, #4]
    4a94:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    4a96:	9b01      	ldr	r3, [sp, #4]
    4a98:	f023 0304 	bic.w	r3, r3, #4
    4a9c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4a9e:	4b03      	ldr	r3, [pc, #12]	; (4aac <Power_Ip_CM4_DisableDeepSleep+0x24>)
    4aa0:	681b      	ldr	r3, [r3, #0]
    4aa2:	9a01      	ldr	r2, [sp, #4]
    4aa4:	605a      	str	r2, [r3, #4]
}
    4aa6:	bf00      	nop
    4aa8:	b002      	add	sp, #8
    4aaa:	4770      	bx	lr
    4aac:	1fff8b20 	.word	0x1fff8b20

00004ab0 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    4ab0:	b084      	sub	sp, #16
    4ab2:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    4ab4:	4b20      	ldr	r3, [pc, #128]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4ab6:	781b      	ldrb	r3, [r3, #0]
    4ab8:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    4abc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4ac0:	f003 030f 	and.w	r3, r3, #15
    4ac4:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    4ac8:	9b01      	ldr	r3, [sp, #4]
    4aca:	781a      	ldrb	r2, [r3, #0]
    4acc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4ad0:	4313      	orrs	r3, r2
    4ad2:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    4ad6:	4a18      	ldr	r2, [pc, #96]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4ad8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4adc:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    4ade:	4b16      	ldr	r3, [pc, #88]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4ae0:	785b      	ldrb	r3, [r3, #1]
    4ae2:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    4ae6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4aea:	f003 031f 	and.w	r3, r3, #31
    4aee:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    4af2:	9b01      	ldr	r3, [sp, #4]
    4af4:	785a      	ldrb	r2, [r3, #1]
    4af6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4afa:	4313      	orrs	r3, r2
    4afc:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    4b00:	4a0d      	ldr	r2, [pc, #52]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4b02:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4b06:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    4b08:	4b0b      	ldr	r3, [pc, #44]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4b0a:	789b      	ldrb	r3, [r3, #2]
    4b0c:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    4b10:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4b14:	f003 0338 	and.w	r3, r3, #56	; 0x38
    4b18:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    4b1c:	9b01      	ldr	r3, [sp, #4]
    4b1e:	789a      	ldrb	r2, [r3, #2]
    4b20:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4b24:	4313      	orrs	r3, r2
    4b26:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    4b2a:	4a03      	ldr	r2, [pc, #12]	; (4b38 <Power_Ip_PMC_PowerInit+0x88>)
    4b2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4b30:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    4b32:	bf00      	nop
    4b34:	b004      	add	sp, #16
    4b36:	4770      	bx	lr
    4b38:	4007d000 	.word	0x4007d000

00004b3c <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4b3c:	b500      	push	{lr}
    4b3e:	b083      	sub	sp, #12
    4b40:	9001      	str	r0, [sp, #4]
    4b42:	460b      	mov	r3, r1
    4b44:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    4b48:	4b05      	ldr	r3, [pc, #20]	; (4b60 <Power_Ip_ReportPowerErrors+0x24>)
    4b4a:	681b      	ldr	r3, [r3, #0]
    4b4c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    4b50:	4611      	mov	r1, r2
    4b52:	9801      	ldr	r0, [sp, #4]
    4b54:	4798      	blx	r3
}
    4b56:	bf00      	nop
    4b58:	b003      	add	sp, #12
    4b5a:	f85d fb04 	ldr.w	pc, [sp], #4
    4b5e:	bf00      	nop
    4b60:	1fff8b1c 	.word	0x1fff8b1c

00004b64 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4b64:	b082      	sub	sp, #8
    4b66:	9001      	str	r0, [sp, #4]
    4b68:	460b      	mov	r3, r1
    4b6a:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    4b6e:	bf00      	nop
    4b70:	b002      	add	sp, #8
    4b72:	4770      	bx	lr

00004b74 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    4b74:	b500      	push	{lr}
    4b76:	b085      	sub	sp, #20
    4b78:	9003      	str	r0, [sp, #12]
    4b7a:	9102      	str	r1, [sp, #8]
    4b7c:	9201      	str	r2, [sp, #4]
    4b7e:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    4b80:	2000      	movs	r0, #0
    4b82:	f7fc f83c 	bl	bfe <OsIf_GetCounter>
    4b86:	4602      	mov	r2, r0
    4b88:	9b03      	ldr	r3, [sp, #12]
    4b8a:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    4b8c:	9b02      	ldr	r3, [sp, #8]
    4b8e:	2200      	movs	r2, #0
    4b90:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    4b92:	2100      	movs	r1, #0
    4b94:	9800      	ldr	r0, [sp, #0]
    4b96:	f7fc f87e 	bl	c96 <OsIf_MicrosToTicks>
    4b9a:	4602      	mov	r2, r0
    4b9c:	9b01      	ldr	r3, [sp, #4]
    4b9e:	601a      	str	r2, [r3, #0]
}
    4ba0:	bf00      	nop
    4ba2:	b005      	add	sp, #20
    4ba4:	f85d fb04 	ldr.w	pc, [sp], #4

00004ba8 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    4ba8:	b500      	push	{lr}
    4baa:	b087      	sub	sp, #28
    4bac:	9003      	str	r0, [sp, #12]
    4bae:	9102      	str	r1, [sp, #8]
    4bb0:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    4bb2:	2300      	movs	r3, #0
    4bb4:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    4bb8:	2100      	movs	r1, #0
    4bba:	9803      	ldr	r0, [sp, #12]
    4bbc:	f7fc f838 	bl	c30 <OsIf_GetElapsed>
    4bc0:	4602      	mov	r2, r0
    4bc2:	9b02      	ldr	r3, [sp, #8]
    4bc4:	681b      	ldr	r3, [r3, #0]
    4bc6:	441a      	add	r2, r3
    4bc8:	9b02      	ldr	r3, [sp, #8]
    4bca:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    4bcc:	9b02      	ldr	r3, [sp, #8]
    4bce:	681b      	ldr	r3, [r3, #0]
    4bd0:	9a01      	ldr	r2, [sp, #4]
    4bd2:	429a      	cmp	r2, r3
    4bd4:	d802      	bhi.n	4bdc <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    4bd6:	2301      	movs	r3, #1
    4bd8:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    4bdc:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    4be0:	4618      	mov	r0, r3
    4be2:	b007      	add	sp, #28
    4be4:	f85d fb04 	ldr.w	pc, [sp], #4

00004be8 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    4be8:	b082      	sub	sp, #8
    4bea:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    4bec:	9b01      	ldr	r3, [sp, #4]
    4bee:	681a      	ldr	r2, [r3, #0]
    4bf0:	4907      	ldr	r1, [pc, #28]	; (4c10 <Power_Ip_RCM_ResetInit+0x28>)
    4bf2:	f641 7307 	movw	r3, #7943	; 0x1f07
    4bf6:	4013      	ands	r3, r2
    4bf8:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    4bfa:	9b01      	ldr	r3, [sp, #4]
    4bfc:	685a      	ldr	r2, [r3, #4]
    4bfe:	4904      	ldr	r1, [pc, #16]	; (4c10 <Power_Ip_RCM_ResetInit+0x28>)
    4c00:	f642 73ff 	movw	r3, #12287	; 0x2fff
    4c04:	4013      	ands	r3, r2
    4c06:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    4c08:	bf00      	nop
    4c0a:	b002      	add	sp, #8
    4c0c:	4770      	bx	lr
    4c0e:	bf00      	nop
    4c10:	4007f000 	.word	0x4007f000

00004c14 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    4c14:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    4c16:	230c      	movs	r3, #12
    4c18:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    4c1a:	2300      	movs	r3, #0
    4c1c:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    4c1e:	2300      	movs	r3, #0
    4c20:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    4c22:	2300      	movs	r3, #0
    4c24:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    4c26:	4b25      	ldr	r3, [pc, #148]	; (4cbc <Power_Ip_RCM_GetResetReason+0xa8>)
    4c28:	699a      	ldr	r2, [r3, #24]
    4c2a:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4c2e:	4013      	ands	r3, r2
    4c30:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    4c32:	9b03      	ldr	r3, [sp, #12]
    4c34:	2b00      	cmp	r3, #0
    4c36:	d008      	beq.n	4c4a <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    4c38:	4920      	ldr	r1, [pc, #128]	; (4cbc <Power_Ip_RCM_GetResetReason+0xa8>)
    4c3a:	9a03      	ldr	r2, [sp, #12]
    4c3c:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4c40:	4013      	ands	r3, r2
    4c42:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    4c44:	4a1e      	ldr	r2, [pc, #120]	; (4cc0 <Power_Ip_RCM_GetResetReason+0xac>)
    4c46:	9b03      	ldr	r3, [sp, #12]
    4c48:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    4c4a:	4b1d      	ldr	r3, [pc, #116]	; (4cc0 <Power_Ip_RCM_GetResetReason+0xac>)
    4c4c:	681b      	ldr	r3, [r3, #0]
    4c4e:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    4c50:	9a02      	ldr	r2, [sp, #8]
    4c52:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4c56:	4013      	ands	r3, r2
    4c58:	2b82      	cmp	r3, #130	; 0x82
    4c5a:	d102      	bne.n	4c62 <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    4c5c:	2305      	movs	r3, #5
    4c5e:	9307      	str	r3, [sp, #28]
    4c60:	e027      	b.n	4cb2 <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    4c62:	2300      	movs	r3, #0
    4c64:	9306      	str	r3, [sp, #24]
    4c66:	e021      	b.n	4cac <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    4c68:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4c6c:	9b06      	ldr	r3, [sp, #24]
    4c6e:	fa22 f303 	lsr.w	r3, r2, r3
    4c72:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    4c74:	9a01      	ldr	r2, [sp, #4]
    4c76:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    4c7a:	4013      	ands	r3, r2
    4c7c:	2b00      	cmp	r3, #0
    4c7e:	d012      	beq.n	4ca6 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    4c80:	9a01      	ldr	r2, [sp, #4]
    4c82:	9b02      	ldr	r3, [sp, #8]
    4c84:	4013      	ands	r3, r2
    4c86:	2b00      	cmp	r3, #0
    4c88:	d00a      	beq.n	4ca0 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    4c8a:	9b05      	ldr	r3, [sp, #20]
    4c8c:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    4c8e:	9b04      	ldr	r3, [sp, #16]
    4c90:	3301      	adds	r3, #1
    4c92:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    4c94:	9b04      	ldr	r3, [sp, #16]
    4c96:	2b01      	cmp	r3, #1
    4c98:	d902      	bls.n	4ca0 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    4c9a:	230d      	movs	r3, #13
    4c9c:	9307      	str	r3, [sp, #28]
                        break;
    4c9e:	e008      	b.n	4cb2 <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    4ca0:	9b05      	ldr	r3, [sp, #20]
    4ca2:	3301      	adds	r3, #1
    4ca4:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    4ca6:	9b06      	ldr	r3, [sp, #24]
    4ca8:	3301      	adds	r3, #1
    4caa:	9306      	str	r3, [sp, #24]
    4cac:	9b06      	ldr	r3, [sp, #24]
    4cae:	2b1f      	cmp	r3, #31
    4cb0:	d9da      	bls.n	4c68 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    4cb2:	9b07      	ldr	r3, [sp, #28]
}
    4cb4:	4618      	mov	r0, r3
    4cb6:	b008      	add	sp, #32
    4cb8:	4770      	bx	lr
    4cba:	bf00      	nop
    4cbc:	4007f000 	.word	0x4007f000
    4cc0:	1fff8d10 	.word	0x1fff8d10

00004cc4 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    4cc4:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    4cc6:	4b0c      	ldr	r3, [pc, #48]	; (4cf8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    4cc8:	699a      	ldr	r2, [r3, #24]
    4cca:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4cce:	4013      	ands	r3, r2
    4cd0:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    4cd2:	9b01      	ldr	r3, [sp, #4]
    4cd4:	2b00      	cmp	r3, #0
    4cd6:	d008      	beq.n	4cea <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    4cd8:	4907      	ldr	r1, [pc, #28]	; (4cf8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    4cda:	9a01      	ldr	r2, [sp, #4]
    4cdc:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4ce0:	4013      	ands	r3, r2
    4ce2:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    4ce4:	4a05      	ldr	r2, [pc, #20]	; (4cfc <Power_Ip_RCM_GetResetRawValue+0x38>)
    4ce6:	9b01      	ldr	r3, [sp, #4]
    4ce8:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    4cea:	4b04      	ldr	r3, [pc, #16]	; (4cfc <Power_Ip_RCM_GetResetRawValue+0x38>)
    4cec:	681b      	ldr	r3, [r3, #0]
    4cee:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    4cf0:	9b00      	ldr	r3, [sp, #0]
}
    4cf2:	4618      	mov	r0, r3
    4cf4:	b002      	add	sp, #8
    4cf6:	4770      	bx	lr
    4cf8:	4007f000 	.word	0x4007f000
    4cfc:	1fff8d10 	.word	0x1fff8d10

00004d00 <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    4d00:	b082      	sub	sp, #8
    4d02:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    4d04:	9b01      	ldr	r3, [sp, #4]
    4d06:	681b      	ldr	r3, [r3, #0]
    4d08:	4a03      	ldr	r2, [pc, #12]	; (4d18 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    4d0a:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    4d0e:	6093      	str	r3, [r2, #8]
}
    4d10:	bf00      	nop
    4d12:	b002      	add	sp, #8
    4d14:	4770      	bx	lr
    4d16:	bf00      	nop
    4d18:	4007e000 	.word	0x4007e000

00004d1c <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    4d1c:	b084      	sub	sp, #16
    4d1e:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    4d20:	2301      	movs	r3, #1
    4d22:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    4d24:	4b15      	ldr	r3, [pc, #84]	; (4d7c <Power_Ip_SMC_ModeCheckEntry+0x60>)
    4d26:	695b      	ldr	r3, [r3, #20]
    4d28:	b2db      	uxtb	r3, r3
    4d2a:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    4d2c:	9b01      	ldr	r3, [sp, #4]
    4d2e:	2b02      	cmp	r3, #2
    4d30:	d012      	beq.n	4d58 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    4d32:	9b01      	ldr	r3, [sp, #4]
    4d34:	2b02      	cmp	r3, #2
    4d36:	d818      	bhi.n	4d6a <Power_Ip_SMC_ModeCheckEntry+0x4e>
    4d38:	9b01      	ldr	r3, [sp, #4]
    4d3a:	2b00      	cmp	r3, #0
    4d3c:	d003      	beq.n	4d46 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    4d3e:	9b01      	ldr	r3, [sp, #4]
    4d40:	2b01      	cmp	r3, #1
    4d42:	d003      	beq.n	4d4c <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    4d44:	e011      	b.n	4d6a <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    4d46:	2300      	movs	r3, #0
    4d48:	9303      	str	r3, [sp, #12]
            break;
    4d4a:	e013      	b.n	4d74 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    4d4c:	9b02      	ldr	r3, [sp, #8]
    4d4e:	2b01      	cmp	r3, #1
    4d50:	d10d      	bne.n	4d6e <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    4d52:	2300      	movs	r3, #0
    4d54:	9303      	str	r3, [sp, #12]
            break;
    4d56:	e00a      	b.n	4d6e <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    4d58:	9b02      	ldr	r3, [sp, #8]
    4d5a:	2b01      	cmp	r3, #1
    4d5c:	d002      	beq.n	4d64 <Power_Ip_SMC_ModeCheckEntry+0x48>
    4d5e:	9b02      	ldr	r3, [sp, #8]
    4d60:	2b10      	cmp	r3, #16
    4d62:	d106      	bne.n	4d72 <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    4d64:	2300      	movs	r3, #0
    4d66:	9303      	str	r3, [sp, #12]
            break;
    4d68:	e003      	b.n	4d72 <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    4d6a:	bf00      	nop
    4d6c:	e002      	b.n	4d74 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4d6e:	bf00      	nop
    4d70:	e000      	b.n	4d74 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4d72:	bf00      	nop
        }
    }

    return PowerModeCheck;
    4d74:	9b03      	ldr	r3, [sp, #12]
}
    4d76:	4618      	mov	r0, r3
    4d78:	b004      	add	sp, #16
    4d7a:	4770      	bx	lr
    4d7c:	4007e000 	.word	0x4007e000

00004d80 <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4d80:	b500      	push	{lr}
    4d82:	b08b      	sub	sp, #44	; 0x2c
    4d84:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    4d86:	2300      	movs	r3, #0
    4d88:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    4d8a:	2300      	movs	r3, #0
    4d8c:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    4d8e:	2300      	movs	r3, #0
    4d90:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    4d94:	9b01      	ldr	r3, [sp, #4]
    4d96:	685b      	ldr	r3, [r3, #4]
    4d98:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    4d9a:	9b08      	ldr	r3, [sp, #32]
    4d9c:	2b02      	cmp	r3, #2
    4d9e:	d076      	beq.n	4e8e <Power_Ip_SMC_ModeConfig+0x10e>
    4da0:	9b08      	ldr	r3, [sp, #32]
    4da2:	2b02      	cmp	r3, #2
    4da4:	f200 80ab 	bhi.w	4efe <Power_Ip_SMC_ModeConfig+0x17e>
    4da8:	9b08      	ldr	r3, [sp, #32]
    4daa:	2b00      	cmp	r3, #0
    4dac:	d003      	beq.n	4db6 <Power_Ip_SMC_ModeConfig+0x36>
    4dae:	9b08      	ldr	r3, [sp, #32]
    4db0:	2b01      	cmp	r3, #1
    4db2:	d034      	beq.n	4e1e <Power_Ip_SMC_ModeConfig+0x9e>
    4db4:	e0a3      	b.n	4efe <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    4db6:	4b58      	ldr	r3, [pc, #352]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4db8:	68db      	ldr	r3, [r3, #12]
    4dba:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4dbc:	9b06      	ldr	r3, [sp, #24]
    4dbe:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4dc2:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    4dc4:	4a54      	ldr	r2, [pc, #336]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4dc6:	9b06      	ldr	r3, [sp, #24]
    4dc8:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4dca:	aa02      	add	r2, sp, #8
    4dcc:	a903      	add	r1, sp, #12
    4dce:	a804      	add	r0, sp, #16
    4dd0:	f24c 3350 	movw	r3, #50000	; 0xc350
    4dd4:	f7ff fece 	bl	4b74 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4dd8:	9a02      	ldr	r2, [sp, #8]
    4dda:	a903      	add	r1, sp, #12
    4ddc:	ab04      	add	r3, sp, #16
    4dde:	4618      	mov	r0, r3
    4de0:	f7ff fee2 	bl	4ba8 <Power_Ip_TimeoutExpired>
    4de4:	4603      	mov	r3, r0
    4de6:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    4dea:	4b4b      	ldr	r3, [pc, #300]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4dec:	695b      	ldr	r3, [r3, #20]
    4dee:	f003 0301 	and.w	r3, r3, #1
    4df2:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4df4:	9b05      	ldr	r3, [sp, #20]
    4df6:	2b01      	cmp	r3, #1
    4df8:	d006      	beq.n	4e08 <Power_Ip_SMC_ModeConfig+0x88>
    4dfa:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4dfe:	f083 0301 	eor.w	r3, r3, #1
    4e02:	b2db      	uxtb	r3, r3
    4e04:	2b00      	cmp	r3, #0
    4e06:	d1e7      	bne.n	4dd8 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    4e08:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e0c:	2b00      	cmp	r3, #0
    4e0e:	d079      	beq.n	4f04 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4e10:	2301      	movs	r3, #1
    4e12:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4e14:	21ff      	movs	r1, #255	; 0xff
    4e16:	2000      	movs	r0, #0
    4e18:	f7ff fe90 	bl	4b3c <Power_Ip_ReportPowerErrors>
            }

            break;
    4e1c:	e072      	b.n	4f04 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    4e1e:	4b3e      	ldr	r3, [pc, #248]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4e20:	68db      	ldr	r3, [r3, #12]
    4e22:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4e24:	9b06      	ldr	r3, [sp, #24]
    4e26:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4e2a:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    4e2c:	9b06      	ldr	r3, [sp, #24]
    4e2e:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    4e32:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4e34:	4a38      	ldr	r2, [pc, #224]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4e36:	9b06      	ldr	r3, [sp, #24]
    4e38:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4e3a:	aa02      	add	r2, sp, #8
    4e3c:	a903      	add	r1, sp, #12
    4e3e:	a804      	add	r0, sp, #16
    4e40:	f24c 3350 	movw	r3, #50000	; 0xc350
    4e44:	f7ff fe96 	bl	4b74 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4e48:	9a02      	ldr	r2, [sp, #8]
    4e4a:	a903      	add	r1, sp, #12
    4e4c:	ab04      	add	r3, sp, #16
    4e4e:	4618      	mov	r0, r3
    4e50:	f7ff feaa 	bl	4ba8 <Power_Ip_TimeoutExpired>
    4e54:	4603      	mov	r3, r0
    4e56:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    4e5a:	4b2f      	ldr	r3, [pc, #188]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4e5c:	695b      	ldr	r3, [r3, #20]
    4e5e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4e62:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4e64:	9b05      	ldr	r3, [sp, #20]
    4e66:	2b80      	cmp	r3, #128	; 0x80
    4e68:	d006      	beq.n	4e78 <Power_Ip_SMC_ModeConfig+0xf8>
    4e6a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e6e:	f083 0301 	eor.w	r3, r3, #1
    4e72:	b2db      	uxtb	r3, r3
    4e74:	2b00      	cmp	r3, #0
    4e76:	d1e7      	bne.n	4e48 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    4e78:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e7c:	2b00      	cmp	r3, #0
    4e7e:	d043      	beq.n	4f08 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4e80:	2301      	movs	r3, #1
    4e82:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4e84:	21ff      	movs	r1, #255	; 0xff
    4e86:	2000      	movs	r0, #0
    4e88:	f7ff fe58 	bl	4b3c <Power_Ip_ReportPowerErrors>
            }

            break;
    4e8c:	e03c      	b.n	4f08 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    4e8e:	4b22      	ldr	r3, [pc, #136]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4e90:	68db      	ldr	r3, [r3, #12]
    4e92:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4e94:	9b06      	ldr	r3, [sp, #24]
    4e96:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4e9a:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    4e9c:	9b06      	ldr	r3, [sp, #24]
    4e9e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4ea2:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4ea4:	4a1c      	ldr	r2, [pc, #112]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4ea6:	9b06      	ldr	r3, [sp, #24]
    4ea8:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4eaa:	aa02      	add	r2, sp, #8
    4eac:	a903      	add	r1, sp, #12
    4eae:	a804      	add	r0, sp, #16
    4eb0:	f24c 3350 	movw	r3, #50000	; 0xc350
    4eb4:	f7ff fe5e 	bl	4b74 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4eb8:	9a02      	ldr	r2, [sp, #8]
    4eba:	a903      	add	r1, sp, #12
    4ebc:	ab04      	add	r3, sp, #16
    4ebe:	4618      	mov	r0, r3
    4ec0:	f7ff fe72 	bl	4ba8 <Power_Ip_TimeoutExpired>
    4ec4:	4603      	mov	r3, r0
    4ec6:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    4eca:	4b13      	ldr	r3, [pc, #76]	; (4f18 <Power_Ip_SMC_ModeConfig+0x198>)
    4ecc:	695b      	ldr	r3, [r3, #20]
    4ece:	f003 0304 	and.w	r3, r3, #4
    4ed2:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4ed4:	9b05      	ldr	r3, [sp, #20]
    4ed6:	2b04      	cmp	r3, #4
    4ed8:	d006      	beq.n	4ee8 <Power_Ip_SMC_ModeConfig+0x168>
    4eda:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4ede:	f083 0301 	eor.w	r3, r3, #1
    4ee2:	b2db      	uxtb	r3, r3
    4ee4:	2b00      	cmp	r3, #0
    4ee6:	d1e7      	bne.n	4eb8 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    4ee8:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4eec:	2b00      	cmp	r3, #0
    4eee:	d00d      	beq.n	4f0c <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4ef0:	2301      	movs	r3, #1
    4ef2:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4ef4:	21ff      	movs	r1, #255	; 0xff
    4ef6:	2000      	movs	r0, #0
    4ef8:	f7ff fe20 	bl	4b3c <Power_Ip_ReportPowerErrors>
            }

            break;
    4efc:	e006      	b.n	4f0c <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4efe:	2301      	movs	r3, #1
    4f00:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    4f02:	e004      	b.n	4f0e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4f04:	bf00      	nop
    4f06:	e002      	b.n	4f0e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4f08:	bf00      	nop
    4f0a:	e000      	b.n	4f0e <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4f0c:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    4f0e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    4f10:	4618      	mov	r0, r3
    4f12:	b00b      	add	sp, #44	; 0x2c
    4f14:	f85d fb04 	ldr.w	pc, [sp], #4
    4f18:	4007e000 	.word	0x4007e000

00004f1c <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    4f1c:	b500      	push	{lr}
    4f1e:	b085      	sub	sp, #20
    4f20:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    4f22:	9b01      	ldr	r3, [sp, #4]
    4f24:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    4f26:	9803      	ldr	r0, [sp, #12]
    4f28:	f000 fbc8 	bl	56bc <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    4f2c:	4a03      	ldr	r2, [pc, #12]	; (4f3c <Port_Init+0x20>)
    4f2e:	9b03      	ldr	r3, [sp, #12]
    4f30:	6013      	str	r3, [r2, #0]
        }
    }
}
    4f32:	bf00      	nop
    4f34:	b005      	add	sp, #20
    4f36:	f85d fb04 	ldr.w	pc, [sp], #4
    4f3a:	bf00      	nop
    4f3c:	1fff8d14 	.word	0x1fff8d14

00004f40 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    4f40:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    4f42:	4b03      	ldr	r3, [pc, #12]	; (4f50 <Port_RefreshPortDirection+0x10>)
    4f44:	681b      	ldr	r3, [r3, #0]
    4f46:	4618      	mov	r0, r3
    4f48:	f000 fc10 	bl	576c <Port_Ipw_RefreshPortDirection>
    }
}
    4f4c:	bf00      	nop
    4f4e:	bd08      	pop	{r3, pc}
    4f50:	1fff8d14 	.word	0x1fff8d14

00004f54 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    4f54:	b086      	sub	sp, #24
    4f56:	9003      	str	r0, [sp, #12]
    4f58:	9102      	str	r1, [sp, #8]
    4f5a:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    4f5c:	23ff      	movs	r3, #255	; 0xff
    4f5e:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    4f60:	9b03      	ldr	r3, [sp, #12]
    4f62:	4a39      	ldr	r2, [pc, #228]	; (5048 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    4f64:	4293      	cmp	r3, r2
    4f66:	d151      	bne.n	500c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    4f68:	9b02      	ldr	r3, [sp, #8]
    4f6a:	2b10      	cmp	r3, #16
    4f6c:	d867      	bhi.n	503e <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    4f6e:	a201      	add	r2, pc, #4	; (adr r2, 4f74 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    4f70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4f74:	00004fb9 	.word	0x00004fb9
    4f78:	00004fc7 	.word	0x00004fc7
    4f7c:	0000503f 	.word	0x0000503f
    4f80:	0000503f 	.word	0x0000503f
    4f84:	0000503f 	.word	0x0000503f
    4f88:	0000503f 	.word	0x0000503f
    4f8c:	0000503f 	.word	0x0000503f
    4f90:	0000503f 	.word	0x0000503f
    4f94:	0000503f 	.word	0x0000503f
    4f98:	0000503f 	.word	0x0000503f
    4f9c:	0000503f 	.word	0x0000503f
    4fa0:	0000503f 	.word	0x0000503f
    4fa4:	0000503f 	.word	0x0000503f
    4fa8:	00004fd5 	.word	0x00004fd5
    4fac:	00004fe3 	.word	0x00004fe3
    4fb0:	00004ff1 	.word	0x00004ff1
    4fb4:	00004fff 	.word	0x00004fff
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    4fb8:	2301      	movs	r3, #1
    4fba:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4fbc:	9a05      	ldr	r2, [sp, #20]
    4fbe:	9b01      	ldr	r3, [sp, #4]
    4fc0:	4313      	orrs	r3, r2
    4fc2:	9305      	str	r3, [sp, #20]
                break;
    4fc4:	e03c      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    4fc6:	2302      	movs	r3, #2
    4fc8:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4fca:	9a05      	ldr	r2, [sp, #20]
    4fcc:	9b01      	ldr	r3, [sp, #4]
    4fce:	4313      	orrs	r3, r2
    4fd0:	9305      	str	r3, [sp, #20]
                break;
    4fd2:	e035      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    4fd4:	2304      	movs	r3, #4
    4fd6:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4fd8:	9a05      	ldr	r2, [sp, #20]
    4fda:	9b01      	ldr	r3, [sp, #4]
    4fdc:	4313      	orrs	r3, r2
    4fde:	9305      	str	r3, [sp, #20]
                break;
    4fe0:	e02e      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    4fe2:	2308      	movs	r3, #8
    4fe4:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4fe6:	9a05      	ldr	r2, [sp, #20]
    4fe8:	9b01      	ldr	r3, [sp, #4]
    4fea:	4313      	orrs	r3, r2
    4fec:	9305      	str	r3, [sp, #20]
                break;
    4fee:	e027      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    4ff0:	230e      	movs	r3, #14
    4ff2:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4ff4:	9a05      	ldr	r2, [sp, #20]
    4ff6:	9b01      	ldr	r3, [sp, #4]
    4ff8:	4013      	ands	r3, r2
    4ffa:	9305      	str	r3, [sp, #20]
                break;
    4ffc:	e020      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    4ffe:	230d      	movs	r3, #13
    5000:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    5002:	9a05      	ldr	r2, [sp, #20]
    5004:	9b01      	ldr	r3, [sp, #4]
    5006:	4013      	ands	r3, r2
    5008:	9305      	str	r3, [sp, #20]
                break;
    500a:	e019      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    500c:	9b03      	ldr	r3, [sp, #12]
    500e:	4a0f      	ldr	r2, [pc, #60]	; (504c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    5010:	4293      	cmp	r3, r2
    5012:	d115      	bne.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    5014:	9b02      	ldr	r3, [sp, #8]
    5016:	2b00      	cmp	r3, #0
    5018:	d003      	beq.n	5022 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    501a:	9b02      	ldr	r3, [sp, #8]
    501c:	2b01      	cmp	r3, #1
    501e:	d007      	beq.n	5030 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    5020:	e00e      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    5022:	230b      	movs	r3, #11
    5024:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    5026:	9a05      	ldr	r2, [sp, #20]
    5028:	9b01      	ldr	r3, [sp, #4]
    502a:	4013      	ands	r3, r2
    502c:	9305      	str	r3, [sp, #20]
                break;
    502e:	e007      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    5030:	2307      	movs	r3, #7
    5032:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    5034:	9a05      	ldr	r2, [sp, #20]
    5036:	9b01      	ldr	r3, [sp, #4]
    5038:	4013      	ands	r3, r2
    503a:	9305      	str	r3, [sp, #20]
                break;
    503c:	e000      	b.n	5040 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    503e:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    5040:	9b05      	ldr	r3, [sp, #20]
}
    5042:	4618      	mov	r0, r3
    5044:	b006      	add	sp, #24
    5046:	4770      	bx	lr
    5048:	4004a000 	.word	0x4004a000
    504c:	4004b000 	.word	0x4004b000

00005050 <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    5050:	b500      	push	{lr}
    5052:	b089      	sub	sp, #36	; 0x24
    5054:	9003      	str	r0, [sp, #12]
    5056:	9102      	str	r1, [sp, #8]
    5058:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    505a:	9b01      	ldr	r3, [sp, #4]
    505c:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    505e:	9b01      	ldr	r3, [sp, #4]
    5060:	2b08      	cmp	r3, #8
    5062:	d121      	bne.n	50a8 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    5064:	4b13      	ldr	r3, [pc, #76]	; (50b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    5066:	685b      	ldr	r3, [r3, #4]
    5068:	f003 030f 	and.w	r3, r3, #15
    506c:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    506e:	9a06      	ldr	r2, [sp, #24]
    5070:	9902      	ldr	r1, [sp, #8]
    5072:	9803      	ldr	r0, [sp, #12]
    5074:	f7ff ff6e 	bl	4f54 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    5078:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    507a:	9b05      	ldr	r3, [sp, #20]
    507c:	2bff      	cmp	r3, #255	; 0xff
    507e:	d011      	beq.n	50a4 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    5080:	f004 ff3e 	bl	9f00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    5084:	4b0b      	ldr	r3, [pc, #44]	; (50b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    5086:	685b      	ldr	r3, [r3, #4]
    5088:	4a0a      	ldr	r2, [pc, #40]	; (50b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    508a:	f023 030f 	bic.w	r3, r3, #15
    508e:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    5090:	4b08      	ldr	r3, [pc, #32]	; (50b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    5092:	685a      	ldr	r2, [r3, #4]
    5094:	9b05      	ldr	r3, [sp, #20]
    5096:	f003 030f 	and.w	r3, r3, #15
    509a:	4906      	ldr	r1, [pc, #24]	; (50b4 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    509c:	4313      	orrs	r3, r2
    509e:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    50a0:	f004 ff5a 	bl	9f58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    50a4:	2300      	movs	r3, #0
    50a6:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    50a8:	9b07      	ldr	r3, [sp, #28]
}
    50aa:	4618      	mov	r0, r3
    50ac:	b009      	add	sp, #36	; 0x24
    50ae:	f85d fb04 	ldr.w	pc, [sp], #4
    50b2:	bf00      	nop
    50b4:	40048000 	.word	0x40048000

000050b8 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    50b8:	b500      	push	{lr}
    50ba:	b087      	sub	sp, #28
    50bc:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    50be:	2300      	movs	r3, #0
    50c0:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    50c2:	2300      	movs	r3, #0
    50c4:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    50c6:	2300      	movs	r3, #0
    50c8:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    50ca:	9b01      	ldr	r3, [sp, #4]
    50cc:	68db      	ldr	r3, [r3, #12]
    50ce:	2b02      	cmp	r3, #2
    50d0:	d00a      	beq.n	50e8 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    50d2:	9b05      	ldr	r3, [sp, #20]
    50d4:	f043 0302 	orr.w	r3, r3, #2
    50d8:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    50da:	9b01      	ldr	r3, [sp, #4]
    50dc:	68db      	ldr	r3, [r3, #12]
    50de:	f003 0301 	and.w	r3, r3, #1
    50e2:	9a05      	ldr	r2, [sp, #20]
    50e4:	4313      	orrs	r3, r2
    50e6:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    50e8:	9b01      	ldr	r3, [sp, #4]
    50ea:	699b      	ldr	r3, [r3, #24]
    50ec:	019b      	lsls	r3, r3, #6
    50ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
    50f2:	9a05      	ldr	r2, [sp, #20]
    50f4:	4313      	orrs	r3, r2
    50f6:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    50f8:	9b01      	ldr	r3, [sp, #4]
    50fa:	6a1b      	ldr	r3, [r3, #32]
    50fc:	03db      	lsls	r3, r3, #15
    50fe:	b29b      	uxth	r3, r3
    5100:	9a05      	ldr	r2, [sp, #20]
    5102:	4313      	orrs	r3, r2
    5104:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    5106:	9b01      	ldr	r3, [sp, #4]
    5108:	7f1b      	ldrb	r3, [r3, #28]
    510a:	2b00      	cmp	r3, #0
    510c:	d001      	beq.n	5112 <Port_Ci_Port_Ip_PinInit+0x5a>
    510e:	2310      	movs	r3, #16
    5110:	e000      	b.n	5114 <Port_Ci_Port_Ip_PinInit+0x5c>
    5112:	2300      	movs	r3, #0
    5114:	9a05      	ldr	r2, [sp, #20]
    5116:	4313      	orrs	r3, r2
    5118:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    511a:	9b01      	ldr	r3, [sp, #4]
    511c:	691b      	ldr	r3, [r3, #16]
    511e:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    5120:	9b01      	ldr	r3, [sp, #4]
    5122:	6818      	ldr	r0, [r3, #0]
    5124:	9b01      	ldr	r3, [sp, #4]
    5126:	689b      	ldr	r3, [r3, #8]
    5128:	9a04      	ldr	r2, [sp, #16]
    512a:	4619      	mov	r1, r3
    512c:	f7ff ff90 	bl	5050 <Port_Ci_Port_Ip_ConfigureInterleave>
    5130:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    5132:	9b03      	ldr	r3, [sp, #12]
    5134:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    5136:	9b04      	ldr	r3, [sp, #16]
    5138:	021b      	lsls	r3, r3, #8
    513a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    513e:	9a05      	ldr	r2, [sp, #20]
    5140:	4313      	orrs	r3, r2
    5142:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    5144:	f004 fd42 	bl	9bcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    5148:	9b01      	ldr	r3, [sp, #4]
    514a:	681b      	ldr	r3, [r3, #0]
    514c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    5150:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    5152:	9b01      	ldr	r3, [sp, #4]
    5154:	689b      	ldr	r3, [r3, #8]
    5156:	2201      	movs	r2, #1
    5158:	fa02 f303 	lsl.w	r3, r2, r3
    515c:	43db      	mvns	r3, r3
    515e:	9a02      	ldr	r2, [sp, #8]
    5160:	4013      	ands	r3, r2
    5162:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    5164:	9b01      	ldr	r3, [sp, #4]
    5166:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    516a:	2b00      	cmp	r3, #0
    516c:	d001      	beq.n	5172 <Port_Ci_Port_Ip_PinInit+0xba>
    516e:	2201      	movs	r2, #1
    5170:	e000      	b.n	5174 <Port_Ci_Port_Ip_PinInit+0xbc>
    5172:	2200      	movs	r2, #0
    5174:	9b01      	ldr	r3, [sp, #4]
    5176:	689b      	ldr	r3, [r3, #8]
    5178:	fa02 f303 	lsl.w	r3, r2, r3
    517c:	9a02      	ldr	r2, [sp, #8]
    517e:	4313      	orrs	r3, r2
    5180:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    5182:	9b01      	ldr	r3, [sp, #4]
    5184:	681b      	ldr	r3, [r3, #0]
    5186:	9a02      	ldr	r2, [sp, #8]
    5188:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    518c:	f004 fd4a 	bl	9c24 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    5190:	9b04      	ldr	r3, [sp, #16]
    5192:	2b01      	cmp	r3, #1
    5194:	d16d      	bne.n	5272 <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    5196:	9b01      	ldr	r3, [sp, #4]
    5198:	695b      	ldr	r3, [r3, #20]
    519a:	2b02      	cmp	r3, #2
    519c:	d138      	bne.n	5210 <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    519e:	9b01      	ldr	r3, [sp, #4]
    51a0:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    51a4:	2b01      	cmp	r3, #1
    51a6:	d10f      	bne.n	51c8 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    51a8:	f004 fd62 	bl	9c70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    51ac:	9b01      	ldr	r3, [sp, #4]
    51ae:	685b      	ldr	r3, [r3, #4]
    51b0:	6859      	ldr	r1, [r3, #4]
    51b2:	9b01      	ldr	r3, [sp, #4]
    51b4:	689b      	ldr	r3, [r3, #8]
    51b6:	2201      	movs	r2, #1
    51b8:	409a      	lsls	r2, r3
    51ba:	9b01      	ldr	r3, [sp, #4]
    51bc:	685b      	ldr	r3, [r3, #4]
    51be:	430a      	orrs	r2, r1
    51c0:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    51c2:	f004 fd81 	bl	9cc8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    51c6:	e013      	b.n	51f0 <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    51c8:	9b01      	ldr	r3, [sp, #4]
    51ca:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    51ce:	2b00      	cmp	r3, #0
    51d0:	d10e      	bne.n	51f0 <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    51d2:	f004 fd9f 	bl	9d14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    51d6:	9b01      	ldr	r3, [sp, #4]
    51d8:	685b      	ldr	r3, [r3, #4]
    51da:	6899      	ldr	r1, [r3, #8]
    51dc:	9b01      	ldr	r3, [sp, #4]
    51de:	689b      	ldr	r3, [r3, #8]
    51e0:	2201      	movs	r2, #1
    51e2:	409a      	lsls	r2, r3
    51e4:	9b01      	ldr	r3, [sp, #4]
    51e6:	685b      	ldr	r3, [r3, #4]
    51e8:	430a      	orrs	r2, r1
    51ea:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    51ec:	f004 fdbe 	bl	9d6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    51f0:	f004 fde2 	bl	9db8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    51f4:	9b01      	ldr	r3, [sp, #4]
    51f6:	685b      	ldr	r3, [r3, #4]
    51f8:	6959      	ldr	r1, [r3, #20]
    51fa:	9b01      	ldr	r3, [sp, #4]
    51fc:	689b      	ldr	r3, [r3, #8]
    51fe:	2201      	movs	r2, #1
    5200:	409a      	lsls	r2, r3
    5202:	9b01      	ldr	r3, [sp, #4]
    5204:	685b      	ldr	r3, [r3, #4]
    5206:	430a      	orrs	r2, r1
    5208:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    520a:	f004 fe01 	bl	9e10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    520e:	e030      	b.n	5272 <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    5210:	f004 fdd2 	bl	9db8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    5214:	9b01      	ldr	r3, [sp, #4]
    5216:	685b      	ldr	r3, [r3, #4]
    5218:	6959      	ldr	r1, [r3, #20]
    521a:	9b01      	ldr	r3, [sp, #4]
    521c:	689b      	ldr	r3, [r3, #8]
    521e:	2201      	movs	r2, #1
    5220:	fa02 f303 	lsl.w	r3, r2, r3
    5224:	43da      	mvns	r2, r3
    5226:	9b01      	ldr	r3, [sp, #4]
    5228:	685b      	ldr	r3, [r3, #4]
    522a:	400a      	ands	r2, r1
    522c:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    522e:	f004 fdef 	bl	9e10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    5232:	f004 fe13 	bl	9e5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    5236:	9b01      	ldr	r3, [sp, #4]
    5238:	685b      	ldr	r3, [r3, #4]
    523a:	6999      	ldr	r1, [r3, #24]
    523c:	9b01      	ldr	r3, [sp, #4]
    523e:	689b      	ldr	r3, [r3, #8]
    5240:	2201      	movs	r2, #1
    5242:	fa02 f303 	lsl.w	r3, r2, r3
    5246:	43da      	mvns	r2, r3
    5248:	9b01      	ldr	r3, [sp, #4]
    524a:	685b      	ldr	r3, [r3, #4]
    524c:	400a      	ands	r2, r1
    524e:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    5250:	9b01      	ldr	r3, [sp, #4]
    5252:	695b      	ldr	r3, [r3, #20]
    5254:	2b03      	cmp	r3, #3
    5256:	d10a      	bne.n	526e <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    5258:	9b01      	ldr	r3, [sp, #4]
    525a:	685b      	ldr	r3, [r3, #4]
    525c:	6999      	ldr	r1, [r3, #24]
    525e:	9b01      	ldr	r3, [sp, #4]
    5260:	689b      	ldr	r3, [r3, #8]
    5262:	2201      	movs	r2, #1
    5264:	409a      	lsls	r2, r3
    5266:	9b01      	ldr	r3, [sp, #4]
    5268:	685b      	ldr	r3, [r3, #4]
    526a:	430a      	orrs	r2, r1
    526c:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    526e:	f004 fe21 	bl	9eb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    5272:	9b01      	ldr	r3, [sp, #4]
    5274:	681b      	ldr	r3, [r3, #0]
    5276:	9a01      	ldr	r2, [sp, #4]
    5278:	6892      	ldr	r2, [r2, #8]
    527a:	9905      	ldr	r1, [sp, #20]
    527c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    5280:	bf00      	nop
    5282:	b007      	add	sp, #28
    5284:	f85d fb04 	ldr.w	pc, [sp], #4

00005288 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    5288:	b500      	push	{lr}
    528a:	b085      	sub	sp, #20
    528c:	9001      	str	r0, [sp, #4]
    528e:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    5290:	2300      	movs	r3, #0
    5292:	9303      	str	r3, [sp, #12]
    5294:	e00d      	b.n	52b2 <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    5296:	9a03      	ldr	r2, [sp, #12]
    5298:	4613      	mov	r3, r2
    529a:	009b      	lsls	r3, r3, #2
    529c:	4413      	add	r3, r2
    529e:	00db      	lsls	r3, r3, #3
    52a0:	461a      	mov	r2, r3
    52a2:	9b00      	ldr	r3, [sp, #0]
    52a4:	4413      	add	r3, r2
    52a6:	4618      	mov	r0, r3
    52a8:	f7ff ff06 	bl	50b8 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    52ac:	9b03      	ldr	r3, [sp, #12]
    52ae:	3301      	adds	r3, #1
    52b0:	9303      	str	r3, [sp, #12]
    52b2:	9a03      	ldr	r2, [sp, #12]
    52b4:	9b01      	ldr	r3, [sp, #4]
    52b6:	429a      	cmp	r2, r3
    52b8:	d3ed      	bcc.n	5296 <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    52ba:	2300      	movs	r3, #0
}
    52bc:	4618      	mov	r0, r3
    52be:	b005      	add	sp, #20
    52c0:	f85d fb04 	ldr.w	pc, [sp], #4

000052c4 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    52c4:	b500      	push	{lr}
    52c6:	b087      	sub	sp, #28
    52c8:	9003      	str	r0, [sp, #12]
    52ca:	9102      	str	r1, [sp, #8]
    52cc:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    52ce:	9a01      	ldr	r2, [sp, #4]
    52d0:	9902      	ldr	r1, [sp, #8]
    52d2:	9803      	ldr	r0, [sp, #12]
    52d4:	f7ff febc 	bl	5050 <Port_Ci_Port_Ip_ConfigureInterleave>
    52d8:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    52da:	f004 fe63 	bl	9fa4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    52de:	9b03      	ldr	r3, [sp, #12]
    52e0:	9a02      	ldr	r2, [sp, #8]
    52e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    52e6:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    52e8:	9b04      	ldr	r3, [sp, #16]
    52ea:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    52ee:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    52f0:	9b05      	ldr	r3, [sp, #20]
    52f2:	021b      	lsls	r3, r3, #8
    52f4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    52f8:	9a04      	ldr	r2, [sp, #16]
    52fa:	4313      	orrs	r3, r2
    52fc:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    52fe:	9b03      	ldr	r3, [sp, #12]
    5300:	9a02      	ldr	r2, [sp, #8]
    5302:	9904      	ldr	r1, [sp, #16]
    5304:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    5308:	f004 fe78 	bl	9ffc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    530c:	bf00      	nop
    530e:	b007      	add	sp, #28
    5310:	f85d fb04 	ldr.w	pc, [sp], #4

00005314 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    5314:	b500      	push	{lr}
    5316:	b083      	sub	sp, #12
    5318:	9001      	str	r0, [sp, #4]
    531a:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    531c:	f004 fe94 	bl	a048 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    5320:	9b01      	ldr	r3, [sp, #4]
    5322:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    5326:	2101      	movs	r1, #1
    5328:	9b00      	ldr	r3, [sp, #0]
    532a:	fa01 f303 	lsl.w	r3, r1, r3
    532e:	431a      	orrs	r2, r3
    5330:	9b01      	ldr	r3, [sp, #4]
    5332:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    5336:	f004 feb3 	bl	a0a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    533a:	bf00      	nop
    533c:	b003      	add	sp, #12
    533e:	f85d fb04 	ldr.w	pc, [sp], #4

00005342 <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    5342:	b500      	push	{lr}
    5344:	b083      	sub	sp, #12
    5346:	9001      	str	r0, [sp, #4]
    5348:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    534a:	f004 fecf 	bl	a0ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    534e:	9b01      	ldr	r3, [sp, #4]
    5350:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    5354:	2101      	movs	r1, #1
    5356:	9b00      	ldr	r3, [sp, #0]
    5358:	fa01 f303 	lsl.w	r3, r1, r3
    535c:	43db      	mvns	r3, r3
    535e:	401a      	ands	r2, r3
    5360:	9b01      	ldr	r3, [sp, #4]
    5362:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    5366:	f004 feed 	bl	a144 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    536a:	bf00      	nop
    536c:	b003      	add	sp, #12
    536e:	f85d fb04 	ldr.w	pc, [sp], #4

00005372 <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    5372:	b082      	sub	sp, #8
    5374:	9001      	str	r0, [sp, #4]
    5376:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    5378:	9b00      	ldr	r3, [sp, #0]
    537a:	785b      	ldrb	r3, [r3, #1]
    537c:	f003 0201 	and.w	r2, r3, #1
    5380:	9b01      	ldr	r3, [sp, #4]
    5382:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    5386:	9b00      	ldr	r3, [sp, #0]
    5388:	789b      	ldrb	r3, [r3, #2]
    538a:	f003 021f 	and.w	r2, r3, #31
    538e:	9b01      	ldr	r3, [sp, #4]
    5390:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    5394:	bf00      	nop
    5396:	b002      	add	sp, #8
    5398:	4770      	bx	lr

0000539a <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    539a:	b086      	sub	sp, #24
    539c:	9003      	str	r0, [sp, #12]
    539e:	9301      	str	r3, [sp, #4]
    53a0:	460b      	mov	r3, r1
    53a2:	f8ad 300a 	strh.w	r3, [sp, #10]
    53a6:	4613      	mov	r3, r2
    53a8:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    53ac:	2300      	movs	r3, #0
    53ae:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    53b2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53b6:	f043 0301 	orr.w	r3, r3, #1
    53ba:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    53be:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53c2:	f043 0302 	orr.w	r3, r3, #2
    53c6:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    53ca:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53ce:	f043 0310 	orr.w	r3, r3, #16
    53d2:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    53d6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    53de:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    53e2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53e6:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    53ea:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    53ee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53f2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    53f6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    53fa:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    53fe:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    5402:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    5406:	4013      	ands	r3, r2
    5408:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    540c:	9b01      	ldr	r3, [sp, #4]
    540e:	2b00      	cmp	r3, #0
    5410:	d003      	beq.n	541a <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    5412:	9b01      	ldr	r3, [sp, #4]
    5414:	2b01      	cmp	r3, #1
    5416:	d00a      	beq.n	542e <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    5418:	e013      	b.n	5442 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    541a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    541e:	041a      	lsls	r2, r3, #16
    5420:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5424:	431a      	orrs	r2, r3
    5426:	9b03      	ldr	r3, [sp, #12]
    5428:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    542c:	e009      	b.n	5442 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    542e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5432:	041a      	lsls	r2, r3, #16
    5434:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5438:	431a      	orrs	r2, r3
    543a:	9b03      	ldr	r3, [sp, #12]
    543c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    5440:	bf00      	nop
    }
}
    5442:	bf00      	nop
    5444:	b006      	add	sp, #24
    5446:	4770      	bx	lr

00005448 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    5448:	b500      	push	{lr}
    544a:	b087      	sub	sp, #28
    544c:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    544e:	9b01      	ldr	r3, [sp, #4]
    5450:	885b      	ldrh	r3, [r3, #2]
    5452:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    5456:	9b01      	ldr	r3, [sp, #4]
    5458:	689b      	ldr	r3, [r3, #8]
    545a:	7a1b      	ldrb	r3, [r3, #8]
    545c:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    5460:	9b01      	ldr	r3, [sp, #4]
    5462:	689b      	ldr	r3, [r3, #8]
    5464:	681b      	ldr	r3, [r3, #0]
    5466:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    5468:	9b01      	ldr	r3, [sp, #4]
    546a:	689b      	ldr	r3, [r3, #8]
    546c:	685b      	ldr	r3, [r3, #4]
    546e:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    5470:	2300      	movs	r3, #0
    5472:	f8ad 3016 	strh.w	r3, [sp, #22]
    5476:	e111      	b.n	569c <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    5478:	9b02      	ldr	r3, [sp, #8]
    547a:	2b02      	cmp	r3, #2
    547c:	d169      	bne.n	5552 <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    547e:	f89d 3013 	ldrb.w	r3, [sp, #19]
    5482:	2b01      	cmp	r3, #1
    5484:	d11a      	bne.n	54bc <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5486:	9b01      	ldr	r3, [sp, #4]
    5488:	685a      	ldr	r2, [r3, #4]
    548a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    548e:	005b      	lsls	r3, r3, #1
    5490:	4413      	add	r3, r2
    5492:	881b      	ldrh	r3, [r3, #0]
    5494:	f003 021f 	and.w	r2, r3, #31
    5498:	9b01      	ldr	r3, [sp, #4]
    549a:	6859      	ldr	r1, [r3, #4]
    549c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54a0:	005b      	lsls	r3, r3, #1
    54a2:	440b      	add	r3, r1
    54a4:	881b      	ldrh	r3, [r3, #0]
    54a6:	095b      	lsrs	r3, r3, #5
    54a8:	b29b      	uxth	r3, r3
    54aa:	4619      	mov	r1, r3
    54ac:	4b81      	ldr	r3, [pc, #516]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    54ae:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    54b2:	2101      	movs	r1, #1
    54b4:	fa01 f202 	lsl.w	r2, r1, r2
    54b8:	605a      	str	r2, [r3, #4]
    54ba:	e01d      	b.n	54f8 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    54bc:	f89d 3013 	ldrb.w	r3, [sp, #19]
    54c0:	2b00      	cmp	r3, #0
    54c2:	d119      	bne.n	54f8 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    54c4:	9b01      	ldr	r3, [sp, #4]
    54c6:	685a      	ldr	r2, [r3, #4]
    54c8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54cc:	005b      	lsls	r3, r3, #1
    54ce:	4413      	add	r3, r2
    54d0:	881b      	ldrh	r3, [r3, #0]
    54d2:	f003 021f 	and.w	r2, r3, #31
    54d6:	9b01      	ldr	r3, [sp, #4]
    54d8:	6859      	ldr	r1, [r3, #4]
    54da:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54de:	005b      	lsls	r3, r3, #1
    54e0:	440b      	add	r3, r1
    54e2:	881b      	ldrh	r3, [r3, #0]
    54e4:	095b      	lsrs	r3, r3, #5
    54e6:	b29b      	uxth	r3, r3
    54e8:	4619      	mov	r1, r3
    54ea:	4b72      	ldr	r3, [pc, #456]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    54ec:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    54f0:	2101      	movs	r1, #1
    54f2:	fa01 f202 	lsl.w	r2, r1, r2
    54f6:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    54f8:	f004 fe4a 	bl	a190 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    54fc:	9b01      	ldr	r3, [sp, #4]
    54fe:	685a      	ldr	r2, [r3, #4]
    5500:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5504:	005b      	lsls	r3, r3, #1
    5506:	4413      	add	r3, r2
    5508:	881b      	ldrh	r3, [r3, #0]
    550a:	095b      	lsrs	r3, r3, #5
    550c:	b29b      	uxth	r3, r3
    550e:	461a      	mov	r2, r3
    5510:	4b68      	ldr	r3, [pc, #416]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    5512:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5516:	6959      	ldr	r1, [r3, #20]
    5518:	9b01      	ldr	r3, [sp, #4]
    551a:	685a      	ldr	r2, [r3, #4]
    551c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5520:	005b      	lsls	r3, r3, #1
    5522:	4413      	add	r3, r2
    5524:	881b      	ldrh	r3, [r3, #0]
    5526:	f003 031f 	and.w	r3, r3, #31
    552a:	2201      	movs	r2, #1
    552c:	409a      	lsls	r2, r3
    552e:	9b01      	ldr	r3, [sp, #4]
    5530:	6858      	ldr	r0, [r3, #4]
    5532:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5536:	005b      	lsls	r3, r3, #1
    5538:	4403      	add	r3, r0
    553a:	881b      	ldrh	r3, [r3, #0]
    553c:	095b      	lsrs	r3, r3, #5
    553e:	b29b      	uxth	r3, r3
    5540:	4618      	mov	r0, r3
    5542:	4b5c      	ldr	r3, [pc, #368]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    5544:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5548:	430a      	orrs	r2, r1
    554a:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    554c:	f004 fe4c 	bl	a1e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    5550:	e086      	b.n	5660 <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    5552:	f004 fe1d 	bl	a190 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    5556:	9b01      	ldr	r3, [sp, #4]
    5558:	685a      	ldr	r2, [r3, #4]
    555a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    555e:	005b      	lsls	r3, r3, #1
    5560:	4413      	add	r3, r2
    5562:	881b      	ldrh	r3, [r3, #0]
    5564:	095b      	lsrs	r3, r3, #5
    5566:	b29b      	uxth	r3, r3
    5568:	461a      	mov	r2, r3
    556a:	4b52      	ldr	r3, [pc, #328]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    556c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5570:	6959      	ldr	r1, [r3, #20]
    5572:	9b01      	ldr	r3, [sp, #4]
    5574:	685a      	ldr	r2, [r3, #4]
    5576:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    557a:	005b      	lsls	r3, r3, #1
    557c:	4413      	add	r3, r2
    557e:	881b      	ldrh	r3, [r3, #0]
    5580:	f003 031f 	and.w	r3, r3, #31
    5584:	2201      	movs	r2, #1
    5586:	fa02 f303 	lsl.w	r3, r2, r3
    558a:	43da      	mvns	r2, r3
    558c:	9b01      	ldr	r3, [sp, #4]
    558e:	6858      	ldr	r0, [r3, #4]
    5590:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5594:	005b      	lsls	r3, r3, #1
    5596:	4403      	add	r3, r0
    5598:	881b      	ldrh	r3, [r3, #0]
    559a:	095b      	lsrs	r3, r3, #5
    559c:	b29b      	uxth	r3, r3
    559e:	4618      	mov	r0, r3
    55a0:	4b44      	ldr	r3, [pc, #272]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    55a2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    55a6:	400a      	ands	r2, r1
    55a8:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    55aa:	f004 fe1d 	bl	a1e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    55ae:	f004 fe41 	bl	a234 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    55b2:	9b01      	ldr	r3, [sp, #4]
    55b4:	685a      	ldr	r2, [r3, #4]
    55b6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55ba:	005b      	lsls	r3, r3, #1
    55bc:	4413      	add	r3, r2
    55be:	881b      	ldrh	r3, [r3, #0]
    55c0:	095b      	lsrs	r3, r3, #5
    55c2:	b29b      	uxth	r3, r3
    55c4:	461a      	mov	r2, r3
    55c6:	4b3b      	ldr	r3, [pc, #236]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    55c8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    55cc:	6999      	ldr	r1, [r3, #24]
    55ce:	9b01      	ldr	r3, [sp, #4]
    55d0:	685a      	ldr	r2, [r3, #4]
    55d2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55d6:	005b      	lsls	r3, r3, #1
    55d8:	4413      	add	r3, r2
    55da:	881b      	ldrh	r3, [r3, #0]
    55dc:	f003 031f 	and.w	r3, r3, #31
    55e0:	2201      	movs	r2, #1
    55e2:	fa02 f303 	lsl.w	r3, r2, r3
    55e6:	43da      	mvns	r2, r3
    55e8:	9b01      	ldr	r3, [sp, #4]
    55ea:	6858      	ldr	r0, [r3, #4]
    55ec:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55f0:	005b      	lsls	r3, r3, #1
    55f2:	4403      	add	r3, r0
    55f4:	881b      	ldrh	r3, [r3, #0]
    55f6:	095b      	lsrs	r3, r3, #5
    55f8:	b29b      	uxth	r3, r3
    55fa:	4618      	mov	r0, r3
    55fc:	4b2d      	ldr	r3, [pc, #180]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    55fe:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5602:	400a      	ands	r2, r1
    5604:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    5606:	9b02      	ldr	r3, [sp, #8]
    5608:	2b03      	cmp	r3, #3
    560a:	d127      	bne.n	565c <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    560c:	9b01      	ldr	r3, [sp, #4]
    560e:	685a      	ldr	r2, [r3, #4]
    5610:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5614:	005b      	lsls	r3, r3, #1
    5616:	4413      	add	r3, r2
    5618:	881b      	ldrh	r3, [r3, #0]
    561a:	095b      	lsrs	r3, r3, #5
    561c:	b29b      	uxth	r3, r3
    561e:	461a      	mov	r2, r3
    5620:	4b24      	ldr	r3, [pc, #144]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    5622:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5626:	6999      	ldr	r1, [r3, #24]
    5628:	9b01      	ldr	r3, [sp, #4]
    562a:	685a      	ldr	r2, [r3, #4]
    562c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5630:	005b      	lsls	r3, r3, #1
    5632:	4413      	add	r3, r2
    5634:	881b      	ldrh	r3, [r3, #0]
    5636:	f003 031f 	and.w	r3, r3, #31
    563a:	2201      	movs	r2, #1
    563c:	409a      	lsls	r2, r3
    563e:	9b01      	ldr	r3, [sp, #4]
    5640:	6858      	ldr	r0, [r3, #4]
    5642:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5646:	005b      	lsls	r3, r3, #1
    5648:	4403      	add	r3, r0
    564a:	881b      	ldrh	r3, [r3, #0]
    564c:	095b      	lsrs	r3, r3, #5
    564e:	b29b      	uxth	r3, r3
    5650:	4618      	mov	r0, r3
    5652:	4b18      	ldr	r3, [pc, #96]	; (56b4 <Port_Ipw_Init_UnusedPins+0x26c>)
    5654:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5658:	430a      	orrs	r2, r1
    565a:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    565c:	f004 fe16 	bl	a28c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    5660:	9b01      	ldr	r3, [sp, #4]
    5662:	685a      	ldr	r2, [r3, #4]
    5664:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5668:	005b      	lsls	r3, r3, #1
    566a:	4413      	add	r3, r2
    566c:	881b      	ldrh	r3, [r3, #0]
    566e:	095b      	lsrs	r3, r3, #5
    5670:	b29b      	uxth	r3, r3
    5672:	461a      	mov	r2, r3
    5674:	4b10      	ldr	r3, [pc, #64]	; (56b8 <Port_Ipw_Init_UnusedPins+0x270>)
    5676:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    567a:	9a01      	ldr	r2, [sp, #4]
    567c:	6851      	ldr	r1, [r2, #4]
    567e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    5682:	0052      	lsls	r2, r2, #1
    5684:	440a      	add	r2, r1
    5686:	8812      	ldrh	r2, [r2, #0]
    5688:	f002 021f 	and.w	r2, r2, #31
    568c:	9903      	ldr	r1, [sp, #12]
    568e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    5692:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5696:	3301      	adds	r3, #1
    5698:	f8ad 3016 	strh.w	r3, [sp, #22]
    569c:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    56a0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    56a4:	429a      	cmp	r2, r3
    56a6:	f4ff aee7 	bcc.w	5478 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    56aa:	bf00      	nop
    56ac:	bf00      	nop
    56ae:	b007      	add	sp, #28
    56b0:	f85d fb04 	ldr.w	pc, [sp], #4
    56b4:	0000b6bc 	.word	0x0000b6bc
    56b8:	0000b6a8 	.word	0x0000b6a8

000056bc <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    56bc:	b500      	push	{lr}
    56be:	b085      	sub	sp, #20
    56c0:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    56c2:	9b01      	ldr	r3, [sp, #4]
    56c4:	7c1b      	ldrb	r3, [r3, #16]
    56c6:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    56ca:	2300      	movs	r3, #0
    56cc:	f8ad 300e 	strh.w	r3, [sp, #14]
    56d0:	e035      	b.n	573e <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    56d2:	9b01      	ldr	r3, [sp, #4]
    56d4:	695a      	ldr	r2, [r3, #20]
    56d6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    56da:	00db      	lsls	r3, r3, #3
    56dc:	4413      	add	r3, r2
    56de:	781b      	ldrb	r3, [r3, #0]
    56e0:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    56e4:	f89d 300c 	ldrb.w	r3, [sp, #12]
    56e8:	4a1f      	ldr	r2, [pc, #124]	; (5768 <Port_Ipw_Init+0xac>)
    56ea:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    56ee:	9b01      	ldr	r3, [sp, #4]
    56f0:	695a      	ldr	r2, [r3, #20]
    56f2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    56f6:	00db      	lsls	r3, r3, #3
    56f8:	4413      	add	r3, r2
    56fa:	4619      	mov	r1, r3
    56fc:	f7ff fe39 	bl	5372 <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    5700:	f004 ff32 	bl	a568 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    5704:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5708:	4a17      	ldr	r2, [pc, #92]	; (5768 <Port_Ipw_Init+0xac>)
    570a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    570e:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    5712:	9b01      	ldr	r3, [sp, #4]
    5714:	695a      	ldr	r2, [r3, #20]
    5716:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    571a:	00db      	lsls	r3, r3, #3
    571c:	4413      	add	r3, r2
    571e:	685a      	ldr	r2, [r3, #4]
    5720:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5724:	4810      	ldr	r0, [pc, #64]	; (5768 <Port_Ipw_Init+0xac>)
    5726:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    572a:	430a      	orrs	r2, r1
    572c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    5730:	f004 ff46 	bl	a5c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5734:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5738:	3301      	adds	r3, #1
    573a:	f8ad 300e 	strh.w	r3, [sp, #14]
    573e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    5742:	b29b      	uxth	r3, r3
    5744:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5748:	429a      	cmp	r2, r3
    574a:	d3c2      	bcc.n	56d2 <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    574c:	9b01      	ldr	r3, [sp, #4]
    574e:	6a1b      	ldr	r3, [r3, #32]
    5750:	4619      	mov	r1, r3
    5752:	2002      	movs	r0, #2
    5754:	f7ff fd98 	bl	5288 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    5758:	9801      	ldr	r0, [sp, #4]
    575a:	f7ff fe75 	bl	5448 <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    575e:	bf00      	nop
    5760:	b005      	add	sp, #20
    5762:	f85d fb04 	ldr.w	pc, [sp], #4
    5766:	bf00      	nop
    5768:	0000b6a8 	.word	0x0000b6a8

0000576c <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    576c:	b500      	push	{lr}
    576e:	b085      	sub	sp, #20
    5770:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    5772:	9b01      	ldr	r3, [sp, #4]
    5774:	881b      	ldrh	r3, [r3, #0]
    5776:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    577a:	2300      	movs	r3, #0
    577c:	f8ad 300e 	strh.w	r3, [sp, #14]
    5780:	e0d2      	b.n	5928 <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    5782:	9b01      	ldr	r3, [sp, #4]
    5784:	68d9      	ldr	r1, [r3, #12]
    5786:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    578a:	4613      	mov	r3, r2
    578c:	009b      	lsls	r3, r3, #2
    578e:	4413      	add	r3, r2
    5790:	009b      	lsls	r3, r3, #2
    5792:	440b      	add	r3, r1
    5794:	7c5b      	ldrb	r3, [r3, #17]
    5796:	f083 0301 	eor.w	r3, r3, #1
    579a:	b2db      	uxtb	r3, r3
    579c:	2b00      	cmp	r3, #0
    579e:	f000 80be 	beq.w	591e <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    57a2:	9b01      	ldr	r3, [sp, #4]
    57a4:	68d9      	ldr	r1, [r3, #12]
    57a6:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57aa:	4613      	mov	r3, r2
    57ac:	009b      	lsls	r3, r3, #2
    57ae:	4413      	add	r3, r2
    57b0:	009b      	lsls	r3, r3, #2
    57b2:	440b      	add	r3, r1
    57b4:	7c1b      	ldrb	r3, [r3, #16]
    57b6:	2b00      	cmp	r3, #0
    57b8:	f000 80b1 	beq.w	591e <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    57bc:	9b01      	ldr	r3, [sp, #4]
    57be:	68d9      	ldr	r1, [r3, #12]
    57c0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57c4:	4613      	mov	r3, r2
    57c6:	009b      	lsls	r3, r3, #2
    57c8:	4413      	add	r3, r2
    57ca:	009b      	lsls	r3, r3, #2
    57cc:	440b      	add	r3, r1
    57ce:	881b      	ldrh	r3, [r3, #0]
    57d0:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    57d4:	9b01      	ldr	r3, [sp, #4]
    57d6:	68d9      	ldr	r1, [r3, #12]
    57d8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57dc:	4613      	mov	r3, r2
    57de:	009b      	lsls	r3, r3, #2
    57e0:	4413      	add	r3, r2
    57e2:	009b      	lsls	r3, r3, #2
    57e4:	440b      	add	r3, r1
    57e6:	68db      	ldr	r3, [r3, #12]
    57e8:	2b02      	cmp	r3, #2
    57ea:	d11d      	bne.n	5828 <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    57ec:	f005 f804 	bl	a7f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    57f0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57f4:	095b      	lsrs	r3, r3, #5
    57f6:	b29b      	uxth	r3, r3
    57f8:	461a      	mov	r2, r3
    57fa:	4b51      	ldr	r3, [pc, #324]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    57fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5800:	6959      	ldr	r1, [r3, #20]
    5802:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5806:	f003 031f 	and.w	r3, r3, #31
    580a:	2201      	movs	r2, #1
    580c:	409a      	lsls	r2, r3
    580e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5812:	095b      	lsrs	r3, r3, #5
    5814:	b29b      	uxth	r3, r3
    5816:	4618      	mov	r0, r3
    5818:	4b49      	ldr	r3, [pc, #292]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    581a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    581e:	430a      	orrs	r2, r1
    5820:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    5822:	f005 f815 	bl	a850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    5826:	e07a      	b.n	591e <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    5828:	9b01      	ldr	r3, [sp, #4]
    582a:	68d9      	ldr	r1, [r3, #12]
    582c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5830:	4613      	mov	r3, r2
    5832:	009b      	lsls	r3, r3, #2
    5834:	4413      	add	r3, r2
    5836:	009b      	lsls	r3, r3, #2
    5838:	440b      	add	r3, r1
    583a:	68db      	ldr	r3, [r3, #12]
    583c:	2b01      	cmp	r3, #1
    583e:	d00b      	beq.n	5858 <Port_Ipw_RefreshPortDirection+0xec>
    5840:	9b01      	ldr	r3, [sp, #4]
    5842:	68d9      	ldr	r1, [r3, #12]
    5844:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5848:	4613      	mov	r3, r2
    584a:	009b      	lsls	r3, r3, #2
    584c:	4413      	add	r3, r2
    584e:	009b      	lsls	r3, r3, #2
    5850:	440b      	add	r3, r1
    5852:	68db      	ldr	r3, [r3, #12]
    5854:	2b03      	cmp	r3, #3
    5856:	d162      	bne.n	591e <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    5858:	f004 ffce 	bl	a7f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    585c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5860:	095b      	lsrs	r3, r3, #5
    5862:	b29b      	uxth	r3, r3
    5864:	461a      	mov	r2, r3
    5866:	4b36      	ldr	r3, [pc, #216]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5868:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    586c:	6959      	ldr	r1, [r3, #20]
    586e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5872:	f003 031f 	and.w	r3, r3, #31
    5876:	2201      	movs	r2, #1
    5878:	fa02 f303 	lsl.w	r3, r2, r3
    587c:	43da      	mvns	r2, r3
    587e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5882:	095b      	lsrs	r3, r3, #5
    5884:	b29b      	uxth	r3, r3
    5886:	4618      	mov	r0, r3
    5888:	4b2d      	ldr	r3, [pc, #180]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    588a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    588e:	400a      	ands	r2, r1
    5890:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    5892:	f004 ffdd 	bl	a850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    5896:	f005 f801 	bl	a89c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    589a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    589e:	095b      	lsrs	r3, r3, #5
    58a0:	b29b      	uxth	r3, r3
    58a2:	461a      	mov	r2, r3
    58a4:	4b26      	ldr	r3, [pc, #152]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    58a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    58aa:	6999      	ldr	r1, [r3, #24]
    58ac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58b0:	f003 031f 	and.w	r3, r3, #31
    58b4:	2201      	movs	r2, #1
    58b6:	fa02 f303 	lsl.w	r3, r2, r3
    58ba:	43da      	mvns	r2, r3
    58bc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58c0:	095b      	lsrs	r3, r3, #5
    58c2:	b29b      	uxth	r3, r3
    58c4:	4618      	mov	r0, r3
    58c6:	4b1e      	ldr	r3, [pc, #120]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    58c8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    58cc:	400a      	ands	r2, r1
    58ce:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    58d0:	9b01      	ldr	r3, [sp, #4]
    58d2:	68d9      	ldr	r1, [r3, #12]
    58d4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    58d8:	4613      	mov	r3, r2
    58da:	009b      	lsls	r3, r3, #2
    58dc:	4413      	add	r3, r2
    58de:	009b      	lsls	r3, r3, #2
    58e0:	440b      	add	r3, r1
    58e2:	68db      	ldr	r3, [r3, #12]
    58e4:	2b03      	cmp	r3, #3
    58e6:	d118      	bne.n	591a <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    58e8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58ec:	095b      	lsrs	r3, r3, #5
    58ee:	b29b      	uxth	r3, r3
    58f0:	461a      	mov	r2, r3
    58f2:	4b13      	ldr	r3, [pc, #76]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    58f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    58f8:	6999      	ldr	r1, [r3, #24]
    58fa:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58fe:	f003 031f 	and.w	r3, r3, #31
    5902:	2201      	movs	r2, #1
    5904:	409a      	lsls	r2, r3
    5906:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    590a:	095b      	lsrs	r3, r3, #5
    590c:	b29b      	uxth	r3, r3
    590e:	4618      	mov	r0, r3
    5910:	4b0b      	ldr	r3, [pc, #44]	; (5940 <Port_Ipw_RefreshPortDirection+0x1d4>)
    5912:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5916:	430a      	orrs	r2, r1
    5918:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    591a:	f004 ffeb 	bl	a8f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    591e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5922:	3301      	adds	r3, #1
    5924:	f8ad 300e 	strh.w	r3, [sp, #14]
    5928:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    592c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    5930:	429a      	cmp	r2, r3
    5932:	f4ff af26 	bcc.w	5782 <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    5936:	bf00      	nop
    5938:	bf00      	nop
    593a:	b005      	add	sp, #20
    593c:	f85d fb04 	ldr.w	pc, [sp], #4
    5940:	0000b6bc 	.word	0x0000b6bc

00005944 <Dio_ReadChannel>:
*/
Dio_LevelType Dio_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    5944:	b500      	push	{lr}
    5946:	b085      	sub	sp, #20
    5948:	4603      	mov	r3, r0
    594a:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    594e:	2300      	movs	r3, #0
    5950:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForRead(ChannelId, DIO_READCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_ReadChannel(ChannelId);
    5954:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5958:	4618      	mov	r0, r3
    595a:	f000 f871 	bl	5a40 <Dio_Ipw_ReadChannel>
    595e:	4603      	mov	r3, r0
    5960:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return ChannelLevel;
    5964:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5968:	4618      	mov	r0, r3
    596a:	b005      	add	sp, #20
    596c:	f85d fb04 	ldr.w	pc, [sp], #4

00005970 <Dio_WriteChannel>:
void Dio_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    5970:	b500      	push	{lr}
    5972:	b083      	sub	sp, #12
    5974:	4603      	mov	r3, r0
    5976:	460a      	mov	r2, r1
    5978:	f8ad 3006 	strh.w	r3, [sp, #6]
    597c:	4613      	mov	r3, r2
    597e:	f88d 3005 	strb.w	r3, [sp, #5]
    {
        Valid = Dio_ValidateChannelLevel(Level);
        if ((Std_ReturnType) E_OK == Valid)
        {
#endif
            Dio_Ipw_WriteChannel(ChannelId, Level);
    5982:	f89d 2005 	ldrb.w	r2, [sp, #5]
    5986:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    598a:	4611      	mov	r1, r2
    598c:	4618      	mov	r0, r3
    598e:	f000 f87d 	bl	5a8c <Dio_Ipw_WriteChannel>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
        }
    }
#endif

}
    5992:	bf00      	nop
    5994:	b003      	add	sp, #12
    5996:	f85d fb04 	ldr.w	pc, [sp], #4

0000599a <Dio_FlipChannel>:
*/
Dio_LevelType Dio_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    599a:	b500      	push	{lr}
    599c:	b085      	sub	sp, #20
    599e:	4603      	mov	r3, r0
    59a0:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    59a4:	2300      	movs	r3, #0
    59a6:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForWrite(ChannelId, DIO_FLIPCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_FlipChannel(ChannelId);
    59aa:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59ae:	4618      	mov	r0, r3
    59b0:	f000 f892 	bl	5ad8 <Dio_Ipw_FlipChannel>
    59b4:	4603      	mov	r3, r0
    59b6:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

   return ChannelLevel;
    59ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    59be:	4618      	mov	r0, r3
    59c0:	b005      	add	sp, #20
    59c2:	f85d fb04 	ldr.w	pc, [sp], #4

000059c6 <Dio_ReadPort>:
*/
Dio_PortLevelType Dio_ReadPort
(
    Dio_PortType PortId
)
{
    59c6:	b500      	push	{lr}
    59c8:	b085      	sub	sp, #20
    59ca:	4603      	mov	r3, r0
    59cc:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    59d0:	2300      	movs	r3, #0
    59d2:	9303      	str	r3, [sp, #12]
    Std_ReturnType Valid = Dio_ValidatePortForRead(PortId, DIO_READPORT_ID);

    if ((Std_ReturnType) E_OK == Valid)
    {
#endif
        PortLevel = Dio_Ipw_ReadPort(PortId);
    59d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    59d8:	4618      	mov	r0, r3
    59da:	f000 f8b3 	bl	5b44 <Dio_Ipw_ReadPort>
    59de:	9003      	str	r0, [sp, #12]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return PortLevel;
    59e0:	9b03      	ldr	r3, [sp, #12]
}
    59e2:	4618      	mov	r0, r3
    59e4:	b005      	add	sp, #20
    59e6:	f85d fb04 	ldr.w	pc, [sp], #4

000059ea <Dio_WritePort>:
void Dio_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    59ea:	b500      	push	{lr}
    59ec:	b083      	sub	sp, #12
    59ee:	4603      	mov	r3, r0
    59f0:	9100      	str	r1, [sp, #0]
    59f2:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType Valid = Dio_ValidatePortForWrite(PortId, DIO_WRITEPORT_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        Dio_Ipw_WritePort(PortId, Level);
    59f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    59fa:	9900      	ldr	r1, [sp, #0]
    59fc:	4618      	mov	r0, r3
    59fe:	f000 f8b9 	bl	5b74 <Dio_Ipw_WritePort>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif
}
    5a02:	bf00      	nop
    5a04:	b003      	add	sp, #12
    5a06:	f85d fb04 	ldr.w	pc, [sp], #4

00005a0a <Dio_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_ReadChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr
)
{
    5a0a:	b500      	push	{lr}
    5a0c:	b085      	sub	sp, #20
    5a0e:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5a10:	2300      	movs	r3, #0
    5a12:	9303      	str	r3, [sp, #12]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            PortLevel = Dio_Ipw_ReadChannelGroup(ChannelGroupIdPtr);
    5a14:	9801      	ldr	r0, [sp, #4]
    5a16:	f000 f8c5 	bl	5ba4 <Dio_Ipw_ReadChannelGroup>
    5a1a:	9003      	str	r0, [sp, #12]
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */

    return PortLevel;
    5a1c:	9b03      	ldr	r3, [sp, #12]
}
    5a1e:	4618      	mov	r0, r3
    5a20:	b005      	add	sp, #20
    5a22:	f85d fb04 	ldr.w	pc, [sp], #4

00005a26 <Dio_WriteChannelGroup>:
void Dio_WriteChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr,
    Dio_PortLevelType Level
)
{
    5a26:	b500      	push	{lr}
    5a28:	b083      	sub	sp, #12
    5a2a:	9001      	str	r0, [sp, #4]
    5a2c:	9100      	str	r1, [sp, #0]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            Dio_Ipw_WriteChannelGroup(ChannelGroupIdPtr, Level);
    5a2e:	9900      	ldr	r1, [sp, #0]
    5a30:	9801      	ldr	r0, [sp, #4]
    5a32:	f000 f8d7 	bl	5be4 <Dio_Ipw_WriteChannelGroup>
            (void)Det_ReportError((uint16)DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_WRITECHANNELGROUP_ID, DIO_E_PARAM_CONFIG);
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */
}
    5a36:	bf00      	nop
    5a38:	b003      	add	sp, #12
    5a3a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005a40 <Dio_Ipw_ReadChannel>:
*/
Dio_LevelType Dio_Ipw_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    5a40:	b500      	push	{lr}
    5a42:	b087      	sub	sp, #28
    5a44:	4603      	mov	r3, r0
    5a46:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType) STD_LOW;
    5a4a:	2300      	movs	r3, #0
    5a4c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    5a50:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5a54:	095b      	lsrs	r3, r3, #5
    5a56:	b29b      	uxth	r3, r3
    5a58:	9304      	str	r3, [sp, #16]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    5a5a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5a5e:	f003 031f 	and.w	r3, r3, #31
    5a62:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    5a64:	4a08      	ldr	r2, [pc, #32]	; (5a88 <Dio_Ipw_ReadChannel+0x48>)
    5a66:	9b04      	ldr	r3, [sp, #16]
    5a68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a6c:	9302      	str	r3, [sp, #8]

    ChannelLevel = Gpio_Dio_Ip_ReadPin(GpioBase, u32PinIndex);
    5a6e:	9903      	ldr	r1, [sp, #12]
    5a70:	9802      	ldr	r0, [sp, #8]
    5a72:	f000 f940 	bl	5cf6 <Gpio_Dio_Ip_ReadPin>
    5a76:	4603      	mov	r3, r0
    5a78:	f88d 3017 	strb.w	r3, [sp, #23]
    return ChannelLevel;
    5a7c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5a80:	4618      	mov	r0, r3
    5a82:	b007      	add	sp, #28
    5a84:	f85d fb04 	ldr.w	pc, [sp], #4
    5a88:	1fff8b24 	.word	0x1fff8b24

00005a8c <Dio_Ipw_WriteChannel>:
void Dio_Ipw_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    5a8c:	b500      	push	{lr}
    5a8e:	b087      	sub	sp, #28
    5a90:	4603      	mov	r3, r0
    5a92:	460a      	mov	r2, r1
    5a94:	f8ad 3006 	strh.w	r3, [sp, #6]
    5a98:	4613      	mov	r3, r2
    5a9a:	f88d 3005 	strb.w	r3, [sp, #5]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    5a9e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5aa2:	095b      	lsrs	r3, r3, #5
    5aa4:	b29b      	uxth	r3, r3
    5aa6:	9305      	str	r3, [sp, #20]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    5aa8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5aac:	f003 031f 	and.w	r3, r3, #31
    5ab0:	9304      	str	r3, [sp, #16]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    5ab2:	4a08      	ldr	r2, [pc, #32]	; (5ad4 <Dio_Ipw_WriteChannel+0x48>)
    5ab4:	9b05      	ldr	r3, [sp, #20]
    5ab6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5aba:	9303      	str	r3, [sp, #12]

    Gpio_Dio_Ip_WritePin(GpioBase, u32PinIndex, Level);
    5abc:	f89d 3005 	ldrb.w	r3, [sp, #5]
    5ac0:	461a      	mov	r2, r3
    5ac2:	9904      	ldr	r1, [sp, #16]
    5ac4:	9803      	ldr	r0, [sp, #12]
    5ac6:	f000 f8b7 	bl	5c38 <Gpio_Dio_Ip_WritePin>
}
    5aca:	bf00      	nop
    5acc:	b007      	add	sp, #28
    5ace:	f85d fb04 	ldr.w	pc, [sp], #4
    5ad2:	bf00      	nop
    5ad4:	1fff8b24 	.word	0x1fff8b24

00005ad8 <Dio_Ipw_FlipChannel>:
*/
Dio_LevelType Dio_Ipw_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    5ad8:	b500      	push	{lr}
    5ada:	b089      	sub	sp, #36	; 0x24
    5adc:	4603      	mov	r3, r0
    5ade:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    5ae2:	2300      	movs	r3, #0
    5ae4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;
    uint32 u32PortOutPutLevel;
    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    5ae8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5aec:	095b      	lsrs	r3, r3, #5
    5aee:	b29b      	uxth	r3, r3
    5af0:	9306      	str	r3, [sp, #24]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    5af2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5af6:	f003 031f 	and.w	r3, r3, #31
    5afa:	9305      	str	r3, [sp, #20]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    5afc:	4a10      	ldr	r2, [pc, #64]	; (5b40 <Dio_Ipw_FlipChannel+0x68>)
    5afe:	9b06      	ldr	r3, [sp, #24]
    5b00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b04:	9304      	str	r3, [sp, #16]

    Gpio_Dio_Ip_TogglePins(GpioBase, ((uint32)1U << u32PinIndex));
    5b06:	2201      	movs	r2, #1
    5b08:	9b05      	ldr	r3, [sp, #20]
    5b0a:	fa02 f303 	lsl.w	r3, r2, r3
    5b0e:	4619      	mov	r1, r3
    5b10:	9804      	ldr	r0, [sp, #16]
    5b12:	f000 f8dc 	bl	5cce <Gpio_Dio_Ip_TogglePins>

    u32PortOutPutLevel = Gpio_Dio_Ip_GetPinsOutput(GpioBase);
    5b16:	9804      	ldr	r0, [sp, #16]
    5b18:	f000 f8bc 	bl	5c94 <Gpio_Dio_Ip_GetPinsOutput>
    5b1c:	9003      	str	r0, [sp, #12]
    ChannelLevel = (Dio_LevelType)((u32PortOutPutLevel & ((uint32)1U << u32PinIndex)) >> u32PinIndex);
    5b1e:	2201      	movs	r2, #1
    5b20:	9b05      	ldr	r3, [sp, #20]
    5b22:	409a      	lsls	r2, r3
    5b24:	9b03      	ldr	r3, [sp, #12]
    5b26:	401a      	ands	r2, r3
    5b28:	9b05      	ldr	r3, [sp, #20]
    5b2a:	fa22 f303 	lsr.w	r3, r2, r3
    5b2e:	f88d 301f 	strb.w	r3, [sp, #31]

    return ChannelLevel;
    5b32:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    5b36:	4618      	mov	r0, r3
    5b38:	b009      	add	sp, #36	; 0x24
    5b3a:	f85d fb04 	ldr.w	pc, [sp], #4
    5b3e:	bf00      	nop
    5b40:	1fff8b24 	.word	0x1fff8b24

00005b44 <Dio_Ipw_ReadPort>:
*/
Dio_PortLevelType Dio_Ipw_ReadPort
(
    Dio_PortType PortId
)
{
    5b44:	b500      	push	{lr}
    5b46:	b085      	sub	sp, #20
    5b48:	4603      	mov	r3, r0
    5b4a:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5b4e:	2300      	movs	r3, #0
    5b50:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    5b52:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5b56:	4a06      	ldr	r2, [pc, #24]	; (5b70 <Dio_Ipw_ReadPort+0x2c>)
    5b58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b5c:	9302      	str	r3, [sp, #8]

    PortLevel = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    5b5e:	9802      	ldr	r0, [sp, #8]
    5b60:	f000 f8be 	bl	5ce0 <Gpio_Dio_Ip_ReadPins>
    5b64:	9003      	str	r0, [sp, #12]
#endif
#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#endif

    return PortLevel;
    5b66:	9b03      	ldr	r3, [sp, #12]
}
    5b68:	4618      	mov	r0, r3
    5b6a:	b005      	add	sp, #20
    5b6c:	f85d fb04 	ldr.w	pc, [sp], #4
    5b70:	1fff8b24 	.word	0x1fff8b24

00005b74 <Dio_Ipw_WritePort>:
void Dio_Ipw_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    5b74:	b500      	push	{lr}
    5b76:	b085      	sub	sp, #20
    5b78:	4603      	mov	r3, r0
    5b7a:	9100      	str	r1, [sp, #0]
    5b7c:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType CrtLevel = Level;
    5b80:	9b00      	ldr	r3, [sp, #0]
    5b82:	9303      	str	r3, [sp, #12]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    5b84:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5b88:	4a05      	ldr	r2, [pc, #20]	; (5ba0 <Dio_Ipw_WritePort+0x2c>)
    5b8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b8e:	9302      	str	r3, [sp, #8]

#if (STD_ON == DIO_REVERSEPORTBITS)
    CrtLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(CrtLevel));
#endif /* STD_ON == DIO_REVERSEPORTBITS */
    Gpio_Dio_Ip_WritePins(GpioBase, CrtLevel);
    5b90:	9903      	ldr	r1, [sp, #12]
    5b92:	9802      	ldr	r0, [sp, #8]
    5b94:	f000 f875 	bl	5c82 <Gpio_Dio_Ip_WritePins>
}
    5b98:	bf00      	nop
    5b9a:	b005      	add	sp, #20
    5b9c:	f85d fb04 	ldr.w	pc, [sp], #4
    5ba0:	1fff8b24 	.word	0x1fff8b24

00005ba4 <Dio_Ipw_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_Ipw_ReadChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr
)
{
    5ba4:	b500      	push	{lr}
    5ba6:	b087      	sub	sp, #28
    5ba8:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5baa:	2300      	movs	r3, #0
    5bac:	9305      	str	r3, [sp, #20]
    Dio_PortLevelType pinsValue;
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    5bae:	9b01      	ldr	r3, [sp, #4]
    5bb0:	781b      	ldrb	r3, [r3, #0]
    5bb2:	461a      	mov	r2, r3
    5bb4:	4b0a      	ldr	r3, [pc, #40]	; (5be0 <Dio_Ipw_ReadChannelGroup+0x3c>)
    5bb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5bba:	9304      	str	r3, [sp, #16]

    pinsValue = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    5bbc:	9804      	ldr	r0, [sp, #16]
    5bbe:	f000 f88f 	bl	5ce0 <Gpio_Dio_Ip_ReadPins>
    5bc2:	9003      	str	r0, [sp, #12]

#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) << (pChannelGroupIdPtr->u8offset));
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#else
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) >> (pChannelGroupIdPtr->u8offset));
    5bc4:	9b01      	ldr	r3, [sp, #4]
    5bc6:	685a      	ldr	r2, [r3, #4]
    5bc8:	9b03      	ldr	r3, [sp, #12]
    5bca:	4013      	ands	r3, r2
    5bcc:	9a01      	ldr	r2, [sp, #4]
    5bce:	7852      	ldrb	r2, [r2, #1]
    5bd0:	40d3      	lsrs	r3, r2
    5bd2:	9305      	str	r3, [sp, #20]
#endif

    return PortLevel;
    5bd4:	9b05      	ldr	r3, [sp, #20]
}
    5bd6:	4618      	mov	r0, r3
    5bd8:	b007      	add	sp, #28
    5bda:	f85d fb04 	ldr.w	pc, [sp], #4
    5bde:	bf00      	nop
    5be0:	1fff8b24 	.word	0x1fff8b24

00005be4 <Dio_Ipw_WriteChannelGroup>:
void Dio_Ipw_WriteChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr,
    Dio_PortLevelType                 Level
)
{
    5be4:	b500      	push	{lr}
    5be6:	b087      	sub	sp, #28
    5be8:	9001      	str	r0, [sp, #4]
    5bea:	9100      	str	r1, [sp, #0]
    Dio_PortLevelType ValueSet;
    Dio_PortLevelType ValueClear;

    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    5bec:	9b01      	ldr	r3, [sp, #4]
    5bee:	781b      	ldrb	r3, [r3, #0]
    5bf0:	461a      	mov	r2, r3
    5bf2:	4b10      	ldr	r3, [pc, #64]	; (5c34 <Dio_Ipw_WriteChannelGroup+0x50>)
    5bf4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5bf8:	9305      	str	r3, [sp, #20]

#if (STD_ON == DIO_REVERSEPORTBITS)
    ValueSet = (((Dio_PortLevelType)(Dio_Ipw_ReverseBits(Level)) >> (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
#else
    ValueSet = (((Dio_PortLevelType)(Level) << (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
    5bfa:	9b01      	ldr	r3, [sp, #4]
    5bfc:	785b      	ldrb	r3, [r3, #1]
    5bfe:	461a      	mov	r2, r3
    5c00:	9b00      	ldr	r3, [sp, #0]
    5c02:	fa03 f202 	lsl.w	r2, r3, r2
    5c06:	9b01      	ldr	r3, [sp, #4]
    5c08:	685b      	ldr	r3, [r3, #4]
    5c0a:	4013      	ands	r3, r2
    5c0c:	9304      	str	r3, [sp, #16]
#endif

    Gpio_Dio_Ip_SetPins(GpioBase, ValueSet);
    5c0e:	9904      	ldr	r1, [sp, #16]
    5c10:	9805      	ldr	r0, [sp, #20]
    5c12:	f000 f84a 	bl	5caa <Gpio_Dio_Ip_SetPins>
    ValueClear = (~ValueSet) & pChannelGroupIdPtr->mask;
    5c16:	9b04      	ldr	r3, [sp, #16]
    5c18:	43da      	mvns	r2, r3
    5c1a:	9b01      	ldr	r3, [sp, #4]
    5c1c:	685b      	ldr	r3, [r3, #4]
    5c1e:	4013      	ands	r3, r2
    5c20:	9303      	str	r3, [sp, #12]
    Gpio_Dio_Ip_ClearPins(GpioBase, ValueClear);
    5c22:	9903      	ldr	r1, [sp, #12]
    5c24:	9805      	ldr	r0, [sp, #20]
    5c26:	f000 f849 	bl	5cbc <Gpio_Dio_Ip_ClearPins>

}
    5c2a:	bf00      	nop
    5c2c:	b007      	add	sp, #28
    5c2e:	f85d fb04 	ldr.w	pc, [sp], #4
    5c32:	bf00      	nop
    5c34:	1fff8b24 	.word	0x1fff8b24

00005c38 <Gpio_Dio_Ip_WritePin>:
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pin,
    Gpio_Dio_Ip_PinsLevelType value
)
{
    5c38:	b500      	push	{lr}
    5c3a:	b087      	sub	sp, #28
    5c3c:	9003      	str	r0, [sp, #12]
    5c3e:	9102      	str	r1, [sp, #8]
    5c40:	4613      	mov	r3, r2
    5c42:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Enter critical region */
    SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00();
    5c46:	f001 fd7f 	bl	7748 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>
    Gpio_Dio_Ip_PinsChannelType pinsValues = (Gpio_Dio_Ip_PinsChannelType)base->PDOR;
    5c4a:	9b03      	ldr	r3, [sp, #12]
    5c4c:	681b      	ldr	r3, [r3, #0]
    5c4e:	9305      	str	r3, [sp, #20]
    pinsValues &= (Gpio_Dio_Ip_PinsChannelType)(~((Gpio_Dio_Ip_PinsChannelType)1U << pin));
    5c50:	2201      	movs	r2, #1
    5c52:	9b02      	ldr	r3, [sp, #8]
    5c54:	fa02 f303 	lsl.w	r3, r2, r3
    5c58:	43db      	mvns	r3, r3
    5c5a:	9a05      	ldr	r2, [sp, #20]
    5c5c:	4013      	ands	r3, r2
    5c5e:	9305      	str	r3, [sp, #20]
    pinsValues |= (Gpio_Dio_Ip_PinsChannelType)((Gpio_Dio_Ip_PinsChannelType)value << pin);
    5c60:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5c64:	9b02      	ldr	r3, [sp, #8]
    5c66:	fa02 f303 	lsl.w	r3, r2, r3
    5c6a:	9a05      	ldr	r2, [sp, #20]
    5c6c:	4313      	orrs	r3, r2
    5c6e:	9305      	str	r3, [sp, #20]
    base->PDOR = GPIO_PDOR_PDO(pinsValues);
    5c70:	9b03      	ldr	r3, [sp, #12]
    5c72:	9a05      	ldr	r2, [sp, #20]
    5c74:	601a      	str	r2, [r3, #0]
    /* Exit critical region */
    SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00();
    5c76:	f001 fd93 	bl	77a0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>
}
    5c7a:	bf00      	nop
    5c7c:	b007      	add	sp, #28
    5c7e:	f85d fb04 	ldr.w	pc, [sp], #4

00005c82 <Gpio_Dio_Ip_WritePins>:
void Gpio_Dio_Ip_WritePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5c82:	b082      	sub	sp, #8
    5c84:	9001      	str	r0, [sp, #4]
    5c86:	9100      	str	r1, [sp, #0]
    base->PDOR = GPIO_PDOR_PDO(pins);
    5c88:	9b01      	ldr	r3, [sp, #4]
    5c8a:	9a00      	ldr	r2, [sp, #0]
    5c8c:	601a      	str	r2, [r3, #0]
}
    5c8e:	bf00      	nop
    5c90:	b002      	add	sp, #8
    5c92:	4770      	bx	lr

00005c94 <Gpio_Dio_Ip_GetPinsOutput>:
 * that are configured as output will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_GetPinsOutput_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_GetPinsOutput(const GPIO_Type * const base)
{
    5c94:	b084      	sub	sp, #16
    5c96:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    5c98:	2300      	movs	r3, #0
    5c9a:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDOR);
    5c9c:	9b01      	ldr	r3, [sp, #4]
    5c9e:	681b      	ldr	r3, [r3, #0]
    5ca0:	9303      	str	r3, [sp, #12]
    return returnValue;
    5ca2:	9b03      	ldr	r3, [sp, #12]
}
    5ca4:	4618      	mov	r0, r3
    5ca6:	b004      	add	sp, #16
    5ca8:	4770      	bx	lr

00005caa <Gpio_Dio_Ip_SetPins>:
void Gpio_Dio_Ip_SetPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5caa:	b082      	sub	sp, #8
    5cac:	9001      	str	r0, [sp, #4]
    5cae:	9100      	str	r1, [sp, #0]
    base->PSOR = GPIO_PSOR_PTSO(pins);
    5cb0:	9b01      	ldr	r3, [sp, #4]
    5cb2:	9a00      	ldr	r2, [sp, #0]
    5cb4:	605a      	str	r2, [r3, #4]
}
    5cb6:	bf00      	nop
    5cb8:	b002      	add	sp, #8
    5cba:	4770      	bx	lr

00005cbc <Gpio_Dio_Ip_ClearPins>:
void Gpio_Dio_Ip_ClearPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5cbc:	b082      	sub	sp, #8
    5cbe:	9001      	str	r0, [sp, #4]
    5cc0:	9100      	str	r1, [sp, #0]
    base->PCOR = GPIO_PCOR_PTCO(pins);
    5cc2:	9b01      	ldr	r3, [sp, #4]
    5cc4:	9a00      	ldr	r2, [sp, #0]
    5cc6:	609a      	str	r2, [r3, #8]
}
    5cc8:	bf00      	nop
    5cca:	b002      	add	sp, #8
    5ccc:	4770      	bx	lr

00005cce <Gpio_Dio_Ip_TogglePins>:
void Gpio_Dio_Ip_TogglePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5cce:	b082      	sub	sp, #8
    5cd0:	9001      	str	r0, [sp, #4]
    5cd2:	9100      	str	r1, [sp, #0]
    base->PTOR = GPIO_PTOR_PTTO(pins);
    5cd4:	9b01      	ldr	r3, [sp, #4]
    5cd6:	9a00      	ldr	r2, [sp, #0]
    5cd8:	60da      	str	r2, [r3, #12]
}
    5cda:	bf00      	nop
    5cdc:	b002      	add	sp, #8
    5cde:	4770      	bx	lr

00005ce0 <Gpio_Dio_Ip_ReadPins>:
 * configured as input will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_ReadPins_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_ReadPins(const GPIO_Type * const base)
{
    5ce0:	b084      	sub	sp, #16
    5ce2:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    5ce4:	2300      	movs	r3, #0
    5ce6:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDIR);
    5ce8:	9b01      	ldr	r3, [sp, #4]
    5cea:	691b      	ldr	r3, [r3, #16]
    5cec:	9303      	str	r3, [sp, #12]
    return returnValue;
    5cee:	9b03      	ldr	r3, [sp, #12]
}
    5cf0:	4618      	mov	r0, r3
    5cf2:	b004      	add	sp, #16
    5cf4:	4770      	bx	lr

00005cf6 <Gpio_Dio_Ip_ReadPin>:
 * configured as input will have meaningful value.
 *
 * @implements    Gpio_Dio_Ip_ReadPin_Activity
 */
Gpio_Dio_Ip_PinsLevelType Gpio_Dio_Ip_ReadPin(const GPIO_Type * const base, Gpio_Dio_Ip_PinsChannelType pin)
{
    5cf6:	b084      	sub	sp, #16
    5cf8:	9001      	str	r0, [sp, #4]
    5cfa:	9100      	str	r1, [sp, #0]
    Gpio_Dio_Ip_PinsLevelType returnValue = 0U;
    5cfc:	2300      	movs	r3, #0
    5cfe:	f88d 300f 	strb.w	r3, [sp, #15]
    returnValue  = (Gpio_Dio_Ip_PinsLevelType)(((base->PDIR)&((uint32)1<<pin))>>(pin));
    5d02:	9b01      	ldr	r3, [sp, #4]
    5d04:	691a      	ldr	r2, [r3, #16]
    5d06:	2101      	movs	r1, #1
    5d08:	9b00      	ldr	r3, [sp, #0]
    5d0a:	fa01 f303 	lsl.w	r3, r1, r3
    5d0e:	401a      	ands	r2, r3
    5d10:	9b00      	ldr	r3, [sp, #0]
    5d12:	fa22 f303 	lsr.w	r3, r2, r3
    5d16:	f88d 300f 	strb.w	r3, [sp, #15]

    return returnValue;
    5d1a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5d1e:	4618      	mov	r0, r3
    5d20:	b004      	add	sp, #16
    5d22:	4770      	bx	lr

00005d24 <Ftm_Gpt_Ip_GetCntValue>:
*
* @return   current counter value
*
*/
static inline uint32 Ftm_Gpt_Ip_GetCntValue(uint8 instance)
{
    5d24:	b082      	sub	sp, #8
    5d26:	4603      	mov	r3, r0
    5d28:	f88d 3007 	strb.w	r3, [sp, #7]
    return ftmGptBase[instance]->CNT;
    5d2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5d30:	4a03      	ldr	r2, [pc, #12]	; (5d40 <Ftm_Gpt_Ip_GetCntValue+0x1c>)
    5d32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d36:	685b      	ldr	r3, [r3, #4]
}
    5d38:	4618      	mov	r0, r3
    5d3a:	b002      	add	sp, #8
    5d3c:	4770      	bx	lr
    5d3e:	bf00      	nop
    5d40:	0000b6d0 	.word	0x0000b6d0

00005d44 <Ftm_Gpt_Ip_SetFreezeBits>:
 *
 * @return      void
 *
 */
static inline void Ftm_Gpt_Ip_SetFreezeBits(uint8 instance, boolean freezeBits)
{
    5d44:	b500      	push	{lr}
    5d46:	b085      	sub	sp, #20
    5d48:	4603      	mov	r3, r0
    5d4a:	460a      	mov	r2, r1
    5d4c:	f88d 3007 	strb.w	r3, [sp, #7]
    5d50:	4613      	mov	r3, r2
    5d52:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 freezeVal = (TRUE == freezeBits) ? 0UL : 3UL;
    5d56:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5d5a:	2b00      	cmp	r3, #0
    5d5c:	d001      	beq.n	5d62 <Ftm_Gpt_Ip_SetFreezeBits+0x1e>
    5d5e:	2300      	movs	r3, #0
    5d60:	e000      	b.n	5d64 <Ftm_Gpt_Ip_SetFreezeBits+0x20>
    5d62:	2303      	movs	r3, #3
    5d64:	9303      	str	r3, [sp, #12]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17();
    5d66:	f002 f8c7 	bl	7ef8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17>
    ftmGptBase[instance]->CONF = (ftmGptBase[instance]->CONF & ~FTM_CONF_BDMMODE_MASK) | FTM_CONF_BDMMODE(freezeVal);
    5d6a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5d6e:	4a0c      	ldr	r2, [pc, #48]	; (5da0 <Ftm_Gpt_Ip_SetFreezeBits+0x5c>)
    5d70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d74:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    5d78:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
    5d7c:	9b03      	ldr	r3, [sp, #12]
    5d7e:	019b      	lsls	r3, r3, #6
    5d80:	b2da      	uxtb	r2, r3
    5d82:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5d86:	4806      	ldr	r0, [pc, #24]	; (5da0 <Ftm_Gpt_Ip_SetFreezeBits+0x5c>)
    5d88:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5d8c:	430a      	orrs	r2, r1
    5d8e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17();
    5d92:	f002 f8dd 	bl	7f50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17>
}
    5d96:	bf00      	nop
    5d98:	b005      	add	sp, #20
    5d9a:	f85d fb04 	ldr.w	pc, [sp], #4
    5d9e:	bf00      	nop
    5da0:	0000b6d0 	.word	0x0000b6d0

00005da4 <Ftm_Gpt_Ip_SetCounterInitVal>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCounterInitVal(uint8 instance, uint16 value)
{
    5da4:	b082      	sub	sp, #8
    5da6:	4603      	mov	r3, r0
    5da8:	460a      	mov	r2, r1
    5daa:	f88d 3007 	strb.w	r3, [sp, #7]
    5dae:	4613      	mov	r3, r2
    5db0:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]->CNTIN = (uint32)(((uint32)value << FTM_CNTIN_INIT_SHIFT) & FTM_CNTIN_INIT_MASK);
    5db4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5db8:	4a04      	ldr	r2, [pc, #16]	; (5dcc <Ftm_Gpt_Ip_SetCounterInitVal+0x28>)
    5dba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5dbe:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    5dc2:	64da      	str	r2, [r3, #76]	; 0x4c
}
    5dc4:	bf00      	nop
    5dc6:	b002      	add	sp, #8
    5dc8:	4770      	bx	lr
    5dca:	bf00      	nop
    5dcc:	0000b6d0 	.word	0x0000b6d0

00005dd0 <Ftm_Gpt_Ip_SetCounter>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCounter(uint8 instance, uint16 value)
{
    5dd0:	b082      	sub	sp, #8
    5dd2:	4603      	mov	r3, r0
    5dd4:	460a      	mov	r2, r1
    5dd6:	f88d 3007 	strb.w	r3, [sp, #7]
    5dda:	4613      	mov	r3, r2
    5ddc:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]->CNT = (uint32)(((uint32)value << FTM_CNT_COUNT_SHIFT) & FTM_CNT_COUNT_MASK);
    5de0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5de4:	4a04      	ldr	r2, [pc, #16]	; (5df8 <Ftm_Gpt_Ip_SetCounter+0x28>)
    5de6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5dea:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    5dee:	605a      	str	r2, [r3, #4]
}
    5df0:	bf00      	nop
    5df2:	b002      	add	sp, #8
    5df4:	4770      	bx	lr
    5df6:	bf00      	nop
    5df8:	0000b6d0 	.word	0x0000b6d0

00005dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>:
 *
 * @return      void
 * @pre         The driver needs to be initialized.
 */
static inline void Ftm_Gpt_Ip_ClearChInterruptStatusFlag(uint8 instance, uint8 channel)
{
    5dfc:	b082      	sub	sp, #8
    5dfe:	4603      	mov	r3, r0
    5e00:	460a      	mov	r2, r1
    5e02:	f88d 3007 	strb.w	r3, [sp, #7]
    5e06:	4613      	mov	r3, r2
    5e08:	f88d 3006 	strb.w	r3, [sp, #6]
    ftmGptBase[instance]-> CONTROLS[channel].CSC &= ~(FTM_CSC_CHF_MASK);
    5e0c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5e10:	4a0c      	ldr	r2, [pc, #48]	; (5e44 <Ftm_Gpt_Ip_ClearChInterruptStatusFlag+0x48>)
    5e12:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    5e16:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5e1a:	3301      	adds	r3, #1
    5e1c:	00db      	lsls	r3, r3, #3
    5e1e:	4413      	add	r3, r2
    5e20:	685a      	ldr	r2, [r3, #4]
    5e22:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5e26:	4907      	ldr	r1, [pc, #28]	; (5e44 <Ftm_Gpt_Ip_ClearChInterruptStatusFlag+0x48>)
    5e28:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    5e2c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5e30:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    5e34:	3301      	adds	r3, #1
    5e36:	00db      	lsls	r3, r3, #3
    5e38:	440b      	add	r3, r1
    5e3a:	605a      	str	r2, [r3, #4]
}
    5e3c:	bf00      	nop
    5e3e:	b002      	add	sp, #8
    5e40:	4770      	bx	lr
    5e42:	bf00      	nop
    5e44:	0000b6d0 	.word	0x0000b6d0

00005e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>:
 * @param[in]   aboEn - Enables the FTM channel(n) interrupt
 *              - True : Enable the FTM channel(n) interrupt.
 *              - False: Disable the FTM channel(n) interrupt.
 */
static inline void Ftm_Gpt_Ip_SetChannelEnableInterrupt(uint8 instance, uint8 channel, boolean aboEn)
{
    5e48:	b082      	sub	sp, #8
    5e4a:	4603      	mov	r3, r0
    5e4c:	f88d 3007 	strb.w	r3, [sp, #7]
    5e50:	460b      	mov	r3, r1
    5e52:	f88d 3006 	strb.w	r3, [sp, #6]
    5e56:	4613      	mov	r3, r2
    5e58:	f88d 3005 	strb.w	r3, [sp, #5]
    ftmGptBase[instance]-> CONTROLS[channel].CSC = (ftmGptBase[instance]-> CONTROLS[channel].CSC & ~(FTM_CSC_CHIE_MASK)) | FTM_CSC_CHIE((TRUE == aboEn) ? 1UL : 0UL);
    5e5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5e60:	4a10      	ldr	r2, [pc, #64]	; (5ea4 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x5c>)
    5e62:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    5e66:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5e6a:	3301      	adds	r3, #1
    5e6c:	00db      	lsls	r3, r3, #3
    5e6e:	4413      	add	r3, r2
    5e70:	685b      	ldr	r3, [r3, #4]
    5e72:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    5e76:	f89d 3005 	ldrb.w	r3, [sp, #5]
    5e7a:	2b00      	cmp	r3, #0
    5e7c:	d001      	beq.n	5e82 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x3a>
    5e7e:	2040      	movs	r0, #64	; 0x40
    5e80:	e000      	b.n	5e84 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x3c>
    5e82:	2000      	movs	r0, #0
    5e84:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5e88:	4906      	ldr	r1, [pc, #24]	; (5ea4 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x5c>)
    5e8a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    5e8e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5e92:	4302      	orrs	r2, r0
    5e94:	3301      	adds	r3, #1
    5e96:	00db      	lsls	r3, r3, #3
    5e98:	440b      	add	r3, r1
    5e9a:	605a      	str	r2, [r3, #4]
}
    5e9c:	bf00      	nop
    5e9e:	b002      	add	sp, #8
    5ea0:	4770      	bx	lr
    5ea2:	bf00      	nop
    5ea4:	0000b6d0 	.word	0x0000b6d0

00005ea8 <Ftm_Gpt_Ip_SetClockSource>:
 * @param[in]       instance    FTM hardware instance number
 *
 * @return      void
 */
static inline void Ftm_Gpt_Ip_SetClockSource(uint8 instance, Ftm_Gpt_Ip_ClockSource clocksource)
{
    5ea8:	b500      	push	{lr}
    5eaa:	b083      	sub	sp, #12
    5eac:	4603      	mov	r3, r0
    5eae:	9100      	str	r1, [sp, #0]
    5eb0:	f88d 3007 	strb.w	r3, [sp, #7]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21();
    5eb4:	f002 f872 	bl	7f9c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21>
    ftmGptBase[instance]->SC = (ftmGptBase[instance]->SC & ~FTM_SC_CLKS_MASK) | FTM_SC_CLKS(clocksource);
    5eb8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ebc:	4a0b      	ldr	r2, [pc, #44]	; (5eec <Ftm_Gpt_Ip_SetClockSource+0x44>)
    5ebe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ec2:	681b      	ldr	r3, [r3, #0]
    5ec4:	f023 0118 	bic.w	r1, r3, #24
    5ec8:	9b00      	ldr	r3, [sp, #0]
    5eca:	00db      	lsls	r3, r3, #3
    5ecc:	f003 0218 	and.w	r2, r3, #24
    5ed0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ed4:	4805      	ldr	r0, [pc, #20]	; (5eec <Ftm_Gpt_Ip_SetClockSource+0x44>)
    5ed6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5eda:	430a      	orrs	r2, r1
    5edc:	601a      	str	r2, [r3, #0]
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21();
    5ede:	f002 f889 	bl	7ff4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21>
}
    5ee2:	bf00      	nop
    5ee4:	b003      	add	sp, #12
    5ee6:	f85d fb04 	ldr.w	pc, [sp], #4
    5eea:	bf00      	nop
    5eec:	0000b6d0 	.word	0x0000b6d0

00005ef0 <Ftm_Gpt_Ip_SetPrescaler>:
 *
 * @return        void
 *
 */
static inline void Ftm_Gpt_Ip_SetPrescaler(uint8 instance, uint8 prescalerValue)
{
    5ef0:	b500      	push	{lr}
    5ef2:	b083      	sub	sp, #12
    5ef4:	4603      	mov	r3, r0
    5ef6:	460a      	mov	r2, r1
    5ef8:	f88d 3007 	strb.w	r3, [sp, #7]
    5efc:	4613      	mov	r3, r2
    5efe:	f88d 3006 	strb.w	r3, [sp, #6]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22();
    5f02:	f002 f89d 	bl	8040 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22>
    ftmGptBase[instance]->SC = (ftmGptBase[instance]->SC & ~FTM_SC_PS_MASK) | FTM_SC_PS(prescalerValue);
    5f06:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f0a:	4a0b      	ldr	r2, [pc, #44]	; (5f38 <Ftm_Gpt_Ip_SetPrescaler+0x48>)
    5f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f10:	681b      	ldr	r3, [r3, #0]
    5f12:	f023 0107 	bic.w	r1, r3, #7
    5f16:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5f1a:	f003 0207 	and.w	r2, r3, #7
    5f1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f22:	4805      	ldr	r0, [pc, #20]	; (5f38 <Ftm_Gpt_Ip_SetPrescaler+0x48>)
    5f24:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5f28:	430a      	orrs	r2, r1
    5f2a:	601a      	str	r2, [r3, #0]
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22();
    5f2c:	f002 f8b4 	bl	8098 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22>
}
    5f30:	bf00      	nop
    5f32:	b003      	add	sp, #12
    5f34:	f85d fb04 	ldr.w	pc, [sp], #4
    5f38:	0000b6d0 	.word	0x0000b6d0

00005f3c <Ftm_Gpt_Ip_SetEnFtmModule>:
 * @param[in]   enable
 *
 * @return      void
 */
static inline void Ftm_Gpt_Ip_SetEnFtmModule(uint8 instance, boolean enable)
{
    5f3c:	b500      	push	{lr}
    5f3e:	b083      	sub	sp, #12
    5f40:	4603      	mov	r3, r0
    5f42:	460a      	mov	r2, r1
    5f44:	f88d 3007 	strb.w	r3, [sp, #7]
    5f48:	4613      	mov	r3, r2
    5f4a:	f88d 3006 	strb.w	r3, [sp, #6]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23();
    5f4e:	f002 f8c9 	bl	80e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23>
    {
        ftmGptBase[instance]->MODE &= ~(FTM_MODE_FTMEN_MASK);
    5f52:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f56:	4a13      	ldr	r2, [pc, #76]	; (5fa4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    5f58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f5c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    5f5e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f62:	4910      	ldr	r1, [pc, #64]	; (5fa4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    5f64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    5f68:	f022 0201 	bic.w	r2, r2, #1
    5f6c:	655a      	str	r2, [r3, #84]	; 0x54
        ftmGptBase[instance]->MODE |= FTM_MODE_FTMEN(enable ? 1UL : 0UL);
    5f6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f72:	4a0c      	ldr	r2, [pc, #48]	; (5fa4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    5f74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f78:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    5f7a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5f7e:	2b00      	cmp	r3, #0
    5f80:	d001      	beq.n	5f86 <Ftm_Gpt_Ip_SetEnFtmModule+0x4a>
    5f82:	2101      	movs	r1, #1
    5f84:	e000      	b.n	5f88 <Ftm_Gpt_Ip_SetEnFtmModule+0x4c>
    5f86:	2100      	movs	r1, #0
    5f88:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f8c:	4805      	ldr	r0, [pc, #20]	; (5fa4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    5f8e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5f92:	430a      	orrs	r2, r1
    5f94:	655a      	str	r2, [r3, #84]	; 0x54
    }
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23();
    5f96:	f002 f8d1 	bl	813c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23>
}
    5f9a:	bf00      	nop
    5f9c:	b003      	add	sp, #12
    5f9e:	f85d fb04 	ldr.w	pc, [sp], #4
    5fa2:	bf00      	nop
    5fa4:	0000b6d0 	.word	0x0000b6d0

00005fa8 <Ftm_Gpt_Ip_SetCompareValue>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCompareValue(uint8 instance, uint8 channel, uint32 value)
{
    5fa8:	b082      	sub	sp, #8
    5faa:	4603      	mov	r3, r0
    5fac:	9200      	str	r2, [sp, #0]
    5fae:	f88d 3007 	strb.w	r3, [sp, #7]
    5fb2:	460b      	mov	r3, r1
    5fb4:	f88d 3006 	strb.w	r3, [sp, #6]
    ftmGptBase[instance]-> CONTROLS[channel].CV = (uint32)((((uint32)value << FTM_CV_VAL_SHIFT) & FTM_CV_VAL_MASK));
    5fb8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5fbc:	4a06      	ldr	r2, [pc, #24]	; (5fd8 <Ftm_Gpt_Ip_SetCompareValue+0x30>)
    5fbe:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    5fc2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5fc6:	9a00      	ldr	r2, [sp, #0]
    5fc8:	b292      	uxth	r2, r2
    5fca:	3301      	adds	r3, #1
    5fcc:	00db      	lsls	r3, r3, #3
    5fce:	440b      	add	r3, r1
    5fd0:	609a      	str	r2, [r3, #8]

}
    5fd2:	bf00      	nop
    5fd4:	b002      	add	sp, #8
    5fd6:	4770      	bx	lr
    5fd8:	0000b6d0 	.word	0x0000b6d0

00005fdc <Ftm_Gpt_Ip_WriteModulo>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_WriteModulo(uint8 instance, uint16 value)
{
    5fdc:	b082      	sub	sp, #8
    5fde:	4603      	mov	r3, r0
    5fe0:	460a      	mov	r2, r1
    5fe2:	f88d 3007 	strb.w	r3, [sp, #7]
    5fe6:	4613      	mov	r3, r2
    5fe8:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]-> MOD = value;
    5fec:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ff0:	4a04      	ldr	r2, [pc, #16]	; (6004 <Ftm_Gpt_Ip_WriteModulo+0x28>)
    5ff2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ff6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    5ffa:	609a      	str	r2, [r3, #8]

}
    5ffc:	bf00      	nop
    5ffe:	b002      	add	sp, #8
    6000:	4770      	bx	lr
    6002:	bf00      	nop
    6004:	0000b6d0 	.word	0x0000b6d0

00006008 <Ftm_Gpt_Ip_ModeSelectA>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_ModeSelectA(uint8 instance, uint8 channel, boolean enable)
{
    6008:	b500      	push	{lr}
    600a:	b083      	sub	sp, #12
    600c:	4603      	mov	r3, r0
    600e:	f88d 3007 	strb.w	r3, [sp, #7]
    6012:	460b      	mov	r3, r1
    6014:	f88d 3006 	strb.w	r3, [sp, #6]
    6018:	4613      	mov	r3, r2
    601a:	f88d 3005 	strb.w	r3, [sp, #5]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24();
    601e:	f002 f8b3 	bl	8188 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24>
    if (TRUE == enable)
    6022:	f89d 3005 	ldrb.w	r3, [sp, #5]
    6026:	2b00      	cmp	r3, #0
    6028:	d018      	beq.n	605c <Ftm_Gpt_Ip_ModeSelectA+0x54>
    {
        ftmGptBase[instance]->CONTROLS[channel].CSC |= FTM_CSC_MSA_MASK;
    602a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    602e:	4a1a      	ldr	r2, [pc, #104]	; (6098 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6030:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6034:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6038:	3301      	adds	r3, #1
    603a:	00db      	lsls	r3, r3, #3
    603c:	4413      	add	r3, r2
    603e:	685a      	ldr	r2, [r3, #4]
    6040:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6044:	4914      	ldr	r1, [pc, #80]	; (6098 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6046:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    604a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    604e:	f042 0210 	orr.w	r2, r2, #16
    6052:	3301      	adds	r3, #1
    6054:	00db      	lsls	r3, r3, #3
    6056:	440b      	add	r3, r1
    6058:	605a      	str	r2, [r3, #4]
    605a:	e017      	b.n	608c <Ftm_Gpt_Ip_ModeSelectA+0x84>
    }
    else
    {
        ftmGptBase[instance]->CONTROLS[channel].CSC &= (~(FTM_CSC_MSA_MASK));
    605c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6060:	4a0d      	ldr	r2, [pc, #52]	; (6098 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6062:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6066:	f89d 3006 	ldrb.w	r3, [sp, #6]
    606a:	3301      	adds	r3, #1
    606c:	00db      	lsls	r3, r3, #3
    606e:	4413      	add	r3, r2
    6070:	685a      	ldr	r2, [r3, #4]
    6072:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6076:	4908      	ldr	r1, [pc, #32]	; (6098 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6078:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    607c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6080:	f022 0210 	bic.w	r2, r2, #16
    6084:	3301      	adds	r3, #1
    6086:	00db      	lsls	r3, r3, #3
    6088:	440b      	add	r3, r1
    608a:	605a      	str	r2, [r3, #4]
    }
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24();
    608c:	f002 f8a8 	bl	81e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24>
}
    6090:	bf00      	nop
    6092:	b003      	add	sp, #12
    6094:	f85d fb04 	ldr.w	pc, [sp], #4
    6098:	0000b6d0 	.word	0x0000b6d0

0000609c <Ftm_Gpt_Ip_SetHalfCycleValue>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetHalfCycleValue(FTM_Type * const base, uint16 value)
{
    609c:	b082      	sub	sp, #8
    609e:	9001      	str	r0, [sp, #4]
    60a0:	460b      	mov	r3, r1
    60a2:	f8ad 3002 	strh.w	r3, [sp, #2]
    ((base)->HCR) = value;
    60a6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    60aa:	9b01      	ldr	r3, [sp, #4]
    60ac:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
}
    60b0:	bf00      	nop
    60b2:	b002      	add	sp, #8
    60b4:	4770      	bx	lr

000060b6 <Ftm_Gpt_Ip_Init>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver
* @implements    Ftm_Gpt_Ip_Init_Activity
*/
void Ftm_Gpt_Ip_Init(uint8 instance, const Ftm_Gpt_Ip_InstanceConfigType *configPtr)
{
    60b6:	b500      	push	{lr}
    60b8:	b083      	sub	sp, #12
    60ba:	4603      	mov	r3, r0
    60bc:	9100      	str	r1, [sp, #0]
    60be:	f88d 3007 	strb.w	r3, [sp, #7]
#endif
    /* Enable register access from user mode, if enabled from configuration file */
    Call_Ftm_Gpt_Ip_SetUserAccessAllowed((uint32)ftmGptBase[instance]);

    /* Check the FTM counter modes */
    if (FTM_GPT_IP_MODE_UP_TIMER == configPtr->mode)
    60c2:	9b00      	ldr	r3, [sp, #0]
    60c4:	68db      	ldr	r3, [r3, #12]
    60c6:	2b01      	cmp	r3, #1
    60c8:	d12a      	bne.n	6120 <Ftm_Gpt_Ip_Init+0x6a>
    {
        /* Set clock and prescalerValue FTM */
        Ftm_Gpt_Ip_SetPrescaler(instance, configPtr->clockPrescaler);
    60ca:	9b00      	ldr	r3, [sp, #0]
    60cc:	7a1a      	ldrb	r2, [r3, #8]
    60ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    60d2:	4611      	mov	r1, r2
    60d4:	4618      	mov	r0, r3
    60d6:	f7ff ff0b 	bl	5ef0 <Ftm_Gpt_Ip_SetPrescaler>
        /* Set FTM counter clock source */
        Ftm_Gpt_Ip_SetClockSource(instance, configPtr->clocksource);
    60da:	9b00      	ldr	r3, [sp, #0]
    60dc:	685a      	ldr	r2, [r3, #4]
    60de:	f89d 3007 	ldrb.w	r3, [sp, #7]
    60e2:	4611      	mov	r1, r2
    60e4:	4618      	mov	r0, r3
    60e6:	f7ff fedf 	bl	5ea8 <Ftm_Gpt_Ip_SetClockSource>

        /* Set freeze bits */
        Ftm_Gpt_Ip_SetFreezeBits(instance, configPtr->freezeBits);
    60ea:	9b00      	ldr	r3, [sp, #0]
    60ec:	781a      	ldrb	r2, [r3, #0]
    60ee:	f89d 3007 	ldrb.w	r3, [sp, #7]
    60f2:	4611      	mov	r1, r2
    60f4:	4618      	mov	r0, r3
    60f6:	f7ff fe25 	bl	5d44 <Ftm_Gpt_Ip_SetFreezeBits>

        /*Set Counter register and Initial Counter Value*/
        Ftm_Gpt_Ip_SetCounterInitVal(instance, 1U);
    60fa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    60fe:	2101      	movs	r1, #1
    6100:	4618      	mov	r0, r3
    6102:	f7ff fe4f 	bl	5da4 <Ftm_Gpt_Ip_SetCounterInitVal>

        /* write the Ftm Modulo Register with 0xFFFF */
        Ftm_Gpt_Ip_WriteModulo(instance, 0xFFFFU);
    6106:	f89d 3007 	ldrb.w	r3, [sp, #7]
    610a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    610e:	4618      	mov	r0, r3
    6110:	f7ff ff64 	bl	5fdc <Ftm_Gpt_Ip_WriteModulo>

        /* set FTM Enable bit */
        Ftm_Gpt_Ip_SetEnFtmModule(instance, TRUE);
    6114:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6118:	2101      	movs	r1, #1
    611a:	4618      	mov	r0, r3
    611c:	f7ff ff0e 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
#if (FTM_GPT_IP_SET_CLOCK_MODE == STD_ON)
    Ftm_Gpt_Ip_u32InstancePrescaler[instance].clockPrescaler = configPtr->clockPrescaler;
    Ftm_Gpt_Ip_u32InstancePrescaler[instance].clockAlternatePrescaler = configPtr->clockAlternatePrescaler;
#endif
    /* set FTM instance status to initialized */
    Ftm_Gpt_Ip_u32InstanceState[instance] = FTM_GPT_IP_STATUS_INITIALIZED;
    6120:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6124:	4a03      	ldr	r2, [pc, #12]	; (6134 <Ftm_Gpt_Ip_Init+0x7e>)
    6126:	2101      	movs	r1, #1
    6128:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    612c:	bf00      	nop
    612e:	b003      	add	sp, #12
    6130:	f85d fb04 	ldr.w	pc, [sp], #4
    6134:	1fff8d98 	.word	0x1fff8d98

00006138 <Ftm_Gpt_Ip_InitChannel>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver
* @implements    Ftm_Gpt_Ip_InitChannel_Activity
*/
void Ftm_Gpt_Ip_InitChannel(uint8 instance, const Ftm_Gpt_Ip_ChannelConfigType *configPtr)
{
    6138:	b500      	push	{lr}
    613a:	b083      	sub	sp, #12
    613c:	4603      	mov	r3, r0
    613e:	9100      	str	r1, [sp, #0]
    6140:	f88d 3007 	strb.w	r3, [sp, #7]
    DevAssert(FTM_INSTANCE_COUNT > instance);
    DevAssert(FTM_CONTROLS_COUNT > configPtr->hwChannel);
#endif

    /* Disable channels interrupt bit */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, configPtr->hwChannel, FALSE);
    6144:	9b00      	ldr	r3, [sp, #0]
    6146:	7819      	ldrb	r1, [r3, #0]
    6148:	f89d 3007 	ldrb.w	r3, [sp, #7]
    614c:	2200      	movs	r2, #0
    614e:	4618      	mov	r0, r3
    6150:	f7ff fe7a 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear ClearInterruptFlag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, configPtr->hwChannel);
    6154:	9b00      	ldr	r3, [sp, #0]
    6156:	781a      	ldrb	r2, [r3, #0]
    6158:	f89d 3007 	ldrb.w	r3, [sp, #7]
    615c:	4611      	mov	r1, r2
    615e:	4618      	mov	r0, r3
    6160:	f7ff fe4c 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Set Compare Value register to 0xFFFF */
    Ftm_Gpt_Ip_SetCompareValue(instance, configPtr->hwChannel, 0xFFFFU);
    6164:	9b00      	ldr	r3, [sp, #0]
    6166:	7819      	ldrb	r1, [r3, #0]
    6168:	f89d 3007 	ldrb.w	r3, [sp, #7]
    616c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6170:	4618      	mov	r0, r3
    6172:	f7ff ff19 	bl	5fa8 <Ftm_Gpt_Ip_SetCompareValue>
    /* Set bit MSA */
    Ftm_Gpt_Ip_ModeSelectA(instance, configPtr->hwChannel, TRUE);
    6176:	9b00      	ldr	r3, [sp, #0]
    6178:	7819      	ldrb	r1, [r3, #0]
    617a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    617e:	2201      	movs	r2, #1
    6180:	4618      	mov	r0, r3
    6182:	f7ff ff41 	bl	6008 <Ftm_Gpt_Ip_ModeSelectA>
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].chInit = TRUE;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].callback = configPtr->callback;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].callbackParam = configPtr->callbackParam;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].channelMode = configPtr->channelMode;
#endif
}
    6186:	bf00      	nop
    6188:	b003      	add	sp, #12
    618a:	f85d fb04 	ldr.w	pc, [sp], #4

0000618e <Ftm_Gpt_Ip_Deinit>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver.
* @implements    Ftm_Gpt_Ip_Deinit_Activity
*/
void Ftm_Gpt_Ip_Deinit(uint8 instance)
{
    618e:	b500      	push	{lr}
    6190:	b085      	sub	sp, #20
    6192:	4603      	mov	r3, r0
    6194:	f88d 3007 	strb.w	r3, [sp, #7]
    #endif

    uint8 channelIndex;

    /* Reset all channels to default */
    for (channelIndex = 0; channelIndex < FTM_CONTROLS_COUNT; channelIndex++)
    6198:	2300      	movs	r3, #0
    619a:	f88d 300f 	strb.w	r3, [sp, #15]
    619e:	e014      	b.n	61ca <Ftm_Gpt_Ip_Deinit+0x3c>
    {
        /* Disable interrupts */
        Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channelIndex, FALSE );
    61a0:	f89d 100f 	ldrb.w	r1, [sp, #15]
    61a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61a8:	2200      	movs	r2, #0
    61aa:	4618      	mov	r0, r3
    61ac:	f7ff fe4c 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
        /*Clear interrupt flags*/
        Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channelIndex);
    61b0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    61b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61b8:	4611      	mov	r1, r2
    61ba:	4618      	mov	r0, r3
    61bc:	f7ff fe1e 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    for (channelIndex = 0; channelIndex < FTM_CONTROLS_COUNT; channelIndex++)
    61c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    61c4:	3301      	adds	r3, #1
    61c6:	f88d 300f 	strb.w	r3, [sp, #15]
    61ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
    61ce:	2b07      	cmp	r3, #7
    61d0:	d9e6      	bls.n	61a0 <Ftm_Gpt_Ip_Deinit+0x12>
    }
    /* Set clock source as 'No clock'. This in effect disables the FTM counter */
    Ftm_Gpt_Ip_SetClockSource(instance, FTM_GPT_IP_CLOCK_SOURCE_NONE);
    61d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61d6:	2100      	movs	r1, #0
    61d8:	4618      	mov	r0, r3
    61da:	f7ff fe65 	bl	5ea8 <Ftm_Gpt_Ip_SetClockSource>
    /* clear FTM Enable bit */
    Ftm_Gpt_Ip_SetEnFtmModule(instance, FALSE);
    61de:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61e2:	2100      	movs	r1, #0
    61e4:	4618      	mov	r0, r3
    61e6:	f7ff fea9 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* clearde freeze bits */
    Ftm_Gpt_Ip_SetFreezeBits(instance, FALSE);
    61ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61ee:	2100      	movs	r1, #0
    61f0:	4618      	mov	r0, r3
    61f2:	f7ff fda7 	bl	5d44 <Ftm_Gpt_Ip_SetFreezeBits>
    /* Set Counter register to 0 and Initial Counter Value to 0 */
    Ftm_Gpt_Ip_SetCounterInitVal(instance, 0U);
    61f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61fa:	2100      	movs	r1, #0
    61fc:	4618      	mov	r0, r3
    61fe:	f7ff fdd1 	bl	5da4 <Ftm_Gpt_Ip_SetCounterInitVal>
    Ftm_Gpt_Ip_SetCounter(instance, 0U);
    6202:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6206:	2100      	movs	r1, #0
    6208:	4618      	mov	r0, r3
    620a:	f7ff fde1 	bl	5dd0 <Ftm_Gpt_Ip_SetCounter>
    /* set FTM instance status to uninitialized */
    Ftm_Gpt_Ip_u32InstanceState[instance] = FTM_GPT_IP_STATUS_UNINITIALIZED;
    620e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6212:	4a04      	ldr	r2, [pc, #16]	; (6224 <Ftm_Gpt_Ip_Deinit+0x96>)
    6214:	2100      	movs	r1, #0
    6216:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    621a:	bf00      	nop
    621c:	b005      	add	sp, #20
    621e:	f85d fb04 	ldr.w	pc, [sp], #4
    6222:	bf00      	nop
    6224:	1fff8d98 	.word	0x1fff8d98

00006228 <Ftm_Gpt_Ip_StartCounting>:
* @return        void
* @pre           The driver needs to be initialized. This function is called for starting the FTM timer channel.
* @implements    Ftm_Gpt_Ip_StartCounting_Activity
*/
void Ftm_Gpt_Ip_StartCounting(uint8 instance, uint8 channel, uint16 compareValue)
{
    6228:	b500      	push	{lr}
    622a:	b085      	sub	sp, #20
    622c:	4603      	mov	r3, r0
    622e:	f88d 3007 	strb.w	r3, [sp, #7]
    6232:	460b      	mov	r3, r1
    6234:	f88d 3006 	strb.w	r3, [sp, #6]
    6238:	4613      	mov	r3, r2
    623a:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
    DevAssert(FTM_INSTANCE_COUNT > instance);
    DevAssert(FTM_CONTROLS_COUNT > channel);
#endif
    uint32 counterValue;
    uint32 currentCntValue = Ftm_Gpt_Ip_GetCntValue(instance);
    623e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6242:	4618      	mov	r0, r3
    6244:	f7ff fd6e 	bl	5d24 <Ftm_Gpt_Ip_GetCntValue>
    6248:	9002      	str	r0, [sp, #8]

    if ((uint32)(currentCntValue + compareValue) > FTM_CNT_MAX_VALUE)
    624a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    624e:	9b02      	ldr	r3, [sp, #8]
    6250:	4413      	add	r3, r2
    6252:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    6256:	d308      	bcc.n	626a <Ftm_Gpt_Ip_StartCounting+0x42>
    {
        counterValue = (uint32)(compareValue - (FTM_CNT_MAX_VALUE - currentCntValue));
    6258:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    625c:	9b02      	ldr	r3, [sp, #8]
    625e:	4413      	add	r3, r2
    6260:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
    6264:	3bff      	subs	r3, #255	; 0xff
    6266:	9303      	str	r3, [sp, #12]
    6268:	e004      	b.n	6274 <Ftm_Gpt_Ip_StartCounting+0x4c>
    }
    else
    {
        counterValue = (uint32)(currentCntValue + compareValue);
    626a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    626e:	9a02      	ldr	r2, [sp, #8]
    6270:	4413      	add	r3, r2
    6272:	9303      	str	r3, [sp, #12]
    }
    /* Set new compare value */
    Ftm_Gpt_Ip_SetCompareValue(instance, channel, counterValue);
    6274:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6278:	f89d 3007 	ldrb.w	r3, [sp, #7]
    627c:	9a03      	ldr	r2, [sp, #12]
    627e:	4618      	mov	r0, r3
    6280:	f7ff fe92 	bl	5fa8 <Ftm_Gpt_Ip_SetCompareValue>
    /* Save compare value */
    Ftm_Gpt_Ip_u32TargetValue[instance][channel] = compareValue;
    6284:	f89d 1007 	ldrb.w	r1, [sp, #7]
    6288:	f89d 3006 	ldrb.w	r3, [sp, #6]
    628c:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6290:	480c      	ldr	r0, [pc, #48]	; (62c4 <Ftm_Gpt_Ip_StartCounting+0x9c>)
    6292:	00c9      	lsls	r1, r1, #3
    6294:	440b      	add	r3, r1
    6296:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    /* Clear CHF flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance,channel);
    629a:	f89d 2006 	ldrb.w	r2, [sp, #6]
    629e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62a2:	4611      	mov	r1, r2
    62a4:	4618      	mov	r0, r3
    62a6:	f7ff fda9 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Enable interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, TRUE);
    62aa:	f89d 1006 	ldrb.w	r1, [sp, #6]
    62ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62b2:	2201      	movs	r2, #1
    62b4:	4618      	mov	r0, r3
    62b6:	f7ff fdc7 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>

}
    62ba:	bf00      	nop
    62bc:	b005      	add	sp, #20
    62be:	f85d fb04 	ldr.w	pc, [sp], #4
    62c2:	bf00      	nop
    62c4:	1fff8d18 	.word	0x1fff8d18

000062c8 <Ftm_Gpt_Ip_StartTimer>:
 *                  - enables the FTM counter
 * @pre           The driver needs to be initialized.
 * @implements    Ftm_Gpt_Ip_StartTimer_Activity
 */
void Ftm_Gpt_Ip_StartTimer(uint8 instance, uint16 counterValue)
{
    62c8:	b500      	push	{lr}
    62ca:	b083      	sub	sp, #12
    62cc:	4603      	mov	r3, r0
    62ce:	460a      	mov	r2, r1
    62d0:	f88d 3007 	strb.w	r3, [sp, #7]
    62d4:	4613      	mov	r3, r2
    62d6:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
    DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    if (instance < FTM_INSTANCE_COUNT)
    62da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62de:	2b03      	cmp	r3, #3
    62e0:	d814      	bhi.n	630c <Ftm_Gpt_Ip_StartTimer+0x44>
    {
        if (FTM_GPT_IP_STATUS_INITIALIZED == Ftm_Gpt_Ip_u32InstanceState[instance])
    62e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62e6:	4a0b      	ldr	r2, [pc, #44]	; (6314 <Ftm_Gpt_Ip_StartTimer+0x4c>)
    62e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62ec:	2b01      	cmp	r3, #1
    62ee:	d10d      	bne.n	630c <Ftm_Gpt_Ip_StartTimer+0x44>
        {
            /* Set the new value counter */
            Ftm_Gpt_Ip_SetCounterInitVal(instance, counterValue);
    62f0:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    62f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62f8:	4611      	mov	r1, r2
    62fa:	4618      	mov	r0, r3
    62fc:	f7ff fd52 	bl	5da4 <Ftm_Gpt_Ip_SetCounterInitVal>
            /* set FTM Enable bit */
            Ftm_Gpt_Ip_SetEnFtmModule(instance, TRUE);
    6300:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6304:	2101      	movs	r1, #1
    6306:	4618      	mov	r0, r3
    6308:	f7ff fe18 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
        }
    }
}
    630c:	bf00      	nop
    630e:	b003      	add	sp, #12
    6310:	f85d fb04 	ldr.w	pc, [sp], #4
    6314:	1fff8d98 	.word	0x1fff8d98

00006318 <Ftm_Gpt_Ip_StopTimer>:
* @return        void
* @pre           The driver needs to be initialized. This function is called for stoping the FTM timer channel.
* @implements    Ftm_Gpt_Ip_StopTimer_Activity
*/
void Ftm_Gpt_Ip_StopTimer(uint8 instance)
{
    6318:	b500      	push	{lr}
    631a:	b083      	sub	sp, #12
    631c:	4603      	mov	r3, r0
    631e:	f88d 3007 	strb.w	r3, [sp, #7]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    /* clear FTM Enable bit */
    Ftm_Gpt_Ip_SetEnFtmModule(instance, FALSE);
    6322:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6326:	2100      	movs	r1, #0
    6328:	4618      	mov	r0, r3
    632a:	f7ff fe07 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* Set clock source as 'No clock'. This in effect disables the FTM counter */
    Ftm_Gpt_Ip_SetClockSource(instance, FTM_GPT_IP_CLOCK_SOURCE_NONE);
    632e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6332:	2100      	movs	r1, #0
    6334:	4618      	mov	r0, r3
    6336:	f7ff fdb7 	bl	5ea8 <Ftm_Gpt_Ip_SetClockSource>
}
    633a:	bf00      	nop
    633c:	b003      	add	sp, #12
    633e:	f85d fb04 	ldr.w	pc, [sp], #4

00006342 <Ftm_Gpt_Ip_EnableChannelInterrupt>:
* @return       void
* @pre          The driver needs to be initialized.
* @implements   Ftm_Gpt_Ip_EnableChannelInterrupt_Activity
*/
void Ftm_Gpt_Ip_EnableChannelInterrupt(uint8 instance, uint8 channel)
{
    6342:	b500      	push	{lr}
    6344:	b083      	sub	sp, #12
    6346:	4603      	mov	r3, r0
    6348:	460a      	mov	r2, r1
    634a:	f88d 3007 	strb.w	r3, [sp, #7]
    634e:	4613      	mov	r3, r2
    6350:	f88d 3006 	strb.w	r3, [sp, #6]
DevAssert(FTM_INSTANCE_COUNT > instance);
DevAssert(FTM_CONTROLS_COUNT > channel);
#endif

     /* Clear interrupt flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    6354:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6358:	f89d 3007 	ldrb.w	r3, [sp, #7]
    635c:	4611      	mov	r1, r2
    635e:	4618      	mov	r0, r3
    6360:	f7ff fd4c 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Enable channel interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, TRUE);
    6364:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6368:	f89d 3007 	ldrb.w	r3, [sp, #7]
    636c:	2201      	movs	r2, #1
    636e:	4618      	mov	r0, r3
    6370:	f7ff fd6a 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
}
    6374:	bf00      	nop
    6376:	b003      	add	sp, #12
    6378:	f85d fb04 	ldr.w	pc, [sp], #4

0000637c <Ftm_Gpt_Ip_DisableChannelInterrupt>:
* @return        void
* @pre           The driver needs to be initialized.
* @implements    Ftm_Gpt_Ip_DisableChannelInterrupt_Activity
*/
void Ftm_Gpt_Ip_DisableChannelInterrupt(uint8 instance, uint8 channel)
{
    637c:	b500      	push	{lr}
    637e:	b083      	sub	sp, #12
    6380:	4603      	mov	r3, r0
    6382:	460a      	mov	r2, r1
    6384:	f88d 3007 	strb.w	r3, [sp, #7]
    6388:	4613      	mov	r3, r2
    638a:	f88d 3006 	strb.w	r3, [sp, #6]
DevAssert(FTM_INSTANCE_COUNT > instance);
DevAssert(FTM_CONTROLS_COUNT > channel);
#endif

    /* Disable interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, FALSE);
    638e:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6392:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6396:	2200      	movs	r2, #0
    6398:	4618      	mov	r0, r3
    639a:	f7ff fd55 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear interrupt flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    639e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    63a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    63a6:	4611      	mov	r1, r2
    63a8:	4618      	mov	r0, r3
    63aa:	f7ff fd27 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
}
    63ae:	bf00      	nop
    63b0:	b003      	add	sp, #12
    63b2:	f85d fb04 	ldr.w	pc, [sp], #4

000063b6 <Ftm_Gpt_Ip_SetHalfCycleReloadPoint>:
* @return
* @pre           The driver needs to be initialized.
* @implements    Ftm_Gpt_Ip_SetHalfCycleReloadPoint_Activity
*/
void Ftm_Gpt_Ip_SetHalfCycleReloadPoint(uint8 instance, uint16 reloadPoint)
{
    63b6:	b500      	push	{lr}
    63b8:	b083      	sub	sp, #12
    63ba:	4603      	mov	r3, r0
    63bc:	460a      	mov	r2, r1
    63be:	f88d 3007 	strb.w	r3, [sp, #7]
    63c2:	4613      	mov	r3, r2
    63c4:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    Ftm_Gpt_Ip_SetHalfCycleValue(ftmGptBase[instance], reloadPoint);
    63c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    63cc:	4a06      	ldr	r2, [pc, #24]	; (63e8 <Ftm_Gpt_Ip_SetHalfCycleReloadPoint+0x32>)
    63ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63d2:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    63d6:	4611      	mov	r1, r2
    63d8:	4618      	mov	r0, r3
    63da:	f7ff fe5f 	bl	609c <Ftm_Gpt_Ip_SetHalfCycleValue>
}
    63de:	bf00      	nop
    63e0:	b003      	add	sp, #12
    63e2:	f85d fb04 	ldr.w	pc, [sp], #4
    63e6:	bf00      	nop
    63e8:	0000b6d0 	.word	0x0000b6d0

000063ec <Ftm_Gpt_Ip_StartPredefTimer>:
* @param[in]  bFreezeEnable   enables/disables freeze bits
* @return     void
* @pre        The driver needs to be initialized
*/
void Ftm_Gpt_Ip_StartPredefTimer (uint8 instance,uint8 channel, uint8 uPrescaler, uint8 clocksource, boolean bFreezeEnable)
{
    63ec:	b510      	push	{r4, lr}
    63ee:	b082      	sub	sp, #8
    63f0:	4604      	mov	r4, r0
    63f2:	4608      	mov	r0, r1
    63f4:	4611      	mov	r1, r2
    63f6:	461a      	mov	r2, r3
    63f8:	4623      	mov	r3, r4
    63fa:	f88d 3007 	strb.w	r3, [sp, #7]
    63fe:	4603      	mov	r3, r0
    6400:	f88d 3006 	strb.w	r3, [sp, #6]
    6404:	460b      	mov	r3, r1
    6406:	f88d 3005 	strb.w	r3, [sp, #5]
    640a:	4613      	mov	r3, r2
    640c:	f88d 3004 	strb.w	r3, [sp, #4]

    /* Enable register access from user mode, if enabled from configuration file */
    Call_Ftm_Gpt_Ip_SetUserAccessAllowed((uint32)ftmGptBase[instance]);

    /* Disable all interrupts on this channel */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, FALSE);
    6410:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6414:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6418:	2200      	movs	r2, #0
    641a:	4618      	mov	r0, r3
    641c:	f7ff fd14 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear interrupt flags */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    6420:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6424:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6428:	4611      	mov	r1, r2
    642a:	4618      	mov	r0, r3
    642c:	f7ff fce6 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Disable TOIE flags */
    ftmGptBase[instance]-> SC &= (~(FTM_SC_TOIE_MASK));
    6430:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6434:	4a35      	ldr	r2, [pc, #212]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    6436:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    643a:	681a      	ldr	r2, [r3, #0]
    643c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6440:	4932      	ldr	r1, [pc, #200]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    6442:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    6446:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    644a:	601a      	str	r2, [r3, #0]
    /* Configure FTM as a Free-Running Timer by setting FTMEN=1, CTNIN=0, MOD=0xFFFF, QUADEN=0, CPWMS=0*/
    Ftm_Gpt_Ip_SetEnFtmModule(instance, TRUE);
    644c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6450:	2101      	movs	r1, #1
    6452:	4618      	mov	r0, r3
    6454:	f7ff fd72 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* Initial Counter Value to 0 */
    Ftm_Gpt_Ip_SetCounterInitVal(instance, 0U);
    6458:	f89d 3007 	ldrb.w	r3, [sp, #7]
    645c:	2100      	movs	r1, #0
    645e:	4618      	mov	r0, r3
    6460:	f7ff fca0 	bl	5da4 <Ftm_Gpt_Ip_SetCounterInitVal>
    /* write the Ftm Modulo Register with 0xFFFF */
    Ftm_Gpt_Ip_WriteModulo(instance, 0xFFFFU);
    6464:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6468:	f64f 71ff 	movw	r1, #65535	; 0xffff
    646c:	4618      	mov	r0, r3
    646e:	f7ff fdb5 	bl	5fdc <Ftm_Gpt_Ip_WriteModulo>
    /* Set Compare Value register to 0xFFFF */
    Ftm_Gpt_Ip_SetCompareValue(instance, channel, 0xFFFFU);
    6472:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6476:	f89d 3007 	ldrb.w	r3, [sp, #7]
    647a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    647e:	4618      	mov	r0, r3
    6480:	f7ff fd92 	bl	5fa8 <Ftm_Gpt_Ip_SetCompareValue>
    /* Enter EA_28*/
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26();
    6484:	f001 ff24 	bl	82d0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26>
    /* Clear bit QUADEN */
    ftmGptBase[instance]->QDCTRL &= (~(FTM_QDCTRL_QUADEN_MASK));
    6488:	f89d 3007 	ldrb.w	r3, [sp, #7]
    648c:	4a1f      	ldr	r2, [pc, #124]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    648e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6492:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    6496:	f89d 3007 	ldrb.w	r3, [sp, #7]
    649a:	491c      	ldr	r1, [pc, #112]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    649c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    64a0:	f022 0201 	bic.w	r2, r2, #1
    64a4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    /* Clear bit CPWMS */
    ftmGptBase[instance]->SC &= (~(FTM_SC_CPWMS_MASK));
    64a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64ac:	4a17      	ldr	r2, [pc, #92]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    64ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64b2:	681a      	ldr	r2, [r3, #0]
    64b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64b8:	4914      	ldr	r1, [pc, #80]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    64ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    64be:	f022 0220 	bic.w	r2, r2, #32
    64c2:	601a      	str	r2, [r3, #0]
    /* Exit EA_28*/
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26();
    64c4:	f001 ff30 	bl	8328 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26>

    /* Configure Predef Timer */
    Ftm_Gpt_Ip_SetPrescaler(instance, uPrescaler);
    64c8:	f89d 2005 	ldrb.w	r2, [sp, #5]
    64cc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64d0:	4611      	mov	r1, r2
    64d2:	4618      	mov	r0, r3
    64d4:	f7ff fd0c 	bl	5ef0 <Ftm_Gpt_Ip_SetPrescaler>
    /* Set FTM counter clock source */
    Ftm_Gpt_Ip_SetClockSource(instance, (Ftm_Gpt_Ip_ClockSource)clocksource);
    64d8:	f89d 2004 	ldrb.w	r2, [sp, #4]
    64dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64e0:	4611      	mov	r1, r2
    64e2:	4618      	mov	r0, r3
    64e4:	f7ff fce0 	bl	5ea8 <Ftm_Gpt_Ip_SetClockSource>
    /* Set freeze bits */
    Ftm_Gpt_Ip_SetFreezeBits(instance, bFreezeEnable);
    64e8:	f89d 2010 	ldrb.w	r2, [sp, #16]
    64ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64f0:	4611      	mov	r1, r2
    64f2:	4618      	mov	r0, r3
    64f4:	f7ff fc26 	bl	5d44 <Ftm_Gpt_Ip_SetFreezeBits>
    /* Intialize FTM timer by writing any value to CNT register when CLKS not equal 0 */
    ftmGptBase[instance]->CNT = (uint32)(((uint32)1U << FTM_CNT_COUNT_SHIFT) & FTM_CNT_COUNT_MASK);
    64f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64fc:	4a03      	ldr	r2, [pc, #12]	; (650c <Ftm_Gpt_Ip_StartPredefTimer+0x120>)
    64fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6502:	2201      	movs	r2, #1
    6504:	605a      	str	r2, [r3, #4]
}
    6506:	bf00      	nop
    6508:	b002      	add	sp, #8
    650a:	bd10      	pop	{r4, pc}
    650c:	0000b6d0 	.word	0x0000b6d0

00006510 <Ftm_Gpt_Ip_StopPredefTimer>:
* @return     void
* @pre        The driver needs to be initialized
*
*/
void Ftm_Gpt_Ip_StopPredefTimer (uint8 instance, uint8 channel)
{
    6510:	b500      	push	{lr}
    6512:	b083      	sub	sp, #12
    6514:	4603      	mov	r3, r0
    6516:	460a      	mov	r2, r1
    6518:	f88d 3007 	strb.w	r3, [sp, #7]
    651c:	4613      	mov	r3, r2
    651e:	f88d 3006 	strb.w	r3, [sp, #6]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
    DevAssert(FTM_INSTANCE_COUNT > instance);
    DevAssert(FTM_CONTROLS_COUNT > channel);
#endif
    /* Set clock source as 'No clock'. This in effect disables the FTM counter */
    Ftm_Gpt_Ip_SetClockSource(instance, FTM_GPT_IP_CLOCK_SOURCE_NONE);
    6522:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6526:	2100      	movs	r1, #0
    6528:	4618      	mov	r0, r3
    652a:	f7ff fcbd 	bl	5ea8 <Ftm_Gpt_Ip_SetClockSource>
    /* Disable all interrupts on this channel */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, FALSE);
    652e:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6532:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6536:	2200      	movs	r2, #0
    6538:	4618      	mov	r0, r3
    653a:	f7ff fc85 	bl	5e48 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear interrupt flags */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    653e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6542:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6546:	4611      	mov	r1, r2
    6548:	4618      	mov	r0, r3
    654a:	f7ff fc57 	bl	5dfc <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* clear FTM Enable bit */
    Ftm_Gpt_Ip_SetEnFtmModule(instance, FALSE);
    654e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6552:	2100      	movs	r1, #0
    6554:	4618      	mov	r0, r3
    6556:	f7ff fcf1 	bl	5f3c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* Set Counter register to 0 and Initial Counter Value to 0 */
    Ftm_Gpt_Ip_SetCounterInitVal(instance, 0U);
    655a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    655e:	2100      	movs	r1, #0
    6560:	4618      	mov	r0, r3
    6562:	f7ff fc1f 	bl	5da4 <Ftm_Gpt_Ip_SetCounterInitVal>
    Ftm_Gpt_Ip_SetCounter(instance, 0U);
    6566:	f89d 3007 	ldrb.w	r3, [sp, #7]
    656a:	2100      	movs	r1, #0
    656c:	4618      	mov	r0, r3
    656e:	f7ff fc2f 	bl	5dd0 <Ftm_Gpt_Ip_SetCounter>
    Ftm_Gpt_Ip_SetCompareValue(instance, channel, 0U);
    6572:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6576:	f89d 3007 	ldrb.w	r3, [sp, #7]
    657a:	2200      	movs	r2, #0
    657c:	4618      	mov	r0, r3
    657e:	f7ff fd13 	bl	5fa8 <Ftm_Gpt_Ip_SetCompareValue>
    Ftm_Gpt_Ip_WriteModulo(instance, 0U );
    6582:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6586:	2100      	movs	r1, #0
    6588:	4618      	mov	r0, r3
    658a:	f7ff fd27 	bl	5fdc <Ftm_Gpt_Ip_WriteModulo>
    /* Set bit MSA */
    Ftm_Gpt_Ip_ModeSelectA(instance, channel, FALSE);
    658e:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6592:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6596:	2200      	movs	r2, #0
    6598:	4618      	mov	r0, r3
    659a:	f7ff fd35 	bl	6008 <Ftm_Gpt_Ip_ModeSelectA>
}
    659e:	bf00      	nop
    65a0:	b003      	add	sp, #12
    65a2:	f85d fb04 	ldr.w	pc, [sp], #4
    65a6:	bf00      	nop

000065a8 <Gpt_ValidateChannelStatus>:
(
    uint8 u8ServiceId,
    Gpt_ChannelType channel,
    uint32 coreID
)
{
    65a8:	b500      	push	{lr}
    65aa:	b085      	sub	sp, #20
    65ac:	4603      	mov	r3, r0
    65ae:	9200      	str	r2, [sp, #0]
    65b0:	f88d 3007 	strb.w	r3, [sp, #7]
    65b4:	460b      	mov	r3, r1
    65b6:	f88d 3006 	strb.w	r3, [sp, #6]
    Std_ReturnType returnValue = (Std_ReturnType)E_NOT_OK;
    65ba:	2301      	movs	r3, #1
    65bc:	f88d 300f 	strb.w	r3, [sp, #15]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(u8ServiceId, channel, coreID))
    {
#endif
        if(channel < GPT_HW_CHANNEL_NUM)
    65c0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    65c4:	2b00      	cmp	r3, #0
    65c6:	d113      	bne.n	65f0 <Gpt_ValidateChannelStatus+0x48>
                    );
                }
                else
                {
    #else
                    if (GPT_STATUS_RUNNING == Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    65c8:	f89d 2006 	ldrb.w	r2, [sp, #6]
    65cc:	490b      	ldr	r1, [pc, #44]	; (65fc <Gpt_ValidateChannelStatus+0x54>)
    65ce:	9b00      	ldr	r3, [sp, #0]
    65d0:	4413      	add	r3, r2
    65d2:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    65d6:	2b04      	cmp	r3, #4
    65d8:	d107      	bne.n	65ea <Gpt_ValidateChannelStatus+0x42>
                    {
                        (void)Det_ReportRuntimeError\
    65da:	f89d 2007 	ldrb.w	r2, [sp, #7]
    65de:	230b      	movs	r3, #11
    65e0:	2100      	movs	r1, #0
    65e2:	2064      	movs	r0, #100	; 0x64
    65e4:	f004 fc26 	bl	ae34 <Det_ReportRuntimeError>
    65e8:	e002      	b.n	65f0 <Gpt_ValidateChannelStatus+0x48>
                        );
                    }
                    else
                    {
    #endif
                        returnValue = (Std_ReturnType)E_OK;
    65ea:	2300      	movs	r3, #0
    65ec:	f88d 300f 	strb.w	r3, [sp, #15]
    #endif
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return returnValue;
    65f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    65f4:	4618      	mov	r0, r3
    65f6:	b005      	add	sp, #20
    65f8:	f85d fb04 	ldr.w	pc, [sp], #4
    65fc:	1fff8db0 	.word	0x1fff8db0

00006600 <Gpt_ValidateMode>:
static inline Std_ReturnType Gpt_ValidateMode
(
	uint8 u8ServiceId,
	uint32 coreID
)
{
    6600:	b500      	push	{lr}
    6602:	b085      	sub	sp, #20
    6604:	4603      	mov	r3, r0
    6606:	9100      	str	r1, [sp, #0]
    6608:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType returnValue;
    if (GPT_MODE_SLEEP == Gpt_eMode[coreID])
    660c:	4a0c      	ldr	r2, [pc, #48]	; (6640 <Gpt_ValidateMode+0x40>)
    660e:	9b00      	ldr	r3, [sp, #0]
    6610:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6614:	2b01      	cmp	r3, #1
    6616:	d10a      	bne.n	662e <Gpt_ValidateMode+0x2e>
    {
        (void)Det_ReportRuntimeError\
    6618:	f89d 2007 	ldrb.w	r2, [sp, #7]
    661c:	230c      	movs	r3, #12
    661e:	2100      	movs	r1, #0
    6620:	2064      	movs	r0, #100	; 0x64
    6622:	f004 fc07 	bl	ae34 <Det_ReportRuntimeError>
            (uint16)GPT_MODULE_ID,\
            (uint8)GPT_INSTANCE_ID,\
            (uint8)u8ServiceId,\
            (uint8)GPT_E_MODE\
        );
		returnValue = (Std_ReturnType)E_NOT_OK;
    6626:	2301      	movs	r3, #1
    6628:	f88d 300f 	strb.w	r3, [sp, #15]
    662c:	e002      	b.n	6634 <Gpt_ValidateMode+0x34>
    }
    else
    {
        returnValue = (Std_ReturnType)E_OK;
    662e:	2300      	movs	r3, #0
    6630:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return returnValue;
    6634:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6638:	4618      	mov	r0, r3
    663a:	b005      	add	sp, #20
    663c:	f85d fb04 	ldr.w	pc, [sp], #4
    6640:	1fff8da8 	.word	0x1fff8da8

00006644 <Gpt_ConvertChannelIndexToChannel>:
 *
 * */
static inline Gpt_ChannelType Gpt_ConvertChannelIndexToChannel(Gpt_ChannelType ChannelIndex,
                                                                              uint32 coreID
                                                                              )
{
    6644:	b084      	sub	sp, #16
    6646:	4603      	mov	r3, r0
    6648:	9100      	str	r1, [sp, #0]
    664a:	f88d 3007 	strb.w	r3, [sp, #7]
    Gpt_ChannelType Channel;

    for (Channel = 0U; Channel < GPT_HW_CHANNEL_NUM; ++Channel)
    664e:	2300      	movs	r3, #0
    6650:	f88d 300f 	strb.w	r3, [sp, #15]
    6654:	e010      	b.n	6678 <Gpt_ConvertChannelIndexToChannel+0x34>
    {
        if(ChannelIndex == (*Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap)[Channel])
    6656:	4a0e      	ldr	r2, [pc, #56]	; (6690 <Gpt_ConvertChannelIndexToChannel+0x4c>)
    6658:	9b00      	ldr	r3, [sp, #0]
    665a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    665e:	695a      	ldr	r2, [r3, #20]
    6660:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6664:	5cd3      	ldrb	r3, [r2, r3]
    6666:	f89d 2007 	ldrb.w	r2, [sp, #7]
    666a:	429a      	cmp	r2, r3
    666c:	d009      	beq.n	6682 <Gpt_ConvertChannelIndexToChannel+0x3e>
    for (Channel = 0U; Channel < GPT_HW_CHANNEL_NUM; ++Channel)
    666e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6672:	3301      	adds	r3, #1
    6674:	f88d 300f 	strb.w	r3, [sp, #15]
    6678:	f89d 300f 	ldrb.w	r3, [sp, #15]
    667c:	2b00      	cmp	r3, #0
    667e:	d0ea      	beq.n	6656 <Gpt_ConvertChannelIndexToChannel+0x12>
    6680:	e000      	b.n	6684 <Gpt_ConvertChannelIndexToChannel+0x40>
        {
            break;
    6682:	bf00      	nop
        }
    }
    return Channel;
    6684:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6688:	4618      	mov	r0, r3
    668a:	b004      	add	sp, #16
    668c:	4770      	bx	lr
    668e:	bf00      	nop
    6690:	1fff8dac 	.word	0x1fff8dac

00006694 <Gpt_CheckStatusNotificationEnabled>:
 * @pre         Gpt_Init,  must be called before.
 *
 *
 * */
static inline void Gpt_CheckStatusNotificationEnabled(uint32 coreID)
{
    6694:	b500      	push	{lr}
    6696:	b085      	sub	sp, #20
    6698:	9001      	str	r0, [sp, #4]
    Gpt_ChannelType channel;
    Gpt_ChannelType ChannelIndex;

    /*Implements the behaviour for normal mode*/
    for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    669a:	2300      	movs	r3, #0
    669c:	f88d 300f 	strb.w	r3, [sp, #15]
    66a0:	e057      	b.n	6752 <Gpt_CheckStatusNotificationEnabled+0xbe>
    {
        channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    66a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    66a6:	9901      	ldr	r1, [sp, #4]
    66a8:	4618      	mov	r0, r3
    66aa:	f7ff ffcb 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    66ae:	4603      	mov	r3, r0
    66b0:	f88d 300e 	strb.w	r3, [sp, #14]
        if(channel < GPT_HW_CHANNEL_NUM)
    66b4:	f89d 300e 	ldrb.w	r3, [sp, #14]
    66b8:	2b00      	cmp	r3, #0
    66ba:	d145      	bne.n	6748 <Gpt_CheckStatusNotificationEnabled+0xb4>
        {
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
            if (TRUE == Gpt_aChannelInfo[coreID][channel].bNotificationEnabled)
    66bc:	f89d 200e 	ldrb.w	r2, [sp, #14]
    66c0:	492b      	ldr	r1, [pc, #172]	; (6770 <Gpt_CheckStatusNotificationEnabled+0xdc>)
    66c2:	9b01      	ldr	r3, [sp, #4]
    66c4:	4413      	add	r3, r2
    66c6:	00db      	lsls	r3, r3, #3
    66c8:	440b      	add	r3, r1
    66ca:	791b      	ldrb	r3, [r3, #4]
    66cc:	2b00      	cmp	r3, #0
    66ce:	d011      	beq.n	66f4 <Gpt_CheckStatusNotificationEnabled+0x60>
            {
                /* Enable hardware interrupts */
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    66d0:	4a28      	ldr	r2, [pc, #160]	; (6774 <Gpt_CheckStatusNotificationEnabled+0xe0>)
    66d2:	9b01      	ldr	r3, [sp, #4]
    66d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66d8:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    66da:	f89d 200f 	ldrb.w	r2, [sp, #15]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    66de:	4613      	mov	r3, r2
    66e0:	005b      	lsls	r3, r3, #1
    66e2:	4413      	add	r3, r2
    66e4:	00db      	lsls	r3, r3, #3
    66e6:	440b      	add	r3, r1
    66e8:	3314      	adds	r3, #20
    66ea:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    66ec:	4618      	mov	r0, r3
    66ee:	f000 ff51 	bl	7594 <Gpt_Ipw_EnableInterrupt>
    66f2:	e029      	b.n	6748 <Gpt_CheckStatusNotificationEnabled+0xb4>
            else
            {
#endif
                /* Disable hardware interrupts if the channel is not running in the ONE-SHOT mode.
                This is needed because the channel state is updated by ISR for ONE-SHOT mode */
                if((GPT_STATUS_RUNNING != Gpt_aChannelInfo[coreID][channel].eChannelStatus) || \
    66f4:	f89d 200e 	ldrb.w	r2, [sp, #14]
    66f8:	491d      	ldr	r1, [pc, #116]	; (6770 <Gpt_CheckStatusNotificationEnabled+0xdc>)
    66fa:	9b01      	ldr	r3, [sp, #4]
    66fc:	4413      	add	r3, r2
    66fe:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6702:	2b04      	cmp	r3, #4
    6704:	d10f      	bne.n	6726 <Gpt_CheckStatusNotificationEnabled+0x92>
                    (GPT_CH_MODE_CONTINUOUS == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6706:	4a1b      	ldr	r2, [pc, #108]	; (6774 <Gpt_CheckStatusNotificationEnabled+0xe0>)
    6708:	9b01      	ldr	r3, [sp, #4]
    670a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    670e:	6859      	ldr	r1, [r3, #4]
    6710:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6714:	4613      	mov	r3, r2
    6716:	005b      	lsls	r3, r3, #1
    6718:	4413      	add	r3, r2
    671a:	00db      	lsls	r3, r3, #3
    671c:	440b      	add	r3, r1
    671e:	3310      	adds	r3, #16
    6720:	681b      	ldr	r3, [r3, #0]
                if((GPT_STATUS_RUNNING != Gpt_aChannelInfo[coreID][channel].eChannelStatus) || \
    6722:	2b00      	cmp	r3, #0
    6724:	d110      	bne.n	6748 <Gpt_CheckStatusNotificationEnabled+0xb4>
                    )
                {
                    /*Disable hardware interrupts*/
                    Gpt_Ipw_DisableInterrupt
                    (
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6726:	4a13      	ldr	r2, [pc, #76]	; (6774 <Gpt_CheckStatusNotificationEnabled+0xe0>)
    6728:	9b01      	ldr	r3, [sp, #4]
    672a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    672e:	6859      	ldr	r1, [r3, #4]
                    Gpt_Ipw_DisableInterrupt
    6730:	f89d 200f 	ldrb.w	r2, [sp, #15]
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6734:	4613      	mov	r3, r2
    6736:	005b      	lsls	r3, r3, #1
    6738:	4413      	add	r3, r2
    673a:	00db      	lsls	r3, r3, #3
    673c:	440b      	add	r3, r1
    673e:	3314      	adds	r3, #20
    6740:	681b      	ldr	r3, [r3, #0]
                    Gpt_Ipw_DisableInterrupt
    6742:	4618      	mov	r0, r3
    6744:	f000 ff41 	bl	75ca <Gpt_Ipw_DisableInterrupt>
    for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6748:	f89d 300f 	ldrb.w	r3, [sp, #15]
    674c:	3301      	adds	r3, #1
    674e:	f88d 300f 	strb.w	r3, [sp, #15]
    6752:	4a08      	ldr	r2, [pc, #32]	; (6774 <Gpt_CheckStatusNotificationEnabled+0xe0>)
    6754:	9b01      	ldr	r3, [sp, #4]
    6756:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    675a:	781b      	ldrb	r3, [r3, #0]
    675c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6760:	429a      	cmp	r2, r3
    6762:	d39e      	bcc.n	66a2 <Gpt_CheckStatusNotificationEnabled+0xe>
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
            }
#endif
        }
    }
}
    6764:	bf00      	nop
    6766:	bf00      	nop
    6768:	b005      	add	sp, #20
    676a:	f85d fb04 	ldr.w	pc, [sp], #4
    676e:	bf00      	nop
    6770:	1fff8db0 	.word	0x1fff8db0
    6774:	1fff8dac 	.word	0x1fff8dac

00006778 <Gpt_CheckStatusWakeupEnabled>:
 * @pre         Gpt_Init, Gpt_SetMode must be called before.
 *
 *
 * */
static inline void Gpt_CheckStatusWakeupEnabled(uint32 coreID)
{
    6778:	b500      	push	{lr}
    677a:	b089      	sub	sp, #36	; 0x24
    677c:	9001      	str	r0, [sp, #4]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    677e:	2300      	movs	r3, #0
    6780:	f88d 3008 	strb.w	r3, [sp, #8]
    6784:	2300      	movs	r3, #0
    6786:	9303      	str	r3, [sp, #12]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    6788:	ab02      	add	r3, sp, #8
    678a:	9306      	str	r3, [sp, #24]
    Gpt_ValueType uElapsedTime = 0U;
    678c:	2300      	movs	r3, #0
    678e:	9305      	str	r3, [sp, #20]
#endif
    Gpt_ChannelType ChannelIndex;
    Gpt_ChannelType channel;

    for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6790:	2300      	movs	r3, #0
    6792:	f88d 301f 	strb.w	r3, [sp, #31]
    6796:	e099      	b.n	68cc <Gpt_CheckStatusWakeupEnabled+0x154>
    {
        channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    6798:	f89d 301f 	ldrb.w	r3, [sp, #31]
    679c:	9901      	ldr	r1, [sp, #4]
    679e:	4618      	mov	r0, r3
    67a0:	f7ff ff50 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    67a4:	4603      	mov	r3, r0
    67a6:	f88d 3013 	strb.w	r3, [sp, #19]
        if(channel < GPT_HW_CHANNEL_NUM)
    67aa:	f89d 3013 	ldrb.w	r3, [sp, #19]
    67ae:	2b00      	cmp	r3, #0
    67b0:	f040 8087 	bne.w	68c2 <Gpt_CheckStatusWakeupEnabled+0x14a>
        {
            if (TRUE == Gpt_aChannelInfo[coreID][channel].bWakeupEnabled)
    67b4:	f89d 2013 	ldrb.w	r2, [sp, #19]
    67b8:	494c      	ldr	r1, [pc, #304]	; (68ec <Gpt_CheckStatusWakeupEnabled+0x174>)
    67ba:	9b01      	ldr	r3, [sp, #4]
    67bc:	4413      	add	r3, r2
    67be:	00db      	lsls	r3, r3, #3
    67c0:	440b      	add	r3, r1
    67c2:	795b      	ldrb	r3, [r3, #5]
    67c4:	2b00      	cmp	r3, #0
    67c6:	d011      	beq.n	67ec <Gpt_CheckStatusWakeupEnabled+0x74>
            {
                /*Enable hardware interrupts*/
                Gpt_Ipw_EnableInterrupt(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    67c8:	4a49      	ldr	r2, [pc, #292]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    67ca:	9b01      	ldr	r3, [sp, #4]
    67cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67d0:	6859      	ldr	r1, [r3, #4]
    67d2:	f89d 201f 	ldrb.w	r2, [sp, #31]
    67d6:	4613      	mov	r3, r2
    67d8:	005b      	lsls	r3, r3, #1
    67da:	4413      	add	r3, r2
    67dc:	00db      	lsls	r3, r3, #3
    67de:	440b      	add	r3, r1
    67e0:	3314      	adds	r3, #20
    67e2:	681b      	ldr	r3, [r3, #0]
    67e4:	4618      	mov	r0, r3
    67e6:	f000 fed5 	bl	7594 <Gpt_Ipw_EnableInterrupt>
    67ea:	e06a      	b.n	68c2 <Gpt_CheckStatusWakeupEnabled+0x14a>
            }
            else
            {
                /*Disable hardware interrupts*/
                Gpt_Ipw_DisableInterrupt(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    67ec:	4a40      	ldr	r2, [pc, #256]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    67ee:	9b01      	ldr	r3, [sp, #4]
    67f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67f4:	6859      	ldr	r1, [r3, #4]
    67f6:	f89d 201f 	ldrb.w	r2, [sp, #31]
    67fa:	4613      	mov	r3, r2
    67fc:	005b      	lsls	r3, r3, #1
    67fe:	4413      	add	r3, r2
    6800:	00db      	lsls	r3, r3, #3
    6802:	440b      	add	r3, r1
    6804:	3314      	adds	r3, #20
    6806:	681b      	ldr	r3, [r3, #0]
    6808:	4618      	mov	r0, r3
    680a:	f000 fede 	bl	75ca <Gpt_Ipw_DisableInterrupt>
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                /*Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs
                can change the logical channel state between the checking of logical channel
                state and timestamp retrieval*/
                /* Get the elapsed  time  for later use by other API calls*/
                uElapsedTime = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    680e:	4a38      	ldr	r2, [pc, #224]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    6810:	9b01      	ldr	r3, [sp, #4]
    6812:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6816:	6859      	ldr	r1, [r3, #4]
    6818:	f89d 201f 	ldrb.w	r2, [sp, #31]
    681c:	4613      	mov	r3, r2
    681e:	005b      	lsls	r3, r3, #1
    6820:	4413      	add	r3, r2
    6822:	00db      	lsls	r3, r3, #3
    6824:	440b      	add	r3, r1
    6826:	3314      	adds	r3, #20
    6828:	681b      	ldr	r3, [r3, #0]
    682a:	9906      	ldr	r1, [sp, #24]
    682c:	4618      	mov	r0, r3
    682e:	f000 fe86 	bl	753e <Gpt_Ipw_GetTimeElapsed>
    6832:	9005      	str	r0, [sp, #20]
#endif

                /*Stop  the running timer*/
                if (GPT_STATUS_RUNNING == Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6834:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6838:	492c      	ldr	r1, [pc, #176]	; (68ec <Gpt_CheckStatusWakeupEnabled+0x174>)
    683a:	9b01      	ldr	r3, [sp, #4]
    683c:	4413      	add	r3, r2
    683e:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6842:	2b04      	cmp	r3, #4
    6844:	d13d      	bne.n	68c2 <Gpt_CheckStatusWakeupEnabled+0x14a>
                {
                    if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6846:	f89d 3008 	ldrb.w	r3, [sp, #8]
    684a:	2b00      	cmp	r3, #0
    684c:	d018      	beq.n	6880 <Gpt_CheckStatusWakeupEnabled+0x108>
                        (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    684e:	4a28      	ldr	r2, [pc, #160]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    6850:	9b01      	ldr	r3, [sp, #4]
    6852:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6856:	6859      	ldr	r1, [r3, #4]
    6858:	f89d 201f 	ldrb.w	r2, [sp, #31]
    685c:	4613      	mov	r3, r2
    685e:	005b      	lsls	r3, r3, #1
    6860:	4413      	add	r3, r2
    6862:	00db      	lsls	r3, r3, #3
    6864:	440b      	add	r3, r1
    6866:	3310      	adds	r3, #16
    6868:	681b      	ldr	r3, [r3, #0]
                    if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    686a:	2b01      	cmp	r3, #1
    686c:	d108      	bne.n	6880 <Gpt_CheckStatusWakeupEnabled+0x108>
                        )
                    {
                        /*This action could be executed only when the function is called
                        during a critical section implemented by disabling all interrupts*/
                        /*Set the channel status to EXPIRED*/
                        Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_EXPIRED;
    686e:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6872:	491e      	ldr	r1, [pc, #120]	; (68ec <Gpt_CheckStatusWakeupEnabled+0x174>)
    6874:	9b01      	ldr	r3, [sp, #4]
    6876:	4413      	add	r3, r2
    6878:	2203      	movs	r2, #3
    687a:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    687e:	e00f      	b.n	68a0 <Gpt_CheckStatusWakeupEnabled+0x128>
                    }
                    else
                    {
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                        /* Store the stopping time for later use by other API calls*/
                        Gpt_aStopTime[coreID][channel] = uElapsedTime;
    6880:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6884:	491b      	ldr	r1, [pc, #108]	; (68f4 <Gpt_CheckStatusWakeupEnabled+0x17c>)
    6886:	9b01      	ldr	r3, [sp, #4]
    6888:	4413      	add	r3, r2
    688a:	9a05      	ldr	r2, [sp, #20]
    688c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
                        /* Set the channel status to STOPPED*/
                        Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_STOPPED;
    6890:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6894:	4915      	ldr	r1, [pc, #84]	; (68ec <Gpt_CheckStatusWakeupEnabled+0x174>)
    6896:	9b01      	ldr	r3, [sp, #4]
    6898:	4413      	add	r3, r2
    689a:	2202      	movs	r2, #2
    689c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
                    }
                    /* Call low level stop timer */
                    Gpt_Ipw_StopTimer
                    (
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    68a0:	4a13      	ldr	r2, [pc, #76]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    68a2:	9b01      	ldr	r3, [sp, #4]
    68a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    68a8:	6859      	ldr	r1, [r3, #4]
                    Gpt_Ipw_StopTimer
    68aa:	f89d 201f 	ldrb.w	r2, [sp, #31]
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    68ae:	4613      	mov	r3, r2
    68b0:	005b      	lsls	r3, r3, #1
    68b2:	4413      	add	r3, r2
    68b4:	00db      	lsls	r3, r3, #3
    68b6:	440b      	add	r3, r1
    68b8:	3314      	adds	r3, #20
    68ba:	681b      	ldr	r3, [r3, #0]
                    Gpt_Ipw_StopTimer
    68bc:	4618      	mov	r0, r3
    68be:	f000 fe54 	bl	756a <Gpt_Ipw_StopTimer>
    for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    68c2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    68c6:	3301      	adds	r3, #1
    68c8:	f88d 301f 	strb.w	r3, [sp, #31]
    68cc:	4a08      	ldr	r2, [pc, #32]	; (68f0 <Gpt_CheckStatusWakeupEnabled+0x178>)
    68ce:	9b01      	ldr	r3, [sp, #4]
    68d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    68d4:	781b      	ldrb	r3, [r3, #0]
    68d6:	f89d 201f 	ldrb.w	r2, [sp, #31]
    68da:	429a      	cmp	r2, r3
    68dc:	f4ff af5c 	bcc.w	6798 <Gpt_CheckStatusWakeupEnabled+0x20>
                    );
                }
            }
        }
    }
}
    68e0:	bf00      	nop
    68e2:	bf00      	nop
    68e4:	b009      	add	sp, #36	; 0x24
    68e6:	f85d fb04 	ldr.w	pc, [sp], #4
    68ea:	bf00      	nop
    68ec:	1fff8db0 	.word	0x1fff8db0
    68f0:	1fff8dac 	.word	0x1fff8dac
    68f4:	1fff8db8 	.word	0x1fff8db8

000068f8 <Gpt_Init>:
*
* @pre            The data structure including the configuration set required for initializing the GPT driver..
* @implements     Gpt_Init_Activity
*/
void Gpt_Init(const Gpt_ConfigType * configPtr)
{
    68f8:	b500      	push	{lr}
    68fa:	b087      	sub	sp, #28
    68fc:	9001      	str	r0, [sp, #4]
    Gpt_ChannelType ChannelIndex;
    Gpt_ChannelType channel;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    68fe:	2300      	movs	r3, #0
    6900:	9304      	str	r3, [sp, #16]
        #else
            Gpt_pConfig[coreID] = &Gpt_Config;
        #endif
            (void)configPtr;
    #else
            Gpt_pConfig[coreID] = configPtr;
    6902:	493b      	ldr	r1, [pc, #236]	; (69f0 <Gpt_Init+0xf8>)
    6904:	9b04      	ldr	r3, [sp, #16]
    6906:	9a01      	ldr	r2, [sp, #4]
    6908:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    #endif

#if(GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON)
            /*Initialize and Start Predef Timers.*/
            Gpt_Ipw_StartPredefTimer(Gpt_pConfig[coreID]);
    690c:	4a38      	ldr	r2, [pc, #224]	; (69f0 <Gpt_Init+0xf8>)
    690e:	9b04      	ldr	r3, [sp, #16]
    6910:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6914:	4618      	mov	r0, r3
    6916:	f000 fe61 	bl	75dc <Gpt_Ipw_StartPredefTimer>
#endif
            Gpt_Ipw_InitInstances(Gpt_pConfig[coreID]);
    691a:	4a35      	ldr	r2, [pc, #212]	; (69f0 <Gpt_Init+0xf8>)
    691c:	9b04      	ldr	r3, [sp, #16]
    691e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6922:	4618      	mov	r0, r3
    6924:	f000 fda0 	bl	7468 <Gpt_Ipw_InitInstances>

            /*Initialize for each channel the runtime status informations.*/
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6928:	2300      	movs	r3, #0
    692a:	f88d 3017 	strb.w	r3, [sp, #23]
    692e:	e04d      	b.n	69cc <Gpt_Init+0xd4>
            {
                channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    6930:	f89d 3017 	ldrb.w	r3, [sp, #23]
    6934:	9904      	ldr	r1, [sp, #16]
    6936:	4618      	mov	r0, r3
    6938:	f7ff fe84 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    693c:	4603      	mov	r3, r0
    693e:	f88d 300f 	strb.w	r3, [sp, #15]
                if(channel < GPT_HW_CHANNEL_NUM)
    6942:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6946:	2b00      	cmp	r3, #0
    6948:	d12a      	bne.n	69a0 <Gpt_Init+0xa8>
                {
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
                    /*Disable notification*/
                    Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    694a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    694e:	4929      	ldr	r1, [pc, #164]	; (69f4 <Gpt_Init+0xfc>)
    6950:	9b04      	ldr	r3, [sp, #16]
    6952:	4413      	add	r3, r2
    6954:	00db      	lsls	r3, r3, #3
    6956:	440b      	add	r3, r1
    6958:	2200      	movs	r2, #0
    695a:	711a      	strb	r2, [r3, #4]
#endif

#if ((GPT_WAKEUP_FUNCTIONALITY_API == STD_ON) && (GPT_REPORT_WAKEUP_SOURCE == STD_ON))
                    /*Disable wakeup*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = FALSE;
    695c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6960:	4924      	ldr	r1, [pc, #144]	; (69f4 <Gpt_Init+0xfc>)
    6962:	9b04      	ldr	r3, [sp, #16]
    6964:	4413      	add	r3, r2
    6966:	00db      	lsls	r3, r3, #3
    6968:	440b      	add	r3, r1
    696a:	2200      	movs	r2, #0
    696c:	715a      	strb	r2, [r3, #5]
                    /*Clear wakeup generation status*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupGenerated = FALSE;
    696e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6972:	4920      	ldr	r1, [pc, #128]	; (69f4 <Gpt_Init+0xfc>)
    6974:	9b04      	ldr	r3, [sp, #16]
    6976:	4413      	add	r3, r2
    6978:	00db      	lsls	r3, r3, #3
    697a:	440b      	add	r3, r1
    697c:	2200      	movs	r2, #0
    697e:	719a      	strb	r2, [r3, #6]
#endif
                    /* Initialize the running information of the channel*/
                    Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_INITIALIZED;
    6980:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6984:	491b      	ldr	r1, [pc, #108]	; (69f4 <Gpt_Init+0xfc>)
    6986:	9b04      	ldr	r3, [sp, #16]
    6988:	4413      	add	r3, r2
    698a:	2201      	movs	r2, #1
    698c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                    Gpt_aStopTime[coreID][channel] = 0U;
    6990:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6994:	4918      	ldr	r1, [pc, #96]	; (69f8 <Gpt_Init+0x100>)
    6996:	9b04      	ldr	r3, [sp, #16]
    6998:	4413      	add	r3, r2
    699a:	2200      	movs	r2, #0
    699c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
                }

                /*Initialize hardware timer channel.*/
                Gpt_Ipw_Init(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    69a0:	4a13      	ldr	r2, [pc, #76]	; (69f0 <Gpt_Init+0xf8>)
    69a2:	9b04      	ldr	r3, [sp, #16]
    69a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69a8:	6859      	ldr	r1, [r3, #4]
    69aa:	f89d 2017 	ldrb.w	r2, [sp, #23]
    69ae:	4613      	mov	r3, r2
    69b0:	005b      	lsls	r3, r3, #1
    69b2:	4413      	add	r3, r2
    69b4:	00db      	lsls	r3, r3, #3
    69b6:	440b      	add	r3, r1
    69b8:	3314      	adds	r3, #20
    69ba:	681b      	ldr	r3, [r3, #0]
    69bc:	4618      	mov	r0, r3
    69be:	f000 fd8a 	bl	74d6 <Gpt_Ipw_Init>
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    69c2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    69c6:	3301      	adds	r3, #1
    69c8:	f88d 3017 	strb.w	r3, [sp, #23]
    69cc:	4a08      	ldr	r2, [pc, #32]	; (69f0 <Gpt_Init+0xf8>)
    69ce:	9b04      	ldr	r3, [sp, #16]
    69d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69d4:	781b      	ldrb	r3, [r3, #0]
    69d6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    69da:	429a      	cmp	r2, r3
    69dc:	d3a8      	bcc.n	6930 <Gpt_Init+0x38>
            }
#if (((GPT_WAKEUP_FUNCTIONALITY_API == STD_ON) && (GPT_REPORT_WAKEUP_SOURCE == STD_ON)) || \
     (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) || \
     (GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON))
            /*Set the driver to normal mode*/
            Gpt_eMode[coreID] = GPT_MODE_NORMAL;
    69de:	4a07      	ldr	r2, [pc, #28]	; (69fc <Gpt_Init+0x104>)
    69e0:	9b04      	ldr	r3, [sp, #16]
    69e2:	2100      	movs	r1, #0
    69e4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#endif
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
    return;
    69e8:	bf00      	nop
}
    69ea:	b007      	add	sp, #28
    69ec:	f85d fb04 	ldr.w	pc, [sp], #4
    69f0:	1fff8dac 	.word	0x1fff8dac
    69f4:	1fff8db0 	.word	0x1fff8db0
    69f8:	1fff8db8 	.word	0x1fff8db8
    69fc:	1fff8da8 	.word	0x1fff8da8

00006a00 <Gpt_DeInit>:
* @return  void
*
* @implements   Gpt_DeInit_Activity
*/
void Gpt_DeInit(void)
{
    6a00:	b500      	push	{lr}
    6a02:	b085      	sub	sp, #20
    Gpt_ChannelType channel;
    Gpt_ChannelType ChannelIndex;

    Std_ReturnType allChannelStatus = (Std_ReturnType)E_OK;
    6a04:	2300      	movs	r3, #0
    6a06:	f88d 300e 	strb.w	r3, [sp, #14]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6a0a:	2300      	movs	r3, #0
    6a0c:	9302      	str	r3, [sp, #8]
    /*Validate if the calling context is valid*/
    if((Std_ReturnType)E_OK == Gpt_ValidateGlobalCall(GPT_DEINIT_ID, coreID))
    {
#endif
        /* Initialize for each channel the runtime status informations.*/
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6a0e:	2300      	movs	r3, #0
    6a10:	f88d 300f 	strb.w	r3, [sp, #15]
    6a14:	e01b      	b.n	6a4e <Gpt_DeInit+0x4e>
        {
            channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    6a16:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6a1a:	9902      	ldr	r1, [sp, #8]
    6a1c:	4618      	mov	r0, r3
    6a1e:	f7ff fe11 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    6a22:	4603      	mov	r3, r0
    6a24:	f88d 3007 	strb.w	r3, [sp, #7]
            /*Check if the channel is not running.*/
            if((Std_ReturnType)E_NOT_OK == Gpt_ValidateChannelStatus(GPT_DEINIT_ID, channel, coreID))
    6a28:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a2c:	9a02      	ldr	r2, [sp, #8]
    6a2e:	4619      	mov	r1, r3
    6a30:	2002      	movs	r0, #2
    6a32:	f7ff fdb9 	bl	65a8 <Gpt_ValidateChannelStatus>
    6a36:	4603      	mov	r3, r0
    6a38:	2b01      	cmp	r3, #1
    6a3a:	d103      	bne.n	6a44 <Gpt_DeInit+0x44>
            {
                allChannelStatus = (Std_ReturnType)E_NOT_OK;
    6a3c:	2301      	movs	r3, #1
    6a3e:	f88d 300e 	strb.w	r3, [sp, #14]
                break;
    6a42:	e00d      	b.n	6a60 <Gpt_DeInit+0x60>
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6a44:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6a48:	3301      	adds	r3, #1
    6a4a:	f88d 300f 	strb.w	r3, [sp, #15]
    6a4e:	4a3c      	ldr	r2, [pc, #240]	; (6b40 <Gpt_DeInit+0x140>)
    6a50:	9b02      	ldr	r3, [sp, #8]
    6a52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a56:	781b      	ldrb	r3, [r3, #0]
    6a58:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6a5c:	429a      	cmp	r2, r3
    6a5e:	d3da      	bcc.n	6a16 <Gpt_DeInit+0x16>
            }
        }

        if((Std_ReturnType)E_OK == allChannelStatus)
    6a60:	f89d 300e 	ldrb.w	r3, [sp, #14]
    6a64:	2b00      	cmp	r3, #0
    6a66:	d167      	bne.n	6b38 <Gpt_DeInit+0x138>
        {
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6a68:	2300      	movs	r3, #0
    6a6a:	f88d 300f 	strb.w	r3, [sp, #15]
    6a6e:	e04d      	b.n	6b0c <Gpt_DeInit+0x10c>
            {
                channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    6a70:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6a74:	9902      	ldr	r1, [sp, #8]
    6a76:	4618      	mov	r0, r3
    6a78:	f7ff fde4 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    6a7c:	4603      	mov	r3, r0
    6a7e:	f88d 3007 	strb.w	r3, [sp, #7]
                if(channel < GPT_HW_CHANNEL_NUM)
    6a82:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a86:	2b00      	cmp	r3, #0
    6a88:	d13b      	bne.n	6b02 <Gpt_DeInit+0x102>
                {
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
                    /*Disable notification*/
                    Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    6a8a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6a8e:	492d      	ldr	r1, [pc, #180]	; (6b44 <Gpt_DeInit+0x144>)
    6a90:	9b02      	ldr	r3, [sp, #8]
    6a92:	4413      	add	r3, r2
    6a94:	00db      	lsls	r3, r3, #3
    6a96:	440b      	add	r3, r1
    6a98:	2200      	movs	r2, #0
    6a9a:	711a      	strb	r2, [r3, #4]
#endif

#if ((GPT_WAKEUP_FUNCTIONALITY_API == STD_ON) && (GPT_REPORT_WAKEUP_SOURCE == STD_ON))
                    /*Disable wakeup*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = FALSE;
    6a9c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6aa0:	4928      	ldr	r1, [pc, #160]	; (6b44 <Gpt_DeInit+0x144>)
    6aa2:	9b02      	ldr	r3, [sp, #8]
    6aa4:	4413      	add	r3, r2
    6aa6:	00db      	lsls	r3, r3, #3
    6aa8:	440b      	add	r3, r1
    6aaa:	2200      	movs	r2, #0
    6aac:	715a      	strb	r2, [r3, #5]
                    /*Clear wakeup generation status*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupGenerated = FALSE;
    6aae:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ab2:	4924      	ldr	r1, [pc, #144]	; (6b44 <Gpt_DeInit+0x144>)
    6ab4:	9b02      	ldr	r3, [sp, #8]
    6ab6:	4413      	add	r3, r2
    6ab8:	00db      	lsls	r3, r3, #3
    6aba:	440b      	add	r3, r1
    6abc:	2200      	movs	r2, #0
    6abe:	719a      	strb	r2, [r3, #6]
#endif
                    /* De initialize the running information of the channel*/
                    Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_UNINITIALIZED;
    6ac0:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ac4:	491f      	ldr	r1, [pc, #124]	; (6b44 <Gpt_DeInit+0x144>)
    6ac6:	9b02      	ldr	r3, [sp, #8]
    6ac8:	4413      	add	r3, r2
    6aca:	2200      	movs	r2, #0
    6acc:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                    Gpt_aStopTime[coreID][channel] = 0U;
    6ad0:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ad4:	491c      	ldr	r1, [pc, #112]	; (6b48 <Gpt_DeInit+0x148>)
    6ad6:	9b02      	ldr	r3, [sp, #8]
    6ad8:	4413      	add	r3, r2
    6ada:	2200      	movs	r2, #0
    6adc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
                    /*Initialize hardware timer channel.*/
                    Gpt_Ipw_DeInit
                    (
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6ae0:	4a17      	ldr	r2, [pc, #92]	; (6b40 <Gpt_DeInit+0x140>)
    6ae2:	9b02      	ldr	r3, [sp, #8]
    6ae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ae8:	6859      	ldr	r1, [r3, #4]
                    Gpt_Ipw_DeInit
    6aea:	f89d 200f 	ldrb.w	r2, [sp, #15]
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6aee:	4613      	mov	r3, r2
    6af0:	005b      	lsls	r3, r3, #1
    6af2:	4413      	add	r3, r2
    6af4:	00db      	lsls	r3, r3, #3
    6af6:	440b      	add	r3, r1
    6af8:	3314      	adds	r3, #20
    6afa:	681b      	ldr	r3, [r3, #0]
                    Gpt_Ipw_DeInit
    6afc:	4618      	mov	r0, r3
    6afe:	f000 fd52 	bl	75a6 <Gpt_Ipw_DeInit>
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    6b02:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6b06:	3301      	adds	r3, #1
    6b08:	f88d 300f 	strb.w	r3, [sp, #15]
    6b0c:	4a0c      	ldr	r2, [pc, #48]	; (6b40 <Gpt_DeInit+0x140>)
    6b0e:	9b02      	ldr	r3, [sp, #8]
    6b10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b14:	781b      	ldrb	r3, [r3, #0]
    6b16:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6b1a:	429a      	cmp	r2, r3
    6b1c:	d3a8      	bcc.n	6a70 <Gpt_DeInit+0x70>
                }
            }

#if(GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON)
            /* Deinitialize and stop Predef timers.*/
            Gpt_Ipw_StopPredefTimer(Gpt_pConfig[coreID]);
    6b1e:	4a08      	ldr	r2, [pc, #32]	; (6b40 <Gpt_DeInit+0x140>)
    6b20:	9b02      	ldr	r3, [sp, #8]
    6b22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b26:	4618      	mov	r0, r3
    6b28:	f000 fdca 	bl	76c0 <Gpt_Ipw_StopPredefTimer>
#endif
            /* Writing NULL to configuration pointer is mandatory because that variable
            is used to test the initialization of the driver */
            Gpt_pConfig[coreID] = NULL_PTR;
    6b2c:	4a04      	ldr	r2, [pc, #16]	; (6b40 <Gpt_DeInit+0x140>)
    6b2e:	9b02      	ldr	r3, [sp, #8]
    6b30:	2100      	movs	r1, #0
    6b32:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }

#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
    return;
    6b36:	bf00      	nop
    6b38:	bf00      	nop
}
    6b3a:	b005      	add	sp, #20
    6b3c:	f85d fb04 	ldr.w	pc, [sp], #4
    6b40:	1fff8dac 	.word	0x1fff8dac
    6b44:	1fff8db0 	.word	0x1fff8db0
    6b48:	1fff8db8 	.word	0x1fff8db8

00006b4c <Gpt_GetTimeElapsed>:
*
* @pre     The driver needs to be initialized.
* @implements Gpt_GetTimeElapsed_Activity
*/
Gpt_ValueType Gpt_GetTimeElapsed(Gpt_ChannelType channel)
{
    6b4c:	b500      	push	{lr}
    6b4e:	b089      	sub	sp, #36	; 0x24
    6b50:	4603      	mov	r3, r0
    6b52:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    6b56:	2300      	movs	r3, #0
    6b58:	f88d 3008 	strb.w	r3, [sp, #8]
    6b5c:	2300      	movs	r3, #0
    6b5e:	9303      	str	r3, [sp, #12]
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    6b60:	ab02      	add	r3, sp, #8
    6b62:	9306      	str	r3, [sp, #24]
    Gpt_ChannelType ChannelIndex;

    Gpt_ValueType returnValue = 0U;
    6b64:	2300      	movs	r3, #0
    6b66:	9307      	str	r3, [sp, #28]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6b68:	2300      	movs	r3, #0
    6b6a:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_TIMEELAPSED_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6b6c:	4a2f      	ldr	r2, [pc, #188]	; (6c2c <Gpt_GetTimeElapsed+0xe0>)
    6b6e:	9b05      	ldr	r3, [sp, #20]
    6b70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b74:	695a      	ldr	r2, [r3, #20]
    6b76:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b7a:	5cd3      	ldrb	r3, [r2, r3]
    6b7c:	f88d 3013 	strb.w	r3, [sp, #19]
        /*Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can change
        the logical channel state between the checking of logical channel state and timestamp
        retrieval*/
        returnValue = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    6b80:	4a2a      	ldr	r2, [pc, #168]	; (6c2c <Gpt_GetTimeElapsed+0xe0>)
    6b82:	9b05      	ldr	r3, [sp, #20]
    6b84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b88:	6859      	ldr	r1, [r3, #4]
    6b8a:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6b8e:	4613      	mov	r3, r2
    6b90:	005b      	lsls	r3, r3, #1
    6b92:	4413      	add	r3, r2
    6b94:	00db      	lsls	r3, r3, #3
    6b96:	440b      	add	r3, r1
    6b98:	3314      	adds	r3, #20
    6b9a:	681b      	ldr	r3, [r3, #0]
    6b9c:	9906      	ldr	r1, [sp, #24]
    6b9e:	4618      	mov	r0, r3
    6ba0:	f000 fccd 	bl	753e <Gpt_Ipw_GetTimeElapsed>
    6ba4:	9007      	str	r0, [sp, #28]

        /*Check the channel status*/
        switch(Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6ba6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6baa:	4921      	ldr	r1, [pc, #132]	; (6c30 <Gpt_GetTimeElapsed+0xe4>)
    6bac:	9b05      	ldr	r3, [sp, #20]
    6bae:	4413      	add	r3, r2
    6bb0:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6bb4:	3b01      	subs	r3, #1
    6bb6:	2b03      	cmp	r3, #3
    6bb8:	d830      	bhi.n	6c1c <Gpt_GetTimeElapsed+0xd0>
    6bba:	a201      	add	r2, pc, #4	; (adr r2, 6bc0 <Gpt_GetTimeElapsed+0x74>)
    6bbc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6bc0:	00006bff 	.word	0x00006bff
    6bc4:	00006c05 	.word	0x00006c05
    6bc8:	00006c17 	.word	0x00006c17
    6bcc:	00006bd1 	.word	0x00006bd1
        {
            case GPT_STATUS_RUNNING:
            {
                /*Check if channel counter has already rollover*/
                if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6bd0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6bd4:	2b00      	cmp	r3, #0
    6bd6:	d023      	beq.n	6c20 <Gpt_GetTimeElapsed+0xd4>
                    (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6bd8:	4a14      	ldr	r2, [pc, #80]	; (6c2c <Gpt_GetTimeElapsed+0xe0>)
    6bda:	9b05      	ldr	r3, [sp, #20]
    6bdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6be0:	6859      	ldr	r1, [r3, #4]
    6be2:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6be6:	4613      	mov	r3, r2
    6be8:	005b      	lsls	r3, r3, #1
    6bea:	4413      	add	r3, r2
    6bec:	00db      	lsls	r3, r3, #3
    6bee:	440b      	add	r3, r1
    6bf0:	3310      	adds	r3, #16
    6bf2:	681b      	ldr	r3, [r3, #0]
                if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6bf4:	2b01      	cmp	r3, #1
    6bf6:	d113      	bne.n	6c20 <Gpt_GetTimeElapsed+0xd4>
                   )
                {
                    /*The timer has already expired.The hardware timer status is not yet
                    synchronized with the logical timer status*/
                    returnValue = returnHwChannelInfo.uTargetTime;
    6bf8:	9b03      	ldr	r3, [sp, #12]
    6bfa:	9307      	str	r3, [sp, #28]
                }
            }
            break;
    6bfc:	e010      	b.n	6c20 <Gpt_GetTimeElapsed+0xd4>
            case GPT_STATUS_INITIALIZED:
            {
                returnValue = 0U;
    6bfe:	2300      	movs	r3, #0
    6c00:	9307      	str	r3, [sp, #28]
            }
            break;
    6c02:	e00e      	b.n	6c22 <Gpt_GetTimeElapsed+0xd6>
            case GPT_STATUS_STOPPED:
            {
                /*Return elapsed time at the when the channel was stopped*/
                returnValue = Gpt_aStopTime[coreID][channel];
    6c04:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6c08:	490a      	ldr	r1, [pc, #40]	; (6c34 <Gpt_GetTimeElapsed+0xe8>)
    6c0a:	9b05      	ldr	r3, [sp, #20]
    6c0c:	4413      	add	r3, r2
    6c0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    6c12:	9307      	str	r3, [sp, #28]
            }
            break;
    6c14:	e005      	b.n	6c22 <Gpt_GetTimeElapsed+0xd6>
            case GPT_STATUS_EXPIRED:
            {
                returnValue = returnHwChannelInfo.uTargetTime;
    6c16:	9b03      	ldr	r3, [sp, #12]
    6c18:	9307      	str	r3, [sp, #28]
            }
            break;
    6c1a:	e002      	b.n	6c22 <Gpt_GetTimeElapsed+0xd6>
            default:
                /*Only the above four channel states are allowed when this function is called*/
                break;
    6c1c:	bf00      	nop
    6c1e:	e000      	b.n	6c22 <Gpt_GetTimeElapsed+0xd6>
            break;
    6c20:	bf00      	nop
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return returnValue;
    6c22:	9b07      	ldr	r3, [sp, #28]
}
    6c24:	4618      	mov	r0, r3
    6c26:	b009      	add	sp, #36	; 0x24
    6c28:	f85d fb04 	ldr.w	pc, [sp], #4
    6c2c:	1fff8dac 	.word	0x1fff8dac
    6c30:	1fff8db0 	.word	0x1fff8db0
    6c34:	1fff8db8 	.word	0x1fff8db8

00006c38 <Gpt_GetTimeRemaining>:
*
* @pre           The driver needs to be initialized.
* @implements    Gpt_GetTimeRemaining_Activity
*/
Gpt_ValueType Gpt_GetTimeRemaining(Gpt_ChannelType channel)
{
    6c38:	b500      	push	{lr}
    6c3a:	b089      	sub	sp, #36	; 0x24
    6c3c:	4603      	mov	r3, r0
    6c3e:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    6c42:	2300      	movs	r3, #0
    6c44:	f88d 3008 	strb.w	r3, [sp, #8]
    6c48:	2300      	movs	r3, #0
    6c4a:	9303      	str	r3, [sp, #12]
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    6c4c:	ab02      	add	r3, sp, #8
    6c4e:	9306      	str	r3, [sp, #24]
    Gpt_ChannelType ChannelIndex;

    Gpt_ValueType returnValue = 0U;
    6c50:	2300      	movs	r3, #0
    6c52:	9307      	str	r3, [sp, #28]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6c54:	2300      	movs	r3, #0
    6c56:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_TIMEREMAINING_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6c58:	4a32      	ldr	r2, [pc, #200]	; (6d24 <Gpt_GetTimeRemaining+0xec>)
    6c5a:	9b05      	ldr	r3, [sp, #20]
    6c5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c60:	695a      	ldr	r2, [r3, #20]
    6c62:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c66:	5cd3      	ldrb	r3, [r2, r3]
    6c68:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Calculate the remaining time from the elapsed time*/
        /* Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can
        change the logical channel state between the checking of logical channel state
        and timestamps retrieval*/
        returnValue = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    6c6c:	4a2d      	ldr	r2, [pc, #180]	; (6d24 <Gpt_GetTimeRemaining+0xec>)
    6c6e:	9b05      	ldr	r3, [sp, #20]
    6c70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c74:	6859      	ldr	r1, [r3, #4]
    6c76:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6c7a:	4613      	mov	r3, r2
    6c7c:	005b      	lsls	r3, r3, #1
    6c7e:	4413      	add	r3, r2
    6c80:	00db      	lsls	r3, r3, #3
    6c82:	440b      	add	r3, r1
    6c84:	3314      	adds	r3, #20
    6c86:	681b      	ldr	r3, [r3, #0]
    6c88:	9906      	ldr	r1, [sp, #24]
    6c8a:	4618      	mov	r0, r3
    6c8c:	f000 fc57 	bl	753e <Gpt_Ipw_GetTimeElapsed>
    6c90:	9007      	str	r0, [sp, #28]

        /*Check the channel status*/
        switch(Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6c92:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6c96:	4924      	ldr	r1, [pc, #144]	; (6d28 <Gpt_GetTimeRemaining+0xf0>)
    6c98:	9b05      	ldr	r3, [sp, #20]
    6c9a:	4413      	add	r3, r2
    6c9c:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6ca0:	3b01      	subs	r3, #1
    6ca2:	2b03      	cmp	r3, #3
    6ca4:	d837      	bhi.n	6d16 <Gpt_GetTimeRemaining+0xde>
    6ca6:	a201      	add	r2, pc, #4	; (adr r2, 6cac <Gpt_GetTimeRemaining+0x74>)
    6ca8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6cac:	00006cf5 	.word	0x00006cf5
    6cb0:	00006cfb 	.word	0x00006cfb
    6cb4:	00006d11 	.word	0x00006d11
    6cb8:	00006cbd 	.word	0x00006cbd
        {
            case GPT_STATUS_RUNNING:
            {
                /*Check if channel counter has already roll-over*/
                if((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6cbc:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cc0:	2b00      	cmp	r3, #0
    6cc2:	d012      	beq.n	6cea <Gpt_GetTimeRemaining+0xb2>
                   (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6cc4:	4a17      	ldr	r2, [pc, #92]	; (6d24 <Gpt_GetTimeRemaining+0xec>)
    6cc6:	9b05      	ldr	r3, [sp, #20]
    6cc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ccc:	6859      	ldr	r1, [r3, #4]
    6cce:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6cd2:	4613      	mov	r3, r2
    6cd4:	005b      	lsls	r3, r3, #1
    6cd6:	4413      	add	r3, r2
    6cd8:	00db      	lsls	r3, r3, #3
    6cda:	440b      	add	r3, r1
    6cdc:	3310      	adds	r3, #16
    6cde:	681b      	ldr	r3, [r3, #0]
                if((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6ce0:	2b01      	cmp	r3, #1
    6ce2:	d102      	bne.n	6cea <Gpt_GetTimeRemaining+0xb2>
                  )
                {
                    /*The timer has already expired.The hardware timer status is not yet
                    synchronized with the logical timer status*/
                    returnValue = 0U;
    6ce4:	2300      	movs	r3, #0
    6ce6:	9307      	str	r3, [sp, #28]
                {
                    /*Calculate remaining time from elapsed time*/
                    returnValue = returnHwChannelInfo.uTargetTime - returnValue;
                }
            }
            break;
    6ce8:	e016      	b.n	6d18 <Gpt_GetTimeRemaining+0xe0>
                    returnValue = returnHwChannelInfo.uTargetTime - returnValue;
    6cea:	9a03      	ldr	r2, [sp, #12]
    6cec:	9b07      	ldr	r3, [sp, #28]
    6cee:	1ad3      	subs	r3, r2, r3
    6cf0:	9307      	str	r3, [sp, #28]
            break;
    6cf2:	e011      	b.n	6d18 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_INITIALIZED:
            {
                returnValue = 0U;
    6cf4:	2300      	movs	r3, #0
    6cf6:	9307      	str	r3, [sp, #28]
            }
            break;
    6cf8:	e00e      	b.n	6d18 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_STOPPED:
            {
                returnValue = returnHwChannelInfo.uTargetTime-Gpt_aStopTime[coreID][channel];
    6cfa:	9a03      	ldr	r2, [sp, #12]
    6cfc:	f89d 1007 	ldrb.w	r1, [sp, #7]
    6d00:	480a      	ldr	r0, [pc, #40]	; (6d2c <Gpt_GetTimeRemaining+0xf4>)
    6d02:	9b05      	ldr	r3, [sp, #20]
    6d04:	440b      	add	r3, r1
    6d06:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    6d0a:	1ad3      	subs	r3, r2, r3
    6d0c:	9307      	str	r3, [sp, #28]
            }
            break;
    6d0e:	e003      	b.n	6d18 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_EXPIRED:
            {
                returnValue = 0U;
    6d10:	2300      	movs	r3, #0
    6d12:	9307      	str	r3, [sp, #28]
            }
            break;
    6d14:	e000      	b.n	6d18 <Gpt_GetTimeRemaining+0xe0>
            default:
                /*Only the above four channel states are allowed when this function is called*/
                break;
    6d16:	bf00      	nop
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return returnValue;
    6d18:	9b07      	ldr	r3, [sp, #28]
}
    6d1a:	4618      	mov	r0, r3
    6d1c:	b009      	add	sp, #36	; 0x24
    6d1e:	f85d fb04 	ldr.w	pc, [sp], #4
    6d22:	bf00      	nop
    6d24:	1fff8dac 	.word	0x1fff8dac
    6d28:	1fff8db0 	.word	0x1fff8db0
    6d2c:	1fff8db8 	.word	0x1fff8db8

00006d30 <Gpt_StartTimer>:
void Gpt_StartTimer
(
    Gpt_ChannelType channel,
    Gpt_ValueType value
)
{
    6d30:	b500      	push	{lr}
    6d32:	b085      	sub	sp, #20
    6d34:	4603      	mov	r3, r0
    6d36:	9100      	str	r1, [sp, #0]
    6d38:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    Std_ReturnType returnValue;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6d3c:	2300      	movs	r3, #0
    6d3e:	9303      	str	r3, [sp, #12]

    if ((Std_ReturnType)E_OK == Gpt_ValidateChannelStatus(GPT_STARTTIMER_ID, channel, coreID))
    6d40:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6d44:	9a03      	ldr	r2, [sp, #12]
    6d46:	4619      	mov	r1, r3
    6d48:	2005      	movs	r0, #5
    6d4a:	f7ff fc2d 	bl	65a8 <Gpt_ValidateChannelStatus>
    6d4e:	4603      	mov	r3, r0
    6d50:	2b00      	cmp	r3, #0
    6d52:	d152      	bne.n	6dfa <Gpt_StartTimer+0xca>
    {
#if (GPT_VALIDATE_PARAM  == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateParamValue(GPT_STARTTIMER_ID, channel, value, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6d54:	4a2b      	ldr	r2, [pc, #172]	; (6e04 <Gpt_StartTimer+0xd4>)
    6d56:	9b03      	ldr	r3, [sp, #12]
    6d58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d5c:	695a      	ldr	r2, [r3, #20]
    6d5e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6d62:	5cd3      	ldrb	r3, [r2, r3]
    6d64:	f88d 300b 	strb.w	r3, [sp, #11]
            /*Enable hardware interrupts for the one-shot mode to set the status of  channel*/
            if (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6d68:	4a26      	ldr	r2, [pc, #152]	; (6e04 <Gpt_StartTimer+0xd4>)
    6d6a:	9b03      	ldr	r3, [sp, #12]
    6d6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d70:	6859      	ldr	r1, [r3, #4]
    6d72:	f89d 200b 	ldrb.w	r2, [sp, #11]
    6d76:	4613      	mov	r3, r2
    6d78:	005b      	lsls	r3, r3, #1
    6d7a:	4413      	add	r3, r2
    6d7c:	00db      	lsls	r3, r3, #3
    6d7e:	440b      	add	r3, r1
    6d80:	3310      	adds	r3, #16
    6d82:	681b      	ldr	r3, [r3, #0]
    6d84:	2b01      	cmp	r3, #1
    6d86:	d110      	bne.n	6daa <Gpt_StartTimer+0x7a>
            {
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6d88:	4a1e      	ldr	r2, [pc, #120]	; (6e04 <Gpt_StartTimer+0xd4>)
    6d8a:	9b03      	ldr	r3, [sp, #12]
    6d8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6d90:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    6d92:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6d96:	4613      	mov	r3, r2
    6d98:	005b      	lsls	r3, r3, #1
    6d9a:	4413      	add	r3, r2
    6d9c:	00db      	lsls	r3, r3, #3
    6d9e:	440b      	add	r3, r1
    6da0:	3314      	adds	r3, #20
    6da2:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    6da4:	4618      	mov	r0, r3
    6da6:	f000 fbf5 	bl	7594 <Gpt_Ipw_EnableInterrupt>
                );
            }

            /* Change GPT channel status.Channel status change shall be made before to start
            the hardware in order to not change the channel status from EXPIRED to RUNNING*/
            Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_RUNNING;
    6daa:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6dae:	4916      	ldr	r1, [pc, #88]	; (6e08 <Gpt_StartTimer+0xd8>)
    6db0:	9b03      	ldr	r3, [sp, #12]
    6db2:	4413      	add	r3, r2
    6db4:	2204      	movs	r2, #4
    6db6:	f841 2033 	str.w	r2, [r1, r3, lsl #3]

            /* Call low level API */
            returnValue = Gpt_Ipw_StartTimer(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig),value);
    6dba:	4a12      	ldr	r2, [pc, #72]	; (6e04 <Gpt_StartTimer+0xd4>)
    6dbc:	9b03      	ldr	r3, [sp, #12]
    6dbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6dc2:	6859      	ldr	r1, [r3, #4]
    6dc4:	f89d 200b 	ldrb.w	r2, [sp, #11]
    6dc8:	4613      	mov	r3, r2
    6dca:	005b      	lsls	r3, r3, #1
    6dcc:	4413      	add	r3, r2
    6dce:	00db      	lsls	r3, r3, #3
    6dd0:	440b      	add	r3, r1
    6dd2:	3314      	adds	r3, #20
    6dd4:	681b      	ldr	r3, [r3, #0]
    6dd6:	9900      	ldr	r1, [sp, #0]
    6dd8:	4618      	mov	r0, r3
    6dda:	f000 fb91 	bl	7500 <Gpt_Ipw_StartTimer>
    6dde:	4603      	mov	r3, r0
    6de0:	f88d 300a 	strb.w	r3, [sp, #10]

            if((Std_ReturnType)E_OK != returnValue)
    6de4:	f89d 300a 	ldrb.w	r3, [sp, #10]
    6de8:	2b00      	cmp	r3, #0
    6dea:	d006      	beq.n	6dfa <Gpt_StartTimer+0xca>
            {
                (void)Det_ReportRuntimeError\
    6dec:	232b      	movs	r3, #43	; 0x2b
    6dee:	2205      	movs	r2, #5
    6df0:	2100      	movs	r1, #0
    6df2:	2064      	movs	r0, #100	; 0x64
    6df4:	f004 f81e 	bl	ae34 <Det_ReportRuntimeError>
            }
#if (GPT_VALIDATE_PARAM  == STD_ON)
        }
#endif
    }
    return;
    6df8:	bf00      	nop
    6dfa:	bf00      	nop
}
    6dfc:	b005      	add	sp, #20
    6dfe:	f85d fb04 	ldr.w	pc, [sp], #4
    6e02:	bf00      	nop
    6e04:	1fff8dac 	.word	0x1fff8dac
    6e08:	1fff8db0 	.word	0x1fff8db0

00006e0c <Gpt_StopTimer>:
*
* @pre          The driver needs to be initialized. Gpt_StartTimer must be called before.
* @implements   Gpt_StopTimer_Activity
*/
void Gpt_StopTimer(Gpt_ChannelType channel)
{
    6e0c:	b500      	push	{lr}
    6e0e:	b089      	sub	sp, #36	; 0x24
    6e10:	4603      	mov	r3, r0
    6e12:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    6e16:	2300      	movs	r3, #0
    6e18:	f88d 3008 	strb.w	r3, [sp, #8]
    6e1c:	2300      	movs	r3, #0
    6e1e:	9303      	str	r3, [sp, #12]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    6e20:	ab02      	add	r3, sp, #8
    6e22:	9307      	str	r3, [sp, #28]
    Gpt_ValueType uElapsedTime = 0U;
    6e24:	2300      	movs	r3, #0
    6e26:	9306      	str	r3, [sp, #24]
#endif
    Gpt_ChannelType ChannelIndex;

    uint32 coreID = (uint32)Gpt_GetCoreID();
    6e28:	2300      	movs	r3, #0
    6e2a:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_STOPTIMER_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6e2c:	4a34      	ldr	r2, [pc, #208]	; (6f00 <Gpt_StopTimer+0xf4>)
    6e2e:	9b05      	ldr	r3, [sp, #20]
    6e30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e34:	695a      	ldr	r2, [r3, #20]
    6e36:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6e3a:	5cd3      	ldrb	r3, [r2, r3]
    6e3c:	f88d 3013 	strb.w	r3, [sp, #19]
        /*Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can change
        the logical channel state between the checking of logical channel state and timestamps
        retrieval*/
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
        /* Get the elapsed  time  for later use by other API calls*/
        uElapsedTime = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    6e40:	4a2f      	ldr	r2, [pc, #188]	; (6f00 <Gpt_StopTimer+0xf4>)
    6e42:	9b05      	ldr	r3, [sp, #20]
    6e44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e48:	6859      	ldr	r1, [r3, #4]
    6e4a:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6e4e:	4613      	mov	r3, r2
    6e50:	005b      	lsls	r3, r3, #1
    6e52:	4413      	add	r3, r2
    6e54:	00db      	lsls	r3, r3, #3
    6e56:	440b      	add	r3, r1
    6e58:	3314      	adds	r3, #20
    6e5a:	681b      	ldr	r3, [r3, #0]
    6e5c:	9907      	ldr	r1, [sp, #28]
    6e5e:	4618      	mov	r0, r3
    6e60:	f000 fb6d 	bl	753e <Gpt_Ipw_GetTimeElapsed>
    6e64:	9006      	str	r0, [sp, #24]
#endif

        /*Check the logical channel status*/
        if (GPT_STATUS_RUNNING == Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6e66:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6e6a:	4926      	ldr	r1, [pc, #152]	; (6f04 <Gpt_StopTimer+0xf8>)
    6e6c:	9b05      	ldr	r3, [sp, #20]
    6e6e:	4413      	add	r3, r2
    6e70:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6e74:	2b04      	cmp	r3, #4
    6e76:	d13e      	bne.n	6ef6 <Gpt_StopTimer+0xea>
        {
            /* Call low level stop timer */
            Gpt_Ipw_StopTimer(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    6e78:	4a21      	ldr	r2, [pc, #132]	; (6f00 <Gpt_StopTimer+0xf4>)
    6e7a:	9b05      	ldr	r3, [sp, #20]
    6e7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e80:	6859      	ldr	r1, [r3, #4]
    6e82:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6e86:	4613      	mov	r3, r2
    6e88:	005b      	lsls	r3, r3, #1
    6e8a:	4413      	add	r3, r2
    6e8c:	00db      	lsls	r3, r3, #3
    6e8e:	440b      	add	r3, r1
    6e90:	3314      	adds	r3, #20
    6e92:	681b      	ldr	r3, [r3, #0]
    6e94:	4618      	mov	r0, r3
    6e96:	f000 fb68 	bl	756a <Gpt_Ipw_StopTimer>

            if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6e9a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6e9e:	2b00      	cmp	r3, #0
    6ea0:	d018      	beq.n	6ed4 <Gpt_StopTimer+0xc8>
                (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6ea2:	4a17      	ldr	r2, [pc, #92]	; (6f00 <Gpt_StopTimer+0xf4>)
    6ea4:	9b05      	ldr	r3, [sp, #20]
    6ea6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6eaa:	6859      	ldr	r1, [r3, #4]
    6eac:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6eb0:	4613      	mov	r3, r2
    6eb2:	005b      	lsls	r3, r3, #1
    6eb4:	4413      	add	r3, r2
    6eb6:	00db      	lsls	r3, r3, #3
    6eb8:	440b      	add	r3, r1
    6eba:	3310      	adds	r3, #16
    6ebc:	681b      	ldr	r3, [r3, #0]
            if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6ebe:	2b01      	cmp	r3, #1
    6ec0:	d108      	bne.n	6ed4 <Gpt_StopTimer+0xc8>
            )
            {
                /*This action could be executed only when the function is called during a critical
                section implemented by disabling all interrupts*/
                /*Set channel status to EXPIRED*/
                Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_EXPIRED;
    6ec2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ec6:	490f      	ldr	r1, [pc, #60]	; (6f04 <Gpt_StopTimer+0xf8>)
    6ec8:	9b05      	ldr	r3, [sp, #20]
    6eca:	4413      	add	r3, r2
    6ecc:	2203      	movs	r2, #3
    6ece:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    6ed2:	e00f      	b.n	6ef4 <Gpt_StopTimer+0xe8>
            }
            else
            {
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                /* Store the stopping time for later use by other API calls*/
                Gpt_aStopTime[coreID][channel] = uElapsedTime;
    6ed4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ed8:	490b      	ldr	r1, [pc, #44]	; (6f08 <Gpt_StopTimer+0xfc>)
    6eda:	9b05      	ldr	r3, [sp, #20]
    6edc:	4413      	add	r3, r2
    6ede:	9a06      	ldr	r2, [sp, #24]
    6ee0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

                /* Set GPT channel status to stopped*/
                Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_STOPPED;
    6ee4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6ee8:	4906      	ldr	r1, [pc, #24]	; (6f04 <Gpt_StopTimer+0xf8>)
    6eea:	9b05      	ldr	r3, [sp, #20]
    6eec:	4413      	add	r3, r2
    6eee:	2202      	movs	r2, #2
    6ef0:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
            }
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return;
    6ef4:	bf00      	nop
    6ef6:	bf00      	nop
}
    6ef8:	b009      	add	sp, #36	; 0x24
    6efa:	f85d fb04 	ldr.w	pc, [sp], #4
    6efe:	bf00      	nop
    6f00:	1fff8dac 	.word	0x1fff8dac
    6f04:	1fff8db0 	.word	0x1fff8db0
    6f08:	1fff8db8 	.word	0x1fff8db8

00006f0c <Gpt_EnableNotification>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_EnableNotification_Activity
*/
void Gpt_EnableNotification(Gpt_ChannelType channel)
{
    6f0c:	b500      	push	{lr}
    6f0e:	b085      	sub	sp, #20
    6f10:	4603      	mov	r3, r0
    6f12:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6f16:	2300      	movs	r3, #0
    6f18:	9303      	str	r3, [sp, #12]
#endif
#if (GPT_VALIDATE_PARAM == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateChannelNotification(GPT_ENABLENOTIFICATION_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6f1a:	4a17      	ldr	r2, [pc, #92]	; (6f78 <Gpt_EnableNotification+0x6c>)
    6f1c:	9b03      	ldr	r3, [sp, #12]
    6f1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f22:	695a      	ldr	r2, [r3, #20]
    6f24:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6f28:	5cd3      	ldrb	r3, [r2, r3]
    6f2a:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Set the enable notification attribute */
            Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = TRUE;
    6f2e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6f32:	4912      	ldr	r1, [pc, #72]	; (6f7c <Gpt_EnableNotification+0x70>)
    6f34:	9b03      	ldr	r3, [sp, #12]
    6f36:	4413      	add	r3, r2
    6f38:	00db      	lsls	r3, r3, #3
    6f3a:	440b      	add	r3, r1
    6f3c:	2201      	movs	r2, #1
    6f3e:	711a      	strb	r2, [r3, #4]

            if (GPT_MODE_NORMAL == Gpt_eMode[coreID])
    6f40:	4a0f      	ldr	r2, [pc, #60]	; (6f80 <Gpt_EnableNotification+0x74>)
    6f42:	9b03      	ldr	r3, [sp, #12]
    6f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f48:	2b00      	cmp	r3, #0
    6f4a:	d111      	bne.n	6f70 <Gpt_EnableNotification+0x64>
            {
                /*Enable hardware interrupts*/
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6f4c:	4a0a      	ldr	r2, [pc, #40]	; (6f78 <Gpt_EnableNotification+0x6c>)
    6f4e:	9b03      	ldr	r3, [sp, #12]
    6f50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f54:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    6f56:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6f5a:	4613      	mov	r3, r2
    6f5c:	005b      	lsls	r3, r3, #1
    6f5e:	4413      	add	r3, r2
    6f60:	00db      	lsls	r3, r3, #3
    6f62:	440b      	add	r3, r1
    6f64:	3314      	adds	r3, #20
    6f66:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    6f68:	4618      	mov	r0, r3
    6f6a:	f000 fb13 	bl	7594 <Gpt_Ipw_EnableInterrupt>
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return;
    6f6e:	bf00      	nop
    6f70:	bf00      	nop
}
    6f72:	b005      	add	sp, #20
    6f74:	f85d fb04 	ldr.w	pc, [sp], #4
    6f78:	1fff8dac 	.word	0x1fff8dac
    6f7c:	1fff8db0 	.word	0x1fff8db0
    6f80:	1fff8da8 	.word	0x1fff8da8

00006f84 <Gpt_DisableNotification>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_DisableNotification_Activity
*/
void Gpt_DisableNotification(Gpt_ChannelType channel)
{
    6f84:	b500      	push	{lr}
    6f86:	b085      	sub	sp, #20
    6f88:	4603      	mov	r3, r0
    6f8a:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6f8e:	2300      	movs	r3, #0
    6f90:	9303      	str	r3, [sp, #12]
#endif
#if (GPT_VALIDATE_PARAM == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateChannelNotification(GPT_DISABLENOTIFICATION_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6f92:	4a24      	ldr	r2, [pc, #144]	; (7024 <Gpt_DisableNotification+0xa0>)
    6f94:	9b03      	ldr	r3, [sp, #12]
    6f96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f9a:	695a      	ldr	r2, [r3, #20]
    6f9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6fa0:	5cd3      	ldrb	r3, [r2, r3]
    6fa2:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Set the enable notification attribute */
            Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    6fa6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6faa:	491f      	ldr	r1, [pc, #124]	; (7028 <Gpt_DisableNotification+0xa4>)
    6fac:	9b03      	ldr	r3, [sp, #12]
    6fae:	4413      	add	r3, r2
    6fb0:	00db      	lsls	r3, r3, #3
    6fb2:	440b      	add	r3, r1
    6fb4:	2200      	movs	r2, #0
    6fb6:	711a      	strb	r2, [r3, #4]

            /* Disable hardware interrupts if the channel is not running in the ONE-SHOT mode.
            This is needed because the channel state is updated by ISR for ONE-SHOT mode */
            if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && \
    6fb8:	4a1c      	ldr	r2, [pc, #112]	; (702c <Gpt_DisableNotification+0xa8>)
    6fba:	9b03      	ldr	r3, [sp, #12]
    6fbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fc0:	2b00      	cmp	r3, #0
    6fc2:	d12a      	bne.n	701a <Gpt_DisableNotification+0x96>
                ((GPT_CH_MODE_CONTINUOUS == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode) \
    6fc4:	4a17      	ldr	r2, [pc, #92]	; (7024 <Gpt_DisableNotification+0xa0>)
    6fc6:	9b03      	ldr	r3, [sp, #12]
    6fc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fcc:	6859      	ldr	r1, [r3, #4]
    6fce:	f89d 200b 	ldrb.w	r2, [sp, #11]
    6fd2:	4613      	mov	r3, r2
    6fd4:	005b      	lsls	r3, r3, #1
    6fd6:	4413      	add	r3, r2
    6fd8:	00db      	lsls	r3, r3, #3
    6fda:	440b      	add	r3, r1
    6fdc:	3310      	adds	r3, #16
    6fde:	681b      	ldr	r3, [r3, #0]
            if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && \
    6fe0:	2b00      	cmp	r3, #0
    6fe2:	d008      	beq.n	6ff6 <Gpt_DisableNotification+0x72>
                 || (GPT_STATUS_RUNNING != Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6fe4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6fe8:	490f      	ldr	r1, [pc, #60]	; (7028 <Gpt_DisableNotification+0xa4>)
    6fea:	9b03      	ldr	r3, [sp, #12]
    6fec:	4413      	add	r3, r2
    6fee:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6ff2:	2b04      	cmp	r3, #4
    6ff4:	d011      	beq.n	701a <Gpt_DisableNotification+0x96>
               )
            {
                /*Disable hardware interrupts*/
                Gpt_Ipw_DisableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6ff6:	4a0b      	ldr	r2, [pc, #44]	; (7024 <Gpt_DisableNotification+0xa0>)
    6ff8:	9b03      	ldr	r3, [sp, #12]
    6ffa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ffe:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_DisableInterrupt
    7000:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    7004:	4613      	mov	r3, r2
    7006:	005b      	lsls	r3, r3, #1
    7008:	4413      	add	r3, r2
    700a:	00db      	lsls	r3, r3, #3
    700c:	440b      	add	r3, r1
    700e:	3314      	adds	r3, #20
    7010:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_DisableInterrupt
    7012:	4618      	mov	r0, r3
    7014:	f000 fad9 	bl	75ca <Gpt_Ipw_DisableInterrupt>
        }
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return;
    7018:	bf00      	nop
    701a:	bf00      	nop
}
    701c:	b005      	add	sp, #20
    701e:	f85d fb04 	ldr.w	pc, [sp], #4
    7022:	bf00      	nop
    7024:	1fff8dac 	.word	0x1fff8dac
    7028:	1fff8db0 	.word	0x1fff8db0
    702c:	1fff8da8 	.word	0x1fff8da8

00007030 <Gpt_SetMode>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_SetMode_Activity
*/
void Gpt_SetMode(Gpt_ModeType Mode)
{
    7030:	b500      	push	{lr}
    7032:	b085      	sub	sp, #20
    7034:	9001      	str	r0, [sp, #4]
#if (GPT_REPORT_WAKEUP_SOURCE == STD_OFF)
    (void)Mode;
#endif

#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
    uint32 coreID = (uint32)Gpt_GetCoreID();
    7036:	2300      	movs	r3, #0
    7038:	9303      	str	r3, [sp, #12]
        /*Validate the driver calling context*/
        if((Std_ReturnType)E_OK == Gpt_ValidateParamMode(Mode))
        {
#endif
            /*Implements the behaviour for the sleep mode */
            if(GPT_MODE_SLEEP == Mode)
    703a:	9b01      	ldr	r3, [sp, #4]
    703c:	2b01      	cmp	r3, #1
    703e:	d10f      	bne.n	7060 <Gpt_SetMode+0x30>
            {
                /* Check channel has wakeup enabled at runtime */
                Gpt_CheckStatusWakeupEnabled(coreID);
    7040:	9803      	ldr	r0, [sp, #12]
    7042:	f7ff fb99 	bl	6778 <Gpt_CheckStatusWakeupEnabled>

#if(GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON)
                /* De-initialize and Stop Predef Timers. */
                Gpt_Ipw_StopPredefTimer(Gpt_pConfig[coreID]);
    7046:	4a15      	ldr	r2, [pc, #84]	; (709c <Gpt_SetMode+0x6c>)
    7048:	9b03      	ldr	r3, [sp, #12]
    704a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    704e:	4618      	mov	r0, r3
    7050:	f000 fb36 	bl	76c0 <Gpt_Ipw_StopPredefTimer>
#endif
#if (((GPT_WAKEUP_FUNCTIONALITY_API == STD_ON) && (GPT_REPORT_WAKEUP_SOURCE == STD_ON)) || \
     (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) || \
     (GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON))
                /* Set the driver mode to sleep */
                Gpt_eMode[coreID] = GPT_MODE_SLEEP;
    7054:	4a12      	ldr	r2, [pc, #72]	; (70a0 <Gpt_SetMode+0x70>)
    7056:	9b03      	ldr	r3, [sp, #12]
    7058:	2101      	movs	r1, #1
    705a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif

#endif /*GPT_REPORT_WAKEUP_SOURCE*/
    return;
    705e:	e018      	b.n	7092 <Gpt_SetMode+0x62>
            else if (GPT_MODE_NORMAL == Mode)
    7060:	9b01      	ldr	r3, [sp, #4]
    7062:	2b00      	cmp	r3, #0
    7064:	d115      	bne.n	7092 <Gpt_SetMode+0x62>
                   if ((Gpt_ModeType)GPT_MODE_SLEEP == Gpt_eMode[coreID])
    7066:	4a0e      	ldr	r2, [pc, #56]	; (70a0 <Gpt_SetMode+0x70>)
    7068:	9b03      	ldr	r3, [sp, #12]
    706a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    706e:	2b01      	cmp	r3, #1
    7070:	d106      	bne.n	7080 <Gpt_SetMode+0x50>
                   Gpt_Ipw_StartPredefTimer(Gpt_pConfig[coreID]);
    7072:	4a0a      	ldr	r2, [pc, #40]	; (709c <Gpt_SetMode+0x6c>)
    7074:	9b03      	ldr	r3, [sp, #12]
    7076:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    707a:	4618      	mov	r0, r3
    707c:	f000 faae 	bl	75dc <Gpt_Ipw_StartPredefTimer>
                Gpt_CheckStatusNotificationEnabled(coreID);
    7080:	9803      	ldr	r0, [sp, #12]
    7082:	f7ff fb07 	bl	6694 <Gpt_CheckStatusNotificationEnabled>
                Gpt_eMode[coreID] = GPT_MODE_NORMAL;
    7086:	4a06      	ldr	r2, [pc, #24]	; (70a0 <Gpt_SetMode+0x70>)
    7088:	9b03      	ldr	r3, [sp, #12]
    708a:	2100      	movs	r1, #0
    708c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    return;
    7090:	bf00      	nop
    7092:	bf00      	nop
}
    7094:	b005      	add	sp, #20
    7096:	f85d fb04 	ldr.w	pc, [sp], #4
    709a:	bf00      	nop
    709c:	1fff8dac 	.word	0x1fff8dac
    70a0:	1fff8da8 	.word	0x1fff8da8

000070a4 <Gpt_DisableWakeup>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_DisableWakeup_Activity
*/
void Gpt_DisableWakeup(Gpt_ChannelType channel)
{
    70a4:	b500      	push	{lr}
    70a6:	b085      	sub	sp, #20
    70a8:	4603      	mov	r3, r0
    70aa:	f88d 3007 	strb.w	r3, [sp, #7]
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    70ae:	2300      	movs	r3, #0
    70b0:	9303      	str	r3, [sp, #12]

#if (GPT_VALIDATE_PARAM == STD_ON)
        if((Std_ReturnType)E_OK == Gpt_ValidateChannelWakeup(GPT_DISABLEWAKEUP_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    70b2:	4a24      	ldr	r2, [pc, #144]	; (7144 <Gpt_DisableWakeup+0xa0>)
    70b4:	9b03      	ldr	r3, [sp, #12]
    70b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70ba:	695a      	ldr	r2, [r3, #20]
    70bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    70c0:	5cd3      	ldrb	r3, [r2, r3]
    70c2:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Set the enable wakeup attribute */
            Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = FALSE;
    70c6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    70ca:	491f      	ldr	r1, [pc, #124]	; (7148 <Gpt_DisableWakeup+0xa4>)
    70cc:	9b03      	ldr	r3, [sp, #12]
    70ce:	4413      	add	r3, r2
    70d0:	00db      	lsls	r3, r3, #3
    70d2:	440b      	add	r3, r1
    70d4:	2200      	movs	r2, #0
    70d6:	715a      	strb	r2, [r3, #5]

            /* Disable hardware interrupts if the channel is not running in the ONE-SHOT mode.
            This is needed because the channel state is updated by ISR for ONE-SHOT mode */
            if ((GPT_MODE_SLEEP == Gpt_eMode[coreID]) && \
    70d8:	4a1c      	ldr	r2, [pc, #112]	; (714c <Gpt_DisableWakeup+0xa8>)
    70da:	9b03      	ldr	r3, [sp, #12]
    70dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70e0:	2b01      	cmp	r3, #1
    70e2:	d12a      	bne.n	713a <Gpt_DisableWakeup+0x96>
                ((GPT_CH_MODE_CONTINUOUS == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    70e4:	4a17      	ldr	r2, [pc, #92]	; (7144 <Gpt_DisableWakeup+0xa0>)
    70e6:	9b03      	ldr	r3, [sp, #12]
    70e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70ec:	6859      	ldr	r1, [r3, #4]
    70ee:	f89d 200b 	ldrb.w	r2, [sp, #11]
    70f2:	4613      	mov	r3, r2
    70f4:	005b      	lsls	r3, r3, #1
    70f6:	4413      	add	r3, r2
    70f8:	00db      	lsls	r3, r3, #3
    70fa:	440b      	add	r3, r1
    70fc:	3310      	adds	r3, #16
    70fe:	681b      	ldr	r3, [r3, #0]
            if ((GPT_MODE_SLEEP == Gpt_eMode[coreID]) && \
    7100:	2b00      	cmp	r3, #0
    7102:	d008      	beq.n	7116 <Gpt_DisableWakeup+0x72>
                 || (GPT_STATUS_RUNNING != Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    7104:	f89d 2007 	ldrb.w	r2, [sp, #7]
    7108:	490f      	ldr	r1, [pc, #60]	; (7148 <Gpt_DisableWakeup+0xa4>)
    710a:	9b03      	ldr	r3, [sp, #12]
    710c:	4413      	add	r3, r2
    710e:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    7112:	2b04      	cmp	r3, #4
    7114:	d011      	beq.n	713a <Gpt_DisableWakeup+0x96>
               )
            {
                /*Disable hardware interrupts*/
                Gpt_Ipw_DisableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    7116:	4a0b      	ldr	r2, [pc, #44]	; (7144 <Gpt_DisableWakeup+0xa0>)
    7118:	9b03      	ldr	r3, [sp, #12]
    711a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    711e:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_DisableInterrupt
    7120:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    7124:	4613      	mov	r3, r2
    7126:	005b      	lsls	r3, r3, #1
    7128:	4413      	add	r3, r2
    712a:	00db      	lsls	r3, r3, #3
    712c:	440b      	add	r3, r1
    712e:	3314      	adds	r3, #20
    7130:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_DisableInterrupt
    7132:	4618      	mov	r0, r3
    7134:	f000 fa49 	bl	75ca <Gpt_Ipw_DisableInterrupt>
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
#endif /*GPT_REPORT_WAKEUP_SOURCE*/
    return;
    7138:	bf00      	nop
    713a:	bf00      	nop
}
    713c:	b005      	add	sp, #20
    713e:	f85d fb04 	ldr.w	pc, [sp], #4
    7142:	bf00      	nop
    7144:	1fff8dac 	.word	0x1fff8dac
    7148:	1fff8db0 	.word	0x1fff8db0
    714c:	1fff8da8 	.word	0x1fff8da8

00007150 <Gpt_EnableWakeup>:
*
* @pre          The driver needs to be initialized. The channel must be configured as wakeup capable.
* @implements   Gpt_EnableWakeup_Activity
*/
void Gpt_EnableWakeup(Gpt_ChannelType channel)
{
    7150:	b500      	push	{lr}
    7152:	b085      	sub	sp, #20
    7154:	4603      	mov	r3, r0
    7156:	f88d 3007 	strb.w	r3, [sp, #7]
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    715a:	2300      	movs	r3, #0
    715c:	9303      	str	r3, [sp, #12]
#endif
#if (GPT_VALIDATE_PARAM == STD_ON)
        if((Std_ReturnType)E_OK == Gpt_ValidateChannelWakeup(GPT_ENABLEWAKEUP_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    715e:	4a17      	ldr	r2, [pc, #92]	; (71bc <Gpt_EnableWakeup+0x6c>)
    7160:	9b03      	ldr	r3, [sp, #12]
    7162:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7166:	695a      	ldr	r2, [r3, #20]
    7168:	f89d 3007 	ldrb.w	r3, [sp, #7]
    716c:	5cd3      	ldrb	r3, [r2, r3]
    716e:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Functionality implementation */
            /* Set the enable wakeup attribute */
            Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = TRUE;
    7172:	f89d 2007 	ldrb.w	r2, [sp, #7]
    7176:	4912      	ldr	r1, [pc, #72]	; (71c0 <Gpt_EnableWakeup+0x70>)
    7178:	9b03      	ldr	r3, [sp, #12]
    717a:	4413      	add	r3, r2
    717c:	00db      	lsls	r3, r3, #3
    717e:	440b      	add	r3, r1
    7180:	2201      	movs	r2, #1
    7182:	715a      	strb	r2, [r3, #5]

            if (GPT_MODE_SLEEP == Gpt_eMode[coreID])
    7184:	4a0f      	ldr	r2, [pc, #60]	; (71c4 <Gpt_EnableWakeup+0x74>)
    7186:	9b03      	ldr	r3, [sp, #12]
    7188:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    718c:	2b01      	cmp	r3, #1
    718e:	d111      	bne.n	71b4 <Gpt_EnableWakeup+0x64>
            {
                /*Enable hardware interrupts*/
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    7190:	4a0a      	ldr	r2, [pc, #40]	; (71bc <Gpt_EnableWakeup+0x6c>)
    7192:	9b03      	ldr	r3, [sp, #12]
    7194:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7198:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    719a:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    719e:	4613      	mov	r3, r2
    71a0:	005b      	lsls	r3, r3, #1
    71a2:	4413      	add	r3, r2
    71a4:	00db      	lsls	r3, r3, #3
    71a6:	440b      	add	r3, r1
    71a8:	3314      	adds	r3, #20
    71aa:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    71ac:	4618      	mov	r0, r3
    71ae:	f000 f9f1 	bl	7594 <Gpt_Ipw_EnableInterrupt>
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
#endif /*GPT_REPORT_WAKEUP_SOURCE*/
    return;
    71b2:	bf00      	nop
    71b4:	bf00      	nop
}
    71b6:	b005      	add	sp, #20
    71b8:	f85d fb04 	ldr.w	pc, [sp], #4
    71bc:	1fff8dac 	.word	0x1fff8dac
    71c0:	1fff8db0 	.word	0x1fff8db0
    71c4:	1fff8da8 	.word	0x1fff8da8

000071c8 <Gpt_CheckWakeup>:
*
* @pre          The driver needs to be initialized. The channel must be configured as wakeup capable.
* @implements   Gpt_CheckWakeup_Activity
*/
void Gpt_CheckWakeup(EcuM_WakeupSourceType wakeupSource)
{
    71c8:	b500      	push	{lr}
    71ca:	b087      	sub	sp, #28
    71cc:	9001      	str	r0, [sp, #4]
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
    uint32 coreID = (uint32)Gpt_GetCoreID();
    71ce:	2300      	movs	r3, #0
    71d0:	9304      	str	r3, [sp, #16]
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    /*Validate the driver calling context*/
    if((Std_ReturnType)E_OK == Gpt_ValidateGlobalCall(GPT_CHECKWAKEUP_ID, coreID))
    {
#endif
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    71d2:	2300      	movs	r3, #0
    71d4:	f88d 3017 	strb.w	r3, [sp, #23]
    71d8:	e039      	b.n	724e <Gpt_CheckWakeup+0x86>
        {
            channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    71da:	f89d 3017 	ldrb.w	r3, [sp, #23]
    71de:	9904      	ldr	r1, [sp, #16]
    71e0:	4618      	mov	r0, r3
    71e2:	f7ff fa2f 	bl	6644 <Gpt_ConvertChannelIndexToChannel>
    71e6:	4603      	mov	r3, r0
    71e8:	f88d 300f 	strb.w	r3, [sp, #15]
            if(channel < GPT_HW_CHANNEL_NUM)
    71ec:	f89d 300f 	ldrb.w	r3, [sp, #15]
    71f0:	2b00      	cmp	r3, #0
    71f2:	d127      	bne.n	7244 <Gpt_CheckWakeup+0x7c>
            {
                if ((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_uWakeupSource) == wakeupSource) && \
    71f4:	4a1c      	ldr	r2, [pc, #112]	; (7268 <Gpt_CheckWakeup+0xa0>)
    71f6:	9b04      	ldr	r3, [sp, #16]
    71f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    71fc:	6859      	ldr	r1, [r3, #4]
    71fe:	f89d 2017 	ldrb.w	r2, [sp, #23]
    7202:	4613      	mov	r3, r2
    7204:	005b      	lsls	r3, r3, #1
    7206:	4413      	add	r3, r2
    7208:	00db      	lsls	r3, r3, #3
    720a:	440b      	add	r3, r1
    720c:	3308      	adds	r3, #8
    720e:	681b      	ldr	r3, [r3, #0]
    7210:	9a01      	ldr	r2, [sp, #4]
    7212:	429a      	cmp	r2, r3
    7214:	d116      	bne.n	7244 <Gpt_CheckWakeup+0x7c>
                    ((boolean)TRUE == Gpt_aChannelInfo[coreID][channel].bWakeupGenerated)
    7216:	f89d 200f 	ldrb.w	r2, [sp, #15]
    721a:	4914      	ldr	r1, [pc, #80]	; (726c <Gpt_CheckWakeup+0xa4>)
    721c:	9b04      	ldr	r3, [sp, #16]
    721e:	4413      	add	r3, r2
    7220:	00db      	lsls	r3, r3, #3
    7222:	440b      	add	r3, r1
    7224:	799b      	ldrb	r3, [r3, #6]
                if ((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_uWakeupSource) == wakeupSource) && \
    7226:	2b00      	cmp	r3, #0
    7228:	d00c      	beq.n	7244 <Gpt_CheckWakeup+0x7c>
                    )
                {
                    /*Reset the wakeup flag */
                    Gpt_aChannelInfo[coreID][channel].bWakeupGenerated = FALSE;
    722a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    722e:	490f      	ldr	r1, [pc, #60]	; (726c <Gpt_CheckWakeup+0xa4>)
    7230:	9b04      	ldr	r3, [sp, #16]
    7232:	4413      	add	r3, r2
    7234:	00db      	lsls	r3, r3, #3
    7236:	440b      	add	r3, r1
    7238:	2200      	movs	r2, #0
    723a:	719a      	strb	r2, [r3, #6]

                    /* Calling EcuM_SetWakeupEvent and exit*/
                    EcuM_SetWakeupEvent(wakeupSource);
    723c:	9801      	ldr	r0, [sp, #4]
    723e:	f000 fa6f 	bl	7720 <EcuM_SetWakeupEvent>

                    break;
    7242:	e00d      	b.n	7260 <Gpt_CheckWakeup+0x98>
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    7244:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7248:	3301      	adds	r3, #1
    724a:	f88d 3017 	strb.w	r3, [sp, #23]
    724e:	4a06      	ldr	r2, [pc, #24]	; (7268 <Gpt_CheckWakeup+0xa0>)
    7250:	9b04      	ldr	r3, [sp, #16]
    7252:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7256:	781b      	ldrb	r3, [r3, #0]
    7258:	f89d 2017 	ldrb.w	r2, [sp, #23]
    725c:	429a      	cmp	r2, r3
    725e:	d3bc      	bcc.n	71da <Gpt_CheckWakeup+0x12>
        }    /*for*/
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
#endif /* GPT_REPORT_WAKEUP_SOURCE */
    return;
    7260:	bf00      	nop
}
    7262:	b007      	add	sp, #28
    7264:	f85d fb04 	ldr.w	pc, [sp], #4
    7268:	1fff8dac 	.word	0x1fff8dac
    726c:	1fff8db0 	.word	0x1fff8db0

00007270 <Gpt_ProcessCommonInterrupt>:
* @return       void
* @pre          The driver needs to be initialized.
* @implements   Gpt_ProcessCommonInterrupt_Activity
*/
void Gpt_ProcessCommonInterrupt(uint8 channel)
{
    7270:	b500      	push	{lr}
    7272:	b085      	sub	sp, #20
    7274:	4603      	mov	r3, r0
    7276:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    727a:	2300      	movs	r3, #0
    727c:	9303      	str	r3, [sp, #12]

    if (Gpt_pConfig[coreID] != NULL_PTR)
    727e:	4a3b      	ldr	r2, [pc, #236]	; (736c <Gpt_ProcessCommonInterrupt+0xfc>)
    7280:	9b03      	ldr	r3, [sp, #12]
    7282:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7286:	2b00      	cmp	r3, #0
    7288:	d06b      	beq.n	7362 <Gpt_ProcessCommonInterrupt+0xf2>
    {
        /* Extract the logical channel from the hardware to logic map table */
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    728a:	4a38      	ldr	r2, [pc, #224]	; (736c <Gpt_ProcessCommonInterrupt+0xfc>)
    728c:	9b03      	ldr	r3, [sp, #12]
    728e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7292:	695a      	ldr	r2, [r3, #20]
    7294:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7298:	5cd3      	ldrb	r3, [r2, r3]
    729a:	f88d 300b 	strb.w	r3, [sp, #11]

        /* Change the channel status for one-shot mode */
        if (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    729e:	4a33      	ldr	r2, [pc, #204]	; (736c <Gpt_ProcessCommonInterrupt+0xfc>)
    72a0:	9b03      	ldr	r3, [sp, #12]
    72a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72a6:	6859      	ldr	r1, [r3, #4]
    72a8:	f89d 200b 	ldrb.w	r2, [sp, #11]
    72ac:	4613      	mov	r3, r2
    72ae:	005b      	lsls	r3, r3, #1
    72b0:	4413      	add	r3, r2
    72b2:	00db      	lsls	r3, r3, #3
    72b4:	440b      	add	r3, r1
    72b6:	3310      	adds	r3, #16
    72b8:	681b      	ldr	r3, [r3, #0]
    72ba:	2b01      	cmp	r3, #1
    72bc:	d107      	bne.n	72ce <Gpt_ProcessCommonInterrupt+0x5e>
        {
            /* Change the channel status to expired */
            Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_EXPIRED;
    72be:	f89d 2007 	ldrb.w	r2, [sp, #7]
    72c2:	492b      	ldr	r1, [pc, #172]	; (7370 <Gpt_ProcessCommonInterrupt+0x100>)
    72c4:	9b03      	ldr	r3, [sp, #12]
    72c6:	4413      	add	r3, r2
    72c8:	2203      	movs	r2, #3
    72ca:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        }
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
        if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && (TRUE == Gpt_aChannelInfo[coreID][channel].bNotificationEnabled))
    72ce:	4a29      	ldr	r2, [pc, #164]	; (7374 <Gpt_ProcessCommonInterrupt+0x104>)
    72d0:	9b03      	ldr	r3, [sp, #12]
    72d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72d6:	2b00      	cmp	r3, #0
    72d8:	d118      	bne.n	730c <Gpt_ProcessCommonInterrupt+0x9c>
    72da:	f89d 2007 	ldrb.w	r2, [sp, #7]
    72de:	4924      	ldr	r1, [pc, #144]	; (7370 <Gpt_ProcessCommonInterrupt+0x100>)
    72e0:	9b03      	ldr	r3, [sp, #12]
    72e2:	4413      	add	r3, r2
    72e4:	00db      	lsls	r3, r3, #3
    72e6:	440b      	add	r3, r1
    72e8:	791b      	ldrb	r3, [r3, #4]
    72ea:	2b00      	cmp	r3, #0
    72ec:	d00e      	beq.n	730c <Gpt_ProcessCommonInterrupt+0x9c>
        {
            (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_pfNotification();
    72ee:	4a1f      	ldr	r2, [pc, #124]	; (736c <Gpt_ProcessCommonInterrupt+0xfc>)
    72f0:	9b03      	ldr	r3, [sp, #12]
    72f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72f6:	6859      	ldr	r1, [r3, #4]
    72f8:	f89d 200b 	ldrb.w	r2, [sp, #11]
    72fc:	4613      	mov	r3, r2
    72fe:	005b      	lsls	r3, r3, #1
    7300:	4413      	add	r3, r2
    7302:	00db      	lsls	r3, r3, #3
    7304:	440b      	add	r3, r1
    7306:	3304      	adds	r3, #4
    7308:	681b      	ldr	r3, [r3, #0]
    730a:	4798      	blx	r3
        }
#endif

#if (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
        if ((GPT_MODE_SLEEP == Gpt_eMode[coreID]) && (TRUE == Gpt_aChannelInfo[coreID][channel].bWakeupEnabled))
    730c:	4a19      	ldr	r2, [pc, #100]	; (7374 <Gpt_ProcessCommonInterrupt+0x104>)
    730e:	9b03      	ldr	r3, [sp, #12]
    7310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7314:	2b01      	cmp	r3, #1
    7316:	d124      	bne.n	7362 <Gpt_ProcessCommonInterrupt+0xf2>
    7318:	f89d 2007 	ldrb.w	r2, [sp, #7]
    731c:	4914      	ldr	r1, [pc, #80]	; (7370 <Gpt_ProcessCommonInterrupt+0x100>)
    731e:	9b03      	ldr	r3, [sp, #12]
    7320:	4413      	add	r3, r2
    7322:	00db      	lsls	r3, r3, #3
    7324:	440b      	add	r3, r1
    7326:	795b      	ldrb	r3, [r3, #5]
    7328:	2b00      	cmp	r3, #0
    732a:	d01a      	beq.n	7362 <Gpt_ProcessCommonInterrupt+0xf2>
        {
            Gpt_aChannelInfo[coreID][channel].bWakeupGenerated =TRUE;
    732c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    7330:	490f      	ldr	r1, [pc, #60]	; (7370 <Gpt_ProcessCommonInterrupt+0x100>)
    7332:	9b03      	ldr	r3, [sp, #12]
    7334:	4413      	add	r3, r2
    7336:	00db      	lsls	r3, r3, #3
    7338:	440b      	add	r3, r1
    733a:	2201      	movs	r2, #1
    733c:	719a      	strb	r2, [r3, #6]
            EcuM_CheckWakeup((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_uWakeupSource);
    733e:	4a0b      	ldr	r2, [pc, #44]	; (736c <Gpt_ProcessCommonInterrupt+0xfc>)
    7340:	9b03      	ldr	r3, [sp, #12]
    7342:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7346:	6859      	ldr	r1, [r3, #4]
    7348:	f89d 200b 	ldrb.w	r2, [sp, #11]
    734c:	4613      	mov	r3, r2
    734e:	005b      	lsls	r3, r3, #1
    7350:	4413      	add	r3, r2
    7352:	00db      	lsls	r3, r3, #3
    7354:	440b      	add	r3, r1
    7356:	3308      	adds	r3, #8
    7358:	681b      	ldr	r3, [r3, #0]
    735a:	4618      	mov	r0, r3
    735c:	f000 f9ef 	bl	773e <EcuM_CheckWakeup>
        }
#endif
#endif
    }
    return;
    7360:	bf00      	nop
    7362:	bf00      	nop
}
    7364:	b005      	add	sp, #20
    7366:	f85d fb04 	ldr.w	pc, [sp], #4
    736a:	bf00      	nop
    736c:	1fff8dac 	.word	0x1fff8dac
    7370:	1fff8db0 	.word	0x1fff8db0
    7374:	1fff8da8 	.word	0x1fff8da8

00007378 <Gpt_GetPredefTimerValue>:
Std_ReturnType Gpt_GetPredefTimerValue
(
    Gpt_PredefTimerType PredefTimer,
    uint32 * TimeValuePtr
)
{
    7378:	b500      	push	{lr}
    737a:	b085      	sub	sp, #20
    737c:	9001      	str	r0, [sp, #4]
    737e:	9100      	str	r1, [sp, #0]
    Std_ReturnType returnValue;
    Gpt_ChannelType channel;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    7380:	2300      	movs	r3, #0
    7382:	9303      	str	r3, [sp, #12]
            returnValue = Gpt_ValidateParamTypePredefTimer(PredefTimer, coreID);
            if((Std_ReturnType)E_OK == returnValue)
            {
#endif

               returnValue = Gpt_ValidateMode(GPT_GET_PREDEF_TIMERVALUE_ID, coreID);
    7384:	9903      	ldr	r1, [sp, #12]
    7386:	200d      	movs	r0, #13
    7388:	f7ff f93a 	bl	6600 <Gpt_ValidateMode>
    738c:	4603      	mov	r3, r0
    738e:	f88d 300b 	strb.w	r3, [sp, #11]
               if((Std_ReturnType)E_OK ==returnValue)
    7392:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7396:	2b00      	cmp	r3, #0
    7398:	d112      	bne.n	73c0 <Gpt_GetPredefTimerValue+0x48>
               {

                        channel = (Gpt_ChannelType)PredefTimer;
    739a:	9b01      	ldr	r3, [sp, #4]
    739c:	f88d 300a 	strb.w	r3, [sp, #10]

                        Gpt_Ipw_GetPredefTimerValue((Gpt_pConfig[coreID]->Gpt_pChannelPredefConfigType)[channel], PredefTimer, TimeValuePtr);
    73a0:	4a0c      	ldr	r2, [pc, #48]	; (73d4 <Gpt_GetPredefTimerValue+0x5c>)
    73a2:	9b03      	ldr	r3, [sp, #12]
    73a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73a8:	691a      	ldr	r2, [r3, #16]
    73aa:	f89d 300a 	ldrb.w	r3, [sp, #10]
    73ae:	009b      	lsls	r3, r3, #2
    73b0:	4413      	add	r3, r2
    73b2:	681b      	ldr	r3, [r3, #0]
    73b4:	9a00      	ldr	r2, [sp, #0]
    73b6:	9901      	ldr	r1, [sp, #4]
    73b8:	4618      	mov	r0, r3
    73ba:	f000 f943 	bl	7644 <Gpt_Ipw_GetPredefTimerValue>
    73be:	e002      	b.n	73c6 <Gpt_GetPredefTimerValue+0x4e>

               }
               else
               {
                   *TimeValuePtr = 0U;
    73c0:	9b00      	ldr	r3, [sp, #0]
    73c2:	2200      	movs	r2, #0
    73c4:	601a      	str	r2, [r3, #0]
        }
#endif
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
    return returnValue;
    73c6:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    73ca:	4618      	mov	r0, r3
    73cc:	b005      	add	sp, #20
    73ce:	f85d fb04 	ldr.w	pc, [sp], #4
    73d2:	bf00      	nop
    73d4:	1fff8dac 	.word	0x1fff8dac

000073d8 <Ftm_Gpt_Ip_GetChInterruptStatusFlag>:
{
    73d8:	b082      	sub	sp, #8
    73da:	4603      	mov	r3, r0
    73dc:	460a      	mov	r2, r1
    73de:	f88d 3007 	strb.w	r3, [sp, #7]
    73e2:	4613      	mov	r3, r2
    73e4:	f88d 3006 	strb.w	r3, [sp, #6]
    return (0U != (ftmGptBase[instance]->CONTROLS[channel].CSC & FTM_CSC_CHF_MASK)) ? TRUE : FALSE;
    73e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    73ec:	4a09      	ldr	r2, [pc, #36]	; (7414 <Ftm_Gpt_Ip_GetChInterruptStatusFlag+0x3c>)
    73ee:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    73f2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    73f6:	3301      	adds	r3, #1
    73f8:	00db      	lsls	r3, r3, #3
    73fa:	4413      	add	r3, r2
    73fc:	685b      	ldr	r3, [r3, #4]
    73fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
    7402:	2b00      	cmp	r3, #0
    7404:	bf14      	ite	ne
    7406:	2301      	movne	r3, #1
    7408:	2300      	moveq	r3, #0
    740a:	b2db      	uxtb	r3, r3
}
    740c:	4618      	mov	r0, r3
    740e:	b002      	add	sp, #8
    7410:	4770      	bx	lr
    7412:	bf00      	nop
    7414:	0000b6d0 	.word	0x0000b6d0

00007418 <Ftm_Gpt_Ip_GetCntValue>:
{
    7418:	b082      	sub	sp, #8
    741a:	4603      	mov	r3, r0
    741c:	f88d 3007 	strb.w	r3, [sp, #7]
    return ftmGptBase[instance]->CNT;
    7420:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7424:	4a03      	ldr	r2, [pc, #12]	; (7434 <Ftm_Gpt_Ip_GetCntValue+0x1c>)
    7426:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    742a:	685b      	ldr	r3, [r3, #4]
}
    742c:	4618      	mov	r0, r3
    742e:	b002      	add	sp, #8
    7430:	4770      	bx	lr
    7432:	bf00      	nop
    7434:	0000b6d0 	.word	0x0000b6d0

00007438 <Ftm_Gpt_Ip_GetCompareValue>:
 *
 * @return      compare value (CV)
 *
 */
static inline uint32 Ftm_Gpt_Ip_GetCompareValue(uint8 instance, uint8 channel)
{
    7438:	b082      	sub	sp, #8
    743a:	4603      	mov	r3, r0
    743c:	460a      	mov	r2, r1
    743e:	f88d 3007 	strb.w	r3, [sp, #7]
    7442:	4613      	mov	r3, r2
    7444:	f88d 3006 	strb.w	r3, [sp, #6]
    return ftmGptBase[instance]->CONTROLS[channel].CV;
    7448:	f89d 3007 	ldrb.w	r3, [sp, #7]
    744c:	4a05      	ldr	r2, [pc, #20]	; (7464 <Ftm_Gpt_Ip_GetCompareValue+0x2c>)
    744e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    7452:	f89d 3006 	ldrb.w	r3, [sp, #6]
    7456:	3301      	adds	r3, #1
    7458:	00db      	lsls	r3, r3, #3
    745a:	4413      	add	r3, r2
    745c:	689b      	ldr	r3, [r3, #8]
}
    745e:	4618      	mov	r0, r3
    7460:	b002      	add	sp, #8
    7462:	4770      	bx	lr
    7464:	0000b6d0 	.word	0x0000b6d0

00007468 <Gpt_Ipw_InitInstances>:
*
* @return       void
* @pre          The driver needs to be initialized.
*/
void Gpt_Ipw_InitInstances(const Gpt_ConfigType * configPtr)
{
    7468:	b500      	push	{lr}
    746a:	b085      	sub	sp, #20
    746c:	9001      	str	r0, [sp, #4]

    uint8 index = 0U;
    746e:	2300      	movs	r3, #0
    7470:	f88d 300f 	strb.w	r3, [sp, #15]

    for(index = 0; index < configPtr->instanceCount; index++)
    7474:	2300      	movs	r3, #0
    7476:	f88d 300f 	strb.w	r3, [sp, #15]
    747a:	e022      	b.n	74c2 <Gpt_Ipw_InitInstances+0x5a>
    {
        switch((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instanceType)
    747c:	9b01      	ldr	r3, [sp, #4]
    747e:	68da      	ldr	r2, [r3, #12]
    7480:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7484:	011b      	lsls	r3, r3, #4
    7486:	4413      	add	r3, r2
    7488:	681b      	ldr	r3, [r3, #0]
    748a:	2b00      	cmp	r3, #0
    748c:	d113      	bne.n	74b6 <Gpt_Ipw_InitInstances+0x4e>
        {
#if (FTM_GPT_IP_USED == STD_ON)
            case(GPT_FTM_MODULE):
            {
                Ftm_Gpt_Ip_Init((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instance,
    748e:	9b01      	ldr	r3, [sp, #4]
    7490:	68da      	ldr	r2, [r3, #12]
    7492:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7496:	011b      	lsls	r3, r3, #4
    7498:	4413      	add	r3, r2
    749a:	3304      	adds	r3, #4
    749c:	7818      	ldrb	r0, [r3, #0]
                                (*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].Gpt_Ipw_InstanceConfig.Ftm_Gpt_Ip_InstanceConfig);
    749e:	9b01      	ldr	r3, [sp, #4]
    74a0:	68da      	ldr	r2, [r3, #12]
                Ftm_Gpt_Ip_Init((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instance,
    74a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74a6:	011b      	lsls	r3, r3, #4
    74a8:	4413      	add	r3, r2
    74aa:	3308      	adds	r3, #8
    74ac:	681b      	ldr	r3, [r3, #0]
    74ae:	4619      	mov	r1, r3
    74b0:	f7fe fe01 	bl	60b6 <Ftm_Gpt_Ip_Init>
            }
            break;
    74b4:	e000      	b.n	74b8 <Gpt_Ipw_InitInstances+0x50>
            break;
#endif

            default:
                /*This switch branch is empty because it shall not be executed for normal behaviour*/
            break;
    74b6:	bf00      	nop
    for(index = 0; index < configPtr->instanceCount; index++)
    74b8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    74bc:	3301      	adds	r3, #1
    74be:	f88d 300f 	strb.w	r3, [sp, #15]
    74c2:	9b01      	ldr	r3, [sp, #4]
    74c4:	7a1b      	ldrb	r3, [r3, #8]
    74c6:	f89d 200f 	ldrb.w	r2, [sp, #15]
    74ca:	429a      	cmp	r2, r3
    74cc:	d3d6      	bcc.n	747c <Gpt_Ipw_InitInstances+0x14>
        }
    }
    return;
    74ce:	bf00      	nop
}
    74d0:	b005      	add	sp, #20
    74d2:	f85d fb04 	ldr.w	pc, [sp], #4

000074d6 <Gpt_Ipw_Init>:
* @param[in]    pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return       void
* @pre          The driver needs to be initialized.
*/
void Gpt_Ipw_Init(const Gpt_Ipw_HwChannelConfigType *pHwChannelConfig)
{
    74d6:	b500      	push	{lr}
    74d8:	b083      	sub	sp, #12
    74da:	9001      	str	r0, [sp, #4]

    switch(pHwChannelConfig->instanceType)
    74dc:	9b01      	ldr	r3, [sp, #4]
    74de:	681b      	ldr	r3, [r3, #0]
    74e0:	2b00      	cmp	r3, #0
    74e2:	d108      	bne.n	74f6 <Gpt_Ipw_Init+0x20>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
            Ftm_Gpt_Ip_InitChannel(pHwChannelConfig->instance,
    74e4:	9b01      	ldr	r3, [sp, #4]
    74e6:	791a      	ldrb	r2, [r3, #4]
    74e8:	9b01      	ldr	r3, [sp, #4]
    74ea:	689b      	ldr	r3, [r3, #8]
    74ec:	4619      	mov	r1, r3
    74ee:	4610      	mov	r0, r2
    74f0:	f7fe fe22 	bl	6138 <Ftm_Gpt_Ip_InitChannel>
                                   pHwChannelConfig->Gpt_Ipw_ChannelConfig.Ftm_Gpt_Ip_ChannelConfig);
        }
        break;
    74f4:	e000      	b.n	74f8 <Gpt_Ipw_Init+0x22>
        }
            break;
#endif
        default:
            /* This switch branch is empty because it shall not be executed for normal behaviour */
        break;
    74f6:	bf00      	nop
    }
    return;
    74f8:	bf00      	nop
}
    74fa:	b003      	add	sp, #12
    74fc:	f85d fb04 	ldr.w	pc, [sp], #4

00007500 <Gpt_Ipw_StartTimer>:
* @param[in]     uValue              Timeout period (in ticks) after which a notification shall occur (if enabled).
* @return        void
* @pre           The driver needs to be initialized.Call Gpt_StartTimer before.
*/
Std_ReturnType Gpt_Ipw_StartTimer(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig, Gpt_ValueType uValue)
{
    7500:	b500      	push	{lr}
    7502:	b085      	sub	sp, #20
    7504:	9001      	str	r0, [sp, #4]
    7506:	9100      	str	r1, [sp, #0]

    Std_ReturnType returnValue = (Std_ReturnType)E_NOT_OK;
    7508:	2301      	movs	r3, #1
    750a:	f88d 300f 	strb.w	r3, [sp, #15]

    switch(pHwChannelConfig->instanceType)
    750e:	9b01      	ldr	r3, [sp, #4]
    7510:	681b      	ldr	r3, [r3, #0]
    7512:	2b00      	cmp	r3, #0
    7514:	d10c      	bne.n	7530 <Gpt_Ipw_StartTimer+0x30>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
            {
                Ftm_Gpt_Ip_StartCounting(pHwChannelConfig->instance,
    7516:	9b01      	ldr	r3, [sp, #4]
    7518:	7918      	ldrb	r0, [r3, #4]
    751a:	9b01      	ldr	r3, [sp, #4]
    751c:	795b      	ldrb	r3, [r3, #5]
    751e:	9a00      	ldr	r2, [sp, #0]
    7520:	b292      	uxth	r2, r2
    7522:	4619      	mov	r1, r3
    7524:	f7fe fe80 	bl	6228 <Ftm_Gpt_Ip_StartCounting>
                                         pHwChannelConfig->channel,
                                         (uint16)uValue);
                returnValue = (Std_ReturnType)E_OK;
    7528:	2300      	movs	r3, #0
    752a:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        break;
    752e:	e000      	b.n	7532 <Gpt_Ipw_StartTimer+0x32>
            }
            break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour */
        break;
    7530:	bf00      	nop
    }

    return returnValue;
    7532:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    7536:	4618      	mov	r0, r3
    7538:	b005      	add	sp, #20
    753a:	f85d fb04 	ldr.w	pc, [sp], #4

0000753e <Gpt_Ipw_GetTimeElapsed>:
* @pre           The driver needs to be initialized.Call GetTimeElapsed before.
*
*/
Gpt_ValueType Gpt_Ipw_GetTimeElapsed(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig,
                                                      Gpt_HwChannelInfoType * pReturnHwChannelInfo)
{
    753e:	b500      	push	{lr}
    7540:	b085      	sub	sp, #20
    7542:	9001      	str	r0, [sp, #4]
    7544:	9100      	str	r1, [sp, #0]
    uint32 returnValue;

    switch(pHwChannelConfig->instanceType)
    7546:	9b01      	ldr	r3, [sp, #4]
    7548:	681b      	ldr	r3, [r3, #0]
    754a:	2b00      	cmp	r3, #0
    754c:	d105      	bne.n	755a <Gpt_Ipw_GetTimeElapsed+0x1c>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
            returnValue = Gpt_Ipw_FtmGetTimeElapsed(pHwChannelConfig, pReturnHwChannelInfo);
    754e:	9900      	ldr	r1, [sp, #0]
    7550:	9801      	ldr	r0, [sp, #4]
    7552:	f7f9 f9df 	bl	914 <Gpt_Ipw_FtmGetTimeElapsed>
    7556:	9003      	str	r0, [sp, #12]
        }
        break;
    7558:	e002      	b.n	7560 <Gpt_Ipw_GetTimeElapsed+0x22>
        break;
#endif

        default:
             /* This switch branch is empty because it shall not be executed for normal behaviour */
             returnValue = 0U;
    755a:	2300      	movs	r3, #0
    755c:	9303      	str	r3, [sp, #12]
        break;
    755e:	bf00      	nop
    }
    return (Gpt_ValueType)returnValue;
    7560:	9b03      	ldr	r3, [sp, #12]
}
    7562:	4618      	mov	r0, r3
    7564:	b005      	add	sp, #20
    7566:	f85d fb04 	ldr.w	pc, [sp], #4

0000756a <Gpt_Ipw_StopTimer>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.Call StopTimer before.
*/
void Gpt_Ipw_StopTimer(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    756a:	b500      	push	{lr}
    756c:	b083      	sub	sp, #12
    756e:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    7570:	9b01      	ldr	r3, [sp, #4]
    7572:	681b      	ldr	r3, [r3, #0]
    7574:	2b00      	cmp	r3, #0
    7576:	d108      	bne.n	758a <Gpt_Ipw_StopTimer+0x20>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {

            Ftm_Gpt_Ip_DisableChannelInterrupt(pHwChannelConfig->instance,
    7578:	9b01      	ldr	r3, [sp, #4]
    757a:	791a      	ldrb	r2, [r3, #4]
    757c:	9b01      	ldr	r3, [sp, #4]
    757e:	795b      	ldrb	r3, [r3, #5]
    7580:	4619      	mov	r1, r3
    7582:	4610      	mov	r0, r2
    7584:	f7fe fefa 	bl	637c <Ftm_Gpt_Ip_DisableChannelInterrupt>
                                               pHwChannelConfig->channel);
        }
        break;
    7588:	e000      	b.n	758c <Gpt_Ipw_StopTimer+0x22>
        }
            break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    758a:	bf00      	nop
    }

    return;
    758c:	bf00      	nop
}
    758e:	b003      	add	sp, #12
    7590:	f85d fb04 	ldr.w	pc, [sp], #4

00007594 <Gpt_Ipw_EnableInterrupt>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.
*/
void Gpt_Ipw_EnableInterrupt(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    7594:	b082      	sub	sp, #8
    7596:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    7598:	9b01      	ldr	r3, [sp, #4]
    759a:	681b      	ldr	r3, [r3, #0]
    759c:	2b00      	cmp	r3, #0
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    759e:	bf00      	nop
    }

    return;
    75a0:	bf00      	nop
}
    75a2:	b002      	add	sp, #8
    75a4:	4770      	bx	lr

000075a6 <Gpt_Ipw_DeInit>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized. On/Off by the configuration parameter: GPT_DEINIT_API
*/
void Gpt_Ipw_DeInit(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    75a6:	b500      	push	{lr}
    75a8:	b083      	sub	sp, #12
    75aa:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    75ac:	9b01      	ldr	r3, [sp, #4]
    75ae:	681b      	ldr	r3, [r3, #0]
    75b0:	2b00      	cmp	r3, #0
    75b2:	d105      	bne.n	75c0 <Gpt_Ipw_DeInit+0x1a>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
           Ftm_Gpt_Ip_Deinit(pHwChannelConfig->instance);
    75b4:	9b01      	ldr	r3, [sp, #4]
    75b6:	791b      	ldrb	r3, [r3, #4]
    75b8:	4618      	mov	r0, r3
    75ba:	f7fe fde8 	bl	618e <Ftm_Gpt_Ip_Deinit>
        }
        break;
    75be:	e000      	b.n	75c2 <Gpt_Ipw_DeInit+0x1c>
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    75c0:	bf00      	nop
    }
    return;
    75c2:	bf00      	nop
}
    75c4:	b003      	add	sp, #12
    75c6:	f85d fb04 	ldr.w	pc, [sp], #4

000075ca <Gpt_Ipw_DisableInterrupt>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.On/Off by the configuration parameter: GPT_ENABLE_DISABLE_NOTIFICATION_API
*/
void Gpt_Ipw_DisableInterrupt(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    75ca:	b082      	sub	sp, #8
    75cc:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    75ce:	9b01      	ldr	r3, [sp, #4]
    75d0:	681b      	ldr	r3, [r3, #0]
    75d2:	2b00      	cmp	r3, #0
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    75d4:	bf00      	nop
    }

    return;
    75d6:	bf00      	nop
}
    75d8:	b002      	add	sp, #8
    75da:	4770      	bx	lr

000075dc <Gpt_Ipw_StartPredefTimer>:

void Gpt_Ipw_StartPredefTimer
(
    const Gpt_ConfigType * configPtr
)
{
    75dc:	b510      	push	{r4, lr}
    75de:	b086      	sub	sp, #24
    75e0:	9003      	str	r0, [sp, #12]
    Gpt_ChannelType channel;
    const Gpt_HwPredefChannelConfigType * pHwChannelConfig;

    for(channel = 0U; channel < GPT_HW_PREDEFTIMER_NUM; channel++)
    75e2:	2300      	movs	r3, #0
    75e4:	f88d 3017 	strb.w	r3, [sp, #23]
    75e8:	e025      	b.n	7636 <Gpt_Ipw_StartPredefTimer+0x5a>
    {
        pHwChannelConfig = (configPtr->Gpt_pChannelPredefConfigType)[channel];
    75ea:	9b03      	ldr	r3, [sp, #12]
    75ec:	691a      	ldr	r2, [r3, #16]
    75ee:	f89d 3017 	ldrb.w	r3, [sp, #23]
    75f2:	009b      	lsls	r3, r3, #2
    75f4:	4413      	add	r3, r2
    75f6:	681b      	ldr	r3, [r3, #0]
    75f8:	9304      	str	r3, [sp, #16]

        if(NULL_PTR != pHwChannelConfig)
    75fa:	9b04      	ldr	r3, [sp, #16]
    75fc:	2b00      	cmp	r3, #0
    75fe:	d012      	beq.n	7626 <Gpt_Ipw_StartPredefTimer+0x4a>
        {
            switch(pHwChannelConfig->instanceType)
    7600:	9b04      	ldr	r3, [sp, #16]
    7602:	681b      	ldr	r3, [r3, #0]
    7604:	2b00      	cmp	r3, #0
    7606:	d110      	bne.n	762a <Gpt_Ipw_StartPredefTimer+0x4e>
            {
#if (FTM_GPT_IP_USED == STD_ON)
            case GPT_FTM_MODULE:
            {
                Ftm_Gpt_Ip_StartPredefTimer(pHwChannelConfig->instance, \
    7608:	9b04      	ldr	r3, [sp, #16]
    760a:	7918      	ldrb	r0, [r3, #4]
    760c:	9b04      	ldr	r3, [sp, #16]
    760e:	7959      	ldrb	r1, [r3, #5]
    7610:	9b04      	ldr	r3, [sp, #16]
    7612:	7a1a      	ldrb	r2, [r3, #8]
    7614:	9b04      	ldr	r3, [sp, #16]
    7616:	799c      	ldrb	r4, [r3, #6]
    7618:	9b04      	ldr	r3, [sp, #16]
    761a:	79db      	ldrb	r3, [r3, #7]
    761c:	9300      	str	r3, [sp, #0]
    761e:	4623      	mov	r3, r4
    7620:	f7fe fee4 	bl	63ec <Ftm_Gpt_Ip_StartPredefTimer>
                                            pHwChannelConfig->channel, \
                                            pHwChannelConfig->Gpt_uPrescaler, \
                                            pHwChannelConfig->Gpt_uClockSource, \
                                            pHwChannelConfig->Gpt_bFreezeEnable);
            }
            break;
    7624:	e002      	b.n	762c <Gpt_Ipw_StartPredefTimer+0x50>
#endif
            default:
                /*This switch branch is empty because it shall not be executed for normal behaviour*/
            break;
            }
        }
    7626:	bf00      	nop
    7628:	e000      	b.n	762c <Gpt_Ipw_StartPredefTimer+0x50>
            break;
    762a:	bf00      	nop
    for(channel = 0U; channel < GPT_HW_PREDEFTIMER_NUM; channel++)
    762c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    7630:	3301      	adds	r3, #1
    7632:	f88d 3017 	strb.w	r3, [sp, #23]
    7636:	f89d 3017 	ldrb.w	r3, [sp, #23]
    763a:	2b03      	cmp	r3, #3
    763c:	d9d5      	bls.n	75ea <Gpt_Ipw_StartPredefTimer+0xe>
    }

    return;
    763e:	bf00      	nop
}
    7640:	b006      	add	sp, #24
    7642:	bd10      	pop	{r4, pc}

00007644 <Gpt_Ipw_GetPredefTimerValue>:
(
    const Gpt_HwPredefChannelConfigType * pHwChannelConfig,
    Gpt_PredefTimerType PredefTimer,
    uint32 * TimeValuePtr
)
{
    7644:	b500      	push	{lr}
    7646:	b087      	sub	sp, #28
    7648:	9003      	str	r0, [sp, #12]
    764a:	9102      	str	r1, [sp, #8]
    764c:	9201      	str	r2, [sp, #4]
    uint32 u32ReturnValue = 0U;
    764e:	2300      	movs	r3, #0
    7650:	9305      	str	r3, [sp, #20]
    switch(pHwChannelConfig->instanceType)
    7652:	9b03      	ldr	r3, [sp, #12]
    7654:	681b      	ldr	r3, [r3, #0]
    7656:	2b00      	cmp	r3, #0
    7658:	d106      	bne.n	7668 <Gpt_Ipw_GetPredefTimerValue+0x24>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case GPT_FTM_MODULE:
        {
            u32ReturnValue = Ftm_Gpt_Ip_GetCntValue(pHwChannelConfig->instance);
    765a:	9b03      	ldr	r3, [sp, #12]
    765c:	791b      	ldrb	r3, [r3, #4]
    765e:	4618      	mov	r0, r3
    7660:	f7ff feda 	bl	7418 <Ftm_Gpt_Ip_GetCntValue>
    7664:	9005      	str	r0, [sp, #20]
        }
        break;
    7666:	e000      	b.n	766a <Gpt_Ipw_GetPredefTimerValue+0x26>
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    7668:	bf00      	nop
    }
    if(0U != u32ReturnValue)
    766a:	9b05      	ldr	r3, [sp, #20]
    766c:	2b00      	cmp	r3, #0
    766e:	d020      	beq.n	76b2 <Gpt_Ipw_GetPredefTimerValue+0x6e>
    7670:	9b02      	ldr	r3, [sp, #8]
    7672:	2b03      	cmp	r3, #3
    7674:	d81f      	bhi.n	76b6 <Gpt_Ipw_GetPredefTimerValue+0x72>
    7676:	a201      	add	r2, pc, #4	; (adr r2, 767c <Gpt_Ipw_GetPredefTimerValue+0x38>)
    7678:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    767c:	0000768d 	.word	0x0000768d
    7680:	00007697 	.word	0x00007697
    7684:	000076a3 	.word	0x000076a3
    7688:	000076ab 	.word	0x000076ab
    {
        switch(PredefTimer)
        {
            case GPT_PREDEF_TIMER_1US_16BIT:
                *TimeValuePtr = (0x0000FFFFU & u32ReturnValue);
    768c:	9b05      	ldr	r3, [sp, #20]
    768e:	b29a      	uxth	r2, r3
    7690:	9b01      	ldr	r3, [sp, #4]
    7692:	601a      	str	r2, [r3, #0]
            break;
    7694:	e010      	b.n	76b8 <Gpt_Ipw_GetPredefTimerValue+0x74>
            case GPT_PREDEF_TIMER_1US_24BIT:
                *TimeValuePtr = (0x00FFFFFFU & u32ReturnValue);
    7696:	9b05      	ldr	r3, [sp, #20]
    7698:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    769c:	9b01      	ldr	r3, [sp, #4]
    769e:	601a      	str	r2, [r3, #0]
            break;
    76a0:	e00a      	b.n	76b8 <Gpt_Ipw_GetPredefTimerValue+0x74>
            case GPT_PREDEF_TIMER_1US_32BIT:
                *TimeValuePtr = u32ReturnValue;
    76a2:	9b01      	ldr	r3, [sp, #4]
    76a4:	9a05      	ldr	r2, [sp, #20]
    76a6:	601a      	str	r2, [r3, #0]
            break;
    76a8:	e006      	b.n	76b8 <Gpt_Ipw_GetPredefTimerValue+0x74>
            case GPT_PREDEF_TIMER_100US_32BIT:
                *TimeValuePtr = u32ReturnValue;
    76aa:	9b01      	ldr	r3, [sp, #4]
    76ac:	9a05      	ldr	r2, [sp, #20]
    76ae:	601a      	str	r2, [r3, #0]
            break;
    76b0:	e002      	b.n	76b8 <Gpt_Ipw_GetPredefTimerValue+0x74>
            default:
                /* 32bit timer */
            break;
        }
    }
    76b2:	bf00      	nop
    76b4:	e000      	b.n	76b8 <Gpt_Ipw_GetPredefTimerValue+0x74>
            break;
    76b6:	bf00      	nop
    return;
    76b8:	bf00      	nop
}
    76ba:	b007      	add	sp, #28
    76bc:	f85d fb04 	ldr.w	pc, [sp], #4

000076c0 <Gpt_Ipw_StopPredefTimer>:
*/
void Gpt_Ipw_StopPredefTimer
(
    const Gpt_ConfigType * configPtr
)
{
    76c0:	b500      	push	{lr}
    76c2:	b085      	sub	sp, #20
    76c4:	9001      	str	r0, [sp, #4]
    Gpt_ChannelType channel;
    const Gpt_HwPredefChannelConfigType * pHwChannelConfig;

    for(channel = 0U; channel < GPT_HW_PREDEFTIMER_NUM; channel++)
    76c6:	2300      	movs	r3, #0
    76c8:	f88d 300f 	strb.w	r3, [sp, #15]
    76cc:	e01f      	b.n	770e <Gpt_Ipw_StopPredefTimer+0x4e>
    {

        pHwChannelConfig = (configPtr->Gpt_pChannelPredefConfigType)[channel];
    76ce:	9b01      	ldr	r3, [sp, #4]
    76d0:	691a      	ldr	r2, [r3, #16]
    76d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    76d6:	009b      	lsls	r3, r3, #2
    76d8:	4413      	add	r3, r2
    76da:	681b      	ldr	r3, [r3, #0]
    76dc:	9302      	str	r3, [sp, #8]
        if(NULL_PTR != pHwChannelConfig)
    76de:	9b02      	ldr	r3, [sp, #8]
    76e0:	2b00      	cmp	r3, #0
    76e2:	d00c      	beq.n	76fe <Gpt_Ipw_StopPredefTimer+0x3e>
        {
            switch(pHwChannelConfig->instanceType)
    76e4:	9b02      	ldr	r3, [sp, #8]
    76e6:	681b      	ldr	r3, [r3, #0]
    76e8:	2b00      	cmp	r3, #0
    76ea:	d10a      	bne.n	7702 <Gpt_Ipw_StopPredefTimer+0x42>
            {
#if (FTM_GPT_IP_USED == STD_ON)
            case GPT_FTM_MODULE:
            {
                Ftm_Gpt_Ip_StopPredefTimer(pHwChannelConfig->instance, \
    76ec:	9b02      	ldr	r3, [sp, #8]
    76ee:	791a      	ldrb	r2, [r3, #4]
    76f0:	9b02      	ldr	r3, [sp, #8]
    76f2:	795b      	ldrb	r3, [r3, #5]
    76f4:	4619      	mov	r1, r3
    76f6:	4610      	mov	r0, r2
    76f8:	f7fe ff0a 	bl	6510 <Ftm_Gpt_Ip_StopPredefTimer>
                                           pHwChannelConfig->channel);
            }
            break;
    76fc:	e002      	b.n	7704 <Gpt_Ipw_StopPredefTimer+0x44>
#endif
            default:
                /*This switch branch is empty because it shall not be executed for normal behaviour*/
            break;
            }
        }
    76fe:	bf00      	nop
    7700:	e000      	b.n	7704 <Gpt_Ipw_StopPredefTimer+0x44>
            break;
    7702:	bf00      	nop
    for(channel = 0U; channel < GPT_HW_PREDEFTIMER_NUM; channel++)
    7704:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7708:	3301      	adds	r3, #1
    770a:	f88d 300f 	strb.w	r3, [sp, #15]
    770e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7712:	2b03      	cmp	r3, #3
    7714:	d9db      	bls.n	76ce <Gpt_Ipw_StopPredefTimer+0xe>
    }
    return;
    7716:	bf00      	nop
}
    7718:	b005      	add	sp, #20
    771a:	f85d fb04 	ldr.w	pc, [sp], #4
    771e:	bf00      	nop

00007720 <EcuM_SetWakeupEvent>:
* 
* @param[in]     events  last wakeup event
* 
*/
void EcuM_SetWakeupEvent(EcuM_WakeupSourceType events)
{
    7720:	b082      	sub	sp, #8
    7722:	9001      	str	r0, [sp, #4]
    EcuMLastWakeupEvent = events;
    7724:	4a02      	ldr	r2, [pc, #8]	; (7730 <EcuM_SetWakeupEvent+0x10>)
    7726:	9b01      	ldr	r3, [sp, #4]
    7728:	6013      	str	r3, [r2, #0]
}
    772a:	bf00      	nop
    772c:	b002      	add	sp, #8
    772e:	4770      	bx	lr
    7730:	1fff8dbc 	.word	0x1fff8dbc

00007734 <EcuM_ValidateWakeupEvent>:
* @details This is a function stub only. Functionality is void in this implementation
* 
* @param[in]     events wakeup event to validate
*/
void EcuM_ValidateWakeupEvent(EcuM_WakeupSourceType events)
{
    7734:	b082      	sub	sp, #8
    7736:	9001      	str	r0, [sp, #4]
    (void)events;
}
    7738:	bf00      	nop
    773a:	b002      	add	sp, #8
    773c:	4770      	bx	lr

0000773e <EcuM_CheckWakeup>:
* 
* @param[in]     wakeupSource  wakeup source ID
* 
*/
void EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource)
{
    773e:	b082      	sub	sp, #8
    7740:	9001      	str	r0, [sp, #4]
#endif
#ifdef TEST_ICU
    Icu_CheckWakeup(wakeupSource);
#endif
    (void)wakeupSource;
}
    7742:	bf00      	nop
    7744:	b002      	add	sp, #8
    7746:	4770      	bx	lr

00007748 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    7748:	b500      	push	{lr}
    774a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    774c:	f7f9 fa2e 	bl	bac <Sys_GetCoreID>
    7750:	4603      	mov	r3, r0
    7752:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId])
    7754:	4a10      	ldr	r2, [pc, #64]	; (7798 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    7756:	9b01      	ldr	r3, [sp, #4]
    7758:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    775c:	2b00      	cmp	r3, #0
    775e:	d10d      	bne.n	777c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7760:	f7f9 f93a 	bl	9d8 <Dio_schm_read_msr>
    7764:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7766:	9b00      	ldr	r3, [sp, #0]
    7768:	f003 0301 	and.w	r3, r3, #1
    776c:	2b00      	cmp	r3, #0
    776e:	d100      	bne.n	7772 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7770:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    7772:	490a      	ldr	r1, [pc, #40]	; (779c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x54>)
    7774:	9b01      	ldr	r3, [sp, #4]
    7776:	9a00      	ldr	r2, [sp, #0]
    7778:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]++;
    777c:	4a06      	ldr	r2, [pc, #24]	; (7798 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    777e:	9b01      	ldr	r3, [sp, #4]
    7780:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7784:	1c5a      	adds	r2, r3, #1
    7786:	4904      	ldr	r1, [pc, #16]	; (7798 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    7788:	9b01      	ldr	r3, [sp, #4]
    778a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    778e:	bf00      	nop
    7790:	b003      	add	sp, #12
    7792:	f85d fb04 	ldr.w	pc, [sp], #4
    7796:	bf00      	nop
    7798:	1fff8dc4 	.word	0x1fff8dc4
    779c:	1fff8dc0 	.word	0x1fff8dc0

000077a0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    77a0:	b500      	push	{lr}
    77a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    77a4:	f7f9 fa02 	bl	bac <Sys_GetCoreID>
    77a8:	4603      	mov	r3, r0
    77aa:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]--;
    77ac:	4a0d      	ldr	r2, [pc, #52]	; (77e4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    77ae:	9b01      	ldr	r3, [sp, #4]
    77b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77b4:	1e5a      	subs	r2, r3, #1
    77b6:	490b      	ldr	r1, [pc, #44]	; (77e4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    77b8:	9b01      	ldr	r3, [sp, #4]
    77ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    77be:	4a0a      	ldr	r2, [pc, #40]	; (77e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x48>)
    77c0:	9b01      	ldr	r3, [sp, #4]
    77c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77c6:	f003 0301 	and.w	r3, r3, #1
    77ca:	2b00      	cmp	r3, #0
    77cc:	d106      	bne.n	77dc <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    77ce:	4a05      	ldr	r2, [pc, #20]	; (77e4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    77d0:	9b01      	ldr	r3, [sp, #4]
    77d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77d6:	2b00      	cmp	r3, #0
    77d8:	d100      	bne.n	77dc <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    77da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    77dc:	bf00      	nop
    77de:	b003      	add	sp, #12
    77e0:	f85d fb04 	ldr.w	pc, [sp], #4
    77e4:	1fff8dc4 	.word	0x1fff8dc4
    77e8:	1fff8dc0 	.word	0x1fff8dc0

000077ec <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    77ec:	b500      	push	{lr}
    77ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    77f0:	f7f9 f9dc 	bl	bac <Sys_GetCoreID>
    77f4:	4603      	mov	r3, r0
    77f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId])
    77f8:	4a10      	ldr	r2, [pc, #64]	; (783c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    77fa:	9b01      	ldr	r3, [sp, #4]
    77fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7800:	2b00      	cmp	r3, #0
    7802:	d10d      	bne.n	7820 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7804:	f7f9 f8e8 	bl	9d8 <Dio_schm_read_msr>
    7808:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    780a:	9b00      	ldr	r3, [sp, #0]
    780c:	f003 0301 	and.w	r3, r3, #1
    7810:	2b00      	cmp	r3, #0
    7812:	d100      	bne.n	7816 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7814:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    7816:	490a      	ldr	r1, [pc, #40]	; (7840 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x54>)
    7818:	9b01      	ldr	r3, [sp, #4]
    781a:	9a00      	ldr	r2, [sp, #0]
    781c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]++;
    7820:	4a06      	ldr	r2, [pc, #24]	; (783c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    7822:	9b01      	ldr	r3, [sp, #4]
    7824:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7828:	1c5a      	adds	r2, r3, #1
    782a:	4904      	ldr	r1, [pc, #16]	; (783c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    782c:	9b01      	ldr	r3, [sp, #4]
    782e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7832:	bf00      	nop
    7834:	b003      	add	sp, #12
    7836:	f85d fb04 	ldr.w	pc, [sp], #4
    783a:	bf00      	nop
    783c:	1fff8dcc 	.word	0x1fff8dcc
    7840:	1fff8dc8 	.word	0x1fff8dc8

00007844 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    7844:	b500      	push	{lr}
    7846:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7848:	f7f9 f9b0 	bl	bac <Sys_GetCoreID>
    784c:	4603      	mov	r3, r0
    784e:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]--;
    7850:	4a0d      	ldr	r2, [pc, #52]	; (7888 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    7852:	9b01      	ldr	r3, [sp, #4]
    7854:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7858:	1e5a      	subs	r2, r3, #1
    785a:	490b      	ldr	r1, [pc, #44]	; (7888 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    785c:	9b01      	ldr	r3, [sp, #4]
    785e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    7862:	4a0a      	ldr	r2, [pc, #40]	; (788c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x48>)
    7864:	9b01      	ldr	r3, [sp, #4]
    7866:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    786a:	f003 0301 	and.w	r3, r3, #1
    786e:	2b00      	cmp	r3, #0
    7870:	d106      	bne.n	7880 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    7872:	4a05      	ldr	r2, [pc, #20]	; (7888 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    7874:	9b01      	ldr	r3, [sp, #4]
    7876:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    787a:	2b00      	cmp	r3, #0
    787c:	d100      	bne.n	7880 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    787e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7880:	bf00      	nop
    7882:	b003      	add	sp, #12
    7884:	f85d fb04 	ldr.w	pc, [sp], #4
    7888:	1fff8dcc 	.word	0x1fff8dcc
    788c:	1fff8dc8 	.word	0x1fff8dc8

00007890 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00(void)
{
    7890:	b500      	push	{lr}
    7892:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7894:	f7f9 f98a 	bl	bac <Sys_GetCoreID>
    7898:	4603      	mov	r3, r0
    789a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId])
    789c:	4a10      	ldr	r2, [pc, #64]	; (78e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    789e:	9b01      	ldr	r3, [sp, #4]
    78a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78a4:	2b00      	cmp	r3, #0
    78a6:	d10d      	bne.n	78c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    78a8:	f7f9 f89f 	bl	9ea <Gpt_schm_read_msr>
    78ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    78ae:	9b00      	ldr	r3, [sp, #0]
    78b0:	f003 0301 	and.w	r3, r3, #1
    78b4:	2b00      	cmp	r3, #0
    78b6:	d100      	bne.n	78ba <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    78b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    78ba:	490a      	ldr	r1, [pc, #40]	; (78e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x54>)
    78bc:	9b01      	ldr	r3, [sp, #4]
    78be:	9a00      	ldr	r2, [sp, #0]
    78c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]++;
    78c4:	4a06      	ldr	r2, [pc, #24]	; (78e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    78c6:	9b01      	ldr	r3, [sp, #4]
    78c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78cc:	1c5a      	adds	r2, r3, #1
    78ce:	4904      	ldr	r1, [pc, #16]	; (78e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    78d0:	9b01      	ldr	r3, [sp, #4]
    78d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    78d6:	bf00      	nop
    78d8:	b003      	add	sp, #12
    78da:	f85d fb04 	ldr.w	pc, [sp], #4
    78de:	bf00      	nop
    78e0:	1fff8dd4 	.word	0x1fff8dd4
    78e4:	1fff8dd0 	.word	0x1fff8dd0

000078e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00(void)
{
    78e8:	b500      	push	{lr}
    78ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    78ec:	f7f9 f95e 	bl	bac <Sys_GetCoreID>
    78f0:	4603      	mov	r3, r0
    78f2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]--;
    78f4:	4a0d      	ldr	r2, [pc, #52]	; (792c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    78f6:	9b01      	ldr	r3, [sp, #4]
    78f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78fc:	1e5a      	subs	r2, r3, #1
    78fe:	490b      	ldr	r1, [pc, #44]	; (792c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    7900:	9b01      	ldr	r3, [sp, #4]
    7902:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    7906:	4a0a      	ldr	r2, [pc, #40]	; (7930 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x48>)
    7908:	9b01      	ldr	r3, [sp, #4]
    790a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    790e:	f003 0301 	and.w	r3, r3, #1
    7912:	2b00      	cmp	r3, #0
    7914:	d106      	bne.n	7924 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x3c>
    7916:	4a05      	ldr	r2, [pc, #20]	; (792c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    7918:	9b01      	ldr	r3, [sp, #4]
    791a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    791e:	2b00      	cmp	r3, #0
    7920:	d100      	bne.n	7924 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7922:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7924:	bf00      	nop
    7926:	b003      	add	sp, #12
    7928:	f85d fb04 	ldr.w	pc, [sp], #4
    792c:	1fff8dd4 	.word	0x1fff8dd4
    7930:	1fff8dd0 	.word	0x1fff8dd0

00007934 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01(void)
{
    7934:	b500      	push	{lr}
    7936:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7938:	f7f9 f938 	bl	bac <Sys_GetCoreID>
    793c:	4603      	mov	r3, r0
    793e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId])
    7940:	4a10      	ldr	r2, [pc, #64]	; (7984 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    7942:	9b01      	ldr	r3, [sp, #4]
    7944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7948:	2b00      	cmp	r3, #0
    794a:	d10d      	bne.n	7968 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    794c:	f7f9 f84d 	bl	9ea <Gpt_schm_read_msr>
    7950:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7952:	9b00      	ldr	r3, [sp, #0]
    7954:	f003 0301 	and.w	r3, r3, #1
    7958:	2b00      	cmp	r3, #0
    795a:	d100      	bne.n	795e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    795c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    795e:	490a      	ldr	r1, [pc, #40]	; (7988 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x54>)
    7960:	9b01      	ldr	r3, [sp, #4]
    7962:	9a00      	ldr	r2, [sp, #0]
    7964:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]++;
    7968:	4a06      	ldr	r2, [pc, #24]	; (7984 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    796a:	9b01      	ldr	r3, [sp, #4]
    796c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7970:	1c5a      	adds	r2, r3, #1
    7972:	4904      	ldr	r1, [pc, #16]	; (7984 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    7974:	9b01      	ldr	r3, [sp, #4]
    7976:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    797a:	bf00      	nop
    797c:	b003      	add	sp, #12
    797e:	f85d fb04 	ldr.w	pc, [sp], #4
    7982:	bf00      	nop
    7984:	1fff8ddc 	.word	0x1fff8ddc
    7988:	1fff8dd8 	.word	0x1fff8dd8

0000798c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01(void)
{
    798c:	b500      	push	{lr}
    798e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7990:	f7f9 f90c 	bl	bac <Sys_GetCoreID>
    7994:	4603      	mov	r3, r0
    7996:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]--;
    7998:	4a0d      	ldr	r2, [pc, #52]	; (79d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    799a:	9b01      	ldr	r3, [sp, #4]
    799c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79a0:	1e5a      	subs	r2, r3, #1
    79a2:	490b      	ldr	r1, [pc, #44]	; (79d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    79a4:	9b01      	ldr	r3, [sp, #4]
    79a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    79aa:	4a0a      	ldr	r2, [pc, #40]	; (79d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x48>)
    79ac:	9b01      	ldr	r3, [sp, #4]
    79ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79b2:	f003 0301 	and.w	r3, r3, #1
    79b6:	2b00      	cmp	r3, #0
    79b8:	d106      	bne.n	79c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x3c>
    79ba:	4a05      	ldr	r2, [pc, #20]	; (79d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    79bc:	9b01      	ldr	r3, [sp, #4]
    79be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79c2:	2b00      	cmp	r3, #0
    79c4:	d100      	bne.n	79c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    79c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    79c8:	bf00      	nop
    79ca:	b003      	add	sp, #12
    79cc:	f85d fb04 	ldr.w	pc, [sp], #4
    79d0:	1fff8ddc 	.word	0x1fff8ddc
    79d4:	1fff8dd8 	.word	0x1fff8dd8

000079d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02(void)
{
    79d8:	b500      	push	{lr}
    79da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    79dc:	f7f9 f8e6 	bl	bac <Sys_GetCoreID>
    79e0:	4603      	mov	r3, r0
    79e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId])
    79e4:	4a10      	ldr	r2, [pc, #64]	; (7a28 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    79e6:	9b01      	ldr	r3, [sp, #4]
    79e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79ec:	2b00      	cmp	r3, #0
    79ee:	d10d      	bne.n	7a0c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    79f0:	f7f8 fffb 	bl	9ea <Gpt_schm_read_msr>
    79f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    79f6:	9b00      	ldr	r3, [sp, #0]
    79f8:	f003 0301 	and.w	r3, r3, #1
    79fc:	2b00      	cmp	r3, #0
    79fe:	d100      	bne.n	7a02 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7a00:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    7a02:	490a      	ldr	r1, [pc, #40]	; (7a2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x54>)
    7a04:	9b01      	ldr	r3, [sp, #4]
    7a06:	9a00      	ldr	r2, [sp, #0]
    7a08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]++;
    7a0c:	4a06      	ldr	r2, [pc, #24]	; (7a28 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    7a0e:	9b01      	ldr	r3, [sp, #4]
    7a10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a14:	1c5a      	adds	r2, r3, #1
    7a16:	4904      	ldr	r1, [pc, #16]	; (7a28 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    7a18:	9b01      	ldr	r3, [sp, #4]
    7a1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7a1e:	bf00      	nop
    7a20:	b003      	add	sp, #12
    7a22:	f85d fb04 	ldr.w	pc, [sp], #4
    7a26:	bf00      	nop
    7a28:	1fff8de4 	.word	0x1fff8de4
    7a2c:	1fff8de0 	.word	0x1fff8de0

00007a30 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02(void)
{
    7a30:	b500      	push	{lr}
    7a32:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a34:	f7f9 f8ba 	bl	bac <Sys_GetCoreID>
    7a38:	4603      	mov	r3, r0
    7a3a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]--;
    7a3c:	4a0d      	ldr	r2, [pc, #52]	; (7a74 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    7a3e:	9b01      	ldr	r3, [sp, #4]
    7a40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a44:	1e5a      	subs	r2, r3, #1
    7a46:	490b      	ldr	r1, [pc, #44]	; (7a74 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    7a48:	9b01      	ldr	r3, [sp, #4]
    7a4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    7a4e:	4a0a      	ldr	r2, [pc, #40]	; (7a78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x48>)
    7a50:	9b01      	ldr	r3, [sp, #4]
    7a52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a56:	f003 0301 	and.w	r3, r3, #1
    7a5a:	2b00      	cmp	r3, #0
    7a5c:	d106      	bne.n	7a6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x3c>
    7a5e:	4a05      	ldr	r2, [pc, #20]	; (7a74 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    7a60:	9b01      	ldr	r3, [sp, #4]
    7a62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a66:	2b00      	cmp	r3, #0
    7a68:	d100      	bne.n	7a6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7a6a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7a6c:	bf00      	nop
    7a6e:	b003      	add	sp, #12
    7a70:	f85d fb04 	ldr.w	pc, [sp], #4
    7a74:	1fff8de4 	.word	0x1fff8de4
    7a78:	1fff8de0 	.word	0x1fff8de0

00007a7c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03(void)
{
    7a7c:	b500      	push	{lr}
    7a7e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a80:	f7f9 f894 	bl	bac <Sys_GetCoreID>
    7a84:	4603      	mov	r3, r0
    7a86:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId])
    7a88:	4a10      	ldr	r2, [pc, #64]	; (7acc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    7a8a:	9b01      	ldr	r3, [sp, #4]
    7a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a90:	2b00      	cmp	r3, #0
    7a92:	d10d      	bne.n	7ab0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7a94:	f7f8 ffa9 	bl	9ea <Gpt_schm_read_msr>
    7a98:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7a9a:	9b00      	ldr	r3, [sp, #0]
    7a9c:	f003 0301 	and.w	r3, r3, #1
    7aa0:	2b00      	cmp	r3, #0
    7aa2:	d100      	bne.n	7aa6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7aa4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    7aa6:	490a      	ldr	r1, [pc, #40]	; (7ad0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x54>)
    7aa8:	9b01      	ldr	r3, [sp, #4]
    7aaa:	9a00      	ldr	r2, [sp, #0]
    7aac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]++;
    7ab0:	4a06      	ldr	r2, [pc, #24]	; (7acc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    7ab2:	9b01      	ldr	r3, [sp, #4]
    7ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ab8:	1c5a      	adds	r2, r3, #1
    7aba:	4904      	ldr	r1, [pc, #16]	; (7acc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    7abc:	9b01      	ldr	r3, [sp, #4]
    7abe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7ac2:	bf00      	nop
    7ac4:	b003      	add	sp, #12
    7ac6:	f85d fb04 	ldr.w	pc, [sp], #4
    7aca:	bf00      	nop
    7acc:	1fff8dec 	.word	0x1fff8dec
    7ad0:	1fff8de8 	.word	0x1fff8de8

00007ad4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03(void)
{
    7ad4:	b500      	push	{lr}
    7ad6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ad8:	f7f9 f868 	bl	bac <Sys_GetCoreID>
    7adc:	4603      	mov	r3, r0
    7ade:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]--;
    7ae0:	4a0d      	ldr	r2, [pc, #52]	; (7b18 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    7ae2:	9b01      	ldr	r3, [sp, #4]
    7ae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ae8:	1e5a      	subs	r2, r3, #1
    7aea:	490b      	ldr	r1, [pc, #44]	; (7b18 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    7aec:	9b01      	ldr	r3, [sp, #4]
    7aee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    7af2:	4a0a      	ldr	r2, [pc, #40]	; (7b1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x48>)
    7af4:	9b01      	ldr	r3, [sp, #4]
    7af6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7afa:	f003 0301 	and.w	r3, r3, #1
    7afe:	2b00      	cmp	r3, #0
    7b00:	d106      	bne.n	7b10 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x3c>
    7b02:	4a05      	ldr	r2, [pc, #20]	; (7b18 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    7b04:	9b01      	ldr	r3, [sp, #4]
    7b06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b0a:	2b00      	cmp	r3, #0
    7b0c:	d100      	bne.n	7b10 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7b0e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7b10:	bf00      	nop
    7b12:	b003      	add	sp, #12
    7b14:	f85d fb04 	ldr.w	pc, [sp], #4
    7b18:	1fff8dec 	.word	0x1fff8dec
    7b1c:	1fff8de8 	.word	0x1fff8de8

00007b20 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04(void)
{
    7b20:	b500      	push	{lr}
    7b22:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b24:	f7f9 f842 	bl	bac <Sys_GetCoreID>
    7b28:	4603      	mov	r3, r0
    7b2a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId])
    7b2c:	4a10      	ldr	r2, [pc, #64]	; (7b70 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    7b2e:	9b01      	ldr	r3, [sp, #4]
    7b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b34:	2b00      	cmp	r3, #0
    7b36:	d10d      	bne.n	7b54 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7b38:	f7f8 ff57 	bl	9ea <Gpt_schm_read_msr>
    7b3c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7b3e:	9b00      	ldr	r3, [sp, #0]
    7b40:	f003 0301 	and.w	r3, r3, #1
    7b44:	2b00      	cmp	r3, #0
    7b46:	d100      	bne.n	7b4a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7b48:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    7b4a:	490a      	ldr	r1, [pc, #40]	; (7b74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x54>)
    7b4c:	9b01      	ldr	r3, [sp, #4]
    7b4e:	9a00      	ldr	r2, [sp, #0]
    7b50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]++;
    7b54:	4a06      	ldr	r2, [pc, #24]	; (7b70 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    7b56:	9b01      	ldr	r3, [sp, #4]
    7b58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b5c:	1c5a      	adds	r2, r3, #1
    7b5e:	4904      	ldr	r1, [pc, #16]	; (7b70 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    7b60:	9b01      	ldr	r3, [sp, #4]
    7b62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7b66:	bf00      	nop
    7b68:	b003      	add	sp, #12
    7b6a:	f85d fb04 	ldr.w	pc, [sp], #4
    7b6e:	bf00      	nop
    7b70:	1fff8df4 	.word	0x1fff8df4
    7b74:	1fff8df0 	.word	0x1fff8df0

00007b78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04(void)
{
    7b78:	b500      	push	{lr}
    7b7a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b7c:	f7f9 f816 	bl	bac <Sys_GetCoreID>
    7b80:	4603      	mov	r3, r0
    7b82:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]--;
    7b84:	4a0d      	ldr	r2, [pc, #52]	; (7bbc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    7b86:	9b01      	ldr	r3, [sp, #4]
    7b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b8c:	1e5a      	subs	r2, r3, #1
    7b8e:	490b      	ldr	r1, [pc, #44]	; (7bbc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    7b90:	9b01      	ldr	r3, [sp, #4]
    7b92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    7b96:	4a0a      	ldr	r2, [pc, #40]	; (7bc0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x48>)
    7b98:	9b01      	ldr	r3, [sp, #4]
    7b9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b9e:	f003 0301 	and.w	r3, r3, #1
    7ba2:	2b00      	cmp	r3, #0
    7ba4:	d106      	bne.n	7bb4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x3c>
    7ba6:	4a05      	ldr	r2, [pc, #20]	; (7bbc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    7ba8:	9b01      	ldr	r3, [sp, #4]
    7baa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bae:	2b00      	cmp	r3, #0
    7bb0:	d100      	bne.n	7bb4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7bb2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7bb4:	bf00      	nop
    7bb6:	b003      	add	sp, #12
    7bb8:	f85d fb04 	ldr.w	pc, [sp], #4
    7bbc:	1fff8df4 	.word	0x1fff8df4
    7bc0:	1fff8df0 	.word	0x1fff8df0

00007bc4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05(void)
{
    7bc4:	b500      	push	{lr}
    7bc6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7bc8:	f7f8 fff0 	bl	bac <Sys_GetCoreID>
    7bcc:	4603      	mov	r3, r0
    7bce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId])
    7bd0:	4a10      	ldr	r2, [pc, #64]	; (7c14 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    7bd2:	9b01      	ldr	r3, [sp, #4]
    7bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bd8:	2b00      	cmp	r3, #0
    7bda:	d10d      	bne.n	7bf8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7bdc:	f7f8 ff05 	bl	9ea <Gpt_schm_read_msr>
    7be0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7be2:	9b00      	ldr	r3, [sp, #0]
    7be4:	f003 0301 	and.w	r3, r3, #1
    7be8:	2b00      	cmp	r3, #0
    7bea:	d100      	bne.n	7bee <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7bec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    7bee:	490a      	ldr	r1, [pc, #40]	; (7c18 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x54>)
    7bf0:	9b01      	ldr	r3, [sp, #4]
    7bf2:	9a00      	ldr	r2, [sp, #0]
    7bf4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]++;
    7bf8:	4a06      	ldr	r2, [pc, #24]	; (7c14 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    7bfa:	9b01      	ldr	r3, [sp, #4]
    7bfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c00:	1c5a      	adds	r2, r3, #1
    7c02:	4904      	ldr	r1, [pc, #16]	; (7c14 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    7c04:	9b01      	ldr	r3, [sp, #4]
    7c06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7c0a:	bf00      	nop
    7c0c:	b003      	add	sp, #12
    7c0e:	f85d fb04 	ldr.w	pc, [sp], #4
    7c12:	bf00      	nop
    7c14:	1fff8dfc 	.word	0x1fff8dfc
    7c18:	1fff8df8 	.word	0x1fff8df8

00007c1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05(void)
{
    7c1c:	b500      	push	{lr}
    7c1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c20:	f7f8 ffc4 	bl	bac <Sys_GetCoreID>
    7c24:	4603      	mov	r3, r0
    7c26:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]--;
    7c28:	4a0d      	ldr	r2, [pc, #52]	; (7c60 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    7c2a:	9b01      	ldr	r3, [sp, #4]
    7c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c30:	1e5a      	subs	r2, r3, #1
    7c32:	490b      	ldr	r1, [pc, #44]	; (7c60 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    7c34:	9b01      	ldr	r3, [sp, #4]
    7c36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    7c3a:	4a0a      	ldr	r2, [pc, #40]	; (7c64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x48>)
    7c3c:	9b01      	ldr	r3, [sp, #4]
    7c3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c42:	f003 0301 	and.w	r3, r3, #1
    7c46:	2b00      	cmp	r3, #0
    7c48:	d106      	bne.n	7c58 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x3c>
    7c4a:	4a05      	ldr	r2, [pc, #20]	; (7c60 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    7c4c:	9b01      	ldr	r3, [sp, #4]
    7c4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c52:	2b00      	cmp	r3, #0
    7c54:	d100      	bne.n	7c58 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7c56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7c58:	bf00      	nop
    7c5a:	b003      	add	sp, #12
    7c5c:	f85d fb04 	ldr.w	pc, [sp], #4
    7c60:	1fff8dfc 	.word	0x1fff8dfc
    7c64:	1fff8df8 	.word	0x1fff8df8

00007c68 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06(void)
{
    7c68:	b500      	push	{lr}
    7c6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c6c:	f7f8 ff9e 	bl	bac <Sys_GetCoreID>
    7c70:	4603      	mov	r3, r0
    7c72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId])
    7c74:	4a10      	ldr	r2, [pc, #64]	; (7cb8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    7c76:	9b01      	ldr	r3, [sp, #4]
    7c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c7c:	2b00      	cmp	r3, #0
    7c7e:	d10d      	bne.n	7c9c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7c80:	f7f8 feb3 	bl	9ea <Gpt_schm_read_msr>
    7c84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7c86:	9b00      	ldr	r3, [sp, #0]
    7c88:	f003 0301 	and.w	r3, r3, #1
    7c8c:	2b00      	cmp	r3, #0
    7c8e:	d100      	bne.n	7c92 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7c90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    7c92:	490a      	ldr	r1, [pc, #40]	; (7cbc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x54>)
    7c94:	9b01      	ldr	r3, [sp, #4]
    7c96:	9a00      	ldr	r2, [sp, #0]
    7c98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]++;
    7c9c:	4a06      	ldr	r2, [pc, #24]	; (7cb8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    7c9e:	9b01      	ldr	r3, [sp, #4]
    7ca0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ca4:	1c5a      	adds	r2, r3, #1
    7ca6:	4904      	ldr	r1, [pc, #16]	; (7cb8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    7ca8:	9b01      	ldr	r3, [sp, #4]
    7caa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7cae:	bf00      	nop
    7cb0:	b003      	add	sp, #12
    7cb2:	f85d fb04 	ldr.w	pc, [sp], #4
    7cb6:	bf00      	nop
    7cb8:	1fff8e04 	.word	0x1fff8e04
    7cbc:	1fff8e00 	.word	0x1fff8e00

00007cc0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06(void)
{
    7cc0:	b500      	push	{lr}
    7cc2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7cc4:	f7f8 ff72 	bl	bac <Sys_GetCoreID>
    7cc8:	4603      	mov	r3, r0
    7cca:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]--;
    7ccc:	4a0d      	ldr	r2, [pc, #52]	; (7d04 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    7cce:	9b01      	ldr	r3, [sp, #4]
    7cd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cd4:	1e5a      	subs	r2, r3, #1
    7cd6:	490b      	ldr	r1, [pc, #44]	; (7d04 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    7cd8:	9b01      	ldr	r3, [sp, #4]
    7cda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    7cde:	4a0a      	ldr	r2, [pc, #40]	; (7d08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x48>)
    7ce0:	9b01      	ldr	r3, [sp, #4]
    7ce2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ce6:	f003 0301 	and.w	r3, r3, #1
    7cea:	2b00      	cmp	r3, #0
    7cec:	d106      	bne.n	7cfc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x3c>
    7cee:	4a05      	ldr	r2, [pc, #20]	; (7d04 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    7cf0:	9b01      	ldr	r3, [sp, #4]
    7cf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cf6:	2b00      	cmp	r3, #0
    7cf8:	d100      	bne.n	7cfc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7cfa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7cfc:	bf00      	nop
    7cfe:	b003      	add	sp, #12
    7d00:	f85d fb04 	ldr.w	pc, [sp], #4
    7d04:	1fff8e04 	.word	0x1fff8e04
    7d08:	1fff8e00 	.word	0x1fff8e00

00007d0c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07(void)
{
    7d0c:	b500      	push	{lr}
    7d0e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d10:	f7f8 ff4c 	bl	bac <Sys_GetCoreID>
    7d14:	4603      	mov	r3, r0
    7d16:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId])
    7d18:	4a10      	ldr	r2, [pc, #64]	; (7d5c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    7d1a:	9b01      	ldr	r3, [sp, #4]
    7d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d20:	2b00      	cmp	r3, #0
    7d22:	d10d      	bne.n	7d40 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7d24:	f7f8 fe61 	bl	9ea <Gpt_schm_read_msr>
    7d28:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7d2a:	9b00      	ldr	r3, [sp, #0]
    7d2c:	f003 0301 	and.w	r3, r3, #1
    7d30:	2b00      	cmp	r3, #0
    7d32:	d100      	bne.n	7d36 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7d34:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    7d36:	490a      	ldr	r1, [pc, #40]	; (7d60 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x54>)
    7d38:	9b01      	ldr	r3, [sp, #4]
    7d3a:	9a00      	ldr	r2, [sp, #0]
    7d3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]++;
    7d40:	4a06      	ldr	r2, [pc, #24]	; (7d5c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    7d42:	9b01      	ldr	r3, [sp, #4]
    7d44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d48:	1c5a      	adds	r2, r3, #1
    7d4a:	4904      	ldr	r1, [pc, #16]	; (7d5c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    7d4c:	9b01      	ldr	r3, [sp, #4]
    7d4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7d52:	bf00      	nop
    7d54:	b003      	add	sp, #12
    7d56:	f85d fb04 	ldr.w	pc, [sp], #4
    7d5a:	bf00      	nop
    7d5c:	1fff8e0c 	.word	0x1fff8e0c
    7d60:	1fff8e08 	.word	0x1fff8e08

00007d64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07(void)
{
    7d64:	b500      	push	{lr}
    7d66:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d68:	f7f8 ff20 	bl	bac <Sys_GetCoreID>
    7d6c:	4603      	mov	r3, r0
    7d6e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]--;
    7d70:	4a0d      	ldr	r2, [pc, #52]	; (7da8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    7d72:	9b01      	ldr	r3, [sp, #4]
    7d74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d78:	1e5a      	subs	r2, r3, #1
    7d7a:	490b      	ldr	r1, [pc, #44]	; (7da8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    7d7c:	9b01      	ldr	r3, [sp, #4]
    7d7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    7d82:	4a0a      	ldr	r2, [pc, #40]	; (7dac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x48>)
    7d84:	9b01      	ldr	r3, [sp, #4]
    7d86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d8a:	f003 0301 	and.w	r3, r3, #1
    7d8e:	2b00      	cmp	r3, #0
    7d90:	d106      	bne.n	7da0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x3c>
    7d92:	4a05      	ldr	r2, [pc, #20]	; (7da8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    7d94:	9b01      	ldr	r3, [sp, #4]
    7d96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d9a:	2b00      	cmp	r3, #0
    7d9c:	d100      	bne.n	7da0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7d9e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7da0:	bf00      	nop
    7da2:	b003      	add	sp, #12
    7da4:	f85d fb04 	ldr.w	pc, [sp], #4
    7da8:	1fff8e0c 	.word	0x1fff8e0c
    7dac:	1fff8e08 	.word	0x1fff8e08

00007db0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10(void)
{
    7db0:	b500      	push	{lr}
    7db2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7db4:	f7f8 fefa 	bl	bac <Sys_GetCoreID>
    7db8:	4603      	mov	r3, r0
    7dba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId])
    7dbc:	4a10      	ldr	r2, [pc, #64]	; (7e00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    7dbe:	9b01      	ldr	r3, [sp, #4]
    7dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dc4:	2b00      	cmp	r3, #0
    7dc6:	d10d      	bne.n	7de4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7dc8:	f7f8 fe0f 	bl	9ea <Gpt_schm_read_msr>
    7dcc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7dce:	9b00      	ldr	r3, [sp, #0]
    7dd0:	f003 0301 	and.w	r3, r3, #1
    7dd4:	2b00      	cmp	r3, #0
    7dd6:	d100      	bne.n	7dda <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7dd8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    7dda:	490a      	ldr	r1, [pc, #40]	; (7e04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x54>)
    7ddc:	9b01      	ldr	r3, [sp, #4]
    7dde:	9a00      	ldr	r2, [sp, #0]
    7de0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]++;
    7de4:	4a06      	ldr	r2, [pc, #24]	; (7e00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    7de6:	9b01      	ldr	r3, [sp, #4]
    7de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dec:	1c5a      	adds	r2, r3, #1
    7dee:	4904      	ldr	r1, [pc, #16]	; (7e00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    7df0:	9b01      	ldr	r3, [sp, #4]
    7df2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7df6:	bf00      	nop
    7df8:	b003      	add	sp, #12
    7dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    7dfe:	bf00      	nop
    7e00:	1fff8e14 	.word	0x1fff8e14
    7e04:	1fff8e10 	.word	0x1fff8e10

00007e08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10(void)
{
    7e08:	b500      	push	{lr}
    7e0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e0c:	f7f8 fece 	bl	bac <Sys_GetCoreID>
    7e10:	4603      	mov	r3, r0
    7e12:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]--;
    7e14:	4a0d      	ldr	r2, [pc, #52]	; (7e4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    7e16:	9b01      	ldr	r3, [sp, #4]
    7e18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e1c:	1e5a      	subs	r2, r3, #1
    7e1e:	490b      	ldr	r1, [pc, #44]	; (7e4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    7e20:	9b01      	ldr	r3, [sp, #4]
    7e22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    7e26:	4a0a      	ldr	r2, [pc, #40]	; (7e50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x48>)
    7e28:	9b01      	ldr	r3, [sp, #4]
    7e2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e2e:	f003 0301 	and.w	r3, r3, #1
    7e32:	2b00      	cmp	r3, #0
    7e34:	d106      	bne.n	7e44 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x3c>
    7e36:	4a05      	ldr	r2, [pc, #20]	; (7e4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    7e38:	9b01      	ldr	r3, [sp, #4]
    7e3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e3e:	2b00      	cmp	r3, #0
    7e40:	d100      	bne.n	7e44 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7e42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7e44:	bf00      	nop
    7e46:	b003      	add	sp, #12
    7e48:	f85d fb04 	ldr.w	pc, [sp], #4
    7e4c:	1fff8e14 	.word	0x1fff8e14
    7e50:	1fff8e10 	.word	0x1fff8e10

00007e54 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11(void)
{
    7e54:	b500      	push	{lr}
    7e56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e58:	f7f8 fea8 	bl	bac <Sys_GetCoreID>
    7e5c:	4603      	mov	r3, r0
    7e5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId])
    7e60:	4a10      	ldr	r2, [pc, #64]	; (7ea4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    7e62:	9b01      	ldr	r3, [sp, #4]
    7e64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e68:	2b00      	cmp	r3, #0
    7e6a:	d10d      	bne.n	7e88 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7e6c:	f7f8 fdbd 	bl	9ea <Gpt_schm_read_msr>
    7e70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7e72:	9b00      	ldr	r3, [sp, #0]
    7e74:	f003 0301 	and.w	r3, r3, #1
    7e78:	2b00      	cmp	r3, #0
    7e7a:	d100      	bne.n	7e7e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7e7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    7e7e:	490a      	ldr	r1, [pc, #40]	; (7ea8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x54>)
    7e80:	9b01      	ldr	r3, [sp, #4]
    7e82:	9a00      	ldr	r2, [sp, #0]
    7e84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]++;
    7e88:	4a06      	ldr	r2, [pc, #24]	; (7ea4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    7e8a:	9b01      	ldr	r3, [sp, #4]
    7e8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e90:	1c5a      	adds	r2, r3, #1
    7e92:	4904      	ldr	r1, [pc, #16]	; (7ea4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    7e94:	9b01      	ldr	r3, [sp, #4]
    7e96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7e9a:	bf00      	nop
    7e9c:	b003      	add	sp, #12
    7e9e:	f85d fb04 	ldr.w	pc, [sp], #4
    7ea2:	bf00      	nop
    7ea4:	1fff8e1c 	.word	0x1fff8e1c
    7ea8:	1fff8e18 	.word	0x1fff8e18

00007eac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11(void)
{
    7eac:	b500      	push	{lr}
    7eae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7eb0:	f7f8 fe7c 	bl	bac <Sys_GetCoreID>
    7eb4:	4603      	mov	r3, r0
    7eb6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]--;
    7eb8:	4a0d      	ldr	r2, [pc, #52]	; (7ef0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    7eba:	9b01      	ldr	r3, [sp, #4]
    7ebc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ec0:	1e5a      	subs	r2, r3, #1
    7ec2:	490b      	ldr	r1, [pc, #44]	; (7ef0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    7ec4:	9b01      	ldr	r3, [sp, #4]
    7ec6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    7eca:	4a0a      	ldr	r2, [pc, #40]	; (7ef4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x48>)
    7ecc:	9b01      	ldr	r3, [sp, #4]
    7ece:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ed2:	f003 0301 	and.w	r3, r3, #1
    7ed6:	2b00      	cmp	r3, #0
    7ed8:	d106      	bne.n	7ee8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x3c>
    7eda:	4a05      	ldr	r2, [pc, #20]	; (7ef0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    7edc:	9b01      	ldr	r3, [sp, #4]
    7ede:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ee2:	2b00      	cmp	r3, #0
    7ee4:	d100      	bne.n	7ee8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7ee6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7ee8:	bf00      	nop
    7eea:	b003      	add	sp, #12
    7eec:	f85d fb04 	ldr.w	pc, [sp], #4
    7ef0:	1fff8e1c 	.word	0x1fff8e1c
    7ef4:	1fff8e18 	.word	0x1fff8e18

00007ef8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17(void)
{
    7ef8:	b500      	push	{lr}
    7efa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7efc:	f7f8 fe56 	bl	bac <Sys_GetCoreID>
    7f00:	4603      	mov	r3, r0
    7f02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId])
    7f04:	4a10      	ldr	r2, [pc, #64]	; (7f48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    7f06:	9b01      	ldr	r3, [sp, #4]
    7f08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f0c:	2b00      	cmp	r3, #0
    7f0e:	d10d      	bne.n	7f2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7f10:	f7f8 fd6b 	bl	9ea <Gpt_schm_read_msr>
    7f14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7f16:	9b00      	ldr	r3, [sp, #0]
    7f18:	f003 0301 	and.w	r3, r3, #1
    7f1c:	2b00      	cmp	r3, #0
    7f1e:	d100      	bne.n	7f22 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7f20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    7f22:	490a      	ldr	r1, [pc, #40]	; (7f4c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x54>)
    7f24:	9b01      	ldr	r3, [sp, #4]
    7f26:	9a00      	ldr	r2, [sp, #0]
    7f28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]++;
    7f2c:	4a06      	ldr	r2, [pc, #24]	; (7f48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    7f2e:	9b01      	ldr	r3, [sp, #4]
    7f30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f34:	1c5a      	adds	r2, r3, #1
    7f36:	4904      	ldr	r1, [pc, #16]	; (7f48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    7f38:	9b01      	ldr	r3, [sp, #4]
    7f3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7f3e:	bf00      	nop
    7f40:	b003      	add	sp, #12
    7f42:	f85d fb04 	ldr.w	pc, [sp], #4
    7f46:	bf00      	nop
    7f48:	1fff8e24 	.word	0x1fff8e24
    7f4c:	1fff8e20 	.word	0x1fff8e20

00007f50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17(void)
{
    7f50:	b500      	push	{lr}
    7f52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7f54:	f7f8 fe2a 	bl	bac <Sys_GetCoreID>
    7f58:	4603      	mov	r3, r0
    7f5a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]--;
    7f5c:	4a0d      	ldr	r2, [pc, #52]	; (7f94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    7f5e:	9b01      	ldr	r3, [sp, #4]
    7f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f64:	1e5a      	subs	r2, r3, #1
    7f66:	490b      	ldr	r1, [pc, #44]	; (7f94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    7f68:	9b01      	ldr	r3, [sp, #4]
    7f6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    7f6e:	4a0a      	ldr	r2, [pc, #40]	; (7f98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x48>)
    7f70:	9b01      	ldr	r3, [sp, #4]
    7f72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f76:	f003 0301 	and.w	r3, r3, #1
    7f7a:	2b00      	cmp	r3, #0
    7f7c:	d106      	bne.n	7f8c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x3c>
    7f7e:	4a05      	ldr	r2, [pc, #20]	; (7f94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    7f80:	9b01      	ldr	r3, [sp, #4]
    7f82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f86:	2b00      	cmp	r3, #0
    7f88:	d100      	bne.n	7f8c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7f8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7f8c:	bf00      	nop
    7f8e:	b003      	add	sp, #12
    7f90:	f85d fb04 	ldr.w	pc, [sp], #4
    7f94:	1fff8e24 	.word	0x1fff8e24
    7f98:	1fff8e20 	.word	0x1fff8e20

00007f9c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21(void)
{
    7f9c:	b500      	push	{lr}
    7f9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7fa0:	f7f8 fe04 	bl	bac <Sys_GetCoreID>
    7fa4:	4603      	mov	r3, r0
    7fa6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId])
    7fa8:	4a10      	ldr	r2, [pc, #64]	; (7fec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    7faa:	9b01      	ldr	r3, [sp, #4]
    7fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fb0:	2b00      	cmp	r3, #0
    7fb2:	d10d      	bne.n	7fd0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7fb4:	f7f8 fd19 	bl	9ea <Gpt_schm_read_msr>
    7fb8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7fba:	9b00      	ldr	r3, [sp, #0]
    7fbc:	f003 0301 	and.w	r3, r3, #1
    7fc0:	2b00      	cmp	r3, #0
    7fc2:	d100      	bne.n	7fc6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7fc4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    7fc6:	490a      	ldr	r1, [pc, #40]	; (7ff0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x54>)
    7fc8:	9b01      	ldr	r3, [sp, #4]
    7fca:	9a00      	ldr	r2, [sp, #0]
    7fcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]++;
    7fd0:	4a06      	ldr	r2, [pc, #24]	; (7fec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    7fd2:	9b01      	ldr	r3, [sp, #4]
    7fd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fd8:	1c5a      	adds	r2, r3, #1
    7fda:	4904      	ldr	r1, [pc, #16]	; (7fec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    7fdc:	9b01      	ldr	r3, [sp, #4]
    7fde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7fe2:	bf00      	nop
    7fe4:	b003      	add	sp, #12
    7fe6:	f85d fb04 	ldr.w	pc, [sp], #4
    7fea:	bf00      	nop
    7fec:	1fff8e2c 	.word	0x1fff8e2c
    7ff0:	1fff8e28 	.word	0x1fff8e28

00007ff4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21(void)
{
    7ff4:	b500      	push	{lr}
    7ff6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ff8:	f7f8 fdd8 	bl	bac <Sys_GetCoreID>
    7ffc:	4603      	mov	r3, r0
    7ffe:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]--;
    8000:	4a0d      	ldr	r2, [pc, #52]	; (8038 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    8002:	9b01      	ldr	r3, [sp, #4]
    8004:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8008:	1e5a      	subs	r2, r3, #1
    800a:	490b      	ldr	r1, [pc, #44]	; (8038 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    800c:	9b01      	ldr	r3, [sp, #4]
    800e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    8012:	4a0a      	ldr	r2, [pc, #40]	; (803c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x48>)
    8014:	9b01      	ldr	r3, [sp, #4]
    8016:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    801a:	f003 0301 	and.w	r3, r3, #1
    801e:	2b00      	cmp	r3, #0
    8020:	d106      	bne.n	8030 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x3c>
    8022:	4a05      	ldr	r2, [pc, #20]	; (8038 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    8024:	9b01      	ldr	r3, [sp, #4]
    8026:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    802a:	2b00      	cmp	r3, #0
    802c:	d100      	bne.n	8030 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    802e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8030:	bf00      	nop
    8032:	b003      	add	sp, #12
    8034:	f85d fb04 	ldr.w	pc, [sp], #4
    8038:	1fff8e2c 	.word	0x1fff8e2c
    803c:	1fff8e28 	.word	0x1fff8e28

00008040 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22(void)
{
    8040:	b500      	push	{lr}
    8042:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8044:	f7f8 fdb2 	bl	bac <Sys_GetCoreID>
    8048:	4603      	mov	r3, r0
    804a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId])
    804c:	4a10      	ldr	r2, [pc, #64]	; (8090 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    804e:	9b01      	ldr	r3, [sp, #4]
    8050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8054:	2b00      	cmp	r3, #0
    8056:	d10d      	bne.n	8074 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8058:	f7f8 fcc7 	bl	9ea <Gpt_schm_read_msr>
    805c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    805e:	9b00      	ldr	r3, [sp, #0]
    8060:	f003 0301 	and.w	r3, r3, #1
    8064:	2b00      	cmp	r3, #0
    8066:	d100      	bne.n	806a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8068:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    806a:	490a      	ldr	r1, [pc, #40]	; (8094 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x54>)
    806c:	9b01      	ldr	r3, [sp, #4]
    806e:	9a00      	ldr	r2, [sp, #0]
    8070:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]++;
    8074:	4a06      	ldr	r2, [pc, #24]	; (8090 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    8076:	9b01      	ldr	r3, [sp, #4]
    8078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    807c:	1c5a      	adds	r2, r3, #1
    807e:	4904      	ldr	r1, [pc, #16]	; (8090 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    8080:	9b01      	ldr	r3, [sp, #4]
    8082:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8086:	bf00      	nop
    8088:	b003      	add	sp, #12
    808a:	f85d fb04 	ldr.w	pc, [sp], #4
    808e:	bf00      	nop
    8090:	1fff8e34 	.word	0x1fff8e34
    8094:	1fff8e30 	.word	0x1fff8e30

00008098 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22(void)
{
    8098:	b500      	push	{lr}
    809a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    809c:	f7f8 fd86 	bl	bac <Sys_GetCoreID>
    80a0:	4603      	mov	r3, r0
    80a2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]--;
    80a4:	4a0d      	ldr	r2, [pc, #52]	; (80dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    80a6:	9b01      	ldr	r3, [sp, #4]
    80a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80ac:	1e5a      	subs	r2, r3, #1
    80ae:	490b      	ldr	r1, [pc, #44]	; (80dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    80b0:	9b01      	ldr	r3, [sp, #4]
    80b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    80b6:	4a0a      	ldr	r2, [pc, #40]	; (80e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x48>)
    80b8:	9b01      	ldr	r3, [sp, #4]
    80ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80be:	f003 0301 	and.w	r3, r3, #1
    80c2:	2b00      	cmp	r3, #0
    80c4:	d106      	bne.n	80d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x3c>
    80c6:	4a05      	ldr	r2, [pc, #20]	; (80dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    80c8:	9b01      	ldr	r3, [sp, #4]
    80ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80ce:	2b00      	cmp	r3, #0
    80d0:	d100      	bne.n	80d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    80d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    80d4:	bf00      	nop
    80d6:	b003      	add	sp, #12
    80d8:	f85d fb04 	ldr.w	pc, [sp], #4
    80dc:	1fff8e34 	.word	0x1fff8e34
    80e0:	1fff8e30 	.word	0x1fff8e30

000080e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23(void)
{
    80e4:	b500      	push	{lr}
    80e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    80e8:	f7f8 fd60 	bl	bac <Sys_GetCoreID>
    80ec:	4603      	mov	r3, r0
    80ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId])
    80f0:	4a10      	ldr	r2, [pc, #64]	; (8134 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    80f2:	9b01      	ldr	r3, [sp, #4]
    80f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80f8:	2b00      	cmp	r3, #0
    80fa:	d10d      	bne.n	8118 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    80fc:	f7f8 fc75 	bl	9ea <Gpt_schm_read_msr>
    8100:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8102:	9b00      	ldr	r3, [sp, #0]
    8104:	f003 0301 	and.w	r3, r3, #1
    8108:	2b00      	cmp	r3, #0
    810a:	d100      	bne.n	810e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    810c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    810e:	490a      	ldr	r1, [pc, #40]	; (8138 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x54>)
    8110:	9b01      	ldr	r3, [sp, #4]
    8112:	9a00      	ldr	r2, [sp, #0]
    8114:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]++;
    8118:	4a06      	ldr	r2, [pc, #24]	; (8134 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    811a:	9b01      	ldr	r3, [sp, #4]
    811c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8120:	1c5a      	adds	r2, r3, #1
    8122:	4904      	ldr	r1, [pc, #16]	; (8134 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    8124:	9b01      	ldr	r3, [sp, #4]
    8126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    812a:	bf00      	nop
    812c:	b003      	add	sp, #12
    812e:	f85d fb04 	ldr.w	pc, [sp], #4
    8132:	bf00      	nop
    8134:	1fff8e3c 	.word	0x1fff8e3c
    8138:	1fff8e38 	.word	0x1fff8e38

0000813c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23(void)
{
    813c:	b500      	push	{lr}
    813e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8140:	f7f8 fd34 	bl	bac <Sys_GetCoreID>
    8144:	4603      	mov	r3, r0
    8146:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]--;
    8148:	4a0d      	ldr	r2, [pc, #52]	; (8180 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    814a:	9b01      	ldr	r3, [sp, #4]
    814c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8150:	1e5a      	subs	r2, r3, #1
    8152:	490b      	ldr	r1, [pc, #44]	; (8180 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    8154:	9b01      	ldr	r3, [sp, #4]
    8156:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    815a:	4a0a      	ldr	r2, [pc, #40]	; (8184 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x48>)
    815c:	9b01      	ldr	r3, [sp, #4]
    815e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8162:	f003 0301 	and.w	r3, r3, #1
    8166:	2b00      	cmp	r3, #0
    8168:	d106      	bne.n	8178 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x3c>
    816a:	4a05      	ldr	r2, [pc, #20]	; (8180 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    816c:	9b01      	ldr	r3, [sp, #4]
    816e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8172:	2b00      	cmp	r3, #0
    8174:	d100      	bne.n	8178 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8176:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8178:	bf00      	nop
    817a:	b003      	add	sp, #12
    817c:	f85d fb04 	ldr.w	pc, [sp], #4
    8180:	1fff8e3c 	.word	0x1fff8e3c
    8184:	1fff8e38 	.word	0x1fff8e38

00008188 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24(void)
{
    8188:	b500      	push	{lr}
    818a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    818c:	f7f8 fd0e 	bl	bac <Sys_GetCoreID>
    8190:	4603      	mov	r3, r0
    8192:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId])
    8194:	4a10      	ldr	r2, [pc, #64]	; (81d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    8196:	9b01      	ldr	r3, [sp, #4]
    8198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    819c:	2b00      	cmp	r3, #0
    819e:	d10d      	bne.n	81bc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    81a0:	f7f8 fc23 	bl	9ea <Gpt_schm_read_msr>
    81a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    81a6:	9b00      	ldr	r3, [sp, #0]
    81a8:	f003 0301 	and.w	r3, r3, #1
    81ac:	2b00      	cmp	r3, #0
    81ae:	d100      	bne.n	81b2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    81b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    81b2:	490a      	ldr	r1, [pc, #40]	; (81dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x54>)
    81b4:	9b01      	ldr	r3, [sp, #4]
    81b6:	9a00      	ldr	r2, [sp, #0]
    81b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]++;
    81bc:	4a06      	ldr	r2, [pc, #24]	; (81d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    81be:	9b01      	ldr	r3, [sp, #4]
    81c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81c4:	1c5a      	adds	r2, r3, #1
    81c6:	4904      	ldr	r1, [pc, #16]	; (81d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    81c8:	9b01      	ldr	r3, [sp, #4]
    81ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    81ce:	bf00      	nop
    81d0:	b003      	add	sp, #12
    81d2:	f85d fb04 	ldr.w	pc, [sp], #4
    81d6:	bf00      	nop
    81d8:	1fff8e44 	.word	0x1fff8e44
    81dc:	1fff8e40 	.word	0x1fff8e40

000081e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24(void)
{
    81e0:	b500      	push	{lr}
    81e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    81e4:	f7f8 fce2 	bl	bac <Sys_GetCoreID>
    81e8:	4603      	mov	r3, r0
    81ea:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]--;
    81ec:	4a0d      	ldr	r2, [pc, #52]	; (8224 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    81ee:	9b01      	ldr	r3, [sp, #4]
    81f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81f4:	1e5a      	subs	r2, r3, #1
    81f6:	490b      	ldr	r1, [pc, #44]	; (8224 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    81f8:	9b01      	ldr	r3, [sp, #4]
    81fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    81fe:	4a0a      	ldr	r2, [pc, #40]	; (8228 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x48>)
    8200:	9b01      	ldr	r3, [sp, #4]
    8202:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8206:	f003 0301 	and.w	r3, r3, #1
    820a:	2b00      	cmp	r3, #0
    820c:	d106      	bne.n	821c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x3c>
    820e:	4a05      	ldr	r2, [pc, #20]	; (8224 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    8210:	9b01      	ldr	r3, [sp, #4]
    8212:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8216:	2b00      	cmp	r3, #0
    8218:	d100      	bne.n	821c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    821a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    821c:	bf00      	nop
    821e:	b003      	add	sp, #12
    8220:	f85d fb04 	ldr.w	pc, [sp], #4
    8224:	1fff8e44 	.word	0x1fff8e44
    8228:	1fff8e40 	.word	0x1fff8e40

0000822c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25(void)
{
    822c:	b500      	push	{lr}
    822e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8230:	f7f8 fcbc 	bl	bac <Sys_GetCoreID>
    8234:	4603      	mov	r3, r0
    8236:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId])
    8238:	4a10      	ldr	r2, [pc, #64]	; (827c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    823a:	9b01      	ldr	r3, [sp, #4]
    823c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8240:	2b00      	cmp	r3, #0
    8242:	d10d      	bne.n	8260 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8244:	f7f8 fbd1 	bl	9ea <Gpt_schm_read_msr>
    8248:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    824a:	9b00      	ldr	r3, [sp, #0]
    824c:	f003 0301 	and.w	r3, r3, #1
    8250:	2b00      	cmp	r3, #0
    8252:	d100      	bne.n	8256 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8254:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    8256:	490a      	ldr	r1, [pc, #40]	; (8280 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x54>)
    8258:	9b01      	ldr	r3, [sp, #4]
    825a:	9a00      	ldr	r2, [sp, #0]
    825c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]++;
    8260:	4a06      	ldr	r2, [pc, #24]	; (827c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    8262:	9b01      	ldr	r3, [sp, #4]
    8264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8268:	1c5a      	adds	r2, r3, #1
    826a:	4904      	ldr	r1, [pc, #16]	; (827c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    826c:	9b01      	ldr	r3, [sp, #4]
    826e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8272:	bf00      	nop
    8274:	b003      	add	sp, #12
    8276:	f85d fb04 	ldr.w	pc, [sp], #4
    827a:	bf00      	nop
    827c:	1fff8e4c 	.word	0x1fff8e4c
    8280:	1fff8e48 	.word	0x1fff8e48

00008284 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25(void)
{
    8284:	b500      	push	{lr}
    8286:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8288:	f7f8 fc90 	bl	bac <Sys_GetCoreID>
    828c:	4603      	mov	r3, r0
    828e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]--;
    8290:	4a0d      	ldr	r2, [pc, #52]	; (82c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    8292:	9b01      	ldr	r3, [sp, #4]
    8294:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8298:	1e5a      	subs	r2, r3, #1
    829a:	490b      	ldr	r1, [pc, #44]	; (82c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    829c:	9b01      	ldr	r3, [sp, #4]
    829e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    82a2:	4a0a      	ldr	r2, [pc, #40]	; (82cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x48>)
    82a4:	9b01      	ldr	r3, [sp, #4]
    82a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82aa:	f003 0301 	and.w	r3, r3, #1
    82ae:	2b00      	cmp	r3, #0
    82b0:	d106      	bne.n	82c0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x3c>
    82b2:	4a05      	ldr	r2, [pc, #20]	; (82c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    82b4:	9b01      	ldr	r3, [sp, #4]
    82b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82ba:	2b00      	cmp	r3, #0
    82bc:	d100      	bne.n	82c0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    82be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    82c0:	bf00      	nop
    82c2:	b003      	add	sp, #12
    82c4:	f85d fb04 	ldr.w	pc, [sp], #4
    82c8:	1fff8e4c 	.word	0x1fff8e4c
    82cc:	1fff8e48 	.word	0x1fff8e48

000082d0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26(void)
{
    82d0:	b500      	push	{lr}
    82d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    82d4:	f7f8 fc6a 	bl	bac <Sys_GetCoreID>
    82d8:	4603      	mov	r3, r0
    82da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId])
    82dc:	4a10      	ldr	r2, [pc, #64]	; (8320 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    82de:	9b01      	ldr	r3, [sp, #4]
    82e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82e4:	2b00      	cmp	r3, #0
    82e6:	d10d      	bne.n	8304 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    82e8:	f7f8 fb7f 	bl	9ea <Gpt_schm_read_msr>
    82ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    82ee:	9b00      	ldr	r3, [sp, #0]
    82f0:	f003 0301 	and.w	r3, r3, #1
    82f4:	2b00      	cmp	r3, #0
    82f6:	d100      	bne.n	82fa <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    82f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    82fa:	490a      	ldr	r1, [pc, #40]	; (8324 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x54>)
    82fc:	9b01      	ldr	r3, [sp, #4]
    82fe:	9a00      	ldr	r2, [sp, #0]
    8300:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]++;
    8304:	4a06      	ldr	r2, [pc, #24]	; (8320 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    8306:	9b01      	ldr	r3, [sp, #4]
    8308:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    830c:	1c5a      	adds	r2, r3, #1
    830e:	4904      	ldr	r1, [pc, #16]	; (8320 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    8310:	9b01      	ldr	r3, [sp, #4]
    8312:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8316:	bf00      	nop
    8318:	b003      	add	sp, #12
    831a:	f85d fb04 	ldr.w	pc, [sp], #4
    831e:	bf00      	nop
    8320:	1fff8e54 	.word	0x1fff8e54
    8324:	1fff8e50 	.word	0x1fff8e50

00008328 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26(void)
{
    8328:	b500      	push	{lr}
    832a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    832c:	f7f8 fc3e 	bl	bac <Sys_GetCoreID>
    8330:	4603      	mov	r3, r0
    8332:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]--;
    8334:	4a0d      	ldr	r2, [pc, #52]	; (836c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8336:	9b01      	ldr	r3, [sp, #4]
    8338:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    833c:	1e5a      	subs	r2, r3, #1
    833e:	490b      	ldr	r1, [pc, #44]	; (836c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8340:	9b01      	ldr	r3, [sp, #4]
    8342:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    8346:	4a0a      	ldr	r2, [pc, #40]	; (8370 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x48>)
    8348:	9b01      	ldr	r3, [sp, #4]
    834a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    834e:	f003 0301 	and.w	r3, r3, #1
    8352:	2b00      	cmp	r3, #0
    8354:	d106      	bne.n	8364 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x3c>
    8356:	4a05      	ldr	r2, [pc, #20]	; (836c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8358:	9b01      	ldr	r3, [sp, #4]
    835a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    835e:	2b00      	cmp	r3, #0
    8360:	d100      	bne.n	8364 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8362:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8364:	bf00      	nop
    8366:	b003      	add	sp, #12
    8368:	f85d fb04 	ldr.w	pc, [sp], #4
    836c:	1fff8e54 	.word	0x1fff8e54
    8370:	1fff8e50 	.word	0x1fff8e50

00008374 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29(void)
{
    8374:	b500      	push	{lr}
    8376:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8378:	f7f8 fc18 	bl	bac <Sys_GetCoreID>
    837c:	4603      	mov	r3, r0
    837e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId])
    8380:	4a10      	ldr	r2, [pc, #64]	; (83c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    8382:	9b01      	ldr	r3, [sp, #4]
    8384:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8388:	2b00      	cmp	r3, #0
    838a:	d10d      	bne.n	83a8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    838c:	f7f8 fb2d 	bl	9ea <Gpt_schm_read_msr>
    8390:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8392:	9b00      	ldr	r3, [sp, #0]
    8394:	f003 0301 	and.w	r3, r3, #1
    8398:	2b00      	cmp	r3, #0
    839a:	d100      	bne.n	839e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    839c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_29[u32CoreId] = msr;
    839e:	490a      	ldr	r1, [pc, #40]	; (83c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x54>)
    83a0:	9b01      	ldr	r3, [sp, #4]
    83a2:	9a00      	ldr	r2, [sp, #0]
    83a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]++;
    83a8:	4a06      	ldr	r2, [pc, #24]	; (83c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    83aa:	9b01      	ldr	r3, [sp, #4]
    83ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83b0:	1c5a      	adds	r2, r3, #1
    83b2:	4904      	ldr	r1, [pc, #16]	; (83c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    83b4:	9b01      	ldr	r3, [sp, #4]
    83b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    83ba:	bf00      	nop
    83bc:	b003      	add	sp, #12
    83be:	f85d fb04 	ldr.w	pc, [sp], #4
    83c2:	bf00      	nop
    83c4:	1fff8e5c 	.word	0x1fff8e5c
    83c8:	1fff8e58 	.word	0x1fff8e58

000083cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29(void)
{
    83cc:	b500      	push	{lr}
    83ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    83d0:	f7f8 fbec 	bl	bac <Sys_GetCoreID>
    83d4:	4603      	mov	r3, r0
    83d6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]--;
    83d8:	4a0d      	ldr	r2, [pc, #52]	; (8410 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    83da:	9b01      	ldr	r3, [sp, #4]
    83dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83e0:	1e5a      	subs	r2, r3, #1
    83e2:	490b      	ldr	r1, [pc, #44]	; (8410 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    83e4:	9b01      	ldr	r3, [sp, #4]
    83e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_29[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]))         /*if interrupts were enabled*/
    83ea:	4a0a      	ldr	r2, [pc, #40]	; (8414 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x48>)
    83ec:	9b01      	ldr	r3, [sp, #4]
    83ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83f2:	f003 0301 	and.w	r3, r3, #1
    83f6:	2b00      	cmp	r3, #0
    83f8:	d106      	bne.n	8408 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x3c>
    83fa:	4a05      	ldr	r2, [pc, #20]	; (8410 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    83fc:	9b01      	ldr	r3, [sp, #4]
    83fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8402:	2b00      	cmp	r3, #0
    8404:	d100      	bne.n	8408 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8406:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8408:	bf00      	nop
    840a:	b003      	add	sp, #12
    840c:	f85d fb04 	ldr.w	pc, [sp], #4
    8410:	1fff8e5c 	.word	0x1fff8e5c
    8414:	1fff8e58 	.word	0x1fff8e58

00008418 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30(void)
{
    8418:	b500      	push	{lr}
    841a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    841c:	f7f8 fbc6 	bl	bac <Sys_GetCoreID>
    8420:	4603      	mov	r3, r0
    8422:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId])
    8424:	4a10      	ldr	r2, [pc, #64]	; (8468 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    8426:	9b01      	ldr	r3, [sp, #4]
    8428:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    842c:	2b00      	cmp	r3, #0
    842e:	d10d      	bne.n	844c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8430:	f7f8 fadb 	bl	9ea <Gpt_schm_read_msr>
    8434:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8436:	9b00      	ldr	r3, [sp, #0]
    8438:	f003 0301 	and.w	r3, r3, #1
    843c:	2b00      	cmp	r3, #0
    843e:	d100      	bne.n	8442 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8440:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_30[u32CoreId] = msr;
    8442:	490a      	ldr	r1, [pc, #40]	; (846c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x54>)
    8444:	9b01      	ldr	r3, [sp, #4]
    8446:	9a00      	ldr	r2, [sp, #0]
    8448:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]++;
    844c:	4a06      	ldr	r2, [pc, #24]	; (8468 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    844e:	9b01      	ldr	r3, [sp, #4]
    8450:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8454:	1c5a      	adds	r2, r3, #1
    8456:	4904      	ldr	r1, [pc, #16]	; (8468 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    8458:	9b01      	ldr	r3, [sp, #4]
    845a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    845e:	bf00      	nop
    8460:	b003      	add	sp, #12
    8462:	f85d fb04 	ldr.w	pc, [sp], #4
    8466:	bf00      	nop
    8468:	1fff8e64 	.word	0x1fff8e64
    846c:	1fff8e60 	.word	0x1fff8e60

00008470 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30(void)
{
    8470:	b500      	push	{lr}
    8472:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8474:	f7f8 fb9a 	bl	bac <Sys_GetCoreID>
    8478:	4603      	mov	r3, r0
    847a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]--;
    847c:	4a0d      	ldr	r2, [pc, #52]	; (84b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    847e:	9b01      	ldr	r3, [sp, #4]
    8480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8484:	1e5a      	subs	r2, r3, #1
    8486:	490b      	ldr	r1, [pc, #44]	; (84b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    8488:	9b01      	ldr	r3, [sp, #4]
    848a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_30[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]))         /*if interrupts were enabled*/
    848e:	4a0a      	ldr	r2, [pc, #40]	; (84b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x48>)
    8490:	9b01      	ldr	r3, [sp, #4]
    8492:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8496:	f003 0301 	and.w	r3, r3, #1
    849a:	2b00      	cmp	r3, #0
    849c:	d106      	bne.n	84ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x3c>
    849e:	4a05      	ldr	r2, [pc, #20]	; (84b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    84a0:	9b01      	ldr	r3, [sp, #4]
    84a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84a6:	2b00      	cmp	r3, #0
    84a8:	d100      	bne.n	84ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    84aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    84ac:	bf00      	nop
    84ae:	b003      	add	sp, #12
    84b0:	f85d fb04 	ldr.w	pc, [sp], #4
    84b4:	1fff8e64 	.word	0x1fff8e64
    84b8:	1fff8e60 	.word	0x1fff8e60

000084bc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31(void)
{
    84bc:	b500      	push	{lr}
    84be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    84c0:	f7f8 fb74 	bl	bac <Sys_GetCoreID>
    84c4:	4603      	mov	r3, r0
    84c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId])
    84c8:	4a10      	ldr	r2, [pc, #64]	; (850c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    84ca:	9b01      	ldr	r3, [sp, #4]
    84cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84d0:	2b00      	cmp	r3, #0
    84d2:	d10d      	bne.n	84f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    84d4:	f7f8 fa89 	bl	9ea <Gpt_schm_read_msr>
    84d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    84da:	9b00      	ldr	r3, [sp, #0]
    84dc:	f003 0301 	and.w	r3, r3, #1
    84e0:	2b00      	cmp	r3, #0
    84e2:	d100      	bne.n	84e6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    84e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_31[u32CoreId] = msr;
    84e6:	490a      	ldr	r1, [pc, #40]	; (8510 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x54>)
    84e8:	9b01      	ldr	r3, [sp, #4]
    84ea:	9a00      	ldr	r2, [sp, #0]
    84ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]++;
    84f0:	4a06      	ldr	r2, [pc, #24]	; (850c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    84f2:	9b01      	ldr	r3, [sp, #4]
    84f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84f8:	1c5a      	adds	r2, r3, #1
    84fa:	4904      	ldr	r1, [pc, #16]	; (850c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    84fc:	9b01      	ldr	r3, [sp, #4]
    84fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8502:	bf00      	nop
    8504:	b003      	add	sp, #12
    8506:	f85d fb04 	ldr.w	pc, [sp], #4
    850a:	bf00      	nop
    850c:	1fff8e6c 	.word	0x1fff8e6c
    8510:	1fff8e68 	.word	0x1fff8e68

00008514 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31(void)
{
    8514:	b500      	push	{lr}
    8516:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8518:	f7f8 fb48 	bl	bac <Sys_GetCoreID>
    851c:	4603      	mov	r3, r0
    851e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]--;
    8520:	4a0d      	ldr	r2, [pc, #52]	; (8558 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    8522:	9b01      	ldr	r3, [sp, #4]
    8524:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8528:	1e5a      	subs	r2, r3, #1
    852a:	490b      	ldr	r1, [pc, #44]	; (8558 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    852c:	9b01      	ldr	r3, [sp, #4]
    852e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_31[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]))         /*if interrupts were enabled*/
    8532:	4a0a      	ldr	r2, [pc, #40]	; (855c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x48>)
    8534:	9b01      	ldr	r3, [sp, #4]
    8536:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    853a:	f003 0301 	and.w	r3, r3, #1
    853e:	2b00      	cmp	r3, #0
    8540:	d106      	bne.n	8550 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x3c>
    8542:	4a05      	ldr	r2, [pc, #20]	; (8558 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    8544:	9b01      	ldr	r3, [sp, #4]
    8546:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    854a:	2b00      	cmp	r3, #0
    854c:	d100      	bne.n	8550 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    854e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8550:	bf00      	nop
    8552:	b003      	add	sp, #12
    8554:	f85d fb04 	ldr.w	pc, [sp], #4
    8558:	1fff8e6c 	.word	0x1fff8e6c
    855c:	1fff8e68 	.word	0x1fff8e68

00008560 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35(void)
{
    8560:	b500      	push	{lr}
    8562:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8564:	f7f8 fb22 	bl	bac <Sys_GetCoreID>
    8568:	4603      	mov	r3, r0
    856a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId])
    856c:	4a10      	ldr	r2, [pc, #64]	; (85b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    856e:	9b01      	ldr	r3, [sp, #4]
    8570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8574:	2b00      	cmp	r3, #0
    8576:	d10d      	bne.n	8594 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8578:	f7f8 fa37 	bl	9ea <Gpt_schm_read_msr>
    857c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    857e:	9b00      	ldr	r3, [sp, #0]
    8580:	f003 0301 	and.w	r3, r3, #1
    8584:	2b00      	cmp	r3, #0
    8586:	d100      	bne.n	858a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8588:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_35[u32CoreId] = msr;
    858a:	490a      	ldr	r1, [pc, #40]	; (85b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x54>)
    858c:	9b01      	ldr	r3, [sp, #4]
    858e:	9a00      	ldr	r2, [sp, #0]
    8590:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]++;
    8594:	4a06      	ldr	r2, [pc, #24]	; (85b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    8596:	9b01      	ldr	r3, [sp, #4]
    8598:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    859c:	1c5a      	adds	r2, r3, #1
    859e:	4904      	ldr	r1, [pc, #16]	; (85b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    85a0:	9b01      	ldr	r3, [sp, #4]
    85a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    85a6:	bf00      	nop
    85a8:	b003      	add	sp, #12
    85aa:	f85d fb04 	ldr.w	pc, [sp], #4
    85ae:	bf00      	nop
    85b0:	1fff8e74 	.word	0x1fff8e74
    85b4:	1fff8e70 	.word	0x1fff8e70

000085b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35(void)
{
    85b8:	b500      	push	{lr}
    85ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    85bc:	f7f8 faf6 	bl	bac <Sys_GetCoreID>
    85c0:	4603      	mov	r3, r0
    85c2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]--;
    85c4:	4a0d      	ldr	r2, [pc, #52]	; (85fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    85c6:	9b01      	ldr	r3, [sp, #4]
    85c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85cc:	1e5a      	subs	r2, r3, #1
    85ce:	490b      	ldr	r1, [pc, #44]	; (85fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    85d0:	9b01      	ldr	r3, [sp, #4]
    85d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_35[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]))         /*if interrupts were enabled*/
    85d6:	4a0a      	ldr	r2, [pc, #40]	; (8600 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x48>)
    85d8:	9b01      	ldr	r3, [sp, #4]
    85da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85de:	f003 0301 	and.w	r3, r3, #1
    85e2:	2b00      	cmp	r3, #0
    85e4:	d106      	bne.n	85f4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x3c>
    85e6:	4a05      	ldr	r2, [pc, #20]	; (85fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    85e8:	9b01      	ldr	r3, [sp, #4]
    85ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85ee:	2b00      	cmp	r3, #0
    85f0:	d100      	bne.n	85f4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    85f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    85f4:	bf00      	nop
    85f6:	b003      	add	sp, #12
    85f8:	f85d fb04 	ldr.w	pc, [sp], #4
    85fc:	1fff8e74 	.word	0x1fff8e74
    8600:	1fff8e70 	.word	0x1fff8e70

00008604 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36(void)
{
    8604:	b500      	push	{lr}
    8606:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8608:	f7f8 fad0 	bl	bac <Sys_GetCoreID>
    860c:	4603      	mov	r3, r0
    860e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId])
    8610:	4a10      	ldr	r2, [pc, #64]	; (8654 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    8612:	9b01      	ldr	r3, [sp, #4]
    8614:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8618:	2b00      	cmp	r3, #0
    861a:	d10d      	bne.n	8638 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    861c:	f7f8 f9e5 	bl	9ea <Gpt_schm_read_msr>
    8620:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8622:	9b00      	ldr	r3, [sp, #0]
    8624:	f003 0301 	and.w	r3, r3, #1
    8628:	2b00      	cmp	r3, #0
    862a:	d100      	bne.n	862e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    862c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_36[u32CoreId] = msr;
    862e:	490a      	ldr	r1, [pc, #40]	; (8658 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x54>)
    8630:	9b01      	ldr	r3, [sp, #4]
    8632:	9a00      	ldr	r2, [sp, #0]
    8634:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]++;
    8638:	4a06      	ldr	r2, [pc, #24]	; (8654 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    863a:	9b01      	ldr	r3, [sp, #4]
    863c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8640:	1c5a      	adds	r2, r3, #1
    8642:	4904      	ldr	r1, [pc, #16]	; (8654 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    8644:	9b01      	ldr	r3, [sp, #4]
    8646:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    864a:	bf00      	nop
    864c:	b003      	add	sp, #12
    864e:	f85d fb04 	ldr.w	pc, [sp], #4
    8652:	bf00      	nop
    8654:	1fff8e7c 	.word	0x1fff8e7c
    8658:	1fff8e78 	.word	0x1fff8e78

0000865c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36(void)
{
    865c:	b500      	push	{lr}
    865e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8660:	f7f8 faa4 	bl	bac <Sys_GetCoreID>
    8664:	4603      	mov	r3, r0
    8666:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]--;
    8668:	4a0d      	ldr	r2, [pc, #52]	; (86a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    866a:	9b01      	ldr	r3, [sp, #4]
    866c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8670:	1e5a      	subs	r2, r3, #1
    8672:	490b      	ldr	r1, [pc, #44]	; (86a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    8674:	9b01      	ldr	r3, [sp, #4]
    8676:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_36[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]))         /*if interrupts were enabled*/
    867a:	4a0a      	ldr	r2, [pc, #40]	; (86a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x48>)
    867c:	9b01      	ldr	r3, [sp, #4]
    867e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8682:	f003 0301 	and.w	r3, r3, #1
    8686:	2b00      	cmp	r3, #0
    8688:	d106      	bne.n	8698 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x3c>
    868a:	4a05      	ldr	r2, [pc, #20]	; (86a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    868c:	9b01      	ldr	r3, [sp, #4]
    868e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8692:	2b00      	cmp	r3, #0
    8694:	d100      	bne.n	8698 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8696:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8698:	bf00      	nop
    869a:	b003      	add	sp, #12
    869c:	f85d fb04 	ldr.w	pc, [sp], #4
    86a0:	1fff8e7c 	.word	0x1fff8e7c
    86a4:	1fff8e78 	.word	0x1fff8e78

000086a8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38(void)
{
    86a8:	b500      	push	{lr}
    86aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    86ac:	f7f8 fa7e 	bl	bac <Sys_GetCoreID>
    86b0:	4603      	mov	r3, r0
    86b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId])
    86b4:	4a10      	ldr	r2, [pc, #64]	; (86f8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    86b6:	9b01      	ldr	r3, [sp, #4]
    86b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86bc:	2b00      	cmp	r3, #0
    86be:	d10d      	bne.n	86dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    86c0:	f7f8 f993 	bl	9ea <Gpt_schm_read_msr>
    86c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    86c6:	9b00      	ldr	r3, [sp, #0]
    86c8:	f003 0301 	and.w	r3, r3, #1
    86cc:	2b00      	cmp	r3, #0
    86ce:	d100      	bne.n	86d2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    86d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_38[u32CoreId] = msr;
    86d2:	490a      	ldr	r1, [pc, #40]	; (86fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x54>)
    86d4:	9b01      	ldr	r3, [sp, #4]
    86d6:	9a00      	ldr	r2, [sp, #0]
    86d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]++;
    86dc:	4a06      	ldr	r2, [pc, #24]	; (86f8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    86de:	9b01      	ldr	r3, [sp, #4]
    86e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86e4:	1c5a      	adds	r2, r3, #1
    86e6:	4904      	ldr	r1, [pc, #16]	; (86f8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    86e8:	9b01      	ldr	r3, [sp, #4]
    86ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    86ee:	bf00      	nop
    86f0:	b003      	add	sp, #12
    86f2:	f85d fb04 	ldr.w	pc, [sp], #4
    86f6:	bf00      	nop
    86f8:	1fff8e84 	.word	0x1fff8e84
    86fc:	1fff8e80 	.word	0x1fff8e80

00008700 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38(void)
{
    8700:	b500      	push	{lr}
    8702:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8704:	f7f8 fa52 	bl	bac <Sys_GetCoreID>
    8708:	4603      	mov	r3, r0
    870a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]--;
    870c:	4a0d      	ldr	r2, [pc, #52]	; (8744 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    870e:	9b01      	ldr	r3, [sp, #4]
    8710:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8714:	1e5a      	subs	r2, r3, #1
    8716:	490b      	ldr	r1, [pc, #44]	; (8744 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    8718:	9b01      	ldr	r3, [sp, #4]
    871a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_38[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]))         /*if interrupts were enabled*/
    871e:	4a0a      	ldr	r2, [pc, #40]	; (8748 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x48>)
    8720:	9b01      	ldr	r3, [sp, #4]
    8722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8726:	f003 0301 	and.w	r3, r3, #1
    872a:	2b00      	cmp	r3, #0
    872c:	d106      	bne.n	873c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x3c>
    872e:	4a05      	ldr	r2, [pc, #20]	; (8744 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    8730:	9b01      	ldr	r3, [sp, #4]
    8732:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8736:	2b00      	cmp	r3, #0
    8738:	d100      	bne.n	873c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    873a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    873c:	bf00      	nop
    873e:	b003      	add	sp, #12
    8740:	f85d fb04 	ldr.w	pc, [sp], #4
    8744:	1fff8e84 	.word	0x1fff8e84
    8748:	1fff8e80 	.word	0x1fff8e80

0000874c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39(void)
{
    874c:	b500      	push	{lr}
    874e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8750:	f7f8 fa2c 	bl	bac <Sys_GetCoreID>
    8754:	4603      	mov	r3, r0
    8756:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId])
    8758:	4a10      	ldr	r2, [pc, #64]	; (879c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    875a:	9b01      	ldr	r3, [sp, #4]
    875c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8760:	2b00      	cmp	r3, #0
    8762:	d10d      	bne.n	8780 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8764:	f7f8 f941 	bl	9ea <Gpt_schm_read_msr>
    8768:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    876a:	9b00      	ldr	r3, [sp, #0]
    876c:	f003 0301 	and.w	r3, r3, #1
    8770:	2b00      	cmp	r3, #0
    8772:	d100      	bne.n	8776 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8774:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_39[u32CoreId] = msr;
    8776:	490a      	ldr	r1, [pc, #40]	; (87a0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x54>)
    8778:	9b01      	ldr	r3, [sp, #4]
    877a:	9a00      	ldr	r2, [sp, #0]
    877c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]++;
    8780:	4a06      	ldr	r2, [pc, #24]	; (879c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    8782:	9b01      	ldr	r3, [sp, #4]
    8784:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8788:	1c5a      	adds	r2, r3, #1
    878a:	4904      	ldr	r1, [pc, #16]	; (879c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    878c:	9b01      	ldr	r3, [sp, #4]
    878e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8792:	bf00      	nop
    8794:	b003      	add	sp, #12
    8796:	f85d fb04 	ldr.w	pc, [sp], #4
    879a:	bf00      	nop
    879c:	1fff8e8c 	.word	0x1fff8e8c
    87a0:	1fff8e88 	.word	0x1fff8e88

000087a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39(void)
{
    87a4:	b500      	push	{lr}
    87a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87a8:	f7f8 fa00 	bl	bac <Sys_GetCoreID>
    87ac:	4603      	mov	r3, r0
    87ae:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]--;
    87b0:	4a0d      	ldr	r2, [pc, #52]	; (87e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    87b2:	9b01      	ldr	r3, [sp, #4]
    87b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87b8:	1e5a      	subs	r2, r3, #1
    87ba:	490b      	ldr	r1, [pc, #44]	; (87e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    87bc:	9b01      	ldr	r3, [sp, #4]
    87be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_39[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]))         /*if interrupts were enabled*/
    87c2:	4a0a      	ldr	r2, [pc, #40]	; (87ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x48>)
    87c4:	9b01      	ldr	r3, [sp, #4]
    87c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87ca:	f003 0301 	and.w	r3, r3, #1
    87ce:	2b00      	cmp	r3, #0
    87d0:	d106      	bne.n	87e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x3c>
    87d2:	4a05      	ldr	r2, [pc, #20]	; (87e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    87d4:	9b01      	ldr	r3, [sp, #4]
    87d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87da:	2b00      	cmp	r3, #0
    87dc:	d100      	bne.n	87e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    87de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    87e0:	bf00      	nop
    87e2:	b003      	add	sp, #12
    87e4:	f85d fb04 	ldr.w	pc, [sp], #4
    87e8:	1fff8e8c 	.word	0x1fff8e8c
    87ec:	1fff8e88 	.word	0x1fff8e88

000087f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40(void)
{
    87f0:	b500      	push	{lr}
    87f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87f4:	f7f8 f9da 	bl	bac <Sys_GetCoreID>
    87f8:	4603      	mov	r3, r0
    87fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId])
    87fc:	4a10      	ldr	r2, [pc, #64]	; (8840 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    87fe:	9b01      	ldr	r3, [sp, #4]
    8800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8804:	2b00      	cmp	r3, #0
    8806:	d10d      	bne.n	8824 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8808:	f7f8 f8ef 	bl	9ea <Gpt_schm_read_msr>
    880c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    880e:	9b00      	ldr	r3, [sp, #0]
    8810:	f003 0301 	and.w	r3, r3, #1
    8814:	2b00      	cmp	r3, #0
    8816:	d100      	bne.n	881a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8818:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_40[u32CoreId] = msr;
    881a:	490a      	ldr	r1, [pc, #40]	; (8844 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x54>)
    881c:	9b01      	ldr	r3, [sp, #4]
    881e:	9a00      	ldr	r2, [sp, #0]
    8820:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]++;
    8824:	4a06      	ldr	r2, [pc, #24]	; (8840 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    8826:	9b01      	ldr	r3, [sp, #4]
    8828:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    882c:	1c5a      	adds	r2, r3, #1
    882e:	4904      	ldr	r1, [pc, #16]	; (8840 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    8830:	9b01      	ldr	r3, [sp, #4]
    8832:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8836:	bf00      	nop
    8838:	b003      	add	sp, #12
    883a:	f85d fb04 	ldr.w	pc, [sp], #4
    883e:	bf00      	nop
    8840:	1fff8e94 	.word	0x1fff8e94
    8844:	1fff8e90 	.word	0x1fff8e90

00008848 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40(void)
{
    8848:	b500      	push	{lr}
    884a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    884c:	f7f8 f9ae 	bl	bac <Sys_GetCoreID>
    8850:	4603      	mov	r3, r0
    8852:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]--;
    8854:	4a0d      	ldr	r2, [pc, #52]	; (888c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8856:	9b01      	ldr	r3, [sp, #4]
    8858:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    885c:	1e5a      	subs	r2, r3, #1
    885e:	490b      	ldr	r1, [pc, #44]	; (888c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8860:	9b01      	ldr	r3, [sp, #4]
    8862:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_40[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]))         /*if interrupts were enabled*/
    8866:	4a0a      	ldr	r2, [pc, #40]	; (8890 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x48>)
    8868:	9b01      	ldr	r3, [sp, #4]
    886a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    886e:	f003 0301 	and.w	r3, r3, #1
    8872:	2b00      	cmp	r3, #0
    8874:	d106      	bne.n	8884 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x3c>
    8876:	4a05      	ldr	r2, [pc, #20]	; (888c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8878:	9b01      	ldr	r3, [sp, #4]
    887a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    887e:	2b00      	cmp	r3, #0
    8880:	d100      	bne.n	8884 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8882:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8884:	bf00      	nop
    8886:	b003      	add	sp, #12
    8888:	f85d fb04 	ldr.w	pc, [sp], #4
    888c:	1fff8e94 	.word	0x1fff8e94
    8890:	1fff8e90 	.word	0x1fff8e90

00008894 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41(void)
{
    8894:	b500      	push	{lr}
    8896:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8898:	f7f8 f988 	bl	bac <Sys_GetCoreID>
    889c:	4603      	mov	r3, r0
    889e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId])
    88a0:	4a10      	ldr	r2, [pc, #64]	; (88e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    88a2:	9b01      	ldr	r3, [sp, #4]
    88a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88a8:	2b00      	cmp	r3, #0
    88aa:	d10d      	bne.n	88c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    88ac:	f7f8 f89d 	bl	9ea <Gpt_schm_read_msr>
    88b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    88b2:	9b00      	ldr	r3, [sp, #0]
    88b4:	f003 0301 	and.w	r3, r3, #1
    88b8:	2b00      	cmp	r3, #0
    88ba:	d100      	bne.n	88be <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    88bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_41[u32CoreId] = msr;
    88be:	490a      	ldr	r1, [pc, #40]	; (88e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x54>)
    88c0:	9b01      	ldr	r3, [sp, #4]
    88c2:	9a00      	ldr	r2, [sp, #0]
    88c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]++;
    88c8:	4a06      	ldr	r2, [pc, #24]	; (88e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    88ca:	9b01      	ldr	r3, [sp, #4]
    88cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88d0:	1c5a      	adds	r2, r3, #1
    88d2:	4904      	ldr	r1, [pc, #16]	; (88e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    88d4:	9b01      	ldr	r3, [sp, #4]
    88d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    88da:	bf00      	nop
    88dc:	b003      	add	sp, #12
    88de:	f85d fb04 	ldr.w	pc, [sp], #4
    88e2:	bf00      	nop
    88e4:	1fff8e9c 	.word	0x1fff8e9c
    88e8:	1fff8e98 	.word	0x1fff8e98

000088ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41(void)
{
    88ec:	b500      	push	{lr}
    88ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    88f0:	f7f8 f95c 	bl	bac <Sys_GetCoreID>
    88f4:	4603      	mov	r3, r0
    88f6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]--;
    88f8:	4a0d      	ldr	r2, [pc, #52]	; (8930 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    88fa:	9b01      	ldr	r3, [sp, #4]
    88fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8900:	1e5a      	subs	r2, r3, #1
    8902:	490b      	ldr	r1, [pc, #44]	; (8930 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    8904:	9b01      	ldr	r3, [sp, #4]
    8906:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_41[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]))         /*if interrupts were enabled*/
    890a:	4a0a      	ldr	r2, [pc, #40]	; (8934 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x48>)
    890c:	9b01      	ldr	r3, [sp, #4]
    890e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8912:	f003 0301 	and.w	r3, r3, #1
    8916:	2b00      	cmp	r3, #0
    8918:	d106      	bne.n	8928 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x3c>
    891a:	4a05      	ldr	r2, [pc, #20]	; (8930 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    891c:	9b01      	ldr	r3, [sp, #4]
    891e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8922:	2b00      	cmp	r3, #0
    8924:	d100      	bne.n	8928 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8926:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8928:	bf00      	nop
    892a:	b003      	add	sp, #12
    892c:	f85d fb04 	ldr.w	pc, [sp], #4
    8930:	1fff8e9c 	.word	0x1fff8e9c
    8934:	1fff8e98 	.word	0x1fff8e98

00008938 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42(void)
{
    8938:	b500      	push	{lr}
    893a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    893c:	f7f8 f936 	bl	bac <Sys_GetCoreID>
    8940:	4603      	mov	r3, r0
    8942:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId])
    8944:	4a10      	ldr	r2, [pc, #64]	; (8988 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    8946:	9b01      	ldr	r3, [sp, #4]
    8948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    894c:	2b00      	cmp	r3, #0
    894e:	d10d      	bne.n	896c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8950:	f7f8 f84b 	bl	9ea <Gpt_schm_read_msr>
    8954:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8956:	9b00      	ldr	r3, [sp, #0]
    8958:	f003 0301 	and.w	r3, r3, #1
    895c:	2b00      	cmp	r3, #0
    895e:	d100      	bne.n	8962 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8960:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_42[u32CoreId] = msr;
    8962:	490a      	ldr	r1, [pc, #40]	; (898c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x54>)
    8964:	9b01      	ldr	r3, [sp, #4]
    8966:	9a00      	ldr	r2, [sp, #0]
    8968:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]++;
    896c:	4a06      	ldr	r2, [pc, #24]	; (8988 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    896e:	9b01      	ldr	r3, [sp, #4]
    8970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8974:	1c5a      	adds	r2, r3, #1
    8976:	4904      	ldr	r1, [pc, #16]	; (8988 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    8978:	9b01      	ldr	r3, [sp, #4]
    897a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    897e:	bf00      	nop
    8980:	b003      	add	sp, #12
    8982:	f85d fb04 	ldr.w	pc, [sp], #4
    8986:	bf00      	nop
    8988:	1fff8ea4 	.word	0x1fff8ea4
    898c:	1fff8ea0 	.word	0x1fff8ea0

00008990 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42(void)
{
    8990:	b500      	push	{lr}
    8992:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8994:	f7f8 f90a 	bl	bac <Sys_GetCoreID>
    8998:	4603      	mov	r3, r0
    899a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]--;
    899c:	4a0d      	ldr	r2, [pc, #52]	; (89d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    899e:	9b01      	ldr	r3, [sp, #4]
    89a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89a4:	1e5a      	subs	r2, r3, #1
    89a6:	490b      	ldr	r1, [pc, #44]	; (89d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    89a8:	9b01      	ldr	r3, [sp, #4]
    89aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_42[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]))         /*if interrupts were enabled*/
    89ae:	4a0a      	ldr	r2, [pc, #40]	; (89d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x48>)
    89b0:	9b01      	ldr	r3, [sp, #4]
    89b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89b6:	f003 0301 	and.w	r3, r3, #1
    89ba:	2b00      	cmp	r3, #0
    89bc:	d106      	bne.n	89cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x3c>
    89be:	4a05      	ldr	r2, [pc, #20]	; (89d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    89c0:	9b01      	ldr	r3, [sp, #4]
    89c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89c6:	2b00      	cmp	r3, #0
    89c8:	d100      	bne.n	89cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    89ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    89cc:	bf00      	nop
    89ce:	b003      	add	sp, #12
    89d0:	f85d fb04 	ldr.w	pc, [sp], #4
    89d4:	1fff8ea4 	.word	0x1fff8ea4
    89d8:	1fff8ea0 	.word	0x1fff8ea0

000089dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43(void)
{
    89dc:	b500      	push	{lr}
    89de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    89e0:	f7f8 f8e4 	bl	bac <Sys_GetCoreID>
    89e4:	4603      	mov	r3, r0
    89e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId])
    89e8:	4a10      	ldr	r2, [pc, #64]	; (8a2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    89ea:	9b01      	ldr	r3, [sp, #4]
    89ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89f0:	2b00      	cmp	r3, #0
    89f2:	d10d      	bne.n	8a10 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    89f4:	f7f7 fff9 	bl	9ea <Gpt_schm_read_msr>
    89f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    89fa:	9b00      	ldr	r3, [sp, #0]
    89fc:	f003 0301 	and.w	r3, r3, #1
    8a00:	2b00      	cmp	r3, #0
    8a02:	d100      	bne.n	8a06 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8a04:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_43[u32CoreId] = msr;
    8a06:	490a      	ldr	r1, [pc, #40]	; (8a30 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x54>)
    8a08:	9b01      	ldr	r3, [sp, #4]
    8a0a:	9a00      	ldr	r2, [sp, #0]
    8a0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]++;
    8a10:	4a06      	ldr	r2, [pc, #24]	; (8a2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    8a12:	9b01      	ldr	r3, [sp, #4]
    8a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a18:	1c5a      	adds	r2, r3, #1
    8a1a:	4904      	ldr	r1, [pc, #16]	; (8a2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    8a1c:	9b01      	ldr	r3, [sp, #4]
    8a1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8a22:	bf00      	nop
    8a24:	b003      	add	sp, #12
    8a26:	f85d fb04 	ldr.w	pc, [sp], #4
    8a2a:	bf00      	nop
    8a2c:	1fff8eac 	.word	0x1fff8eac
    8a30:	1fff8ea8 	.word	0x1fff8ea8

00008a34 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43(void)
{
    8a34:	b500      	push	{lr}
    8a36:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a38:	f7f8 f8b8 	bl	bac <Sys_GetCoreID>
    8a3c:	4603      	mov	r3, r0
    8a3e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]--;
    8a40:	4a0d      	ldr	r2, [pc, #52]	; (8a78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    8a42:	9b01      	ldr	r3, [sp, #4]
    8a44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a48:	1e5a      	subs	r2, r3, #1
    8a4a:	490b      	ldr	r1, [pc, #44]	; (8a78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    8a4c:	9b01      	ldr	r3, [sp, #4]
    8a4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_43[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]))         /*if interrupts were enabled*/
    8a52:	4a0a      	ldr	r2, [pc, #40]	; (8a7c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x48>)
    8a54:	9b01      	ldr	r3, [sp, #4]
    8a56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a5a:	f003 0301 	and.w	r3, r3, #1
    8a5e:	2b00      	cmp	r3, #0
    8a60:	d106      	bne.n	8a70 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x3c>
    8a62:	4a05      	ldr	r2, [pc, #20]	; (8a78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    8a64:	9b01      	ldr	r3, [sp, #4]
    8a66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a6a:	2b00      	cmp	r3, #0
    8a6c:	d100      	bne.n	8a70 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8a6e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8a70:	bf00      	nop
    8a72:	b003      	add	sp, #12
    8a74:	f85d fb04 	ldr.w	pc, [sp], #4
    8a78:	1fff8eac 	.word	0x1fff8eac
    8a7c:	1fff8ea8 	.word	0x1fff8ea8

00008a80 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44(void)
{
    8a80:	b500      	push	{lr}
    8a82:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a84:	f7f8 f892 	bl	bac <Sys_GetCoreID>
    8a88:	4603      	mov	r3, r0
    8a8a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId])
    8a8c:	4a10      	ldr	r2, [pc, #64]	; (8ad0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    8a8e:	9b01      	ldr	r3, [sp, #4]
    8a90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a94:	2b00      	cmp	r3, #0
    8a96:	d10d      	bne.n	8ab4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8a98:	f7f7 ffa7 	bl	9ea <Gpt_schm_read_msr>
    8a9c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8a9e:	9b00      	ldr	r3, [sp, #0]
    8aa0:	f003 0301 	and.w	r3, r3, #1
    8aa4:	2b00      	cmp	r3, #0
    8aa6:	d100      	bne.n	8aaa <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8aa8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_44[u32CoreId] = msr;
    8aaa:	490a      	ldr	r1, [pc, #40]	; (8ad4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x54>)
    8aac:	9b01      	ldr	r3, [sp, #4]
    8aae:	9a00      	ldr	r2, [sp, #0]
    8ab0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]++;
    8ab4:	4a06      	ldr	r2, [pc, #24]	; (8ad0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    8ab6:	9b01      	ldr	r3, [sp, #4]
    8ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8abc:	1c5a      	adds	r2, r3, #1
    8abe:	4904      	ldr	r1, [pc, #16]	; (8ad0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    8ac0:	9b01      	ldr	r3, [sp, #4]
    8ac2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8ac6:	bf00      	nop
    8ac8:	b003      	add	sp, #12
    8aca:	f85d fb04 	ldr.w	pc, [sp], #4
    8ace:	bf00      	nop
    8ad0:	1fff8eb4 	.word	0x1fff8eb4
    8ad4:	1fff8eb0 	.word	0x1fff8eb0

00008ad8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44(void)
{
    8ad8:	b500      	push	{lr}
    8ada:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8adc:	f7f8 f866 	bl	bac <Sys_GetCoreID>
    8ae0:	4603      	mov	r3, r0
    8ae2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]--;
    8ae4:	4a0d      	ldr	r2, [pc, #52]	; (8b1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    8ae6:	9b01      	ldr	r3, [sp, #4]
    8ae8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aec:	1e5a      	subs	r2, r3, #1
    8aee:	490b      	ldr	r1, [pc, #44]	; (8b1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    8af0:	9b01      	ldr	r3, [sp, #4]
    8af2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_44[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]))         /*if interrupts were enabled*/
    8af6:	4a0a      	ldr	r2, [pc, #40]	; (8b20 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x48>)
    8af8:	9b01      	ldr	r3, [sp, #4]
    8afa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8afe:	f003 0301 	and.w	r3, r3, #1
    8b02:	2b00      	cmp	r3, #0
    8b04:	d106      	bne.n	8b14 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x3c>
    8b06:	4a05      	ldr	r2, [pc, #20]	; (8b1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    8b08:	9b01      	ldr	r3, [sp, #4]
    8b0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b0e:	2b00      	cmp	r3, #0
    8b10:	d100      	bne.n	8b14 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8b12:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8b14:	bf00      	nop
    8b16:	b003      	add	sp, #12
    8b18:	f85d fb04 	ldr.w	pc, [sp], #4
    8b1c:	1fff8eb4 	.word	0x1fff8eb4
    8b20:	1fff8eb0 	.word	0x1fff8eb0

00008b24 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45(void)
{
    8b24:	b500      	push	{lr}
    8b26:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b28:	f7f8 f840 	bl	bac <Sys_GetCoreID>
    8b2c:	4603      	mov	r3, r0
    8b2e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId])
    8b30:	4a10      	ldr	r2, [pc, #64]	; (8b74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    8b32:	9b01      	ldr	r3, [sp, #4]
    8b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b38:	2b00      	cmp	r3, #0
    8b3a:	d10d      	bne.n	8b58 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8b3c:	f7f7 ff55 	bl	9ea <Gpt_schm_read_msr>
    8b40:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8b42:	9b00      	ldr	r3, [sp, #0]
    8b44:	f003 0301 	and.w	r3, r3, #1
    8b48:	2b00      	cmp	r3, #0
    8b4a:	d100      	bne.n	8b4e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8b4c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_45[u32CoreId] = msr;
    8b4e:	490a      	ldr	r1, [pc, #40]	; (8b78 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x54>)
    8b50:	9b01      	ldr	r3, [sp, #4]
    8b52:	9a00      	ldr	r2, [sp, #0]
    8b54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]++;
    8b58:	4a06      	ldr	r2, [pc, #24]	; (8b74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    8b5a:	9b01      	ldr	r3, [sp, #4]
    8b5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b60:	1c5a      	adds	r2, r3, #1
    8b62:	4904      	ldr	r1, [pc, #16]	; (8b74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    8b64:	9b01      	ldr	r3, [sp, #4]
    8b66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8b6a:	bf00      	nop
    8b6c:	b003      	add	sp, #12
    8b6e:	f85d fb04 	ldr.w	pc, [sp], #4
    8b72:	bf00      	nop
    8b74:	1fff8ebc 	.word	0x1fff8ebc
    8b78:	1fff8eb8 	.word	0x1fff8eb8

00008b7c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45(void)
{
    8b7c:	b500      	push	{lr}
    8b7e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b80:	f7f8 f814 	bl	bac <Sys_GetCoreID>
    8b84:	4603      	mov	r3, r0
    8b86:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]--;
    8b88:	4a0d      	ldr	r2, [pc, #52]	; (8bc0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    8b8a:	9b01      	ldr	r3, [sp, #4]
    8b8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b90:	1e5a      	subs	r2, r3, #1
    8b92:	490b      	ldr	r1, [pc, #44]	; (8bc0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    8b94:	9b01      	ldr	r3, [sp, #4]
    8b96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_45[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]))         /*if interrupts were enabled*/
    8b9a:	4a0a      	ldr	r2, [pc, #40]	; (8bc4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x48>)
    8b9c:	9b01      	ldr	r3, [sp, #4]
    8b9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ba2:	f003 0301 	and.w	r3, r3, #1
    8ba6:	2b00      	cmp	r3, #0
    8ba8:	d106      	bne.n	8bb8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x3c>
    8baa:	4a05      	ldr	r2, [pc, #20]	; (8bc0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    8bac:	9b01      	ldr	r3, [sp, #4]
    8bae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bb2:	2b00      	cmp	r3, #0
    8bb4:	d100      	bne.n	8bb8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8bb6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8bb8:	bf00      	nop
    8bba:	b003      	add	sp, #12
    8bbc:	f85d fb04 	ldr.w	pc, [sp], #4
    8bc0:	1fff8ebc 	.word	0x1fff8ebc
    8bc4:	1fff8eb8 	.word	0x1fff8eb8

00008bc8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46(void)
{
    8bc8:	b500      	push	{lr}
    8bca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8bcc:	f7f7 ffee 	bl	bac <Sys_GetCoreID>
    8bd0:	4603      	mov	r3, r0
    8bd2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId])
    8bd4:	4a10      	ldr	r2, [pc, #64]	; (8c18 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    8bd6:	9b01      	ldr	r3, [sp, #4]
    8bd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bdc:	2b00      	cmp	r3, #0
    8bde:	d10d      	bne.n	8bfc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8be0:	f7f7 ff03 	bl	9ea <Gpt_schm_read_msr>
    8be4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8be6:	9b00      	ldr	r3, [sp, #0]
    8be8:	f003 0301 	and.w	r3, r3, #1
    8bec:	2b00      	cmp	r3, #0
    8bee:	d100      	bne.n	8bf2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8bf0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_46[u32CoreId] = msr;
    8bf2:	490a      	ldr	r1, [pc, #40]	; (8c1c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x54>)
    8bf4:	9b01      	ldr	r3, [sp, #4]
    8bf6:	9a00      	ldr	r2, [sp, #0]
    8bf8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]++;
    8bfc:	4a06      	ldr	r2, [pc, #24]	; (8c18 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    8bfe:	9b01      	ldr	r3, [sp, #4]
    8c00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c04:	1c5a      	adds	r2, r3, #1
    8c06:	4904      	ldr	r1, [pc, #16]	; (8c18 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    8c08:	9b01      	ldr	r3, [sp, #4]
    8c0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8c0e:	bf00      	nop
    8c10:	b003      	add	sp, #12
    8c12:	f85d fb04 	ldr.w	pc, [sp], #4
    8c16:	bf00      	nop
    8c18:	1fff8ec4 	.word	0x1fff8ec4
    8c1c:	1fff8ec0 	.word	0x1fff8ec0

00008c20 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46(void)
{
    8c20:	b500      	push	{lr}
    8c22:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c24:	f7f7 ffc2 	bl	bac <Sys_GetCoreID>
    8c28:	4603      	mov	r3, r0
    8c2a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]--;
    8c2c:	4a0d      	ldr	r2, [pc, #52]	; (8c64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    8c2e:	9b01      	ldr	r3, [sp, #4]
    8c30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c34:	1e5a      	subs	r2, r3, #1
    8c36:	490b      	ldr	r1, [pc, #44]	; (8c64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    8c38:	9b01      	ldr	r3, [sp, #4]
    8c3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_46[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]))         /*if interrupts were enabled*/
    8c3e:	4a0a      	ldr	r2, [pc, #40]	; (8c68 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x48>)
    8c40:	9b01      	ldr	r3, [sp, #4]
    8c42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c46:	f003 0301 	and.w	r3, r3, #1
    8c4a:	2b00      	cmp	r3, #0
    8c4c:	d106      	bne.n	8c5c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x3c>
    8c4e:	4a05      	ldr	r2, [pc, #20]	; (8c64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    8c50:	9b01      	ldr	r3, [sp, #4]
    8c52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c56:	2b00      	cmp	r3, #0
    8c58:	d100      	bne.n	8c5c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8c5a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8c5c:	bf00      	nop
    8c5e:	b003      	add	sp, #12
    8c60:	f85d fb04 	ldr.w	pc, [sp], #4
    8c64:	1fff8ec4 	.word	0x1fff8ec4
    8c68:	1fff8ec0 	.word	0x1fff8ec0

00008c6c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50(void)
{
    8c6c:	b500      	push	{lr}
    8c6e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c70:	f7f7 ff9c 	bl	bac <Sys_GetCoreID>
    8c74:	4603      	mov	r3, r0
    8c76:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId])
    8c78:	4a10      	ldr	r2, [pc, #64]	; (8cbc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    8c7a:	9b01      	ldr	r3, [sp, #4]
    8c7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c80:	2b00      	cmp	r3, #0
    8c82:	d10d      	bne.n	8ca0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8c84:	f7f7 feb1 	bl	9ea <Gpt_schm_read_msr>
    8c88:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8c8a:	9b00      	ldr	r3, [sp, #0]
    8c8c:	f003 0301 	and.w	r3, r3, #1
    8c90:	2b00      	cmp	r3, #0
    8c92:	d100      	bne.n	8c96 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8c94:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_50[u32CoreId] = msr;
    8c96:	490a      	ldr	r1, [pc, #40]	; (8cc0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x54>)
    8c98:	9b01      	ldr	r3, [sp, #4]
    8c9a:	9a00      	ldr	r2, [sp, #0]
    8c9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]++;
    8ca0:	4a06      	ldr	r2, [pc, #24]	; (8cbc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    8ca2:	9b01      	ldr	r3, [sp, #4]
    8ca4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ca8:	1c5a      	adds	r2, r3, #1
    8caa:	4904      	ldr	r1, [pc, #16]	; (8cbc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    8cac:	9b01      	ldr	r3, [sp, #4]
    8cae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8cb2:	bf00      	nop
    8cb4:	b003      	add	sp, #12
    8cb6:	f85d fb04 	ldr.w	pc, [sp], #4
    8cba:	bf00      	nop
    8cbc:	1fff8ecc 	.word	0x1fff8ecc
    8cc0:	1fff8ec8 	.word	0x1fff8ec8

00008cc4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50(void)
{
    8cc4:	b500      	push	{lr}
    8cc6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8cc8:	f7f7 ff70 	bl	bac <Sys_GetCoreID>
    8ccc:	4603      	mov	r3, r0
    8cce:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]--;
    8cd0:	4a0d      	ldr	r2, [pc, #52]	; (8d08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    8cd2:	9b01      	ldr	r3, [sp, #4]
    8cd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cd8:	1e5a      	subs	r2, r3, #1
    8cda:	490b      	ldr	r1, [pc, #44]	; (8d08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    8cdc:	9b01      	ldr	r3, [sp, #4]
    8cde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_50[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]))         /*if interrupts were enabled*/
    8ce2:	4a0a      	ldr	r2, [pc, #40]	; (8d0c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x48>)
    8ce4:	9b01      	ldr	r3, [sp, #4]
    8ce6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cea:	f003 0301 	and.w	r3, r3, #1
    8cee:	2b00      	cmp	r3, #0
    8cf0:	d106      	bne.n	8d00 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x3c>
    8cf2:	4a05      	ldr	r2, [pc, #20]	; (8d08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    8cf4:	9b01      	ldr	r3, [sp, #4]
    8cf6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cfa:	2b00      	cmp	r3, #0
    8cfc:	d100      	bne.n	8d00 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8cfe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8d00:	bf00      	nop
    8d02:	b003      	add	sp, #12
    8d04:	f85d fb04 	ldr.w	pc, [sp], #4
    8d08:	1fff8ecc 	.word	0x1fff8ecc
    8d0c:	1fff8ec8 	.word	0x1fff8ec8

00008d10 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51(void)
{
    8d10:	b500      	push	{lr}
    8d12:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d14:	f7f7 ff4a 	bl	bac <Sys_GetCoreID>
    8d18:	4603      	mov	r3, r0
    8d1a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId])
    8d1c:	4a10      	ldr	r2, [pc, #64]	; (8d60 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    8d1e:	9b01      	ldr	r3, [sp, #4]
    8d20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d24:	2b00      	cmp	r3, #0
    8d26:	d10d      	bne.n	8d44 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8d28:	f7f7 fe5f 	bl	9ea <Gpt_schm_read_msr>
    8d2c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8d2e:	9b00      	ldr	r3, [sp, #0]
    8d30:	f003 0301 	and.w	r3, r3, #1
    8d34:	2b00      	cmp	r3, #0
    8d36:	d100      	bne.n	8d3a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8d38:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_51[u32CoreId] = msr;
    8d3a:	490a      	ldr	r1, [pc, #40]	; (8d64 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x54>)
    8d3c:	9b01      	ldr	r3, [sp, #4]
    8d3e:	9a00      	ldr	r2, [sp, #0]
    8d40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]++;
    8d44:	4a06      	ldr	r2, [pc, #24]	; (8d60 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    8d46:	9b01      	ldr	r3, [sp, #4]
    8d48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d4c:	1c5a      	adds	r2, r3, #1
    8d4e:	4904      	ldr	r1, [pc, #16]	; (8d60 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    8d50:	9b01      	ldr	r3, [sp, #4]
    8d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8d56:	bf00      	nop
    8d58:	b003      	add	sp, #12
    8d5a:	f85d fb04 	ldr.w	pc, [sp], #4
    8d5e:	bf00      	nop
    8d60:	1fff8ed4 	.word	0x1fff8ed4
    8d64:	1fff8ed0 	.word	0x1fff8ed0

00008d68 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51(void)
{
    8d68:	b500      	push	{lr}
    8d6a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d6c:	f7f7 ff1e 	bl	bac <Sys_GetCoreID>
    8d70:	4603      	mov	r3, r0
    8d72:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]--;
    8d74:	4a0d      	ldr	r2, [pc, #52]	; (8dac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    8d76:	9b01      	ldr	r3, [sp, #4]
    8d78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d7c:	1e5a      	subs	r2, r3, #1
    8d7e:	490b      	ldr	r1, [pc, #44]	; (8dac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    8d80:	9b01      	ldr	r3, [sp, #4]
    8d82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_51[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]))         /*if interrupts were enabled*/
    8d86:	4a0a      	ldr	r2, [pc, #40]	; (8db0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x48>)
    8d88:	9b01      	ldr	r3, [sp, #4]
    8d8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d8e:	f003 0301 	and.w	r3, r3, #1
    8d92:	2b00      	cmp	r3, #0
    8d94:	d106      	bne.n	8da4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x3c>
    8d96:	4a05      	ldr	r2, [pc, #20]	; (8dac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    8d98:	9b01      	ldr	r3, [sp, #4]
    8d9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d9e:	2b00      	cmp	r3, #0
    8da0:	d100      	bne.n	8da4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8da2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8da4:	bf00      	nop
    8da6:	b003      	add	sp, #12
    8da8:	f85d fb04 	ldr.w	pc, [sp], #4
    8dac:	1fff8ed4 	.word	0x1fff8ed4
    8db0:	1fff8ed0 	.word	0x1fff8ed0

00008db4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52(void)
{
    8db4:	b500      	push	{lr}
    8db6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8db8:	f7f7 fef8 	bl	bac <Sys_GetCoreID>
    8dbc:	4603      	mov	r3, r0
    8dbe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId])
    8dc0:	4a10      	ldr	r2, [pc, #64]	; (8e04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    8dc2:	9b01      	ldr	r3, [sp, #4]
    8dc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dc8:	2b00      	cmp	r3, #0
    8dca:	d10d      	bne.n	8de8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8dcc:	f7f7 fe0d 	bl	9ea <Gpt_schm_read_msr>
    8dd0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8dd2:	9b00      	ldr	r3, [sp, #0]
    8dd4:	f003 0301 	and.w	r3, r3, #1
    8dd8:	2b00      	cmp	r3, #0
    8dda:	d100      	bne.n	8dde <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8ddc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_52[u32CoreId] = msr;
    8dde:	490a      	ldr	r1, [pc, #40]	; (8e08 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x54>)
    8de0:	9b01      	ldr	r3, [sp, #4]
    8de2:	9a00      	ldr	r2, [sp, #0]
    8de4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]++;
    8de8:	4a06      	ldr	r2, [pc, #24]	; (8e04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    8dea:	9b01      	ldr	r3, [sp, #4]
    8dec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8df0:	1c5a      	adds	r2, r3, #1
    8df2:	4904      	ldr	r1, [pc, #16]	; (8e04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    8df4:	9b01      	ldr	r3, [sp, #4]
    8df6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8dfa:	bf00      	nop
    8dfc:	b003      	add	sp, #12
    8dfe:	f85d fb04 	ldr.w	pc, [sp], #4
    8e02:	bf00      	nop
    8e04:	1fff8edc 	.word	0x1fff8edc
    8e08:	1fff8ed8 	.word	0x1fff8ed8

00008e0c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52(void)
{
    8e0c:	b500      	push	{lr}
    8e0e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e10:	f7f7 fecc 	bl	bac <Sys_GetCoreID>
    8e14:	4603      	mov	r3, r0
    8e16:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]--;
    8e18:	4a0d      	ldr	r2, [pc, #52]	; (8e50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    8e1a:	9b01      	ldr	r3, [sp, #4]
    8e1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e20:	1e5a      	subs	r2, r3, #1
    8e22:	490b      	ldr	r1, [pc, #44]	; (8e50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    8e24:	9b01      	ldr	r3, [sp, #4]
    8e26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_52[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]))         /*if interrupts were enabled*/
    8e2a:	4a0a      	ldr	r2, [pc, #40]	; (8e54 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x48>)
    8e2c:	9b01      	ldr	r3, [sp, #4]
    8e2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e32:	f003 0301 	and.w	r3, r3, #1
    8e36:	2b00      	cmp	r3, #0
    8e38:	d106      	bne.n	8e48 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x3c>
    8e3a:	4a05      	ldr	r2, [pc, #20]	; (8e50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    8e3c:	9b01      	ldr	r3, [sp, #4]
    8e3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e42:	2b00      	cmp	r3, #0
    8e44:	d100      	bne.n	8e48 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8e46:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8e48:	bf00      	nop
    8e4a:	b003      	add	sp, #12
    8e4c:	f85d fb04 	ldr.w	pc, [sp], #4
    8e50:	1fff8edc 	.word	0x1fff8edc
    8e54:	1fff8ed8 	.word	0x1fff8ed8

00008e58 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53(void)
{
    8e58:	b500      	push	{lr}
    8e5a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e5c:	f7f7 fea6 	bl	bac <Sys_GetCoreID>
    8e60:	4603      	mov	r3, r0
    8e62:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId])
    8e64:	4a10      	ldr	r2, [pc, #64]	; (8ea8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    8e66:	9b01      	ldr	r3, [sp, #4]
    8e68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e6c:	2b00      	cmp	r3, #0
    8e6e:	d10d      	bne.n	8e8c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8e70:	f7f7 fdbb 	bl	9ea <Gpt_schm_read_msr>
    8e74:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8e76:	9b00      	ldr	r3, [sp, #0]
    8e78:	f003 0301 	and.w	r3, r3, #1
    8e7c:	2b00      	cmp	r3, #0
    8e7e:	d100      	bne.n	8e82 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8e80:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_53[u32CoreId] = msr;
    8e82:	490a      	ldr	r1, [pc, #40]	; (8eac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x54>)
    8e84:	9b01      	ldr	r3, [sp, #4]
    8e86:	9a00      	ldr	r2, [sp, #0]
    8e88:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]++;
    8e8c:	4a06      	ldr	r2, [pc, #24]	; (8ea8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    8e8e:	9b01      	ldr	r3, [sp, #4]
    8e90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e94:	1c5a      	adds	r2, r3, #1
    8e96:	4904      	ldr	r1, [pc, #16]	; (8ea8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    8e98:	9b01      	ldr	r3, [sp, #4]
    8e9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8e9e:	bf00      	nop
    8ea0:	b003      	add	sp, #12
    8ea2:	f85d fb04 	ldr.w	pc, [sp], #4
    8ea6:	bf00      	nop
    8ea8:	1fff8ee4 	.word	0x1fff8ee4
    8eac:	1fff8ee0 	.word	0x1fff8ee0

00008eb0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53(void)
{
    8eb0:	b500      	push	{lr}
    8eb2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8eb4:	f7f7 fe7a 	bl	bac <Sys_GetCoreID>
    8eb8:	4603      	mov	r3, r0
    8eba:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]--;
    8ebc:	4a0d      	ldr	r2, [pc, #52]	; (8ef4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    8ebe:	9b01      	ldr	r3, [sp, #4]
    8ec0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ec4:	1e5a      	subs	r2, r3, #1
    8ec6:	490b      	ldr	r1, [pc, #44]	; (8ef4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    8ec8:	9b01      	ldr	r3, [sp, #4]
    8eca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_53[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]))         /*if interrupts were enabled*/
    8ece:	4a0a      	ldr	r2, [pc, #40]	; (8ef8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x48>)
    8ed0:	9b01      	ldr	r3, [sp, #4]
    8ed2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ed6:	f003 0301 	and.w	r3, r3, #1
    8eda:	2b00      	cmp	r3, #0
    8edc:	d106      	bne.n	8eec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x3c>
    8ede:	4a05      	ldr	r2, [pc, #20]	; (8ef4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    8ee0:	9b01      	ldr	r3, [sp, #4]
    8ee2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ee6:	2b00      	cmp	r3, #0
    8ee8:	d100      	bne.n	8eec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8eea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8eec:	bf00      	nop
    8eee:	b003      	add	sp, #12
    8ef0:	f85d fb04 	ldr.w	pc, [sp], #4
    8ef4:	1fff8ee4 	.word	0x1fff8ee4
    8ef8:	1fff8ee0 	.word	0x1fff8ee0

00008efc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54(void)
{
    8efc:	b500      	push	{lr}
    8efe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f00:	f7f7 fe54 	bl	bac <Sys_GetCoreID>
    8f04:	4603      	mov	r3, r0
    8f06:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId])
    8f08:	4a10      	ldr	r2, [pc, #64]	; (8f4c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    8f0a:	9b01      	ldr	r3, [sp, #4]
    8f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f10:	2b00      	cmp	r3, #0
    8f12:	d10d      	bne.n	8f30 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8f14:	f7f7 fd69 	bl	9ea <Gpt_schm_read_msr>
    8f18:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8f1a:	9b00      	ldr	r3, [sp, #0]
    8f1c:	f003 0301 	and.w	r3, r3, #1
    8f20:	2b00      	cmp	r3, #0
    8f22:	d100      	bne.n	8f26 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8f24:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_54[u32CoreId] = msr;
    8f26:	490a      	ldr	r1, [pc, #40]	; (8f50 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x54>)
    8f28:	9b01      	ldr	r3, [sp, #4]
    8f2a:	9a00      	ldr	r2, [sp, #0]
    8f2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]++;
    8f30:	4a06      	ldr	r2, [pc, #24]	; (8f4c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    8f32:	9b01      	ldr	r3, [sp, #4]
    8f34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f38:	1c5a      	adds	r2, r3, #1
    8f3a:	4904      	ldr	r1, [pc, #16]	; (8f4c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    8f3c:	9b01      	ldr	r3, [sp, #4]
    8f3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8f42:	bf00      	nop
    8f44:	b003      	add	sp, #12
    8f46:	f85d fb04 	ldr.w	pc, [sp], #4
    8f4a:	bf00      	nop
    8f4c:	1fff8eec 	.word	0x1fff8eec
    8f50:	1fff8ee8 	.word	0x1fff8ee8

00008f54 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54(void)
{
    8f54:	b500      	push	{lr}
    8f56:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f58:	f7f7 fe28 	bl	bac <Sys_GetCoreID>
    8f5c:	4603      	mov	r3, r0
    8f5e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]--;
    8f60:	4a0d      	ldr	r2, [pc, #52]	; (8f98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    8f62:	9b01      	ldr	r3, [sp, #4]
    8f64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f68:	1e5a      	subs	r2, r3, #1
    8f6a:	490b      	ldr	r1, [pc, #44]	; (8f98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    8f6c:	9b01      	ldr	r3, [sp, #4]
    8f6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_54[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]))         /*if interrupts were enabled*/
    8f72:	4a0a      	ldr	r2, [pc, #40]	; (8f9c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x48>)
    8f74:	9b01      	ldr	r3, [sp, #4]
    8f76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f7a:	f003 0301 	and.w	r3, r3, #1
    8f7e:	2b00      	cmp	r3, #0
    8f80:	d106      	bne.n	8f90 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x3c>
    8f82:	4a05      	ldr	r2, [pc, #20]	; (8f98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    8f84:	9b01      	ldr	r3, [sp, #4]
    8f86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f8a:	2b00      	cmp	r3, #0
    8f8c:	d100      	bne.n	8f90 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8f8e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8f90:	bf00      	nop
    8f92:	b003      	add	sp, #12
    8f94:	f85d fb04 	ldr.w	pc, [sp], #4
    8f98:	1fff8eec 	.word	0x1fff8eec
    8f9c:	1fff8ee8 	.word	0x1fff8ee8

00008fa0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55(void)
{
    8fa0:	b500      	push	{lr}
    8fa2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8fa4:	f7f7 fe02 	bl	bac <Sys_GetCoreID>
    8fa8:	4603      	mov	r3, r0
    8faa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId])
    8fac:	4a10      	ldr	r2, [pc, #64]	; (8ff0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    8fae:	9b01      	ldr	r3, [sp, #4]
    8fb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fb4:	2b00      	cmp	r3, #0
    8fb6:	d10d      	bne.n	8fd4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8fb8:	f7f7 fd17 	bl	9ea <Gpt_schm_read_msr>
    8fbc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8fbe:	9b00      	ldr	r3, [sp, #0]
    8fc0:	f003 0301 	and.w	r3, r3, #1
    8fc4:	2b00      	cmp	r3, #0
    8fc6:	d100      	bne.n	8fca <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8fc8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_55[u32CoreId] = msr;
    8fca:	490a      	ldr	r1, [pc, #40]	; (8ff4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x54>)
    8fcc:	9b01      	ldr	r3, [sp, #4]
    8fce:	9a00      	ldr	r2, [sp, #0]
    8fd0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]++;
    8fd4:	4a06      	ldr	r2, [pc, #24]	; (8ff0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    8fd6:	9b01      	ldr	r3, [sp, #4]
    8fd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fdc:	1c5a      	adds	r2, r3, #1
    8fde:	4904      	ldr	r1, [pc, #16]	; (8ff0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    8fe0:	9b01      	ldr	r3, [sp, #4]
    8fe2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8fe6:	bf00      	nop
    8fe8:	b003      	add	sp, #12
    8fea:	f85d fb04 	ldr.w	pc, [sp], #4
    8fee:	bf00      	nop
    8ff0:	1fff8ef4 	.word	0x1fff8ef4
    8ff4:	1fff8ef0 	.word	0x1fff8ef0

00008ff8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55(void)
{
    8ff8:	b500      	push	{lr}
    8ffa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ffc:	f7f7 fdd6 	bl	bac <Sys_GetCoreID>
    9000:	4603      	mov	r3, r0
    9002:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]--;
    9004:	4a0d      	ldr	r2, [pc, #52]	; (903c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    9006:	9b01      	ldr	r3, [sp, #4]
    9008:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    900c:	1e5a      	subs	r2, r3, #1
    900e:	490b      	ldr	r1, [pc, #44]	; (903c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    9010:	9b01      	ldr	r3, [sp, #4]
    9012:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_55[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]))         /*if interrupts were enabled*/
    9016:	4a0a      	ldr	r2, [pc, #40]	; (9040 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x48>)
    9018:	9b01      	ldr	r3, [sp, #4]
    901a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    901e:	f003 0301 	and.w	r3, r3, #1
    9022:	2b00      	cmp	r3, #0
    9024:	d106      	bne.n	9034 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x3c>
    9026:	4a05      	ldr	r2, [pc, #20]	; (903c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    9028:	9b01      	ldr	r3, [sp, #4]
    902a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    902e:	2b00      	cmp	r3, #0
    9030:	d100      	bne.n	9034 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9032:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9034:	bf00      	nop
    9036:	b003      	add	sp, #12
    9038:	f85d fb04 	ldr.w	pc, [sp], #4
    903c:	1fff8ef4 	.word	0x1fff8ef4
    9040:	1fff8ef0 	.word	0x1fff8ef0

00009044 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56(void)
{
    9044:	b500      	push	{lr}
    9046:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9048:	f7f7 fdb0 	bl	bac <Sys_GetCoreID>
    904c:	4603      	mov	r3, r0
    904e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId])
    9050:	4a10      	ldr	r2, [pc, #64]	; (9094 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    9052:	9b01      	ldr	r3, [sp, #4]
    9054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9058:	2b00      	cmp	r3, #0
    905a:	d10d      	bne.n	9078 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    905c:	f7f7 fcc5 	bl	9ea <Gpt_schm_read_msr>
    9060:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9062:	9b00      	ldr	r3, [sp, #0]
    9064:	f003 0301 	and.w	r3, r3, #1
    9068:	2b00      	cmp	r3, #0
    906a:	d100      	bne.n	906e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    906c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_56[u32CoreId] = msr;
    906e:	490a      	ldr	r1, [pc, #40]	; (9098 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x54>)
    9070:	9b01      	ldr	r3, [sp, #4]
    9072:	9a00      	ldr	r2, [sp, #0]
    9074:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]++;
    9078:	4a06      	ldr	r2, [pc, #24]	; (9094 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    907a:	9b01      	ldr	r3, [sp, #4]
    907c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9080:	1c5a      	adds	r2, r3, #1
    9082:	4904      	ldr	r1, [pc, #16]	; (9094 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    9084:	9b01      	ldr	r3, [sp, #4]
    9086:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    908a:	bf00      	nop
    908c:	b003      	add	sp, #12
    908e:	f85d fb04 	ldr.w	pc, [sp], #4
    9092:	bf00      	nop
    9094:	1fff8efc 	.word	0x1fff8efc
    9098:	1fff8ef8 	.word	0x1fff8ef8

0000909c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56(void)
{
    909c:	b500      	push	{lr}
    909e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    90a0:	f7f7 fd84 	bl	bac <Sys_GetCoreID>
    90a4:	4603      	mov	r3, r0
    90a6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]--;
    90a8:	4a0d      	ldr	r2, [pc, #52]	; (90e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    90aa:	9b01      	ldr	r3, [sp, #4]
    90ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90b0:	1e5a      	subs	r2, r3, #1
    90b2:	490b      	ldr	r1, [pc, #44]	; (90e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    90b4:	9b01      	ldr	r3, [sp, #4]
    90b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_56[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]))         /*if interrupts were enabled*/
    90ba:	4a0a      	ldr	r2, [pc, #40]	; (90e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x48>)
    90bc:	9b01      	ldr	r3, [sp, #4]
    90be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90c2:	f003 0301 	and.w	r3, r3, #1
    90c6:	2b00      	cmp	r3, #0
    90c8:	d106      	bne.n	90d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x3c>
    90ca:	4a05      	ldr	r2, [pc, #20]	; (90e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    90cc:	9b01      	ldr	r3, [sp, #4]
    90ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90d2:	2b00      	cmp	r3, #0
    90d4:	d100      	bne.n	90d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    90d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    90d8:	bf00      	nop
    90da:	b003      	add	sp, #12
    90dc:	f85d fb04 	ldr.w	pc, [sp], #4
    90e0:	1fff8efc 	.word	0x1fff8efc
    90e4:	1fff8ef8 	.word	0x1fff8ef8

000090e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60(void)
{
    90e8:	b500      	push	{lr}
    90ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    90ec:	f7f7 fd5e 	bl	bac <Sys_GetCoreID>
    90f0:	4603      	mov	r3, r0
    90f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId])
    90f4:	4a10      	ldr	r2, [pc, #64]	; (9138 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    90f6:	9b01      	ldr	r3, [sp, #4]
    90f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90fc:	2b00      	cmp	r3, #0
    90fe:	d10d      	bne.n	911c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9100:	f7f7 fc73 	bl	9ea <Gpt_schm_read_msr>
    9104:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9106:	9b00      	ldr	r3, [sp, #0]
    9108:	f003 0301 	and.w	r3, r3, #1
    910c:	2b00      	cmp	r3, #0
    910e:	d100      	bne.n	9112 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9110:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_60[u32CoreId] = msr;
    9112:	490a      	ldr	r1, [pc, #40]	; (913c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x54>)
    9114:	9b01      	ldr	r3, [sp, #4]
    9116:	9a00      	ldr	r2, [sp, #0]
    9118:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]++;
    911c:	4a06      	ldr	r2, [pc, #24]	; (9138 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    911e:	9b01      	ldr	r3, [sp, #4]
    9120:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9124:	1c5a      	adds	r2, r3, #1
    9126:	4904      	ldr	r1, [pc, #16]	; (9138 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    9128:	9b01      	ldr	r3, [sp, #4]
    912a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    912e:	bf00      	nop
    9130:	b003      	add	sp, #12
    9132:	f85d fb04 	ldr.w	pc, [sp], #4
    9136:	bf00      	nop
    9138:	1fff8f04 	.word	0x1fff8f04
    913c:	1fff8f00 	.word	0x1fff8f00

00009140 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60(void)
{
    9140:	b500      	push	{lr}
    9142:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9144:	f7f7 fd32 	bl	bac <Sys_GetCoreID>
    9148:	4603      	mov	r3, r0
    914a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]--;
    914c:	4a0d      	ldr	r2, [pc, #52]	; (9184 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    914e:	9b01      	ldr	r3, [sp, #4]
    9150:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9154:	1e5a      	subs	r2, r3, #1
    9156:	490b      	ldr	r1, [pc, #44]	; (9184 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    9158:	9b01      	ldr	r3, [sp, #4]
    915a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_60[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]))         /*if interrupts were enabled*/
    915e:	4a0a      	ldr	r2, [pc, #40]	; (9188 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x48>)
    9160:	9b01      	ldr	r3, [sp, #4]
    9162:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9166:	f003 0301 	and.w	r3, r3, #1
    916a:	2b00      	cmp	r3, #0
    916c:	d106      	bne.n	917c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x3c>
    916e:	4a05      	ldr	r2, [pc, #20]	; (9184 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    9170:	9b01      	ldr	r3, [sp, #4]
    9172:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9176:	2b00      	cmp	r3, #0
    9178:	d100      	bne.n	917c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    917a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    917c:	bf00      	nop
    917e:	b003      	add	sp, #12
    9180:	f85d fb04 	ldr.w	pc, [sp], #4
    9184:	1fff8f04 	.word	0x1fff8f04
    9188:	1fff8f00 	.word	0x1fff8f00

0000918c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61(void)
{
    918c:	b500      	push	{lr}
    918e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9190:	f7f7 fd0c 	bl	bac <Sys_GetCoreID>
    9194:	4603      	mov	r3, r0
    9196:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId])
    9198:	4a10      	ldr	r2, [pc, #64]	; (91dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    919a:	9b01      	ldr	r3, [sp, #4]
    919c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91a0:	2b00      	cmp	r3, #0
    91a2:	d10d      	bne.n	91c0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    91a4:	f7f7 fc21 	bl	9ea <Gpt_schm_read_msr>
    91a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    91aa:	9b00      	ldr	r3, [sp, #0]
    91ac:	f003 0301 	and.w	r3, r3, #1
    91b0:	2b00      	cmp	r3, #0
    91b2:	d100      	bne.n	91b6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    91b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_61[u32CoreId] = msr;
    91b6:	490a      	ldr	r1, [pc, #40]	; (91e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x54>)
    91b8:	9b01      	ldr	r3, [sp, #4]
    91ba:	9a00      	ldr	r2, [sp, #0]
    91bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]++;
    91c0:	4a06      	ldr	r2, [pc, #24]	; (91dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    91c2:	9b01      	ldr	r3, [sp, #4]
    91c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91c8:	1c5a      	adds	r2, r3, #1
    91ca:	4904      	ldr	r1, [pc, #16]	; (91dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    91cc:	9b01      	ldr	r3, [sp, #4]
    91ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    91d2:	bf00      	nop
    91d4:	b003      	add	sp, #12
    91d6:	f85d fb04 	ldr.w	pc, [sp], #4
    91da:	bf00      	nop
    91dc:	1fff8f0c 	.word	0x1fff8f0c
    91e0:	1fff8f08 	.word	0x1fff8f08

000091e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61(void)
{
    91e4:	b500      	push	{lr}
    91e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    91e8:	f7f7 fce0 	bl	bac <Sys_GetCoreID>
    91ec:	4603      	mov	r3, r0
    91ee:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]--;
    91f0:	4a0d      	ldr	r2, [pc, #52]	; (9228 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    91f2:	9b01      	ldr	r3, [sp, #4]
    91f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91f8:	1e5a      	subs	r2, r3, #1
    91fa:	490b      	ldr	r1, [pc, #44]	; (9228 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    91fc:	9b01      	ldr	r3, [sp, #4]
    91fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_61[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]))         /*if interrupts were enabled*/
    9202:	4a0a      	ldr	r2, [pc, #40]	; (922c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x48>)
    9204:	9b01      	ldr	r3, [sp, #4]
    9206:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    920a:	f003 0301 	and.w	r3, r3, #1
    920e:	2b00      	cmp	r3, #0
    9210:	d106      	bne.n	9220 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x3c>
    9212:	4a05      	ldr	r2, [pc, #20]	; (9228 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    9214:	9b01      	ldr	r3, [sp, #4]
    9216:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    921a:	2b00      	cmp	r3, #0
    921c:	d100      	bne.n	9220 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    921e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9220:	bf00      	nop
    9222:	b003      	add	sp, #12
    9224:	f85d fb04 	ldr.w	pc, [sp], #4
    9228:	1fff8f0c 	.word	0x1fff8f0c
    922c:	1fff8f08 	.word	0x1fff8f08

00009230 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62(void)
{
    9230:	b500      	push	{lr}
    9232:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9234:	f7f7 fcba 	bl	bac <Sys_GetCoreID>
    9238:	4603      	mov	r3, r0
    923a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId])
    923c:	4a10      	ldr	r2, [pc, #64]	; (9280 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    923e:	9b01      	ldr	r3, [sp, #4]
    9240:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9244:	2b00      	cmp	r3, #0
    9246:	d10d      	bne.n	9264 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9248:	f7f7 fbcf 	bl	9ea <Gpt_schm_read_msr>
    924c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    924e:	9b00      	ldr	r3, [sp, #0]
    9250:	f003 0301 	and.w	r3, r3, #1
    9254:	2b00      	cmp	r3, #0
    9256:	d100      	bne.n	925a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9258:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_62[u32CoreId] = msr;
    925a:	490a      	ldr	r1, [pc, #40]	; (9284 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x54>)
    925c:	9b01      	ldr	r3, [sp, #4]
    925e:	9a00      	ldr	r2, [sp, #0]
    9260:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]++;
    9264:	4a06      	ldr	r2, [pc, #24]	; (9280 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    9266:	9b01      	ldr	r3, [sp, #4]
    9268:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    926c:	1c5a      	adds	r2, r3, #1
    926e:	4904      	ldr	r1, [pc, #16]	; (9280 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    9270:	9b01      	ldr	r3, [sp, #4]
    9272:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9276:	bf00      	nop
    9278:	b003      	add	sp, #12
    927a:	f85d fb04 	ldr.w	pc, [sp], #4
    927e:	bf00      	nop
    9280:	1fff8f14 	.word	0x1fff8f14
    9284:	1fff8f10 	.word	0x1fff8f10

00009288 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62(void)
{
    9288:	b500      	push	{lr}
    928a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    928c:	f7f7 fc8e 	bl	bac <Sys_GetCoreID>
    9290:	4603      	mov	r3, r0
    9292:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]--;
    9294:	4a0d      	ldr	r2, [pc, #52]	; (92cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    9296:	9b01      	ldr	r3, [sp, #4]
    9298:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    929c:	1e5a      	subs	r2, r3, #1
    929e:	490b      	ldr	r1, [pc, #44]	; (92cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    92a0:	9b01      	ldr	r3, [sp, #4]
    92a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_62[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]))         /*if interrupts were enabled*/
    92a6:	4a0a      	ldr	r2, [pc, #40]	; (92d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x48>)
    92a8:	9b01      	ldr	r3, [sp, #4]
    92aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92ae:	f003 0301 	and.w	r3, r3, #1
    92b2:	2b00      	cmp	r3, #0
    92b4:	d106      	bne.n	92c4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x3c>
    92b6:	4a05      	ldr	r2, [pc, #20]	; (92cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    92b8:	9b01      	ldr	r3, [sp, #4]
    92ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92be:	2b00      	cmp	r3, #0
    92c0:	d100      	bne.n	92c4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    92c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    92c4:	bf00      	nop
    92c6:	b003      	add	sp, #12
    92c8:	f85d fb04 	ldr.w	pc, [sp], #4
    92cc:	1fff8f14 	.word	0x1fff8f14
    92d0:	1fff8f10 	.word	0x1fff8f10

000092d4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63(void)
{
    92d4:	b500      	push	{lr}
    92d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    92d8:	f7f7 fc68 	bl	bac <Sys_GetCoreID>
    92dc:	4603      	mov	r3, r0
    92de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId])
    92e0:	4a10      	ldr	r2, [pc, #64]	; (9324 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    92e2:	9b01      	ldr	r3, [sp, #4]
    92e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92e8:	2b00      	cmp	r3, #0
    92ea:	d10d      	bne.n	9308 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    92ec:	f7f7 fb7d 	bl	9ea <Gpt_schm_read_msr>
    92f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    92f2:	9b00      	ldr	r3, [sp, #0]
    92f4:	f003 0301 	and.w	r3, r3, #1
    92f8:	2b00      	cmp	r3, #0
    92fa:	d100      	bne.n	92fe <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    92fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_63[u32CoreId] = msr;
    92fe:	490a      	ldr	r1, [pc, #40]	; (9328 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x54>)
    9300:	9b01      	ldr	r3, [sp, #4]
    9302:	9a00      	ldr	r2, [sp, #0]
    9304:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]++;
    9308:	4a06      	ldr	r2, [pc, #24]	; (9324 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    930a:	9b01      	ldr	r3, [sp, #4]
    930c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9310:	1c5a      	adds	r2, r3, #1
    9312:	4904      	ldr	r1, [pc, #16]	; (9324 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    9314:	9b01      	ldr	r3, [sp, #4]
    9316:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    931a:	bf00      	nop
    931c:	b003      	add	sp, #12
    931e:	f85d fb04 	ldr.w	pc, [sp], #4
    9322:	bf00      	nop
    9324:	1fff8f1c 	.word	0x1fff8f1c
    9328:	1fff8f18 	.word	0x1fff8f18

0000932c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63(void)
{
    932c:	b500      	push	{lr}
    932e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9330:	f7f7 fc3c 	bl	bac <Sys_GetCoreID>
    9334:	4603      	mov	r3, r0
    9336:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]--;
    9338:	4a0d      	ldr	r2, [pc, #52]	; (9370 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    933a:	9b01      	ldr	r3, [sp, #4]
    933c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9340:	1e5a      	subs	r2, r3, #1
    9342:	490b      	ldr	r1, [pc, #44]	; (9370 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    9344:	9b01      	ldr	r3, [sp, #4]
    9346:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_63[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]))         /*if interrupts were enabled*/
    934a:	4a0a      	ldr	r2, [pc, #40]	; (9374 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x48>)
    934c:	9b01      	ldr	r3, [sp, #4]
    934e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9352:	f003 0301 	and.w	r3, r3, #1
    9356:	2b00      	cmp	r3, #0
    9358:	d106      	bne.n	9368 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x3c>
    935a:	4a05      	ldr	r2, [pc, #20]	; (9370 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    935c:	9b01      	ldr	r3, [sp, #4]
    935e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9362:	2b00      	cmp	r3, #0
    9364:	d100      	bne.n	9368 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9366:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9368:	bf00      	nop
    936a:	b003      	add	sp, #12
    936c:	f85d fb04 	ldr.w	pc, [sp], #4
    9370:	1fff8f1c 	.word	0x1fff8f1c
    9374:	1fff8f18 	.word	0x1fff8f18

00009378 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64(void)
{
    9378:	b500      	push	{lr}
    937a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    937c:	f7f7 fc16 	bl	bac <Sys_GetCoreID>
    9380:	4603      	mov	r3, r0
    9382:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId])
    9384:	4a10      	ldr	r2, [pc, #64]	; (93c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    9386:	9b01      	ldr	r3, [sp, #4]
    9388:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    938c:	2b00      	cmp	r3, #0
    938e:	d10d      	bne.n	93ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9390:	f7f7 fb2b 	bl	9ea <Gpt_schm_read_msr>
    9394:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9396:	9b00      	ldr	r3, [sp, #0]
    9398:	f003 0301 	and.w	r3, r3, #1
    939c:	2b00      	cmp	r3, #0
    939e:	d100      	bne.n	93a2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    93a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_64[u32CoreId] = msr;
    93a2:	490a      	ldr	r1, [pc, #40]	; (93cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x54>)
    93a4:	9b01      	ldr	r3, [sp, #4]
    93a6:	9a00      	ldr	r2, [sp, #0]
    93a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]++;
    93ac:	4a06      	ldr	r2, [pc, #24]	; (93c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    93ae:	9b01      	ldr	r3, [sp, #4]
    93b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93b4:	1c5a      	adds	r2, r3, #1
    93b6:	4904      	ldr	r1, [pc, #16]	; (93c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    93b8:	9b01      	ldr	r3, [sp, #4]
    93ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    93be:	bf00      	nop
    93c0:	b003      	add	sp, #12
    93c2:	f85d fb04 	ldr.w	pc, [sp], #4
    93c6:	bf00      	nop
    93c8:	1fff8f24 	.word	0x1fff8f24
    93cc:	1fff8f20 	.word	0x1fff8f20

000093d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64(void)
{
    93d0:	b500      	push	{lr}
    93d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    93d4:	f7f7 fbea 	bl	bac <Sys_GetCoreID>
    93d8:	4603      	mov	r3, r0
    93da:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]--;
    93dc:	4a0d      	ldr	r2, [pc, #52]	; (9414 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    93de:	9b01      	ldr	r3, [sp, #4]
    93e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93e4:	1e5a      	subs	r2, r3, #1
    93e6:	490b      	ldr	r1, [pc, #44]	; (9414 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    93e8:	9b01      	ldr	r3, [sp, #4]
    93ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_64[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]))         /*if interrupts were enabled*/
    93ee:	4a0a      	ldr	r2, [pc, #40]	; (9418 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x48>)
    93f0:	9b01      	ldr	r3, [sp, #4]
    93f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93f6:	f003 0301 	and.w	r3, r3, #1
    93fa:	2b00      	cmp	r3, #0
    93fc:	d106      	bne.n	940c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x3c>
    93fe:	4a05      	ldr	r2, [pc, #20]	; (9414 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    9400:	9b01      	ldr	r3, [sp, #4]
    9402:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9406:	2b00      	cmp	r3, #0
    9408:	d100      	bne.n	940c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    940a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    940c:	bf00      	nop
    940e:	b003      	add	sp, #12
    9410:	f85d fb04 	ldr.w	pc, [sp], #4
    9414:	1fff8f24 	.word	0x1fff8f24
    9418:	1fff8f20 	.word	0x1fff8f20

0000941c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65(void)
{
    941c:	b500      	push	{lr}
    941e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9420:	f7f7 fbc4 	bl	bac <Sys_GetCoreID>
    9424:	4603      	mov	r3, r0
    9426:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId])
    9428:	4a10      	ldr	r2, [pc, #64]	; (946c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    942a:	9b01      	ldr	r3, [sp, #4]
    942c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9430:	2b00      	cmp	r3, #0
    9432:	d10d      	bne.n	9450 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9434:	f7f7 fad9 	bl	9ea <Gpt_schm_read_msr>
    9438:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    943a:	9b00      	ldr	r3, [sp, #0]
    943c:	f003 0301 	and.w	r3, r3, #1
    9440:	2b00      	cmp	r3, #0
    9442:	d100      	bne.n	9446 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9444:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_65[u32CoreId] = msr;
    9446:	490a      	ldr	r1, [pc, #40]	; (9470 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x54>)
    9448:	9b01      	ldr	r3, [sp, #4]
    944a:	9a00      	ldr	r2, [sp, #0]
    944c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]++;
    9450:	4a06      	ldr	r2, [pc, #24]	; (946c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    9452:	9b01      	ldr	r3, [sp, #4]
    9454:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9458:	1c5a      	adds	r2, r3, #1
    945a:	4904      	ldr	r1, [pc, #16]	; (946c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    945c:	9b01      	ldr	r3, [sp, #4]
    945e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9462:	bf00      	nop
    9464:	b003      	add	sp, #12
    9466:	f85d fb04 	ldr.w	pc, [sp], #4
    946a:	bf00      	nop
    946c:	1fff8f2c 	.word	0x1fff8f2c
    9470:	1fff8f28 	.word	0x1fff8f28

00009474 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65(void)
{
    9474:	b500      	push	{lr}
    9476:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9478:	f7f7 fb98 	bl	bac <Sys_GetCoreID>
    947c:	4603      	mov	r3, r0
    947e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]--;
    9480:	4a0d      	ldr	r2, [pc, #52]	; (94b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    9482:	9b01      	ldr	r3, [sp, #4]
    9484:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9488:	1e5a      	subs	r2, r3, #1
    948a:	490b      	ldr	r1, [pc, #44]	; (94b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    948c:	9b01      	ldr	r3, [sp, #4]
    948e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_65[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]))         /*if interrupts were enabled*/
    9492:	4a0a      	ldr	r2, [pc, #40]	; (94bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x48>)
    9494:	9b01      	ldr	r3, [sp, #4]
    9496:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    949a:	f003 0301 	and.w	r3, r3, #1
    949e:	2b00      	cmp	r3, #0
    94a0:	d106      	bne.n	94b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x3c>
    94a2:	4a05      	ldr	r2, [pc, #20]	; (94b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    94a4:	9b01      	ldr	r3, [sp, #4]
    94a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94aa:	2b00      	cmp	r3, #0
    94ac:	d100      	bne.n	94b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    94ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    94b0:	bf00      	nop
    94b2:	b003      	add	sp, #12
    94b4:	f85d fb04 	ldr.w	pc, [sp], #4
    94b8:	1fff8f2c 	.word	0x1fff8f2c
    94bc:	1fff8f28 	.word	0x1fff8f28

000094c0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66(void)
{
    94c0:	b500      	push	{lr}
    94c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    94c4:	f7f7 fb72 	bl	bac <Sys_GetCoreID>
    94c8:	4603      	mov	r3, r0
    94ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId])
    94cc:	4a10      	ldr	r2, [pc, #64]	; (9510 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    94ce:	9b01      	ldr	r3, [sp, #4]
    94d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94d4:	2b00      	cmp	r3, #0
    94d6:	d10d      	bne.n	94f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    94d8:	f7f7 fa87 	bl	9ea <Gpt_schm_read_msr>
    94dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    94de:	9b00      	ldr	r3, [sp, #0]
    94e0:	f003 0301 	and.w	r3, r3, #1
    94e4:	2b00      	cmp	r3, #0
    94e6:	d100      	bne.n	94ea <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    94e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_66[u32CoreId] = msr;
    94ea:	490a      	ldr	r1, [pc, #40]	; (9514 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x54>)
    94ec:	9b01      	ldr	r3, [sp, #4]
    94ee:	9a00      	ldr	r2, [sp, #0]
    94f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]++;
    94f4:	4a06      	ldr	r2, [pc, #24]	; (9510 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    94f6:	9b01      	ldr	r3, [sp, #4]
    94f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94fc:	1c5a      	adds	r2, r3, #1
    94fe:	4904      	ldr	r1, [pc, #16]	; (9510 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    9500:	9b01      	ldr	r3, [sp, #4]
    9502:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9506:	bf00      	nop
    9508:	b003      	add	sp, #12
    950a:	f85d fb04 	ldr.w	pc, [sp], #4
    950e:	bf00      	nop
    9510:	1fff8f34 	.word	0x1fff8f34
    9514:	1fff8f30 	.word	0x1fff8f30

00009518 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66(void)
{
    9518:	b500      	push	{lr}
    951a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    951c:	f7f7 fb46 	bl	bac <Sys_GetCoreID>
    9520:	4603      	mov	r3, r0
    9522:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]--;
    9524:	4a0d      	ldr	r2, [pc, #52]	; (955c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9526:	9b01      	ldr	r3, [sp, #4]
    9528:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    952c:	1e5a      	subs	r2, r3, #1
    952e:	490b      	ldr	r1, [pc, #44]	; (955c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9530:	9b01      	ldr	r3, [sp, #4]
    9532:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_66[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]))         /*if interrupts were enabled*/
    9536:	4a0a      	ldr	r2, [pc, #40]	; (9560 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x48>)
    9538:	9b01      	ldr	r3, [sp, #4]
    953a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    953e:	f003 0301 	and.w	r3, r3, #1
    9542:	2b00      	cmp	r3, #0
    9544:	d106      	bne.n	9554 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x3c>
    9546:	4a05      	ldr	r2, [pc, #20]	; (955c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9548:	9b01      	ldr	r3, [sp, #4]
    954a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    954e:	2b00      	cmp	r3, #0
    9550:	d100      	bne.n	9554 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9552:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9554:	bf00      	nop
    9556:	b003      	add	sp, #12
    9558:	f85d fb04 	ldr.w	pc, [sp], #4
    955c:	1fff8f34 	.word	0x1fff8f34
    9560:	1fff8f30 	.word	0x1fff8f30

00009564 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67(void)
{
    9564:	b500      	push	{lr}
    9566:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9568:	f7f7 fb20 	bl	bac <Sys_GetCoreID>
    956c:	4603      	mov	r3, r0
    956e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId])
    9570:	4a10      	ldr	r2, [pc, #64]	; (95b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    9572:	9b01      	ldr	r3, [sp, #4]
    9574:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9578:	2b00      	cmp	r3, #0
    957a:	d10d      	bne.n	9598 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    957c:	f7f7 fa35 	bl	9ea <Gpt_schm_read_msr>
    9580:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9582:	9b00      	ldr	r3, [sp, #0]
    9584:	f003 0301 	and.w	r3, r3, #1
    9588:	2b00      	cmp	r3, #0
    958a:	d100      	bne.n	958e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    958c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_67[u32CoreId] = msr;
    958e:	490a      	ldr	r1, [pc, #40]	; (95b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x54>)
    9590:	9b01      	ldr	r3, [sp, #4]
    9592:	9a00      	ldr	r2, [sp, #0]
    9594:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]++;
    9598:	4a06      	ldr	r2, [pc, #24]	; (95b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    959a:	9b01      	ldr	r3, [sp, #4]
    959c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95a0:	1c5a      	adds	r2, r3, #1
    95a2:	4904      	ldr	r1, [pc, #16]	; (95b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    95a4:	9b01      	ldr	r3, [sp, #4]
    95a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    95aa:	bf00      	nop
    95ac:	b003      	add	sp, #12
    95ae:	f85d fb04 	ldr.w	pc, [sp], #4
    95b2:	bf00      	nop
    95b4:	1fff8f3c 	.word	0x1fff8f3c
    95b8:	1fff8f38 	.word	0x1fff8f38

000095bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67(void)
{
    95bc:	b500      	push	{lr}
    95be:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    95c0:	f7f7 faf4 	bl	bac <Sys_GetCoreID>
    95c4:	4603      	mov	r3, r0
    95c6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]--;
    95c8:	4a0d      	ldr	r2, [pc, #52]	; (9600 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    95ca:	9b01      	ldr	r3, [sp, #4]
    95cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95d0:	1e5a      	subs	r2, r3, #1
    95d2:	490b      	ldr	r1, [pc, #44]	; (9600 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    95d4:	9b01      	ldr	r3, [sp, #4]
    95d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_67[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]))         /*if interrupts were enabled*/
    95da:	4a0a      	ldr	r2, [pc, #40]	; (9604 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x48>)
    95dc:	9b01      	ldr	r3, [sp, #4]
    95de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95e2:	f003 0301 	and.w	r3, r3, #1
    95e6:	2b00      	cmp	r3, #0
    95e8:	d106      	bne.n	95f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x3c>
    95ea:	4a05      	ldr	r2, [pc, #20]	; (9600 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    95ec:	9b01      	ldr	r3, [sp, #4]
    95ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95f2:	2b00      	cmp	r3, #0
    95f4:	d100      	bne.n	95f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    95f6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    95f8:	bf00      	nop
    95fa:	b003      	add	sp, #12
    95fc:	f85d fb04 	ldr.w	pc, [sp], #4
    9600:	1fff8f3c 	.word	0x1fff8f3c
    9604:	1fff8f38 	.word	0x1fff8f38

00009608 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68(void)
{
    9608:	b500      	push	{lr}
    960a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    960c:	f7f7 face 	bl	bac <Sys_GetCoreID>
    9610:	4603      	mov	r3, r0
    9612:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId])
    9614:	4a10      	ldr	r2, [pc, #64]	; (9658 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    9616:	9b01      	ldr	r3, [sp, #4]
    9618:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    961c:	2b00      	cmp	r3, #0
    961e:	d10d      	bne.n	963c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9620:	f7f7 f9e3 	bl	9ea <Gpt_schm_read_msr>
    9624:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9626:	9b00      	ldr	r3, [sp, #0]
    9628:	f003 0301 	and.w	r3, r3, #1
    962c:	2b00      	cmp	r3, #0
    962e:	d100      	bne.n	9632 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9630:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_68[u32CoreId] = msr;
    9632:	490a      	ldr	r1, [pc, #40]	; (965c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x54>)
    9634:	9b01      	ldr	r3, [sp, #4]
    9636:	9a00      	ldr	r2, [sp, #0]
    9638:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]++;
    963c:	4a06      	ldr	r2, [pc, #24]	; (9658 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    963e:	9b01      	ldr	r3, [sp, #4]
    9640:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9644:	1c5a      	adds	r2, r3, #1
    9646:	4904      	ldr	r1, [pc, #16]	; (9658 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    9648:	9b01      	ldr	r3, [sp, #4]
    964a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    964e:	bf00      	nop
    9650:	b003      	add	sp, #12
    9652:	f85d fb04 	ldr.w	pc, [sp], #4
    9656:	bf00      	nop
    9658:	1fff8f44 	.word	0x1fff8f44
    965c:	1fff8f40 	.word	0x1fff8f40

00009660 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68(void)
{
    9660:	b500      	push	{lr}
    9662:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9664:	f7f7 faa2 	bl	bac <Sys_GetCoreID>
    9668:	4603      	mov	r3, r0
    966a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]--;
    966c:	4a0d      	ldr	r2, [pc, #52]	; (96a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    966e:	9b01      	ldr	r3, [sp, #4]
    9670:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9674:	1e5a      	subs	r2, r3, #1
    9676:	490b      	ldr	r1, [pc, #44]	; (96a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    9678:	9b01      	ldr	r3, [sp, #4]
    967a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_68[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]))         /*if interrupts were enabled*/
    967e:	4a0a      	ldr	r2, [pc, #40]	; (96a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x48>)
    9680:	9b01      	ldr	r3, [sp, #4]
    9682:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9686:	f003 0301 	and.w	r3, r3, #1
    968a:	2b00      	cmp	r3, #0
    968c:	d106      	bne.n	969c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x3c>
    968e:	4a05      	ldr	r2, [pc, #20]	; (96a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    9690:	9b01      	ldr	r3, [sp, #4]
    9692:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9696:	2b00      	cmp	r3, #0
    9698:	d100      	bne.n	969c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    969a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    969c:	bf00      	nop
    969e:	b003      	add	sp, #12
    96a0:	f85d fb04 	ldr.w	pc, [sp], #4
    96a4:	1fff8f44 	.word	0x1fff8f44
    96a8:	1fff8f40 	.word	0x1fff8f40

000096ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69(void)
{
    96ac:	b500      	push	{lr}
    96ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    96b0:	f7f7 fa7c 	bl	bac <Sys_GetCoreID>
    96b4:	4603      	mov	r3, r0
    96b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId])
    96b8:	4a10      	ldr	r2, [pc, #64]	; (96fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    96ba:	9b01      	ldr	r3, [sp, #4]
    96bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96c0:	2b00      	cmp	r3, #0
    96c2:	d10d      	bne.n	96e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    96c4:	f7f7 f991 	bl	9ea <Gpt_schm_read_msr>
    96c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    96ca:	9b00      	ldr	r3, [sp, #0]
    96cc:	f003 0301 	and.w	r3, r3, #1
    96d0:	2b00      	cmp	r3, #0
    96d2:	d100      	bne.n	96d6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    96d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_69[u32CoreId] = msr;
    96d6:	490a      	ldr	r1, [pc, #40]	; (9700 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x54>)
    96d8:	9b01      	ldr	r3, [sp, #4]
    96da:	9a00      	ldr	r2, [sp, #0]
    96dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]++;
    96e0:	4a06      	ldr	r2, [pc, #24]	; (96fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    96e2:	9b01      	ldr	r3, [sp, #4]
    96e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96e8:	1c5a      	adds	r2, r3, #1
    96ea:	4904      	ldr	r1, [pc, #16]	; (96fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    96ec:	9b01      	ldr	r3, [sp, #4]
    96ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    96f2:	bf00      	nop
    96f4:	b003      	add	sp, #12
    96f6:	f85d fb04 	ldr.w	pc, [sp], #4
    96fa:	bf00      	nop
    96fc:	1fff8f4c 	.word	0x1fff8f4c
    9700:	1fff8f48 	.word	0x1fff8f48

00009704 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69(void)
{
    9704:	b500      	push	{lr}
    9706:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9708:	f7f7 fa50 	bl	bac <Sys_GetCoreID>
    970c:	4603      	mov	r3, r0
    970e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]--;
    9710:	4a0d      	ldr	r2, [pc, #52]	; (9748 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    9712:	9b01      	ldr	r3, [sp, #4]
    9714:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9718:	1e5a      	subs	r2, r3, #1
    971a:	490b      	ldr	r1, [pc, #44]	; (9748 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    971c:	9b01      	ldr	r3, [sp, #4]
    971e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_69[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]))         /*if interrupts were enabled*/
    9722:	4a0a      	ldr	r2, [pc, #40]	; (974c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x48>)
    9724:	9b01      	ldr	r3, [sp, #4]
    9726:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    972a:	f003 0301 	and.w	r3, r3, #1
    972e:	2b00      	cmp	r3, #0
    9730:	d106      	bne.n	9740 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x3c>
    9732:	4a05      	ldr	r2, [pc, #20]	; (9748 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    9734:	9b01      	ldr	r3, [sp, #4]
    9736:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    973a:	2b00      	cmp	r3, #0
    973c:	d100      	bne.n	9740 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    973e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9740:	bf00      	nop
    9742:	b003      	add	sp, #12
    9744:	f85d fb04 	ldr.w	pc, [sp], #4
    9748:	1fff8f4c 	.word	0x1fff8f4c
    974c:	1fff8f48 	.word	0x1fff8f48

00009750 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70(void)
{
    9750:	b500      	push	{lr}
    9752:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9754:	f7f7 fa2a 	bl	bac <Sys_GetCoreID>
    9758:	4603      	mov	r3, r0
    975a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId])
    975c:	4a10      	ldr	r2, [pc, #64]	; (97a0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    975e:	9b01      	ldr	r3, [sp, #4]
    9760:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9764:	2b00      	cmp	r3, #0
    9766:	d10d      	bne.n	9784 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9768:	f7f7 f93f 	bl	9ea <Gpt_schm_read_msr>
    976c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    976e:	9b00      	ldr	r3, [sp, #0]
    9770:	f003 0301 	and.w	r3, r3, #1
    9774:	2b00      	cmp	r3, #0
    9776:	d100      	bne.n	977a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9778:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_70[u32CoreId] = msr;
    977a:	490a      	ldr	r1, [pc, #40]	; (97a4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x54>)
    977c:	9b01      	ldr	r3, [sp, #4]
    977e:	9a00      	ldr	r2, [sp, #0]
    9780:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]++;
    9784:	4a06      	ldr	r2, [pc, #24]	; (97a0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    9786:	9b01      	ldr	r3, [sp, #4]
    9788:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    978c:	1c5a      	adds	r2, r3, #1
    978e:	4904      	ldr	r1, [pc, #16]	; (97a0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    9790:	9b01      	ldr	r3, [sp, #4]
    9792:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9796:	bf00      	nop
    9798:	b003      	add	sp, #12
    979a:	f85d fb04 	ldr.w	pc, [sp], #4
    979e:	bf00      	nop
    97a0:	1fff8f54 	.word	0x1fff8f54
    97a4:	1fff8f50 	.word	0x1fff8f50

000097a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70(void)
{
    97a8:	b500      	push	{lr}
    97aa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    97ac:	f7f7 f9fe 	bl	bac <Sys_GetCoreID>
    97b0:	4603      	mov	r3, r0
    97b2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]--;
    97b4:	4a0d      	ldr	r2, [pc, #52]	; (97ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    97b6:	9b01      	ldr	r3, [sp, #4]
    97b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97bc:	1e5a      	subs	r2, r3, #1
    97be:	490b      	ldr	r1, [pc, #44]	; (97ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    97c0:	9b01      	ldr	r3, [sp, #4]
    97c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_70[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]))         /*if interrupts were enabled*/
    97c6:	4a0a      	ldr	r2, [pc, #40]	; (97f0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x48>)
    97c8:	9b01      	ldr	r3, [sp, #4]
    97ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97ce:	f003 0301 	and.w	r3, r3, #1
    97d2:	2b00      	cmp	r3, #0
    97d4:	d106      	bne.n	97e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x3c>
    97d6:	4a05      	ldr	r2, [pc, #20]	; (97ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    97d8:	9b01      	ldr	r3, [sp, #4]
    97da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97de:	2b00      	cmp	r3, #0
    97e0:	d100      	bne.n	97e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    97e2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    97e4:	bf00      	nop
    97e6:	b003      	add	sp, #12
    97e8:	f85d fb04 	ldr.w	pc, [sp], #4
    97ec:	1fff8f54 	.word	0x1fff8f54
    97f0:	1fff8f50 	.word	0x1fff8f50

000097f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71(void)
{
    97f4:	b500      	push	{lr}
    97f6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    97f8:	f7f7 f9d8 	bl	bac <Sys_GetCoreID>
    97fc:	4603      	mov	r3, r0
    97fe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId])
    9800:	4a10      	ldr	r2, [pc, #64]	; (9844 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    9802:	9b01      	ldr	r3, [sp, #4]
    9804:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9808:	2b00      	cmp	r3, #0
    980a:	d10d      	bne.n	9828 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    980c:	f7f7 f8ed 	bl	9ea <Gpt_schm_read_msr>
    9810:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9812:	9b00      	ldr	r3, [sp, #0]
    9814:	f003 0301 	and.w	r3, r3, #1
    9818:	2b00      	cmp	r3, #0
    981a:	d100      	bne.n	981e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    981c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_71[u32CoreId] = msr;
    981e:	490a      	ldr	r1, [pc, #40]	; (9848 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x54>)
    9820:	9b01      	ldr	r3, [sp, #4]
    9822:	9a00      	ldr	r2, [sp, #0]
    9824:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]++;
    9828:	4a06      	ldr	r2, [pc, #24]	; (9844 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    982a:	9b01      	ldr	r3, [sp, #4]
    982c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9830:	1c5a      	adds	r2, r3, #1
    9832:	4904      	ldr	r1, [pc, #16]	; (9844 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    9834:	9b01      	ldr	r3, [sp, #4]
    9836:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    983a:	bf00      	nop
    983c:	b003      	add	sp, #12
    983e:	f85d fb04 	ldr.w	pc, [sp], #4
    9842:	bf00      	nop
    9844:	1fff8f5c 	.word	0x1fff8f5c
    9848:	1fff8f58 	.word	0x1fff8f58

0000984c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71(void)
{
    984c:	b500      	push	{lr}
    984e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9850:	f7f7 f9ac 	bl	bac <Sys_GetCoreID>
    9854:	4603      	mov	r3, r0
    9856:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]--;
    9858:	4a0d      	ldr	r2, [pc, #52]	; (9890 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    985a:	9b01      	ldr	r3, [sp, #4]
    985c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9860:	1e5a      	subs	r2, r3, #1
    9862:	490b      	ldr	r1, [pc, #44]	; (9890 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    9864:	9b01      	ldr	r3, [sp, #4]
    9866:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_71[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]))         /*if interrupts were enabled*/
    986a:	4a0a      	ldr	r2, [pc, #40]	; (9894 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x48>)
    986c:	9b01      	ldr	r3, [sp, #4]
    986e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9872:	f003 0301 	and.w	r3, r3, #1
    9876:	2b00      	cmp	r3, #0
    9878:	d106      	bne.n	9888 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x3c>
    987a:	4a05      	ldr	r2, [pc, #20]	; (9890 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    987c:	9b01      	ldr	r3, [sp, #4]
    987e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9882:	2b00      	cmp	r3, #0
    9884:	d100      	bne.n	9888 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9886:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9888:	bf00      	nop
    988a:	b003      	add	sp, #12
    988c:	f85d fb04 	ldr.w	pc, [sp], #4
    9890:	1fff8f5c 	.word	0x1fff8f5c
    9894:	1fff8f58 	.word	0x1fff8f58

00009898 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72(void)
{
    9898:	b500      	push	{lr}
    989a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    989c:	f7f7 f986 	bl	bac <Sys_GetCoreID>
    98a0:	4603      	mov	r3, r0
    98a2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId])
    98a4:	4a10      	ldr	r2, [pc, #64]	; (98e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    98a6:	9b01      	ldr	r3, [sp, #4]
    98a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98ac:	2b00      	cmp	r3, #0
    98ae:	d10d      	bne.n	98cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    98b0:	f7f7 f89b 	bl	9ea <Gpt_schm_read_msr>
    98b4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    98b6:	9b00      	ldr	r3, [sp, #0]
    98b8:	f003 0301 	and.w	r3, r3, #1
    98bc:	2b00      	cmp	r3, #0
    98be:	d100      	bne.n	98c2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    98c0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_72[u32CoreId] = msr;
    98c2:	490a      	ldr	r1, [pc, #40]	; (98ec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x54>)
    98c4:	9b01      	ldr	r3, [sp, #4]
    98c6:	9a00      	ldr	r2, [sp, #0]
    98c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]++;
    98cc:	4a06      	ldr	r2, [pc, #24]	; (98e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    98ce:	9b01      	ldr	r3, [sp, #4]
    98d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98d4:	1c5a      	adds	r2, r3, #1
    98d6:	4904      	ldr	r1, [pc, #16]	; (98e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    98d8:	9b01      	ldr	r3, [sp, #4]
    98da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    98de:	bf00      	nop
    98e0:	b003      	add	sp, #12
    98e2:	f85d fb04 	ldr.w	pc, [sp], #4
    98e6:	bf00      	nop
    98e8:	1fff8f64 	.word	0x1fff8f64
    98ec:	1fff8f60 	.word	0x1fff8f60

000098f0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72(void)
{
    98f0:	b500      	push	{lr}
    98f2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    98f4:	f7f7 f95a 	bl	bac <Sys_GetCoreID>
    98f8:	4603      	mov	r3, r0
    98fa:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]--;
    98fc:	4a0d      	ldr	r2, [pc, #52]	; (9934 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    98fe:	9b01      	ldr	r3, [sp, #4]
    9900:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9904:	1e5a      	subs	r2, r3, #1
    9906:	490b      	ldr	r1, [pc, #44]	; (9934 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    9908:	9b01      	ldr	r3, [sp, #4]
    990a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_72[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]))         /*if interrupts were enabled*/
    990e:	4a0a      	ldr	r2, [pc, #40]	; (9938 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x48>)
    9910:	9b01      	ldr	r3, [sp, #4]
    9912:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9916:	f003 0301 	and.w	r3, r3, #1
    991a:	2b00      	cmp	r3, #0
    991c:	d106      	bne.n	992c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x3c>
    991e:	4a05      	ldr	r2, [pc, #20]	; (9934 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    9920:	9b01      	ldr	r3, [sp, #4]
    9922:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9926:	2b00      	cmp	r3, #0
    9928:	d100      	bne.n	992c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    992a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    992c:	bf00      	nop
    992e:	b003      	add	sp, #12
    9930:	f85d fb04 	ldr.w	pc, [sp], #4
    9934:	1fff8f64 	.word	0x1fff8f64
    9938:	1fff8f60 	.word	0x1fff8f60

0000993c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73(void)
{
    993c:	b500      	push	{lr}
    993e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9940:	f7f7 f934 	bl	bac <Sys_GetCoreID>
    9944:	4603      	mov	r3, r0
    9946:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId])
    9948:	4a10      	ldr	r2, [pc, #64]	; (998c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    994a:	9b01      	ldr	r3, [sp, #4]
    994c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9950:	2b00      	cmp	r3, #0
    9952:	d10d      	bne.n	9970 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9954:	f7f7 f849 	bl	9ea <Gpt_schm_read_msr>
    9958:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    995a:	9b00      	ldr	r3, [sp, #0]
    995c:	f003 0301 	and.w	r3, r3, #1
    9960:	2b00      	cmp	r3, #0
    9962:	d100      	bne.n	9966 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9964:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_73[u32CoreId] = msr;
    9966:	490a      	ldr	r1, [pc, #40]	; (9990 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x54>)
    9968:	9b01      	ldr	r3, [sp, #4]
    996a:	9a00      	ldr	r2, [sp, #0]
    996c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]++;
    9970:	4a06      	ldr	r2, [pc, #24]	; (998c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    9972:	9b01      	ldr	r3, [sp, #4]
    9974:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9978:	1c5a      	adds	r2, r3, #1
    997a:	4904      	ldr	r1, [pc, #16]	; (998c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    997c:	9b01      	ldr	r3, [sp, #4]
    997e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9982:	bf00      	nop
    9984:	b003      	add	sp, #12
    9986:	f85d fb04 	ldr.w	pc, [sp], #4
    998a:	bf00      	nop
    998c:	1fff8f6c 	.word	0x1fff8f6c
    9990:	1fff8f68 	.word	0x1fff8f68

00009994 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73(void)
{
    9994:	b500      	push	{lr}
    9996:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9998:	f7f7 f908 	bl	bac <Sys_GetCoreID>
    999c:	4603      	mov	r3, r0
    999e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]--;
    99a0:	4a0d      	ldr	r2, [pc, #52]	; (99d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    99a2:	9b01      	ldr	r3, [sp, #4]
    99a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99a8:	1e5a      	subs	r2, r3, #1
    99aa:	490b      	ldr	r1, [pc, #44]	; (99d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    99ac:	9b01      	ldr	r3, [sp, #4]
    99ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_73[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]))         /*if interrupts were enabled*/
    99b2:	4a0a      	ldr	r2, [pc, #40]	; (99dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x48>)
    99b4:	9b01      	ldr	r3, [sp, #4]
    99b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99ba:	f003 0301 	and.w	r3, r3, #1
    99be:	2b00      	cmp	r3, #0
    99c0:	d106      	bne.n	99d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x3c>
    99c2:	4a05      	ldr	r2, [pc, #20]	; (99d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    99c4:	9b01      	ldr	r3, [sp, #4]
    99c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99ca:	2b00      	cmp	r3, #0
    99cc:	d100      	bne.n	99d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    99ce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    99d0:	bf00      	nop
    99d2:	b003      	add	sp, #12
    99d4:	f85d fb04 	ldr.w	pc, [sp], #4
    99d8:	1fff8f6c 	.word	0x1fff8f6c
    99dc:	1fff8f68 	.word	0x1fff8f68

000099e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    99e0:	b500      	push	{lr}
    99e2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    99e4:	f7f7 f8e2 	bl	bac <Sys_GetCoreID>
    99e8:	4603      	mov	r3, r0
    99ea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    99ec:	4a10      	ldr	r2, [pc, #64]	; (9a30 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    99ee:	9b01      	ldr	r3, [sp, #4]
    99f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99f4:	2b00      	cmp	r3, #0
    99f6:	d10d      	bne.n	9a14 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    99f8:	f7f7 f800 	bl	9fc <Mcu_schm_read_msr>
    99fc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    99fe:	9b00      	ldr	r3, [sp, #0]
    9a00:	f003 0301 	and.w	r3, r3, #1
    9a04:	2b00      	cmp	r3, #0
    9a06:	d100      	bne.n	9a0a <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9a08:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    9a0a:	490a      	ldr	r1, [pc, #40]	; (9a34 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    9a0c:	9b01      	ldr	r3, [sp, #4]
    9a0e:	9a00      	ldr	r2, [sp, #0]
    9a10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    9a14:	4a06      	ldr	r2, [pc, #24]	; (9a30 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    9a16:	9b01      	ldr	r3, [sp, #4]
    9a18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1c:	1c5a      	adds	r2, r3, #1
    9a1e:	4904      	ldr	r1, [pc, #16]	; (9a30 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    9a20:	9b01      	ldr	r3, [sp, #4]
    9a22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9a26:	bf00      	nop
    9a28:	b003      	add	sp, #12
    9a2a:	f85d fb04 	ldr.w	pc, [sp], #4
    9a2e:	bf00      	nop
    9a30:	1fff8f74 	.word	0x1fff8f74
    9a34:	1fff8f70 	.word	0x1fff8f70

00009a38 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    9a38:	b500      	push	{lr}
    9a3a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a3c:	f7f7 f8b6 	bl	bac <Sys_GetCoreID>
    9a40:	4603      	mov	r3, r0
    9a42:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    9a44:	4a0d      	ldr	r2, [pc, #52]	; (9a7c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    9a46:	9b01      	ldr	r3, [sp, #4]
    9a48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a4c:	1e5a      	subs	r2, r3, #1
    9a4e:	490b      	ldr	r1, [pc, #44]	; (9a7c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    9a50:	9b01      	ldr	r3, [sp, #4]
    9a52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    9a56:	4a0a      	ldr	r2, [pc, #40]	; (9a80 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    9a58:	9b01      	ldr	r3, [sp, #4]
    9a5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a5e:	f003 0301 	and.w	r3, r3, #1
    9a62:	2b00      	cmp	r3, #0
    9a64:	d106      	bne.n	9a74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    9a66:	4a05      	ldr	r2, [pc, #20]	; (9a7c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    9a68:	9b01      	ldr	r3, [sp, #4]
    9a6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a6e:	2b00      	cmp	r3, #0
    9a70:	d100      	bne.n	9a74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9a72:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9a74:	bf00      	nop
    9a76:	b003      	add	sp, #12
    9a78:	f85d fb04 	ldr.w	pc, [sp], #4
    9a7c:	1fff8f74 	.word	0x1fff8f74
    9a80:	1fff8f70 	.word	0x1fff8f70

00009a84 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    9a84:	b500      	push	{lr}
    9a86:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a88:	f7f7 f890 	bl	bac <Sys_GetCoreID>
    9a8c:	4603      	mov	r3, r0
    9a8e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    9a90:	4a10      	ldr	r2, [pc, #64]	; (9ad4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    9a92:	9b01      	ldr	r3, [sp, #4]
    9a94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a98:	2b00      	cmp	r3, #0
    9a9a:	d10d      	bne.n	9ab8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9a9c:	f7f6 ffae 	bl	9fc <Mcu_schm_read_msr>
    9aa0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9aa2:	9b00      	ldr	r3, [sp, #0]
    9aa4:	f003 0301 	and.w	r3, r3, #1
    9aa8:	2b00      	cmp	r3, #0
    9aaa:	d100      	bne.n	9aae <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9aac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    9aae:	490a      	ldr	r1, [pc, #40]	; (9ad8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    9ab0:	9b01      	ldr	r3, [sp, #4]
    9ab2:	9a00      	ldr	r2, [sp, #0]
    9ab4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    9ab8:	4a06      	ldr	r2, [pc, #24]	; (9ad4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    9aba:	9b01      	ldr	r3, [sp, #4]
    9abc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ac0:	1c5a      	adds	r2, r3, #1
    9ac2:	4904      	ldr	r1, [pc, #16]	; (9ad4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    9ac4:	9b01      	ldr	r3, [sp, #4]
    9ac6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9aca:	bf00      	nop
    9acc:	b003      	add	sp, #12
    9ace:	f85d fb04 	ldr.w	pc, [sp], #4
    9ad2:	bf00      	nop
    9ad4:	1fff8f7c 	.word	0x1fff8f7c
    9ad8:	1fff8f78 	.word	0x1fff8f78

00009adc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    9adc:	b500      	push	{lr}
    9ade:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ae0:	f7f7 f864 	bl	bac <Sys_GetCoreID>
    9ae4:	4603      	mov	r3, r0
    9ae6:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    9ae8:	4a0d      	ldr	r2, [pc, #52]	; (9b20 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    9aea:	9b01      	ldr	r3, [sp, #4]
    9aec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9af0:	1e5a      	subs	r2, r3, #1
    9af2:	490b      	ldr	r1, [pc, #44]	; (9b20 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    9af4:	9b01      	ldr	r3, [sp, #4]
    9af6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    9afa:	4a0a      	ldr	r2, [pc, #40]	; (9b24 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    9afc:	9b01      	ldr	r3, [sp, #4]
    9afe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b02:	f003 0301 	and.w	r3, r3, #1
    9b06:	2b00      	cmp	r3, #0
    9b08:	d106      	bne.n	9b18 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    9b0a:	4a05      	ldr	r2, [pc, #20]	; (9b20 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    9b0c:	9b01      	ldr	r3, [sp, #4]
    9b0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b12:	2b00      	cmp	r3, #0
    9b14:	d100      	bne.n	9b18 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9b16:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9b18:	bf00      	nop
    9b1a:	b003      	add	sp, #12
    9b1c:	f85d fb04 	ldr.w	pc, [sp], #4
    9b20:	1fff8f7c 	.word	0x1fff8f7c
    9b24:	1fff8f78 	.word	0x1fff8f78

00009b28 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    9b28:	b500      	push	{lr}
    9b2a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9b2c:	f7f7 f83e 	bl	bac <Sys_GetCoreID>
    9b30:	4603      	mov	r3, r0
    9b32:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    9b34:	4a10      	ldr	r2, [pc, #64]	; (9b78 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    9b36:	9b01      	ldr	r3, [sp, #4]
    9b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b3c:	2b00      	cmp	r3, #0
    9b3e:	d10d      	bne.n	9b5c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9b40:	f7f6 ff5c 	bl	9fc <Mcu_schm_read_msr>
    9b44:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9b46:	9b00      	ldr	r3, [sp, #0]
    9b48:	f003 0301 	and.w	r3, r3, #1
    9b4c:	2b00      	cmp	r3, #0
    9b4e:	d100      	bne.n	9b52 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9b50:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    9b52:	490a      	ldr	r1, [pc, #40]	; (9b7c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    9b54:	9b01      	ldr	r3, [sp, #4]
    9b56:	9a00      	ldr	r2, [sp, #0]
    9b58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    9b5c:	4a06      	ldr	r2, [pc, #24]	; (9b78 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    9b5e:	9b01      	ldr	r3, [sp, #4]
    9b60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b64:	1c5a      	adds	r2, r3, #1
    9b66:	4904      	ldr	r1, [pc, #16]	; (9b78 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    9b68:	9b01      	ldr	r3, [sp, #4]
    9b6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9b6e:	bf00      	nop
    9b70:	b003      	add	sp, #12
    9b72:	f85d fb04 	ldr.w	pc, [sp], #4
    9b76:	bf00      	nop
    9b78:	1fff8f84 	.word	0x1fff8f84
    9b7c:	1fff8f80 	.word	0x1fff8f80

00009b80 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    9b80:	b500      	push	{lr}
    9b82:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9b84:	f7f7 f812 	bl	bac <Sys_GetCoreID>
    9b88:	4603      	mov	r3, r0
    9b8a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    9b8c:	4a0d      	ldr	r2, [pc, #52]	; (9bc4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    9b8e:	9b01      	ldr	r3, [sp, #4]
    9b90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b94:	1e5a      	subs	r2, r3, #1
    9b96:	490b      	ldr	r1, [pc, #44]	; (9bc4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    9b98:	9b01      	ldr	r3, [sp, #4]
    9b9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    9b9e:	4a0a      	ldr	r2, [pc, #40]	; (9bc8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    9ba0:	9b01      	ldr	r3, [sp, #4]
    9ba2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ba6:	f003 0301 	and.w	r3, r3, #1
    9baa:	2b00      	cmp	r3, #0
    9bac:	d106      	bne.n	9bbc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    9bae:	4a05      	ldr	r2, [pc, #20]	; (9bc4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    9bb0:	9b01      	ldr	r3, [sp, #4]
    9bb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bb6:	2b00      	cmp	r3, #0
    9bb8:	d100      	bne.n	9bbc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9bba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9bbc:	bf00      	nop
    9bbe:	b003      	add	sp, #12
    9bc0:	f85d fb04 	ldr.w	pc, [sp], #4
    9bc4:	1fff8f84 	.word	0x1fff8f84
    9bc8:	1fff8f80 	.word	0x1fff8f80

00009bcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    9bcc:	b500      	push	{lr}
    9bce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9bd0:	f7f6 ffec 	bl	bac <Sys_GetCoreID>
    9bd4:	4603      	mov	r3, r0
    9bd6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    9bd8:	4a10      	ldr	r2, [pc, #64]	; (9c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    9bda:	9b01      	ldr	r3, [sp, #4]
    9bdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9be0:	2b00      	cmp	r3, #0
    9be2:	d10d      	bne.n	9c00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9be4:	f7f6 ff13 	bl	a0e <Port_schm_read_msr>
    9be8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9bea:	9b00      	ldr	r3, [sp, #0]
    9bec:	f003 0301 	and.w	r3, r3, #1
    9bf0:	2b00      	cmp	r3, #0
    9bf2:	d100      	bne.n	9bf6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9bf4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    9bf6:	490a      	ldr	r1, [pc, #40]	; (9c20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    9bf8:	9b01      	ldr	r3, [sp, #4]
    9bfa:	9a00      	ldr	r2, [sp, #0]
    9bfc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    9c00:	4a06      	ldr	r2, [pc, #24]	; (9c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    9c02:	9b01      	ldr	r3, [sp, #4]
    9c04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c08:	1c5a      	adds	r2, r3, #1
    9c0a:	4904      	ldr	r1, [pc, #16]	; (9c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    9c0c:	9b01      	ldr	r3, [sp, #4]
    9c0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9c12:	bf00      	nop
    9c14:	b003      	add	sp, #12
    9c16:	f85d fb04 	ldr.w	pc, [sp], #4
    9c1a:	bf00      	nop
    9c1c:	1fff8f8c 	.word	0x1fff8f8c
    9c20:	1fff8f88 	.word	0x1fff8f88

00009c24 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    9c24:	b500      	push	{lr}
    9c26:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c28:	f7f6 ffc0 	bl	bac <Sys_GetCoreID>
    9c2c:	4603      	mov	r3, r0
    9c2e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    9c30:	4a0d      	ldr	r2, [pc, #52]	; (9c68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    9c32:	9b01      	ldr	r3, [sp, #4]
    9c34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c38:	1e5a      	subs	r2, r3, #1
    9c3a:	490b      	ldr	r1, [pc, #44]	; (9c68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    9c3c:	9b01      	ldr	r3, [sp, #4]
    9c3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    9c42:	4a0a      	ldr	r2, [pc, #40]	; (9c6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    9c44:	9b01      	ldr	r3, [sp, #4]
    9c46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c4a:	f003 0301 	and.w	r3, r3, #1
    9c4e:	2b00      	cmp	r3, #0
    9c50:	d106      	bne.n	9c60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    9c52:	4a05      	ldr	r2, [pc, #20]	; (9c68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    9c54:	9b01      	ldr	r3, [sp, #4]
    9c56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c5a:	2b00      	cmp	r3, #0
    9c5c:	d100      	bne.n	9c60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9c5e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9c60:	bf00      	nop
    9c62:	b003      	add	sp, #12
    9c64:	f85d fb04 	ldr.w	pc, [sp], #4
    9c68:	1fff8f8c 	.word	0x1fff8f8c
    9c6c:	1fff8f88 	.word	0x1fff8f88

00009c70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    9c70:	b500      	push	{lr}
    9c72:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c74:	f7f6 ff9a 	bl	bac <Sys_GetCoreID>
    9c78:	4603      	mov	r3, r0
    9c7a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    9c7c:	4a10      	ldr	r2, [pc, #64]	; (9cc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    9c7e:	9b01      	ldr	r3, [sp, #4]
    9c80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c84:	2b00      	cmp	r3, #0
    9c86:	d10d      	bne.n	9ca4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9c88:	f7f6 fec1 	bl	a0e <Port_schm_read_msr>
    9c8c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9c8e:	9b00      	ldr	r3, [sp, #0]
    9c90:	f003 0301 	and.w	r3, r3, #1
    9c94:	2b00      	cmp	r3, #0
    9c96:	d100      	bne.n	9c9a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9c98:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    9c9a:	490a      	ldr	r1, [pc, #40]	; (9cc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    9c9c:	9b01      	ldr	r3, [sp, #4]
    9c9e:	9a00      	ldr	r2, [sp, #0]
    9ca0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    9ca4:	4a06      	ldr	r2, [pc, #24]	; (9cc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    9ca6:	9b01      	ldr	r3, [sp, #4]
    9ca8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cac:	1c5a      	adds	r2, r3, #1
    9cae:	4904      	ldr	r1, [pc, #16]	; (9cc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    9cb0:	9b01      	ldr	r3, [sp, #4]
    9cb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9cb6:	bf00      	nop
    9cb8:	b003      	add	sp, #12
    9cba:	f85d fb04 	ldr.w	pc, [sp], #4
    9cbe:	bf00      	nop
    9cc0:	1fff8f94 	.word	0x1fff8f94
    9cc4:	1fff8f90 	.word	0x1fff8f90

00009cc8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    9cc8:	b500      	push	{lr}
    9cca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ccc:	f7f6 ff6e 	bl	bac <Sys_GetCoreID>
    9cd0:	4603      	mov	r3, r0
    9cd2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    9cd4:	4a0d      	ldr	r2, [pc, #52]	; (9d0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    9cd6:	9b01      	ldr	r3, [sp, #4]
    9cd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cdc:	1e5a      	subs	r2, r3, #1
    9cde:	490b      	ldr	r1, [pc, #44]	; (9d0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    9ce0:	9b01      	ldr	r3, [sp, #4]
    9ce2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    9ce6:	4a0a      	ldr	r2, [pc, #40]	; (9d10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    9ce8:	9b01      	ldr	r3, [sp, #4]
    9cea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cee:	f003 0301 	and.w	r3, r3, #1
    9cf2:	2b00      	cmp	r3, #0
    9cf4:	d106      	bne.n	9d04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    9cf6:	4a05      	ldr	r2, [pc, #20]	; (9d0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    9cf8:	9b01      	ldr	r3, [sp, #4]
    9cfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cfe:	2b00      	cmp	r3, #0
    9d00:	d100      	bne.n	9d04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9d02:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9d04:	bf00      	nop
    9d06:	b003      	add	sp, #12
    9d08:	f85d fb04 	ldr.w	pc, [sp], #4
    9d0c:	1fff8f94 	.word	0x1fff8f94
    9d10:	1fff8f90 	.word	0x1fff8f90

00009d14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    9d14:	b500      	push	{lr}
    9d16:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9d18:	f7f6 ff48 	bl	bac <Sys_GetCoreID>
    9d1c:	4603      	mov	r3, r0
    9d1e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    9d20:	4a10      	ldr	r2, [pc, #64]	; (9d64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    9d22:	9b01      	ldr	r3, [sp, #4]
    9d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d28:	2b00      	cmp	r3, #0
    9d2a:	d10d      	bne.n	9d48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9d2c:	f7f6 fe6f 	bl	a0e <Port_schm_read_msr>
    9d30:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9d32:	9b00      	ldr	r3, [sp, #0]
    9d34:	f003 0301 	and.w	r3, r3, #1
    9d38:	2b00      	cmp	r3, #0
    9d3a:	d100      	bne.n	9d3e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9d3c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    9d3e:	490a      	ldr	r1, [pc, #40]	; (9d68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    9d40:	9b01      	ldr	r3, [sp, #4]
    9d42:	9a00      	ldr	r2, [sp, #0]
    9d44:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    9d48:	4a06      	ldr	r2, [pc, #24]	; (9d64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    9d4a:	9b01      	ldr	r3, [sp, #4]
    9d4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d50:	1c5a      	adds	r2, r3, #1
    9d52:	4904      	ldr	r1, [pc, #16]	; (9d64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    9d54:	9b01      	ldr	r3, [sp, #4]
    9d56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9d5a:	bf00      	nop
    9d5c:	b003      	add	sp, #12
    9d5e:	f85d fb04 	ldr.w	pc, [sp], #4
    9d62:	bf00      	nop
    9d64:	1fff8f9c 	.word	0x1fff8f9c
    9d68:	1fff8f98 	.word	0x1fff8f98

00009d6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    9d6c:	b500      	push	{lr}
    9d6e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9d70:	f7f6 ff1c 	bl	bac <Sys_GetCoreID>
    9d74:	4603      	mov	r3, r0
    9d76:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    9d78:	4a0d      	ldr	r2, [pc, #52]	; (9db0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    9d7a:	9b01      	ldr	r3, [sp, #4]
    9d7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d80:	1e5a      	subs	r2, r3, #1
    9d82:	490b      	ldr	r1, [pc, #44]	; (9db0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    9d84:	9b01      	ldr	r3, [sp, #4]
    9d86:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    9d8a:	4a0a      	ldr	r2, [pc, #40]	; (9db4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    9d8c:	9b01      	ldr	r3, [sp, #4]
    9d8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d92:	f003 0301 	and.w	r3, r3, #1
    9d96:	2b00      	cmp	r3, #0
    9d98:	d106      	bne.n	9da8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    9d9a:	4a05      	ldr	r2, [pc, #20]	; (9db0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    9d9c:	9b01      	ldr	r3, [sp, #4]
    9d9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9da2:	2b00      	cmp	r3, #0
    9da4:	d100      	bne.n	9da8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9da6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9da8:	bf00      	nop
    9daa:	b003      	add	sp, #12
    9dac:	f85d fb04 	ldr.w	pc, [sp], #4
    9db0:	1fff8f9c 	.word	0x1fff8f9c
    9db4:	1fff8f98 	.word	0x1fff8f98

00009db8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    9db8:	b500      	push	{lr}
    9dba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9dbc:	f7f6 fef6 	bl	bac <Sys_GetCoreID>
    9dc0:	4603      	mov	r3, r0
    9dc2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    9dc4:	4a10      	ldr	r2, [pc, #64]	; (9e08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    9dc6:	9b01      	ldr	r3, [sp, #4]
    9dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9dcc:	2b00      	cmp	r3, #0
    9dce:	d10d      	bne.n	9dec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9dd0:	f7f6 fe1d 	bl	a0e <Port_schm_read_msr>
    9dd4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9dd6:	9b00      	ldr	r3, [sp, #0]
    9dd8:	f003 0301 	and.w	r3, r3, #1
    9ddc:	2b00      	cmp	r3, #0
    9dde:	d100      	bne.n	9de2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9de0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    9de2:	490a      	ldr	r1, [pc, #40]	; (9e0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    9de4:	9b01      	ldr	r3, [sp, #4]
    9de6:	9a00      	ldr	r2, [sp, #0]
    9de8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    9dec:	4a06      	ldr	r2, [pc, #24]	; (9e08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    9dee:	9b01      	ldr	r3, [sp, #4]
    9df0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9df4:	1c5a      	adds	r2, r3, #1
    9df6:	4904      	ldr	r1, [pc, #16]	; (9e08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    9df8:	9b01      	ldr	r3, [sp, #4]
    9dfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9dfe:	bf00      	nop
    9e00:	b003      	add	sp, #12
    9e02:	f85d fb04 	ldr.w	pc, [sp], #4
    9e06:	bf00      	nop
    9e08:	1fff8fa4 	.word	0x1fff8fa4
    9e0c:	1fff8fa0 	.word	0x1fff8fa0

00009e10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    9e10:	b500      	push	{lr}
    9e12:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e14:	f7f6 feca 	bl	bac <Sys_GetCoreID>
    9e18:	4603      	mov	r3, r0
    9e1a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    9e1c:	4a0d      	ldr	r2, [pc, #52]	; (9e54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    9e1e:	9b01      	ldr	r3, [sp, #4]
    9e20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e24:	1e5a      	subs	r2, r3, #1
    9e26:	490b      	ldr	r1, [pc, #44]	; (9e54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    9e28:	9b01      	ldr	r3, [sp, #4]
    9e2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    9e2e:	4a0a      	ldr	r2, [pc, #40]	; (9e58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    9e30:	9b01      	ldr	r3, [sp, #4]
    9e32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e36:	f003 0301 	and.w	r3, r3, #1
    9e3a:	2b00      	cmp	r3, #0
    9e3c:	d106      	bne.n	9e4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    9e3e:	4a05      	ldr	r2, [pc, #20]	; (9e54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    9e40:	9b01      	ldr	r3, [sp, #4]
    9e42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e46:	2b00      	cmp	r3, #0
    9e48:	d100      	bne.n	9e4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9e4a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9e4c:	bf00      	nop
    9e4e:	b003      	add	sp, #12
    9e50:	f85d fb04 	ldr.w	pc, [sp], #4
    9e54:	1fff8fa4 	.word	0x1fff8fa4
    9e58:	1fff8fa0 	.word	0x1fff8fa0

00009e5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    9e5c:	b500      	push	{lr}
    9e5e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e60:	f7f6 fea4 	bl	bac <Sys_GetCoreID>
    9e64:	4603      	mov	r3, r0
    9e66:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    9e68:	4a10      	ldr	r2, [pc, #64]	; (9eac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    9e6a:	9b01      	ldr	r3, [sp, #4]
    9e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e70:	2b00      	cmp	r3, #0
    9e72:	d10d      	bne.n	9e90 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9e74:	f7f6 fdcb 	bl	a0e <Port_schm_read_msr>
    9e78:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9e7a:	9b00      	ldr	r3, [sp, #0]
    9e7c:	f003 0301 	and.w	r3, r3, #1
    9e80:	2b00      	cmp	r3, #0
    9e82:	d100      	bne.n	9e86 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9e84:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    9e86:	490a      	ldr	r1, [pc, #40]	; (9eb0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    9e88:	9b01      	ldr	r3, [sp, #4]
    9e8a:	9a00      	ldr	r2, [sp, #0]
    9e8c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    9e90:	4a06      	ldr	r2, [pc, #24]	; (9eac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    9e92:	9b01      	ldr	r3, [sp, #4]
    9e94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e98:	1c5a      	adds	r2, r3, #1
    9e9a:	4904      	ldr	r1, [pc, #16]	; (9eac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    9e9c:	9b01      	ldr	r3, [sp, #4]
    9e9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9ea2:	bf00      	nop
    9ea4:	b003      	add	sp, #12
    9ea6:	f85d fb04 	ldr.w	pc, [sp], #4
    9eaa:	bf00      	nop
    9eac:	1fff8fac 	.word	0x1fff8fac
    9eb0:	1fff8fa8 	.word	0x1fff8fa8

00009eb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    9eb4:	b500      	push	{lr}
    9eb6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9eb8:	f7f6 fe78 	bl	bac <Sys_GetCoreID>
    9ebc:	4603      	mov	r3, r0
    9ebe:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    9ec0:	4a0d      	ldr	r2, [pc, #52]	; (9ef8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    9ec2:	9b01      	ldr	r3, [sp, #4]
    9ec4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ec8:	1e5a      	subs	r2, r3, #1
    9eca:	490b      	ldr	r1, [pc, #44]	; (9ef8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    9ecc:	9b01      	ldr	r3, [sp, #4]
    9ece:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    9ed2:	4a0a      	ldr	r2, [pc, #40]	; (9efc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    9ed4:	9b01      	ldr	r3, [sp, #4]
    9ed6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9eda:	f003 0301 	and.w	r3, r3, #1
    9ede:	2b00      	cmp	r3, #0
    9ee0:	d106      	bne.n	9ef0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    9ee2:	4a05      	ldr	r2, [pc, #20]	; (9ef8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    9ee4:	9b01      	ldr	r3, [sp, #4]
    9ee6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9eea:	2b00      	cmp	r3, #0
    9eec:	d100      	bne.n	9ef0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9eee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ef0:	bf00      	nop
    9ef2:	b003      	add	sp, #12
    9ef4:	f85d fb04 	ldr.w	pc, [sp], #4
    9ef8:	1fff8fac 	.word	0x1fff8fac
    9efc:	1fff8fa8 	.word	0x1fff8fa8

00009f00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    9f00:	b500      	push	{lr}
    9f02:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f04:	f7f6 fe52 	bl	bac <Sys_GetCoreID>
    9f08:	4603      	mov	r3, r0
    9f0a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    9f0c:	4a10      	ldr	r2, [pc, #64]	; (9f50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    9f0e:	9b01      	ldr	r3, [sp, #4]
    9f10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f14:	2b00      	cmp	r3, #0
    9f16:	d10d      	bne.n	9f34 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9f18:	f7f6 fd79 	bl	a0e <Port_schm_read_msr>
    9f1c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9f1e:	9b00      	ldr	r3, [sp, #0]
    9f20:	f003 0301 	and.w	r3, r3, #1
    9f24:	2b00      	cmp	r3, #0
    9f26:	d100      	bne.n	9f2a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9f28:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    9f2a:	490a      	ldr	r1, [pc, #40]	; (9f54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    9f2c:	9b01      	ldr	r3, [sp, #4]
    9f2e:	9a00      	ldr	r2, [sp, #0]
    9f30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    9f34:	4a06      	ldr	r2, [pc, #24]	; (9f50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    9f36:	9b01      	ldr	r3, [sp, #4]
    9f38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f3c:	1c5a      	adds	r2, r3, #1
    9f3e:	4904      	ldr	r1, [pc, #16]	; (9f50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    9f40:	9b01      	ldr	r3, [sp, #4]
    9f42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9f46:	bf00      	nop
    9f48:	b003      	add	sp, #12
    9f4a:	f85d fb04 	ldr.w	pc, [sp], #4
    9f4e:	bf00      	nop
    9f50:	1fff8fb4 	.word	0x1fff8fb4
    9f54:	1fff8fb0 	.word	0x1fff8fb0

00009f58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    9f58:	b500      	push	{lr}
    9f5a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f5c:	f7f6 fe26 	bl	bac <Sys_GetCoreID>
    9f60:	4603      	mov	r3, r0
    9f62:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    9f64:	4a0d      	ldr	r2, [pc, #52]	; (9f9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    9f66:	9b01      	ldr	r3, [sp, #4]
    9f68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f6c:	1e5a      	subs	r2, r3, #1
    9f6e:	490b      	ldr	r1, [pc, #44]	; (9f9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    9f70:	9b01      	ldr	r3, [sp, #4]
    9f72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    9f76:	4a0a      	ldr	r2, [pc, #40]	; (9fa0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    9f78:	9b01      	ldr	r3, [sp, #4]
    9f7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f7e:	f003 0301 	and.w	r3, r3, #1
    9f82:	2b00      	cmp	r3, #0
    9f84:	d106      	bne.n	9f94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    9f86:	4a05      	ldr	r2, [pc, #20]	; (9f9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    9f88:	9b01      	ldr	r3, [sp, #4]
    9f8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f8e:	2b00      	cmp	r3, #0
    9f90:	d100      	bne.n	9f94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9f92:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9f94:	bf00      	nop
    9f96:	b003      	add	sp, #12
    9f98:	f85d fb04 	ldr.w	pc, [sp], #4
    9f9c:	1fff8fb4 	.word	0x1fff8fb4
    9fa0:	1fff8fb0 	.word	0x1fff8fb0

00009fa4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    9fa4:	b500      	push	{lr}
    9fa6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9fa8:	f7f6 fe00 	bl	bac <Sys_GetCoreID>
    9fac:	4603      	mov	r3, r0
    9fae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    9fb0:	4a10      	ldr	r2, [pc, #64]	; (9ff4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    9fb2:	9b01      	ldr	r3, [sp, #4]
    9fb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fb8:	2b00      	cmp	r3, #0
    9fba:	d10d      	bne.n	9fd8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9fbc:	f7f6 fd27 	bl	a0e <Port_schm_read_msr>
    9fc0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9fc2:	9b00      	ldr	r3, [sp, #0]
    9fc4:	f003 0301 	and.w	r3, r3, #1
    9fc8:	2b00      	cmp	r3, #0
    9fca:	d100      	bne.n	9fce <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9fcc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    9fce:	490a      	ldr	r1, [pc, #40]	; (9ff8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    9fd0:	9b01      	ldr	r3, [sp, #4]
    9fd2:	9a00      	ldr	r2, [sp, #0]
    9fd4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    9fd8:	4a06      	ldr	r2, [pc, #24]	; (9ff4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    9fda:	9b01      	ldr	r3, [sp, #4]
    9fdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fe0:	1c5a      	adds	r2, r3, #1
    9fe2:	4904      	ldr	r1, [pc, #16]	; (9ff4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    9fe4:	9b01      	ldr	r3, [sp, #4]
    9fe6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9fea:	bf00      	nop
    9fec:	b003      	add	sp, #12
    9fee:	f85d fb04 	ldr.w	pc, [sp], #4
    9ff2:	bf00      	nop
    9ff4:	1fff8fbc 	.word	0x1fff8fbc
    9ff8:	1fff8fb8 	.word	0x1fff8fb8

00009ffc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    9ffc:	b500      	push	{lr}
    9ffe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a000:	f7f6 fdd4 	bl	bac <Sys_GetCoreID>
    a004:	4603      	mov	r3, r0
    a006:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    a008:	4a0d      	ldr	r2, [pc, #52]	; (a040 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    a00a:	9b01      	ldr	r3, [sp, #4]
    a00c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a010:	1e5a      	subs	r2, r3, #1
    a012:	490b      	ldr	r1, [pc, #44]	; (a040 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    a014:	9b01      	ldr	r3, [sp, #4]
    a016:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    a01a:	4a0a      	ldr	r2, [pc, #40]	; (a044 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    a01c:	9b01      	ldr	r3, [sp, #4]
    a01e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a022:	f003 0301 	and.w	r3, r3, #1
    a026:	2b00      	cmp	r3, #0
    a028:	d106      	bne.n	a038 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    a02a:	4a05      	ldr	r2, [pc, #20]	; (a040 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    a02c:	9b01      	ldr	r3, [sp, #4]
    a02e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a032:	2b00      	cmp	r3, #0
    a034:	d100      	bne.n	a038 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a036:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a038:	bf00      	nop
    a03a:	b003      	add	sp, #12
    a03c:	f85d fb04 	ldr.w	pc, [sp], #4
    a040:	1fff8fbc 	.word	0x1fff8fbc
    a044:	1fff8fb8 	.word	0x1fff8fb8

0000a048 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    a048:	b500      	push	{lr}
    a04a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a04c:	f7f6 fdae 	bl	bac <Sys_GetCoreID>
    a050:	4603      	mov	r3, r0
    a052:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    a054:	4a10      	ldr	r2, [pc, #64]	; (a098 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    a056:	9b01      	ldr	r3, [sp, #4]
    a058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a05c:	2b00      	cmp	r3, #0
    a05e:	d10d      	bne.n	a07c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a060:	f7f6 fcd5 	bl	a0e <Port_schm_read_msr>
    a064:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a066:	9b00      	ldr	r3, [sp, #0]
    a068:	f003 0301 	and.w	r3, r3, #1
    a06c:	2b00      	cmp	r3, #0
    a06e:	d100      	bne.n	a072 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a070:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    a072:	490a      	ldr	r1, [pc, #40]	; (a09c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    a074:	9b01      	ldr	r3, [sp, #4]
    a076:	9a00      	ldr	r2, [sp, #0]
    a078:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    a07c:	4a06      	ldr	r2, [pc, #24]	; (a098 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    a07e:	9b01      	ldr	r3, [sp, #4]
    a080:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a084:	1c5a      	adds	r2, r3, #1
    a086:	4904      	ldr	r1, [pc, #16]	; (a098 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    a088:	9b01      	ldr	r3, [sp, #4]
    a08a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a08e:	bf00      	nop
    a090:	b003      	add	sp, #12
    a092:	f85d fb04 	ldr.w	pc, [sp], #4
    a096:	bf00      	nop
    a098:	1fff8fc4 	.word	0x1fff8fc4
    a09c:	1fff8fc0 	.word	0x1fff8fc0

0000a0a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    a0a0:	b500      	push	{lr}
    a0a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a0a4:	f7f6 fd82 	bl	bac <Sys_GetCoreID>
    a0a8:	4603      	mov	r3, r0
    a0aa:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    a0ac:	4a0d      	ldr	r2, [pc, #52]	; (a0e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    a0ae:	9b01      	ldr	r3, [sp, #4]
    a0b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0b4:	1e5a      	subs	r2, r3, #1
    a0b6:	490b      	ldr	r1, [pc, #44]	; (a0e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    a0b8:	9b01      	ldr	r3, [sp, #4]
    a0ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    a0be:	4a0a      	ldr	r2, [pc, #40]	; (a0e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    a0c0:	9b01      	ldr	r3, [sp, #4]
    a0c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0c6:	f003 0301 	and.w	r3, r3, #1
    a0ca:	2b00      	cmp	r3, #0
    a0cc:	d106      	bne.n	a0dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    a0ce:	4a05      	ldr	r2, [pc, #20]	; (a0e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    a0d0:	9b01      	ldr	r3, [sp, #4]
    a0d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0d6:	2b00      	cmp	r3, #0
    a0d8:	d100      	bne.n	a0dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a0da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a0dc:	bf00      	nop
    a0de:	b003      	add	sp, #12
    a0e0:	f85d fb04 	ldr.w	pc, [sp], #4
    a0e4:	1fff8fc4 	.word	0x1fff8fc4
    a0e8:	1fff8fc0 	.word	0x1fff8fc0

0000a0ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    a0ec:	b500      	push	{lr}
    a0ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a0f0:	f7f6 fd5c 	bl	bac <Sys_GetCoreID>
    a0f4:	4603      	mov	r3, r0
    a0f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    a0f8:	4a10      	ldr	r2, [pc, #64]	; (a13c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    a0fa:	9b01      	ldr	r3, [sp, #4]
    a0fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a100:	2b00      	cmp	r3, #0
    a102:	d10d      	bne.n	a120 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a104:	f7f6 fc83 	bl	a0e <Port_schm_read_msr>
    a108:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a10a:	9b00      	ldr	r3, [sp, #0]
    a10c:	f003 0301 	and.w	r3, r3, #1
    a110:	2b00      	cmp	r3, #0
    a112:	d100      	bne.n	a116 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a114:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    a116:	490a      	ldr	r1, [pc, #40]	; (a140 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    a118:	9b01      	ldr	r3, [sp, #4]
    a11a:	9a00      	ldr	r2, [sp, #0]
    a11c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    a120:	4a06      	ldr	r2, [pc, #24]	; (a13c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    a122:	9b01      	ldr	r3, [sp, #4]
    a124:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a128:	1c5a      	adds	r2, r3, #1
    a12a:	4904      	ldr	r1, [pc, #16]	; (a13c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    a12c:	9b01      	ldr	r3, [sp, #4]
    a12e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a132:	bf00      	nop
    a134:	b003      	add	sp, #12
    a136:	f85d fb04 	ldr.w	pc, [sp], #4
    a13a:	bf00      	nop
    a13c:	1fff8fcc 	.word	0x1fff8fcc
    a140:	1fff8fc8 	.word	0x1fff8fc8

0000a144 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    a144:	b500      	push	{lr}
    a146:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a148:	f7f6 fd30 	bl	bac <Sys_GetCoreID>
    a14c:	4603      	mov	r3, r0
    a14e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    a150:	4a0d      	ldr	r2, [pc, #52]	; (a188 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    a152:	9b01      	ldr	r3, [sp, #4]
    a154:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a158:	1e5a      	subs	r2, r3, #1
    a15a:	490b      	ldr	r1, [pc, #44]	; (a188 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    a15c:	9b01      	ldr	r3, [sp, #4]
    a15e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    a162:	4a0a      	ldr	r2, [pc, #40]	; (a18c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    a164:	9b01      	ldr	r3, [sp, #4]
    a166:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a16a:	f003 0301 	and.w	r3, r3, #1
    a16e:	2b00      	cmp	r3, #0
    a170:	d106      	bne.n	a180 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    a172:	4a05      	ldr	r2, [pc, #20]	; (a188 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    a174:	9b01      	ldr	r3, [sp, #4]
    a176:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a17a:	2b00      	cmp	r3, #0
    a17c:	d100      	bne.n	a180 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a17e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a180:	bf00      	nop
    a182:	b003      	add	sp, #12
    a184:	f85d fb04 	ldr.w	pc, [sp], #4
    a188:	1fff8fcc 	.word	0x1fff8fcc
    a18c:	1fff8fc8 	.word	0x1fff8fc8

0000a190 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    a190:	b500      	push	{lr}
    a192:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a194:	f7f6 fd0a 	bl	bac <Sys_GetCoreID>
    a198:	4603      	mov	r3, r0
    a19a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    a19c:	4a10      	ldr	r2, [pc, #64]	; (a1e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    a19e:	9b01      	ldr	r3, [sp, #4]
    a1a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1a4:	2b00      	cmp	r3, #0
    a1a6:	d10d      	bne.n	a1c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a1a8:	f7f6 fc31 	bl	a0e <Port_schm_read_msr>
    a1ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a1ae:	9b00      	ldr	r3, [sp, #0]
    a1b0:	f003 0301 	and.w	r3, r3, #1
    a1b4:	2b00      	cmp	r3, #0
    a1b6:	d100      	bne.n	a1ba <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a1b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    a1ba:	490a      	ldr	r1, [pc, #40]	; (a1e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    a1bc:	9b01      	ldr	r3, [sp, #4]
    a1be:	9a00      	ldr	r2, [sp, #0]
    a1c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    a1c4:	4a06      	ldr	r2, [pc, #24]	; (a1e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    a1c6:	9b01      	ldr	r3, [sp, #4]
    a1c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1cc:	1c5a      	adds	r2, r3, #1
    a1ce:	4904      	ldr	r1, [pc, #16]	; (a1e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    a1d0:	9b01      	ldr	r3, [sp, #4]
    a1d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a1d6:	bf00      	nop
    a1d8:	b003      	add	sp, #12
    a1da:	f85d fb04 	ldr.w	pc, [sp], #4
    a1de:	bf00      	nop
    a1e0:	1fff8fd4 	.word	0x1fff8fd4
    a1e4:	1fff8fd0 	.word	0x1fff8fd0

0000a1e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    a1e8:	b500      	push	{lr}
    a1ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a1ec:	f7f6 fcde 	bl	bac <Sys_GetCoreID>
    a1f0:	4603      	mov	r3, r0
    a1f2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    a1f4:	4a0d      	ldr	r2, [pc, #52]	; (a22c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    a1f6:	9b01      	ldr	r3, [sp, #4]
    a1f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1fc:	1e5a      	subs	r2, r3, #1
    a1fe:	490b      	ldr	r1, [pc, #44]	; (a22c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    a200:	9b01      	ldr	r3, [sp, #4]
    a202:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    a206:	4a0a      	ldr	r2, [pc, #40]	; (a230 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    a208:	9b01      	ldr	r3, [sp, #4]
    a20a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a20e:	f003 0301 	and.w	r3, r3, #1
    a212:	2b00      	cmp	r3, #0
    a214:	d106      	bne.n	a224 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    a216:	4a05      	ldr	r2, [pc, #20]	; (a22c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    a218:	9b01      	ldr	r3, [sp, #4]
    a21a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a21e:	2b00      	cmp	r3, #0
    a220:	d100      	bne.n	a224 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a222:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a224:	bf00      	nop
    a226:	b003      	add	sp, #12
    a228:	f85d fb04 	ldr.w	pc, [sp], #4
    a22c:	1fff8fd4 	.word	0x1fff8fd4
    a230:	1fff8fd0 	.word	0x1fff8fd0

0000a234 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    a234:	b500      	push	{lr}
    a236:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a238:	f7f6 fcb8 	bl	bac <Sys_GetCoreID>
    a23c:	4603      	mov	r3, r0
    a23e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    a240:	4a10      	ldr	r2, [pc, #64]	; (a284 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    a242:	9b01      	ldr	r3, [sp, #4]
    a244:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a248:	2b00      	cmp	r3, #0
    a24a:	d10d      	bne.n	a268 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a24c:	f7f6 fbdf 	bl	a0e <Port_schm_read_msr>
    a250:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a252:	9b00      	ldr	r3, [sp, #0]
    a254:	f003 0301 	and.w	r3, r3, #1
    a258:	2b00      	cmp	r3, #0
    a25a:	d100      	bne.n	a25e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a25c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    a25e:	490a      	ldr	r1, [pc, #40]	; (a288 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    a260:	9b01      	ldr	r3, [sp, #4]
    a262:	9a00      	ldr	r2, [sp, #0]
    a264:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    a268:	4a06      	ldr	r2, [pc, #24]	; (a284 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    a26a:	9b01      	ldr	r3, [sp, #4]
    a26c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a270:	1c5a      	adds	r2, r3, #1
    a272:	4904      	ldr	r1, [pc, #16]	; (a284 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    a274:	9b01      	ldr	r3, [sp, #4]
    a276:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a27a:	bf00      	nop
    a27c:	b003      	add	sp, #12
    a27e:	f85d fb04 	ldr.w	pc, [sp], #4
    a282:	bf00      	nop
    a284:	1fff8fdc 	.word	0x1fff8fdc
    a288:	1fff8fd8 	.word	0x1fff8fd8

0000a28c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    a28c:	b500      	push	{lr}
    a28e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a290:	f7f6 fc8c 	bl	bac <Sys_GetCoreID>
    a294:	4603      	mov	r3, r0
    a296:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    a298:	4a0d      	ldr	r2, [pc, #52]	; (a2d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    a29a:	9b01      	ldr	r3, [sp, #4]
    a29c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2a0:	1e5a      	subs	r2, r3, #1
    a2a2:	490b      	ldr	r1, [pc, #44]	; (a2d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    a2a4:	9b01      	ldr	r3, [sp, #4]
    a2a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    a2aa:	4a0a      	ldr	r2, [pc, #40]	; (a2d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    a2ac:	9b01      	ldr	r3, [sp, #4]
    a2ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2b2:	f003 0301 	and.w	r3, r3, #1
    a2b6:	2b00      	cmp	r3, #0
    a2b8:	d106      	bne.n	a2c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    a2ba:	4a05      	ldr	r2, [pc, #20]	; (a2d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    a2bc:	9b01      	ldr	r3, [sp, #4]
    a2be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2c2:	2b00      	cmp	r3, #0
    a2c4:	d100      	bne.n	a2c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a2c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a2c8:	bf00      	nop
    a2ca:	b003      	add	sp, #12
    a2cc:	f85d fb04 	ldr.w	pc, [sp], #4
    a2d0:	1fff8fdc 	.word	0x1fff8fdc
    a2d4:	1fff8fd8 	.word	0x1fff8fd8

0000a2d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    a2d8:	b500      	push	{lr}
    a2da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a2dc:	f7f6 fc66 	bl	bac <Sys_GetCoreID>
    a2e0:	4603      	mov	r3, r0
    a2e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    a2e4:	4a10      	ldr	r2, [pc, #64]	; (a328 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    a2e6:	9b01      	ldr	r3, [sp, #4]
    a2e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2ec:	2b00      	cmp	r3, #0
    a2ee:	d10d      	bne.n	a30c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a2f0:	f7f6 fb8d 	bl	a0e <Port_schm_read_msr>
    a2f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a2f6:	9b00      	ldr	r3, [sp, #0]
    a2f8:	f003 0301 	and.w	r3, r3, #1
    a2fc:	2b00      	cmp	r3, #0
    a2fe:	d100      	bne.n	a302 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a300:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    a302:	490a      	ldr	r1, [pc, #40]	; (a32c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    a304:	9b01      	ldr	r3, [sp, #4]
    a306:	9a00      	ldr	r2, [sp, #0]
    a308:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    a30c:	4a06      	ldr	r2, [pc, #24]	; (a328 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    a30e:	9b01      	ldr	r3, [sp, #4]
    a310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a314:	1c5a      	adds	r2, r3, #1
    a316:	4904      	ldr	r1, [pc, #16]	; (a328 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    a318:	9b01      	ldr	r3, [sp, #4]
    a31a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a31e:	bf00      	nop
    a320:	b003      	add	sp, #12
    a322:	f85d fb04 	ldr.w	pc, [sp], #4
    a326:	bf00      	nop
    a328:	1fff8fe4 	.word	0x1fff8fe4
    a32c:	1fff8fe0 	.word	0x1fff8fe0

0000a330 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    a330:	b500      	push	{lr}
    a332:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a334:	f7f6 fc3a 	bl	bac <Sys_GetCoreID>
    a338:	4603      	mov	r3, r0
    a33a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    a33c:	4a0d      	ldr	r2, [pc, #52]	; (a374 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    a33e:	9b01      	ldr	r3, [sp, #4]
    a340:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a344:	1e5a      	subs	r2, r3, #1
    a346:	490b      	ldr	r1, [pc, #44]	; (a374 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    a348:	9b01      	ldr	r3, [sp, #4]
    a34a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    a34e:	4a0a      	ldr	r2, [pc, #40]	; (a378 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    a350:	9b01      	ldr	r3, [sp, #4]
    a352:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a356:	f003 0301 	and.w	r3, r3, #1
    a35a:	2b00      	cmp	r3, #0
    a35c:	d106      	bne.n	a36c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    a35e:	4a05      	ldr	r2, [pc, #20]	; (a374 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    a360:	9b01      	ldr	r3, [sp, #4]
    a362:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a366:	2b00      	cmp	r3, #0
    a368:	d100      	bne.n	a36c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a36a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a36c:	bf00      	nop
    a36e:	b003      	add	sp, #12
    a370:	f85d fb04 	ldr.w	pc, [sp], #4
    a374:	1fff8fe4 	.word	0x1fff8fe4
    a378:	1fff8fe0 	.word	0x1fff8fe0

0000a37c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    a37c:	b500      	push	{lr}
    a37e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a380:	f7f6 fc14 	bl	bac <Sys_GetCoreID>
    a384:	4603      	mov	r3, r0
    a386:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    a388:	4a10      	ldr	r2, [pc, #64]	; (a3cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    a38a:	9b01      	ldr	r3, [sp, #4]
    a38c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a390:	2b00      	cmp	r3, #0
    a392:	d10d      	bne.n	a3b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a394:	f7f6 fb3b 	bl	a0e <Port_schm_read_msr>
    a398:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a39a:	9b00      	ldr	r3, [sp, #0]
    a39c:	f003 0301 	and.w	r3, r3, #1
    a3a0:	2b00      	cmp	r3, #0
    a3a2:	d100      	bne.n	a3a6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a3a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    a3a6:	490a      	ldr	r1, [pc, #40]	; (a3d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    a3a8:	9b01      	ldr	r3, [sp, #4]
    a3aa:	9a00      	ldr	r2, [sp, #0]
    a3ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    a3b0:	4a06      	ldr	r2, [pc, #24]	; (a3cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    a3b2:	9b01      	ldr	r3, [sp, #4]
    a3b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3b8:	1c5a      	adds	r2, r3, #1
    a3ba:	4904      	ldr	r1, [pc, #16]	; (a3cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    a3bc:	9b01      	ldr	r3, [sp, #4]
    a3be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a3c2:	bf00      	nop
    a3c4:	b003      	add	sp, #12
    a3c6:	f85d fb04 	ldr.w	pc, [sp], #4
    a3ca:	bf00      	nop
    a3cc:	1fff8fec 	.word	0x1fff8fec
    a3d0:	1fff8fe8 	.word	0x1fff8fe8

0000a3d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    a3d4:	b500      	push	{lr}
    a3d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a3d8:	f7f6 fbe8 	bl	bac <Sys_GetCoreID>
    a3dc:	4603      	mov	r3, r0
    a3de:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    a3e0:	4a0d      	ldr	r2, [pc, #52]	; (a418 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    a3e2:	9b01      	ldr	r3, [sp, #4]
    a3e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3e8:	1e5a      	subs	r2, r3, #1
    a3ea:	490b      	ldr	r1, [pc, #44]	; (a418 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    a3ec:	9b01      	ldr	r3, [sp, #4]
    a3ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    a3f2:	4a0a      	ldr	r2, [pc, #40]	; (a41c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    a3f4:	9b01      	ldr	r3, [sp, #4]
    a3f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3fa:	f003 0301 	and.w	r3, r3, #1
    a3fe:	2b00      	cmp	r3, #0
    a400:	d106      	bne.n	a410 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    a402:	4a05      	ldr	r2, [pc, #20]	; (a418 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    a404:	9b01      	ldr	r3, [sp, #4]
    a406:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a40a:	2b00      	cmp	r3, #0
    a40c:	d100      	bne.n	a410 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a40e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a410:	bf00      	nop
    a412:	b003      	add	sp, #12
    a414:	f85d fb04 	ldr.w	pc, [sp], #4
    a418:	1fff8fec 	.word	0x1fff8fec
    a41c:	1fff8fe8 	.word	0x1fff8fe8

0000a420 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    a420:	b500      	push	{lr}
    a422:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a424:	f7f6 fbc2 	bl	bac <Sys_GetCoreID>
    a428:	4603      	mov	r3, r0
    a42a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    a42c:	4a10      	ldr	r2, [pc, #64]	; (a470 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    a42e:	9b01      	ldr	r3, [sp, #4]
    a430:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a434:	2b00      	cmp	r3, #0
    a436:	d10d      	bne.n	a454 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a438:	f7f6 fae9 	bl	a0e <Port_schm_read_msr>
    a43c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a43e:	9b00      	ldr	r3, [sp, #0]
    a440:	f003 0301 	and.w	r3, r3, #1
    a444:	2b00      	cmp	r3, #0
    a446:	d100      	bne.n	a44a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a448:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    a44a:	490a      	ldr	r1, [pc, #40]	; (a474 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    a44c:	9b01      	ldr	r3, [sp, #4]
    a44e:	9a00      	ldr	r2, [sp, #0]
    a450:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    a454:	4a06      	ldr	r2, [pc, #24]	; (a470 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    a456:	9b01      	ldr	r3, [sp, #4]
    a458:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a45c:	1c5a      	adds	r2, r3, #1
    a45e:	4904      	ldr	r1, [pc, #16]	; (a470 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    a460:	9b01      	ldr	r3, [sp, #4]
    a462:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a466:	bf00      	nop
    a468:	b003      	add	sp, #12
    a46a:	f85d fb04 	ldr.w	pc, [sp], #4
    a46e:	bf00      	nop
    a470:	1fff8ff4 	.word	0x1fff8ff4
    a474:	1fff8ff0 	.word	0x1fff8ff0

0000a478 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    a478:	b500      	push	{lr}
    a47a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a47c:	f7f6 fb96 	bl	bac <Sys_GetCoreID>
    a480:	4603      	mov	r3, r0
    a482:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    a484:	4a0d      	ldr	r2, [pc, #52]	; (a4bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    a486:	9b01      	ldr	r3, [sp, #4]
    a488:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a48c:	1e5a      	subs	r2, r3, #1
    a48e:	490b      	ldr	r1, [pc, #44]	; (a4bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    a490:	9b01      	ldr	r3, [sp, #4]
    a492:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    a496:	4a0a      	ldr	r2, [pc, #40]	; (a4c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    a498:	9b01      	ldr	r3, [sp, #4]
    a49a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a49e:	f003 0301 	and.w	r3, r3, #1
    a4a2:	2b00      	cmp	r3, #0
    a4a4:	d106      	bne.n	a4b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    a4a6:	4a05      	ldr	r2, [pc, #20]	; (a4bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    a4a8:	9b01      	ldr	r3, [sp, #4]
    a4aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4ae:	2b00      	cmp	r3, #0
    a4b0:	d100      	bne.n	a4b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a4b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a4b4:	bf00      	nop
    a4b6:	b003      	add	sp, #12
    a4b8:	f85d fb04 	ldr.w	pc, [sp], #4
    a4bc:	1fff8ff4 	.word	0x1fff8ff4
    a4c0:	1fff8ff0 	.word	0x1fff8ff0

0000a4c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    a4c4:	b500      	push	{lr}
    a4c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a4c8:	f7f6 fb70 	bl	bac <Sys_GetCoreID>
    a4cc:	4603      	mov	r3, r0
    a4ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    a4d0:	4a10      	ldr	r2, [pc, #64]	; (a514 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    a4d2:	9b01      	ldr	r3, [sp, #4]
    a4d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4d8:	2b00      	cmp	r3, #0
    a4da:	d10d      	bne.n	a4f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a4dc:	f7f6 fa97 	bl	a0e <Port_schm_read_msr>
    a4e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a4e2:	9b00      	ldr	r3, [sp, #0]
    a4e4:	f003 0301 	and.w	r3, r3, #1
    a4e8:	2b00      	cmp	r3, #0
    a4ea:	d100      	bne.n	a4ee <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a4ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    a4ee:	490a      	ldr	r1, [pc, #40]	; (a518 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    a4f0:	9b01      	ldr	r3, [sp, #4]
    a4f2:	9a00      	ldr	r2, [sp, #0]
    a4f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    a4f8:	4a06      	ldr	r2, [pc, #24]	; (a514 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    a4fa:	9b01      	ldr	r3, [sp, #4]
    a4fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a500:	1c5a      	adds	r2, r3, #1
    a502:	4904      	ldr	r1, [pc, #16]	; (a514 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    a504:	9b01      	ldr	r3, [sp, #4]
    a506:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a50a:	bf00      	nop
    a50c:	b003      	add	sp, #12
    a50e:	f85d fb04 	ldr.w	pc, [sp], #4
    a512:	bf00      	nop
    a514:	1fff8ffc 	.word	0x1fff8ffc
    a518:	1fff8ff8 	.word	0x1fff8ff8

0000a51c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    a51c:	b500      	push	{lr}
    a51e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a520:	f7f6 fb44 	bl	bac <Sys_GetCoreID>
    a524:	4603      	mov	r3, r0
    a526:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    a528:	4a0d      	ldr	r2, [pc, #52]	; (a560 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    a52a:	9b01      	ldr	r3, [sp, #4]
    a52c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a530:	1e5a      	subs	r2, r3, #1
    a532:	490b      	ldr	r1, [pc, #44]	; (a560 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    a534:	9b01      	ldr	r3, [sp, #4]
    a536:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    a53a:	4a0a      	ldr	r2, [pc, #40]	; (a564 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    a53c:	9b01      	ldr	r3, [sp, #4]
    a53e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a542:	f003 0301 	and.w	r3, r3, #1
    a546:	2b00      	cmp	r3, #0
    a548:	d106      	bne.n	a558 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    a54a:	4a05      	ldr	r2, [pc, #20]	; (a560 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    a54c:	9b01      	ldr	r3, [sp, #4]
    a54e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a552:	2b00      	cmp	r3, #0
    a554:	d100      	bne.n	a558 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a556:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a558:	bf00      	nop
    a55a:	b003      	add	sp, #12
    a55c:	f85d fb04 	ldr.w	pc, [sp], #4
    a560:	1fff8ffc 	.word	0x1fff8ffc
    a564:	1fff8ff8 	.word	0x1fff8ff8

0000a568 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    a568:	b500      	push	{lr}
    a56a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a56c:	f7f6 fb1e 	bl	bac <Sys_GetCoreID>
    a570:	4603      	mov	r3, r0
    a572:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    a574:	4a10      	ldr	r2, [pc, #64]	; (a5b8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    a576:	9b01      	ldr	r3, [sp, #4]
    a578:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a57c:	2b00      	cmp	r3, #0
    a57e:	d10d      	bne.n	a59c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a580:	f7f6 fa45 	bl	a0e <Port_schm_read_msr>
    a584:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a586:	9b00      	ldr	r3, [sp, #0]
    a588:	f003 0301 	and.w	r3, r3, #1
    a58c:	2b00      	cmp	r3, #0
    a58e:	d100      	bne.n	a592 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a590:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    a592:	490a      	ldr	r1, [pc, #40]	; (a5bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    a594:	9b01      	ldr	r3, [sp, #4]
    a596:	9a00      	ldr	r2, [sp, #0]
    a598:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    a59c:	4a06      	ldr	r2, [pc, #24]	; (a5b8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    a59e:	9b01      	ldr	r3, [sp, #4]
    a5a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5a4:	1c5a      	adds	r2, r3, #1
    a5a6:	4904      	ldr	r1, [pc, #16]	; (a5b8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    a5a8:	9b01      	ldr	r3, [sp, #4]
    a5aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a5ae:	bf00      	nop
    a5b0:	b003      	add	sp, #12
    a5b2:	f85d fb04 	ldr.w	pc, [sp], #4
    a5b6:	bf00      	nop
    a5b8:	1fff9004 	.word	0x1fff9004
    a5bc:	1fff9000 	.word	0x1fff9000

0000a5c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    a5c0:	b500      	push	{lr}
    a5c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a5c4:	f7f6 faf2 	bl	bac <Sys_GetCoreID>
    a5c8:	4603      	mov	r3, r0
    a5ca:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    a5cc:	4a0d      	ldr	r2, [pc, #52]	; (a604 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    a5ce:	9b01      	ldr	r3, [sp, #4]
    a5d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5d4:	1e5a      	subs	r2, r3, #1
    a5d6:	490b      	ldr	r1, [pc, #44]	; (a604 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    a5d8:	9b01      	ldr	r3, [sp, #4]
    a5da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    a5de:	4a0a      	ldr	r2, [pc, #40]	; (a608 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    a5e0:	9b01      	ldr	r3, [sp, #4]
    a5e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5e6:	f003 0301 	and.w	r3, r3, #1
    a5ea:	2b00      	cmp	r3, #0
    a5ec:	d106      	bne.n	a5fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    a5ee:	4a05      	ldr	r2, [pc, #20]	; (a604 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    a5f0:	9b01      	ldr	r3, [sp, #4]
    a5f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5f6:	2b00      	cmp	r3, #0
    a5f8:	d100      	bne.n	a5fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a5fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a5fc:	bf00      	nop
    a5fe:	b003      	add	sp, #12
    a600:	f85d fb04 	ldr.w	pc, [sp], #4
    a604:	1fff9004 	.word	0x1fff9004
    a608:	1fff9000 	.word	0x1fff9000

0000a60c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    a60c:	b500      	push	{lr}
    a60e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a610:	f7f6 facc 	bl	bac <Sys_GetCoreID>
    a614:	4603      	mov	r3, r0
    a616:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    a618:	4a10      	ldr	r2, [pc, #64]	; (a65c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    a61a:	9b01      	ldr	r3, [sp, #4]
    a61c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a620:	2b00      	cmp	r3, #0
    a622:	d10d      	bne.n	a640 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a624:	f7f6 f9f3 	bl	a0e <Port_schm_read_msr>
    a628:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a62a:	9b00      	ldr	r3, [sp, #0]
    a62c:	f003 0301 	and.w	r3, r3, #1
    a630:	2b00      	cmp	r3, #0
    a632:	d100      	bne.n	a636 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a634:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    a636:	490a      	ldr	r1, [pc, #40]	; (a660 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    a638:	9b01      	ldr	r3, [sp, #4]
    a63a:	9a00      	ldr	r2, [sp, #0]
    a63c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    a640:	4a06      	ldr	r2, [pc, #24]	; (a65c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    a642:	9b01      	ldr	r3, [sp, #4]
    a644:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a648:	1c5a      	adds	r2, r3, #1
    a64a:	4904      	ldr	r1, [pc, #16]	; (a65c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    a64c:	9b01      	ldr	r3, [sp, #4]
    a64e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a652:	bf00      	nop
    a654:	b003      	add	sp, #12
    a656:	f85d fb04 	ldr.w	pc, [sp], #4
    a65a:	bf00      	nop
    a65c:	1fff900c 	.word	0x1fff900c
    a660:	1fff9008 	.word	0x1fff9008

0000a664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    a664:	b500      	push	{lr}
    a666:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a668:	f7f6 faa0 	bl	bac <Sys_GetCoreID>
    a66c:	4603      	mov	r3, r0
    a66e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    a670:	4a0d      	ldr	r2, [pc, #52]	; (a6a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    a672:	9b01      	ldr	r3, [sp, #4]
    a674:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a678:	1e5a      	subs	r2, r3, #1
    a67a:	490b      	ldr	r1, [pc, #44]	; (a6a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    a67c:	9b01      	ldr	r3, [sp, #4]
    a67e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    a682:	4a0a      	ldr	r2, [pc, #40]	; (a6ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    a684:	9b01      	ldr	r3, [sp, #4]
    a686:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a68a:	f003 0301 	and.w	r3, r3, #1
    a68e:	2b00      	cmp	r3, #0
    a690:	d106      	bne.n	a6a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    a692:	4a05      	ldr	r2, [pc, #20]	; (a6a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    a694:	9b01      	ldr	r3, [sp, #4]
    a696:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a69a:	2b00      	cmp	r3, #0
    a69c:	d100      	bne.n	a6a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a69e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a6a0:	bf00      	nop
    a6a2:	b003      	add	sp, #12
    a6a4:	f85d fb04 	ldr.w	pc, [sp], #4
    a6a8:	1fff900c 	.word	0x1fff900c
    a6ac:	1fff9008 	.word	0x1fff9008

0000a6b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    a6b0:	b500      	push	{lr}
    a6b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a6b4:	f7f6 fa7a 	bl	bac <Sys_GetCoreID>
    a6b8:	4603      	mov	r3, r0
    a6ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    a6bc:	4a10      	ldr	r2, [pc, #64]	; (a700 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    a6be:	9b01      	ldr	r3, [sp, #4]
    a6c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a6c4:	2b00      	cmp	r3, #0
    a6c6:	d10d      	bne.n	a6e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a6c8:	f7f6 f9a1 	bl	a0e <Port_schm_read_msr>
    a6cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a6ce:	9b00      	ldr	r3, [sp, #0]
    a6d0:	f003 0301 	and.w	r3, r3, #1
    a6d4:	2b00      	cmp	r3, #0
    a6d6:	d100      	bne.n	a6da <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a6d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    a6da:	490a      	ldr	r1, [pc, #40]	; (a704 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    a6dc:	9b01      	ldr	r3, [sp, #4]
    a6de:	9a00      	ldr	r2, [sp, #0]
    a6e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    a6e4:	4a06      	ldr	r2, [pc, #24]	; (a700 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    a6e6:	9b01      	ldr	r3, [sp, #4]
    a6e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a6ec:	1c5a      	adds	r2, r3, #1
    a6ee:	4904      	ldr	r1, [pc, #16]	; (a700 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    a6f0:	9b01      	ldr	r3, [sp, #4]
    a6f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a6f6:	bf00      	nop
    a6f8:	b003      	add	sp, #12
    a6fa:	f85d fb04 	ldr.w	pc, [sp], #4
    a6fe:	bf00      	nop
    a700:	1fff9014 	.word	0x1fff9014
    a704:	1fff9010 	.word	0x1fff9010

0000a708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    a708:	b500      	push	{lr}
    a70a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a70c:	f7f6 fa4e 	bl	bac <Sys_GetCoreID>
    a710:	4603      	mov	r3, r0
    a712:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    a714:	4a0d      	ldr	r2, [pc, #52]	; (a74c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    a716:	9b01      	ldr	r3, [sp, #4]
    a718:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a71c:	1e5a      	subs	r2, r3, #1
    a71e:	490b      	ldr	r1, [pc, #44]	; (a74c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    a720:	9b01      	ldr	r3, [sp, #4]
    a722:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    a726:	4a0a      	ldr	r2, [pc, #40]	; (a750 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    a728:	9b01      	ldr	r3, [sp, #4]
    a72a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a72e:	f003 0301 	and.w	r3, r3, #1
    a732:	2b00      	cmp	r3, #0
    a734:	d106      	bne.n	a744 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    a736:	4a05      	ldr	r2, [pc, #20]	; (a74c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    a738:	9b01      	ldr	r3, [sp, #4]
    a73a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a73e:	2b00      	cmp	r3, #0
    a740:	d100      	bne.n	a744 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a742:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a744:	bf00      	nop
    a746:	b003      	add	sp, #12
    a748:	f85d fb04 	ldr.w	pc, [sp], #4
    a74c:	1fff9014 	.word	0x1fff9014
    a750:	1fff9010 	.word	0x1fff9010

0000a754 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    a754:	b500      	push	{lr}
    a756:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a758:	f7f6 fa28 	bl	bac <Sys_GetCoreID>
    a75c:	4603      	mov	r3, r0
    a75e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    a760:	4a10      	ldr	r2, [pc, #64]	; (a7a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    a762:	9b01      	ldr	r3, [sp, #4]
    a764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a768:	2b00      	cmp	r3, #0
    a76a:	d10d      	bne.n	a788 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a76c:	f7f6 f94f 	bl	a0e <Port_schm_read_msr>
    a770:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a772:	9b00      	ldr	r3, [sp, #0]
    a774:	f003 0301 	and.w	r3, r3, #1
    a778:	2b00      	cmp	r3, #0
    a77a:	d100      	bne.n	a77e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a77c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    a77e:	490a      	ldr	r1, [pc, #40]	; (a7a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    a780:	9b01      	ldr	r3, [sp, #4]
    a782:	9a00      	ldr	r2, [sp, #0]
    a784:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    a788:	4a06      	ldr	r2, [pc, #24]	; (a7a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    a78a:	9b01      	ldr	r3, [sp, #4]
    a78c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a790:	1c5a      	adds	r2, r3, #1
    a792:	4904      	ldr	r1, [pc, #16]	; (a7a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    a794:	9b01      	ldr	r3, [sp, #4]
    a796:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a79a:	bf00      	nop
    a79c:	b003      	add	sp, #12
    a79e:	f85d fb04 	ldr.w	pc, [sp], #4
    a7a2:	bf00      	nop
    a7a4:	1fff901c 	.word	0x1fff901c
    a7a8:	1fff9018 	.word	0x1fff9018

0000a7ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    a7ac:	b500      	push	{lr}
    a7ae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a7b0:	f7f6 f9fc 	bl	bac <Sys_GetCoreID>
    a7b4:	4603      	mov	r3, r0
    a7b6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    a7b8:	4a0d      	ldr	r2, [pc, #52]	; (a7f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    a7ba:	9b01      	ldr	r3, [sp, #4]
    a7bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7c0:	1e5a      	subs	r2, r3, #1
    a7c2:	490b      	ldr	r1, [pc, #44]	; (a7f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    a7c4:	9b01      	ldr	r3, [sp, #4]
    a7c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    a7ca:	4a0a      	ldr	r2, [pc, #40]	; (a7f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    a7cc:	9b01      	ldr	r3, [sp, #4]
    a7ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7d2:	f003 0301 	and.w	r3, r3, #1
    a7d6:	2b00      	cmp	r3, #0
    a7d8:	d106      	bne.n	a7e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    a7da:	4a05      	ldr	r2, [pc, #20]	; (a7f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    a7dc:	9b01      	ldr	r3, [sp, #4]
    a7de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7e2:	2b00      	cmp	r3, #0
    a7e4:	d100      	bne.n	a7e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a7e6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a7e8:	bf00      	nop
    a7ea:	b003      	add	sp, #12
    a7ec:	f85d fb04 	ldr.w	pc, [sp], #4
    a7f0:	1fff901c 	.word	0x1fff901c
    a7f4:	1fff9018 	.word	0x1fff9018

0000a7f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    a7f8:	b500      	push	{lr}
    a7fa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a7fc:	f7f6 f9d6 	bl	bac <Sys_GetCoreID>
    a800:	4603      	mov	r3, r0
    a802:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    a804:	4a10      	ldr	r2, [pc, #64]	; (a848 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    a806:	9b01      	ldr	r3, [sp, #4]
    a808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a80c:	2b00      	cmp	r3, #0
    a80e:	d10d      	bne.n	a82c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a810:	f7f6 f8fd 	bl	a0e <Port_schm_read_msr>
    a814:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a816:	9b00      	ldr	r3, [sp, #0]
    a818:	f003 0301 	and.w	r3, r3, #1
    a81c:	2b00      	cmp	r3, #0
    a81e:	d100      	bne.n	a822 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a820:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    a822:	490a      	ldr	r1, [pc, #40]	; (a84c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    a824:	9b01      	ldr	r3, [sp, #4]
    a826:	9a00      	ldr	r2, [sp, #0]
    a828:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    a82c:	4a06      	ldr	r2, [pc, #24]	; (a848 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    a82e:	9b01      	ldr	r3, [sp, #4]
    a830:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a834:	1c5a      	adds	r2, r3, #1
    a836:	4904      	ldr	r1, [pc, #16]	; (a848 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    a838:	9b01      	ldr	r3, [sp, #4]
    a83a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a83e:	bf00      	nop
    a840:	b003      	add	sp, #12
    a842:	f85d fb04 	ldr.w	pc, [sp], #4
    a846:	bf00      	nop
    a848:	1fff9024 	.word	0x1fff9024
    a84c:	1fff9020 	.word	0x1fff9020

0000a850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    a850:	b500      	push	{lr}
    a852:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a854:	f7f6 f9aa 	bl	bac <Sys_GetCoreID>
    a858:	4603      	mov	r3, r0
    a85a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    a85c:	4a0d      	ldr	r2, [pc, #52]	; (a894 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    a85e:	9b01      	ldr	r3, [sp, #4]
    a860:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a864:	1e5a      	subs	r2, r3, #1
    a866:	490b      	ldr	r1, [pc, #44]	; (a894 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    a868:	9b01      	ldr	r3, [sp, #4]
    a86a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    a86e:	4a0a      	ldr	r2, [pc, #40]	; (a898 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    a870:	9b01      	ldr	r3, [sp, #4]
    a872:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a876:	f003 0301 	and.w	r3, r3, #1
    a87a:	2b00      	cmp	r3, #0
    a87c:	d106      	bne.n	a88c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    a87e:	4a05      	ldr	r2, [pc, #20]	; (a894 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    a880:	9b01      	ldr	r3, [sp, #4]
    a882:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a886:	2b00      	cmp	r3, #0
    a888:	d100      	bne.n	a88c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a88a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a88c:	bf00      	nop
    a88e:	b003      	add	sp, #12
    a890:	f85d fb04 	ldr.w	pc, [sp], #4
    a894:	1fff9024 	.word	0x1fff9024
    a898:	1fff9020 	.word	0x1fff9020

0000a89c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    a89c:	b500      	push	{lr}
    a89e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a8a0:	f7f6 f984 	bl	bac <Sys_GetCoreID>
    a8a4:	4603      	mov	r3, r0
    a8a6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    a8a8:	4a10      	ldr	r2, [pc, #64]	; (a8ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    a8aa:	9b01      	ldr	r3, [sp, #4]
    a8ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8b0:	2b00      	cmp	r3, #0
    a8b2:	d10d      	bne.n	a8d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a8b4:	f7f6 f8ab 	bl	a0e <Port_schm_read_msr>
    a8b8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a8ba:	9b00      	ldr	r3, [sp, #0]
    a8bc:	f003 0301 	and.w	r3, r3, #1
    a8c0:	2b00      	cmp	r3, #0
    a8c2:	d100      	bne.n	a8c6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a8c4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    a8c6:	490a      	ldr	r1, [pc, #40]	; (a8f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    a8c8:	9b01      	ldr	r3, [sp, #4]
    a8ca:	9a00      	ldr	r2, [sp, #0]
    a8cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    a8d0:	4a06      	ldr	r2, [pc, #24]	; (a8ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    a8d2:	9b01      	ldr	r3, [sp, #4]
    a8d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8d8:	1c5a      	adds	r2, r3, #1
    a8da:	4904      	ldr	r1, [pc, #16]	; (a8ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    a8dc:	9b01      	ldr	r3, [sp, #4]
    a8de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a8e2:	bf00      	nop
    a8e4:	b003      	add	sp, #12
    a8e6:	f85d fb04 	ldr.w	pc, [sp], #4
    a8ea:	bf00      	nop
    a8ec:	1fff902c 	.word	0x1fff902c
    a8f0:	1fff9028 	.word	0x1fff9028

0000a8f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    a8f4:	b500      	push	{lr}
    a8f6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a8f8:	f7f6 f958 	bl	bac <Sys_GetCoreID>
    a8fc:	4603      	mov	r3, r0
    a8fe:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    a900:	4a0d      	ldr	r2, [pc, #52]	; (a938 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    a902:	9b01      	ldr	r3, [sp, #4]
    a904:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a908:	1e5a      	subs	r2, r3, #1
    a90a:	490b      	ldr	r1, [pc, #44]	; (a938 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    a90c:	9b01      	ldr	r3, [sp, #4]
    a90e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    a912:	4a0a      	ldr	r2, [pc, #40]	; (a93c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    a914:	9b01      	ldr	r3, [sp, #4]
    a916:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a91a:	f003 0301 	and.w	r3, r3, #1
    a91e:	2b00      	cmp	r3, #0
    a920:	d106      	bne.n	a930 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    a922:	4a05      	ldr	r2, [pc, #20]	; (a938 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    a924:	9b01      	ldr	r3, [sp, #4]
    a926:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a92a:	2b00      	cmp	r3, #0
    a92c:	d100      	bne.n	a930 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a92e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a930:	bf00      	nop
    a932:	b003      	add	sp, #12
    a934:	f85d fb04 	ldr.w	pc, [sp], #4
    a938:	1fff902c 	.word	0x1fff902c
    a93c:	1fff9028 	.word	0x1fff9028

0000a940 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    a940:	b500      	push	{lr}
    a942:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a944:	f7f6 f932 	bl	bac <Sys_GetCoreID>
    a948:	4603      	mov	r3, r0
    a94a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    a94c:	4a10      	ldr	r2, [pc, #64]	; (a990 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    a94e:	9b01      	ldr	r3, [sp, #4]
    a950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a954:	2b00      	cmp	r3, #0
    a956:	d10d      	bne.n	a974 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a958:	f7f6 f859 	bl	a0e <Port_schm_read_msr>
    a95c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a95e:	9b00      	ldr	r3, [sp, #0]
    a960:	f003 0301 	and.w	r3, r3, #1
    a964:	2b00      	cmp	r3, #0
    a966:	d100      	bne.n	a96a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a968:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    a96a:	490a      	ldr	r1, [pc, #40]	; (a994 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    a96c:	9b01      	ldr	r3, [sp, #4]
    a96e:	9a00      	ldr	r2, [sp, #0]
    a970:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    a974:	4a06      	ldr	r2, [pc, #24]	; (a990 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    a976:	9b01      	ldr	r3, [sp, #4]
    a978:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a97c:	1c5a      	adds	r2, r3, #1
    a97e:	4904      	ldr	r1, [pc, #16]	; (a990 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    a980:	9b01      	ldr	r3, [sp, #4]
    a982:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a986:	bf00      	nop
    a988:	b003      	add	sp, #12
    a98a:	f85d fb04 	ldr.w	pc, [sp], #4
    a98e:	bf00      	nop
    a990:	1fff9034 	.word	0x1fff9034
    a994:	1fff9030 	.word	0x1fff9030

0000a998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    a998:	b500      	push	{lr}
    a99a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a99c:	f7f6 f906 	bl	bac <Sys_GetCoreID>
    a9a0:	4603      	mov	r3, r0
    a9a2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    a9a4:	4a0d      	ldr	r2, [pc, #52]	; (a9dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    a9a6:	9b01      	ldr	r3, [sp, #4]
    a9a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9ac:	1e5a      	subs	r2, r3, #1
    a9ae:	490b      	ldr	r1, [pc, #44]	; (a9dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    a9b0:	9b01      	ldr	r3, [sp, #4]
    a9b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    a9b6:	4a0a      	ldr	r2, [pc, #40]	; (a9e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    a9b8:	9b01      	ldr	r3, [sp, #4]
    a9ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9be:	f003 0301 	and.w	r3, r3, #1
    a9c2:	2b00      	cmp	r3, #0
    a9c4:	d106      	bne.n	a9d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    a9c6:	4a05      	ldr	r2, [pc, #20]	; (a9dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    a9c8:	9b01      	ldr	r3, [sp, #4]
    a9ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9ce:	2b00      	cmp	r3, #0
    a9d0:	d100      	bne.n	a9d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a9d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a9d4:	bf00      	nop
    a9d6:	b003      	add	sp, #12
    a9d8:	f85d fb04 	ldr.w	pc, [sp], #4
    a9dc:	1fff9034 	.word	0x1fff9034
    a9e0:	1fff9030 	.word	0x1fff9030

0000a9e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    a9e4:	b500      	push	{lr}
    a9e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a9e8:	f7f6 f8e0 	bl	bac <Sys_GetCoreID>
    a9ec:	4603      	mov	r3, r0
    a9ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    a9f0:	4a10      	ldr	r2, [pc, #64]	; (aa34 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    a9f2:	9b01      	ldr	r3, [sp, #4]
    a9f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9f8:	2b00      	cmp	r3, #0
    a9fa:	d10d      	bne.n	aa18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a9fc:	f7f6 f807 	bl	a0e <Port_schm_read_msr>
    aa00:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    aa02:	9b00      	ldr	r3, [sp, #0]
    aa04:	f003 0301 	and.w	r3, r3, #1
    aa08:	2b00      	cmp	r3, #0
    aa0a:	d100      	bne.n	aa0e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    aa0c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    aa0e:	490a      	ldr	r1, [pc, #40]	; (aa38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    aa10:	9b01      	ldr	r3, [sp, #4]
    aa12:	9a00      	ldr	r2, [sp, #0]
    aa14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    aa18:	4a06      	ldr	r2, [pc, #24]	; (aa34 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    aa1a:	9b01      	ldr	r3, [sp, #4]
    aa1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa20:	1c5a      	adds	r2, r3, #1
    aa22:	4904      	ldr	r1, [pc, #16]	; (aa34 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    aa24:	9b01      	ldr	r3, [sp, #4]
    aa26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    aa2a:	bf00      	nop
    aa2c:	b003      	add	sp, #12
    aa2e:	f85d fb04 	ldr.w	pc, [sp], #4
    aa32:	bf00      	nop
    aa34:	1fff903c 	.word	0x1fff903c
    aa38:	1fff9038 	.word	0x1fff9038

0000aa3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    aa3c:	b500      	push	{lr}
    aa3e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aa40:	f7f6 f8b4 	bl	bac <Sys_GetCoreID>
    aa44:	4603      	mov	r3, r0
    aa46:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    aa48:	4a0d      	ldr	r2, [pc, #52]	; (aa80 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    aa4a:	9b01      	ldr	r3, [sp, #4]
    aa4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa50:	1e5a      	subs	r2, r3, #1
    aa52:	490b      	ldr	r1, [pc, #44]	; (aa80 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    aa54:	9b01      	ldr	r3, [sp, #4]
    aa56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    aa5a:	4a0a      	ldr	r2, [pc, #40]	; (aa84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    aa5c:	9b01      	ldr	r3, [sp, #4]
    aa5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa62:	f003 0301 	and.w	r3, r3, #1
    aa66:	2b00      	cmp	r3, #0
    aa68:	d106      	bne.n	aa78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    aa6a:	4a05      	ldr	r2, [pc, #20]	; (aa80 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    aa6c:	9b01      	ldr	r3, [sp, #4]
    aa6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa72:	2b00      	cmp	r3, #0
    aa74:	d100      	bne.n	aa78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    aa76:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    aa78:	bf00      	nop
    aa7a:	b003      	add	sp, #12
    aa7c:	f85d fb04 	ldr.w	pc, [sp], #4
    aa80:	1fff903c 	.word	0x1fff903c
    aa84:	1fff9038 	.word	0x1fff9038

0000aa88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    aa88:	b500      	push	{lr}
    aa8a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aa8c:	f7f6 f88e 	bl	bac <Sys_GetCoreID>
    aa90:	4603      	mov	r3, r0
    aa92:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    aa94:	4a10      	ldr	r2, [pc, #64]	; (aad8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    aa96:	9b01      	ldr	r3, [sp, #4]
    aa98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa9c:	2b00      	cmp	r3, #0
    aa9e:	d10d      	bne.n	aabc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    aaa0:	f7f5 ffb5 	bl	a0e <Port_schm_read_msr>
    aaa4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    aaa6:	9b00      	ldr	r3, [sp, #0]
    aaa8:	f003 0301 	and.w	r3, r3, #1
    aaac:	2b00      	cmp	r3, #0
    aaae:	d100      	bne.n	aab2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    aab0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    aab2:	490a      	ldr	r1, [pc, #40]	; (aadc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    aab4:	9b01      	ldr	r3, [sp, #4]
    aab6:	9a00      	ldr	r2, [sp, #0]
    aab8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    aabc:	4a06      	ldr	r2, [pc, #24]	; (aad8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    aabe:	9b01      	ldr	r3, [sp, #4]
    aac0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aac4:	1c5a      	adds	r2, r3, #1
    aac6:	4904      	ldr	r1, [pc, #16]	; (aad8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    aac8:	9b01      	ldr	r3, [sp, #4]
    aaca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    aace:	bf00      	nop
    aad0:	b003      	add	sp, #12
    aad2:	f85d fb04 	ldr.w	pc, [sp], #4
    aad6:	bf00      	nop
    aad8:	1fff9044 	.word	0x1fff9044
    aadc:	1fff9040 	.word	0x1fff9040

0000aae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    aae0:	b500      	push	{lr}
    aae2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aae4:	f7f6 f862 	bl	bac <Sys_GetCoreID>
    aae8:	4603      	mov	r3, r0
    aaea:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    aaec:	4a0d      	ldr	r2, [pc, #52]	; (ab24 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    aaee:	9b01      	ldr	r3, [sp, #4]
    aaf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aaf4:	1e5a      	subs	r2, r3, #1
    aaf6:	490b      	ldr	r1, [pc, #44]	; (ab24 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    aaf8:	9b01      	ldr	r3, [sp, #4]
    aafa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    aafe:	4a0a      	ldr	r2, [pc, #40]	; (ab28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    ab00:	9b01      	ldr	r3, [sp, #4]
    ab02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ab06:	f003 0301 	and.w	r3, r3, #1
    ab0a:	2b00      	cmp	r3, #0
    ab0c:	d106      	bne.n	ab1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    ab0e:	4a05      	ldr	r2, [pc, #20]	; (ab24 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    ab10:	9b01      	ldr	r3, [sp, #4]
    ab12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ab16:	2b00      	cmp	r3, #0
    ab18:	d100      	bne.n	ab1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ab1a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ab1c:	bf00      	nop
    ab1e:	b003      	add	sp, #12
    ab20:	f85d fb04 	ldr.w	pc, [sp], #4
    ab24:	1fff9044 	.word	0x1fff9044
    ab28:	1fff9040 	.word	0x1fff9040

0000ab2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    ab2c:	b500      	push	{lr}
    ab2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ab30:	f7f6 f83c 	bl	bac <Sys_GetCoreID>
    ab34:	4603      	mov	r3, r0
    ab36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    ab38:	4a10      	ldr	r2, [pc, #64]	; (ab7c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    ab3a:	9b01      	ldr	r3, [sp, #4]
    ab3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ab40:	2b00      	cmp	r3, #0
    ab42:	d10d      	bne.n	ab60 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ab44:	f7f5 ff63 	bl	a0e <Port_schm_read_msr>
    ab48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ab4a:	9b00      	ldr	r3, [sp, #0]
    ab4c:	f003 0301 	and.w	r3, r3, #1
    ab50:	2b00      	cmp	r3, #0
    ab52:	d100      	bne.n	ab56 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ab54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    ab56:	490a      	ldr	r1, [pc, #40]	; (ab80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    ab58:	9b01      	ldr	r3, [sp, #4]
    ab5a:	9a00      	ldr	r2, [sp, #0]
    ab5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    ab60:	4a06      	ldr	r2, [pc, #24]	; (ab7c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    ab62:	9b01      	ldr	r3, [sp, #4]
    ab64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ab68:	1c5a      	adds	r2, r3, #1
    ab6a:	4904      	ldr	r1, [pc, #16]	; (ab7c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    ab6c:	9b01      	ldr	r3, [sp, #4]
    ab6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ab72:	bf00      	nop
    ab74:	b003      	add	sp, #12
    ab76:	f85d fb04 	ldr.w	pc, [sp], #4
    ab7a:	bf00      	nop
    ab7c:	1fff904c 	.word	0x1fff904c
    ab80:	1fff9048 	.word	0x1fff9048

0000ab84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    ab84:	b500      	push	{lr}
    ab86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ab88:	f7f6 f810 	bl	bac <Sys_GetCoreID>
    ab8c:	4603      	mov	r3, r0
    ab8e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    ab90:	4a0d      	ldr	r2, [pc, #52]	; (abc8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    ab92:	9b01      	ldr	r3, [sp, #4]
    ab94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ab98:	1e5a      	subs	r2, r3, #1
    ab9a:	490b      	ldr	r1, [pc, #44]	; (abc8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    ab9c:	9b01      	ldr	r3, [sp, #4]
    ab9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    aba2:	4a0a      	ldr	r2, [pc, #40]	; (abcc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    aba4:	9b01      	ldr	r3, [sp, #4]
    aba6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    abaa:	f003 0301 	and.w	r3, r3, #1
    abae:	2b00      	cmp	r3, #0
    abb0:	d106      	bne.n	abc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    abb2:	4a05      	ldr	r2, [pc, #20]	; (abc8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    abb4:	9b01      	ldr	r3, [sp, #4]
    abb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    abba:	2b00      	cmp	r3, #0
    abbc:	d100      	bne.n	abc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    abbe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    abc0:	bf00      	nop
    abc2:	b003      	add	sp, #12
    abc4:	f85d fb04 	ldr.w	pc, [sp], #4
    abc8:	1fff904c 	.word	0x1fff904c
    abcc:	1fff9048 	.word	0x1fff9048

0000abd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    abd0:	b500      	push	{lr}
    abd2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    abd4:	f7f5 ffea 	bl	bac <Sys_GetCoreID>
    abd8:	4603      	mov	r3, r0
    abda:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    abdc:	4a10      	ldr	r2, [pc, #64]	; (ac20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    abde:	9b01      	ldr	r3, [sp, #4]
    abe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    abe4:	2b00      	cmp	r3, #0
    abe6:	d10d      	bne.n	ac04 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    abe8:	f7f5 ff11 	bl	a0e <Port_schm_read_msr>
    abec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    abee:	9b00      	ldr	r3, [sp, #0]
    abf0:	f003 0301 	and.w	r3, r3, #1
    abf4:	2b00      	cmp	r3, #0
    abf6:	d100      	bne.n	abfa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    abf8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    abfa:	490a      	ldr	r1, [pc, #40]	; (ac24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    abfc:	9b01      	ldr	r3, [sp, #4]
    abfe:	9a00      	ldr	r2, [sp, #0]
    ac00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    ac04:	4a06      	ldr	r2, [pc, #24]	; (ac20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    ac06:	9b01      	ldr	r3, [sp, #4]
    ac08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac0c:	1c5a      	adds	r2, r3, #1
    ac0e:	4904      	ldr	r1, [pc, #16]	; (ac20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    ac10:	9b01      	ldr	r3, [sp, #4]
    ac12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ac16:	bf00      	nop
    ac18:	b003      	add	sp, #12
    ac1a:	f85d fb04 	ldr.w	pc, [sp], #4
    ac1e:	bf00      	nop
    ac20:	1fff9054 	.word	0x1fff9054
    ac24:	1fff9050 	.word	0x1fff9050

0000ac28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    ac28:	b500      	push	{lr}
    ac2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ac2c:	f7f5 ffbe 	bl	bac <Sys_GetCoreID>
    ac30:	4603      	mov	r3, r0
    ac32:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    ac34:	4a0d      	ldr	r2, [pc, #52]	; (ac6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    ac36:	9b01      	ldr	r3, [sp, #4]
    ac38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac3c:	1e5a      	subs	r2, r3, #1
    ac3e:	490b      	ldr	r1, [pc, #44]	; (ac6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    ac40:	9b01      	ldr	r3, [sp, #4]
    ac42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    ac46:	4a0a      	ldr	r2, [pc, #40]	; (ac70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    ac48:	9b01      	ldr	r3, [sp, #4]
    ac4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac4e:	f003 0301 	and.w	r3, r3, #1
    ac52:	2b00      	cmp	r3, #0
    ac54:	d106      	bne.n	ac64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    ac56:	4a05      	ldr	r2, [pc, #20]	; (ac6c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    ac58:	9b01      	ldr	r3, [sp, #4]
    ac5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac5e:	2b00      	cmp	r3, #0
    ac60:	d100      	bne.n	ac64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ac62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ac64:	bf00      	nop
    ac66:	b003      	add	sp, #12
    ac68:	f85d fb04 	ldr.w	pc, [sp], #4
    ac6c:	1fff9054 	.word	0x1fff9054
    ac70:	1fff9050 	.word	0x1fff9050

0000ac74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    ac74:	b500      	push	{lr}
    ac76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ac78:	f7f5 ff98 	bl	bac <Sys_GetCoreID>
    ac7c:	4603      	mov	r3, r0
    ac7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    ac80:	4a10      	ldr	r2, [pc, #64]	; (acc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    ac82:	9b01      	ldr	r3, [sp, #4]
    ac84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ac88:	2b00      	cmp	r3, #0
    ac8a:	d10d      	bne.n	aca8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ac8c:	f7f5 febf 	bl	a0e <Port_schm_read_msr>
    ac90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ac92:	9b00      	ldr	r3, [sp, #0]
    ac94:	f003 0301 	and.w	r3, r3, #1
    ac98:	2b00      	cmp	r3, #0
    ac9a:	d100      	bne.n	ac9e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ac9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    ac9e:	490a      	ldr	r1, [pc, #40]	; (acc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    aca0:	9b01      	ldr	r3, [sp, #4]
    aca2:	9a00      	ldr	r2, [sp, #0]
    aca4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    aca8:	4a06      	ldr	r2, [pc, #24]	; (acc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    acaa:	9b01      	ldr	r3, [sp, #4]
    acac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    acb0:	1c5a      	adds	r2, r3, #1
    acb2:	4904      	ldr	r1, [pc, #16]	; (acc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    acb4:	9b01      	ldr	r3, [sp, #4]
    acb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    acba:	bf00      	nop
    acbc:	b003      	add	sp, #12
    acbe:	f85d fb04 	ldr.w	pc, [sp], #4
    acc2:	bf00      	nop
    acc4:	1fff905c 	.word	0x1fff905c
    acc8:	1fff9058 	.word	0x1fff9058

0000accc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    accc:	b500      	push	{lr}
    acce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    acd0:	f7f5 ff6c 	bl	bac <Sys_GetCoreID>
    acd4:	4603      	mov	r3, r0
    acd6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    acd8:	4a0d      	ldr	r2, [pc, #52]	; (ad10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    acda:	9b01      	ldr	r3, [sp, #4]
    acdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ace0:	1e5a      	subs	r2, r3, #1
    ace2:	490b      	ldr	r1, [pc, #44]	; (ad10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    ace4:	9b01      	ldr	r3, [sp, #4]
    ace6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    acea:	4a0a      	ldr	r2, [pc, #40]	; (ad14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    acec:	9b01      	ldr	r3, [sp, #4]
    acee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    acf2:	f003 0301 	and.w	r3, r3, #1
    acf6:	2b00      	cmp	r3, #0
    acf8:	d106      	bne.n	ad08 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    acfa:	4a05      	ldr	r2, [pc, #20]	; (ad10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    acfc:	9b01      	ldr	r3, [sp, #4]
    acfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad02:	2b00      	cmp	r3, #0
    ad04:	d100      	bne.n	ad08 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ad06:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ad08:	bf00      	nop
    ad0a:	b003      	add	sp, #12
    ad0c:	f85d fb04 	ldr.w	pc, [sp], #4
    ad10:	1fff905c 	.word	0x1fff905c
    ad14:	1fff9058 	.word	0x1fff9058

0000ad18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    ad18:	b500      	push	{lr}
    ad1a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ad1c:	f7f5 ff46 	bl	bac <Sys_GetCoreID>
    ad20:	4603      	mov	r3, r0
    ad22:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    ad24:	4a10      	ldr	r2, [pc, #64]	; (ad68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    ad26:	9b01      	ldr	r3, [sp, #4]
    ad28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad2c:	2b00      	cmp	r3, #0
    ad2e:	d10d      	bne.n	ad4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ad30:	f7f5 fe6d 	bl	a0e <Port_schm_read_msr>
    ad34:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ad36:	9b00      	ldr	r3, [sp, #0]
    ad38:	f003 0301 	and.w	r3, r3, #1
    ad3c:	2b00      	cmp	r3, #0
    ad3e:	d100      	bne.n	ad42 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ad40:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    ad42:	490a      	ldr	r1, [pc, #40]	; (ad6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    ad44:	9b01      	ldr	r3, [sp, #4]
    ad46:	9a00      	ldr	r2, [sp, #0]
    ad48:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    ad4c:	4a06      	ldr	r2, [pc, #24]	; (ad68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    ad4e:	9b01      	ldr	r3, [sp, #4]
    ad50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad54:	1c5a      	adds	r2, r3, #1
    ad56:	4904      	ldr	r1, [pc, #16]	; (ad68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    ad58:	9b01      	ldr	r3, [sp, #4]
    ad5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ad5e:	bf00      	nop
    ad60:	b003      	add	sp, #12
    ad62:	f85d fb04 	ldr.w	pc, [sp], #4
    ad66:	bf00      	nop
    ad68:	1fff9064 	.word	0x1fff9064
    ad6c:	1fff9060 	.word	0x1fff9060

0000ad70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    ad70:	b500      	push	{lr}
    ad72:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ad74:	f7f5 ff1a 	bl	bac <Sys_GetCoreID>
    ad78:	4603      	mov	r3, r0
    ad7a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    ad7c:	4a0d      	ldr	r2, [pc, #52]	; (adb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    ad7e:	9b01      	ldr	r3, [sp, #4]
    ad80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad84:	1e5a      	subs	r2, r3, #1
    ad86:	490b      	ldr	r1, [pc, #44]	; (adb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    ad88:	9b01      	ldr	r3, [sp, #4]
    ad8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    ad8e:	4a0a      	ldr	r2, [pc, #40]	; (adb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    ad90:	9b01      	ldr	r3, [sp, #4]
    ad92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad96:	f003 0301 	and.w	r3, r3, #1
    ad9a:	2b00      	cmp	r3, #0
    ad9c:	d106      	bne.n	adac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    ad9e:	4a05      	ldr	r2, [pc, #20]	; (adb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    ada0:	9b01      	ldr	r3, [sp, #4]
    ada2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ada6:	2b00      	cmp	r3, #0
    ada8:	d100      	bne.n	adac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    adaa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    adac:	bf00      	nop
    adae:	b003      	add	sp, #12
    adb0:	f85d fb04 	ldr.w	pc, [sp], #4
    adb4:	1fff9064 	.word	0x1fff9064
    adb8:	1fff9060 	.word	0x1fff9060

0000adbc <Det_Init>:
*
*/
void Det_Init(void)
{
    /* Do nothing */
}
    adbc:	bf00      	nop
    adbe:	4770      	bx	lr

0000adc0 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
    adc0:	b510      	push	{r4, lr}
    adc2:	b084      	sub	sp, #16
    adc4:	4604      	mov	r4, r0
    adc6:	4608      	mov	r0, r1
    adc8:	4611      	mov	r1, r2
    adca:	461a      	mov	r2, r3
    adcc:	4623      	mov	r3, r4
    adce:	f8ad 3006 	strh.w	r3, [sp, #6]
    add2:	4603      	mov	r3, r0
    add4:	f88d 3005 	strb.w	r3, [sp, #5]
    add8:	460b      	mov	r3, r1
    adda:	f88d 3004 	strb.w	r3, [sp, #4]
    adde:	4613      	mov	r3, r2
    ade0:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ade4:	f7f5 fee2 	bl	bac <Sys_GetCoreID>
    ade8:	4603      	mov	r3, r0
    adea:	9303      	str	r3, [sp, #12]

    Det_ModuleId[u32CoreId] = ModuleId;
    adec:	490d      	ldr	r1, [pc, #52]	; (ae24 <Det_ReportError+0x64>)
    adee:	9b03      	ldr	r3, [sp, #12]
    adf0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    adf4:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
    adf8:	4a0b      	ldr	r2, [pc, #44]	; (ae28 <Det_ReportError+0x68>)
    adfa:	9b03      	ldr	r3, [sp, #12]
    adfc:	4413      	add	r3, r2
    adfe:	f89d 2005 	ldrb.w	r2, [sp, #5]
    ae02:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
    ae04:	4a09      	ldr	r2, [pc, #36]	; (ae2c <Det_ReportError+0x6c>)
    ae06:	9b03      	ldr	r3, [sp, #12]
    ae08:	4413      	add	r3, r2
    ae0a:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ae0e:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
    ae10:	4a07      	ldr	r2, [pc, #28]	; (ae30 <Det_ReportError+0x70>)
    ae12:	9b03      	ldr	r3, [sp, #12]
    ae14:	4413      	add	r3, r2
    ae16:	f89d 2003 	ldrb.w	r2, [sp, #3]
    ae1a:	701a      	strb	r2, [r3, #0]

    return E_OK;
    ae1c:	2300      	movs	r3, #0
}
    ae1e:	4618      	mov	r0, r3
    ae20:	b004      	add	sp, #16
    ae22:	bd10      	pop	{r4, pc}
    ae24:	1fff9090 	.word	0x1fff9090
    ae28:	1fff9068 	.word	0x1fff9068
    ae2c:	1fff906c 	.word	0x1fff906c
    ae30:	1fff9070 	.word	0x1fff9070

0000ae34 <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
    ae34:	b510      	push	{r4, lr}
    ae36:	b084      	sub	sp, #16
    ae38:	4604      	mov	r4, r0
    ae3a:	4608      	mov	r0, r1
    ae3c:	4611      	mov	r1, r2
    ae3e:	461a      	mov	r2, r3
    ae40:	4623      	mov	r3, r4
    ae42:	f8ad 3006 	strh.w	r3, [sp, #6]
    ae46:	4603      	mov	r3, r0
    ae48:	f88d 3005 	strb.w	r3, [sp, #5]
    ae4c:	460b      	mov	r3, r1
    ae4e:	f88d 3004 	strb.w	r3, [sp, #4]
    ae52:	4613      	mov	r3, r2
    ae54:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ae58:	f7f5 fea8 	bl	bac <Sys_GetCoreID>
    ae5c:	4603      	mov	r3, r0
    ae5e:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
    ae60:	490d      	ldr	r1, [pc, #52]	; (ae98 <Det_ReportRuntimeError+0x64>)
    ae62:	9b03      	ldr	r3, [sp, #12]
    ae64:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    ae68:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
    ae6c:	4a0b      	ldr	r2, [pc, #44]	; (ae9c <Det_ReportRuntimeError+0x68>)
    ae6e:	9b03      	ldr	r3, [sp, #12]
    ae70:	4413      	add	r3, r2
    ae72:	f89d 2005 	ldrb.w	r2, [sp, #5]
    ae76:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
    ae78:	4a09      	ldr	r2, [pc, #36]	; (aea0 <Det_ReportRuntimeError+0x6c>)
    ae7a:	9b03      	ldr	r3, [sp, #12]
    ae7c:	4413      	add	r3, r2
    ae7e:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ae82:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
    ae84:	4a07      	ldr	r2, [pc, #28]	; (aea4 <Det_ReportRuntimeError+0x70>)
    ae86:	9b03      	ldr	r3, [sp, #12]
    ae88:	4413      	add	r3, r2
    ae8a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    ae8e:	701a      	strb	r2, [r3, #0]

    return E_OK;
    ae90:	2300      	movs	r3, #0
}
    ae92:	4618      	mov	r0, r3
    ae94:	b004      	add	sp, #16
    ae96:	bd10      	pop	{r4, pc}
    ae98:	1fff9094 	.word	0x1fff9094
    ae9c:	1fff9074 	.word	0x1fff9074
    aea0:	1fff9078 	.word	0x1fff9078
    aea4:	1fff907c 	.word	0x1fff907c

0000aea8 <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
    aea8:	b510      	push	{r4, lr}
    aeaa:	b084      	sub	sp, #16
    aeac:	4604      	mov	r4, r0
    aeae:	4608      	mov	r0, r1
    aeb0:	4611      	mov	r1, r2
    aeb2:	461a      	mov	r2, r3
    aeb4:	4623      	mov	r3, r4
    aeb6:	f8ad 3006 	strh.w	r3, [sp, #6]
    aeba:	4603      	mov	r3, r0
    aebc:	f88d 3005 	strb.w	r3, [sp, #5]
    aec0:	460b      	mov	r3, r1
    aec2:	f88d 3004 	strb.w	r3, [sp, #4]
    aec6:	4613      	mov	r3, r2
    aec8:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    aecc:	f7f5 fe6e 	bl	bac <Sys_GetCoreID>
    aed0:	4603      	mov	r3, r0
    aed2:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
    aed4:	490d      	ldr	r1, [pc, #52]	; (af0c <Det_ReportTransientFault+0x64>)
    aed6:	9b03      	ldr	r3, [sp, #12]
    aed8:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    aedc:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
    aee0:	4a0b      	ldr	r2, [pc, #44]	; (af10 <Det_ReportTransientFault+0x68>)
    aee2:	9b03      	ldr	r3, [sp, #12]
    aee4:	4413      	add	r3, r2
    aee6:	f89d 2005 	ldrb.w	r2, [sp, #5]
    aeea:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
    aeec:	4a09      	ldr	r2, [pc, #36]	; (af14 <Det_ReportTransientFault+0x6c>)
    aeee:	9b03      	ldr	r3, [sp, #12]
    aef0:	4413      	add	r3, r2
    aef2:	f89d 2004 	ldrb.w	r2, [sp, #4]
    aef6:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
    aef8:	4a07      	ldr	r2, [pc, #28]	; (af18 <Det_ReportTransientFault+0x70>)
    aefa:	9b03      	ldr	r3, [sp, #12]
    aefc:	4413      	add	r3, r2
    aefe:	f89d 2003 	ldrb.w	r2, [sp, #3]
    af02:	701a      	strb	r2, [r3, #0]

    return E_OK;
    af04:	2300      	movs	r3, #0
}
    af06:	4618      	mov	r0, r3
    af08:	b004      	add	sp, #16
    af0a:	bd10      	pop	{r4, pc}
    af0c:	1fff908c 	.word	0x1fff908c
    af10:	1fff9080 	.word	0x1fff9080
    af14:	1fff9084 	.word	0x1fff9084
    af18:	1fff9088 	.word	0x1fff9088

0000af1c <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
    af1c:	bf00      	nop
    af1e:	4770      	bx	lr

0000af20 <Clock_Ip_au8DividerCallbackIndex>:
    af20:	0c00 0e0d 0201 0603 0409 0a07 0805 000b     ................

0000af30 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

0000af40 <Clock_Ip_au8XoscCallbackIndex>:
    af40:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000af50 <Clock_Ip_au8IrcoscCallbackIndex>:
    af50:	0100 0302 0004 0000 0000 0000 0000 0000     ................

0000af60 <Clock_Ip_au8GateCallbackIndex>:
    af60:	0200 0601 0301 0104 0500 0000 0000 0000     ................

0000af70 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

0000af80 <Clock_Ip_au8PllCallbackIndex>:
    af80:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000af90 <Clock_Ip_au8SelectorCallbackIndex>:
    af90:	0800 0a09 0109 0302 0504 0706 0000 0000     ................

0000afa0 <Clock_Ip_au8PcfsCallbackIndex>:
	...

0000afb0 <Clock_Ip_au8CmuCallbackIndex>:
	...

0000afc0 <Clock_Ip_au8ClockFeatures>:
	...
    afd0:	0000 0100 0000 0000 0000 0000 0002 0000     ................
    afe0:	0000 0000 0300 0000 0000 0000 0000 0004     ................
    aff0:	0000 0000 0000 0500 0000 0000 0000 0000     ................
    b000:	0006 0000 0000 0000 0100 0000 0000 0000     ................
    b010:	0000 0001 0000 0000 0000 0400 0000 0000     ................
    b020:	0000 0000 0005 0000 0001 0000 0401 0000     ................
    b030:	0200 0000 0100 0005 0000 0003 0000 0402     ................
    b040:	0000 0400 0000 0200 0005 0000 0005 0000     ................
    b050:	0403 0000 0600 0000 0300 0005 0000 0007     ................
    b060:	0000 0500 0000 0000 0000 0000 0006 0000     ................
	...
    b0a0:	0000 0005 0000 0000 0000 0600 0100 0000     ................
    b0b0:	0000 0000 0007 0003 0000 0000 0000 0000     ................
    b0c0:	0000 0000 0000 0006 0000 0000 0000 0700     ................
    b0d0:	0100 0000 0000 0000 0008 0003 0000 0000     ................
	...
    b0e8:	0000 0009 0000 0000 0000 0a00 0100 0000     ................
    b0f8:	0000 0000 000b 0003 0000 0000 0000 0000     ................
    b108:	0000 0000 0000 000c 0000 0000 0000 0d00     ................
    b118:	0100 0000 0000 0000 000e 0003 0000 0000     ................
    b128:	0800 0000 0000 0000 0000 0009 0000 0000     ................
    b138:	0000 0a00 0000 0000 0000 0000 000b 0000     ................
    b148:	0000 0000 0b01 0000 0000 0000 0200 000b     ................
    b158:	0000 0000 0000 0b03 0000 0000 0000 0000     ................
	...
    b170:	0400 0000 003b 003b 0000 0004 2700 2700     ....;.;......'.'
    b180:	0000 0100 0000 0000 0000 0000 0007 0000     ................
    b190:	7300 0000 0700 0000 0000 0032 0000 0009     .s........2.....
    b1a0:	0000 0200 0000 0700 0000 0000 0021 0000     ............!...
    b1b0:	0009 0000 0400 0000 0900 0000 0000 0003     ................
    b1c0:	0000 0007 0000 6100 0000 0700 0000 0000     .......a........
    b1d0:	0024 0000 0007 0000 2500 0000 0700 0000     $........%......
    b1e0:	0000 002b 0000 0004 5a00 5a00 0000 0700     ..+......Z.Z....
    b1f0:	0000 0000 0020 0000 0004 3800 3800 0000     .... ......8.8..
    b200:	0400 0000 0039 0039 0000 0004 3a00 3a00     ....9.9......:.:
    b210:	0000 0400 0000 0026 0026 0000 0004 6600     ......&.&......f
    b220:	6600 0000 0400 0000 0037 0037 0000 0004     .f......7.7.....
    b230:	2c00 2c00 0000 0400 0000 002d 002d 0000     .,.,......-.-...
    b240:	0004 2e00 2e00 0000 0200 0000 4040 0040     ............@@@.
    b250:	0000 0004 6a00 6a00 0000 0400 0000 006b     .....j.j......k.
    b260:	006b 0000 0004 6c00 6c00 0000 0900 0000     k......l.l......
    b270:	0000 0001 0000 0009 0000 0000 0000 0700     ................
    b280:	0000 0000 0036 0000 0007 0000 3100 0000     ....6........1..
    b290:	0700 0000 0000 0049 0000 0007 0000 4a00     ......I........J
    b2a0:	0000 0700 0000 0000 004b 0000 0007 0000     ........K.......
    b2b0:	4c00 0000 0700 0000 0000 004d 0000 0007     .L........M.....
    b2c0:	0000 3d00 0000 0300 0000 0000 0000 0000     ...=............

0000b2d0 <Clock_Ip_au16SelectorEntryHardwareValue>:
    b2d0:	0a03 0101 0001 0101 0002 0404 0603 0200     ................
    b2e0:	0810 0001 0100 0202 0000 0000 0007 0000     ................
    b2f0:	0009 0000 0000 0000 0c0e 0000 0000 0000     ................
	...

0000b328 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    b328:	0000 0002 0300 0000 0601 0000 0000 0000     ................
	...

0000b358 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    b358:	0700 0000 0000 0000 0000 0202 0303 0101     ................
    b368:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000b388 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    b388:	0001 0000 0000 0000 0000 0202 0303 0101     ................
    b398:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000b3b8 <Clock_Ip_au8DividerValueHardwareValue>:
    b3b8:	0100 0002 0003 0000 0004 0000 0000 0000     ................
    b3c8:	0005 0000 0000 0000 0000 0000 0000 0000     ................
    b3d8:	0006 0000 0000 0000 0000 0000 0000 0000     ................
	...
    b3f8:	0007 0000                                   ....

0000b3fc <Clock_Ip_apxScgPeriphAsyncDivs>:
    b3fc:	4204 4006 4304 4006 4104 4006 4604 4006     .B.@.C.@.A.@.F.@

0000b40c <Clock_Ip_aeSourceTypeClockName>:
    b40c:	0000 0000 0001 0000 0001 0000 0001 0000     ................
    b41c:	0001 0000 0001 0000 0001 0000 0001 0000     ................
    b42c:	0002 0000 0003 0000 0001 0000 0001 0000     ................
    b43c:	0001 0000 0001 0000 0002 0000 0002 0000     ................
    b44c:	0003 0000 0003 0000 0001 0000 0001 0000     ................
    b45c:	0004 0000 0004 0000 0004 0000 0004 0000     ................
	...

0000b4c8 <Clock_Ip_aeHwPllName>:
    b4c8:	0009 0000                                   ....

0000b4cc <Clock_Ip_aeHwDfsName>:
    b4cc:	0057 0000                                   W...

0000b4d0 <Clock_Ip_axDividerCallbacks>:
    b4d0:	1cc1 0000 1ccb 0000 1ce5 0000 1cff 0000     ................
    b4e0:	1d19 0000 1d33 0000 1d4d 0000 1d67 0000     ....3...M...g...
    b4f0:	1d81 0000 1d9b 0000 1db5 0000 1dcf 0000     ................
    b500:	1de9 0000 1e03 0000 1e1d 0000               ............

0000b50c <Clock_Ip_axDividerTriggerCallbacks>:
    b50c:	2191 0000 2191 0000                         .!...!..

0000b514 <Clock_Ip_axExtOscCallbacks>:
    b514:	219d 0000 219d 0000 219d 0000 21a7 0000     .!...!...!...!..
    b524:	219d 0000 21b1 0000 21cb 0000 21e5 0000     .!...!...!...!..
    b534:	2269 0000 227d 0000                         i"..}"..

0000b53c <Clock_Ip_axFracDivCallbacks>:
    b53c:	243d 0000 243d 0000 2447 0000               =$..=$..G$..

0000b548 <Clock_Ip_axGateCallbacks>:
    b548:	2461 0000 246b 0000 256b 0000 2585 0000     a$..k$..k%...%..
    b558:	251b 0000 2535 0000 24cb 0000 24e5 0000     .%..5%...$...$..
    b568:	247b 0000 2495 0000 25bb 0000 25d5 0000     {$...$...%...%..
    b578:	260b 0000 2625 0000                         .&..%&..

0000b580 <Clock_Ip_axIntOscCallbacks>:
    b580:	27d1 0000 27d1 0000 27db 0000 27e5 0000     .'...'...'...'..
    b590:	27ff 0000 2819 0000 282d 0000 2847 0000     .'...(..-(..G(..
    b5a0:	2861 0000 2875 0000 288f 0000 28a9 0000     a(..u(...(...(..
    b5b0:	2951 0000 296b 0000 2985 0000               Q)..k)...)..

0000b5bc <Clock_Ip_axCmuCallbacks>:
    b5bc:	2f21 0000 2f2b 0000 2f37 0000 2f21 0000     !/..+/..7/..!/..

0000b5cc <Clock_Ip_axPllCallbacks>:
    b5cc:	2f41 0000 2f41 0000 2f4b 0000 2f41 0000     A/..A/..K/..A/..
    b5dc:	2f57 0000 2f61 0000 2f7b 0000 2f95 0000     W/..a/..{/.../..
    b5ec:	3039 0000 3025 0000                         90..%0..

0000b5f4 <Clock_Ip_axPcfsCallbacks>:
    b5f4:	3195 0000                                   .1..

0000b5f8 <Clock_Ip_axSelectorCallbacks>:
    b5f8:	31a1 0000 31a1 0000 31ab 0000 31c5 0000     .1...1...1...1..
    b608:	31a1 0000 31df 0000 31f9 0000 3213 0000     .1...1...1...2..
    b618:	322d 0000 3247 0000 3261 0000 327b 0000     -2..G2..a2..{2..
    b628:	3295 0000 32af 0000 32c9 0000 32e3 0000     .2...2...2...2..
    b638:	32fd 0000 3317 0000 3331 0000 334b 0000     .2...3..13..K3..
    b648:	3365 0000 337f 0000                         e3...3..

0000b650 <ClockSource>:
    b650:	0000 0000 0008 0000 0002 0000 0005 0000     ................
	...
    b668:	0009 0000                                   ....

0000b66c <ResetReasonArray>:
    b66c:	0000 0000 0001 0000 0002 0000 0003 0000     ................
    b67c:	0004 0000 0005 0000 0006 0000 0007 0000     ................
    b68c:	0008 0000 0009 0000 000a 0000 000b 0000     ................
    b69c:	000c 0000 000d 0000 000e 0000               ............

0000b6a8 <Port_au32PortCiPortBaseAddr>:
    b6a8:	9000 4004 a000 4004 b000 4004 c000 4004     ...@...@...@...@
    b6b8:	d000 4004                                   ...@

0000b6bc <Port_au32PortCiGpioBaseAddr>:
    b6bc:	f000 400f f040 400f f080 400f f0c0 400f     ...@@..@...@...@
    b6cc:	f100 400f                                   ...@

0000b6d0 <ftmGptBase>:
    b6d0:	8000 4003 9000 4003 a000 4003 6000 4002     ...@...@...@.`.@

0000b6e0 <Mcu_aClockConfigPB>:
	...
    b6e8:	0101 1c00 0010 0400 0029 0100 0005 0000     ........).......
    b6f8:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    b708:	0000 0000 0008 0000 1200 007a 0001 0000     ..........z.....
    b718:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    b728:	0057 0000 0000 0000 0000 0000 0000 0000     W...............
	...
    b748:	0019 0000 0005 0000 001a 0000 0002 0000     ................
    b758:	001b 0000 0005 0000 002a 0000 0005 0000     ........*.......
    b768:	0028 0000 000e 0000 0029 0000 0001 0000     (.......).......
    b778:	0056 0000 001c 0000 0032 0000 002a 0000     V.......2...*...
    b788:	002b 0000 0014 0000 002c 0000 0014 0000     +.......,.......
    b798:	002d 0000 0014 0000 002e 0000 0014 0000     -...............
    b7a8:	003f 0000 0000 0000 0040 0000 0000 0000     ?.......@.......
    b7b8:	0041 0000 0000 0000 0042 0000 0000 0000     A.......B.......
    b7c8:	0031 0000 0000 0000 0045 0000 0000 0000     1.......E.......
    b7d8:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    b7e8:	0044 0000 0000 0000 0030 0000 0000 0000     D.......0.......
    b7f8:	003d 0000 0000 0000 0043 0000 0000 0000     =.......C.......
    b808:	0049 0000 0000 0000 004a 0000 0000 0000     I.......J.......
    b818:	004b 0000 0000 0000 0048 0000 0000 0000     K.......H.......
    b828:	000c 0000 0001 0000 0000 0000 000d 0000     ................
    b838:	0002 0000 0000 0000 000e 0000 0001 0000     ................
    b848:	0000 0000 000f 0000 0001 0000 0000 0000     ................
    b858:	001d 0000 0001 0000 0000 0000 001e 0000     ................
    b868:	0008 0000 0000 0000 001f 0000 0001 0000     ................
    b878:	0000 0000 0021 0000 0001 0000 0000 0000     ....!...........
    b888:	0022 0000 0002 0000 0000 0000 0023 0000     "...........#...
    b898:	0001 0000 0000 0000 0025 0000 0003 0000     ........%.......
    b8a8:	0000 0000 0026 0000 0004 0000 0000 0000     ....&...........
    b8b8:	0027 0000 0002 0000 0000 0000 0032 0000     '...........2...
    b8c8:	0001 0000 0000 0000 0048 0000 0001 0000     ........H.......
    b8d8:	0001 0000 0056 0000 0001 0000 0001 0000     ....V...........
    b8e8:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    b900:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    b918:	0057 0000 0000 0000 0057 0000 0057 0000     W.......W...W...
	...
    b934:	0014 0000 7d00 0000 0015 0000 7d00 0000     .....}.......}..
    b944:	0016 0000 7d00 0000 0017 0000 8000 0000     .....}..........
    b954:	0012 0000 0001 0000 0013 0000 0001 0000     ................
    b964:	0030 0000 0000 0000 0031 0000 0000 0000     0.......1.......
    b974:	0032 0000 0000 0000 0033 0000 0000 0000     2.......3.......
    b984:	0034 0000 0000 0000 0035 0000 0001 0000     4.......5.......
    b994:	0036 0000 0000 0000 0037 0000 0001 0000     6.......7.......
    b9a4:	0038 0000 0001 0000 0039 0000 0000 0000     8.......9.......
    b9b4:	003a 0000 0000 0000 003b 0000 0000 0000     :.......;.......
    b9c4:	003c 0000 0000 0000 003d 0000 0000 0000     <.......=.......
    b9d4:	003e 0000 0000 0000 003f 0000 0001 0000     >.......?.......
    b9e4:	0040 0000 0000 0000 0041 0000 0000 0000     @.......A.......
    b9f4:	0042 0000 0000 0000 0043 0000 0000 0000     B.......C.......
    ba04:	0044 0000 0000 0000 0045 0000 0000 0000     D.......E.......
    ba14:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    ba24:	0048 0000 0000 0000 0049 0000 0000 0000     H.......I.......
    ba34:	004a 0000 0000 0000 004b 0000 0000 0000     J.......K.......
    ba44:	004c 0000 0001 0000 004d 0000 0001 0000     L.......M.......
    ba54:	004e 0000 0000 0000 004f 0000 0000 0000     N.......O.......
    ba64:	0050 0000 0001 0000 0051 0000 0001 0000     P.......Q.......
    ba74:	0052 0000 0001 0000 0053 0000 0001 0000     R.......S.......
    ba84:	0054 0000 0001 0000 0055 0000 0000 0000     T.......U.......
    ba94:	0056 0000 0001 0000 0057 0000 0000 0000     V.......W.......
    baa4:	0000 0000 0057 0000 0000 0000 0057 0000     ....W.......W...
	...

0000bad8 <FTM_0_InitConfig_PB>:
    bad8:	0000 0000 0001 0000 0007 0000 0001 0000     ................

0000bae8 <FTM_0_ChannelConfig_PB>:
    bae8:	0000 0000 7271 0000 0000 0000 0001 0000     ....qr..........

0000baf8 <Gpt_pInitPredefTimerChannelPB>:
	...

0000bb08 <u8GptChannelIdToIndexMap>:
    bb08:	0000 0000                                   ....

0000bb0c <Gpt_InitChannelPB>:
	...
    bb18:	ffff 0000 0001 0000 8b48 1fff               ........H...

0000bb24 <Gpt_Config>:
    bb24:	0001 0000 bb0c 0000 0001 0000 8b38 1fff     ............8...
    bb34:	baf8 0000 bb08 0000                         ........

0000bb3c <Mcu_Config>:
    bb3c:	005a 0000 0000 0000 0001 0000 0001 0000     Z...............
    bb4c:	bccc 0000 b6e0 0000 bcd8 0000               ............

0000bb58 <OsIf_xPredefinedConfig>:
    bb58:	0000 0000 6c00 02dc                         .....l..

0000bb60 <OsIf_apxPredefinedConfig>:
    bb60:	bb58 0000                                   X...

0000bb64 <g_pin_mux_InitConfigArr>:
    bb64:	c000 4004 f0c0 400f 0000 0000 0002 0000     ...@...@........
    bb74:	0001 0000 0002 0000 0000 0000 0000 0000     ................
    bb84:	0000 0000 0100 0000 c000 4004 f0c0 400f     ...........@...@
    bb94:	0010 0000 0002 0000 0001 0000 0002 0000     ................
	...
    bbb0:	0100 0000                                   ....

0000bbb4 <au8Port_PartitionList>:
    bbb4:	0001 0000                                   ....

0000bbb8 <au32Port_PinToPartitionMap>:
    bbb8:	0001 0000 0001 0000                         ........

0000bbc0 <Port_au16NoUnUsedPadsArrayDefault>:
    bbc0:	0000 0001 0002 0003 0006 0007 0008 0009     ................
    bbd0:	000b 000c 000d 000e 000f 0010 0011 0020     .............. .
    bbe0:	0021 0022 0023 0024 0025 0026 0027 0028     !.".#.$.%.&.'.(.
    bbf0:	0029 002a 002b 002c 002d 002e 002f 0030     ).*.+.,.-.../.0.
    bc00:	0031 0040 0041 0042 0043 0046 0047 0048     1.@.A.B.C.F.G.H.
    bc10:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
    bc20:	0051 0061 0062 0063 0064 0065 0066 0067     Q.a.b.c.d.e.f.g.
    bc30:	0068 0069 006a 006b 006c 006d 006e 006f     h.i.j.k.l.m.n.o.
    bc40:	0071 0080 0081 0082 0083 0084 0085 0086     q...............
    bc50:	0087 0088 0089 008a 008b 008c 008d 008e     ................
    bc60:	008f 0090                                   ....

0000bc64 <Port_UnUsedPin>:
    bc64:	0100 0000 0001 0000 0000 0000               ............

0000bc70 <Port_aPinConfigDefault>:
    bc70:	0060 0000 0100 0000 0001 0000 0002 0000     `...............
    bc80:	0001 0001 0070 0000 0100 0000 0001 0000     ....p...........
    bc90:	0002 0000 0001 0001                         ........

0000bc98 <Port_Config>:
    bc98:	0002 0052 bbc0 0000 bc64 0000 bc70 0000     ..R.....d...p...
	...
    bcb0:	bbb8 0000 bbb4 0000 bb64 0000               ........d...

0000bcbc <Power_Ip_RCM_ConfigPB>:
	...

0000bcc4 <Power_Ip_PMC_ConfigPB>:
    bcc4:	0000 0000                                   ....

0000bcc8 <Power_Ip_SMC_ConfigPB>:
    bcc8:	0000 0000                                   ....

0000bccc <Power_Ip_aModeConfigPB>:
	...

0000bcd8 <Power_Ip_HwIPsConfigPB>:
    bcd8:	bcbc 0000 bcc4 0000 bcc8 0000               ............

0000bce4 <__INIT_TABLE>:
    bce4:	00000002 	.word	0x00000002
    bce8:	1fff8b10 	.word	0x1fff8b10
    bcec:	0000bd0c 	.word	0x0000bd0c
    bcf0:	0000bd5c 	.word	0x0000bd5c
    bcf4:	1fff8800 	.word	0x1fff8800
    bcf8:	00000000 	.word	0x00000000
    bcfc:	00000310 	.word	0x00000310

0000bd00 <__ZERO_TABLE>:
    bd00:	00000001 	.word	0x00000001
    bd04:	1fff8b60 	.word	0x1fff8b60
    bd08:	1fff90a0 	.word	0x1fff90a0
