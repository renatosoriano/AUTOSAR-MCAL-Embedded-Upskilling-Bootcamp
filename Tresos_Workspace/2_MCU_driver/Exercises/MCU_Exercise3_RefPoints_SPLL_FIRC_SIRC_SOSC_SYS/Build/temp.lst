
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000aa7 	.word	0x00000aa7
  10:	00000aa9 	.word	0x00000aa9
  14:	00000aab 	.word	0x00000aab
  18:	00000aad 	.word	0x00000aad
	...
  2c:	00000aaf 	.word	0x00000aaf
  30:	00000ab1 	.word	0x00000ab1
  34:	00000000 	.word	0x00000000
  38:	00000ab3 	.word	0x00000ab3
  3c:	00000ab5 	.word	0x00000ab5
  40:	00000ab7 	.word	0x00000ab7
  44:	00000ab7 	.word	0x00000ab7
  48:	00000ab7 	.word	0x00000ab7
  4c:	00000ab7 	.word	0x00000ab7
  50:	00000ab7 	.word	0x00000ab7
  54:	00000ab7 	.word	0x00000ab7
  58:	00000ab7 	.word	0x00000ab7
  5c:	00000ab7 	.word	0x00000ab7
  60:	00000ab7 	.word	0x00000ab7
  64:	00000ab7 	.word	0x00000ab7
  68:	00000ab7 	.word	0x00000ab7
  6c:	00000ab7 	.word	0x00000ab7
  70:	00000ab7 	.word	0x00000ab7
  74:	00000ab7 	.word	0x00000ab7
  78:	00000ab7 	.word	0x00000ab7
  7c:	00000ab7 	.word	0x00000ab7
  80:	00000ab7 	.word	0x00000ab7
  84:	00000ab7 	.word	0x00000ab7
  88:	00000ab7 	.word	0x00000ab7
  8c:	00000ab7 	.word	0x00000ab7
  90:	00000ab7 	.word	0x00000ab7
  94:	00000ab7 	.word	0x00000ab7
  98:	00000ab7 	.word	0x00000ab7
  9c:	00000ab7 	.word	0x00000ab7
  a0:	00000ab7 	.word	0x00000ab7
  a4:	00000ab7 	.word	0x00000ab7
  a8:	00000ab7 	.word	0x00000ab7
  ac:	00000ab7 	.word	0x00000ab7
  b0:	00000ab7 	.word	0x00000ab7
  b4:	00000ab7 	.word	0x00000ab7
  b8:	00000ab7 	.word	0x00000ab7
  bc:	00000ab7 	.word	0x00000ab7
  c0:	00000ab7 	.word	0x00000ab7
  c4:	00000ab7 	.word	0x00000ab7
  c8:	00000ab7 	.word	0x00000ab7
  cc:	00000ab7 	.word	0x00000ab7
  d0:	00000ab7 	.word	0x00000ab7
  d4:	00000ab7 	.word	0x00000ab7
  d8:	00000ab7 	.word	0x00000ab7
  dc:	00000ab7 	.word	0x00000ab7
  e0:	00000ab7 	.word	0x00000ab7
  e4:	00000ab7 	.word	0x00000ab7
  e8:	00000ab7 	.word	0x00000ab7
  ec:	00000ab7 	.word	0x00000ab7
  f0:	00000ab7 	.word	0x00000ab7
  f4:	00000ab7 	.word	0x00000ab7
  f8:	00000ab7 	.word	0x00000ab7
  fc:	00000ab7 	.word	0x00000ab7
 100:	00000ab7 	.word	0x00000ab7
 104:	00000ab7 	.word	0x00000ab7
 108:	00000ab7 	.word	0x00000ab7
 10c:	00000ab7 	.word	0x00000ab7
 110:	00000ab7 	.word	0x00000ab7
 114:	00000ab7 	.word	0x00000ab7
 118:	00000ab7 	.word	0x00000ab7
 11c:	00000ab7 	.word	0x00000ab7
 120:	00000ab7 	.word	0x00000ab7
 124:	00000ab7 	.word	0x00000ab7
 128:	00000ab7 	.word	0x00000ab7
 12c:	00000ab7 	.word	0x00000ab7
 130:	00000ab7 	.word	0x00000ab7
 134:	00000ab7 	.word	0x00000ab7
 138:	00000ab7 	.word	0x00000ab7
 13c:	00000ab7 	.word	0x00000ab7
 140:	00000ab7 	.word	0x00000ab7
 144:	00000ab7 	.word	0x00000ab7
 148:	00000ab7 	.word	0x00000ab7
 14c:	00000ab7 	.word	0x00000ab7
 150:	00000ab7 	.word	0x00000ab7
 154:	00000ab7 	.word	0x00000ab7
 158:	00000ab7 	.word	0x00000ab7
 15c:	00000ab7 	.word	0x00000ab7
 160:	00000ab7 	.word	0x00000ab7
 164:	00000ab7 	.word	0x00000ab7
 168:	00000ab7 	.word	0x00000ab7
 16c:	00000ab7 	.word	0x00000ab7
 170:	00000ab7 	.word	0x00000ab7
 174:	00000ab7 	.word	0x00000ab7
 178:	00000ab7 	.word	0x00000ab7
 17c:	00000ab7 	.word	0x00000ab7
 180:	00000ab7 	.word	0x00000ab7
 184:	00000ab7 	.word	0x00000ab7
 188:	00000ab7 	.word	0x00000ab7
 18c:	00000ab7 	.word	0x00000ab7
 190:	00000ab7 	.word	0x00000ab7
 194:	00000ab7 	.word	0x00000ab7
 198:	00000ab7 	.word	0x00000ab7
 19c:	00000ab7 	.word	0x00000ab7
 1a0:	00000ab7 	.word	0x00000ab7
 1a4:	00000ab7 	.word	0x00000ab7
 1a8:	00000ab7 	.word	0x00000ab7
 1ac:	00000ab7 	.word	0x00000ab7
 1b0:	00000ab7 	.word	0x00000ab7
 1b4:	00000ab7 	.word	0x00000ab7
 1b8:	00000ab7 	.word	0x00000ab7
 1bc:	00000ab7 	.word	0x00000ab7
 1c0:	00000ab7 	.word	0x00000ab7
 1c4:	00000ab7 	.word	0x00000ab7
 1c8:	00000ab7 	.word	0x00000ab7
 1cc:	00000ab7 	.word	0x00000ab7
 1d0:	00000ab7 	.word	0x00000ab7
 1d4:	00000ab7 	.word	0x00000ab7
 1d8:	00000ab7 	.word	0x00000ab7
 1dc:	00000ab7 	.word	0x00000ab7
 1e0:	00000ab7 	.word	0x00000ab7
 1e4:	00000ab7 	.word	0x00000ab7
 1e8:	00000ab7 	.word	0x00000ab7
 1ec:	00000ab7 	.word	0x00000ab7
 1f0:	00000ab7 	.word	0x00000ab7
 1f4:	00000ab7 	.word	0x00000ab7
 1f8:	00000ab7 	.word	0x00000ab7
 1fc:	00000ab7 	.word	0x00000ab7
 200:	00000ab7 	.word	0x00000ab7
 204:	00000ab7 	.word	0x00000ab7
 208:	00000ab7 	.word	0x00000ab7
 20c:	00000ab7 	.word	0x00000ab7
 210:	00000ab7 	.word	0x00000ab7
 214:	00000ab7 	.word	0x00000ab7
 218:	00000ab7 	.word	0x00000ab7
 21c:	00000ab7 	.word	0x00000ab7
 220:	00000ab7 	.word	0x00000ab7
 224:	00000ab7 	.word	0x00000ab7
 228:	00000ab7 	.word	0x00000ab7
 22c:	00000ab7 	.word	0x00000ab7
 230:	00000ab7 	.word	0x00000ab7
 234:	00000ab7 	.word	0x00000ab7
 238:	00000ab7 	.word	0x00000ab7
 23c:	00000ab7 	.word	0x00000ab7
 240:	00000ab7 	.word	0x00000ab7
 244:	00000ab7 	.word	0x00000ab7
 248:	00000ab7 	.word	0x00000ab7
 24c:	00000ab7 	.word	0x00000ab7
 250:	00000ab7 	.word	0x00000ab7
 254:	00000ab7 	.word	0x00000ab7
 258:	00000ab7 	.word	0x00000ab7
 25c:	00000ab7 	.word	0x00000ab7
 260:	00000ab7 	.word	0x00000ab7
 264:	00000ab7 	.word	0x00000ab7
 268:	00000ab7 	.word	0x00000ab7
 26c:	00000ab7 	.word	0x00000ab7
 270:	00000ab7 	.word	0x00000ab7
 274:	00000ab7 	.word	0x00000ab7
 278:	00000ab7 	.word	0x00000ab7
 27c:	00000ab7 	.word	0x00000ab7
 280:	00000ab7 	.word	0x00000ab7
 284:	00000ab7 	.word	0x00000ab7
 288:	00000ab7 	.word	0x00000ab7
 28c:	00000ab7 	.word	0x00000ab7
 290:	00000ab7 	.word	0x00000ab7
 294:	00000ab7 	.word	0x00000ab7
 298:	00000ab7 	.word	0x00000ab7
 29c:	00000ab7 	.word	0x00000ab7
 2a0:	00000ab7 	.word	0x00000ab7
 2a4:	00000ab7 	.word	0x00000ab7
 2a8:	00000ab7 	.word	0x00000ab7
 2ac:	00000ab7 	.word	0x00000ab7
 2b0:	00000ab7 	.word	0x00000ab7
 2b4:	00000ab7 	.word	0x00000ab7
 2b8:	00000ab7 	.word	0x00000ab7
 2bc:	00000ab7 	.word	0x00000ab7
 2c0:	00000ab7 	.word	0x00000ab7
 2c4:	00000ab7 	.word	0x00000ab7
 2c8:	00000ab7 	.word	0x00000ab7
 2cc:	00000ab7 	.word	0x00000ab7
 2d0:	00000ab7 	.word	0x00000ab7
 2d4:	00000ab7 	.word	0x00000ab7
 2d8:	00000ab7 	.word	0x00000ab7
 2dc:	00000ab7 	.word	0x00000ab7
 2e0:	00000ab7 	.word	0x00000ab7
 2e4:	00000ab7 	.word	0x00000ab7
 2e8:	00000ab7 	.word	0x00000ab7
 2ec:	00000ab7 	.word	0x00000ab7
 2f0:	00000ab7 	.word	0x00000ab7
 2f4:	00000ab7 	.word	0x00000ab7
 2f8:	00000ab7 	.word	0x00000ab7
 2fc:	00000ab7 	.word	0x00000ab7
 300:	00000ab7 	.word	0x00000ab7
 304:	00000ab7 	.word	0x00000ab7
 308:	00000ab7 	.word	0x00000ab7
 30c:	00000ab7 	.word	0x00000ab7

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fa47 	bl	914 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fb06 	bl	a9c <startup_go_to_user_mode>
     490:	f000 fa0e 	bl	8b0 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff8de0 	.word	0x1fff8de0

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fa51 	bl	a40 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <main>:
 * This is the main function of the project, it is the entry point of the program
 * 
 * @return Always zero
*/
int main( void )
{
     8b0:	b508      	push	{r3, lr}
    EcuM_Init();
     8b2:	f000 f801 	bl	8b8 <EcuM_Init>

    while( 1u )
     8b6:	e7fe      	b.n	8b6 <main+0x6>

000008b8 <EcuM_Init>:
 * 
 * it is just a temporary function, in the future this function will be replaced when the EcuM module 
 * is configured and implemented
*/
void EcuM_Init( void )
{
     8b8:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );
     8ba:	480b      	ldr	r0, [pc, #44]	; (8e8 <EcuM_Init+0x30>)
     8bc:	f003 fea6 	bl	460c <Mcu_Init>
    Mcu_InitClock( McuClockSettingConfig_0 );
     8c0:	2000      	movs	r0, #0
     8c2:	f003 fef7 	bl	46b4 <Mcu_InitClock>
    /* Busy wait until the System PLL is locked */
    while(MCU_PLL_LOCKED != Mcu_GetPllStatus());
     8c6:	bf00      	nop
     8c8:	f003 ff47 	bl	475a <Mcu_GetPllStatus>
     8cc:	4603      	mov	r3, r0
     8ce:	2b00      	cmp	r3, #0
     8d0:	d1fa      	bne.n	8c8 <EcuM_Init+0x10>
    Mcu_DistributePllClock();
     8d2:	f003 ff35 	bl	4740 <Mcu_DistributePllClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     8d6:	2000      	movs	r0, #0
     8d8:	f003 ff10 	bl	46fc <Mcu_SetMode>
    /*Apply all the Pin Port microcontroller configuration, for this case
    only Port Pin 122  (D16) is configured as output*/
    Port_Init( &Port_Config );
     8dc:	4803      	ldr	r0, [pc, #12]	; (8ec <EcuM_Init+0x34>)
     8de:	f004 fac3 	bl	4e68 <Port_Init>
}
     8e2:	bf00      	nop
     8e4:	bd08      	pop	{r3, pc}
     8e6:	bf00      	nop
     8e8:	00007814 	.word	0x00007814
     8ec:	00007934 	.word	0x00007934

000008f0 <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     8f0:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     8f2:	f3ef 8310 	mrs	r3, PRIMASK
     8f6:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     8f8:	4623      	mov	r3, r4
}
     8fa:	4618      	mov	r0, r3
     8fc:	f85d 4b04 	ldr.w	r4, [sp], #4
     900:	4770      	bx	lr

00000902 <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     902:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     904:	f3ef 8310 	mrs	r3, PRIMASK
     908:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     90a:	4623      	mov	r3, r4
}
     90c:	4618      	mov	r0, r3
     90e:	f85d 4b04 	ldr.w	r4, [sp], #4
     912:	4770      	bx	lr

00000914 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     914:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     916:	2300      	movs	r3, #0
     918:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     91a:	2300      	movs	r3, #0
     91c:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     91e:	2300      	movs	r3, #0
     920:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     922:	2300      	movs	r3, #0
     924:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     926:	4b44      	ldr	r3, [pc, #272]	; (a38 <init_data_bss+0x124>)
     928:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     92a:	4b44      	ldr	r3, [pc, #272]	; (a3c <init_data_bss+0x128>)
     92c:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     92e:	9b05      	ldr	r3, [sp, #20]
     930:	681b      	ldr	r3, [r3, #0]
     932:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     934:	9b05      	ldr	r3, [sp, #20]
     936:	3304      	adds	r3, #4
     938:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     93a:	9b05      	ldr	r3, [sp, #20]
     93c:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     93e:	2300      	movs	r3, #0
     940:	9309      	str	r3, [sp, #36]	; 0x24
     942:	e03d      	b.n	9c0 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     944:	9a09      	ldr	r2, [sp, #36]	; 0x24
     946:	4613      	mov	r3, r2
     948:	005b      	lsls	r3, r3, #1
     94a:	4413      	add	r3, r2
     94c:	009b      	lsls	r3, r3, #2
     94e:	461a      	mov	r2, r3
     950:	9b03      	ldr	r3, [sp, #12]
     952:	4413      	add	r3, r2
     954:	685b      	ldr	r3, [r3, #4]
     956:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     958:	9a09      	ldr	r2, [sp, #36]	; 0x24
     95a:	4613      	mov	r3, r2
     95c:	005b      	lsls	r3, r3, #1
     95e:	4413      	add	r3, r2
     960:	009b      	lsls	r3, r3, #2
     962:	461a      	mov	r2, r3
     964:	9b03      	ldr	r3, [sp, #12]
     966:	4413      	add	r3, r2
     968:	681b      	ldr	r3, [r3, #0]
     96a:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     96c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     96e:	4613      	mov	r3, r2
     970:	005b      	lsls	r3, r3, #1
     972:	4413      	add	r3, r2
     974:	009b      	lsls	r3, r3, #2
     976:	461a      	mov	r2, r3
     978:	9b03      	ldr	r3, [sp, #12]
     97a:	4413      	add	r3, r2
     97c:	689b      	ldr	r3, [r3, #8]
     97e:	4619      	mov	r1, r3
     980:	9a09      	ldr	r2, [sp, #36]	; 0x24
     982:	4613      	mov	r3, r2
     984:	005b      	lsls	r3, r3, #1
     986:	4413      	add	r3, r2
     988:	009b      	lsls	r3, r3, #2
     98a:	461a      	mov	r2, r3
     98c:	9b03      	ldr	r3, [sp, #12]
     98e:	4413      	add	r3, r2
     990:	685b      	ldr	r3, [r3, #4]
     992:	1acb      	subs	r3, r1, r3
     994:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     996:	2300      	movs	r3, #0
     998:	9308      	str	r3, [sp, #32]
     99a:	e00a      	b.n	9b2 <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     99c:	9a00      	ldr	r2, [sp, #0]
     99e:	9b08      	ldr	r3, [sp, #32]
     9a0:	441a      	add	r2, r3
     9a2:	9901      	ldr	r1, [sp, #4]
     9a4:	9b08      	ldr	r3, [sp, #32]
     9a6:	440b      	add	r3, r1
     9a8:	7812      	ldrb	r2, [r2, #0]
     9aa:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     9ac:	9b08      	ldr	r3, [sp, #32]
     9ae:	3301      	adds	r3, #1
     9b0:	9308      	str	r3, [sp, #32]
     9b2:	9a08      	ldr	r2, [sp, #32]
     9b4:	9b06      	ldr	r3, [sp, #24]
     9b6:	429a      	cmp	r2, r3
     9b8:	d3f0      	bcc.n	99c <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     9ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
     9bc:	3301      	adds	r3, #1
     9be:	9309      	str	r3, [sp, #36]	; 0x24
     9c0:	9a09      	ldr	r2, [sp, #36]	; 0x24
     9c2:	9b07      	ldr	r3, [sp, #28]
     9c4:	429a      	cmp	r2, r3
     9c6:	d3bd      	bcc.n	944 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     9c8:	9b04      	ldr	r3, [sp, #16]
     9ca:	681b      	ldr	r3, [r3, #0]
     9cc:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     9ce:	9b04      	ldr	r3, [sp, #16]
     9d0:	3304      	adds	r3, #4
     9d2:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     9d4:	9b04      	ldr	r3, [sp, #16]
     9d6:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     9d8:	2300      	movs	r3, #0
     9da:	9309      	str	r3, [sp, #36]	; 0x24
     9dc:	e024      	b.n	a28 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     9de:	9b09      	ldr	r3, [sp, #36]	; 0x24
     9e0:	00db      	lsls	r3, r3, #3
     9e2:	9a02      	ldr	r2, [sp, #8]
     9e4:	4413      	add	r3, r2
     9e6:	681b      	ldr	r3, [r3, #0]
     9e8:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     9ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
     9ec:	00db      	lsls	r3, r3, #3
     9ee:	9a02      	ldr	r2, [sp, #8]
     9f0:	4413      	add	r3, r2
     9f2:	685b      	ldr	r3, [r3, #4]
     9f4:	4619      	mov	r1, r3
     9f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     9f8:	00db      	lsls	r3, r3, #3
     9fa:	9a02      	ldr	r2, [sp, #8]
     9fc:	4413      	add	r3, r2
     9fe:	681b      	ldr	r3, [r3, #0]
     a00:	1acb      	subs	r3, r1, r3
     a02:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     a04:	2300      	movs	r3, #0
     a06:	9308      	str	r3, [sp, #32]
     a08:	e007      	b.n	a1a <init_data_bss+0x106>
        {
            ram[j] = 0U;
     a0a:	9a01      	ldr	r2, [sp, #4]
     a0c:	9b08      	ldr	r3, [sp, #32]
     a0e:	4413      	add	r3, r2
     a10:	2200      	movs	r2, #0
     a12:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     a14:	9b08      	ldr	r3, [sp, #32]
     a16:	3301      	adds	r3, #1
     a18:	9308      	str	r3, [sp, #32]
     a1a:	9a08      	ldr	r2, [sp, #32]
     a1c:	9b06      	ldr	r3, [sp, #24]
     a1e:	429a      	cmp	r2, r3
     a20:	d3f3      	bcc.n	a0a <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     a22:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a24:	3301      	adds	r3, #1
     a26:	9309      	str	r3, [sp, #36]	; 0x24
     a28:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a2a:	9b07      	ldr	r3, [sp, #28]
     a2c:	429a      	cmp	r2, r3
     a2e:	d3d6      	bcc.n	9de <init_data_bss+0xca>
        }
    }
}
     a30:	bf00      	nop
     a32:	bf00      	nop
     a34:	b00a      	add	sp, #40	; 0x28
     a36:	4770      	bx	lr
     a38:	00007980 	.word	0x00007980
     a3c:	0000799c 	.word	0x0000799c

00000a40 <sys_m4_cache_init>:
{
     a40:	b084      	sub	sp, #16
     a42:	4603      	mov	r3, r0
     a44:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     a48:	2300      	movs	r3, #0
     a4a:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     a4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     a52:	2b00      	cmp	r3, #0
     a54:	d118      	bne.n	a88 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     a56:	4b10      	ldr	r3, [pc, #64]	; (a98 <sys_m4_cache_init+0x58>)
     a58:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     a5c:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     a5e:	4b0e      	ldr	r3, [pc, #56]	; (a98 <sys_m4_cache_init+0x58>)
     a60:	681b      	ldr	r3, [r3, #0]
     a62:	4a0d      	ldr	r2, [pc, #52]	; (a98 <sys_m4_cache_init+0x58>)
     a64:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     a68:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     a6a:	bf00      	nop
     a6c:	4b0a      	ldr	r3, [pc, #40]	; (a98 <sys_m4_cache_init+0x58>)
     a6e:	681b      	ldr	r3, [r3, #0]
     a70:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     a74:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     a78:	d0f8      	beq.n	a6c <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     a7a:	4b07      	ldr	r3, [pc, #28]	; (a98 <sys_m4_cache_init+0x58>)
     a7c:	681b      	ldr	r3, [r3, #0]
     a7e:	4a06      	ldr	r2, [pc, #24]	; (a98 <sys_m4_cache_init+0x58>)
     a80:	f043 0301 	orr.w	r3, r3, #1
     a84:	6013      	str	r3, [r2, #0]
     a86:	e002      	b.n	a8e <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     a88:	2301      	movs	r3, #1
     a8a:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     a8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     a92:	4618      	mov	r0, r3
     a94:	b004      	add	sp, #16
     a96:	4770      	bx	lr
     a98:	e0082000 	.word	0xe0082000

00000a9c <startup_go_to_user_mode>:
}
     a9c:	bf00      	nop
     a9e:	4770      	bx	lr

00000aa0 <Sys_GetCoreID>:
    return 0U;
     aa0:	2300      	movs	r3, #0
}
     aa2:	4618      	mov	r0, r3
     aa4:	4770      	bx	lr

00000aa6 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     aa6:	e7fe      	b.n	aa6 <HardFault_Handler>

00000aa8 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     aa8:	e7fe      	b.n	aa8 <MemManage_Handler>

00000aaa <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     aaa:	e7fe      	b.n	aaa <BusFault_Handler>

00000aac <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     aac:	e7fe      	b.n	aac <UsageFault_Handler>

00000aae <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     aae:	e7fe      	b.n	aae <SVC_Handler>

00000ab0 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     ab0:	e7fe      	b.n	ab0 <DebugMon_Handler>

00000ab2 <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     ab2:	e7fe      	b.n	ab2 <PendSV_Handler>

00000ab4 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     ab4:	e7fe      	b.n	ab4 <SysTick_Handler>

00000ab6 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     ab6:	e7fe      	b.n	ab6 <undefined_handler>

00000ab8 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
     ab8:	2300      	movs	r3, #0
}
     aba:	4618      	mov	r0, r3
     abc:	4770      	bx	lr

00000abe <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
     abe:	b082      	sub	sp, #8
     ac0:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
     ac2:	2301      	movs	r3, #1
}
     ac4:	4618      	mov	r0, r3
     ac6:	b002      	add	sp, #8
     ac8:	4770      	bx	lr

00000aca <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
     aca:	b082      	sub	sp, #8
     acc:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
     ace:	bf00      	nop
     ad0:	b002      	add	sp, #8
     ad2:	4770      	bx	lr

00000ad4 <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
     ad4:	b082      	sub	sp, #8
     ad6:	9001      	str	r0, [sp, #4]
    return Micros;
     ad8:	9b01      	ldr	r3, [sp, #4]
}
     ada:	4618      	mov	r0, r3
     adc:	b002      	add	sp, #8
     ade:	4770      	bx	lr

00000ae0 <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
     ae0:	b500      	push	{lr}
     ae2:	b083      	sub	sp, #12
     ae4:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
     ae6:	f000 f86d 	bl	bc4 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
     aea:	bf00      	nop
     aec:	b003      	add	sp, #12
     aee:	f85d fb04 	ldr.w	pc, [sp], #4

00000af2 <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
     af2:	b500      	push	{lr}
     af4:	b085      	sub	sp, #20
     af6:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
     af8:	2300      	movs	r3, #0
     afa:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     afc:	9b01      	ldr	r3, [sp, #4]
     afe:	2b00      	cmp	r3, #0
     b00:	d003      	beq.n	b0a <OsIf_GetCounter+0x18>
     b02:	9b01      	ldr	r3, [sp, #4]
     b04:	2b01      	cmp	r3, #1
     b06:	d004      	beq.n	b12 <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     b08:	e007      	b.n	b1a <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
     b0a:	f7ff ffd5 	bl	ab8 <OsIf_Timer_Dummy_GetCounter>
     b0e:	9003      	str	r0, [sp, #12]
            break;
     b10:	e003      	b.n	b1a <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
     b12:	f000 f873 	bl	bfc <OsIf_Timer_System_GetCounter>
     b16:	9003      	str	r0, [sp, #12]
            break;
     b18:	bf00      	nop
    }

    return Value;
     b1a:	9b03      	ldr	r3, [sp, #12]
}
     b1c:	4618      	mov	r0, r3
     b1e:	b005      	add	sp, #20
     b20:	f85d fb04 	ldr.w	pc, [sp], #4

00000b24 <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
     b24:	b500      	push	{lr}
     b26:	b085      	sub	sp, #20
     b28:	9001      	str	r0, [sp, #4]
     b2a:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     b2c:	2300      	movs	r3, #0
     b2e:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     b30:	9b00      	ldr	r3, [sp, #0]
     b32:	2b00      	cmp	r3, #0
     b34:	d003      	beq.n	b3e <OsIf_GetElapsed+0x1a>
     b36:	9b00      	ldr	r3, [sp, #0]
     b38:	2b01      	cmp	r3, #1
     b3a:	d005      	beq.n	b48 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     b3c:	e009      	b.n	b52 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
     b3e:	9801      	ldr	r0, [sp, #4]
     b40:	f7ff ffbd 	bl	abe <OsIf_Timer_Dummy_GetElapsed>
     b44:	9003      	str	r0, [sp, #12]
            break;
     b46:	e004      	b.n	b52 <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
     b48:	9801      	ldr	r0, [sp, #4]
     b4a:	f000 f865 	bl	c18 <OsIf_Timer_System_GetElapsed>
     b4e:	9003      	str	r0, [sp, #12]
            break;
     b50:	bf00      	nop
    }

    return Value;
     b52:	9b03      	ldr	r3, [sp, #12]
}
     b54:	4618      	mov	r0, r3
     b56:	b005      	add	sp, #20
     b58:	f85d fb04 	ldr.w	pc, [sp], #4

00000b5c <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
     b5c:	b500      	push	{lr}
     b5e:	b083      	sub	sp, #12
     b60:	9001      	str	r0, [sp, #4]
     b62:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
     b64:	9b00      	ldr	r3, [sp, #0]
     b66:	2b00      	cmp	r3, #0
     b68:	d003      	beq.n	b72 <OsIf_SetTimerFrequency+0x16>
     b6a:	9b00      	ldr	r3, [sp, #0]
     b6c:	2b01      	cmp	r3, #1
     b6e:	d004      	beq.n	b7a <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     b70:	e007      	b.n	b82 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
     b72:	9801      	ldr	r0, [sp, #4]
     b74:	f7ff ffa9 	bl	aca <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
     b78:	e003      	b.n	b82 <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
     b7a:	9801      	ldr	r0, [sp, #4]
     b7c:	f000 f85c 	bl	c38 <OsIf_Timer_System_SetTimerFrequency>
            break;
     b80:	bf00      	nop
    }
}
     b82:	bf00      	nop
     b84:	b003      	add	sp, #12
     b86:	f85d fb04 	ldr.w	pc, [sp], #4

00000b8a <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
     b8a:	b500      	push	{lr}
     b8c:	b085      	sub	sp, #20
     b8e:	9001      	str	r0, [sp, #4]
     b90:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     b92:	2300      	movs	r3, #0
     b94:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     b96:	9b00      	ldr	r3, [sp, #0]
     b98:	2b00      	cmp	r3, #0
     b9a:	d003      	beq.n	ba4 <OsIf_MicrosToTicks+0x1a>
     b9c:	9b00      	ldr	r3, [sp, #0]
     b9e:	2b01      	cmp	r3, #1
     ba0:	d005      	beq.n	bae <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     ba2:	e009      	b.n	bb8 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
     ba4:	9801      	ldr	r0, [sp, #4]
     ba6:	f7ff ff95 	bl	ad4 <OsIf_Timer_Dummy_MicrosToTicks>
     baa:	9003      	str	r0, [sp, #12]
            break;
     bac:	e004      	b.n	bb8 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
     bae:	9801      	ldr	r0, [sp, #4]
     bb0:	f000 f850 	bl	c54 <OsIf_Timer_System_MicrosToTicks>
     bb4:	9003      	str	r0, [sp, #12]
            break;
     bb6:	bf00      	nop
    }

    return Value;
     bb8:	9b03      	ldr	r3, [sp, #12]
}
     bba:	4618      	mov	r0, r3
     bbc:	b005      	add	sp, #20
     bbe:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000bc4 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
     bc4:	b500      	push	{lr}
     bc6:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
     bc8:	2300      	movs	r3, #0
     bca:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
     bcc:	4a09      	ldr	r2, [pc, #36]	; (bf4 <OsIf_Timer_System_Init+0x30>)
     bce:	9b01      	ldr	r3, [sp, #4]
     bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     bd4:	685a      	ldr	r2, [r3, #4]
     bd6:	4908      	ldr	r1, [pc, #32]	; (bf8 <OsIf_Timer_System_Init+0x34>)
     bd8:	9b01      	ldr	r3, [sp, #4]
     bda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
     bde:	4a06      	ldr	r2, [pc, #24]	; (bf8 <OsIf_Timer_System_Init+0x34>)
     be0:	9b01      	ldr	r3, [sp, #4]
     be2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     be6:	4618      	mov	r0, r3
     be8:	f000 f868 	bl	cbc <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
     bec:	bf00      	nop
     bee:	b003      	add	sp, #12
     bf0:	f85d fb04 	ldr.w	pc, [sp], #4
     bf4:	00007838 	.word	0x00007838
     bf8:	1fff8b30 	.word	0x1fff8b30

00000bfc <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
     bfc:	b500      	push	{lr}
     bfe:	b083      	sub	sp, #12
    uint32 Counter = 0U;
     c00:	2300      	movs	r3, #0
     c02:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     c04:	2300      	movs	r3, #0
     c06:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
     c08:	f000 f86c 	bl	ce4 <OsIf_Timer_System_Internal_GetCounter>
     c0c:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
     c0e:	9b01      	ldr	r3, [sp, #4]
}
     c10:	4618      	mov	r0, r3
     c12:	b003      	add	sp, #12
     c14:	f85d fb04 	ldr.w	pc, [sp], #4

00000c18 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
     c18:	b500      	push	{lr}
     c1a:	b085      	sub	sp, #20
     c1c:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
     c1e:	2300      	movs	r3, #0
     c20:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
     c22:	2300      	movs	r3, #0
     c24:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
     c26:	9801      	ldr	r0, [sp, #4]
     c28:	f000 f864 	bl	cf4 <OsIf_Timer_System_Internal_GetElapsed>
     c2c:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
     c2e:	9b03      	ldr	r3, [sp, #12]
}
     c30:	4618      	mov	r0, r3
     c32:	b005      	add	sp, #20
     c34:	f85d fb04 	ldr.w	pc, [sp], #4

00000c38 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
     c38:	b084      	sub	sp, #16
     c3a:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     c3c:	2300      	movs	r3, #0
     c3e:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
     c40:	4903      	ldr	r1, [pc, #12]	; (c50 <OsIf_Timer_System_SetTimerFrequency+0x18>)
     c42:	9b03      	ldr	r3, [sp, #12]
     c44:	9a01      	ldr	r2, [sp, #4]
     c46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
     c4a:	bf00      	nop
     c4c:	b004      	add	sp, #16
     c4e:	4770      	bx	lr
     c50:	1fff8b30 	.word	0x1fff8b30

00000c54 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
     c54:	b5f0      	push	{r4, r5, r6, r7, lr}
     c56:	b087      	sub	sp, #28
     c58:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
     c5a:	2100      	movs	r1, #0
     c5c:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
     c5e:	2100      	movs	r1, #0
     c60:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
     c62:	9901      	ldr	r1, [sp, #4]
     c64:	2000      	movs	r0, #0
     c66:	460e      	mov	r6, r1
     c68:	4607      	mov	r7, r0
     c6a:	4812      	ldr	r0, [pc, #72]	; (cb4 <OsIf_Timer_System_MicrosToTicks+0x60>)
     c6c:	9904      	ldr	r1, [sp, #16]
     c6e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
     c72:	2000      	movs	r0, #0
     c74:	460c      	mov	r4, r1
     c76:	4605      	mov	r5, r0
     c78:	fb04 f007 	mul.w	r0, r4, r7
     c7c:	fb06 f105 	mul.w	r1, r6, r5
     c80:	4401      	add	r1, r0
     c82:	fba6 2304 	umull	r2, r3, r6, r4
     c86:	4419      	add	r1, r3
     c88:	460b      	mov	r3, r1
     c8a:	e9cd 2302 	strd	r2, r3, [sp, #8]
     c8e:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
     c92:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
     c96:	4a08      	ldr	r2, [pc, #32]	; (cb8 <OsIf_Timer_System_MicrosToTicks+0x64>)
     c98:	f04f 0300 	mov.w	r3, #0
     c9c:	f7ff fc82 	bl	5a4 <__aeabi_uldivmod>
     ca0:	4602      	mov	r2, r0
     ca2:	460b      	mov	r3, r1
     ca4:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
     ca8:	9b02      	ldr	r3, [sp, #8]
     caa:	9305      	str	r3, [sp, #20]
    }

    return ticks;
     cac:	9b05      	ldr	r3, [sp, #20]
}
     cae:	4618      	mov	r0, r3
     cb0:	b007      	add	sp, #28
     cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cb4:	1fff8b30 	.word	0x1fff8b30
     cb8:	000f4240 	.word	0x000f4240

00000cbc <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
     cbc:	b082      	sub	sp, #8
     cbe:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
     cc0:	4b07      	ldr	r3, [pc, #28]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cc2:	2200      	movs	r2, #0
     cc4:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
     cc6:	4b06      	ldr	r3, [pc, #24]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cc8:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
     ccc:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
     cce:	4b04      	ldr	r3, [pc, #16]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cd0:	2200      	movs	r2, #0
     cd2:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
     cd4:	4b02      	ldr	r3, [pc, #8]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cd6:	2205      	movs	r2, #5
     cd8:	601a      	str	r2, [r3, #0]
}
     cda:	bf00      	nop
     cdc:	b002      	add	sp, #8
     cde:	4770      	bx	lr
     ce0:	e000e010 	.word	0xe000e010

00000ce4 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
     ce4:	4b02      	ldr	r3, [pc, #8]	; (cf0 <OsIf_Timer_System_Internal_GetCounter+0xc>)
     ce6:	689b      	ldr	r3, [r3, #8]
     ce8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
     cec:	4618      	mov	r0, r3
     cee:	4770      	bx	lr
     cf0:	e000e010 	.word	0xe000e010

00000cf4 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
     cf4:	b084      	sub	sp, #16
     cf6:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
     cf8:	4b10      	ldr	r3, [pc, #64]	; (d3c <OsIf_Timer_System_Internal_GetElapsed+0x48>)
     cfa:	689b      	ldr	r3, [r3, #8]
     cfc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     d00:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
     d02:	2300      	movs	r3, #0
     d04:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
     d06:	9b01      	ldr	r3, [sp, #4]
     d08:	681b      	ldr	r3, [r3, #0]
     d0a:	9a02      	ldr	r2, [sp, #8]
     d0c:	429a      	cmp	r2, r3
     d0e:	d909      	bls.n	d24 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
     d10:	9b01      	ldr	r3, [sp, #4]
     d12:	681a      	ldr	r2, [r3, #0]
     d14:	9b02      	ldr	r3, [sp, #8]
     d16:	1ad3      	subs	r3, r2, r3
     d18:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
     d1c:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
     d20:	9303      	str	r3, [sp, #12]
     d22:	e004      	b.n	d2e <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
     d24:	9b01      	ldr	r3, [sp, #4]
     d26:	681a      	ldr	r2, [r3, #0]
     d28:	9b02      	ldr	r3, [sp, #8]
     d2a:	1ad3      	subs	r3, r2, r3
     d2c:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
     d2e:	9b01      	ldr	r3, [sp, #4]
     d30:	9a02      	ldr	r2, [sp, #8]
     d32:	601a      	str	r2, [r3, #0]

    return dif;
     d34:	9b03      	ldr	r3, [sp, #12]
}
     d36:	4618      	mov	r0, r3
     d38:	b004      	add	sp, #16
     d3a:	4770      	bx	lr
     d3c:	e000e010 	.word	0xe000e010

00000d40 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
     d40:	b082      	sub	sp, #8
     d42:	9001      	str	r0, [sp, #4]
     d44:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
     d46:	bf00      	nop
     d48:	b002      	add	sp, #8
     d4a:	4770      	bx	lr

00000d4c <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
     d4c:	b500      	push	{lr}
     d4e:	b085      	sub	sp, #20
     d50:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
     d52:	4b24      	ldr	r3, [pc, #144]	; (de4 <Clock_Ip_UpdateDriverContext+0x98>)
     d54:	2201      	movs	r2, #1
     d56:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
     d58:	4b23      	ldr	r3, [pc, #140]	; (de8 <Clock_Ip_UpdateDriverContext+0x9c>)
     d5a:	681b      	ldr	r3, [r3, #0]
     d5c:	2102      	movs	r1, #2
     d5e:	4618      	mov	r0, r3
     d60:	f003 fc32 	bl	45c8 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
     d64:	2300      	movs	r3, #0
     d66:	f88d 300f 	strb.w	r3, [sp, #15]
     d6a:	e015      	b.n	d98 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
     d6c:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d70:	9a01      	ldr	r2, [sp, #4]
     d72:	334a      	adds	r3, #74	; 0x4a
     d74:	00db      	lsls	r3, r3, #3
     d76:	4413      	add	r3, r2
     d78:	6858      	ldr	r0, [r3, #4]
     d7a:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d7e:	9a01      	ldr	r2, [sp, #4]
     d80:	334a      	adds	r3, #74	; 0x4a
     d82:	00db      	lsls	r3, r3, #3
     d84:	4413      	add	r3, r2
     d86:	689b      	ldr	r3, [r3, #8]
     d88:	4619      	mov	r1, r3
     d8a:	f001 fadc 	bl	2346 <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
     d8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
     d92:	3301      	adds	r3, #1
     d94:	f88d 300f 	strb.w	r3, [sp, #15]
     d98:	9b01      	ldr	r3, [sp, #4]
     d9a:	7bdb      	ldrb	r3, [r3, #15]
     d9c:	f89d 200f 	ldrb.w	r2, [sp, #15]
     da0:	429a      	cmp	r2, r3
     da2:	d3e3      	bcc.n	d6c <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
     da4:	f000 f824 	bl	df0 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
     da8:	2301      	movs	r3, #1
     daa:	f88d 300f 	strb.w	r3, [sp, #15]
     dae:	e00e      	b.n	dce <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
     db0:	f89d 200f 	ldrb.w	r2, [sp, #15]
     db4:	9b01      	ldr	r3, [sp, #4]
     db6:	327e      	adds	r2, #126	; 0x7e
     db8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
     dbc:	490b      	ldr	r1, [pc, #44]	; (dec <Clock_Ip_UpdateDriverContext+0xa0>)
     dbe:	f89d 200f 	ldrb.w	r2, [sp, #15]
     dc2:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
     dc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
     dc8:	3301      	adds	r3, #1
     dca:	f88d 300f 	strb.w	r3, [sp, #15]
     dce:	9b01      	ldr	r3, [sp, #4]
     dd0:	7cdb      	ldrb	r3, [r3, #19]
     dd2:	f89d 200f 	ldrb.w	r2, [sp, #15]
     dd6:	429a      	cmp	r2, r3
     dd8:	d3ea      	bcc.n	db0 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
     dda:	bf00      	nop
     ddc:	bf00      	nop
     dde:	b005      	add	sp, #20
     de0:	f85d fb04 	ldr.w	pc, [sp], #4
     de4:	1fff8b10 	.word	0x1fff8b10
     de8:	1fff8b34 	.word	0x1fff8b34
     dec:	1fff8b40 	.word	0x1fff8b40

00000df0 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
     df0:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
     df2:	4b23      	ldr	r3, [pc, #140]	; (e80 <Clock_Ip_CallEmptyCallbacks+0x90>)
     df4:	781b      	ldrb	r3, [r3, #0]
     df6:	f083 0301 	eor.w	r3, r3, #1
     dfa:	b2db      	uxtb	r3, r3
     dfc:	2b00      	cmp	r3, #0
     dfe:	d03d      	beq.n	e7c <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
     e00:	4b1f      	ldr	r3, [pc, #124]	; (e80 <Clock_Ip_CallEmptyCallbacks+0x90>)
     e02:	2201      	movs	r2, #1
     e04:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
     e06:	4b1f      	ldr	r3, [pc, #124]	; (e84 <Clock_Ip_CallEmptyCallbacks+0x94>)
     e08:	685b      	ldr	r3, [r3, #4]
     e0a:	2100      	movs	r1, #0
     e0c:	2000      	movs	r0, #0
     e0e:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
     e10:	4b1c      	ldr	r3, [pc, #112]	; (e84 <Clock_Ip_CallEmptyCallbacks+0x94>)
     e12:	689b      	ldr	r3, [r3, #8]
     e14:	2057      	movs	r0, #87	; 0x57
     e16:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e18:	4b1b      	ldr	r3, [pc, #108]	; (e88 <Clock_Ip_CallEmptyCallbacks+0x98>)
     e1a:	681b      	ldr	r3, [r3, #0]
     e1c:	2000      	movs	r0, #0
     e1e:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
     e20:	4b1a      	ldr	r3, [pc, #104]	; (e8c <Clock_Ip_CallEmptyCallbacks+0x9c>)
     e22:	681b      	ldr	r3, [r3, #0]
     e24:	2000      	movs	r0, #0
     e26:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
     e28:	4b19      	ldr	r3, [pc, #100]	; (e90 <Clock_Ip_CallEmptyCallbacks+0xa0>)
     e2a:	681b      	ldr	r3, [r3, #0]
     e2c:	2000      	movs	r0, #0
     e2e:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e30:	4b18      	ldr	r3, [pc, #96]	; (e94 <Clock_Ip_CallEmptyCallbacks+0xa4>)
     e32:	685b      	ldr	r3, [r3, #4]
     e34:	2000      	movs	r0, #0
     e36:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
     e38:	4b16      	ldr	r3, [pc, #88]	; (e94 <Clock_Ip_CallEmptyCallbacks+0xa4>)
     e3a:	689b      	ldr	r3, [r3, #8]
     e3c:	2057      	movs	r0, #87	; 0x57
     e3e:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e40:	4b15      	ldr	r3, [pc, #84]	; (e98 <Clock_Ip_CallEmptyCallbacks+0xa8>)
     e42:	681b      	ldr	r3, [r3, #0]
     e44:	2000      	movs	r0, #0
     e46:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
     e48:	4b13      	ldr	r3, [pc, #76]	; (e98 <Clock_Ip_CallEmptyCallbacks+0xa8>)
     e4a:	685b      	ldr	r3, [r3, #4]
     e4c:	2100      	movs	r1, #0
     e4e:	2057      	movs	r0, #87	; 0x57
     e50:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e52:	4b12      	ldr	r3, [pc, #72]	; (e9c <Clock_Ip_CallEmptyCallbacks+0xac>)
     e54:	681b      	ldr	r3, [r3, #0]
     e56:	2000      	movs	r0, #0
     e58:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e5a:	4b11      	ldr	r3, [pc, #68]	; (ea0 <Clock_Ip_CallEmptyCallbacks+0xb0>)
     e5c:	685b      	ldr	r3, [r3, #4]
     e5e:	2000      	movs	r0, #0
     e60:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
     e62:	4b0f      	ldr	r3, [pc, #60]	; (ea0 <Clock_Ip_CallEmptyCallbacks+0xb0>)
     e64:	689b      	ldr	r3, [r3, #8]
     e66:	2057      	movs	r0, #87	; 0x57
     e68:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
     e6a:	4b0e      	ldr	r3, [pc, #56]	; (ea4 <Clock_Ip_CallEmptyCallbacks+0xb4>)
     e6c:	685b      	ldr	r3, [r3, #4]
     e6e:	2000      	movs	r0, #0
     e70:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
     e72:	4b0d      	ldr	r3, [pc, #52]	; (ea8 <Clock_Ip_CallEmptyCallbacks+0xb8>)
     e74:	681b      	ldr	r3, [r3, #0]
     e76:	2100      	movs	r1, #0
     e78:	2000      	movs	r0, #0
     e7a:	4798      	blx	r3
    }
}
     e7c:	bf00      	nop
     e7e:	bd08      	pop	{r3, pc}
     e80:	1fff8b38 	.word	0x1fff8b38
     e84:	00007308 	.word	0x00007308
     e88:	0000721c 	.word	0x0000721c
     e8c:	00007258 	.word	0x00007258
     e90:	00007260 	.word	0x00007260
     e94:	00007288 	.word	0x00007288
     e98:	00007294 	.word	0x00007294
     e9c:	000072cc 	.word	0x000072cc
     ea0:	00007318 	.word	0x00007318
     ea4:	00007344 	.word	0x00007344
     ea8:	00007340 	.word	0x00007340

00000eac <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
     eac:	b500      	push	{lr}
     eae:	b085      	sub	sp, #20
     eb0:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
     eb2:	9b01      	ldr	r3, [sp, #4]
     eb4:	7adb      	ldrb	r3, [r3, #11]
     eb6:	9303      	str	r3, [sp, #12]
     eb8:	e01f      	b.n	efa <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
     eba:	9b03      	ldr	r3, [sp, #12]
     ebc:	1e5a      	subs	r2, r3, #1
     ebe:	9b01      	ldr	r3, [sp, #4]
     ec0:	320d      	adds	r2, #13
     ec2:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
     ec6:	495a      	ldr	r1, [pc, #360]	; (1030 <Clock_Ip_ResetClockConfiguration+0x184>)
     ec8:	4613      	mov	r3, r2
     eca:	00db      	lsls	r3, r3, #3
     ecc:	4413      	add	r3, r2
     ece:	440b      	add	r3, r1
     ed0:	3301      	adds	r3, #1
     ed2:	781b      	ldrb	r3, [r3, #0]
     ed4:	461a      	mov	r2, r3
     ed6:	4b57      	ldr	r3, [pc, #348]	; (1034 <Clock_Ip_ResetClockConfiguration+0x188>)
     ed8:	5c9b      	ldrb	r3, [r3, r2]
     eda:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
     edc:	4a56      	ldr	r2, [pc, #344]	; (1038 <Clock_Ip_ResetClockConfiguration+0x18c>)
     ede:	9b02      	ldr	r3, [sp, #8]
     ee0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
     ee4:	9a03      	ldr	r2, [sp, #12]
     ee6:	3a01      	subs	r2, #1
     ee8:	320d      	adds	r2, #13
     eea:	00d2      	lsls	r2, r2, #3
     eec:	9901      	ldr	r1, [sp, #4]
     eee:	440a      	add	r2, r1
     ef0:	4610      	mov	r0, r2
     ef2:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
     ef4:	9b03      	ldr	r3, [sp, #12]
     ef6:	3b01      	subs	r3, #1
     ef8:	9303      	str	r3, [sp, #12]
     efa:	9b03      	ldr	r3, [sp, #12]
     efc:	2b00      	cmp	r3, #0
     efe:	d1dc      	bne.n	eba <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
     f00:	9b01      	ldr	r3, [sp, #4]
     f02:	7b9b      	ldrb	r3, [r3, #14]
     f04:	9303      	str	r3, [sp, #12]
     f06:	e026      	b.n	f56 <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
     f08:	9b03      	ldr	r3, [sp, #12]
     f0a:	3b01      	subs	r3, #1
     f0c:	9a01      	ldr	r2, [sp, #4]
     f0e:	3324      	adds	r3, #36	; 0x24
     f10:	011b      	lsls	r3, r3, #4
     f12:	4413      	add	r3, r2
     f14:	3304      	adds	r3, #4
     f16:	681a      	ldr	r2, [r3, #0]
     f18:	4945      	ldr	r1, [pc, #276]	; (1030 <Clock_Ip_ResetClockConfiguration+0x184>)
     f1a:	4613      	mov	r3, r2
     f1c:	00db      	lsls	r3, r3, #3
     f1e:	4413      	add	r3, r2
     f20:	440b      	add	r3, r1
     f22:	3301      	adds	r3, #1
     f24:	781b      	ldrb	r3, [r3, #0]
     f26:	461a      	mov	r2, r3
     f28:	4b44      	ldr	r3, [pc, #272]	; (103c <Clock_Ip_ResetClockConfiguration+0x190>)
     f2a:	5c9b      	ldrb	r3, [r3, r2]
     f2c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
     f2e:	4944      	ldr	r1, [pc, #272]	; (1040 <Clock_Ip_ResetClockConfiguration+0x194>)
     f30:	9a02      	ldr	r2, [sp, #8]
     f32:	4613      	mov	r3, r2
     f34:	005b      	lsls	r3, r3, #1
     f36:	4413      	add	r3, r2
     f38:	009b      	lsls	r3, r3, #2
     f3a:	440b      	add	r3, r1
     f3c:	681b      	ldr	r3, [r3, #0]
     f3e:	9a03      	ldr	r2, [sp, #12]
     f40:	3a01      	subs	r2, #1
     f42:	3224      	adds	r2, #36	; 0x24
     f44:	0112      	lsls	r2, r2, #4
     f46:	9901      	ldr	r1, [sp, #4]
     f48:	440a      	add	r2, r1
     f4a:	3204      	adds	r2, #4
     f4c:	4610      	mov	r0, r2
     f4e:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
     f50:	9b03      	ldr	r3, [sp, #12]
     f52:	3b01      	subs	r3, #1
     f54:	9303      	str	r3, [sp, #12]
     f56:	9b03      	ldr	r3, [sp, #12]
     f58:	2b00      	cmp	r3, #0
     f5a:	d1d5      	bne.n	f08 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
     f5c:	9b01      	ldr	r3, [sp, #4]
     f5e:	7a9b      	ldrb	r3, [r3, #10]
     f60:	9303      	str	r3, [sp, #12]
     f62:	e02a      	b.n	fba <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
     f64:	9b03      	ldr	r3, [sp, #12]
     f66:	1e5a      	subs	r2, r3, #1
     f68:	9901      	ldr	r1, [sp, #4]
     f6a:	4613      	mov	r3, r2
     f6c:	009b      	lsls	r3, r3, #2
     f6e:	4413      	add	r3, r2
     f70:	00db      	lsls	r3, r3, #3
     f72:	440b      	add	r3, r1
     f74:	3340      	adds	r3, #64	; 0x40
     f76:	681a      	ldr	r2, [r3, #0]
     f78:	492d      	ldr	r1, [pc, #180]	; (1030 <Clock_Ip_ResetClockConfiguration+0x184>)
     f7a:	4613      	mov	r3, r2
     f7c:	00db      	lsls	r3, r3, #3
     f7e:	4413      	add	r3, r2
     f80:	440b      	add	r3, r1
     f82:	3301      	adds	r3, #1
     f84:	781b      	ldrb	r3, [r3, #0]
     f86:	461a      	mov	r2, r3
     f88:	4b2e      	ldr	r3, [pc, #184]	; (1044 <Clock_Ip_ResetClockConfiguration+0x198>)
     f8a:	5c9b      	ldrb	r3, [r3, r2]
     f8c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
     f8e:	492e      	ldr	r1, [pc, #184]	; (1048 <Clock_Ip_ResetClockConfiguration+0x19c>)
     f90:	9a02      	ldr	r2, [sp, #8]
     f92:	4613      	mov	r3, r2
     f94:	009b      	lsls	r3, r3, #2
     f96:	4413      	add	r3, r2
     f98:	009b      	lsls	r3, r3, #2
     f9a:	440b      	add	r3, r1
     f9c:	6819      	ldr	r1, [r3, #0]
     f9e:	9b03      	ldr	r3, [sp, #12]
     fa0:	1e5a      	subs	r2, r3, #1
     fa2:	4613      	mov	r3, r2
     fa4:	009b      	lsls	r3, r3, #2
     fa6:	4413      	add	r3, r2
     fa8:	00db      	lsls	r3, r3, #3
     faa:	3340      	adds	r3, #64	; 0x40
     fac:	9a01      	ldr	r2, [sp, #4]
     fae:	4413      	add	r3, r2
     fb0:	4618      	mov	r0, r3
     fb2:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
     fb4:	9b03      	ldr	r3, [sp, #12]
     fb6:	3b01      	subs	r3, #1
     fb8:	9303      	str	r3, [sp, #12]
     fba:	9b03      	ldr	r3, [sp, #12]
     fbc:	2b00      	cmp	r3, #0
     fbe:	d1d1      	bne.n	f64 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
     fc0:	9b01      	ldr	r3, [sp, #4]
     fc2:	7a5b      	ldrb	r3, [r3, #9]
     fc4:	9303      	str	r3, [sp, #12]
     fc6:	e02b      	b.n	1020 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
     fc8:	9b03      	ldr	r3, [sp, #12]
     fca:	1e5a      	subs	r2, r3, #1
     fcc:	9901      	ldr	r1, [sp, #4]
     fce:	4613      	mov	r3, r2
     fd0:	009b      	lsls	r3, r3, #2
     fd2:	4413      	add	r3, r2
     fd4:	009b      	lsls	r3, r3, #2
     fd6:	440b      	add	r3, r1
     fd8:	332c      	adds	r3, #44	; 0x2c
     fda:	681a      	ldr	r2, [r3, #0]
     fdc:	4914      	ldr	r1, [pc, #80]	; (1030 <Clock_Ip_ResetClockConfiguration+0x184>)
     fde:	4613      	mov	r3, r2
     fe0:	00db      	lsls	r3, r3, #3
     fe2:	4413      	add	r3, r2
     fe4:	440b      	add	r3, r1
     fe6:	3301      	adds	r3, #1
     fe8:	781b      	ldrb	r3, [r3, #0]
     fea:	461a      	mov	r2, r3
     fec:	4b17      	ldr	r3, [pc, #92]	; (104c <Clock_Ip_ResetClockConfiguration+0x1a0>)
     fee:	5c9b      	ldrb	r3, [r3, r2]
     ff0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
     ff2:	4917      	ldr	r1, [pc, #92]	; (1050 <Clock_Ip_ResetClockConfiguration+0x1a4>)
     ff4:	9a02      	ldr	r2, [sp, #8]
     ff6:	4613      	mov	r3, r2
     ff8:	009b      	lsls	r3, r3, #2
     ffa:	4413      	add	r3, r2
     ffc:	009b      	lsls	r3, r3, #2
     ffe:	440b      	add	r3, r1
    1000:	6819      	ldr	r1, [r3, #0]
    1002:	9b03      	ldr	r3, [sp, #12]
    1004:	1e5a      	subs	r2, r3, #1
    1006:	4613      	mov	r3, r2
    1008:	009b      	lsls	r3, r3, #2
    100a:	4413      	add	r3, r2
    100c:	009b      	lsls	r3, r3, #2
    100e:	3328      	adds	r3, #40	; 0x28
    1010:	9a01      	ldr	r2, [sp, #4]
    1012:	4413      	add	r3, r2
    1014:	3304      	adds	r3, #4
    1016:	4618      	mov	r0, r3
    1018:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    101a:	9b03      	ldr	r3, [sp, #12]
    101c:	3b01      	subs	r3, #1
    101e:	9303      	str	r3, [sp, #12]
    1020:	9b03      	ldr	r3, [sp, #12]
    1022:	2b00      	cmp	r3, #0
    1024:	d1d0      	bne.n	fc8 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    1026:	bf00      	nop
    1028:	bf00      	nop
    102a:	b005      	add	sp, #20
    102c:	f85d fb04 	ldr.w	pc, [sp], #4
    1030:	00006d0c 	.word	0x00006d0c
    1034:	00006cdc 	.word	0x00006cdc
    1038:	00007344 	.word	0x00007344
    103c:	00006cbc 	.word	0x00006cbc
    1040:	00007288 	.word	0x00007288
    1044:	00006ccc 	.word	0x00006ccc
    1048:	00007318 	.word	0x00007318
    104c:	00006c8c 	.word	0x00006c8c
    1050:	00007260 	.word	0x00007260

00001054 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    1054:	b500      	push	{lr}
    1056:	b085      	sub	sp, #20
    1058:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    105a:	2301      	movs	r3, #1
    105c:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    105e:	9801      	ldr	r0, [sp, #4]
    1060:	f000 f818 	bl	1094 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    1064:	4b0a      	ldr	r3, [pc, #40]	; (1090 <Clock_Ip_Init+0x3c>)
    1066:	781b      	ldrb	r3, [r3, #0]
    1068:	2b00      	cmp	r3, #0
    106a:	d00a      	beq.n	1082 <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    106c:	f000 fb74 	bl	1758 <Clock_Ip_GetPllStatus>
    1070:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    1072:	9b02      	ldr	r3, [sp, #8]
    1074:	2b00      	cmp	r3, #0
    1076:	d106      	bne.n	1086 <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    1078:	f000 fbf2 	bl	1860 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    107c:	2300      	movs	r3, #0
    107e:	9303      	str	r3, [sp, #12]
    1080:	e001      	b.n	1086 <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    1082:	2300      	movs	r3, #0
    1084:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    1086:	9b03      	ldr	r3, [sp, #12]
}
    1088:	4618      	mov	r0, r3
    108a:	b005      	add	sp, #20
    108c:	f85d fb04 	ldr.w	pc, [sp], #4
    1090:	1fff8b3c 	.word	0x1fff8b3c

00001094 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    1094:	b510      	push	{r4, lr}
    1096:	b084      	sub	sp, #16
    1098:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    109a:	4a9f      	ldr	r2, [pc, #636]	; (1318 <Clock_Ip_InitClock+0x284>)
    109c:	9b01      	ldr	r3, [sp, #4]
    109e:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    10a0:	2101      	movs	r1, #1
    10a2:	9801      	ldr	r0, [sp, #4]
    10a4:	f003 fa90 	bl	45c8 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    10a8:	4b9b      	ldr	r3, [pc, #620]	; (1318 <Clock_Ip_InitClock+0x284>)
    10aa:	681b      	ldr	r3, [r3, #0]
    10ac:	2b00      	cmp	r3, #0
    10ae:	d030      	beq.n	1112 <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    10b0:	2300      	movs	r3, #0
    10b2:	9303      	str	r3, [sp, #12]
    10b4:	e027      	b.n	1106 <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    10b6:	9901      	ldr	r1, [sp, #4]
    10b8:	9a03      	ldr	r2, [sp, #12]
    10ba:	4613      	mov	r3, r2
    10bc:	009b      	lsls	r3, r3, #2
    10be:	4413      	add	r3, r2
    10c0:	009b      	lsls	r3, r3, #2
    10c2:	440b      	add	r3, r1
    10c4:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    10c8:	681a      	ldr	r2, [r3, #0]
    10ca:	4994      	ldr	r1, [pc, #592]	; (131c <Clock_Ip_InitClock+0x288>)
    10cc:	4613      	mov	r3, r2
    10ce:	00db      	lsls	r3, r3, #3
    10d0:	4413      	add	r3, r2
    10d2:	440b      	add	r3, r1
    10d4:	3301      	adds	r3, #1
    10d6:	781b      	ldrb	r3, [r3, #0]
    10d8:	461a      	mov	r2, r3
    10da:	4b91      	ldr	r3, [pc, #580]	; (1320 <Clock_Ip_InitClock+0x28c>)
    10dc:	5c9b      	ldrb	r3, [r3, r2]
    10de:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    10e0:	4a90      	ldr	r2, [pc, #576]	; (1324 <Clock_Ip_InitClock+0x290>)
    10e2:	9b02      	ldr	r3, [sp, #8]
    10e4:	011b      	lsls	r3, r3, #4
    10e6:	4413      	add	r3, r2
    10e8:	6819      	ldr	r1, [r3, #0]
    10ea:	9a03      	ldr	r2, [sp, #12]
    10ec:	4613      	mov	r3, r2
    10ee:	009b      	lsls	r3, r3, #2
    10f0:	4413      	add	r3, r2
    10f2:	009b      	lsls	r3, r3, #2
    10f4:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    10f8:	9a01      	ldr	r2, [sp, #4]
    10fa:	4413      	add	r3, r2
    10fc:	4618      	mov	r0, r3
    10fe:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    1100:	9b03      	ldr	r3, [sp, #12]
    1102:	3301      	adds	r3, #1
    1104:	9303      	str	r3, [sp, #12]
    1106:	9b01      	ldr	r3, [sp, #4]
    1108:	7c9b      	ldrb	r3, [r3, #18]
    110a:	461a      	mov	r2, r3
    110c:	9b03      	ldr	r3, [sp, #12]
    110e:	4293      	cmp	r3, r2
    1110:	d3d1      	bcc.n	10b6 <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    1112:	9801      	ldr	r0, [sp, #4]
    1114:	f7ff feca 	bl	eac <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    1118:	2300      	movs	r3, #0
    111a:	9303      	str	r3, [sp, #12]
    111c:	e029      	b.n	1172 <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    111e:	9901      	ldr	r1, [sp, #4]
    1120:	9a03      	ldr	r2, [sp, #12]
    1122:	4613      	mov	r3, r2
    1124:	005b      	lsls	r3, r3, #1
    1126:	4413      	add	r3, r2
    1128:	009b      	lsls	r3, r3, #2
    112a:	440b      	add	r3, r1
    112c:	3314      	adds	r3, #20
    112e:	681a      	ldr	r2, [r3, #0]
    1130:	497a      	ldr	r1, [pc, #488]	; (131c <Clock_Ip_InitClock+0x288>)
    1132:	4613      	mov	r3, r2
    1134:	00db      	lsls	r3, r3, #3
    1136:	4413      	add	r3, r2
    1138:	440b      	add	r3, r1
    113a:	3301      	adds	r3, #1
    113c:	781b      	ldrb	r3, [r3, #0]
    113e:	461a      	mov	r2, r3
    1140:	4b79      	ldr	r3, [pc, #484]	; (1328 <Clock_Ip_InitClock+0x294>)
    1142:	5c9b      	ldrb	r3, [r3, r2]
    1144:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    1146:	4979      	ldr	r1, [pc, #484]	; (132c <Clock_Ip_InitClock+0x298>)
    1148:	9a02      	ldr	r2, [sp, #8]
    114a:	4613      	mov	r3, r2
    114c:	005b      	lsls	r3, r3, #1
    114e:	4413      	add	r3, r2
    1150:	009b      	lsls	r3, r3, #2
    1152:	440b      	add	r3, r1
    1154:	6819      	ldr	r1, [r3, #0]
    1156:	9a03      	ldr	r2, [sp, #12]
    1158:	4613      	mov	r3, r2
    115a:	005b      	lsls	r3, r3, #1
    115c:	4413      	add	r3, r2
    115e:	009b      	lsls	r3, r3, #2
    1160:	3310      	adds	r3, #16
    1162:	9a01      	ldr	r2, [sp, #4]
    1164:	4413      	add	r3, r2
    1166:	3304      	adds	r3, #4
    1168:	4618      	mov	r0, r3
    116a:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    116c:	9b03      	ldr	r3, [sp, #12]
    116e:	3301      	adds	r3, #1
    1170:	9303      	str	r3, [sp, #12]
    1172:	9b01      	ldr	r3, [sp, #4]
    1174:	7a1b      	ldrb	r3, [r3, #8]
    1176:	461a      	mov	r2, r3
    1178:	9b03      	ldr	r3, [sp, #12]
    117a:	4293      	cmp	r3, r2
    117c:	d3cf      	bcc.n	111e <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    117e:	2300      	movs	r3, #0
    1180:	9303      	str	r3, [sp, #12]
    1182:	e02a      	b.n	11da <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    1184:	9901      	ldr	r1, [sp, #4]
    1186:	9a03      	ldr	r2, [sp, #12]
    1188:	4613      	mov	r3, r2
    118a:	009b      	lsls	r3, r3, #2
    118c:	4413      	add	r3, r2
    118e:	009b      	lsls	r3, r3, #2
    1190:	440b      	add	r3, r1
    1192:	332c      	adds	r3, #44	; 0x2c
    1194:	681a      	ldr	r2, [r3, #0]
    1196:	4961      	ldr	r1, [pc, #388]	; (131c <Clock_Ip_InitClock+0x288>)
    1198:	4613      	mov	r3, r2
    119a:	00db      	lsls	r3, r3, #3
    119c:	4413      	add	r3, r2
    119e:	440b      	add	r3, r1
    11a0:	3301      	adds	r3, #1
    11a2:	781b      	ldrb	r3, [r3, #0]
    11a4:	461a      	mov	r2, r3
    11a6:	4b62      	ldr	r3, [pc, #392]	; (1330 <Clock_Ip_InitClock+0x29c>)
    11a8:	5c9b      	ldrb	r3, [r3, r2]
    11aa:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    11ac:	4961      	ldr	r1, [pc, #388]	; (1334 <Clock_Ip_InitClock+0x2a0>)
    11ae:	9a02      	ldr	r2, [sp, #8]
    11b0:	4613      	mov	r3, r2
    11b2:	009b      	lsls	r3, r3, #2
    11b4:	4413      	add	r3, r2
    11b6:	009b      	lsls	r3, r3, #2
    11b8:	440b      	add	r3, r1
    11ba:	3304      	adds	r3, #4
    11bc:	6819      	ldr	r1, [r3, #0]
    11be:	9a03      	ldr	r2, [sp, #12]
    11c0:	4613      	mov	r3, r2
    11c2:	009b      	lsls	r3, r3, #2
    11c4:	4413      	add	r3, r2
    11c6:	009b      	lsls	r3, r3, #2
    11c8:	3328      	adds	r3, #40	; 0x28
    11ca:	9a01      	ldr	r2, [sp, #4]
    11cc:	4413      	add	r3, r2
    11ce:	3304      	adds	r3, #4
    11d0:	4618      	mov	r0, r3
    11d2:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    11d4:	9b03      	ldr	r3, [sp, #12]
    11d6:	3301      	adds	r3, #1
    11d8:	9303      	str	r3, [sp, #12]
    11da:	9b01      	ldr	r3, [sp, #4]
    11dc:	7a5b      	ldrb	r3, [r3, #9]
    11de:	461a      	mov	r2, r3
    11e0:	9b03      	ldr	r3, [sp, #12]
    11e2:	4293      	cmp	r3, r2
    11e4:	d3ce      	bcc.n	1184 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    11e6:	9801      	ldr	r0, [sp, #4]
    11e8:	f7ff fdb0 	bl	d4c <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    11ec:	2300      	movs	r3, #0
    11ee:	9303      	str	r3, [sp, #12]
    11f0:	e028      	b.n	1244 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    11f2:	9901      	ldr	r1, [sp, #4]
    11f4:	9a03      	ldr	r2, [sp, #12]
    11f6:	4613      	mov	r3, r2
    11f8:	009b      	lsls	r3, r3, #2
    11fa:	4413      	add	r3, r2
    11fc:	009b      	lsls	r3, r3, #2
    11fe:	440b      	add	r3, r1
    1200:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    1204:	681a      	ldr	r2, [r3, #0]
    1206:	4945      	ldr	r1, [pc, #276]	; (131c <Clock_Ip_InitClock+0x288>)
    1208:	4613      	mov	r3, r2
    120a:	00db      	lsls	r3, r3, #3
    120c:	4413      	add	r3, r2
    120e:	440b      	add	r3, r1
    1210:	3301      	adds	r3, #1
    1212:	781b      	ldrb	r3, [r3, #0]
    1214:	461a      	mov	r2, r3
    1216:	4b48      	ldr	r3, [pc, #288]	; (1338 <Clock_Ip_InitClock+0x2a4>)
    1218:	5c9b      	ldrb	r3, [r3, r2]
    121a:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    121c:	4a47      	ldr	r2, [pc, #284]	; (133c <Clock_Ip_InitClock+0x2a8>)
    121e:	9b02      	ldr	r3, [sp, #8]
    1220:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    1224:	9a03      	ldr	r2, [sp, #12]
    1226:	4613      	mov	r3, r2
    1228:	009b      	lsls	r3, r3, #2
    122a:	4413      	add	r3, r2
    122c:	009b      	lsls	r3, r3, #2
    122e:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    1232:	9a01      	ldr	r2, [sp, #4]
    1234:	4413      	add	r3, r2
    1236:	3304      	adds	r3, #4
    1238:	9903      	ldr	r1, [sp, #12]
    123a:	4618      	mov	r0, r3
    123c:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    123e:	9b03      	ldr	r3, [sp, #12]
    1240:	3301      	adds	r3, #1
    1242:	9303      	str	r3, [sp, #12]
    1244:	9b01      	ldr	r3, [sp, #4]
    1246:	7c5b      	ldrb	r3, [r3, #17]
    1248:	461a      	mov	r2, r3
    124a:	9b03      	ldr	r3, [sp, #12]
    124c:	4293      	cmp	r3, r2
    124e:	d3d0      	bcc.n	11f2 <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1250:	2300      	movs	r3, #0
    1252:	9303      	str	r3, [sp, #12]
    1254:	e026      	b.n	12a4 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    1256:	9901      	ldr	r1, [sp, #4]
    1258:	9a03      	ldr	r2, [sp, #12]
    125a:	4613      	mov	r3, r2
    125c:	005b      	lsls	r3, r3, #1
    125e:	4413      	add	r3, r2
    1260:	009b      	lsls	r3, r3, #2
    1262:	440b      	add	r3, r1
    1264:	f503 730e 	add.w	r3, r3, #568	; 0x238
    1268:	681a      	ldr	r2, [r3, #0]
    126a:	492c      	ldr	r1, [pc, #176]	; (131c <Clock_Ip_InitClock+0x288>)
    126c:	4613      	mov	r3, r2
    126e:	00db      	lsls	r3, r3, #3
    1270:	4413      	add	r3, r2
    1272:	440b      	add	r3, r1
    1274:	3301      	adds	r3, #1
    1276:	781b      	ldrb	r3, [r3, #0]
    1278:	461a      	mov	r2, r3
    127a:	4b31      	ldr	r3, [pc, #196]	; (1340 <Clock_Ip_InitClock+0x2ac>)
    127c:	5c9b      	ldrb	r3, [r3, r2]
    127e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    1280:	4a30      	ldr	r2, [pc, #192]	; (1344 <Clock_Ip_InitClock+0x2b0>)
    1282:	9b02      	ldr	r3, [sp, #8]
    1284:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    1288:	9a03      	ldr	r2, [sp, #12]
    128a:	4613      	mov	r3, r2
    128c:	005b      	lsls	r3, r3, #1
    128e:	4413      	add	r3, r2
    1290:	009b      	lsls	r3, r3, #2
    1292:	f503 730e 	add.w	r3, r3, #568	; 0x238
    1296:	9a01      	ldr	r2, [sp, #4]
    1298:	4413      	add	r3, r2
    129a:	4618      	mov	r0, r3
    129c:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    129e:	9b03      	ldr	r3, [sp, #12]
    12a0:	3301      	adds	r3, #1
    12a2:	9303      	str	r3, [sp, #12]
    12a4:	9b01      	ldr	r3, [sp, #4]
    12a6:	7b5b      	ldrb	r3, [r3, #13]
    12a8:	461a      	mov	r2, r3
    12aa:	9b03      	ldr	r3, [sp, #12]
    12ac:	4293      	cmp	r3, r2
    12ae:	d3d2      	bcc.n	1256 <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    12b0:	2300      	movs	r3, #0
    12b2:	9303      	str	r3, [sp, #12]
    12b4:	e026      	b.n	1304 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    12b6:	9901      	ldr	r1, [sp, #4]
    12b8:	9a03      	ldr	r2, [sp, #12]
    12ba:	4613      	mov	r3, r2
    12bc:	005b      	lsls	r3, r3, #1
    12be:	4413      	add	r3, r2
    12c0:	009b      	lsls	r3, r3, #2
    12c2:	440b      	add	r3, r1
    12c4:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    12c8:	681a      	ldr	r2, [r3, #0]
    12ca:	4914      	ldr	r1, [pc, #80]	; (131c <Clock_Ip_InitClock+0x288>)
    12cc:	4613      	mov	r3, r2
    12ce:	00db      	lsls	r3, r3, #3
    12d0:	4413      	add	r3, r2
    12d2:	440b      	add	r3, r1
    12d4:	3301      	adds	r3, #1
    12d6:	781b      	ldrb	r3, [r3, #0]
    12d8:	461a      	mov	r2, r3
    12da:	4b1b      	ldr	r3, [pc, #108]	; (1348 <Clock_Ip_InitClock+0x2b4>)
    12dc:	5c9b      	ldrb	r3, [r3, r2]
    12de:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    12e0:	4a1a      	ldr	r2, [pc, #104]	; (134c <Clock_Ip_InitClock+0x2b8>)
    12e2:	9b02      	ldr	r3, [sp, #8]
    12e4:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    12e8:	9a03      	ldr	r2, [sp, #12]
    12ea:	4613      	mov	r3, r2
    12ec:	005b      	lsls	r3, r3, #1
    12ee:	4413      	add	r3, r2
    12f0:	009b      	lsls	r3, r3, #2
    12f2:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    12f6:	9a01      	ldr	r2, [sp, #4]
    12f8:	4413      	add	r3, r2
    12fa:	4618      	mov	r0, r3
    12fc:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    12fe:	9b03      	ldr	r3, [sp, #12]
    1300:	3301      	adds	r3, #1
    1302:	9303      	str	r3, [sp, #12]
    1304:	9b01      	ldr	r3, [sp, #4]
    1306:	7b1b      	ldrb	r3, [r3, #12]
    1308:	461a      	mov	r2, r3
    130a:	9b03      	ldr	r3, [sp, #12]
    130c:	4293      	cmp	r3, r2
    130e:	d3d2      	bcc.n	12b6 <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    1310:	2300      	movs	r3, #0
    1312:	9303      	str	r3, [sp, #12]
    1314:	e044      	b.n	13a0 <Clock_Ip_InitClock+0x30c>
    1316:	bf00      	nop
    1318:	1fff8b34 	.word	0x1fff8b34
    131c:	00006d0c 	.word	0x00006d0c
    1320:	00006cfc 	.word	0x00006cfc
    1324:	00007308 	.word	0x00007308
    1328:	00006c9c 	.word	0x00006c9c
    132c:	000072cc 	.word	0x000072cc
    1330:	00006c8c 	.word	0x00006c8c
    1334:	00007260 	.word	0x00007260
    1338:	00006cec 	.word	0x00006cec
    133c:	00007340 	.word	0x00007340
    1340:	00006c7c 	.word	0x00006c7c
    1344:	00007258 	.word	0x00007258
    1348:	00006c6c 	.word	0x00006c6c
    134c:	0000721c 	.word	0x0000721c
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    1350:	9901      	ldr	r1, [sp, #4]
    1352:	9a03      	ldr	r2, [sp, #12]
    1354:	4613      	mov	r3, r2
    1356:	005b      	lsls	r3, r3, #1
    1358:	4413      	add	r3, r2
    135a:	009b      	lsls	r3, r3, #2
    135c:	440b      	add	r3, r1
    135e:	f503 730e 	add.w	r3, r3, #568	; 0x238
    1362:	681a      	ldr	r2, [r3, #0]
    1364:	49ac      	ldr	r1, [pc, #688]	; (1618 <Clock_Ip_InitClock+0x584>)
    1366:	4613      	mov	r3, r2
    1368:	00db      	lsls	r3, r3, #3
    136a:	4413      	add	r3, r2
    136c:	440b      	add	r3, r1
    136e:	3301      	adds	r3, #1
    1370:	781b      	ldrb	r3, [r3, #0]
    1372:	461a      	mov	r2, r3
    1374:	4ba9      	ldr	r3, [pc, #676]	; (161c <Clock_Ip_InitClock+0x588>)
    1376:	5c9b      	ldrb	r3, [r3, r2]
    1378:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    137a:	4aa9      	ldr	r2, [pc, #676]	; (1620 <Clock_Ip_InitClock+0x58c>)
    137c:	9b02      	ldr	r3, [sp, #8]
    137e:	00db      	lsls	r3, r3, #3
    1380:	4413      	add	r3, r2
    1382:	6859      	ldr	r1, [r3, #4]
    1384:	9a03      	ldr	r2, [sp, #12]
    1386:	4613      	mov	r3, r2
    1388:	005b      	lsls	r3, r3, #1
    138a:	4413      	add	r3, r2
    138c:	009b      	lsls	r3, r3, #2
    138e:	f503 730e 	add.w	r3, r3, #568	; 0x238
    1392:	9a01      	ldr	r2, [sp, #4]
    1394:	4413      	add	r3, r2
    1396:	4618      	mov	r0, r3
    1398:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    139a:	9b03      	ldr	r3, [sp, #12]
    139c:	3301      	adds	r3, #1
    139e:	9303      	str	r3, [sp, #12]
    13a0:	9b01      	ldr	r3, [sp, #4]
    13a2:	7b5b      	ldrb	r3, [r3, #13]
    13a4:	461a      	mov	r2, r3
    13a6:	9b03      	ldr	r3, [sp, #12]
    13a8:	4293      	cmp	r3, r2
    13aa:	d3d1      	bcc.n	1350 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    13ac:	2300      	movs	r3, #0
    13ae:	9303      	str	r3, [sp, #12]
    13b0:	e029      	b.n	1406 <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    13b2:	9901      	ldr	r1, [sp, #4]
    13b4:	9a03      	ldr	r2, [sp, #12]
    13b6:	4613      	mov	r3, r2
    13b8:	009b      	lsls	r3, r3, #2
    13ba:	4413      	add	r3, r2
    13bc:	00db      	lsls	r3, r3, #3
    13be:	440b      	add	r3, r1
    13c0:	3340      	adds	r3, #64	; 0x40
    13c2:	681a      	ldr	r2, [r3, #0]
    13c4:	4994      	ldr	r1, [pc, #592]	; (1618 <Clock_Ip_InitClock+0x584>)
    13c6:	4613      	mov	r3, r2
    13c8:	00db      	lsls	r3, r3, #3
    13ca:	4413      	add	r3, r2
    13cc:	440b      	add	r3, r1
    13ce:	3301      	adds	r3, #1
    13d0:	781b      	ldrb	r3, [r3, #0]
    13d2:	461a      	mov	r2, r3
    13d4:	4b93      	ldr	r3, [pc, #588]	; (1624 <Clock_Ip_InitClock+0x590>)
    13d6:	5c9b      	ldrb	r3, [r3, r2]
    13d8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    13da:	4993      	ldr	r1, [pc, #588]	; (1628 <Clock_Ip_InitClock+0x594>)
    13dc:	9a02      	ldr	r2, [sp, #8]
    13de:	4613      	mov	r3, r2
    13e0:	009b      	lsls	r3, r3, #2
    13e2:	4413      	add	r3, r2
    13e4:	009b      	lsls	r3, r3, #2
    13e6:	440b      	add	r3, r1
    13e8:	3304      	adds	r3, #4
    13ea:	6819      	ldr	r1, [r3, #0]
    13ec:	9a03      	ldr	r2, [sp, #12]
    13ee:	4613      	mov	r3, r2
    13f0:	009b      	lsls	r3, r3, #2
    13f2:	4413      	add	r3, r2
    13f4:	00db      	lsls	r3, r3, #3
    13f6:	3340      	adds	r3, #64	; 0x40
    13f8:	9a01      	ldr	r2, [sp, #4]
    13fa:	4413      	add	r3, r2
    13fc:	4618      	mov	r0, r3
    13fe:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    1400:	9b03      	ldr	r3, [sp, #12]
    1402:	3301      	adds	r3, #1
    1404:	9303      	str	r3, [sp, #12]
    1406:	9b01      	ldr	r3, [sp, #4]
    1408:	7a9b      	ldrb	r3, [r3, #10]
    140a:	461a      	mov	r2, r3
    140c:	9b03      	ldr	r3, [sp, #12]
    140e:	4293      	cmp	r3, r2
    1410:	d3cf      	bcc.n	13b2 <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    1412:	2300      	movs	r3, #0
    1414:	9303      	str	r3, [sp, #12]
    1416:	e029      	b.n	146c <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1418:	9901      	ldr	r1, [sp, #4]
    141a:	9a03      	ldr	r2, [sp, #12]
    141c:	4613      	mov	r3, r2
    141e:	009b      	lsls	r3, r3, #2
    1420:	4413      	add	r3, r2
    1422:	009b      	lsls	r3, r3, #2
    1424:	440b      	add	r3, r1
    1426:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    142a:	681a      	ldr	r2, [r3, #0]
    142c:	497a      	ldr	r1, [pc, #488]	; (1618 <Clock_Ip_InitClock+0x584>)
    142e:	4613      	mov	r3, r2
    1430:	00db      	lsls	r3, r3, #3
    1432:	4413      	add	r3, r2
    1434:	440b      	add	r3, r1
    1436:	3301      	adds	r3, #1
    1438:	781b      	ldrb	r3, [r3, #0]
    143a:	461a      	mov	r2, r3
    143c:	4b7b      	ldr	r3, [pc, #492]	; (162c <Clock_Ip_InitClock+0x598>)
    143e:	5c9b      	ldrb	r3, [r3, r2]
    1440:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    1442:	4a7b      	ldr	r2, [pc, #492]	; (1630 <Clock_Ip_InitClock+0x59c>)
    1444:	9b02      	ldr	r3, [sp, #8]
    1446:	011b      	lsls	r3, r3, #4
    1448:	4413      	add	r3, r2
    144a:	3304      	adds	r3, #4
    144c:	681c      	ldr	r4, [r3, #0]
    144e:	9a03      	ldr	r2, [sp, #12]
    1450:	4613      	mov	r3, r2
    1452:	009b      	lsls	r3, r3, #2
    1454:	4413      	add	r3, r2
    1456:	009b      	lsls	r3, r3, #2
    1458:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    145c:	9a01      	ldr	r2, [sp, #4]
    145e:	4413      	add	r3, r2
    1460:	9903      	ldr	r1, [sp, #12]
    1462:	4618      	mov	r0, r3
    1464:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    1466:	9b03      	ldr	r3, [sp, #12]
    1468:	3301      	adds	r3, #1
    146a:	9303      	str	r3, [sp, #12]
    146c:	9b01      	ldr	r3, [sp, #4]
    146e:	7c9b      	ldrb	r3, [r3, #18]
    1470:	461a      	mov	r2, r3
    1472:	9b03      	ldr	r3, [sp, #12]
    1474:	4293      	cmp	r3, r2
    1476:	d3cf      	bcc.n	1418 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    1478:	2300      	movs	r3, #0
    147a:	9303      	str	r3, [sp, #12]
    147c:	e02a      	b.n	14d4 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    147e:	9901      	ldr	r1, [sp, #4]
    1480:	9a03      	ldr	r2, [sp, #12]
    1482:	4613      	mov	r3, r2
    1484:	009b      	lsls	r3, r3, #2
    1486:	4413      	add	r3, r2
    1488:	009b      	lsls	r3, r3, #2
    148a:	440b      	add	r3, r1
    148c:	332c      	adds	r3, #44	; 0x2c
    148e:	681a      	ldr	r2, [r3, #0]
    1490:	4961      	ldr	r1, [pc, #388]	; (1618 <Clock_Ip_InitClock+0x584>)
    1492:	4613      	mov	r3, r2
    1494:	00db      	lsls	r3, r3, #3
    1496:	4413      	add	r3, r2
    1498:	440b      	add	r3, r1
    149a:	3301      	adds	r3, #1
    149c:	781b      	ldrb	r3, [r3, #0]
    149e:	461a      	mov	r2, r3
    14a0:	4b64      	ldr	r3, [pc, #400]	; (1634 <Clock_Ip_InitClock+0x5a0>)
    14a2:	5c9b      	ldrb	r3, [r3, r2]
    14a4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    14a6:	4964      	ldr	r1, [pc, #400]	; (1638 <Clock_Ip_InitClock+0x5a4>)
    14a8:	9a02      	ldr	r2, [sp, #8]
    14aa:	4613      	mov	r3, r2
    14ac:	009b      	lsls	r3, r3, #2
    14ae:	4413      	add	r3, r2
    14b0:	009b      	lsls	r3, r3, #2
    14b2:	440b      	add	r3, r1
    14b4:	3308      	adds	r3, #8
    14b6:	6819      	ldr	r1, [r3, #0]
    14b8:	9a03      	ldr	r2, [sp, #12]
    14ba:	4613      	mov	r3, r2
    14bc:	009b      	lsls	r3, r3, #2
    14be:	4413      	add	r3, r2
    14c0:	009b      	lsls	r3, r3, #2
    14c2:	3328      	adds	r3, #40	; 0x28
    14c4:	9a01      	ldr	r2, [sp, #4]
    14c6:	4413      	add	r3, r2
    14c8:	3304      	adds	r3, #4
    14ca:	4618      	mov	r0, r3
    14cc:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    14ce:	9b03      	ldr	r3, [sp, #12]
    14d0:	3301      	adds	r3, #1
    14d2:	9303      	str	r3, [sp, #12]
    14d4:	9b01      	ldr	r3, [sp, #4]
    14d6:	7a5b      	ldrb	r3, [r3, #9]
    14d8:	461a      	mov	r2, r3
    14da:	9b03      	ldr	r3, [sp, #12]
    14dc:	4293      	cmp	r3, r2
    14de:	d3ce      	bcc.n	147e <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    14e0:	2300      	movs	r3, #0
    14e2:	9303      	str	r3, [sp, #12]
    14e4:	e029      	b.n	153a <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    14e6:	9901      	ldr	r1, [sp, #4]
    14e8:	9a03      	ldr	r2, [sp, #12]
    14ea:	4613      	mov	r3, r2
    14ec:	009b      	lsls	r3, r3, #2
    14ee:	4413      	add	r3, r2
    14f0:	00db      	lsls	r3, r3, #3
    14f2:	440b      	add	r3, r1
    14f4:	3340      	adds	r3, #64	; 0x40
    14f6:	681a      	ldr	r2, [r3, #0]
    14f8:	4947      	ldr	r1, [pc, #284]	; (1618 <Clock_Ip_InitClock+0x584>)
    14fa:	4613      	mov	r3, r2
    14fc:	00db      	lsls	r3, r3, #3
    14fe:	4413      	add	r3, r2
    1500:	440b      	add	r3, r1
    1502:	3301      	adds	r3, #1
    1504:	781b      	ldrb	r3, [r3, #0]
    1506:	461a      	mov	r2, r3
    1508:	4b46      	ldr	r3, [pc, #280]	; (1624 <Clock_Ip_InitClock+0x590>)
    150a:	5c9b      	ldrb	r3, [r3, r2]
    150c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    150e:	4946      	ldr	r1, [pc, #280]	; (1628 <Clock_Ip_InitClock+0x594>)
    1510:	9a02      	ldr	r2, [sp, #8]
    1512:	4613      	mov	r3, r2
    1514:	009b      	lsls	r3, r3, #2
    1516:	4413      	add	r3, r2
    1518:	009b      	lsls	r3, r3, #2
    151a:	440b      	add	r3, r1
    151c:	330c      	adds	r3, #12
    151e:	6819      	ldr	r1, [r3, #0]
    1520:	9a03      	ldr	r2, [sp, #12]
    1522:	4613      	mov	r3, r2
    1524:	009b      	lsls	r3, r3, #2
    1526:	4413      	add	r3, r2
    1528:	00db      	lsls	r3, r3, #3
    152a:	3340      	adds	r3, #64	; 0x40
    152c:	9a01      	ldr	r2, [sp, #4]
    152e:	4413      	add	r3, r2
    1530:	4618      	mov	r0, r3
    1532:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    1534:	9b03      	ldr	r3, [sp, #12]
    1536:	3301      	adds	r3, #1
    1538:	9303      	str	r3, [sp, #12]
    153a:	9b01      	ldr	r3, [sp, #4]
    153c:	7a9b      	ldrb	r3, [r3, #10]
    153e:	461a      	mov	r2, r3
    1540:	9b03      	ldr	r3, [sp, #12]
    1542:	4293      	cmp	r3, r2
    1544:	d3cf      	bcc.n	14e6 <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1546:	2300      	movs	r3, #0
    1548:	9303      	str	r3, [sp, #12]
    154a:	e025      	b.n	1598 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    154c:	9a01      	ldr	r2, [sp, #4]
    154e:	9b03      	ldr	r3, [sp, #12]
    1550:	3324      	adds	r3, #36	; 0x24
    1552:	011b      	lsls	r3, r3, #4
    1554:	4413      	add	r3, r2
    1556:	3304      	adds	r3, #4
    1558:	681a      	ldr	r2, [r3, #0]
    155a:	492f      	ldr	r1, [pc, #188]	; (1618 <Clock_Ip_InitClock+0x584>)
    155c:	4613      	mov	r3, r2
    155e:	00db      	lsls	r3, r3, #3
    1560:	4413      	add	r3, r2
    1562:	440b      	add	r3, r1
    1564:	3301      	adds	r3, #1
    1566:	781b      	ldrb	r3, [r3, #0]
    1568:	461a      	mov	r2, r3
    156a:	4b34      	ldr	r3, [pc, #208]	; (163c <Clock_Ip_InitClock+0x5a8>)
    156c:	5c9b      	ldrb	r3, [r3, r2]
    156e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    1570:	4933      	ldr	r1, [pc, #204]	; (1640 <Clock_Ip_InitClock+0x5ac>)
    1572:	9a02      	ldr	r2, [sp, #8]
    1574:	4613      	mov	r3, r2
    1576:	005b      	lsls	r3, r3, #1
    1578:	4413      	add	r3, r2
    157a:	009b      	lsls	r3, r3, #2
    157c:	440b      	add	r3, r1
    157e:	3304      	adds	r3, #4
    1580:	681b      	ldr	r3, [r3, #0]
    1582:	9a03      	ldr	r2, [sp, #12]
    1584:	3224      	adds	r2, #36	; 0x24
    1586:	0112      	lsls	r2, r2, #4
    1588:	9901      	ldr	r1, [sp, #4]
    158a:	440a      	add	r2, r1
    158c:	3204      	adds	r2, #4
    158e:	4610      	mov	r0, r2
    1590:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    1592:	9b03      	ldr	r3, [sp, #12]
    1594:	3301      	adds	r3, #1
    1596:	9303      	str	r3, [sp, #12]
    1598:	9b01      	ldr	r3, [sp, #4]
    159a:	7b9b      	ldrb	r3, [r3, #14]
    159c:	461a      	mov	r2, r3
    159e:	9b03      	ldr	r3, [sp, #12]
    15a0:	4293      	cmp	r3, r2
    15a2:	d3d3      	bcc.n	154c <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    15a4:	4b27      	ldr	r3, [pc, #156]	; (1644 <Clock_Ip_InitClock+0x5b0>)
    15a6:	2200      	movs	r2, #0
    15a8:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    15aa:	4b26      	ldr	r3, [pc, #152]	; (1644 <Clock_Ip_InitClock+0x5b0>)
    15ac:	2200      	movs	r2, #0
    15ae:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    15b0:	4b24      	ldr	r3, [pc, #144]	; (1644 <Clock_Ip_InitClock+0x5b0>)
    15b2:	2201      	movs	r2, #1
    15b4:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    15b6:	4b23      	ldr	r3, [pc, #140]	; (1644 <Clock_Ip_InitClock+0x5b0>)
    15b8:	2200      	movs	r2, #0
    15ba:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    15bc:	f000 fa9c 	bl	1af8 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    15c0:	2300      	movs	r3, #0
    15c2:	9303      	str	r3, [sp, #12]
    15c4:	e04c      	b.n	1660 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    15c6:	9a01      	ldr	r2, [sp, #4]
    15c8:	9b03      	ldr	r3, [sp, #12]
    15ca:	330d      	adds	r3, #13
    15cc:	00db      	lsls	r3, r3, #3
    15ce:	4413      	add	r3, r2
    15d0:	685b      	ldr	r3, [r3, #4]
    15d2:	4a1d      	ldr	r2, [pc, #116]	; (1648 <Clock_Ip_InitClock+0x5b4>)
    15d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    15d8:	2b03      	cmp	r3, #3
    15da:	d03b      	beq.n	1654 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    15dc:	9b01      	ldr	r3, [sp, #4]
    15de:	9a03      	ldr	r2, [sp, #12]
    15e0:	320d      	adds	r2, #13
    15e2:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    15e6:	490c      	ldr	r1, [pc, #48]	; (1618 <Clock_Ip_InitClock+0x584>)
    15e8:	4613      	mov	r3, r2
    15ea:	00db      	lsls	r3, r3, #3
    15ec:	4413      	add	r3, r2
    15ee:	440b      	add	r3, r1
    15f0:	3301      	adds	r3, #1
    15f2:	781b      	ldrb	r3, [r3, #0]
    15f4:	461a      	mov	r2, r3
    15f6:	4b15      	ldr	r3, [pc, #84]	; (164c <Clock_Ip_InitClock+0x5b8>)
    15f8:	5c9b      	ldrb	r3, [r3, r2]
    15fa:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    15fc:	4a14      	ldr	r2, [pc, #80]	; (1650 <Clock_Ip_InitClock+0x5bc>)
    15fe:	9b02      	ldr	r3, [sp, #8]
    1600:	00db      	lsls	r3, r3, #3
    1602:	4413      	add	r3, r2
    1604:	685b      	ldr	r3, [r3, #4]
    1606:	9a03      	ldr	r2, [sp, #12]
    1608:	320d      	adds	r2, #13
    160a:	00d2      	lsls	r2, r2, #3
    160c:	9901      	ldr	r1, [sp, #4]
    160e:	440a      	add	r2, r1
    1610:	4610      	mov	r0, r2
    1612:	4798      	blx	r3
    1614:	e021      	b.n	165a <Clock_Ip_InitClock+0x5c6>
    1616:	bf00      	nop
    1618:	00006d0c 	.word	0x00006d0c
    161c:	00006c7c 	.word	0x00006c7c
    1620:	00007258 	.word	0x00007258
    1624:	00006ccc 	.word	0x00006ccc
    1628:	00007318 	.word	0x00007318
    162c:	00006cfc 	.word	0x00006cfc
    1630:	00007308 	.word	0x00007308
    1634:	00006c8c 	.word	0x00006c8c
    1638:	00007260 	.word	0x00007260
    163c:	00006cbc 	.word	0x00006cbc
    1640:	00007288 	.word	0x00007288
    1644:	1fff8b3c 	.word	0x1fff8b3c
    1648:	00007158 	.word	0x00007158
    164c:	00006cdc 	.word	0x00006cdc
    1650:	00007344 	.word	0x00007344
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    1654:	4b3a      	ldr	r3, [pc, #232]	; (1740 <Clock_Ip_InitClock+0x6ac>)
    1656:	2201      	movs	r2, #1
    1658:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    165a:	9b03      	ldr	r3, [sp, #12]
    165c:	3301      	adds	r3, #1
    165e:	9303      	str	r3, [sp, #12]
    1660:	9b01      	ldr	r3, [sp, #4]
    1662:	7adb      	ldrb	r3, [r3, #11]
    1664:	461a      	mov	r2, r3
    1666:	9b03      	ldr	r3, [sp, #12]
    1668:	4293      	cmp	r3, r2
    166a:	d3ac      	bcc.n	15c6 <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    166c:	4b34      	ldr	r3, [pc, #208]	; (1740 <Clock_Ip_InitClock+0x6ac>)
    166e:	781b      	ldrb	r3, [r3, #0]
    1670:	f083 0301 	eor.w	r3, r3, #1
    1674:	b2db      	uxtb	r3, r3
    1676:	2b00      	cmp	r3, #0
    1678:	d05e      	beq.n	1738 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    167a:	2300      	movs	r3, #0
    167c:	9303      	str	r3, [sp, #12]
    167e:	e01f      	b.n	16c0 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    1680:	9a01      	ldr	r2, [sp, #4]
    1682:	9b03      	ldr	r3, [sp, #12]
    1684:	334e      	adds	r3, #78	; 0x4e
    1686:	00db      	lsls	r3, r3, #3
    1688:	4413      	add	r3, r2
    168a:	685a      	ldr	r2, [r3, #4]
    168c:	492d      	ldr	r1, [pc, #180]	; (1744 <Clock_Ip_InitClock+0x6b0>)
    168e:	4613      	mov	r3, r2
    1690:	00db      	lsls	r3, r3, #3
    1692:	4413      	add	r3, r2
    1694:	440b      	add	r3, r1
    1696:	3301      	adds	r3, #1
    1698:	781b      	ldrb	r3, [r3, #0]
    169a:	461a      	mov	r2, r3
    169c:	4b2a      	ldr	r3, [pc, #168]	; (1748 <Clock_Ip_InitClock+0x6b4>)
    169e:	5c9b      	ldrb	r3, [r3, r2]
    16a0:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    16a2:	4a2a      	ldr	r2, [pc, #168]	; (174c <Clock_Ip_InitClock+0x6b8>)
    16a4:	9b02      	ldr	r3, [sp, #8]
    16a6:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    16aa:	9a03      	ldr	r2, [sp, #12]
    16ac:	324e      	adds	r2, #78	; 0x4e
    16ae:	00d2      	lsls	r2, r2, #3
    16b0:	9901      	ldr	r1, [sp, #4]
    16b2:	440a      	add	r2, r1
    16b4:	3204      	adds	r2, #4
    16b6:	4610      	mov	r0, r2
    16b8:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    16ba:	9b03      	ldr	r3, [sp, #12]
    16bc:	3301      	adds	r3, #1
    16be:	9303      	str	r3, [sp, #12]
    16c0:	9b01      	ldr	r3, [sp, #4]
    16c2:	7c1b      	ldrb	r3, [r3, #16]
    16c4:	461a      	mov	r2, r3
    16c6:	9b03      	ldr	r3, [sp, #12]
    16c8:	4293      	cmp	r3, r2
    16ca:	d3d9      	bcc.n	1680 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    16cc:	2300      	movs	r3, #0
    16ce:	9303      	str	r3, [sp, #12]
    16d0:	e028      	b.n	1724 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    16d2:	9901      	ldr	r1, [sp, #4]
    16d4:	9a03      	ldr	r2, [sp, #12]
    16d6:	4613      	mov	r3, r2
    16d8:	009b      	lsls	r3, r3, #2
    16da:	4413      	add	r3, r2
    16dc:	009b      	lsls	r3, r3, #2
    16de:	440b      	add	r3, r1
    16e0:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    16e4:	681a      	ldr	r2, [r3, #0]
    16e6:	4917      	ldr	r1, [pc, #92]	; (1744 <Clock_Ip_InitClock+0x6b0>)
    16e8:	4613      	mov	r3, r2
    16ea:	00db      	lsls	r3, r3, #3
    16ec:	4413      	add	r3, r2
    16ee:	440b      	add	r3, r1
    16f0:	3301      	adds	r3, #1
    16f2:	781b      	ldrb	r3, [r3, #0]
    16f4:	461a      	mov	r2, r3
    16f6:	4b16      	ldr	r3, [pc, #88]	; (1750 <Clock_Ip_InitClock+0x6bc>)
    16f8:	5c9b      	ldrb	r3, [r3, r2]
    16fa:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    16fc:	4a15      	ldr	r2, [pc, #84]	; (1754 <Clock_Ip_InitClock+0x6c0>)
    16fe:	9b02      	ldr	r3, [sp, #8]
    1700:	011b      	lsls	r3, r3, #4
    1702:	4413      	add	r3, r2
    1704:	330c      	adds	r3, #12
    1706:	6819      	ldr	r1, [r3, #0]
    1708:	9a03      	ldr	r2, [sp, #12]
    170a:	4613      	mov	r3, r2
    170c:	009b      	lsls	r3, r3, #2
    170e:	4413      	add	r3, r2
    1710:	009b      	lsls	r3, r3, #2
    1712:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1716:	9a01      	ldr	r2, [sp, #4]
    1718:	4413      	add	r3, r2
    171a:	4618      	mov	r0, r3
    171c:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    171e:	9b03      	ldr	r3, [sp, #12]
    1720:	3301      	adds	r3, #1
    1722:	9303      	str	r3, [sp, #12]
    1724:	9b01      	ldr	r3, [sp, #4]
    1726:	7c9b      	ldrb	r3, [r3, #18]
    1728:	461a      	mov	r2, r3
    172a:	9b03      	ldr	r3, [sp, #12]
    172c:	4293      	cmp	r3, r2
    172e:	d3d0      	bcc.n	16d2 <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    1730:	2104      	movs	r1, #4
    1732:	9801      	ldr	r0, [sp, #4]
    1734:	f002 ff48 	bl	45c8 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    1738:	bf00      	nop
    173a:	b004      	add	sp, #16
    173c:	bd10      	pop	{r4, pc}
    173e:	bf00      	nop
    1740:	1fff8b3c 	.word	0x1fff8b3c
    1744:	00006d0c 	.word	0x00006d0c
    1748:	00006cac 	.word	0x00006cac
    174c:	00007294 	.word	0x00007294
    1750:	00006cfc 	.word	0x00006cfc
    1754:	00007308 	.word	0x00007308

00001758 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    1758:	b500      	push	{lr}
    175a:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    175c:	2302      	movs	r3, #2
    175e:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    1760:	2300      	movs	r3, #0
    1762:	9304      	str	r3, [sp, #16]
    1764:	e02c      	b.n	17c0 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    1766:	4a36      	ldr	r2, [pc, #216]	; (1840 <Clock_Ip_GetPllStatus+0xe8>)
    1768:	9b04      	ldr	r3, [sp, #16]
    176a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    176e:	4935      	ldr	r1, [pc, #212]	; (1844 <Clock_Ip_GetPllStatus+0xec>)
    1770:	4613      	mov	r3, r2
    1772:	00db      	lsls	r3, r3, #3
    1774:	4413      	add	r3, r2
    1776:	440b      	add	r3, r1
    1778:	3301      	adds	r3, #1
    177a:	781b      	ldrb	r3, [r3, #0]
    177c:	461a      	mov	r2, r3
    177e:	4b32      	ldr	r3, [pc, #200]	; (1848 <Clock_Ip_GetPllStatus+0xf0>)
    1780:	5c9b      	ldrb	r3, [r3, r2]
    1782:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    1784:	4931      	ldr	r1, [pc, #196]	; (184c <Clock_Ip_GetPllStatus+0xf4>)
    1786:	9a03      	ldr	r2, [sp, #12]
    1788:	4613      	mov	r3, r2
    178a:	009b      	lsls	r3, r3, #2
    178c:	4413      	add	r3, r2
    178e:	009b      	lsls	r3, r3, #2
    1790:	440b      	add	r3, r1
    1792:	3308      	adds	r3, #8
    1794:	681b      	ldr	r3, [r3, #0]
    1796:	492a      	ldr	r1, [pc, #168]	; (1840 <Clock_Ip_GetPllStatus+0xe8>)
    1798:	9a04      	ldr	r2, [sp, #16]
    179a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    179e:	4610      	mov	r0, r2
    17a0:	4798      	blx	r3
    17a2:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    17a4:	9b02      	ldr	r3, [sp, #8]
    17a6:	2b01      	cmp	r3, #1
    17a8:	d102      	bne.n	17b0 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    17aa:	2301      	movs	r3, #1
    17ac:	9305      	str	r3, [sp, #20]
            break;
    17ae:	e00d      	b.n	17cc <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    17b0:	9b02      	ldr	r3, [sp, #8]
    17b2:	2b02      	cmp	r3, #2
    17b4:	d101      	bne.n	17ba <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    17b6:	2300      	movs	r3, #0
    17b8:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    17ba:	9b04      	ldr	r3, [sp, #16]
    17bc:	3301      	adds	r3, #1
    17be:	9304      	str	r3, [sp, #16]
    17c0:	4b23      	ldr	r3, [pc, #140]	; (1850 <Clock_Ip_GetPllStatus+0xf8>)
    17c2:	789b      	ldrb	r3, [r3, #2]
    17c4:	461a      	mov	r2, r3
    17c6:	9b04      	ldr	r3, [sp, #16]
    17c8:	4293      	cmp	r3, r2
    17ca:	d3cc      	bcc.n	1766 <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    17cc:	9b05      	ldr	r3, [sp, #20]
    17ce:	2b00      	cmp	r3, #0
    17d0:	d130      	bne.n	1834 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    17d2:	2300      	movs	r3, #0
    17d4:	9304      	str	r3, [sp, #16]
    17d6:	e027      	b.n	1828 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    17d8:	4a1e      	ldr	r2, [pc, #120]	; (1854 <Clock_Ip_GetPllStatus+0xfc>)
    17da:	9b04      	ldr	r3, [sp, #16]
    17dc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    17e0:	4918      	ldr	r1, [pc, #96]	; (1844 <Clock_Ip_GetPllStatus+0xec>)
    17e2:	4613      	mov	r3, r2
    17e4:	00db      	lsls	r3, r3, #3
    17e6:	4413      	add	r3, r2
    17e8:	440b      	add	r3, r1
    17ea:	3301      	adds	r3, #1
    17ec:	781b      	ldrb	r3, [r3, #0]
    17ee:	461a      	mov	r2, r3
    17f0:	4b19      	ldr	r3, [pc, #100]	; (1858 <Clock_Ip_GetPllStatus+0x100>)
    17f2:	5c9b      	ldrb	r3, [r3, r2]
    17f4:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    17f6:	4919      	ldr	r1, [pc, #100]	; (185c <Clock_Ip_GetPllStatus+0x104>)
    17f8:	9a03      	ldr	r2, [sp, #12]
    17fa:	4613      	mov	r3, r2
    17fc:	005b      	lsls	r3, r3, #1
    17fe:	4413      	add	r3, r2
    1800:	009b      	lsls	r3, r3, #2
    1802:	440b      	add	r3, r1
    1804:	3308      	adds	r3, #8
    1806:	681b      	ldr	r3, [r3, #0]
    1808:	4912      	ldr	r1, [pc, #72]	; (1854 <Clock_Ip_GetPllStatus+0xfc>)
    180a:	9a04      	ldr	r2, [sp, #16]
    180c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    1810:	4610      	mov	r0, r2
    1812:	4798      	blx	r3
    1814:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    1816:	9b01      	ldr	r3, [sp, #4]
    1818:	2b01      	cmp	r3, #1
    181a:	d102      	bne.n	1822 <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    181c:	2301      	movs	r3, #1
    181e:	9305      	str	r3, [sp, #20]
                break;
    1820:	e008      	b.n	1834 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    1822:	9b04      	ldr	r3, [sp, #16]
    1824:	3301      	adds	r3, #1
    1826:	9304      	str	r3, [sp, #16]
    1828:	4b09      	ldr	r3, [pc, #36]	; (1850 <Clock_Ip_GetPllStatus+0xf8>)
    182a:	78db      	ldrb	r3, [r3, #3]
    182c:	461a      	mov	r2, r3
    182e:	9b04      	ldr	r3, [sp, #16]
    1830:	4293      	cmp	r3, r2
    1832:	d3d1      	bcc.n	17d8 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    1834:	9b05      	ldr	r3, [sp, #20]
}
    1836:	4618      	mov	r0, r3
    1838:	b007      	add	sp, #28
    183a:	f85d fb04 	ldr.w	pc, [sp], #4
    183e:	bf00      	nop
    1840:	00007214 	.word	0x00007214
    1844:	00006d0c 	.word	0x00006d0c
    1848:	00006ccc 	.word	0x00006ccc
    184c:	00007318 	.word	0x00007318
    1850:	1fff8b3c 	.word	0x1fff8b3c
    1854:	00007218 	.word	0x00007218
    1858:	00006cbc 	.word	0x00006cbc
    185c:	00007288 	.word	0x00007288

00001860 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    1860:	b500      	push	{lr}
    1862:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    1864:	4b55      	ldr	r3, [pc, #340]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    1866:	681b      	ldr	r3, [r3, #0]
    1868:	2b00      	cmp	r3, #0
    186a:	f000 80a2 	beq.w	19b2 <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    186e:	2300      	movs	r3, #0
    1870:	9301      	str	r3, [sp, #4]
    1872:	e02c      	b.n	18ce <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    1874:	4b51      	ldr	r3, [pc, #324]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    1876:	681a      	ldr	r2, [r3, #0]
    1878:	9b01      	ldr	r3, [sp, #4]
    187a:	330d      	adds	r3, #13
    187c:	00db      	lsls	r3, r3, #3
    187e:	4413      	add	r3, r2
    1880:	685b      	ldr	r3, [r3, #4]
    1882:	4a4f      	ldr	r2, [pc, #316]	; (19c0 <Clock_Ip_DistributePll+0x160>)
    1884:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1888:	2b03      	cmp	r3, #3
    188a:	d11d      	bne.n	18c8 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    188c:	4b4b      	ldr	r3, [pc, #300]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    188e:	681b      	ldr	r3, [r3, #0]
    1890:	9a01      	ldr	r2, [sp, #4]
    1892:	320d      	adds	r2, #13
    1894:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    1898:	494a      	ldr	r1, [pc, #296]	; (19c4 <Clock_Ip_DistributePll+0x164>)
    189a:	4613      	mov	r3, r2
    189c:	00db      	lsls	r3, r3, #3
    189e:	4413      	add	r3, r2
    18a0:	440b      	add	r3, r1
    18a2:	3301      	adds	r3, #1
    18a4:	781b      	ldrb	r3, [r3, #0]
    18a6:	461a      	mov	r2, r3
    18a8:	4b47      	ldr	r3, [pc, #284]	; (19c8 <Clock_Ip_DistributePll+0x168>)
    18aa:	5c9b      	ldrb	r3, [r3, r2]
    18ac:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    18ae:	4a47      	ldr	r2, [pc, #284]	; (19cc <Clock_Ip_DistributePll+0x16c>)
    18b0:	9b00      	ldr	r3, [sp, #0]
    18b2:	00db      	lsls	r3, r3, #3
    18b4:	4413      	add	r3, r2
    18b6:	685b      	ldr	r3, [r3, #4]
    18b8:	4a40      	ldr	r2, [pc, #256]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    18ba:	6811      	ldr	r1, [r2, #0]
    18bc:	9a01      	ldr	r2, [sp, #4]
    18be:	320d      	adds	r2, #13
    18c0:	00d2      	lsls	r2, r2, #3
    18c2:	440a      	add	r2, r1
    18c4:	4610      	mov	r0, r2
    18c6:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    18c8:	9b01      	ldr	r3, [sp, #4]
    18ca:	3301      	adds	r3, #1
    18cc:	9301      	str	r3, [sp, #4]
    18ce:	4b3b      	ldr	r3, [pc, #236]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    18d0:	681b      	ldr	r3, [r3, #0]
    18d2:	7adb      	ldrb	r3, [r3, #11]
    18d4:	461a      	mov	r2, r3
    18d6:	9b01      	ldr	r3, [sp, #4]
    18d8:	4293      	cmp	r3, r2
    18da:	d3cb      	bcc.n	1874 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    18dc:	4b3c      	ldr	r3, [pc, #240]	; (19d0 <Clock_Ip_DistributePll+0x170>)
    18de:	781b      	ldrb	r3, [r3, #0]
    18e0:	2b00      	cmp	r3, #0
    18e2:	d066      	beq.n	19b2 <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    18e4:	2300      	movs	r3, #0
    18e6:	9301      	str	r3, [sp, #4]
    18e8:	e021      	b.n	192e <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    18ea:	4b34      	ldr	r3, [pc, #208]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    18ec:	681a      	ldr	r2, [r3, #0]
    18ee:	9b01      	ldr	r3, [sp, #4]
    18f0:	334e      	adds	r3, #78	; 0x4e
    18f2:	00db      	lsls	r3, r3, #3
    18f4:	4413      	add	r3, r2
    18f6:	685a      	ldr	r2, [r3, #4]
    18f8:	4932      	ldr	r1, [pc, #200]	; (19c4 <Clock_Ip_DistributePll+0x164>)
    18fa:	4613      	mov	r3, r2
    18fc:	00db      	lsls	r3, r3, #3
    18fe:	4413      	add	r3, r2
    1900:	440b      	add	r3, r1
    1902:	3301      	adds	r3, #1
    1904:	781b      	ldrb	r3, [r3, #0]
    1906:	461a      	mov	r2, r3
    1908:	4b32      	ldr	r3, [pc, #200]	; (19d4 <Clock_Ip_DistributePll+0x174>)
    190a:	5c9b      	ldrb	r3, [r3, r2]
    190c:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    190e:	4a32      	ldr	r2, [pc, #200]	; (19d8 <Clock_Ip_DistributePll+0x178>)
    1910:	9b00      	ldr	r3, [sp, #0]
    1912:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1916:	4a29      	ldr	r2, [pc, #164]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    1918:	6811      	ldr	r1, [r2, #0]
    191a:	9a01      	ldr	r2, [sp, #4]
    191c:	324e      	adds	r2, #78	; 0x4e
    191e:	00d2      	lsls	r2, r2, #3
    1920:	440a      	add	r2, r1
    1922:	3204      	adds	r2, #4
    1924:	4610      	mov	r0, r2
    1926:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    1928:	9b01      	ldr	r3, [sp, #4]
    192a:	3301      	adds	r3, #1
    192c:	9301      	str	r3, [sp, #4]
    192e:	4b23      	ldr	r3, [pc, #140]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    1930:	681b      	ldr	r3, [r3, #0]
    1932:	7c1b      	ldrb	r3, [r3, #16]
    1934:	461a      	mov	r2, r3
    1936:	9b01      	ldr	r3, [sp, #4]
    1938:	4293      	cmp	r3, r2
    193a:	d3d6      	bcc.n	18ea <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    193c:	2300      	movs	r3, #0
    193e:	9301      	str	r3, [sp, #4]
    1940:	e02a      	b.n	1998 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    1942:	4b1e      	ldr	r3, [pc, #120]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    1944:	6819      	ldr	r1, [r3, #0]
    1946:	9a01      	ldr	r2, [sp, #4]
    1948:	4613      	mov	r3, r2
    194a:	009b      	lsls	r3, r3, #2
    194c:	4413      	add	r3, r2
    194e:	009b      	lsls	r3, r3, #2
    1950:	440b      	add	r3, r1
    1952:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    1956:	681a      	ldr	r2, [r3, #0]
    1958:	491a      	ldr	r1, [pc, #104]	; (19c4 <Clock_Ip_DistributePll+0x164>)
    195a:	4613      	mov	r3, r2
    195c:	00db      	lsls	r3, r3, #3
    195e:	4413      	add	r3, r2
    1960:	440b      	add	r3, r1
    1962:	3301      	adds	r3, #1
    1964:	781b      	ldrb	r3, [r3, #0]
    1966:	461a      	mov	r2, r3
    1968:	4b1c      	ldr	r3, [pc, #112]	; (19dc <Clock_Ip_DistributePll+0x17c>)
    196a:	5c9b      	ldrb	r3, [r3, r2]
    196c:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    196e:	4a1c      	ldr	r2, [pc, #112]	; (19e0 <Clock_Ip_DistributePll+0x180>)
    1970:	9b00      	ldr	r3, [sp, #0]
    1972:	011b      	lsls	r3, r3, #4
    1974:	4413      	add	r3, r2
    1976:	330c      	adds	r3, #12
    1978:	6819      	ldr	r1, [r3, #0]
    197a:	4b10      	ldr	r3, [pc, #64]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    197c:	6818      	ldr	r0, [r3, #0]
    197e:	9a01      	ldr	r2, [sp, #4]
    1980:	4613      	mov	r3, r2
    1982:	009b      	lsls	r3, r3, #2
    1984:	4413      	add	r3, r2
    1986:	009b      	lsls	r3, r3, #2
    1988:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    198c:	4403      	add	r3, r0
    198e:	4618      	mov	r0, r3
    1990:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    1992:	9b01      	ldr	r3, [sp, #4]
    1994:	3301      	adds	r3, #1
    1996:	9301      	str	r3, [sp, #4]
    1998:	4b08      	ldr	r3, [pc, #32]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    199a:	681b      	ldr	r3, [r3, #0]
    199c:	7c9b      	ldrb	r3, [r3, #18]
    199e:	461a      	mov	r2, r3
    19a0:	9b01      	ldr	r3, [sp, #4]
    19a2:	4293      	cmp	r3, r2
    19a4:	d3cd      	bcc.n	1942 <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    19a6:	4b05      	ldr	r3, [pc, #20]	; (19bc <Clock_Ip_DistributePll+0x15c>)
    19a8:	681b      	ldr	r3, [r3, #0]
    19aa:	2104      	movs	r1, #4
    19ac:	4618      	mov	r0, r3
    19ae:	f002 fe0b 	bl	45c8 <Clock_Ip_Command>
        }
    }
}
    19b2:	bf00      	nop
    19b4:	b003      	add	sp, #12
    19b6:	f85d fb04 	ldr.w	pc, [sp], #4
    19ba:	bf00      	nop
    19bc:	1fff8b34 	.word	0x1fff8b34
    19c0:	00007158 	.word	0x00007158
    19c4:	00006d0c 	.word	0x00006d0c
    19c8:	00006cdc 	.word	0x00006cdc
    19cc:	00007344 	.word	0x00007344
    19d0:	1fff8b3c 	.word	0x1fff8b3c
    19d4:	00006cac 	.word	0x00006cac
    19d8:	00007294 	.word	0x00007294
    19dc:	00006cfc 	.word	0x00006cfc
    19e0:	00007308 	.word	0x00007308

000019e4 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    19e4:	b500      	push	{lr}
    19e6:	b085      	sub	sp, #20
    19e8:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    19ea:	490c      	ldr	r1, [pc, #48]	; (1a1c <Clock_Ip_DisableClockMonitor+0x38>)
    19ec:	9a01      	ldr	r2, [sp, #4]
    19ee:	4613      	mov	r3, r2
    19f0:	00db      	lsls	r3, r3, #3
    19f2:	4413      	add	r3, r2
    19f4:	440b      	add	r3, r1
    19f6:	3301      	adds	r3, #1
    19f8:	781b      	ldrb	r3, [r3, #0]
    19fa:	461a      	mov	r2, r3
    19fc:	4b08      	ldr	r3, [pc, #32]	; (1a20 <Clock_Ip_DisableClockMonitor+0x3c>)
    19fe:	5c9b      	ldrb	r3, [r3, r2]
    1a00:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    1a02:	4a08      	ldr	r2, [pc, #32]	; (1a24 <Clock_Ip_DisableClockMonitor+0x40>)
    1a04:	9b03      	ldr	r3, [sp, #12]
    1a06:	011b      	lsls	r3, r3, #4
    1a08:	4413      	add	r3, r2
    1a0a:	3308      	adds	r3, #8
    1a0c:	681b      	ldr	r3, [r3, #0]
    1a0e:	9801      	ldr	r0, [sp, #4]
    1a10:	4798      	blx	r3
}
    1a12:	bf00      	nop
    1a14:	b005      	add	sp, #20
    1a16:	f85d fb04 	ldr.w	pc, [sp], #4
    1a1a:	bf00      	nop
    1a1c:	00006d0c 	.word	0x00006d0c
    1a20:	00006cfc 	.word	0x00006cfc
    1a24:	00007308 	.word	0x00007308

00001a28 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    1a28:	b082      	sub	sp, #8
    1a2a:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    1a2c:	4a02      	ldr	r2, [pc, #8]	; (1a38 <Clock_Ip_InstallNotificationsCallback+0x10>)
    1a2e:	9b01      	ldr	r3, [sp, #4]
    1a30:	6013      	str	r3, [r2, #0]
}
    1a32:	bf00      	nop
    1a34:	b002      	add	sp, #8
    1a36:	4770      	bx	lr
    1a38:	1fff8b14 	.word	0x1fff8b14

00001a3c <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    1a3c:	b500      	push	{lr}
    1a3e:	b085      	sub	sp, #20
    1a40:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1a42:	490c      	ldr	r1, [pc, #48]	; (1a74 <Clock_Ip_DisableModuleClock+0x38>)
    1a44:	9a01      	ldr	r2, [sp, #4]
    1a46:	4613      	mov	r3, r2
    1a48:	00db      	lsls	r3, r3, #3
    1a4a:	4413      	add	r3, r2
    1a4c:	440b      	add	r3, r1
    1a4e:	3301      	adds	r3, #1
    1a50:	781b      	ldrb	r3, [r3, #0]
    1a52:	461a      	mov	r2, r3
    1a54:	4b08      	ldr	r3, [pc, #32]	; (1a78 <Clock_Ip_DisableModuleClock+0x3c>)
    1a56:	5c9b      	ldrb	r3, [r3, r2]
    1a58:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    1a5a:	4a08      	ldr	r2, [pc, #32]	; (1a7c <Clock_Ip_DisableModuleClock+0x40>)
    1a5c:	9b03      	ldr	r3, [sp, #12]
    1a5e:	00db      	lsls	r3, r3, #3
    1a60:	4413      	add	r3, r2
    1a62:	685b      	ldr	r3, [r3, #4]
    1a64:	2101      	movs	r1, #1
    1a66:	9801      	ldr	r0, [sp, #4]
    1a68:	4798      	blx	r3
}
    1a6a:	bf00      	nop
    1a6c:	b005      	add	sp, #20
    1a6e:	f85d fb04 	ldr.w	pc, [sp], #4
    1a72:	bf00      	nop
    1a74:	00006d0c 	.word	0x00006d0c
    1a78:	00006cac 	.word	0x00006cac
    1a7c:	00007294 	.word	0x00007294

00001a80 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    1a80:	b500      	push	{lr}
    1a82:	b085      	sub	sp, #20
    1a84:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    1a86:	490c      	ldr	r1, [pc, #48]	; (1ab8 <Clock_Ip_EnableModuleClock+0x38>)
    1a88:	9a01      	ldr	r2, [sp, #4]
    1a8a:	4613      	mov	r3, r2
    1a8c:	00db      	lsls	r3, r3, #3
    1a8e:	4413      	add	r3, r2
    1a90:	440b      	add	r3, r1
    1a92:	3301      	adds	r3, #1
    1a94:	781b      	ldrb	r3, [r3, #0]
    1a96:	461a      	mov	r2, r3
    1a98:	4b08      	ldr	r3, [pc, #32]	; (1abc <Clock_Ip_EnableModuleClock+0x3c>)
    1a9a:	5c9b      	ldrb	r3, [r3, r2]
    1a9c:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    1a9e:	4a08      	ldr	r2, [pc, #32]	; (1ac0 <Clock_Ip_EnableModuleClock+0x40>)
    1aa0:	9b03      	ldr	r3, [sp, #12]
    1aa2:	00db      	lsls	r3, r3, #3
    1aa4:	4413      	add	r3, r2
    1aa6:	685b      	ldr	r3, [r3, #4]
    1aa8:	2100      	movs	r1, #0
    1aaa:	9801      	ldr	r0, [sp, #4]
    1aac:	4798      	blx	r3
}
    1aae:	bf00      	nop
    1ab0:	b005      	add	sp, #20
    1ab2:	f85d fb04 	ldr.w	pc, [sp], #4
    1ab6:	bf00      	nop
    1ab8:	00006d0c 	.word	0x00006d0c
    1abc:	00006cac 	.word	0x00006cac
    1ac0:	00007294 	.word	0x00007294

00001ac4 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    1ac4:	b500      	push	{lr}
    1ac6:	b083      	sub	sp, #12
    1ac8:	9001      	str	r0, [sp, #4]
    1aca:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    1acc:	4b08      	ldr	r3, [pc, #32]	; (1af0 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    1ace:	2200      	movs	r2, #0
    1ad0:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    1ad2:	4b08      	ldr	r3, [pc, #32]	; (1af4 <Clock_Ip_PowerModeChangeNotification+0x30>)
    1ad4:	681b      	ldr	r3, [r3, #0]
    1ad6:	2102      	movs	r1, #2
    1ad8:	4618      	mov	r0, r3
    1ada:	f002 fd75 	bl	45c8 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    1ade:	9900      	ldr	r1, [sp, #0]
    1ae0:	9801      	ldr	r0, [sp, #4]
    1ae2:	f002 fc51 	bl	4388 <Clock_Ip_ClockPowerModeChangeNotification>
}
    1ae6:	bf00      	nop
    1ae8:	b003      	add	sp, #12
    1aea:	f85d fb04 	ldr.w	pc, [sp], #4
    1aee:	bf00      	nop
    1af0:	1fff8b10 	.word	0x1fff8b10
    1af4:	1fff8b34 	.word	0x1fff8b34

00001af8 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    1af8:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    1afa:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    1afe:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    1b00:	4b06      	ldr	r3, [pc, #24]	; (1b1c <Clock_Ip_SetWaitStates+0x24>)
    1b02:	785b      	ldrb	r3, [r3, #1]
    1b04:	2b00      	cmp	r3, #0
    1b06:	d005      	beq.n	1b14 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    1b08:	9b01      	ldr	r3, [sp, #4]
    1b0a:	3b01      	subs	r3, #1
    1b0c:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    1b0e:	9b01      	ldr	r3, [sp, #4]
    1b10:	2b00      	cmp	r3, #0
    1b12:	d1f9      	bne.n	1b08 <Clock_Ip_SetWaitStates+0x10>
    }
}
    1b14:	bf00      	nop
    1b16:	b002      	add	sp, #8
    1b18:	4770      	bx	lr
    1b1a:	bf00      	nop
    1b1c:	1fff8b3c 	.word	0x1fff8b3c

00001b20 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    1b20:	b500      	push	{lr}
    1b22:	b083      	sub	sp, #12
    1b24:	9001      	str	r0, [sp, #4]
    1b26:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    1b28:	4b04      	ldr	r3, [pc, #16]	; (1b3c <Clock_Ip_ReportClockErrors+0x1c>)
    1b2a:	681b      	ldr	r3, [r3, #0]
    1b2c:	9900      	ldr	r1, [sp, #0]
    1b2e:	9801      	ldr	r0, [sp, #4]
    1b30:	4798      	blx	r3
}
    1b32:	bf00      	nop
    1b34:	b003      	add	sp, #12
    1b36:	f85d fb04 	ldr.w	pc, [sp], #4
    1b3a:	bf00      	nop
    1b3c:	1fff8b14 	.word	0x1fff8b14

00001b40 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    1b40:	b500      	push	{lr}
    1b42:	b085      	sub	sp, #20
    1b44:	9003      	str	r0, [sp, #12]
    1b46:	9102      	str	r1, [sp, #8]
    1b48:	9201      	str	r2, [sp, #4]
    1b4a:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    1b4c:	2000      	movs	r0, #0
    1b4e:	f7fe ffd0 	bl	af2 <OsIf_GetCounter>
    1b52:	4602      	mov	r2, r0
    1b54:	9b03      	ldr	r3, [sp, #12]
    1b56:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    1b58:	9b02      	ldr	r3, [sp, #8]
    1b5a:	2200      	movs	r2, #0
    1b5c:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    1b5e:	2100      	movs	r1, #0
    1b60:	9800      	ldr	r0, [sp, #0]
    1b62:	f7ff f812 	bl	b8a <OsIf_MicrosToTicks>
    1b66:	4602      	mov	r2, r0
    1b68:	9b01      	ldr	r3, [sp, #4]
    1b6a:	601a      	str	r2, [r3, #0]
}
    1b6c:	bf00      	nop
    1b6e:	b005      	add	sp, #20
    1b70:	f85d fb04 	ldr.w	pc, [sp], #4

00001b74 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    1b74:	b500      	push	{lr}
    1b76:	b087      	sub	sp, #28
    1b78:	9003      	str	r0, [sp, #12]
    1b7a:	9102      	str	r1, [sp, #8]
    1b7c:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    1b7e:	2300      	movs	r3, #0
    1b80:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    1b84:	2100      	movs	r1, #0
    1b86:	9803      	ldr	r0, [sp, #12]
    1b88:	f7fe ffcc 	bl	b24 <OsIf_GetElapsed>
    1b8c:	4602      	mov	r2, r0
    1b8e:	9b02      	ldr	r3, [sp, #8]
    1b90:	681b      	ldr	r3, [r3, #0]
    1b92:	441a      	add	r2, r3
    1b94:	9b02      	ldr	r3, [sp, #8]
    1b96:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    1b98:	9b02      	ldr	r3, [sp, #8]
    1b9a:	681b      	ldr	r3, [r3, #0]
    1b9c:	9a01      	ldr	r2, [sp, #4]
    1b9e:	429a      	cmp	r2, r3
    1ba0:	d802      	bhi.n	1ba8 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    1ba2:	2301      	movs	r3, #1
    1ba4:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    1ba8:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    1bac:	4618      	mov	r0, r3
    1bae:	b007      	add	sp, #28
    1bb0:	f85d fb04 	ldr.w	pc, [sp], #4

00001bb4 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    1bb4:	b082      	sub	sp, #8
    1bb6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    1bb8:	bf00      	nop
    1bba:	b002      	add	sp, #8
    1bbc:	4770      	bx	lr

00001bbe <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    1bbe:	b500      	push	{lr}
    1bc0:	b083      	sub	sp, #12
    1bc2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1bc4:	9b01      	ldr	r3, [sp, #4]
    1bc6:	2b00      	cmp	r3, #0
    1bc8:	d002      	beq.n	1bd0 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    1bca:	9801      	ldr	r0, [sp, #4]
    1bcc:	f000 f8ad 	bl	1d2a <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1bd0:	bf00      	nop
    1bd2:	b003      	add	sp, #12
    1bd4:	f85d fb04 	ldr.w	pc, [sp], #4

00001bd8 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    1bd8:	b500      	push	{lr}
    1bda:	b083      	sub	sp, #12
    1bdc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1bde:	9b01      	ldr	r3, [sp, #4]
    1be0:	2b00      	cmp	r3, #0
    1be2:	d002      	beq.n	1bea <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    1be4:	9801      	ldr	r0, [sp, #4]
    1be6:	f000 f8cd 	bl	1d84 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1bea:	bf00      	nop
    1bec:	b003      	add	sp, #12
    1bee:	f85d fb04 	ldr.w	pc, [sp], #4

00001bf2 <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1bf2:	b500      	push	{lr}
    1bf4:	b083      	sub	sp, #12
    1bf6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1bf8:	9b01      	ldr	r3, [sp, #4]
    1bfa:	2b00      	cmp	r3, #0
    1bfc:	d002      	beq.n	1c04 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    1bfe:	9801      	ldr	r0, [sp, #4]
    1c00:	f000 f8ee 	bl	1de0 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c04:	bf00      	nop
    1c06:	b003      	add	sp, #12
    1c08:	f85d fb04 	ldr.w	pc, [sp], #4

00001c0c <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1c0c:	b500      	push	{lr}
    1c0e:	b083      	sub	sp, #12
    1c10:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c12:	9b01      	ldr	r3, [sp, #4]
    1c14:	2b00      	cmp	r3, #0
    1c16:	d002      	beq.n	1c1e <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    1c18:	9801      	ldr	r0, [sp, #4]
    1c1a:	f000 f8f9 	bl	1e10 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c1e:	bf00      	nop
    1c20:	b003      	add	sp, #12
    1c22:	f85d fb04 	ldr.w	pc, [sp], #4

00001c26 <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1c26:	b500      	push	{lr}
    1c28:	b083      	sub	sp, #12
    1c2a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c2c:	9b01      	ldr	r3, [sp, #4]
    1c2e:	2b00      	cmp	r3, #0
    1c30:	d002      	beq.n	1c38 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    1c32:	9801      	ldr	r0, [sp, #4]
    1c34:	f000 f904 	bl	1e40 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c38:	bf00      	nop
    1c3a:	b003      	add	sp, #12
    1c3c:	f85d fb04 	ldr.w	pc, [sp], #4

00001c40 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1c40:	b500      	push	{lr}
    1c42:	b083      	sub	sp, #12
    1c44:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c46:	9b01      	ldr	r3, [sp, #4]
    1c48:	2b00      	cmp	r3, #0
    1c4a:	d002      	beq.n	1c52 <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    1c4c:	9801      	ldr	r0, [sp, #4]
    1c4e:	f000 f90f 	bl	1e70 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c52:	bf00      	nop
    1c54:	b003      	add	sp, #12
    1c56:	f85d fb04 	ldr.w	pc, [sp], #4

00001c5a <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1c5a:	b500      	push	{lr}
    1c5c:	b083      	sub	sp, #12
    1c5e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c60:	9b01      	ldr	r3, [sp, #4]
    1c62:	2b00      	cmp	r3, #0
    1c64:	d002      	beq.n	1c6c <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    1c66:	9801      	ldr	r0, [sp, #4]
    1c68:	f000 f91a 	bl	1ea0 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c6c:	bf00      	nop
    1c6e:	b003      	add	sp, #12
    1c70:	f85d fb04 	ldr.w	pc, [sp], #4

00001c74 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1c74:	b500      	push	{lr}
    1c76:	b083      	sub	sp, #12
    1c78:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c7a:	9b01      	ldr	r3, [sp, #4]
    1c7c:	2b00      	cmp	r3, #0
    1c7e:	d002      	beq.n	1c86 <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    1c80:	9801      	ldr	r0, [sp, #4]
    1c82:	f000 f925 	bl	1ed0 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1c86:	bf00      	nop
    1c88:	b003      	add	sp, #12
    1c8a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c8e <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    1c8e:	b500      	push	{lr}
    1c90:	b083      	sub	sp, #12
    1c92:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1c94:	9b01      	ldr	r3, [sp, #4]
    1c96:	2b00      	cmp	r3, #0
    1c98:	d002      	beq.n	1ca0 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    1c9a:	9801      	ldr	r0, [sp, #4]
    1c9c:	f000 f930 	bl	1f00 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1ca0:	bf00      	nop
    1ca2:	b003      	add	sp, #12
    1ca4:	f85d fb04 	ldr.w	pc, [sp], #4

00001ca8 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    1ca8:	b500      	push	{lr}
    1caa:	b083      	sub	sp, #12
    1cac:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1cae:	9b01      	ldr	r3, [sp, #4]
    1cb0:	2b00      	cmp	r3, #0
    1cb2:	d002      	beq.n	1cba <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    1cb4:	9801      	ldr	r0, [sp, #4]
    1cb6:	f000 f93b 	bl	1f30 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1cba:	bf00      	nop
    1cbc:	b003      	add	sp, #12
    1cbe:	f85d fb04 	ldr.w	pc, [sp], #4

00001cc2 <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    1cc2:	b500      	push	{lr}
    1cc4:	b083      	sub	sp, #12
    1cc6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1cc8:	9b01      	ldr	r3, [sp, #4]
    1cca:	2b00      	cmp	r3, #0
    1ccc:	d002      	beq.n	1cd4 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    1cce:	9801      	ldr	r0, [sp, #4]
    1cd0:	f000 f946 	bl	1f60 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1cd4:	bf00      	nop
    1cd6:	b003      	add	sp, #12
    1cd8:	f85d fb04 	ldr.w	pc, [sp], #4

00001cdc <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    1cdc:	b500      	push	{lr}
    1cde:	b083      	sub	sp, #12
    1ce0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1ce2:	9b01      	ldr	r3, [sp, #4]
    1ce4:	2b00      	cmp	r3, #0
    1ce6:	d002      	beq.n	1cee <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    1ce8:	9801      	ldr	r0, [sp, #4]
    1cea:	f000 f951 	bl	1f90 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1cee:	bf00      	nop
    1cf0:	b003      	add	sp, #12
    1cf2:	f85d fb04 	ldr.w	pc, [sp], #4

00001cf6 <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    1cf6:	b500      	push	{lr}
    1cf8:	b083      	sub	sp, #12
    1cfa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1cfc:	9b01      	ldr	r3, [sp, #4]
    1cfe:	2b00      	cmp	r3, #0
    1d00:	d002      	beq.n	1d08 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    1d02:	9801      	ldr	r0, [sp, #4]
    1d04:	f000 f95e 	bl	1fc4 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d08:	bf00      	nop
    1d0a:	b003      	add	sp, #12
    1d0c:	f85d fb04 	ldr.w	pc, [sp], #4

00001d10 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    1d10:	b500      	push	{lr}
    1d12:	b083      	sub	sp, #12
    1d14:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1d16:	9b01      	ldr	r3, [sp, #4]
    1d18:	2b00      	cmp	r3, #0
    1d1a:	d002      	beq.n	1d22 <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    1d1c:	9801      	ldr	r0, [sp, #4]
    1d1e:	f000 f98b 	bl	2038 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1d22:	bf00      	nop
    1d24:	b003      	add	sp, #12
    1d26:	f85d fb04 	ldr.w	pc, [sp], #4

00001d2a <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1d2a:	b086      	sub	sp, #24
    1d2c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    1d2e:	9b01      	ldr	r3, [sp, #4]
    1d30:	681a      	ldr	r2, [r3, #0]
    1d32:	4911      	ldr	r1, [pc, #68]	; (1d78 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    1d34:	4613      	mov	r3, r2
    1d36:	00db      	lsls	r3, r3, #3
    1d38:	4413      	add	r3, r2
    1d3a:	440b      	add	r3, r1
    1d3c:	781b      	ldrb	r3, [r3, #0]
    1d3e:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    1d40:	9b01      	ldr	r3, [sp, #4]
    1d42:	685b      	ldr	r3, [r3, #4]
    1d44:	4a0d      	ldr	r2, [pc, #52]	; (1d7c <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    1d46:	5cd3      	ldrb	r3, [r2, r3]
    1d48:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    1d4a:	4a0d      	ldr	r2, [pc, #52]	; (1d80 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    1d4c:	9b05      	ldr	r3, [sp, #20]
    1d4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1d52:	681b      	ldr	r3, [r3, #0]
    1d54:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    1d56:	9b03      	ldr	r3, [sp, #12]
    1d58:	f023 0307 	bic.w	r3, r3, #7
    1d5c:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    1d5e:	9a03      	ldr	r2, [sp, #12]
    1d60:	9b04      	ldr	r3, [sp, #16]
    1d62:	4313      	orrs	r3, r2
    1d64:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    1d66:	4a06      	ldr	r2, [pc, #24]	; (1d80 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    1d68:	9b05      	ldr	r3, [sp, #20]
    1d6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1d6e:	9a03      	ldr	r2, [sp, #12]
    1d70:	601a      	str	r2, [r3, #0]
}
    1d72:	bf00      	nop
    1d74:	b006      	add	sp, #24
    1d76:	4770      	bx	lr
    1d78:	00006d0c 	.word	0x00006d0c
    1d7c:	00007104 	.word	0x00007104
    1d80:	00007148 	.word	0x00007148

00001d84 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1d84:	b086      	sub	sp, #24
    1d86:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    1d88:	9b01      	ldr	r3, [sp, #4]
    1d8a:	681a      	ldr	r2, [r3, #0]
    1d8c:	4911      	ldr	r1, [pc, #68]	; (1dd4 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    1d8e:	4613      	mov	r3, r2
    1d90:	00db      	lsls	r3, r3, #3
    1d92:	4413      	add	r3, r2
    1d94:	440b      	add	r3, r1
    1d96:	781b      	ldrb	r3, [r3, #0]
    1d98:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    1d9a:	9b01      	ldr	r3, [sp, #4]
    1d9c:	685b      	ldr	r3, [r3, #4]
    1d9e:	4a0e      	ldr	r2, [pc, #56]	; (1dd8 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    1da0:	5cd3      	ldrb	r3, [r2, r3]
    1da2:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    1da4:	4a0d      	ldr	r2, [pc, #52]	; (1ddc <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    1da6:	9b05      	ldr	r3, [sp, #20]
    1da8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1dac:	681b      	ldr	r3, [r3, #0]
    1dae:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    1db0:	9b03      	ldr	r3, [sp, #12]
    1db2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    1db6:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    1db8:	9b04      	ldr	r3, [sp, #16]
    1dba:	021b      	lsls	r3, r3, #8
    1dbc:	9a03      	ldr	r2, [sp, #12]
    1dbe:	4313      	orrs	r3, r2
    1dc0:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    1dc2:	4a06      	ldr	r2, [pc, #24]	; (1ddc <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    1dc4:	9b05      	ldr	r3, [sp, #20]
    1dc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1dca:	9a03      	ldr	r2, [sp, #12]
    1dcc:	601a      	str	r2, [r3, #0]
}
    1dce:	bf00      	nop
    1dd0:	b006      	add	sp, #24
    1dd2:	4770      	bx	lr
    1dd4:	00006d0c 	.word	0x00006d0c
    1dd8:	00007104 	.word	0x00007104
    1ddc:	00007148 	.word	0x00007148

00001de0 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1de0:	b084      	sub	sp, #16
    1de2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1de4:	4b09      	ldr	r3, [pc, #36]	; (1e0c <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    1de6:	695b      	ldr	r3, [r3, #20]
    1de8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    1dea:	9b03      	ldr	r3, [sp, #12]
    1dec:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1df0:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    1df2:	9b01      	ldr	r3, [sp, #4]
    1df4:	685b      	ldr	r3, [r3, #4]
    1df6:	3b01      	subs	r3, #1
    1df8:	041b      	lsls	r3, r3, #16
    1dfa:	9a03      	ldr	r2, [sp, #12]
    1dfc:	4313      	orrs	r3, r2
    1dfe:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1e00:	4a02      	ldr	r2, [pc, #8]	; (1e0c <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    1e02:	9b03      	ldr	r3, [sp, #12]
    1e04:	6153      	str	r3, [r2, #20]
}
    1e06:	bf00      	nop
    1e08:	b004      	add	sp, #16
    1e0a:	4770      	bx	lr
    1e0c:	40064000 	.word	0x40064000

00001e10 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1e10:	b084      	sub	sp, #16
    1e12:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1e14:	4b09      	ldr	r3, [pc, #36]	; (1e3c <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    1e16:	695b      	ldr	r3, [r3, #20]
    1e18:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    1e1a:	9b03      	ldr	r3, [sp, #12]
    1e1c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1e20:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    1e22:	9b01      	ldr	r3, [sp, #4]
    1e24:	685b      	ldr	r3, [r3, #4]
    1e26:	3b01      	subs	r3, #1
    1e28:	011b      	lsls	r3, r3, #4
    1e2a:	9a03      	ldr	r2, [sp, #12]
    1e2c:	4313      	orrs	r3, r2
    1e2e:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1e30:	4a02      	ldr	r2, [pc, #8]	; (1e3c <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    1e32:	9b03      	ldr	r3, [sp, #12]
    1e34:	6153      	str	r3, [r2, #20]
}
    1e36:	bf00      	nop
    1e38:	b004      	add	sp, #16
    1e3a:	4770      	bx	lr
    1e3c:	40064000 	.word	0x40064000

00001e40 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1e40:	b084      	sub	sp, #16
    1e42:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    1e44:	4b09      	ldr	r3, [pc, #36]	; (1e6c <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    1e46:	695b      	ldr	r3, [r3, #20]
    1e48:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    1e4a:	9b03      	ldr	r3, [sp, #12]
    1e4c:	f023 030f 	bic.w	r3, r3, #15
    1e50:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    1e52:	9b01      	ldr	r3, [sp, #4]
    1e54:	685b      	ldr	r3, [r3, #4]
    1e56:	3b01      	subs	r3, #1
    1e58:	9a03      	ldr	r2, [sp, #12]
    1e5a:	4313      	orrs	r3, r2
    1e5c:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    1e5e:	4a03      	ldr	r2, [pc, #12]	; (1e6c <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    1e60:	9b03      	ldr	r3, [sp, #12]
    1e62:	6153      	str	r3, [r2, #20]
}
    1e64:	bf00      	nop
    1e66:	b004      	add	sp, #16
    1e68:	4770      	bx	lr
    1e6a:	bf00      	nop
    1e6c:	40064000 	.word	0x40064000

00001e70 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1e70:	b084      	sub	sp, #16
    1e72:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1e74:	4b09      	ldr	r3, [pc, #36]	; (1e9c <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    1e76:	699b      	ldr	r3, [r3, #24]
    1e78:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    1e7a:	9b03      	ldr	r3, [sp, #12]
    1e7c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1e80:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    1e82:	9b01      	ldr	r3, [sp, #4]
    1e84:	685b      	ldr	r3, [r3, #4]
    1e86:	3b01      	subs	r3, #1
    1e88:	041b      	lsls	r3, r3, #16
    1e8a:	9a03      	ldr	r2, [sp, #12]
    1e8c:	4313      	orrs	r3, r2
    1e8e:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1e90:	4a02      	ldr	r2, [pc, #8]	; (1e9c <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    1e92:	9b03      	ldr	r3, [sp, #12]
    1e94:	6193      	str	r3, [r2, #24]
}
    1e96:	bf00      	nop
    1e98:	b004      	add	sp, #16
    1e9a:	4770      	bx	lr
    1e9c:	40064000 	.word	0x40064000

00001ea0 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1ea0:	b084      	sub	sp, #16
    1ea2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1ea4:	4b09      	ldr	r3, [pc, #36]	; (1ecc <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    1ea6:	699b      	ldr	r3, [r3, #24]
    1ea8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    1eaa:	9b03      	ldr	r3, [sp, #12]
    1eac:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1eb0:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    1eb2:	9b01      	ldr	r3, [sp, #4]
    1eb4:	685b      	ldr	r3, [r3, #4]
    1eb6:	3b01      	subs	r3, #1
    1eb8:	011b      	lsls	r3, r3, #4
    1eba:	9a03      	ldr	r2, [sp, #12]
    1ebc:	4313      	orrs	r3, r2
    1ebe:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1ec0:	4a02      	ldr	r2, [pc, #8]	; (1ecc <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    1ec2:	9b03      	ldr	r3, [sp, #12]
    1ec4:	6193      	str	r3, [r2, #24]
}
    1ec6:	bf00      	nop
    1ec8:	b004      	add	sp, #16
    1eca:	4770      	bx	lr
    1ecc:	40064000 	.word	0x40064000

00001ed0 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1ed0:	b084      	sub	sp, #16
    1ed2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    1ed4:	4b09      	ldr	r3, [pc, #36]	; (1efc <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    1ed6:	699b      	ldr	r3, [r3, #24]
    1ed8:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    1eda:	9b03      	ldr	r3, [sp, #12]
    1edc:	f023 030f 	bic.w	r3, r3, #15
    1ee0:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    1ee2:	9b01      	ldr	r3, [sp, #4]
    1ee4:	685b      	ldr	r3, [r3, #4]
    1ee6:	3b01      	subs	r3, #1
    1ee8:	9a03      	ldr	r2, [sp, #12]
    1eea:	4313      	orrs	r3, r2
    1eec:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    1eee:	4a03      	ldr	r2, [pc, #12]	; (1efc <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    1ef0:	9b03      	ldr	r3, [sp, #12]
    1ef2:	6193      	str	r3, [r2, #24]
}
    1ef4:	bf00      	nop
    1ef6:	b004      	add	sp, #16
    1ef8:	4770      	bx	lr
    1efa:	bf00      	nop
    1efc:	40064000 	.word	0x40064000

00001f00 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f00:	b084      	sub	sp, #16
    1f02:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    1f04:	4b09      	ldr	r3, [pc, #36]	; (1f2c <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    1f06:	69db      	ldr	r3, [r3, #28]
    1f08:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    1f0a:	9b03      	ldr	r3, [sp, #12]
    1f0c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1f10:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    1f12:	9b01      	ldr	r3, [sp, #4]
    1f14:	685b      	ldr	r3, [r3, #4]
    1f16:	3b01      	subs	r3, #1
    1f18:	041b      	lsls	r3, r3, #16
    1f1a:	9a03      	ldr	r2, [sp, #12]
    1f1c:	4313      	orrs	r3, r2
    1f1e:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    1f20:	4a02      	ldr	r2, [pc, #8]	; (1f2c <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    1f22:	9b03      	ldr	r3, [sp, #12]
    1f24:	61d3      	str	r3, [r2, #28]
}
    1f26:	bf00      	nop
    1f28:	b004      	add	sp, #16
    1f2a:	4770      	bx	lr
    1f2c:	40064000 	.word	0x40064000

00001f30 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f30:	b084      	sub	sp, #16
    1f32:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    1f34:	4b09      	ldr	r3, [pc, #36]	; (1f5c <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    1f36:	69db      	ldr	r3, [r3, #28]
    1f38:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    1f3a:	9b03      	ldr	r3, [sp, #12]
    1f3c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1f40:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    1f42:	9b01      	ldr	r3, [sp, #4]
    1f44:	685b      	ldr	r3, [r3, #4]
    1f46:	3b01      	subs	r3, #1
    1f48:	011b      	lsls	r3, r3, #4
    1f4a:	9a03      	ldr	r2, [sp, #12]
    1f4c:	4313      	orrs	r3, r2
    1f4e:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    1f50:	4a02      	ldr	r2, [pc, #8]	; (1f5c <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    1f52:	9b03      	ldr	r3, [sp, #12]
    1f54:	61d3      	str	r3, [r2, #28]
}
    1f56:	bf00      	nop
    1f58:	b004      	add	sp, #16
    1f5a:	4770      	bx	lr
    1f5c:	40064000 	.word	0x40064000

00001f60 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1f60:	b084      	sub	sp, #16
    1f62:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    1f64:	4b09      	ldr	r3, [pc, #36]	; (1f8c <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    1f66:	69db      	ldr	r3, [r3, #28]
    1f68:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    1f6a:	9b03      	ldr	r3, [sp, #12]
    1f6c:	f023 030f 	bic.w	r3, r3, #15
    1f70:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    1f72:	9b01      	ldr	r3, [sp, #4]
    1f74:	685b      	ldr	r3, [r3, #4]
    1f76:	3b01      	subs	r3, #1
    1f78:	9a03      	ldr	r2, [sp, #12]
    1f7a:	4313      	orrs	r3, r2
    1f7c:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    1f7e:	4a03      	ldr	r2, [pc, #12]	; (1f8c <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    1f80:	9b03      	ldr	r3, [sp, #12]
    1f82:	61d3      	str	r3, [r2, #28]
}
    1f84:	bf00      	nop
    1f86:	b004      	add	sp, #16
    1f88:	4770      	bx	lr
    1f8a:	bf00      	nop
    1f8c:	40064000 	.word	0x40064000

00001f90 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    1f90:	b084      	sub	sp, #16
    1f92:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    1f94:	4b0a      	ldr	r3, [pc, #40]	; (1fc0 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    1f96:	685b      	ldr	r3, [r3, #4]
    1f98:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    1f9a:	9b03      	ldr	r3, [sp, #12]
    1f9c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    1fa0:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    1fa2:	9b01      	ldr	r3, [sp, #4]
    1fa4:	685b      	ldr	r3, [r3, #4]
    1fa6:	3b01      	subs	r3, #1
    1fa8:	021b      	lsls	r3, r3, #8
    1faa:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    1fae:	9a03      	ldr	r2, [sp, #12]
    1fb0:	4313      	orrs	r3, r2
    1fb2:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    1fb4:	4a02      	ldr	r2, [pc, #8]	; (1fc0 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    1fb6:	9b03      	ldr	r3, [sp, #12]
    1fb8:	6053      	str	r3, [r2, #4]
}
    1fba:	bf00      	nop
    1fbc:	b004      	add	sp, #16
    1fbe:	4770      	bx	lr
    1fc0:	40048000 	.word	0x40048000

00001fc4 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    1fc4:	b084      	sub	sp, #16
    1fc6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    1fc8:	4919      	ldr	r1, [pc, #100]	; (2030 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    1fca:	9b01      	ldr	r3, [sp, #4]
    1fcc:	681a      	ldr	r2, [r3, #0]
    1fce:	4819      	ldr	r0, [pc, #100]	; (2034 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    1fd0:	4613      	mov	r3, r2
    1fd2:	00db      	lsls	r3, r3, #3
    1fd4:	4413      	add	r3, r2
    1fd6:	4403      	add	r3, r0
    1fd8:	3305      	adds	r3, #5
    1fda:	781b      	ldrb	r3, [r3, #0]
    1fdc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    1fe0:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    1fe2:	9b03      	ldr	r3, [sp, #12]
    1fe4:	f023 030f 	bic.w	r3, r3, #15
    1fe8:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    1fea:	9b01      	ldr	r3, [sp, #4]
    1fec:	685b      	ldr	r3, [r3, #4]
    1fee:	3b01      	subs	r3, #1
    1ff0:	f003 0307 	and.w	r3, r3, #7
    1ff4:	9a03      	ldr	r2, [sp, #12]
    1ff6:	4313      	orrs	r3, r2
    1ff8:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    1ffa:	9b01      	ldr	r3, [sp, #4]
    1ffc:	7a1b      	ldrb	r3, [r3, #8]
    1ffe:	3b01      	subs	r3, #1
    2000:	00db      	lsls	r3, r3, #3
    2002:	f003 0308 	and.w	r3, r3, #8
    2006:	9a03      	ldr	r2, [sp, #12]
    2008:	4313      	orrs	r3, r2
    200a:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    200c:	4908      	ldr	r1, [pc, #32]	; (2030 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    200e:	9b01      	ldr	r3, [sp, #4]
    2010:	681a      	ldr	r2, [r3, #0]
    2012:	4808      	ldr	r0, [pc, #32]	; (2034 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    2014:	4613      	mov	r3, r2
    2016:	00db      	lsls	r3, r3, #3
    2018:	4413      	add	r3, r2
    201a:	4403      	add	r3, r0
    201c:	3305      	adds	r3, #5
    201e:	781b      	ldrb	r3, [r3, #0]
    2020:	461a      	mov	r2, r3
    2022:	9b03      	ldr	r3, [sp, #12]
    2024:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    2028:	bf00      	nop
    202a:	b004      	add	sp, #16
    202c:	4770      	bx	lr
    202e:	bf00      	nop
    2030:	40065000 	.word	0x40065000
    2034:	00006d0c 	.word	0x00006d0c

00002038 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2038:	b084      	sub	sp, #16
    203a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    203c:	4b10      	ldr	r3, [pc, #64]	; (2080 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    203e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2040:	4a0f      	ldr	r2, [pc, #60]	; (2080 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2042:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2046:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    2048:	4b0d      	ldr	r3, [pc, #52]	; (2080 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    204a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    204c:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    204e:	9b03      	ldr	r3, [sp, #12]
    2050:	f023 030f 	bic.w	r3, r3, #15
    2054:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    2056:	9b01      	ldr	r3, [sp, #4]
    2058:	685b      	ldr	r3, [r3, #4]
    205a:	3b01      	subs	r3, #1
    205c:	005b      	lsls	r3, r3, #1
    205e:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    2062:	9b01      	ldr	r3, [sp, #4]
    2064:	7a1b      	ldrb	r3, [r3, #8]
    2066:	3b01      	subs	r3, #1
    2068:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    206c:	4313      	orrs	r3, r2
    206e:	9a03      	ldr	r2, [sp, #12]
    2070:	4313      	orrs	r3, r2
    2072:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    2074:	4a02      	ldr	r2, [pc, #8]	; (2080 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    2076:	9b03      	ldr	r3, [sp, #12]
    2078:	6693      	str	r3, [r2, #104]	; 0x68
}
    207a:	bf00      	nop
    207c:	b004      	add	sp, #16
    207e:	4770      	bx	lr
    2080:	40048000 	.word	0x40048000

00002084 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    2084:	b082      	sub	sp, #8
    2086:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2088:	bf00      	nop
    208a:	b002      	add	sp, #8
    208c:	4770      	bx	lr
	...

00002090 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    2090:	b082      	sub	sp, #8
    2092:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2094:	bf00      	nop
    2096:	b002      	add	sp, #8
    2098:	4770      	bx	lr

0000209a <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    209a:	b082      	sub	sp, #8
    209c:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    209e:	bf00      	nop
    20a0:	b002      	add	sp, #8
    20a2:	4770      	bx	lr

000020a4 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    20a4:	b500      	push	{lr}
    20a6:	b083      	sub	sp, #12
    20a8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    20aa:	9b01      	ldr	r3, [sp, #4]
    20ac:	2b00      	cmp	r3, #0
    20ae:	d002      	beq.n	20b6 <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    20b0:	9801      	ldr	r0, [sp, #4]
    20b2:	f000 f86a 	bl	218a <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    20b6:	bf00      	nop
    20b8:	b003      	add	sp, #12
    20ba:	f85d fb04 	ldr.w	pc, [sp], #4

000020be <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    20be:	b500      	push	{lr}
    20c0:	b083      	sub	sp, #12
    20c2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    20c4:	9b01      	ldr	r3, [sp, #4]
    20c6:	2b00      	cmp	r3, #0
    20c8:	d002      	beq.n	20d0 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    20ca:	9801      	ldr	r0, [sp, #4]
    20cc:	f000 f884 	bl	21d8 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    20d0:	bf00      	nop
    20d2:	b003      	add	sp, #12
    20d4:	f85d fb04 	ldr.w	pc, [sp], #4

000020d8 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    20d8:	b500      	push	{lr}
    20da:	b089      	sub	sp, #36	; 0x24
    20dc:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    20de:	2300      	movs	r3, #0
    20e0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    20e4:	9b01      	ldr	r3, [sp, #4]
    20e6:	2b00      	cmp	r3, #0
    20e8:	d031      	beq.n	214e <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    20ea:	4b1b      	ldr	r3, [pc, #108]	; (2158 <Clock_Ip_CompleteSOSC+0x80>)
    20ec:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    20f0:	f003 0301 	and.w	r3, r3, #1
    20f4:	2b00      	cmp	r3, #0
    20f6:	d02a      	beq.n	214e <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    20f8:	aa03      	add	r2, sp, #12
    20fa:	a904      	add	r1, sp, #16
    20fc:	a805      	add	r0, sp, #20
    20fe:	f24c 3350 	movw	r3, #50000	; 0xc350
    2102:	f7ff fd1d 	bl	1b40 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    2106:	4b14      	ldr	r3, [pc, #80]	; (2158 <Clock_Ip_CompleteSOSC+0x80>)
    2108:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    210c:	0e1b      	lsrs	r3, r3, #24
    210e:	f003 0301 	and.w	r3, r3, #1
    2112:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2114:	9a03      	ldr	r2, [sp, #12]
    2116:	a904      	add	r1, sp, #16
    2118:	ab05      	add	r3, sp, #20
    211a:	4618      	mov	r0, r3
    211c:	f7ff fd2a 	bl	1b74 <Clock_Ip_TimeoutExpired>
    2120:	4603      	mov	r3, r0
    2122:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    2126:	9b06      	ldr	r3, [sp, #24]
    2128:	2b00      	cmp	r3, #0
    212a:	d106      	bne.n	213a <Clock_Ip_CompleteSOSC+0x62>
    212c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2130:	f083 0301 	eor.w	r3, r3, #1
    2134:	b2db      	uxtb	r3, r3
    2136:	2b00      	cmp	r3, #0
    2138:	d1e5      	bne.n	2106 <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    213a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    213e:	2b00      	cmp	r3, #0
    2140:	d005      	beq.n	214e <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2142:	9b01      	ldr	r3, [sp, #4]
    2144:	681b      	ldr	r3, [r3, #0]
    2146:	4619      	mov	r1, r3
    2148:	2001      	movs	r0, #1
    214a:	f7ff fce9 	bl	1b20 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    214e:	bf00      	nop
    2150:	b009      	add	sp, #36	; 0x24
    2152:	f85d fb04 	ldr.w	pc, [sp], #4
    2156:	bf00      	nop
    2158:	40064000 	.word	0x40064000

0000215c <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    215c:	b500      	push	{lr}
    215e:	b083      	sub	sp, #12
    2160:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    2162:	9801      	ldr	r0, [sp, #4]
    2164:	f000 f8c0 	bl	22e8 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2168:	bf00      	nop
    216a:	b003      	add	sp, #12
    216c:	f85d fb04 	ldr.w	pc, [sp], #4

00002170 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    2170:	b500      	push	{lr}
    2172:	b083      	sub	sp, #12
    2174:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2176:	9b01      	ldr	r3, [sp, #4]
    2178:	2b00      	cmp	r3, #0
    217a:	d002      	beq.n	2182 <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    217c:	9801      	ldr	r0, [sp, #4]
    217e:	f000 f8c3 	bl	2308 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2182:	bf00      	nop
    2184:	b003      	add	sp, #12
    2186:	f85d fb04 	ldr.w	pc, [sp], #4

0000218a <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    218a:	b082      	sub	sp, #8
    218c:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    218e:	4b11      	ldr	r3, [pc, #68]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2190:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2194:	4a0f      	ldr	r2, [pc, #60]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    2196:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    219a:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    219e:	4b0d      	ldr	r3, [pc, #52]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21a0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    21a4:	4a0b      	ldr	r2, [pc, #44]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21a6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    21aa:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    21ae:	4b09      	ldr	r3, [pc, #36]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21b0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    21b4:	4a07      	ldr	r2, [pc, #28]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21b6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    21ba:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    21be:	4b05      	ldr	r3, [pc, #20]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21c0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    21c4:	4a03      	ldr	r2, [pc, #12]	; (21d4 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    21c6:	f023 0301 	bic.w	r3, r3, #1
    21ca:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    21ce:	bf00      	nop
    21d0:	b002      	add	sp, #8
    21d2:	4770      	bx	lr
    21d4:	40064000 	.word	0x40064000

000021d8 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    21d8:	b082      	sub	sp, #8
    21da:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    21dc:	9b01      	ldr	r3, [sp, #4]
    21de:	891b      	ldrh	r3, [r3, #8]
    21e0:	2b01      	cmp	r3, #1
    21e2:	d174      	bne.n	22ce <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    21e4:	9b01      	ldr	r3, [sp, #4]
    21e6:	7bdb      	ldrb	r3, [r3, #15]
    21e8:	2b00      	cmp	r3, #0
    21ea:	d002      	beq.n	21f2 <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    21ec:	2b01      	cmp	r3, #1
    21ee:	d009      	beq.n	2204 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    21f0:	e011      	b.n	2216 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    21f2:	4b39      	ldr	r3, [pc, #228]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    21f4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    21f8:	4a37      	ldr	r2, [pc, #220]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    21fa:	f023 0308 	bic.w	r3, r3, #8
    21fe:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2202:	e008      	b.n	2216 <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    2204:	4b34      	ldr	r3, [pc, #208]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2206:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    220a:	4a33      	ldr	r2, [pc, #204]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    220c:	f043 0308 	orr.w	r3, r3, #8
    2210:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2214:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    2216:	4b30      	ldr	r3, [pc, #192]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2218:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    221c:	4a2e      	ldr	r2, [pc, #184]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    221e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    2222:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    2226:	9b01      	ldr	r3, [sp, #4]
    2228:	685b      	ldr	r3, [r3, #4]
    222a:	4a2c      	ldr	r2, [pc, #176]	; (22dc <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    222c:	4293      	cmp	r3, r2
    222e:	d90d      	bls.n	224c <Clock_Ip_SetSOSC_TrustedCall+0x74>
    2230:	9b01      	ldr	r3, [sp, #4]
    2232:	685b      	ldr	r3, [r3, #4]
    2234:	4a2a      	ldr	r2, [pc, #168]	; (22e0 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    2236:	4293      	cmp	r3, r2
    2238:	d208      	bcs.n	224c <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    223a:	4b27      	ldr	r3, [pc, #156]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    223c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2240:	4a25      	ldr	r2, [pc, #148]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2242:	f043 0320 	orr.w	r3, r3, #32
    2246:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    224a:	e007      	b.n	225c <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    224c:	4b22      	ldr	r3, [pc, #136]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    224e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2252:	4a21      	ldr	r2, [pc, #132]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2254:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    2258:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    225c:	9b01      	ldr	r3, [sp, #4]
    225e:	7b1b      	ldrb	r3, [r3, #12]
    2260:	2b00      	cmp	r3, #0
    2262:	d108      	bne.n	2276 <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    2264:	4b1c      	ldr	r3, [pc, #112]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2266:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    226a:	4a1b      	ldr	r2, [pc, #108]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    226c:	f043 0304 	orr.w	r3, r3, #4
    2270:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    2274:	e007      	b.n	2286 <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    2276:	4b18      	ldr	r3, [pc, #96]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2278:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    227c:	4a16      	ldr	r2, [pc, #88]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    227e:	f023 0304 	bic.w	r3, r3, #4
    2282:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    2286:	9b01      	ldr	r3, [sp, #4]
    2288:	7c1b      	ldrb	r3, [r3, #16]
    228a:	2b02      	cmp	r3, #2
    228c:	d011      	beq.n	22b2 <Clock_Ip_SetSOSC_TrustedCall+0xda>
    228e:	2b02      	cmp	r3, #2
    2290:	dc14      	bgt.n	22bc <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    2292:	2b00      	cmp	r3, #0
    2294:	d002      	beq.n	229c <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    2296:	2b01      	cmp	r3, #1
    2298:	d005      	beq.n	22a6 <Clock_Ip_SetSOSC_TrustedCall+0xce>
    229a:	e00f      	b.n	22bc <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    229c:	4b0e      	ldr	r3, [pc, #56]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    229e:	2201      	movs	r2, #1
    22a0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    22a4:	e014      	b.n	22d0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    22a6:	4b0c      	ldr	r3, [pc, #48]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    22a8:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    22ac:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    22b0:	e00e      	b.n	22d0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    22b2:	4b09      	ldr	r3, [pc, #36]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    22b4:	4a0b      	ldr	r2, [pc, #44]	; (22e4 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    22b6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    22ba:	e009      	b.n	22d0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    22bc:	4b06      	ldr	r3, [pc, #24]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    22be:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22c2:	4a05      	ldr	r2, [pc, #20]	; (22d8 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    22c4:	f043 0301 	orr.w	r3, r3, #1
    22c8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    22cc:	e000      	b.n	22d0 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    22ce:	bf00      	nop
}
    22d0:	bf00      	nop
    22d2:	b002      	add	sp, #8
    22d4:	4770      	bx	lr
    22d6:	bf00      	nop
    22d8:	40064000 	.word	0x40064000
    22dc:	003d08ff 	.word	0x003d08ff
    22e0:	007a1200 	.word	0x007a1200
    22e4:	00030001 	.word	0x00030001

000022e8 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    22e8:	b082      	sub	sp, #8
    22ea:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    22ec:	4b05      	ldr	r3, [pc, #20]	; (2304 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    22ee:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    22f2:	4a04      	ldr	r2, [pc, #16]	; (2304 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    22f4:	f023 0301 	bic.w	r3, r3, #1
    22f8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    22fc:	bf00      	nop
    22fe:	b002      	add	sp, #8
    2300:	4770      	bx	lr
    2302:	bf00      	nop
    2304:	40064000 	.word	0x40064000

00002308 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    2308:	b082      	sub	sp, #8
    230a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    230c:	9b01      	ldr	r3, [sp, #4]
    230e:	891b      	ldrh	r3, [r3, #8]
    2310:	2b01      	cmp	r3, #1
    2312:	d107      	bne.n	2324 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2314:	4b05      	ldr	r3, [pc, #20]	; (232c <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2316:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    231a:	4a04      	ldr	r2, [pc, #16]	; (232c <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    231c:	f043 0301 	orr.w	r3, r3, #1
    2320:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    2324:	bf00      	nop
    2326:	b002      	add	sp, #8
    2328:	4770      	bx	lr
    232a:	bf00      	nop
    232c:	40064000 	.word	0x40064000

00002330 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    2330:	b082      	sub	sp, #8
    2332:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2334:	bf00      	nop
    2336:	b002      	add	sp, #8
    2338:	4770      	bx	lr

0000233a <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    233a:	b082      	sub	sp, #8
    233c:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    233e:	2300      	movs	r3, #0
}
    2340:	4618      	mov	r0, r3
    2342:	b002      	add	sp, #8
    2344:	4770      	bx	lr

00002346 <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    2346:	b082      	sub	sp, #8
    2348:	9001      	str	r0, [sp, #4]
    234a:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    234c:	bf00      	nop
    234e:	b002      	add	sp, #8
    2350:	4770      	bx	lr
	...

00002354 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    2354:	b082      	sub	sp, #8
    2356:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2358:	bf00      	nop
    235a:	b002      	add	sp, #8
    235c:	4770      	bx	lr

0000235e <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    235e:	b082      	sub	sp, #8
    2360:	9001      	str	r0, [sp, #4]
    2362:	460b      	mov	r3, r1
    2364:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    2368:	bf00      	nop
    236a:	b002      	add	sp, #8
    236c:	4770      	bx	lr

0000236e <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    236e:	b500      	push	{lr}
    2370:	b083      	sub	sp, #12
    2372:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2374:	9b01      	ldr	r3, [sp, #4]
    2376:	2b00      	cmp	r3, #0
    2378:	d002      	beq.n	2380 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    237a:	9801      	ldr	r0, [sp, #4]
    237c:	f000 f8e7 	bl	254e <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2380:	bf00      	nop
    2382:	b003      	add	sp, #12
    2384:	f85d fb04 	ldr.w	pc, [sp], #4

00002388 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2388:	b500      	push	{lr}
    238a:	b085      	sub	sp, #20
    238c:	9001      	str	r0, [sp, #4]
    238e:	460b      	mov	r3, r1
    2390:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2394:	9b01      	ldr	r3, [sp, #4]
    2396:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2398:	f89d 3003 	ldrb.w	r3, [sp, #3]
    239c:	2b00      	cmp	r3, #0
    239e:	d003      	beq.n	23a8 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    23a0:	2300      	movs	r3, #0
    23a2:	f8ad 300c 	strh.w	r3, [sp, #12]
    23a6:	e002      	b.n	23ae <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    23a8:	2301      	movs	r3, #1
    23aa:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    23ae:	ab02      	add	r3, sp, #8
    23b0:	4618      	mov	r0, r3
    23b2:	f7ff ffdc 	bl	236e <Clock_Ip_ClockSetSimLPO1KEnable>
}
    23b6:	bf00      	nop
    23b8:	b005      	add	sp, #20
    23ba:	f85d fb04 	ldr.w	pc, [sp], #4

000023be <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    23be:	b500      	push	{lr}
    23c0:	b083      	sub	sp, #12
    23c2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    23c4:	9b01      	ldr	r3, [sp, #4]
    23c6:	2b00      	cmp	r3, #0
    23c8:	d002      	beq.n	23d0 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    23ca:	9801      	ldr	r0, [sp, #4]
    23cc:	f000 f8d6 	bl	257c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    23d0:	bf00      	nop
    23d2:	b003      	add	sp, #12
    23d4:	f85d fb04 	ldr.w	pc, [sp], #4

000023d8 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    23d8:	b500      	push	{lr}
    23da:	b085      	sub	sp, #20
    23dc:	9001      	str	r0, [sp, #4]
    23de:	460b      	mov	r3, r1
    23e0:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    23e4:	9b01      	ldr	r3, [sp, #4]
    23e6:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    23e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    23ec:	2b00      	cmp	r3, #0
    23ee:	d003      	beq.n	23f8 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    23f0:	2300      	movs	r3, #0
    23f2:	f8ad 300c 	strh.w	r3, [sp, #12]
    23f6:	e002      	b.n	23fe <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    23f8:	2301      	movs	r3, #1
    23fa:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    23fe:	ab02      	add	r3, sp, #8
    2400:	4618      	mov	r0, r3
    2402:	f7ff ffdc 	bl	23be <Clock_Ip_ClockSetSimLPO32KEnable>
}
    2406:	bf00      	nop
    2408:	b005      	add	sp, #20
    240a:	f85d fb04 	ldr.w	pc, [sp], #4

0000240e <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    240e:	b500      	push	{lr}
    2410:	b083      	sub	sp, #12
    2412:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2414:	9b01      	ldr	r3, [sp, #4]
    2416:	2b00      	cmp	r3, #0
    2418:	d002      	beq.n	2420 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    241a:	9801      	ldr	r0, [sp, #4]
    241c:	f000 f8c6 	bl	25ac <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2420:	bf00      	nop
    2422:	b003      	add	sp, #12
    2424:	f85d fb04 	ldr.w	pc, [sp], #4

00002428 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2428:	b500      	push	{lr}
    242a:	b085      	sub	sp, #20
    242c:	9001      	str	r0, [sp, #4]
    242e:	460b      	mov	r3, r1
    2430:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2434:	9b01      	ldr	r3, [sp, #4]
    2436:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2438:	f89d 3003 	ldrb.w	r3, [sp, #3]
    243c:	2b00      	cmp	r3, #0
    243e:	d003      	beq.n	2448 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    2440:	2300      	movs	r3, #0
    2442:	f8ad 300c 	strh.w	r3, [sp, #12]
    2446:	e002      	b.n	244e <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2448:	2301      	movs	r3, #1
    244a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    244e:	ab02      	add	r3, sp, #8
    2450:	4618      	mov	r0, r3
    2452:	f7ff ffdc 	bl	240e <Clock_Ip_ClockSetSimClkoutEnable>
}
    2456:	bf00      	nop
    2458:	b005      	add	sp, #20
    245a:	f85d fb04 	ldr.w	pc, [sp], #4

0000245e <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    245e:	b500      	push	{lr}
    2460:	b083      	sub	sp, #12
    2462:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2464:	9b01      	ldr	r3, [sp, #4]
    2466:	2b00      	cmp	r3, #0
    2468:	d002      	beq.n	2470 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    246a:	9801      	ldr	r0, [sp, #4]
    246c:	f000 f8b6 	bl	25dc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2470:	bf00      	nop
    2472:	b003      	add	sp, #12
    2474:	f85d fb04 	ldr.w	pc, [sp], #4

00002478 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2478:	b500      	push	{lr}
    247a:	b085      	sub	sp, #20
    247c:	9001      	str	r0, [sp, #4]
    247e:	460b      	mov	r3, r1
    2480:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2484:	9b01      	ldr	r3, [sp, #4]
    2486:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2488:	f89d 3003 	ldrb.w	r3, [sp, #3]
    248c:	2b00      	cmp	r3, #0
    248e:	d003      	beq.n	2498 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    2490:	2300      	movs	r3, #0
    2492:	f8ad 300c 	strh.w	r3, [sp, #12]
    2496:	e002      	b.n	249e <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2498:	2301      	movs	r3, #1
    249a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    249e:	ab02      	add	r3, sp, #8
    24a0:	4618      	mov	r0, r3
    24a2:	f7ff ffdc 	bl	245e <Clock_Ip_ClockSetPccCgcEnable>
}
    24a6:	bf00      	nop
    24a8:	b005      	add	sp, #20
    24aa:	f85d fb04 	ldr.w	pc, [sp], #4

000024ae <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    24ae:	b500      	push	{lr}
    24b0:	b083      	sub	sp, #12
    24b2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    24b4:	9b01      	ldr	r3, [sp, #4]
    24b6:	2b00      	cmp	r3, #0
    24b8:	d002      	beq.n	24c0 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    24ba:	9801      	ldr	r0, [sp, #4]
    24bc:	f000 f8bc 	bl	2638 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    24c0:	bf00      	nop
    24c2:	b003      	add	sp, #12
    24c4:	f85d fb04 	ldr.w	pc, [sp], #4

000024c8 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    24c8:	b500      	push	{lr}
    24ca:	b085      	sub	sp, #20
    24cc:	9001      	str	r0, [sp, #4]
    24ce:	460b      	mov	r3, r1
    24d0:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    24d4:	9b01      	ldr	r3, [sp, #4]
    24d6:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    24d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    24dc:	2b00      	cmp	r3, #0
    24de:	d003      	beq.n	24e8 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    24e0:	2300      	movs	r3, #0
    24e2:	f8ad 300c 	strh.w	r3, [sp, #12]
    24e6:	e002      	b.n	24ee <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    24e8:	2301      	movs	r3, #1
    24ea:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    24ee:	ab02      	add	r3, sp, #8
    24f0:	4618      	mov	r0, r3
    24f2:	f7ff ffdc 	bl	24ae <Clock_Ip_ClockSetSimGate>
}
    24f6:	bf00      	nop
    24f8:	b005      	add	sp, #20
    24fa:	f85d fb04 	ldr.w	pc, [sp], #4

000024fe <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    24fe:	b500      	push	{lr}
    2500:	b083      	sub	sp, #12
    2502:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2504:	9b01      	ldr	r3, [sp, #4]
    2506:	2b00      	cmp	r3, #0
    2508:	d002      	beq.n	2510 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    250a:	9801      	ldr	r0, [sp, #4]
    250c:	f000 f8c0 	bl	2690 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2510:	bf00      	nop
    2512:	b003      	add	sp, #12
    2514:	f85d fb04 	ldr.w	pc, [sp], #4

00002518 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    2518:	b500      	push	{lr}
    251a:	b085      	sub	sp, #20
    251c:	9001      	str	r0, [sp, #4]
    251e:	460b      	mov	r3, r1
    2520:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    2524:	9b01      	ldr	r3, [sp, #4]
    2526:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    2528:	f89d 3003 	ldrb.w	r3, [sp, #3]
    252c:	2b00      	cmp	r3, #0
    252e:	d003      	beq.n	2538 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    2530:	2300      	movs	r3, #0
    2532:	f8ad 300c 	strh.w	r3, [sp, #12]
    2536:	e002      	b.n	253e <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    2538:	2301      	movs	r3, #1
    253a:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    253e:	ab02      	add	r3, sp, #8
    2540:	4618      	mov	r0, r3
    2542:	f7ff ffdc 	bl	24fe <Clock_Ip_ClockSetSimTraceEnable>
}
    2546:	bf00      	nop
    2548:	b005      	add	sp, #20
    254a:	f85d fb04 	ldr.w	pc, [sp], #4

0000254e <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    254e:	b084      	sub	sp, #16
    2550:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2552:	4b09      	ldr	r3, [pc, #36]	; (2578 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    2554:	691b      	ldr	r3, [r3, #16]
    2556:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    2558:	9b03      	ldr	r3, [sp, #12]
    255a:	f023 0301 	bic.w	r3, r3, #1
    255e:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    2560:	9b01      	ldr	r3, [sp, #4]
    2562:	889b      	ldrh	r3, [r3, #4]
    2564:	461a      	mov	r2, r3
    2566:	9b03      	ldr	r3, [sp, #12]
    2568:	4313      	orrs	r3, r2
    256a:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    256c:	4a02      	ldr	r2, [pc, #8]	; (2578 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    256e:	9b03      	ldr	r3, [sp, #12]
    2570:	6113      	str	r3, [r2, #16]
}
    2572:	bf00      	nop
    2574:	b004      	add	sp, #16
    2576:	4770      	bx	lr
    2578:	40048000 	.word	0x40048000

0000257c <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    257c:	b084      	sub	sp, #16
    257e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    2580:	4b09      	ldr	r3, [pc, #36]	; (25a8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    2582:	691b      	ldr	r3, [r3, #16]
    2584:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    2586:	9b03      	ldr	r3, [sp, #12]
    2588:	f023 0302 	bic.w	r3, r3, #2
    258c:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    258e:	9b01      	ldr	r3, [sp, #4]
    2590:	889b      	ldrh	r3, [r3, #4]
    2592:	005b      	lsls	r3, r3, #1
    2594:	9a03      	ldr	r2, [sp, #12]
    2596:	4313      	orrs	r3, r2
    2598:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    259a:	4a03      	ldr	r2, [pc, #12]	; (25a8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    259c:	9b03      	ldr	r3, [sp, #12]
    259e:	6113      	str	r3, [r2, #16]
}
    25a0:	bf00      	nop
    25a2:	b004      	add	sp, #16
    25a4:	4770      	bx	lr
    25a6:	bf00      	nop
    25a8:	40048000 	.word	0x40048000

000025ac <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    25ac:	b084      	sub	sp, #16
    25ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    25b0:	4b09      	ldr	r3, [pc, #36]	; (25d8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    25b2:	685b      	ldr	r3, [r3, #4]
    25b4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    25b6:	9b03      	ldr	r3, [sp, #12]
    25b8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    25bc:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    25be:	9b01      	ldr	r3, [sp, #4]
    25c0:	889b      	ldrh	r3, [r3, #4]
    25c2:	02db      	lsls	r3, r3, #11
    25c4:	9a03      	ldr	r2, [sp, #12]
    25c6:	4313      	orrs	r3, r2
    25c8:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    25ca:	4a03      	ldr	r2, [pc, #12]	; (25d8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    25cc:	9b03      	ldr	r3, [sp, #12]
    25ce:	6053      	str	r3, [r2, #4]
}
    25d0:	bf00      	nop
    25d2:	b004      	add	sp, #16
    25d4:	4770      	bx	lr
    25d6:	bf00      	nop
    25d8:	40048000 	.word	0x40048000

000025dc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    25dc:	b084      	sub	sp, #16
    25de:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    25e0:	4913      	ldr	r1, [pc, #76]	; (2630 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    25e2:	9b01      	ldr	r3, [sp, #4]
    25e4:	681a      	ldr	r2, [r3, #0]
    25e6:	4813      	ldr	r0, [pc, #76]	; (2634 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    25e8:	4613      	mov	r3, r2
    25ea:	00db      	lsls	r3, r3, #3
    25ec:	4413      	add	r3, r2
    25ee:	4403      	add	r3, r0
    25f0:	3306      	adds	r3, #6
    25f2:	781b      	ldrb	r3, [r3, #0]
    25f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    25f8:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    25fa:	9b03      	ldr	r3, [sp, #12]
    25fc:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    2600:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    2602:	9b01      	ldr	r3, [sp, #4]
    2604:	889b      	ldrh	r3, [r3, #4]
    2606:	079b      	lsls	r3, r3, #30
    2608:	9a03      	ldr	r2, [sp, #12]
    260a:	4313      	orrs	r3, r2
    260c:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    260e:	4908      	ldr	r1, [pc, #32]	; (2630 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    2610:	9b01      	ldr	r3, [sp, #4]
    2612:	681a      	ldr	r2, [r3, #0]
    2614:	4807      	ldr	r0, [pc, #28]	; (2634 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    2616:	4613      	mov	r3, r2
    2618:	00db      	lsls	r3, r3, #3
    261a:	4413      	add	r3, r2
    261c:	4403      	add	r3, r0
    261e:	3306      	adds	r3, #6
    2620:	781b      	ldrb	r3, [r3, #0]
    2622:	461a      	mov	r2, r3
    2624:	9b03      	ldr	r3, [sp, #12]
    2626:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    262a:	bf00      	nop
    262c:	b004      	add	sp, #16
    262e:	4770      	bx	lr
    2630:	40065000 	.word	0x40065000
    2634:	00006d0c 	.word	0x00006d0c

00002638 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2638:	b086      	sub	sp, #24
    263a:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    263c:	9b01      	ldr	r3, [sp, #4]
    263e:	889b      	ldrh	r3, [r3, #4]
    2640:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    2642:	9b01      	ldr	r3, [sp, #4]
    2644:	681a      	ldr	r2, [r3, #0]
    2646:	4910      	ldr	r1, [pc, #64]	; (2688 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    2648:	4613      	mov	r3, r2
    264a:	00db      	lsls	r3, r3, #3
    264c:	4413      	add	r3, r2
    264e:	440b      	add	r3, r1
    2650:	3306      	adds	r3, #6
    2652:	781b      	ldrb	r3, [r3, #0]
    2654:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    2656:	4b0d      	ldr	r3, [pc, #52]	; (268c <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    2658:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    265a:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    265c:	2201      	movs	r2, #1
    265e:	9b04      	ldr	r3, [sp, #16]
    2660:	fa02 f303 	lsl.w	r3, r2, r3
    2664:	43db      	mvns	r3, r3
    2666:	9a03      	ldr	r2, [sp, #12]
    2668:	4013      	ands	r3, r2
    266a:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    266c:	9a05      	ldr	r2, [sp, #20]
    266e:	9b04      	ldr	r3, [sp, #16]
    2670:	fa02 f303 	lsl.w	r3, r2, r3
    2674:	9a03      	ldr	r2, [sp, #12]
    2676:	4313      	orrs	r3, r2
    2678:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    267a:	4a04      	ldr	r2, [pc, #16]	; (268c <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    267c:	9b03      	ldr	r3, [sp, #12]
    267e:	6413      	str	r3, [r2, #64]	; 0x40
}
    2680:	bf00      	nop
    2682:	b006      	add	sp, #24
    2684:	4770      	bx	lr
    2686:	bf00      	nop
    2688:	00006d0c 	.word	0x00006d0c
    268c:	40048000 	.word	0x40048000

00002690 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    2690:	b084      	sub	sp, #16
    2692:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    2694:	4b0a      	ldr	r3, [pc, #40]	; (26c0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    2696:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2698:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    269a:	9b01      	ldr	r3, [sp, #4]
    269c:	889b      	ldrh	r3, [r3, #4]
    269e:	2b01      	cmp	r3, #1
    26a0:	d104      	bne.n	26ac <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    26a2:	9b03      	ldr	r3, [sp, #12]
    26a4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    26a8:	9303      	str	r3, [sp, #12]
    26aa:	e003      	b.n	26b4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    26ac:	9b03      	ldr	r3, [sp, #12]
    26ae:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    26b2:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    26b4:	4a02      	ldr	r2, [pc, #8]	; (26c0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    26b6:	9b03      	ldr	r3, [sp, #12]
    26b8:	6693      	str	r3, [r2, #104]	; 0x68
}
    26ba:	bf00      	nop
    26bc:	b004      	add	sp, #16
    26be:	4770      	bx	lr
    26c0:	40048000 	.word	0x40048000

000026c4 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    26c4:	b082      	sub	sp, #8
    26c6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    26c8:	bf00      	nop
    26ca:	b002      	add	sp, #8
    26cc:	4770      	bx	lr

000026ce <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    26ce:	b082      	sub	sp, #8
    26d0:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    26d2:	bf00      	nop
    26d4:	b002      	add	sp, #8
    26d6:	4770      	bx	lr

000026d8 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    26d8:	b500      	push	{lr}
    26da:	b083      	sub	sp, #12
    26dc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    26de:	9b01      	ldr	r3, [sp, #4]
    26e0:	2b00      	cmp	r3, #0
    26e2:	d002      	beq.n	26ea <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    26e4:	9801      	ldr	r0, [sp, #4]
    26e6:	f000 f8d1 	bl	288c <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    26ea:	bf00      	nop
    26ec:	b003      	add	sp, #12
    26ee:	f85d fb04 	ldr.w	pc, [sp], #4

000026f2 <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    26f2:	b500      	push	{lr}
    26f4:	b083      	sub	sp, #12
    26f6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    26f8:	9b01      	ldr	r3, [sp, #4]
    26fa:	2b00      	cmp	r3, #0
    26fc:	d002      	beq.n	2704 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    26fe:	9801      	ldr	r0, [sp, #4]
    2700:	f000 f950 	bl	29a4 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2704:	bf00      	nop
    2706:	b003      	add	sp, #12
    2708:	f85d fb04 	ldr.w	pc, [sp], #4

0000270c <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    270c:	b500      	push	{lr}
    270e:	b083      	sub	sp, #12
    2710:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    2712:	9801      	ldr	r0, [sp, #4]
    2714:	f000 f98e 	bl	2a34 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2718:	bf00      	nop
    271a:	b003      	add	sp, #12
    271c:	f85d fb04 	ldr.w	pc, [sp], #4

00002720 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    2720:	b500      	push	{lr}
    2722:	b083      	sub	sp, #12
    2724:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2726:	9b01      	ldr	r3, [sp, #4]
    2728:	2b00      	cmp	r3, #0
    272a:	d002      	beq.n	2732 <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    272c:	9801      	ldr	r0, [sp, #4]
    272e:	f000 f999 	bl	2a64 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2732:	bf00      	nop
    2734:	b003      	add	sp, #12
    2736:	f85d fb04 	ldr.w	pc, [sp], #4

0000273a <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    273a:	b500      	push	{lr}
    273c:	b083      	sub	sp, #12
    273e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2740:	9b01      	ldr	r3, [sp, #4]
    2742:	2b00      	cmp	r3, #0
    2744:	d002      	beq.n	274c <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    2746:	9801      	ldr	r0, [sp, #4]
    2748:	f000 f9b0 	bl	2aac <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    274c:	bf00      	nop
    274e:	b003      	add	sp, #12
    2750:	f85d fb04 	ldr.w	pc, [sp], #4

00002754 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    2754:	b500      	push	{lr}
    2756:	b083      	sub	sp, #12
    2758:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    275a:	9801      	ldr	r0, [sp, #4]
    275c:	f000 f9ba 	bl	2ad4 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2760:	bf00      	nop
    2762:	b003      	add	sp, #12
    2764:	f85d fb04 	ldr.w	pc, [sp], #4

00002768 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2768:	b500      	push	{lr}
    276a:	b083      	sub	sp, #12
    276c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    276e:	9b01      	ldr	r3, [sp, #4]
    2770:	2b00      	cmp	r3, #0
    2772:	d002      	beq.n	277a <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    2774:	9801      	ldr	r0, [sp, #4]
    2776:	f000 f9bd 	bl	2af4 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    277a:	bf00      	nop
    277c:	b003      	add	sp, #12
    277e:	f85d fb04 	ldr.w	pc, [sp], #4

00002782 <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    2782:	b500      	push	{lr}
    2784:	b083      	sub	sp, #12
    2786:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2788:	9b01      	ldr	r3, [sp, #4]
    278a:	2b00      	cmp	r3, #0
    278c:	d002      	beq.n	2794 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    278e:	9801      	ldr	r0, [sp, #4]
    2790:	f000 f9d4 	bl	2b3c <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2794:	bf00      	nop
    2796:	b003      	add	sp, #12
    2798:	f85d fb04 	ldr.w	pc, [sp], #4

0000279c <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    279c:	b500      	push	{lr}
    279e:	b083      	sub	sp, #12
    27a0:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    27a2:	9801      	ldr	r0, [sp, #4]
    27a4:	f000 f9de 	bl	2b64 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    27a8:	bf00      	nop
    27aa:	b003      	add	sp, #12
    27ac:	f85d fb04 	ldr.w	pc, [sp], #4

000027b0 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    27b0:	b500      	push	{lr}
    27b2:	b089      	sub	sp, #36	; 0x24
    27b4:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    27b6:	2300      	movs	r3, #0
    27b8:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    27bc:	4b20      	ldr	r3, [pc, #128]	; (2840 <SetInputSouceSytemClock+0x90>)
    27be:	695b      	ldr	r3, [r3, #20]
    27c0:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    27c2:	9b06      	ldr	r3, [sp, #24]
    27c4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    27c8:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    27ca:	9b01      	ldr	r3, [sp, #4]
    27cc:	061b      	lsls	r3, r3, #24
    27ce:	9a06      	ldr	r2, [sp, #24]
    27d0:	4313      	orrs	r3, r2
    27d2:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    27d4:	4a1a      	ldr	r2, [pc, #104]	; (2840 <SetInputSouceSytemClock+0x90>)
    27d6:	9b06      	ldr	r3, [sp, #24]
    27d8:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    27da:	aa02      	add	r2, sp, #8
    27dc:	a903      	add	r1, sp, #12
    27de:	a804      	add	r0, sp, #16
    27e0:	f24c 3350 	movw	r3, #50000	; 0xc350
    27e4:	f7ff f9ac 	bl	1b40 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    27e8:	4b15      	ldr	r3, [pc, #84]	; (2840 <SetInputSouceSytemClock+0x90>)
    27ea:	691b      	ldr	r3, [r3, #16]
    27ec:	0e1b      	lsrs	r3, r3, #24
    27ee:	f003 030f 	and.w	r3, r3, #15
    27f2:	9a01      	ldr	r2, [sp, #4]
    27f4:	429a      	cmp	r2, r3
    27f6:	bf0c      	ite	eq
    27f8:	2301      	moveq	r3, #1
    27fa:	2300      	movne	r3, #0
    27fc:	b2db      	uxtb	r3, r3
    27fe:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2800:	9a02      	ldr	r2, [sp, #8]
    2802:	a903      	add	r1, sp, #12
    2804:	ab04      	add	r3, sp, #16
    2806:	4618      	mov	r0, r3
    2808:	f7ff f9b4 	bl	1b74 <Clock_Ip_TimeoutExpired>
    280c:	4603      	mov	r3, r0
    280e:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    2812:	9b05      	ldr	r3, [sp, #20]
    2814:	2b00      	cmp	r3, #0
    2816:	d106      	bne.n	2826 <SetInputSouceSytemClock+0x76>
    2818:	f89d 301f 	ldrb.w	r3, [sp, #31]
    281c:	f083 0301 	eor.w	r3, r3, #1
    2820:	b2db      	uxtb	r3, r3
    2822:	2b00      	cmp	r3, #0
    2824:	d1e0      	bne.n	27e8 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    2826:	f89d 301f 	ldrb.w	r3, [sp, #31]
    282a:	2b00      	cmp	r3, #0
    282c:	d003      	beq.n	2836 <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    282e:	2105      	movs	r1, #5
    2830:	2001      	movs	r0, #1
    2832:	f7ff f975 	bl	1b20 <Clock_Ip_ReportClockErrors>
    }
}
    2836:	bf00      	nop
    2838:	b009      	add	sp, #36	; 0x24
    283a:	f85d fb04 	ldr.w	pc, [sp], #4
    283e:	bf00      	nop
    2840:	40064000 	.word	0x40064000

00002844 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    2844:	b500      	push	{lr}
    2846:	b083      	sub	sp, #12
    2848:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    284a:	9b01      	ldr	r3, [sp, #4]
    284c:	2b00      	cmp	r3, #0
    284e:	d002      	beq.n	2856 <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    2850:	9801      	ldr	r0, [sp, #4]
    2852:	f000 f997 	bl	2b84 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2856:	bf00      	nop
    2858:	b003      	add	sp, #12
    285a:	f85d fb04 	ldr.w	pc, [sp], #4

0000285e <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    285e:	b500      	push	{lr}
    2860:	b083      	sub	sp, #12
    2862:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2864:	9b01      	ldr	r3, [sp, #4]
    2866:	2b00      	cmp	r3, #0
    2868:	d002      	beq.n	2870 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    286a:	9801      	ldr	r0, [sp, #4]
    286c:	f000 fa7e 	bl	2d6c <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2870:	bf00      	nop
    2872:	b003      	add	sp, #12
    2874:	f85d fb04 	ldr.w	pc, [sp], #4

00002878 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    2878:	b500      	push	{lr}
    287a:	b083      	sub	sp, #12
    287c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    287e:	9801      	ldr	r0, [sp, #4]
    2880:	f000 fab8 	bl	2df4 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2884:	bf00      	nop
    2886:	b003      	add	sp, #12
    2888:	f85d fb04 	ldr.w	pc, [sp], #4

0000288c <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    288c:	b500      	push	{lr}
    288e:	b08b      	sub	sp, #44	; 0x2c
    2890:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2892:	2300      	movs	r3, #0
    2894:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    2898:	9b01      	ldr	r3, [sp, #4]
    289a:	2b00      	cmp	r3, #0
    289c:	d10b      	bne.n	28b6 <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    289e:	2305      	movs	r3, #5
    28a0:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    28a2:	2301      	movs	r3, #1
    28a4:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    28a8:	2301      	movs	r3, #1
    28aa:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    28ae:	2301      	movs	r3, #1
    28b0:	f88d 3010 	strb.w	r3, [sp, #16]
    28b4:	e00e      	b.n	28d4 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    28b6:	9b01      	ldr	r3, [sp, #4]
    28b8:	681b      	ldr	r3, [r3, #0]
    28ba:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    28bc:	9b01      	ldr	r3, [sp, #4]
    28be:	79db      	ldrb	r3, [r3, #7]
    28c0:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    28c4:	9b01      	ldr	r3, [sp, #4]
    28c6:	889b      	ldrh	r3, [r3, #4]
    28c8:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    28cc:	9b01      	ldr	r3, [sp, #4]
    28ce:	7a1b      	ldrb	r3, [r3, #8]
    28d0:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    28d4:	4b32      	ldr	r3, [pc, #200]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28d6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    28da:	4a31      	ldr	r2, [pc, #196]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28dc:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    28e0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    28e4:	4b2e      	ldr	r3, [pc, #184]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28e6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    28ea:	4a2d      	ldr	r2, [pc, #180]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28ec:	f023 0301 	bic.w	r3, r3, #1
    28f0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    28f4:	4b2a      	ldr	r3, [pc, #168]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28f6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    28fa:	4a29      	ldr	r2, [pc, #164]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    28fc:	f023 0304 	bic.w	r3, r3, #4
    2900:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    2904:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    2908:	2b01      	cmp	r3, #1
    290a:	d144      	bne.n	2996 <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    290c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2910:	4a23      	ldr	r2, [pc, #140]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2912:	f003 0301 	and.w	r3, r3, #1
    2916:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    291a:	4b21      	ldr	r3, [pc, #132]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    291c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2920:	4a1f      	ldr	r2, [pc, #124]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2922:	f043 0301 	orr.w	r3, r3, #1
    2926:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    292a:	4b1d      	ldr	r3, [pc, #116]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    292c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2930:	f89d 3010 	ldrb.w	r3, [sp, #16]
    2934:	009b      	lsls	r3, r3, #2
    2936:	f003 0304 	and.w	r3, r3, #4
    293a:	4919      	ldr	r1, [pc, #100]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    293c:	4313      	orrs	r3, r2
    293e:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2942:	aa05      	add	r2, sp, #20
    2944:	a906      	add	r1, sp, #24
    2946:	a807      	add	r0, sp, #28
    2948:	f24c 3350 	movw	r3, #50000	; 0xc350
    294c:	f7ff f8f8 	bl	1b40 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    2950:	4b13      	ldr	r3, [pc, #76]	; (29a0 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    2952:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2956:	0e1b      	lsrs	r3, r3, #24
    2958:	f003 0301 	and.w	r3, r3, #1
    295c:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    295e:	9a05      	ldr	r2, [sp, #20]
    2960:	a906      	add	r1, sp, #24
    2962:	ab07      	add	r3, sp, #28
    2964:	4618      	mov	r0, r3
    2966:	f7ff f905 	bl	1b74 <Clock_Ip_TimeoutExpired>
    296a:	4603      	mov	r3, r0
    296c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2970:	9b08      	ldr	r3, [sp, #32]
    2972:	2b00      	cmp	r3, #0
    2974:	d106      	bne.n	2984 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    2976:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    297a:	f083 0301 	eor.w	r3, r3, #1
    297e:	b2db      	uxtb	r3, r3
    2980:	2b00      	cmp	r3, #0
    2982:	d1e5      	bne.n	2950 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    2984:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2988:	2b00      	cmp	r3, #0
    298a:	d004      	beq.n	2996 <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    298c:	9b02      	ldr	r3, [sp, #8]
    298e:	4619      	mov	r1, r3
    2990:	2001      	movs	r0, #1
    2992:	f7ff f8c5 	bl	1b20 <Clock_Ip_ReportClockErrors>
        }
    }
}
    2996:	bf00      	nop
    2998:	b00b      	add	sp, #44	; 0x2c
    299a:	f85d fb04 	ldr.w	pc, [sp], #4
    299e:	bf00      	nop
    29a0:	40064000 	.word	0x40064000

000029a4 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    29a4:	b500      	push	{lr}
    29a6:	b089      	sub	sp, #36	; 0x24
    29a8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    29aa:	2300      	movs	r3, #0
    29ac:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    29b0:	4b1f      	ldr	r3, [pc, #124]	; (2a30 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    29b2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    29b6:	4a1e      	ldr	r2, [pc, #120]	; (2a30 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    29b8:	f043 0301 	orr.w	r3, r3, #1
    29bc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    29c0:	4b1b      	ldr	r3, [pc, #108]	; (2a30 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    29c2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    29c6:	4a1a      	ldr	r2, [pc, #104]	; (2a30 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    29c8:	f043 0304 	orr.w	r3, r3, #4
    29cc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    29d0:	aa03      	add	r2, sp, #12
    29d2:	a904      	add	r1, sp, #16
    29d4:	a805      	add	r0, sp, #20
    29d6:	f24c 3350 	movw	r3, #50000	; 0xc350
    29da:	f7ff f8b1 	bl	1b40 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    29de:	4b14      	ldr	r3, [pc, #80]	; (2a30 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    29e0:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    29e4:	0e1b      	lsrs	r3, r3, #24
    29e6:	f003 0301 	and.w	r3, r3, #1
    29ea:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    29ec:	9a03      	ldr	r2, [sp, #12]
    29ee:	a904      	add	r1, sp, #16
    29f0:	ab05      	add	r3, sp, #20
    29f2:	4618      	mov	r0, r3
    29f4:	f7ff f8be 	bl	1b74 <Clock_Ip_TimeoutExpired>
    29f8:	4603      	mov	r3, r0
    29fa:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    29fe:	9b06      	ldr	r3, [sp, #24]
    2a00:	2b00      	cmp	r3, #0
    2a02:	d106      	bne.n	2a12 <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    2a04:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2a08:	f083 0301 	eor.w	r3, r3, #1
    2a0c:	b2db      	uxtb	r3, r3
    2a0e:	2b00      	cmp	r3, #0
    2a10:	d1e5      	bne.n	29de <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    2a12:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2a16:	2b00      	cmp	r3, #0
    2a18:	d005      	beq.n	2a26 <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2a1a:	9b01      	ldr	r3, [sp, #4]
    2a1c:	681b      	ldr	r3, [r3, #0]
    2a1e:	4619      	mov	r1, r3
    2a20:	2001      	movs	r0, #1
    2a22:	f7ff f87d 	bl	1b20 <Clock_Ip_ReportClockErrors>
    }
}
    2a26:	bf00      	nop
    2a28:	b009      	add	sp, #36	; 0x24
    2a2a:	f85d fb04 	ldr.w	pc, [sp], #4
    2a2e:	bf00      	nop
    2a30:	40064000 	.word	0x40064000

00002a34 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    2a34:	b082      	sub	sp, #8
    2a36:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    2a38:	4b09      	ldr	r3, [pc, #36]	; (2a60 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2a3a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a3e:	4a08      	ldr	r2, [pc, #32]	; (2a60 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2a40:	f023 0301 	bic.w	r3, r3, #1
    2a44:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2a48:	4b05      	ldr	r3, [pc, #20]	; (2a60 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2a4a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a4e:	4a04      	ldr	r2, [pc, #16]	; (2a60 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    2a50:	f023 0304 	bic.w	r3, r3, #4
    2a54:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2a58:	bf00      	nop
    2a5a:	b002      	add	sp, #8
    2a5c:	4770      	bx	lr
    2a5e:	bf00      	nop
    2a60:	40064000 	.word	0x40064000

00002a64 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2a64:	b082      	sub	sp, #8
    2a66:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2a68:	4b0f      	ldr	r3, [pc, #60]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a6a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a6e:	4a0e      	ldr	r2, [pc, #56]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a70:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2a74:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2a78:	4b0b      	ldr	r3, [pc, #44]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a7a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2a7e:	4a0a      	ldr	r2, [pc, #40]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a80:	f023 0304 	bic.w	r3, r3, #4
    2a84:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    2a88:	4b07      	ldr	r3, [pc, #28]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a8a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2a8e:	9b01      	ldr	r3, [sp, #4]
    2a90:	7a1b      	ldrb	r3, [r3, #8]
    2a92:	009b      	lsls	r3, r3, #2
    2a94:	f003 0304 	and.w	r3, r3, #4
    2a98:	4903      	ldr	r1, [pc, #12]	; (2aa8 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    2a9a:	4313      	orrs	r3, r2
    2a9c:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    2aa0:	bf00      	nop
    2aa2:	b002      	add	sp, #8
    2aa4:	4770      	bx	lr
    2aa6:	bf00      	nop
    2aa8:	40064000 	.word	0x40064000

00002aac <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2aac:	b082      	sub	sp, #8
    2aae:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2ab0:	9b01      	ldr	r3, [sp, #4]
    2ab2:	889b      	ldrh	r3, [r3, #4]
    2ab4:	2b01      	cmp	r3, #1
    2ab6:	d107      	bne.n	2ac8 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    2ab8:	4b05      	ldr	r3, [pc, #20]	; (2ad0 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    2aba:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2abe:	4a04      	ldr	r2, [pc, #16]	; (2ad0 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    2ac0:	f043 0304 	orr.w	r3, r3, #4
    2ac4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    2ac8:	bf00      	nop
    2aca:	b002      	add	sp, #8
    2acc:	4770      	bx	lr
    2ace:	bf00      	nop
    2ad0:	40064000 	.word	0x40064000

00002ad4 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    2ad4:	b082      	sub	sp, #8
    2ad6:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    2ad8:	4b05      	ldr	r3, [pc, #20]	; (2af0 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    2ada:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2ade:	4a04      	ldr	r2, [pc, #16]	; (2af0 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    2ae0:	f023 0304 	bic.w	r3, r3, #4
    2ae4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2ae8:	bf00      	nop
    2aea:	b002      	add	sp, #8
    2aec:	4770      	bx	lr
    2aee:	bf00      	nop
    2af0:	40064000 	.word	0x40064000

00002af4 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2af4:	b082      	sub	sp, #8
    2af6:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    2af8:	4b0f      	ldr	r3, [pc, #60]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2afa:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2afe:	4a0e      	ldr	r2, [pc, #56]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2b00:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2b04:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    2b08:	4b0b      	ldr	r3, [pc, #44]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2b0a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b0e:	4a0a      	ldr	r2, [pc, #40]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2b10:	f023 0302 	bic.w	r3, r3, #2
    2b14:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    2b18:	4b07      	ldr	r3, [pc, #28]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2b1a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    2b1e:	9b01      	ldr	r3, [sp, #4]
    2b20:	7a5b      	ldrb	r3, [r3, #9]
    2b22:	005b      	lsls	r3, r3, #1
    2b24:	f003 0302 	and.w	r3, r3, #2
    2b28:	4903      	ldr	r1, [pc, #12]	; (2b38 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    2b2a:	4313      	orrs	r3, r2
    2b2c:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    2b30:	bf00      	nop
    2b32:	b002      	add	sp, #8
    2b34:	4770      	bx	lr
    2b36:	bf00      	nop
    2b38:	40064000 	.word	0x40064000

00002b3c <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2b3c:	b082      	sub	sp, #8
    2b3e:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2b40:	9b01      	ldr	r3, [sp, #4]
    2b42:	889b      	ldrh	r3, [r3, #4]
    2b44:	2b01      	cmp	r3, #1
    2b46:	d107      	bne.n	2b58 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    2b48:	4b05      	ldr	r3, [pc, #20]	; (2b60 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    2b4a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b4e:	4a04      	ldr	r2, [pc, #16]	; (2b60 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    2b50:	f043 0302 	orr.w	r3, r3, #2
    2b54:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    2b58:	bf00      	nop
    2b5a:	b002      	add	sp, #8
    2b5c:	4770      	bx	lr
    2b5e:	bf00      	nop
    2b60:	40064000 	.word	0x40064000

00002b64 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    2b64:	b082      	sub	sp, #8
    2b66:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    2b68:	4b05      	ldr	r3, [pc, #20]	; (2b80 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    2b6a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2b6e:	4a04      	ldr	r2, [pc, #16]	; (2b80 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    2b70:	f023 0302 	bic.w	r3, r3, #2
    2b74:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    2b78:	bf00      	nop
    2b7a:	b002      	add	sp, #8
    2b7c:	4770      	bx	lr
    2b7e:	bf00      	nop
    2b80:	40064000 	.word	0x40064000

00002b84 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2b84:	b500      	push	{lr}
    2b86:	b08b      	sub	sp, #44	; 0x2c
    2b88:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2b8a:	9b01      	ldr	r3, [sp, #4]
    2b8c:	681a      	ldr	r2, [r3, #0]
    2b8e:	4975      	ldr	r1, [pc, #468]	; (2d64 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    2b90:	4613      	mov	r3, r2
    2b92:	00db      	lsls	r3, r3, #3
    2b94:	4413      	add	r3, r2
    2b96:	440b      	add	r3, r1
    2b98:	781b      	ldrb	r3, [r3, #0]
    2b9a:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    2b9c:	2300      	movs	r3, #0
    2b9e:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    2ba2:	2300      	movs	r3, #0
    2ba4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    2ba8:	4b6f      	ldr	r3, [pc, #444]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2baa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2bae:	4a6e      	ldr	r2, [pc, #440]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2bb0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2bb4:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    2bb8:	4b6b      	ldr	r3, [pc, #428]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2bba:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2bbe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    2bc2:	2b00      	cmp	r3, #0
    2bc4:	d07d      	beq.n	2cc2 <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    2bc6:	9b01      	ldr	r3, [sp, #4]
    2bc8:	79db      	ldrb	r3, [r3, #7]
    2bca:	461a      	mov	r2, r3
    2bcc:	4b66      	ldr	r3, [pc, #408]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2bce:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    2bd2:	f003 0303 	and.w	r3, r3, #3
    2bd6:	429a      	cmp	r2, r3
    2bd8:	d10b      	bne.n	2bf2 <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    2bda:	9b01      	ldr	r3, [sp, #4]
    2bdc:	799b      	ldrb	r3, [r3, #6]
    2bde:	461a      	mov	r2, r3
    2be0:	4b61      	ldr	r3, [pc, #388]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2be2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2be6:	08db      	lsrs	r3, r3, #3
    2be8:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    2bec:	429a      	cmp	r2, r3
    2bee:	f000 80b4 	beq.w	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    2bf2:	4b5d      	ldr	r3, [pc, #372]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2bf4:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    2bf8:	f003 0301 	and.w	r3, r3, #1
    2bfc:	2b00      	cmp	r3, #0
    2bfe:	d105      	bne.n	2c0c <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    2c00:	2301      	movs	r3, #1
    2c02:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    2c06:	2000      	movs	r0, #0
    2c08:	f7ff fd66 	bl	26d8 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    2c0c:	2002      	movs	r0, #2
    2c0e:	f7ff fdcf 	bl	27b0 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    2c12:	4b55      	ldr	r3, [pc, #340]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c14:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2c18:	4a53      	ldr	r2, [pc, #332]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c1a:	f023 0301 	bic.w	r3, r3, #1
    2c1e:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    2c22:	9b01      	ldr	r3, [sp, #4]
    2c24:	889b      	ldrh	r3, [r3, #4]
    2c26:	2b01      	cmp	r3, #1
    2c28:	f040 8097 	bne.w	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    2c2c:	9b01      	ldr	r3, [sp, #4]
    2c2e:	79db      	ldrb	r3, [r3, #7]
    2c30:	4a4d      	ldr	r2, [pc, #308]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c32:	f003 0303 	and.w	r3, r3, #3
    2c36:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    2c3a:	4b4b      	ldr	r3, [pc, #300]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c3c:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    2c40:	9b01      	ldr	r3, [sp, #4]
    2c42:	799b      	ldrb	r3, [r3, #6]
    2c44:	00db      	lsls	r3, r3, #3
    2c46:	f003 0308 	and.w	r3, r3, #8
    2c4a:	4313      	orrs	r3, r2
    2c4c:	4a46      	ldr	r2, [pc, #280]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c4e:	f043 0301 	orr.w	r3, r3, #1
    2c52:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2c56:	aa03      	add	r2, sp, #12
    2c58:	a904      	add	r1, sp, #16
    2c5a:	a805      	add	r0, sp, #20
    2c5c:	f24c 3350 	movw	r3, #50000	; 0xc350
    2c60:	f7fe ff6e 	bl	1b40 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2c64:	4b40      	ldr	r3, [pc, #256]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2c66:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2c6a:	0e1b      	lsrs	r3, r3, #24
    2c6c:	f003 0301 	and.w	r3, r3, #1
    2c70:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2c72:	9a03      	ldr	r2, [sp, #12]
    2c74:	a904      	add	r1, sp, #16
    2c76:	ab05      	add	r3, sp, #20
    2c78:	4618      	mov	r0, r3
    2c7a:	f7fe ff7b 	bl	1b74 <Clock_Ip_TimeoutExpired>
    2c7e:	4603      	mov	r3, r0
    2c80:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2c84:	9b06      	ldr	r3, [sp, #24]
    2c86:	2b00      	cmp	r3, #0
    2c88:	d106      	bne.n	2c98 <Clock_Ip_SetFirc_TrustedCall+0x114>
    2c8a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2c8e:	f083 0301 	eor.w	r3, r3, #1
    2c92:	b2db      	uxtb	r3, r3
    2c94:	2b00      	cmp	r3, #0
    2c96:	d1e5      	bne.n	2c64 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    2c98:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2c9c:	2b00      	cmp	r3, #0
    2c9e:	d005      	beq.n	2cac <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2ca0:	9b01      	ldr	r3, [sp, #4]
    2ca2:	681b      	ldr	r3, [r3, #0]
    2ca4:	4619      	mov	r1, r3
    2ca6:	2001      	movs	r0, #1
    2ca8:	f7fe ff3a 	bl	1b20 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    2cac:	2003      	movs	r0, #3
    2cae:	f7ff fd7f 	bl	27b0 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    2cb2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2cb6:	2b00      	cmp	r3, #0
    2cb8:	d04f      	beq.n	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    2cba:	2002      	movs	r0, #2
    2cbc:	f7ff fd26 	bl	270c <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    2cc0:	e04b      	b.n	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    2cc2:	4b29      	ldr	r3, [pc, #164]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cc4:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2cc8:	4a27      	ldr	r2, [pc, #156]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cca:	f023 0301 	bic.w	r3, r3, #1
    2cce:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    2cd2:	9b01      	ldr	r3, [sp, #4]
    2cd4:	889b      	ldrh	r3, [r3, #4]
    2cd6:	2b01      	cmp	r3, #1
    2cd8:	d13f      	bne.n	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    2cda:	9b01      	ldr	r3, [sp, #4]
    2cdc:	79db      	ldrb	r3, [r3, #7]
    2cde:	4a22      	ldr	r2, [pc, #136]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2ce0:	f003 0303 	and.w	r3, r3, #3
    2ce4:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    2ce8:	4b1f      	ldr	r3, [pc, #124]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cea:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    2cee:	9b01      	ldr	r3, [sp, #4]
    2cf0:	799b      	ldrb	r3, [r3, #6]
    2cf2:	00db      	lsls	r3, r3, #3
    2cf4:	f003 0308 	and.w	r3, r3, #8
    2cf8:	4313      	orrs	r3, r2
    2cfa:	4a1b      	ldr	r2, [pc, #108]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2cfc:	f043 0301 	orr.w	r3, r3, #1
    2d00:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2d04:	aa03      	add	r2, sp, #12
    2d06:	a904      	add	r1, sp, #16
    2d08:	a805      	add	r0, sp, #20
    2d0a:	f24c 3350 	movw	r3, #50000	; 0xc350
    2d0e:	f7fe ff17 	bl	1b40 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2d12:	4b15      	ldr	r3, [pc, #84]	; (2d68 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    2d14:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2d18:	0e1b      	lsrs	r3, r3, #24
    2d1a:	f003 0301 	and.w	r3, r3, #1
    2d1e:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2d20:	9a03      	ldr	r2, [sp, #12]
    2d22:	a904      	add	r1, sp, #16
    2d24:	ab05      	add	r3, sp, #20
    2d26:	4618      	mov	r0, r3
    2d28:	f7fe ff24 	bl	1b74 <Clock_Ip_TimeoutExpired>
    2d2c:	4603      	mov	r3, r0
    2d2e:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2d32:	9b06      	ldr	r3, [sp, #24]
    2d34:	2b00      	cmp	r3, #0
    2d36:	d106      	bne.n	2d46 <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    2d38:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d3c:	f083 0301 	eor.w	r3, r3, #1
    2d40:	b2db      	uxtb	r3, r3
    2d42:	2b00      	cmp	r3, #0
    2d44:	d1e5      	bne.n	2d12 <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    2d46:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2d4a:	2b00      	cmp	r3, #0
    2d4c:	d005      	beq.n	2d5a <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2d4e:	9b01      	ldr	r3, [sp, #4]
    2d50:	681b      	ldr	r3, [r3, #0]
    2d52:	4619      	mov	r1, r3
    2d54:	2001      	movs	r0, #1
    2d56:	f7fe fee3 	bl	1b20 <Clock_Ip_ReportClockErrors>
}
    2d5a:	bf00      	nop
    2d5c:	b00b      	add	sp, #44	; 0x2c
    2d5e:	f85d fb04 	ldr.w	pc, [sp], #4
    2d62:	bf00      	nop
    2d64:	00006d0c 	.word	0x00006d0c
    2d68:	40064000 	.word	0x40064000

00002d6c <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    2d6c:	b500      	push	{lr}
    2d6e:	b089      	sub	sp, #36	; 0x24
    2d70:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2d72:	2300      	movs	r3, #0
    2d74:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    2d78:	9b01      	ldr	r3, [sp, #4]
    2d7a:	889b      	ldrh	r3, [r3, #4]
    2d7c:	2b01      	cmp	r3, #1
    2d7e:	d132      	bne.n	2de6 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    2d80:	4b1b      	ldr	r3, [pc, #108]	; (2df0 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2d82:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2d86:	4a1a      	ldr	r2, [pc, #104]	; (2df0 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2d88:	f043 0301 	orr.w	r3, r3, #1
    2d8c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2d90:	aa03      	add	r2, sp, #12
    2d92:	a904      	add	r1, sp, #16
    2d94:	a805      	add	r0, sp, #20
    2d96:	f24c 3350 	movw	r3, #50000	; 0xc350
    2d9a:	f7fe fed1 	bl	1b40 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    2d9e:	4b14      	ldr	r3, [pc, #80]	; (2df0 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    2da0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2da4:	0e1b      	lsrs	r3, r3, #24
    2da6:	f003 0301 	and.w	r3, r3, #1
    2daa:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2dac:	9a03      	ldr	r2, [sp, #12]
    2dae:	a904      	add	r1, sp, #16
    2db0:	ab05      	add	r3, sp, #20
    2db2:	4618      	mov	r0, r3
    2db4:	f7fe fede 	bl	1b74 <Clock_Ip_TimeoutExpired>
    2db8:	4603      	mov	r3, r0
    2dba:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    2dbe:	9b06      	ldr	r3, [sp, #24]
    2dc0:	2b00      	cmp	r3, #0
    2dc2:	d106      	bne.n	2dd2 <Clock_Ip_EnableFirc_TrustedCall+0x66>
    2dc4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2dc8:	f083 0301 	eor.w	r3, r3, #1
    2dcc:	b2db      	uxtb	r3, r3
    2dce:	2b00      	cmp	r3, #0
    2dd0:	d1e5      	bne.n	2d9e <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    2dd2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2dd6:	2b00      	cmp	r3, #0
    2dd8:	d005      	beq.n	2de6 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2dda:	9b01      	ldr	r3, [sp, #4]
    2ddc:	681b      	ldr	r3, [r3, #0]
    2dde:	4619      	mov	r1, r3
    2de0:	2001      	movs	r0, #1
    2de2:	f7fe fe9d 	bl	1b20 <Clock_Ip_ReportClockErrors>
        }
    }
}
    2de6:	bf00      	nop
    2de8:	b009      	add	sp, #36	; 0x24
    2dea:	f85d fb04 	ldr.w	pc, [sp], #4
    2dee:	bf00      	nop
    2df0:	40064000 	.word	0x40064000

00002df4 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    2df4:	b082      	sub	sp, #8
    2df6:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    2df8:	4b05      	ldr	r3, [pc, #20]	; (2e10 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    2dfa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    2dfe:	4a04      	ldr	r2, [pc, #16]	; (2e10 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    2e00:	f023 0301 	bic.w	r3, r3, #1
    2e04:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    2e08:	bf00      	nop
    2e0a:	b002      	add	sp, #8
    2e0c:	4770      	bx	lr
    2e0e:	bf00      	nop
    2e10:	40064000 	.word	0x40064000

00002e14 <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    2e14:	b082      	sub	sp, #8
    2e16:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2e18:	bf00      	nop
    2e1a:	b002      	add	sp, #8
    2e1c:	4770      	bx	lr

00002e1e <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    2e1e:	b082      	sub	sp, #8
    2e20:	9001      	str	r0, [sp, #4]
    2e22:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    2e24:	bf00      	nop
    2e26:	b002      	add	sp, #8
    2e28:	4770      	bx	lr

00002e2a <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    2e2a:	b082      	sub	sp, #8
    2e2c:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    2e2e:	bf00      	nop
    2e30:	b002      	add	sp, #8
    2e32:	4770      	bx	lr

00002e34 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    2e34:	b082      	sub	sp, #8
    2e36:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2e38:	bf00      	nop
    2e3a:	b002      	add	sp, #8
    2e3c:	4770      	bx	lr

00002e3e <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    2e3e:	b082      	sub	sp, #8
    2e40:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    2e42:	2302      	movs	r3, #2
}
    2e44:	4618      	mov	r0, r3
    2e46:	b002      	add	sp, #8
    2e48:	4770      	bx	lr

00002e4a <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    2e4a:	b082      	sub	sp, #8
    2e4c:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    2e4e:	bf00      	nop
    2e50:	b002      	add	sp, #8
    2e52:	4770      	bx	lr

00002e54 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    2e54:	b500      	push	{lr}
    2e56:	b083      	sub	sp, #12
    2e58:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e5a:	9b01      	ldr	r3, [sp, #4]
    2e5c:	2b00      	cmp	r3, #0
    2e5e:	d002      	beq.n	2e66 <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    2e60:	9801      	ldr	r0, [sp, #4]
    2e62:	f000 f870 	bl	2f46 <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e66:	bf00      	nop
    2e68:	b003      	add	sp, #12
    2e6a:	f85d fb04 	ldr.w	pc, [sp], #4

00002e6e <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    2e6e:	b500      	push	{lr}
    2e70:	b083      	sub	sp, #12
    2e72:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e74:	9b01      	ldr	r3, [sp, #4]
    2e76:	2b00      	cmp	r3, #0
    2e78:	d002      	beq.n	2e80 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    2e7a:	9801      	ldr	r0, [sp, #4]
    2e7c:	f000 f89a 	bl	2fb4 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e80:	bf00      	nop
    2e82:	b003      	add	sp, #12
    2e84:	f85d fb04 	ldr.w	pc, [sp], #4

00002e88 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    2e88:	b500      	push	{lr}
    2e8a:	b089      	sub	sp, #36	; 0x24
    2e8c:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    2e8e:	2301      	movs	r3, #1
    2e90:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    2e92:	2300      	movs	r3, #0
    2e94:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    2e98:	4b1e      	ldr	r3, [pc, #120]	; (2f14 <Clock_Ip_CompleteSpll+0x8c>)
    2e9a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2e9e:	f003 0301 	and.w	r3, r3, #1
    2ea2:	2b00      	cmp	r3, #0
    2ea4:	d02f      	beq.n	2f06 <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    2ea6:	aa02      	add	r2, sp, #8
    2ea8:	a903      	add	r1, sp, #12
    2eaa:	a804      	add	r0, sp, #16
    2eac:	f24c 3350 	movw	r3, #50000	; 0xc350
    2eb0:	f7fe fe46 	bl	1b40 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    2eb4:	4b17      	ldr	r3, [pc, #92]	; (2f14 <Clock_Ip_CompleteSpll+0x8c>)
    2eb6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2eba:	0e1b      	lsrs	r3, r3, #24
    2ebc:	f003 0301 	and.w	r3, r3, #1
    2ec0:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2ec2:	9a02      	ldr	r2, [sp, #8]
    2ec4:	a903      	add	r1, sp, #12
    2ec6:	ab04      	add	r3, sp, #16
    2ec8:	4618      	mov	r0, r3
    2eca:	f7fe fe53 	bl	1b74 <Clock_Ip_TimeoutExpired>
    2ece:	4603      	mov	r3, r0
    2ed0:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    2ed4:	9b05      	ldr	r3, [sp, #20]
    2ed6:	2b00      	cmp	r3, #0
    2ed8:	d106      	bne.n	2ee8 <Clock_Ip_CompleteSpll+0x60>
    2eda:	f89d 301b 	ldrb.w	r3, [sp, #27]
    2ede:	f083 0301 	eor.w	r3, r3, #1
    2ee2:	b2db      	uxtb	r3, r3
    2ee4:	2b00      	cmp	r3, #0
    2ee6:	d1e5      	bne.n	2eb4 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    2ee8:	f89d 301b 	ldrb.w	r3, [sp, #27]
    2eec:	f083 0301 	eor.w	r3, r3, #1
    2ef0:	b2db      	uxtb	r3, r3
    2ef2:	2b00      	cmp	r3, #0
    2ef4:	d002      	beq.n	2efc <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    2ef6:	2302      	movs	r3, #2
    2ef8:	9307      	str	r3, [sp, #28]
    2efa:	e006      	b.n	2f0a <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    2efc:	9901      	ldr	r1, [sp, #4]
    2efe:	2001      	movs	r0, #1
    2f00:	f7fe fe0e 	bl	1b20 <Clock_Ip_ReportClockErrors>
    2f04:	e001      	b.n	2f0a <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    2f06:	2300      	movs	r3, #0
    2f08:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    2f0a:	9b07      	ldr	r3, [sp, #28]
}
    2f0c:	4618      	mov	r0, r3
    2f0e:	b009      	add	sp, #36	; 0x24
    2f10:	f85d fb04 	ldr.w	pc, [sp], #4
    2f14:	40064000 	.word	0x40064000

00002f18 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    2f18:	b500      	push	{lr}
    2f1a:	b083      	sub	sp, #12
    2f1c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    2f1e:	9801      	ldr	r0, [sp, #4]
    2f20:	f000 f886 	bl	3030 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    2f24:	bf00      	nop
    2f26:	b003      	add	sp, #12
    2f28:	f85d fb04 	ldr.w	pc, [sp], #4

00002f2c <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    2f2c:	b500      	push	{lr}
    2f2e:	b083      	sub	sp, #12
    2f30:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f32:	9b01      	ldr	r3, [sp, #4]
    2f34:	2b00      	cmp	r3, #0
    2f36:	d002      	beq.n	2f3e <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    2f38:	9801      	ldr	r0, [sp, #4]
    2f3a:	f000 f891 	bl	3060 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f3e:	bf00      	nop
    2f40:	b003      	add	sp, #12
    2f42:	f85d fb04 	ldr.w	pc, [sp], #4

00002f46 <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    2f46:	b082      	sub	sp, #8
    2f48:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    2f4a:	4b19      	ldr	r3, [pc, #100]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f4c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2f50:	4a17      	ldr	r2, [pc, #92]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f52:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    2f56:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    2f5a:	4b15      	ldr	r3, [pc, #84]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f5c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2f60:	4a13      	ldr	r2, [pc, #76]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f62:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    2f66:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    2f6a:	4b11      	ldr	r3, [pc, #68]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f6c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2f70:	4a0f      	ldr	r2, [pc, #60]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f72:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    2f76:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    2f7a:	4b0d      	ldr	r3, [pc, #52]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f7c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    2f80:	4a0b      	ldr	r2, [pc, #44]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f82:	f023 0301 	bic.w	r3, r3, #1
    2f86:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    2f8a:	4b09      	ldr	r3, [pc, #36]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f8c:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    2f90:	4a07      	ldr	r2, [pc, #28]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f92:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    2f96:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    2f9a:	4b05      	ldr	r3, [pc, #20]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2f9c:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    2fa0:	4a03      	ldr	r2, [pc, #12]	; (2fb0 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    2fa2:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    2fa6:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    2faa:	bf00      	nop
    2fac:	b002      	add	sp, #8
    2fae:	4770      	bx	lr
    2fb0:	40064000 	.word	0x40064000

00002fb4 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    2fb4:	b082      	sub	sp, #8
    2fb6:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    2fb8:	9b01      	ldr	r3, [sp, #4]
    2fba:	889b      	ldrh	r3, [r3, #4]
    2fbc:	2b01      	cmp	r3, #1
    2fbe:	d12f      	bne.n	3020 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    2fc0:	4b1a      	ldr	r3, [pc, #104]	; (302c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    2fc2:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    2fc6:	9b01      	ldr	r3, [sp, #4]
    2fc8:	7b5b      	ldrb	r3, [r3, #13]
    2fca:	3b01      	subs	r3, #1
    2fcc:	021b      	lsls	r3, r3, #8
    2fce:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    2fd2:	9b01      	ldr	r3, [sp, #4]
    2fd4:	7d1b      	ldrb	r3, [r3, #20]
    2fd6:	3b10      	subs	r3, #16
    2fd8:	041b      	lsls	r3, r3, #16
    2fda:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    2fde:	430b      	orrs	r3, r1
    2fe0:	4912      	ldr	r1, [pc, #72]	; (302c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    2fe2:	4313      	orrs	r3, r2
    2fe4:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    2fe8:	9b01      	ldr	r3, [sp, #4]
    2fea:	7fdb      	ldrb	r3, [r3, #31]
    2fec:	2b02      	cmp	r3, #2
    2fee:	d011      	beq.n	3014 <Clock_Ip_SetSpll_TrustedCall+0x60>
    2ff0:	2b02      	cmp	r3, #2
    2ff2:	dc17      	bgt.n	3024 <Clock_Ip_SetSpll_TrustedCall+0x70>
    2ff4:	2b00      	cmp	r3, #0
    2ff6:	d002      	beq.n	2ffe <Clock_Ip_SetSpll_TrustedCall+0x4a>
    2ff8:	2b01      	cmp	r3, #1
    2ffa:	d005      	beq.n	3008 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    2ffc:	e012      	b.n	3024 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    2ffe:	4b0b      	ldr	r3, [pc, #44]	; (302c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3000:	2200      	movs	r2, #0
    3002:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3006:	e00e      	b.n	3026 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3008:	4b08      	ldr	r3, [pc, #32]	; (302c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    300a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    300e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    3012:	e008      	b.n	3026 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    3014:	4b05      	ldr	r3, [pc, #20]	; (302c <Clock_Ip_SetSpll_TrustedCall+0x78>)
    3016:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    301a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    301e:	e002      	b.n	3026 <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    3020:	bf00      	nop
    3022:	e000      	b.n	3026 <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    3024:	bf00      	nop
}
    3026:	bf00      	nop
    3028:	b002      	add	sp, #8
    302a:	4770      	bx	lr
    302c:	40064000 	.word	0x40064000

00003030 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    3030:	b082      	sub	sp, #8
    3032:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    3034:	4b09      	ldr	r3, [pc, #36]	; (305c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3036:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    303a:	4a08      	ldr	r2, [pc, #32]	; (305c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    303c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3040:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    3044:	4b05      	ldr	r3, [pc, #20]	; (305c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    3046:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    304a:	4a04      	ldr	r2, [pc, #16]	; (305c <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    304c:	f023 0301 	bic.w	r3, r3, #1
    3050:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    3054:	bf00      	nop
    3056:	b002      	add	sp, #8
    3058:	4770      	bx	lr
    305a:	bf00      	nop
    305c:	40064000 	.word	0x40064000

00003060 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    3060:	b082      	sub	sp, #8
    3062:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    3064:	9b01      	ldr	r3, [sp, #4]
    3066:	889b      	ldrh	r3, [r3, #4]
    3068:	2b01      	cmp	r3, #1
    306a:	d107      	bne.n	307c <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    306c:	4b05      	ldr	r3, [pc, #20]	; (3084 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    306e:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3072:	4a04      	ldr	r2, [pc, #16]	; (3084 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    3074:	f043 0301 	orr.w	r3, r3, #1
    3078:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    307c:	bf00      	nop
    307e:	b002      	add	sp, #8
    3080:	4770      	bx	lr
    3082:	bf00      	nop
    3084:	40064000 	.word	0x40064000

00003088 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    3088:	b082      	sub	sp, #8
    308a:	9001      	str	r0, [sp, #4]
    308c:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    308e:	bf00      	nop
    3090:	b002      	add	sp, #8
    3092:	4770      	bx	lr

00003094 <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    3094:	b082      	sub	sp, #8
    3096:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3098:	bf00      	nop
    309a:	b002      	add	sp, #8
    309c:	4770      	bx	lr

0000309e <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    309e:	b500      	push	{lr}
    30a0:	b083      	sub	sp, #12
    30a2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30a4:	9b01      	ldr	r3, [sp, #4]
    30a6:	2b00      	cmp	r3, #0
    30a8:	d002      	beq.n	30b0 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    30aa:	9801      	ldr	r0, [sp, #4]
    30ac:	f000 f8ee 	bl	328c <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30b0:	bf00      	nop
    30b2:	b003      	add	sp, #12
    30b4:	f85d fb04 	ldr.w	pc, [sp], #4

000030b8 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    30b8:	b500      	push	{lr}
    30ba:	b083      	sub	sp, #12
    30bc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30be:	9b01      	ldr	r3, [sp, #4]
    30c0:	2b00      	cmp	r3, #0
    30c2:	d002      	beq.n	30ca <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    30c4:	9801      	ldr	r0, [sp, #4]
    30c6:	f000 f8ff 	bl	32c8 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30ca:	bf00      	nop
    30cc:	b003      	add	sp, #12
    30ce:	f85d fb04 	ldr.w	pc, [sp], #4

000030d2 <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    30d2:	b500      	push	{lr}
    30d4:	b083      	sub	sp, #12
    30d6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30d8:	9b01      	ldr	r3, [sp, #4]
    30da:	2b00      	cmp	r3, #0
    30dc:	d002      	beq.n	30e4 <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    30de:	9801      	ldr	r0, [sp, #4]
    30e0:	f000 f912 	bl	3308 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30e4:	bf00      	nop
    30e6:	b003      	add	sp, #12
    30e8:	f85d fb04 	ldr.w	pc, [sp], #4

000030ec <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    30ec:	b500      	push	{lr}
    30ee:	b083      	sub	sp, #12
    30f0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30f2:	9b01      	ldr	r3, [sp, #4]
    30f4:	2b00      	cmp	r3, #0
    30f6:	d002      	beq.n	30fe <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    30f8:	9801      	ldr	r0, [sp, #4]
    30fa:	f000 f925 	bl	3348 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30fe:	bf00      	nop
    3100:	b003      	add	sp, #12
    3102:	f85d fb04 	ldr.w	pc, [sp], #4

00003106 <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    3106:	b500      	push	{lr}
    3108:	b083      	sub	sp, #12
    310a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    310c:	9b01      	ldr	r3, [sp, #4]
    310e:	2b00      	cmp	r3, #0
    3110:	d002      	beq.n	3118 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    3112:	9801      	ldr	r0, [sp, #4]
    3114:	f000 f936 	bl	3384 <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3118:	bf00      	nop
    311a:	b003      	add	sp, #12
    311c:	f85d fb04 	ldr.w	pc, [sp], #4

00003120 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    3120:	b500      	push	{lr}
    3122:	b083      	sub	sp, #12
    3124:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3126:	9b01      	ldr	r3, [sp, #4]
    3128:	2b00      	cmp	r3, #0
    312a:	d002      	beq.n	3132 <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    312c:	9801      	ldr	r0, [sp, #4]
    312e:	f000 f949 	bl	33c4 <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3132:	bf00      	nop
    3134:	b003      	add	sp, #12
    3136:	f85d fb04 	ldr.w	pc, [sp], #4

0000313a <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    313a:	b500      	push	{lr}
    313c:	b083      	sub	sp, #12
    313e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3140:	9b01      	ldr	r3, [sp, #4]
    3142:	2b00      	cmp	r3, #0
    3144:	d002      	beq.n	314c <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    3146:	9801      	ldr	r0, [sp, #4]
    3148:	f000 f958 	bl	33fc <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    314c:	bf00      	nop
    314e:	b003      	add	sp, #12
    3150:	f85d fb04 	ldr.w	pc, [sp], #4

00003154 <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    3154:	b500      	push	{lr}
    3156:	b083      	sub	sp, #12
    3158:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    315a:	9b01      	ldr	r3, [sp, #4]
    315c:	2b00      	cmp	r3, #0
    315e:	d002      	beq.n	3166 <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    3160:	9801      	ldr	r0, [sp, #4]
    3162:	f000 f969 	bl	3438 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3166:	bf00      	nop
    3168:	b003      	add	sp, #12
    316a:	f85d fb04 	ldr.w	pc, [sp], #4

0000316e <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    316e:	b500      	push	{lr}
    3170:	b083      	sub	sp, #12
    3172:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3174:	9b01      	ldr	r3, [sp, #4]
    3176:	2b00      	cmp	r3, #0
    3178:	d002      	beq.n	3180 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    317a:	9801      	ldr	r0, [sp, #4]
    317c:	f000 f978 	bl	3470 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3180:	bf00      	nop
    3182:	b003      	add	sp, #12
    3184:	f85d fb04 	ldr.w	pc, [sp], #4

00003188 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    3188:	b500      	push	{lr}
    318a:	b083      	sub	sp, #12
    318c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    318e:	9b01      	ldr	r3, [sp, #4]
    3190:	2b00      	cmp	r3, #0
    3192:	d002      	beq.n	319a <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    3194:	9801      	ldr	r0, [sp, #4]
    3196:	f000 f989 	bl	34ac <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    319a:	bf00      	nop
    319c:	b003      	add	sp, #12
    319e:	f85d fb04 	ldr.w	pc, [sp], #4

000031a2 <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    31a2:	b500      	push	{lr}
    31a4:	b083      	sub	sp, #12
    31a6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31a8:	9b01      	ldr	r3, [sp, #4]
    31aa:	2b00      	cmp	r3, #0
    31ac:	d002      	beq.n	31b4 <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    31ae:	9801      	ldr	r0, [sp, #4]
    31b0:	f000 f998 	bl	34e4 <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31b4:	bf00      	nop
    31b6:	b003      	add	sp, #12
    31b8:	f85d fb04 	ldr.w	pc, [sp], #4

000031bc <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    31bc:	b500      	push	{lr}
    31be:	b083      	sub	sp, #12
    31c0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31c2:	9b01      	ldr	r3, [sp, #4]
    31c4:	2b00      	cmp	r3, #0
    31c6:	d002      	beq.n	31ce <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    31c8:	9801      	ldr	r0, [sp, #4]
    31ca:	f000 f9a9 	bl	3520 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31ce:	bf00      	nop
    31d0:	b003      	add	sp, #12
    31d2:	f85d fb04 	ldr.w	pc, [sp], #4

000031d6 <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    31d6:	b500      	push	{lr}
    31d8:	b083      	sub	sp, #12
    31da:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31dc:	9b01      	ldr	r3, [sp, #4]
    31de:	2b00      	cmp	r3, #0
    31e0:	d002      	beq.n	31e8 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    31e2:	9801      	ldr	r0, [sp, #4]
    31e4:	f000 f9e6 	bl	35b4 <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    31e8:	bf00      	nop
    31ea:	b003      	add	sp, #12
    31ec:	f85d fb04 	ldr.w	pc, [sp], #4

000031f0 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    31f0:	b500      	push	{lr}
    31f2:	b083      	sub	sp, #12
    31f4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    31f6:	9b01      	ldr	r3, [sp, #4]
    31f8:	2b00      	cmp	r3, #0
    31fa:	d002      	beq.n	3202 <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    31fc:	9801      	ldr	r0, [sp, #4]
    31fe:	f000 fa25 	bl	364c <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3202:	bf00      	nop
    3204:	b003      	add	sp, #12
    3206:	f85d fb04 	ldr.w	pc, [sp], #4

0000320a <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    320a:	b500      	push	{lr}
    320c:	b083      	sub	sp, #12
    320e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3210:	9b01      	ldr	r3, [sp, #4]
    3212:	2b00      	cmp	r3, #0
    3214:	d002      	beq.n	321c <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    3216:	9801      	ldr	r0, [sp, #4]
    3218:	f000 fa2a 	bl	3670 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    321c:	bf00      	nop
    321e:	b003      	add	sp, #12
    3220:	f85d fb04 	ldr.w	pc, [sp], #4

00003224 <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    3224:	b500      	push	{lr}
    3226:	b083      	sub	sp, #12
    3228:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    322a:	9b01      	ldr	r3, [sp, #4]
    322c:	2b00      	cmp	r3, #0
    322e:	d002      	beq.n	3236 <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    3230:	9801      	ldr	r0, [sp, #4]
    3232:	f000 fa3b 	bl	36ac <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3236:	bf00      	nop
    3238:	b003      	add	sp, #12
    323a:	f85d fb04 	ldr.w	pc, [sp], #4

0000323e <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    323e:	b500      	push	{lr}
    3240:	b083      	sub	sp, #12
    3242:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3244:	9b01      	ldr	r3, [sp, #4]
    3246:	2b00      	cmp	r3, #0
    3248:	d002      	beq.n	3250 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    324a:	9801      	ldr	r0, [sp, #4]
    324c:	f000 fa56 	bl	36fc <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3250:	bf00      	nop
    3252:	b003      	add	sp, #12
    3254:	f85d fb04 	ldr.w	pc, [sp], #4

00003258 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    3258:	b500      	push	{lr}
    325a:	b083      	sub	sp, #12
    325c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    325e:	9b01      	ldr	r3, [sp, #4]
    3260:	2b00      	cmp	r3, #0
    3262:	d002      	beq.n	326a <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    3264:	9801      	ldr	r0, [sp, #4]
    3266:	f000 fa79 	bl	375c <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    326a:	bf00      	nop
    326c:	b003      	add	sp, #12
    326e:	f85d fb04 	ldr.w	pc, [sp], #4

00003272 <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    3272:	b500      	push	{lr}
    3274:	b083      	sub	sp, #12
    3276:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3278:	9b01      	ldr	r3, [sp, #4]
    327a:	2b00      	cmp	r3, #0
    327c:	d002      	beq.n	3284 <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    327e:	9801      	ldr	r0, [sp, #4]
    3280:	f000 fa8a 	bl	3798 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3284:	bf00      	nop
    3286:	b003      	add	sp, #12
    3288:	f85d fb04 	ldr.w	pc, [sp], #4

0000328c <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    328c:	b084      	sub	sp, #16
    328e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3290:	4b0b      	ldr	r3, [pc, #44]	; (32c0 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    3292:	795b      	ldrb	r3, [r3, #5]
    3294:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    3296:	4b0b      	ldr	r3, [pc, #44]	; (32c4 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    3298:	695b      	ldr	r3, [r3, #20]
    329a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    329c:	9b02      	ldr	r3, [sp, #8]
    329e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    32a2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    32a4:	9b03      	ldr	r3, [sp, #12]
    32a6:	061b      	lsls	r3, r3, #24
    32a8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    32ac:	9a02      	ldr	r2, [sp, #8]
    32ae:	4313      	orrs	r3, r2
    32b0:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    32b2:	4a04      	ldr	r2, [pc, #16]	; (32c4 <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    32b4:	9b02      	ldr	r3, [sp, #8]
    32b6:	6153      	str	r3, [r2, #20]
}
    32b8:	bf00      	nop
    32ba:	b004      	add	sp, #16
    32bc:	4770      	bx	lr
    32be:	bf00      	nop
    32c0:	00007074 	.word	0x00007074
    32c4:	40064000 	.word	0x40064000

000032c8 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    32c8:	b084      	sub	sp, #16
    32ca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    32cc:	9b01      	ldr	r3, [sp, #4]
    32ce:	685b      	ldr	r3, [r3, #4]
    32d0:	4a0b      	ldr	r2, [pc, #44]	; (3300 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    32d2:	5cd3      	ldrb	r3, [r2, r3]
    32d4:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    32d6:	4b0b      	ldr	r3, [pc, #44]	; (3304 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    32d8:	695b      	ldr	r3, [r3, #20]
    32da:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    32dc:	9b02      	ldr	r3, [sp, #8]
    32de:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    32e2:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    32e4:	9b03      	ldr	r3, [sp, #12]
    32e6:	061b      	lsls	r3, r3, #24
    32e8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    32ec:	9a02      	ldr	r2, [sp, #8]
    32ee:	4313      	orrs	r3, r2
    32f0:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    32f2:	4a04      	ldr	r2, [pc, #16]	; (3304 <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    32f4:	9b02      	ldr	r3, [sp, #8]
    32f6:	6153      	str	r3, [r2, #20]
}
    32f8:	bf00      	nop
    32fa:	b004      	add	sp, #16
    32fc:	4770      	bx	lr
    32fe:	bf00      	nop
    3300:	00007074 	.word	0x00007074
    3304:	40064000 	.word	0x40064000

00003308 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3308:	b084      	sub	sp, #16
    330a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    330c:	9b01      	ldr	r3, [sp, #4]
    330e:	685b      	ldr	r3, [r3, #4]
    3310:	4a0b      	ldr	r2, [pc, #44]	; (3340 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    3312:	5cd3      	ldrb	r3, [r2, r3]
    3314:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    3316:	4b0b      	ldr	r3, [pc, #44]	; (3344 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3318:	699b      	ldr	r3, [r3, #24]
    331a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    331c:	9b02      	ldr	r3, [sp, #8]
    331e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3322:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    3324:	9b03      	ldr	r3, [sp, #12]
    3326:	061b      	lsls	r3, r3, #24
    3328:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    332c:	9a02      	ldr	r2, [sp, #8]
    332e:	4313      	orrs	r3, r2
    3330:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    3332:	4a04      	ldr	r2, [pc, #16]	; (3344 <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    3334:	9b02      	ldr	r3, [sp, #8]
    3336:	6193      	str	r3, [r2, #24]
}
    3338:	bf00      	nop
    333a:	b004      	add	sp, #16
    333c:	4770      	bx	lr
    333e:	bf00      	nop
    3340:	00007074 	.word	0x00007074
    3344:	40064000 	.word	0x40064000

00003348 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3348:	b084      	sub	sp, #16
    334a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    334c:	4b0b      	ldr	r3, [pc, #44]	; (337c <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    334e:	795b      	ldrb	r3, [r3, #5]
    3350:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    3352:	4b0b      	ldr	r3, [pc, #44]	; (3380 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    3354:	69db      	ldr	r3, [r3, #28]
    3356:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    3358:	9b02      	ldr	r3, [sp, #8]
    335a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    335e:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    3360:	9b03      	ldr	r3, [sp, #12]
    3362:	061b      	lsls	r3, r3, #24
    3364:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    3368:	9a02      	ldr	r2, [sp, #8]
    336a:	4313      	orrs	r3, r2
    336c:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    336e:	4a04      	ldr	r2, [pc, #16]	; (3380 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    3370:	9b02      	ldr	r3, [sp, #8]
    3372:	61d3      	str	r3, [r2, #28]
}
    3374:	bf00      	nop
    3376:	b004      	add	sp, #16
    3378:	4770      	bx	lr
    337a:	bf00      	nop
    337c:	00007074 	.word	0x00007074
    3380:	40064000 	.word	0x40064000

00003384 <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3384:	b084      	sub	sp, #16
    3386:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3388:	9b01      	ldr	r3, [sp, #4]
    338a:	685b      	ldr	r3, [r3, #4]
    338c:	4a0b      	ldr	r2, [pc, #44]	; (33bc <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    338e:	5cd3      	ldrb	r3, [r2, r3]
    3390:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    3392:	4b0b      	ldr	r3, [pc, #44]	; (33c0 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    3394:	69db      	ldr	r3, [r3, #28]
    3396:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    3398:	9b02      	ldr	r3, [sp, #8]
    339a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    339e:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    33a0:	9b03      	ldr	r3, [sp, #12]
    33a2:	061b      	lsls	r3, r3, #24
    33a4:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    33a8:	9a02      	ldr	r2, [sp, #8]
    33aa:	4313      	orrs	r3, r2
    33ac:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    33ae:	4a04      	ldr	r2, [pc, #16]	; (33c0 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    33b0:	9b02      	ldr	r3, [sp, #8]
    33b2:	61d3      	str	r3, [r2, #28]
}
    33b4:	bf00      	nop
    33b6:	b004      	add	sp, #16
    33b8:	4770      	bx	lr
    33ba:	bf00      	nop
    33bc:	00007074 	.word	0x00007074
    33c0:	40064000 	.word	0x40064000

000033c4 <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    33c4:	b084      	sub	sp, #16
    33c6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    33c8:	4b0a      	ldr	r3, [pc, #40]	; (33f4 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    33ca:	7b9b      	ldrb	r3, [r3, #14]
    33cc:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    33ce:	4b0a      	ldr	r3, [pc, #40]	; (33f8 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    33d0:	691b      	ldr	r3, [r3, #16]
    33d2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    33d4:	9b02      	ldr	r3, [sp, #8]
    33d6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    33da:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    33dc:	9b03      	ldr	r3, [sp, #12]
    33de:	011b      	lsls	r3, r3, #4
    33e0:	9a02      	ldr	r2, [sp, #8]
    33e2:	4313      	orrs	r3, r2
    33e4:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    33e6:	4a04      	ldr	r2, [pc, #16]	; (33f8 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    33e8:	9b02      	ldr	r3, [sp, #8]
    33ea:	6113      	str	r3, [r2, #16]
}
    33ec:	bf00      	nop
    33ee:	b004      	add	sp, #16
    33f0:	4770      	bx	lr
    33f2:	bf00      	nop
    33f4:	0000701c 	.word	0x0000701c
    33f8:	40048000 	.word	0x40048000

000033fc <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    33fc:	b084      	sub	sp, #16
    33fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3400:	9b01      	ldr	r3, [sp, #4]
    3402:	685b      	ldr	r3, [r3, #4]
    3404:	4a0a      	ldr	r2, [pc, #40]	; (3430 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    3406:	5cd3      	ldrb	r3, [r2, r3]
    3408:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    340a:	4b0a      	ldr	r3, [pc, #40]	; (3434 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    340c:	691b      	ldr	r3, [r3, #16]
    340e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    3410:	9b02      	ldr	r3, [sp, #8]
    3412:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    3416:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    3418:	9b03      	ldr	r3, [sp, #12]
    341a:	011b      	lsls	r3, r3, #4
    341c:	9a02      	ldr	r2, [sp, #8]
    341e:	4313      	orrs	r3, r2
    3420:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    3422:	4a04      	ldr	r2, [pc, #16]	; (3434 <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    3424:	9b02      	ldr	r3, [sp, #8]
    3426:	6113      	str	r3, [r2, #16]
}
    3428:	bf00      	nop
    342a:	b004      	add	sp, #16
    342c:	4770      	bx	lr
    342e:	bf00      	nop
    3430:	0000701c 	.word	0x0000701c
    3434:	40048000 	.word	0x40048000

00003438 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3438:	b084      	sub	sp, #16
    343a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    343c:	4b0a      	ldr	r3, [pc, #40]	; (3468 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    343e:	785b      	ldrb	r3, [r3, #1]
    3440:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    3442:	4b0a      	ldr	r3, [pc, #40]	; (346c <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    3444:	691b      	ldr	r3, [r3, #16]
    3446:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    3448:	9b02      	ldr	r3, [sp, #8]
    344a:	f023 030c 	bic.w	r3, r3, #12
    344e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    3450:	9b03      	ldr	r3, [sp, #12]
    3452:	009b      	lsls	r3, r3, #2
    3454:	9a02      	ldr	r2, [sp, #8]
    3456:	4313      	orrs	r3, r2
    3458:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    345a:	4a04      	ldr	r2, [pc, #16]	; (346c <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    345c:	9b02      	ldr	r3, [sp, #8]
    345e:	6113      	str	r3, [r2, #16]
}
    3460:	bf00      	nop
    3462:	b004      	add	sp, #16
    3464:	4770      	bx	lr
    3466:	bf00      	nop
    3468:	000070d4 	.word	0x000070d4
    346c:	40048000 	.word	0x40048000

00003470 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3470:	b084      	sub	sp, #16
    3472:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3474:	9b01      	ldr	r3, [sp, #4]
    3476:	685b      	ldr	r3, [r3, #4]
    3478:	4a0a      	ldr	r2, [pc, #40]	; (34a4 <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    347a:	5cd3      	ldrb	r3, [r2, r3]
    347c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    347e:	4b0a      	ldr	r3, [pc, #40]	; (34a8 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    3480:	691b      	ldr	r3, [r3, #16]
    3482:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    3484:	9b02      	ldr	r3, [sp, #8]
    3486:	f023 030c 	bic.w	r3, r3, #12
    348a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    348c:	9b03      	ldr	r3, [sp, #12]
    348e:	009b      	lsls	r3, r3, #2
    3490:	9a02      	ldr	r2, [sp, #8]
    3492:	4313      	orrs	r3, r2
    3494:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    3496:	4a04      	ldr	r2, [pc, #16]	; (34a8 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    3498:	9b02      	ldr	r3, [sp, #8]
    349a:	6113      	str	r3, [r2, #16]
}
    349c:	bf00      	nop
    349e:	b004      	add	sp, #16
    34a0:	4770      	bx	lr
    34a2:	bf00      	nop
    34a4:	000070d4 	.word	0x000070d4
    34a8:	40048000 	.word	0x40048000

000034ac <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    34ac:	b084      	sub	sp, #16
    34ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    34b0:	4b0a      	ldr	r3, [pc, #40]	; (34dc <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    34b2:	795b      	ldrb	r3, [r3, #5]
    34b4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    34b6:	4b0a      	ldr	r3, [pc, #40]	; (34e0 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    34b8:	6a1b      	ldr	r3, [r3, #32]
    34ba:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    34bc:	9b02      	ldr	r3, [sp, #8]
    34be:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    34c2:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    34c4:	9b03      	ldr	r3, [sp, #12]
    34c6:	061b      	lsls	r3, r3, #24
    34c8:	9a02      	ldr	r2, [sp, #8]
    34ca:	4313      	orrs	r3, r2
    34cc:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    34ce:	4a04      	ldr	r2, [pc, #16]	; (34e0 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    34d0:	9b02      	ldr	r3, [sp, #8]
    34d2:	6213      	str	r3, [r2, #32]
}
    34d4:	bf00      	nop
    34d6:	b004      	add	sp, #16
    34d8:	4770      	bx	lr
    34da:	bf00      	nop
    34dc:	00007074 	.word	0x00007074
    34e0:	40064000 	.word	0x40064000

000034e4 <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    34e4:	b084      	sub	sp, #16
    34e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    34e8:	9b01      	ldr	r3, [sp, #4]
    34ea:	685b      	ldr	r3, [r3, #4]
    34ec:	4a0a      	ldr	r2, [pc, #40]	; (3518 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    34ee:	5cd3      	ldrb	r3, [r2, r3]
    34f0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    34f2:	4b0a      	ldr	r3, [pc, #40]	; (351c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    34f4:	6a1b      	ldr	r3, [r3, #32]
    34f6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    34f8:	9b02      	ldr	r3, [sp, #8]
    34fa:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    34fe:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    3500:	9b03      	ldr	r3, [sp, #12]
    3502:	061b      	lsls	r3, r3, #24
    3504:	9a02      	ldr	r2, [sp, #8]
    3506:	4313      	orrs	r3, r2
    3508:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    350a:	4a04      	ldr	r2, [pc, #16]	; (351c <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    350c:	9b02      	ldr	r3, [sp, #8]
    350e:	6213      	str	r3, [r2, #32]
}
    3510:	bf00      	nop
    3512:	b004      	add	sp, #16
    3514:	4770      	bx	lr
    3516:	bf00      	nop
    3518:	00007074 	.word	0x00007074
    351c:	40064000 	.word	0x40064000

00003520 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3520:	b086      	sub	sp, #24
    3522:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3524:	4b20      	ldr	r3, [pc, #128]	; (35a8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    3526:	795b      	ldrb	r3, [r3, #5]
    3528:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    352a:	9b01      	ldr	r3, [sp, #4]
    352c:	681a      	ldr	r2, [r3, #0]
    352e:	491f      	ldr	r1, [pc, #124]	; (35ac <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    3530:	4613      	mov	r3, r2
    3532:	00db      	lsls	r3, r3, #3
    3534:	4413      	add	r3, r2
    3536:	440b      	add	r3, r1
    3538:	781b      	ldrb	r3, [r3, #0]
    353a:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    353c:	4b1c      	ldr	r3, [pc, #112]	; (35b0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    353e:	68db      	ldr	r3, [r3, #12]
    3540:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    3542:	9b03      	ldr	r3, [sp, #12]
    3544:	2b03      	cmp	r3, #3
    3546:	d813      	bhi.n	3570 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    3548:	9b03      	ldr	r3, [sp, #12]
    354a:	005b      	lsls	r3, r3, #1
    354c:	3318      	adds	r3, #24
    354e:	2203      	movs	r2, #3
    3550:	fa02 f303 	lsl.w	r3, r2, r3
    3554:	43db      	mvns	r3, r3
    3556:	9a05      	ldr	r2, [sp, #20]
    3558:	4013      	ands	r3, r2
    355a:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    355c:	9b03      	ldr	r3, [sp, #12]
    355e:	005b      	lsls	r3, r3, #1
    3560:	3318      	adds	r3, #24
    3562:	9a04      	ldr	r2, [sp, #16]
    3564:	fa02 f303 	lsl.w	r3, r2, r3
    3568:	9a05      	ldr	r2, [sp, #20]
    356a:	4313      	orrs	r3, r2
    356c:	9305      	str	r3, [sp, #20]
    356e:	e014      	b.n	359a <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3570:	9b03      	ldr	r3, [sp, #12]
    3572:	3b04      	subs	r3, #4
    3574:	005b      	lsls	r3, r3, #1
    3576:	3310      	adds	r3, #16
    3578:	2203      	movs	r2, #3
    357a:	fa02 f303 	lsl.w	r3, r2, r3
    357e:	43db      	mvns	r3, r3
    3580:	9a05      	ldr	r2, [sp, #20]
    3582:	4013      	ands	r3, r2
    3584:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    3586:	9b03      	ldr	r3, [sp, #12]
    3588:	3b04      	subs	r3, #4
    358a:	005b      	lsls	r3, r3, #1
    358c:	3310      	adds	r3, #16
    358e:	9a04      	ldr	r2, [sp, #16]
    3590:	fa02 f303 	lsl.w	r3, r2, r3
    3594:	9a05      	ldr	r2, [sp, #20]
    3596:	4313      	orrs	r3, r2
    3598:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    359a:	4a05      	ldr	r2, [pc, #20]	; (35b0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    359c:	9b05      	ldr	r3, [sp, #20]
    359e:	60d3      	str	r3, [r2, #12]
}
    35a0:	bf00      	nop
    35a2:	b006      	add	sp, #24
    35a4:	4770      	bx	lr
    35a6:	bf00      	nop
    35a8:	0000701c 	.word	0x0000701c
    35ac:	00006d0c 	.word	0x00006d0c
    35b0:	40048000 	.word	0x40048000

000035b4 <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    35b4:	b086      	sub	sp, #24
    35b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    35b8:	9b01      	ldr	r3, [sp, #4]
    35ba:	685b      	ldr	r3, [r3, #4]
    35bc:	4a20      	ldr	r2, [pc, #128]	; (3640 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    35be:	5cd3      	ldrb	r3, [r2, r3]
    35c0:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    35c2:	9b01      	ldr	r3, [sp, #4]
    35c4:	681a      	ldr	r2, [r3, #0]
    35c6:	491f      	ldr	r1, [pc, #124]	; (3644 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    35c8:	4613      	mov	r3, r2
    35ca:	00db      	lsls	r3, r3, #3
    35cc:	4413      	add	r3, r2
    35ce:	440b      	add	r3, r1
    35d0:	781b      	ldrb	r3, [r3, #0]
    35d2:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    35d4:	4b1c      	ldr	r3, [pc, #112]	; (3648 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    35d6:	68db      	ldr	r3, [r3, #12]
    35d8:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    35da:	9b03      	ldr	r3, [sp, #12]
    35dc:	2b03      	cmp	r3, #3
    35de:	d813      	bhi.n	3608 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    35e0:	9b03      	ldr	r3, [sp, #12]
    35e2:	005b      	lsls	r3, r3, #1
    35e4:	3318      	adds	r3, #24
    35e6:	2203      	movs	r2, #3
    35e8:	fa02 f303 	lsl.w	r3, r2, r3
    35ec:	43db      	mvns	r3, r3
    35ee:	9a05      	ldr	r2, [sp, #20]
    35f0:	4013      	ands	r3, r2
    35f2:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    35f4:	9b03      	ldr	r3, [sp, #12]
    35f6:	005b      	lsls	r3, r3, #1
    35f8:	3318      	adds	r3, #24
    35fa:	9a04      	ldr	r2, [sp, #16]
    35fc:	fa02 f303 	lsl.w	r3, r2, r3
    3600:	9a05      	ldr	r2, [sp, #20]
    3602:	4313      	orrs	r3, r2
    3604:	9305      	str	r3, [sp, #20]
    3606:	e014      	b.n	3632 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    3608:	9b03      	ldr	r3, [sp, #12]
    360a:	3b04      	subs	r3, #4
    360c:	005b      	lsls	r3, r3, #1
    360e:	3310      	adds	r3, #16
    3610:	2203      	movs	r2, #3
    3612:	fa02 f303 	lsl.w	r3, r2, r3
    3616:	43db      	mvns	r3, r3
    3618:	9a05      	ldr	r2, [sp, #20]
    361a:	4013      	ands	r3, r2
    361c:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    361e:	9b03      	ldr	r3, [sp, #12]
    3620:	3b04      	subs	r3, #4
    3622:	005b      	lsls	r3, r3, #1
    3624:	3310      	adds	r3, #16
    3626:	9a04      	ldr	r2, [sp, #16]
    3628:	fa02 f303 	lsl.w	r3, r2, r3
    362c:	9a05      	ldr	r2, [sp, #20]
    362e:	4313      	orrs	r3, r2
    3630:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    3632:	4a05      	ldr	r2, [pc, #20]	; (3648 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    3634:	9b05      	ldr	r3, [sp, #20]
    3636:	60d3      	str	r3, [r2, #12]
}
    3638:	bf00      	nop
    363a:	b006      	add	sp, #24
    363c:	4770      	bx	lr
    363e:	bf00      	nop
    3640:	0000701c 	.word	0x0000701c
    3644:	00006d0c 	.word	0x00006d0c
    3648:	40048000 	.word	0x40048000

0000364c <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    364c:	b084      	sub	sp, #16
    364e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    3650:	4b06      	ldr	r3, [pc, #24]	; (366c <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3652:	685b      	ldr	r3, [r3, #4]
    3654:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    3656:	9b03      	ldr	r3, [sp, #12]
    3658:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    365c:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    365e:	4a03      	ldr	r2, [pc, #12]	; (366c <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    3660:	9b03      	ldr	r3, [sp, #12]
    3662:	6053      	str	r3, [r2, #4]
}
    3664:	bf00      	nop
    3666:	b004      	add	sp, #16
    3668:	4770      	bx	lr
    366a:	bf00      	nop
    366c:	40048000 	.word	0x40048000

00003670 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3670:	b084      	sub	sp, #16
    3672:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3674:	9b01      	ldr	r3, [sp, #4]
    3676:	685b      	ldr	r3, [r3, #4]
    3678:	4a0a      	ldr	r2, [pc, #40]	; (36a4 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    367a:	5cd3      	ldrb	r3, [r2, r3]
    367c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    367e:	4b0a      	ldr	r3, [pc, #40]	; (36a8 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3680:	685b      	ldr	r3, [r3, #4]
    3682:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    3684:	9b02      	ldr	r3, [sp, #8]
    3686:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    368a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    368c:	9b03      	ldr	r3, [sp, #12]
    368e:	011b      	lsls	r3, r3, #4
    3690:	9a02      	ldr	r2, [sp, #8]
    3692:	4313      	orrs	r3, r2
    3694:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    3696:	4a04      	ldr	r2, [pc, #16]	; (36a8 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    3698:	9b02      	ldr	r3, [sp, #8]
    369a:	6053      	str	r3, [r2, #4]
}
    369c:	bf00      	nop
    369e:	b004      	add	sp, #16
    36a0:	4770      	bx	lr
    36a2:	bf00      	nop
    36a4:	0000701c 	.word	0x0000701c
    36a8:	40048000 	.word	0x40048000

000036ac <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    36ac:	b084      	sub	sp, #16
    36ae:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    36b0:	9b01      	ldr	r3, [sp, #4]
    36b2:	681a      	ldr	r2, [r3, #0]
    36b4:	490f      	ldr	r1, [pc, #60]	; (36f4 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    36b6:	4613      	mov	r3, r2
    36b8:	00db      	lsls	r3, r3, #3
    36ba:	4413      	add	r3, r2
    36bc:	440b      	add	r3, r1
    36be:	3304      	adds	r3, #4
    36c0:	781b      	ldrb	r3, [r3, #0]
    36c2:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    36c4:	4a0c      	ldr	r2, [pc, #48]	; (36f8 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    36c6:	9b03      	ldr	r3, [sp, #12]
    36c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    36cc:	490a      	ldr	r1, [pc, #40]	; (36f8 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    36ce:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    36d2:	9b03      	ldr	r3, [sp, #12]
    36d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    36d8:	4a07      	ldr	r2, [pc, #28]	; (36f8 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    36da:	9b03      	ldr	r3, [sp, #12]
    36dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    36e0:	4905      	ldr	r1, [pc, #20]	; (36f8 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    36e2:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    36e6:	9b03      	ldr	r3, [sp, #12]
    36e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    36ec:	bf00      	nop
    36ee:	b004      	add	sp, #16
    36f0:	4770      	bx	lr
    36f2:	bf00      	nop
    36f4:	00006d0c 	.word	0x00006d0c
    36f8:	40065000 	.word	0x40065000

000036fc <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    36fc:	b086      	sub	sp, #24
    36fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    3700:	9b01      	ldr	r3, [sp, #4]
    3702:	681a      	ldr	r2, [r3, #0]
    3704:	4912      	ldr	r1, [pc, #72]	; (3750 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    3706:	4613      	mov	r3, r2
    3708:	00db      	lsls	r3, r3, #3
    370a:	4413      	add	r3, r2
    370c:	440b      	add	r3, r1
    370e:	3304      	adds	r3, #4
    3710:	781b      	ldrb	r3, [r3, #0]
    3712:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3714:	9b01      	ldr	r3, [sp, #4]
    3716:	685b      	ldr	r3, [r3, #4]
    3718:	4a0e      	ldr	r2, [pc, #56]	; (3754 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    371a:	5cd3      	ldrb	r3, [r2, r3]
    371c:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    371e:	4a0e      	ldr	r2, [pc, #56]	; (3758 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3720:	9b05      	ldr	r3, [sp, #20]
    3722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3726:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    3728:	9b03      	ldr	r3, [sp, #12]
    372a:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    372e:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    3730:	9b04      	ldr	r3, [sp, #16]
    3732:	061b      	lsls	r3, r3, #24
    3734:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    3738:	9a03      	ldr	r2, [sp, #12]
    373a:	4313      	orrs	r3, r2
    373c:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    373e:	4906      	ldr	r1, [pc, #24]	; (3758 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    3740:	9b05      	ldr	r3, [sp, #20]
    3742:	9a03      	ldr	r2, [sp, #12]
    3744:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    3748:	bf00      	nop
    374a:	b006      	add	sp, #24
    374c:	4770      	bx	lr
    374e:	bf00      	nop
    3750:	00006d0c 	.word	0x00006d0c
    3754:	000070a4 	.word	0x000070a4
    3758:	40065000 	.word	0x40065000

0000375c <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    375c:	b084      	sub	sp, #16
    375e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    3760:	4b0b      	ldr	r3, [pc, #44]	; (3790 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    3762:	7f1b      	ldrb	r3, [r3, #28]
    3764:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    3766:	4b0b      	ldr	r3, [pc, #44]	; (3794 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3768:	685b      	ldr	r3, [r3, #4]
    376a:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    376c:	9b02      	ldr	r3, [sp, #8]
    376e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    3772:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    3774:	9b03      	ldr	r3, [sp, #12]
    3776:	031b      	lsls	r3, r3, #12
    3778:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    377c:	9a02      	ldr	r2, [sp, #8]
    377e:	4313      	orrs	r3, r2
    3780:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    3782:	4a04      	ldr	r2, [pc, #16]	; (3794 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    3784:	9b02      	ldr	r3, [sp, #8]
    3786:	6053      	str	r3, [r2, #4]
}
    3788:	bf00      	nop
    378a:	b004      	add	sp, #16
    378c:	4770      	bx	lr
    378e:	bf00      	nop
    3790:	0000701c 	.word	0x0000701c
    3794:	40048000 	.word	0x40048000

00003798 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    3798:	b084      	sub	sp, #16
    379a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    379c:	9b01      	ldr	r3, [sp, #4]
    379e:	685b      	ldr	r3, [r3, #4]
    37a0:	4a0b      	ldr	r2, [pc, #44]	; (37d0 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    37a2:	5cd3      	ldrb	r3, [r2, r3]
    37a4:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    37a6:	4b0b      	ldr	r3, [pc, #44]	; (37d4 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    37a8:	685b      	ldr	r3, [r3, #4]
    37aa:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    37ac:	9b02      	ldr	r3, [sp, #8]
    37ae:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    37b2:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    37b4:	9b03      	ldr	r3, [sp, #12]
    37b6:	031b      	lsls	r3, r3, #12
    37b8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    37bc:	9a02      	ldr	r2, [sp, #8]
    37be:	4313      	orrs	r3, r2
    37c0:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    37c2:	4a04      	ldr	r2, [pc, #16]	; (37d4 <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    37c4:	9b02      	ldr	r3, [sp, #8]
    37c6:	6053      	str	r3, [r2, #4]
}
    37c8:	bf00      	nop
    37ca:	b004      	add	sp, #16
    37cc:	4770      	bx	lr
    37ce:	bf00      	nop
    37d0:	0000701c 	.word	0x0000701c
    37d4:	40048000 	.word	0x40048000

000037d8 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    37d8:	b500      	push	{lr}
    37da:	b085      	sub	sp, #20
    37dc:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    37de:	2300      	movs	r3, #0
    37e0:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    37e4:	9b01      	ldr	r3, [sp, #4]
    37e6:	2b00      	cmp	r3, #0
    37e8:	d037      	beq.n	385a <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    37ea:	2300      	movs	r3, #0
    37ec:	9303      	str	r3, [sp, #12]
    37ee:	e02b      	b.n	3848 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    37f0:	4b29      	ldr	r3, [pc, #164]	; (3898 <DisableSafeClock+0xc0>)
    37f2:	6819      	ldr	r1, [r3, #0]
    37f4:	9a03      	ldr	r2, [sp, #12]
    37f6:	4613      	mov	r3, r2
    37f8:	005b      	lsls	r3, r3, #1
    37fa:	4413      	add	r3, r2
    37fc:	009b      	lsls	r3, r3, #2
    37fe:	440b      	add	r3, r1
    3800:	3314      	adds	r3, #20
    3802:	681b      	ldr	r3, [r3, #0]
    3804:	2b05      	cmp	r3, #5
    3806:	d11c      	bne.n	3842 <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    3808:	2301      	movs	r3, #1
    380a:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    380e:	4b22      	ldr	r3, [pc, #136]	; (3898 <DisableSafeClock+0xc0>)
    3810:	6819      	ldr	r1, [r3, #0]
    3812:	9a03      	ldr	r2, [sp, #12]
    3814:	4613      	mov	r3, r2
    3816:	005b      	lsls	r3, r3, #1
    3818:	4413      	add	r3, r2
    381a:	009b      	lsls	r3, r3, #2
    381c:	440b      	add	r3, r1
    381e:	3318      	adds	r3, #24
    3820:	881b      	ldrh	r3, [r3, #0]
    3822:	2b00      	cmp	r3, #0
    3824:	d118      	bne.n	3858 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3826:	4b1d      	ldr	r3, [pc, #116]	; (389c <DisableSafeClock+0xc4>)
    3828:	791b      	ldrb	r3, [r3, #4]
    382a:	4619      	mov	r1, r3
    382c:	4a1c      	ldr	r2, [pc, #112]	; (38a0 <DisableSafeClock+0xc8>)
    382e:	460b      	mov	r3, r1
    3830:	005b      	lsls	r3, r3, #1
    3832:	440b      	add	r3, r1
    3834:	009b      	lsls	r3, r3, #2
    3836:	4413      	add	r3, r2
    3838:	3308      	adds	r3, #8
    383a:	681b      	ldr	r3, [r3, #0]
    383c:	2005      	movs	r0, #5
    383e:	4798      	blx	r3
                }
                break;
    3840:	e00a      	b.n	3858 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3842:	9b03      	ldr	r3, [sp, #12]
    3844:	3301      	adds	r3, #1
    3846:	9303      	str	r3, [sp, #12]
    3848:	4b13      	ldr	r3, [pc, #76]	; (3898 <DisableSafeClock+0xc0>)
    384a:	681b      	ldr	r3, [r3, #0]
    384c:	7a1b      	ldrb	r3, [r3, #8]
    384e:	461a      	mov	r2, r3
    3850:	9b03      	ldr	r3, [sp, #12]
    3852:	4293      	cmp	r3, r2
    3854:	d3cc      	bcc.n	37f0 <DisableSafeClock+0x18>
    3856:	e000      	b.n	385a <DisableSafeClock+0x82>
                break;
    3858:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    385a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    385e:	f083 0301 	eor.w	r3, r3, #1
    3862:	b2db      	uxtb	r3, r3
    3864:	2b00      	cmp	r3, #0
    3866:	d013      	beq.n	3890 <DisableSafeClock+0xb8>
    3868:	4b0e      	ldr	r3, [pc, #56]	; (38a4 <DisableSafeClock+0xcc>)
    386a:	781b      	ldrb	r3, [r3, #0]
    386c:	f083 0301 	eor.w	r3, r3, #1
    3870:	b2db      	uxtb	r3, r3
    3872:	2b00      	cmp	r3, #0
    3874:	d00c      	beq.n	3890 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    3876:	4b09      	ldr	r3, [pc, #36]	; (389c <DisableSafeClock+0xc4>)
    3878:	791b      	ldrb	r3, [r3, #4]
    387a:	4619      	mov	r1, r3
    387c:	4a08      	ldr	r2, [pc, #32]	; (38a0 <DisableSafeClock+0xc8>)
    387e:	460b      	mov	r3, r1
    3880:	005b      	lsls	r3, r3, #1
    3882:	440b      	add	r3, r1
    3884:	009b      	lsls	r3, r3, #2
    3886:	4413      	add	r3, r2
    3888:	3308      	adds	r3, #8
    388a:	681b      	ldr	r3, [r3, #0]
    388c:	2005      	movs	r0, #5
    388e:	4798      	blx	r3
    }
}
    3890:	bf00      	nop
    3892:	b005      	add	sp, #20
    3894:	f85d fb04 	ldr.w	pc, [sp], #4
    3898:	1fff8b98 	.word	0x1fff8b98
    389c:	00006c9c 	.word	0x00006c9c
    38a0:	000072cc 	.word	0x000072cc
    38a4:	1fff8b18 	.word	0x1fff8b18

000038a8 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    38a8:	4b06      	ldr	r3, [pc, #24]	; (38c4 <SetFircToResetValue_TrustedCall+0x1c>)
    38aa:	2200      	movs	r2, #0
    38ac:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    38b0:	4b04      	ldr	r3, [pc, #16]	; (38c4 <SetFircToResetValue_TrustedCall+0x1c>)
    38b2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    38b6:	4a03      	ldr	r2, [pc, #12]	; (38c4 <SetFircToResetValue_TrustedCall+0x1c>)
    38b8:	f043 0301 	orr.w	r3, r3, #1
    38bc:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    38c0:	bf00      	nop
    38c2:	4770      	bx	lr
    38c4:	40064000 	.word	0x40064000

000038c8 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    38c8:	b084      	sub	sp, #16
    38ca:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    38cc:	2303      	movs	r3, #3
    38ce:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    38d0:	2300      	movs	r3, #0
    38d2:	9302      	str	r3, [sp, #8]
    38d4:	e028      	b.n	3928 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    38d6:	9b01      	ldr	r3, [sp, #4]
    38d8:	9a02      	ldr	r2, [sp, #8]
    38da:	320d      	adds	r2, #13
    38dc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    38e0:	2b28      	cmp	r3, #40	; 0x28
    38e2:	d10b      	bne.n	38fc <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    38e4:	9a01      	ldr	r2, [sp, #4]
    38e6:	9b02      	ldr	r3, [sp, #8]
    38e8:	330d      	adds	r3, #13
    38ea:	00db      	lsls	r3, r3, #3
    38ec:	4413      	add	r3, r2
    38ee:	685b      	ldr	r3, [r3, #4]
    38f0:	4a2b      	ldr	r2, [pc, #172]	; (39a0 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    38f2:	5cd3      	ldrb	r3, [r2, r3]
    38f4:	011b      	lsls	r3, r3, #4
    38f6:	9a03      	ldr	r2, [sp, #12]
    38f8:	4313      	orrs	r3, r2
    38fa:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    38fc:	9b01      	ldr	r3, [sp, #4]
    38fe:	9a02      	ldr	r2, [sp, #8]
    3900:	320d      	adds	r2, #13
    3902:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3906:	2b29      	cmp	r3, #41	; 0x29
    3908:	d10b      	bne.n	3922 <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    390a:	9a01      	ldr	r2, [sp, #4]
    390c:	9b02      	ldr	r3, [sp, #8]
    390e:	330d      	adds	r3, #13
    3910:	00db      	lsls	r3, r3, #3
    3912:	4413      	add	r3, r2
    3914:	685b      	ldr	r3, [r3, #4]
    3916:	4a23      	ldr	r2, [pc, #140]	; (39a4 <SetSimLpoclksRegister_TrustedCall+0xdc>)
    3918:	5cd3      	ldrb	r3, [r2, r3]
    391a:	009b      	lsls	r3, r3, #2
    391c:	9a03      	ldr	r2, [sp, #12]
    391e:	4313      	orrs	r3, r2
    3920:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    3922:	9b02      	ldr	r3, [sp, #8]
    3924:	3301      	adds	r3, #1
    3926:	9302      	str	r3, [sp, #8]
    3928:	9b01      	ldr	r3, [sp, #4]
    392a:	7adb      	ldrb	r3, [r3, #11]
    392c:	461a      	mov	r2, r3
    392e:	9b02      	ldr	r3, [sp, #8]
    3930:	4293      	cmp	r3, r2
    3932:	d3d0      	bcc.n	38d6 <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3934:	2300      	movs	r3, #0
    3936:	9302      	str	r3, [sp, #8]
    3938:	e026      	b.n	3988 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    393a:	9a01      	ldr	r2, [sp, #4]
    393c:	9b02      	ldr	r3, [sp, #8]
    393e:	334e      	adds	r3, #78	; 0x4e
    3940:	00db      	lsls	r3, r3, #3
    3942:	4413      	add	r3, r2
    3944:	685b      	ldr	r3, [r3, #4]
    3946:	2b12      	cmp	r3, #18
    3948:	d109      	bne.n	395e <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    394a:	9a01      	ldr	r2, [sp, #4]
    394c:	9b02      	ldr	r3, [sp, #8]
    394e:	334e      	adds	r3, #78	; 0x4e
    3950:	00db      	lsls	r3, r3, #3
    3952:	4413      	add	r3, r2
    3954:	891b      	ldrh	r3, [r3, #8]
    3956:	005b      	lsls	r3, r3, #1
    3958:	9a03      	ldr	r2, [sp, #12]
    395a:	4313      	orrs	r3, r2
    395c:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    395e:	9a01      	ldr	r2, [sp, #4]
    3960:	9b02      	ldr	r3, [sp, #8]
    3962:	334e      	adds	r3, #78	; 0x4e
    3964:	00db      	lsls	r3, r3, #3
    3966:	4413      	add	r3, r2
    3968:	685b      	ldr	r3, [r3, #4]
    396a:	2b13      	cmp	r3, #19
    396c:	d109      	bne.n	3982 <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    396e:	9a01      	ldr	r2, [sp, #4]
    3970:	9b02      	ldr	r3, [sp, #8]
    3972:	334e      	adds	r3, #78	; 0x4e
    3974:	00db      	lsls	r3, r3, #3
    3976:	4413      	add	r3, r2
    3978:	891b      	ldrh	r3, [r3, #8]
    397a:	461a      	mov	r2, r3
    397c:	9b03      	ldr	r3, [sp, #12]
    397e:	4313      	orrs	r3, r2
    3980:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    3982:	9b02      	ldr	r3, [sp, #8]
    3984:	3301      	adds	r3, #1
    3986:	9302      	str	r3, [sp, #8]
    3988:	9b01      	ldr	r3, [sp, #4]
    398a:	7c1b      	ldrb	r3, [r3, #16]
    398c:	461a      	mov	r2, r3
    398e:	9b02      	ldr	r3, [sp, #8]
    3990:	4293      	cmp	r3, r2
    3992:	d3d2      	bcc.n	393a <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    3994:	4a04      	ldr	r2, [pc, #16]	; (39a8 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    3996:	9b03      	ldr	r3, [sp, #12]
    3998:	6113      	str	r3, [r2, #16]
}
    399a:	bf00      	nop
    399c:	b004      	add	sp, #16
    399e:	4770      	bx	lr
    39a0:	0000701c 	.word	0x0000701c
    39a4:	000070d4 	.word	0x000070d4
    39a8:	40048000 	.word	0x40048000

000039ac <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    39ac:	b500      	push	{lr}
    39ae:	b089      	sub	sp, #36	; 0x24
    39b0:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    39b2:	2300      	movs	r3, #0
    39b4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    39b8:	4a21      	ldr	r2, [pc, #132]	; (3a40 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    39ba:	9b01      	ldr	r3, [sp, #4]
    39bc:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    39be:	4b21      	ldr	r3, [pc, #132]	; (3a44 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    39c0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    39c4:	f003 0301 	and.w	r3, r3, #1
    39c8:	2b00      	cmp	r3, #0
    39ca:	d12e      	bne.n	3a2a <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    39cc:	4b1e      	ldr	r3, [pc, #120]	; (3a48 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    39ce:	2200      	movs	r2, #0
    39d0:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    39d2:	f7ff ff69 	bl	38a8 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    39d6:	aa03      	add	r2, sp, #12
    39d8:	a904      	add	r1, sp, #16
    39da:	a805      	add	r0, sp, #20
    39dc:	f24c 3350 	movw	r3, #50000	; 0xc350
    39e0:	f7fe f8ae 	bl	1b40 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    39e4:	4b17      	ldr	r3, [pc, #92]	; (3a44 <Clock_Ip_SpecificPlatformInitClock+0x98>)
    39e6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    39ea:	0e1b      	lsrs	r3, r3, #24
    39ec:	f003 0301 	and.w	r3, r3, #1
    39f0:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    39f2:	9a03      	ldr	r2, [sp, #12]
    39f4:	a904      	add	r1, sp, #16
    39f6:	ab05      	add	r3, sp, #20
    39f8:	4618      	mov	r0, r3
    39fa:	f7fe f8bb 	bl	1b74 <Clock_Ip_TimeoutExpired>
    39fe:	4603      	mov	r3, r0
    3a00:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    3a04:	9b06      	ldr	r3, [sp, #24]
    3a06:	2b00      	cmp	r3, #0
    3a08:	d106      	bne.n	3a18 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    3a0a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3a0e:	f083 0301 	eor.w	r3, r3, #1
    3a12:	b2db      	uxtb	r3, r3
    3a14:	2b00      	cmp	r3, #0
    3a16:	d1e5      	bne.n	39e4 <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    3a18:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3a1c:	2b00      	cmp	r3, #0
    3a1e:	d007      	beq.n	3a30 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3a20:	2105      	movs	r1, #5
    3a22:	2001      	movs	r0, #1
    3a24:	f7fe f87c 	bl	1b20 <Clock_Ip_ReportClockErrors>
    3a28:	e002      	b.n	3a30 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    3a2a:	4b07      	ldr	r3, [pc, #28]	; (3a48 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    3a2c:	2201      	movs	r2, #1
    3a2e:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    3a30:	9801      	ldr	r0, [sp, #4]
    3a32:	f7ff ff49 	bl	38c8 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    3a36:	bf00      	nop
    3a38:	b009      	add	sp, #36	; 0x24
    3a3a:	f85d fb04 	ldr.w	pc, [sp], #4
    3a3e:	bf00      	nop
    3a40:	1fff8b98 	.word	0x1fff8b98
    3a44:	40064000 	.word	0x40064000
    3a48:	1fff8b18 	.word	0x1fff8b18

00003a4c <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    3a4c:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    3a4e:	2300      	movs	r3, #0
    3a50:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3a52:	4b29      	ldr	r3, [pc, #164]	; (3af8 <getFircConfig+0xac>)
    3a54:	681b      	ldr	r3, [r3, #0]
    3a56:	2b00      	cmp	r3, #0
    3a58:	d024      	beq.n	3aa4 <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3a5a:	2300      	movs	r3, #0
    3a5c:	9301      	str	r3, [sp, #4]
    3a5e:	e01a      	b.n	3a96 <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    3a60:	4b25      	ldr	r3, [pc, #148]	; (3af8 <getFircConfig+0xac>)
    3a62:	6819      	ldr	r1, [r3, #0]
    3a64:	9a01      	ldr	r2, [sp, #4]
    3a66:	4613      	mov	r3, r2
    3a68:	005b      	lsls	r3, r3, #1
    3a6a:	4413      	add	r3, r2
    3a6c:	009b      	lsls	r3, r3, #2
    3a6e:	440b      	add	r3, r1
    3a70:	3314      	adds	r3, #20
    3a72:	681b      	ldr	r3, [r3, #0]
    3a74:	2b05      	cmp	r3, #5
    3a76:	d10b      	bne.n	3a90 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    3a78:	4b1f      	ldr	r3, [pc, #124]	; (3af8 <getFircConfig+0xac>)
    3a7a:	6819      	ldr	r1, [r3, #0]
    3a7c:	9a01      	ldr	r2, [sp, #4]
    3a7e:	4613      	mov	r3, r2
    3a80:	005b      	lsls	r3, r3, #1
    3a82:	4413      	add	r3, r2
    3a84:	009b      	lsls	r3, r3, #2
    3a86:	3310      	adds	r3, #16
    3a88:	440b      	add	r3, r1
    3a8a:	3304      	adds	r3, #4
    3a8c:	9300      	str	r3, [sp, #0]
                break;
    3a8e:	e009      	b.n	3aa4 <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    3a90:	9b01      	ldr	r3, [sp, #4]
    3a92:	3301      	adds	r3, #1
    3a94:	9301      	str	r3, [sp, #4]
    3a96:	4b18      	ldr	r3, [pc, #96]	; (3af8 <getFircConfig+0xac>)
    3a98:	681b      	ldr	r3, [r3, #0]
    3a9a:	7a1b      	ldrb	r3, [r3, #8]
    3a9c:	461a      	mov	r2, r3
    3a9e:	9b01      	ldr	r3, [sp, #4]
    3aa0:	4293      	cmp	r3, r2
    3aa2:	d3dd      	bcc.n	3a60 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3aa4:	9b00      	ldr	r3, [sp, #0]
    3aa6:	2b00      	cmp	r3, #0
    3aa8:	d121      	bne.n	3aee <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    3aaa:	4b14      	ldr	r3, [pc, #80]	; (3afc <getFircConfig+0xb0>)
    3aac:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    3aae:	4b13      	ldr	r3, [pc, #76]	; (3afc <getFircConfig+0xb0>)
    3ab0:	2205      	movs	r2, #5
    3ab2:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    3ab4:	4b12      	ldr	r3, [pc, #72]	; (3b00 <getFircConfig+0xb4>)
    3ab6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3aba:	b29b      	uxth	r3, r3
    3abc:	f003 0301 	and.w	r3, r3, #1
    3ac0:	b29a      	uxth	r2, r3
    3ac2:	4b0e      	ldr	r3, [pc, #56]	; (3afc <getFircConfig+0xb0>)
    3ac4:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    3ac6:	4b0e      	ldr	r3, [pc, #56]	; (3b00 <getFircConfig+0xb4>)
    3ac8:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3acc:	b2db      	uxtb	r3, r3
    3ace:	f003 0303 	and.w	r3, r3, #3
    3ad2:	b2da      	uxtb	r2, r3
    3ad4:	4b09      	ldr	r3, [pc, #36]	; (3afc <getFircConfig+0xb0>)
    3ad6:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    3ad8:	4b09      	ldr	r3, [pc, #36]	; (3b00 <getFircConfig+0xb4>)
    3ada:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ade:	b2db      	uxtb	r3, r3
    3ae0:	10db      	asrs	r3, r3, #3
    3ae2:	b2db      	uxtb	r3, r3
    3ae4:	f003 0301 	and.w	r3, r3, #1
    3ae8:	b2da      	uxtb	r2, r3
    3aea:	4b04      	ldr	r3, [pc, #16]	; (3afc <getFircConfig+0xb0>)
    3aec:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    3aee:	9b00      	ldr	r3, [sp, #0]
}
    3af0:	4618      	mov	r0, r3
    3af2:	b002      	add	sp, #8
    3af4:	4770      	bx	lr
    3af6:	bf00      	nop
    3af8:	1fff8b98 	.word	0x1fff8b98
    3afc:	1fff8c04 	.word	0x1fff8c04
    3b00:	40064000 	.word	0x40064000

00003b04 <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    3b04:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    3b06:	2300      	movs	r3, #0
    3b08:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3b0a:	4b20      	ldr	r3, [pc, #128]	; (3b8c <getSoscConfig+0x88>)
    3b0c:	681b      	ldr	r3, [r3, #0]
    3b0e:	2b00      	cmp	r3, #0
    3b10:	d024      	beq.n	3b5c <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    3b12:	2300      	movs	r3, #0
    3b14:	9301      	str	r3, [sp, #4]
    3b16:	e01a      	b.n	3b4e <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    3b18:	4b1c      	ldr	r3, [pc, #112]	; (3b8c <getSoscConfig+0x88>)
    3b1a:	6819      	ldr	r1, [r3, #0]
    3b1c:	9a01      	ldr	r2, [sp, #4]
    3b1e:	4613      	mov	r3, r2
    3b20:	009b      	lsls	r3, r3, #2
    3b22:	4413      	add	r3, r2
    3b24:	009b      	lsls	r3, r3, #2
    3b26:	440b      	add	r3, r1
    3b28:	332c      	adds	r3, #44	; 0x2c
    3b2a:	681b      	ldr	r3, [r3, #0]
    3b2c:	2b08      	cmp	r3, #8
    3b2e:	d10b      	bne.n	3b48 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    3b30:	4b16      	ldr	r3, [pc, #88]	; (3b8c <getSoscConfig+0x88>)
    3b32:	6819      	ldr	r1, [r3, #0]
    3b34:	9a01      	ldr	r2, [sp, #4]
    3b36:	4613      	mov	r3, r2
    3b38:	009b      	lsls	r3, r3, #2
    3b3a:	4413      	add	r3, r2
    3b3c:	009b      	lsls	r3, r3, #2
    3b3e:	3328      	adds	r3, #40	; 0x28
    3b40:	440b      	add	r3, r1
    3b42:	3304      	adds	r3, #4
    3b44:	9300      	str	r3, [sp, #0]
                break;
    3b46:	e009      	b.n	3b5c <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    3b48:	9b01      	ldr	r3, [sp, #4]
    3b4a:	3301      	adds	r3, #1
    3b4c:	9301      	str	r3, [sp, #4]
    3b4e:	4b0f      	ldr	r3, [pc, #60]	; (3b8c <getSoscConfig+0x88>)
    3b50:	681b      	ldr	r3, [r3, #0]
    3b52:	7a5b      	ldrb	r3, [r3, #9]
    3b54:	461a      	mov	r2, r3
    3b56:	9b01      	ldr	r3, [sp, #4]
    3b58:	4293      	cmp	r3, r2
    3b5a:	d3dd      	bcc.n	3b18 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3b5c:	9b00      	ldr	r3, [sp, #0]
    3b5e:	2b00      	cmp	r3, #0
    3b60:	d110      	bne.n	3b84 <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    3b62:	4b0b      	ldr	r3, [pc, #44]	; (3b90 <getSoscConfig+0x8c>)
    3b64:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    3b66:	4b0a      	ldr	r3, [pc, #40]	; (3b90 <getSoscConfig+0x8c>)
    3b68:	2208      	movs	r2, #8
    3b6a:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    3b6c:	4b09      	ldr	r3, [pc, #36]	; (3b94 <getSoscConfig+0x90>)
    3b6e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3b72:	b29b      	uxth	r3, r3
    3b74:	f003 0301 	and.w	r3, r3, #1
    3b78:	b29a      	uxth	r2, r3
    3b7a:	4b05      	ldr	r3, [pc, #20]	; (3b90 <getSoscConfig+0x8c>)
    3b7c:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    3b7e:	4b04      	ldr	r3, [pc, #16]	; (3b90 <getSoscConfig+0x8c>)
    3b80:	4a05      	ldr	r2, [pc, #20]	; (3b98 <getSoscConfig+0x94>)
    3b82:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    3b84:	9b00      	ldr	r3, [sp, #0]
}
    3b86:	4618      	mov	r0, r3
    3b88:	b002      	add	sp, #8
    3b8a:	4770      	bx	lr
    3b8c:	1fff8b98 	.word	0x1fff8b98
    3b90:	1fff8c10 	.word	0x1fff8c10
    3b94:	40064000 	.word	0x40064000
    3b98:	02625a00 	.word	0x02625a00

00003b9c <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    3b9c:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    3b9e:	2300      	movs	r3, #0
    3ba0:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    3ba2:	4b28      	ldr	r3, [pc, #160]	; (3c44 <getSpllConfig+0xa8>)
    3ba4:	681b      	ldr	r3, [r3, #0]
    3ba6:	2b00      	cmp	r3, #0
    3ba8:	d023      	beq.n	3bf2 <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    3baa:	2300      	movs	r3, #0
    3bac:	9301      	str	r3, [sp, #4]
    3bae:	e019      	b.n	3be4 <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    3bb0:	4b24      	ldr	r3, [pc, #144]	; (3c44 <getSpllConfig+0xa8>)
    3bb2:	6819      	ldr	r1, [r3, #0]
    3bb4:	9a01      	ldr	r2, [sp, #4]
    3bb6:	4613      	mov	r3, r2
    3bb8:	009b      	lsls	r3, r3, #2
    3bba:	4413      	add	r3, r2
    3bbc:	00db      	lsls	r3, r3, #3
    3bbe:	440b      	add	r3, r1
    3bc0:	3340      	adds	r3, #64	; 0x40
    3bc2:	681b      	ldr	r3, [r3, #0]
    3bc4:	2b09      	cmp	r3, #9
    3bc6:	d10a      	bne.n	3bde <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    3bc8:	4b1e      	ldr	r3, [pc, #120]	; (3c44 <getSpllConfig+0xa8>)
    3bca:	6819      	ldr	r1, [r3, #0]
    3bcc:	9a01      	ldr	r2, [sp, #4]
    3bce:	4613      	mov	r3, r2
    3bd0:	009b      	lsls	r3, r3, #2
    3bd2:	4413      	add	r3, r2
    3bd4:	00db      	lsls	r3, r3, #3
    3bd6:	3340      	adds	r3, #64	; 0x40
    3bd8:	440b      	add	r3, r1
    3bda:	9300      	str	r3, [sp, #0]
                break;
    3bdc:	e009      	b.n	3bf2 <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    3bde:	9b01      	ldr	r3, [sp, #4]
    3be0:	3301      	adds	r3, #1
    3be2:	9301      	str	r3, [sp, #4]
    3be4:	4b17      	ldr	r3, [pc, #92]	; (3c44 <getSpllConfig+0xa8>)
    3be6:	681b      	ldr	r3, [r3, #0]
    3be8:	7a9b      	ldrb	r3, [r3, #10]
    3bea:	461a      	mov	r2, r3
    3bec:	9b01      	ldr	r3, [sp, #4]
    3bee:	4293      	cmp	r3, r2
    3bf0:	d3de      	bcc.n	3bb0 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3bf2:	9b00      	ldr	r3, [sp, #0]
    3bf4:	2b00      	cmp	r3, #0
    3bf6:	d121      	bne.n	3c3c <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    3bf8:	4b13      	ldr	r3, [pc, #76]	; (3c48 <getSpllConfig+0xac>)
    3bfa:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    3bfc:	4b12      	ldr	r3, [pc, #72]	; (3c48 <getSpllConfig+0xac>)
    3bfe:	2209      	movs	r2, #9
    3c00:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    3c02:	4b12      	ldr	r3, [pc, #72]	; (3c4c <getSpllConfig+0xb0>)
    3c04:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    3c08:	b29b      	uxth	r3, r3
    3c0a:	f003 0301 	and.w	r3, r3, #1
    3c0e:	b29a      	uxth	r2, r3
    3c10:	4b0d      	ldr	r3, [pc, #52]	; (3c48 <getSpllConfig+0xac>)
    3c12:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    3c14:	4b0d      	ldr	r3, [pc, #52]	; (3c4c <getSpllConfig+0xb0>)
    3c16:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3c1a:	0a1b      	lsrs	r3, r3, #8
    3c1c:	b2db      	uxtb	r3, r3
    3c1e:	f003 0307 	and.w	r3, r3, #7
    3c22:	b2da      	uxtb	r2, r3
    3c24:	4b08      	ldr	r3, [pc, #32]	; (3c48 <getSpllConfig+0xac>)
    3c26:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    3c28:	4b08      	ldr	r3, [pc, #32]	; (3c4c <getSpllConfig+0xb0>)
    3c2a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3c2e:	0c1b      	lsrs	r3, r3, #16
    3c30:	b2db      	uxtb	r3, r3
    3c32:	f003 031f 	and.w	r3, r3, #31
    3c36:	b2da      	uxtb	r2, r3
    3c38:	4b03      	ldr	r3, [pc, #12]	; (3c48 <getSpllConfig+0xac>)
    3c3a:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    3c3c:	9b00      	ldr	r3, [sp, #0]
}
    3c3e:	4618      	mov	r0, r3
    3c40:	b002      	add	sp, #8
    3c42:	4770      	bx	lr
    3c44:	1fff8b98 	.word	0x1fff8b98
    3c48:	1fff8c24 	.word	0x1fff8c24
    3c4c:	40064000 	.word	0x40064000

00003c50 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    3c50:	b086      	sub	sp, #24
    3c52:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    3c54:	2300      	movs	r3, #0
    3c56:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    3c58:	9b01      	ldr	r3, [sp, #4]
    3c5a:	2b1b      	cmp	r3, #27
    3c5c:	d00f      	beq.n	3c7e <getSelectorConfig+0x2e>
    3c5e:	9b01      	ldr	r3, [sp, #4]
    3c60:	2b1b      	cmp	r3, #27
    3c62:	d80f      	bhi.n	3c84 <getSelectorConfig+0x34>
    3c64:	9b01      	ldr	r3, [sp, #4]
    3c66:	2b19      	cmp	r3, #25
    3c68:	d003      	beq.n	3c72 <getSelectorConfig+0x22>
    3c6a:	9b01      	ldr	r3, [sp, #4]
    3c6c:	2b1a      	cmp	r3, #26
    3c6e:	d003      	beq.n	3c78 <getSelectorConfig+0x28>
    3c70:	e008      	b.n	3c84 <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    3c72:	2300      	movs	r3, #0
    3c74:	9304      	str	r3, [sp, #16]
            break;
    3c76:	e008      	b.n	3c8a <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    3c78:	2301      	movs	r3, #1
    3c7a:	9304      	str	r3, [sp, #16]
            break;
    3c7c:	e005      	b.n	3c8a <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    3c7e:	2302      	movs	r3, #2
    3c80:	9304      	str	r3, [sp, #16]
            break;
    3c82:	e002      	b.n	3c8a <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    3c84:	2300      	movs	r3, #0
    3c86:	9304      	str	r3, [sp, #16]
            break;
    3c88:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    3c8a:	4b36      	ldr	r3, [pc, #216]	; (3d64 <getSelectorConfig+0x114>)
    3c8c:	681b      	ldr	r3, [r3, #0]
    3c8e:	2b00      	cmp	r3, #0
    3c90:	d01d      	beq.n	3cce <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    3c92:	2300      	movs	r3, #0
    3c94:	9303      	str	r3, [sp, #12]
    3c96:	e013      	b.n	3cc0 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    3c98:	4b32      	ldr	r3, [pc, #200]	; (3d64 <getSelectorConfig+0x114>)
    3c9a:	681b      	ldr	r3, [r3, #0]
    3c9c:	9a03      	ldr	r2, [sp, #12]
    3c9e:	320d      	adds	r2, #13
    3ca0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3ca4:	9a01      	ldr	r2, [sp, #4]
    3ca6:	429a      	cmp	r2, r3
    3ca8:	d107      	bne.n	3cba <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    3caa:	4b2e      	ldr	r3, [pc, #184]	; (3d64 <getSelectorConfig+0x114>)
    3cac:	681a      	ldr	r2, [r3, #0]
    3cae:	9b03      	ldr	r3, [sp, #12]
    3cb0:	330d      	adds	r3, #13
    3cb2:	00db      	lsls	r3, r3, #3
    3cb4:	4413      	add	r3, r2
    3cb6:	9305      	str	r3, [sp, #20]
                break;
    3cb8:	e009      	b.n	3cce <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    3cba:	9b03      	ldr	r3, [sp, #12]
    3cbc:	3301      	adds	r3, #1
    3cbe:	9303      	str	r3, [sp, #12]
    3cc0:	4b28      	ldr	r3, [pc, #160]	; (3d64 <getSelectorConfig+0x114>)
    3cc2:	681b      	ldr	r3, [r3, #0]
    3cc4:	7adb      	ldrb	r3, [r3, #11]
    3cc6:	461a      	mov	r2, r3
    3cc8:	9b03      	ldr	r3, [sp, #12]
    3cca:	4293      	cmp	r3, r2
    3ccc:	d3e4      	bcc.n	3c98 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3cce:	9b05      	ldr	r3, [sp, #20]
    3cd0:	2b00      	cmp	r3, #0
    3cd2:	d140      	bne.n	3d56 <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    3cd4:	9b04      	ldr	r3, [sp, #16]
    3cd6:	00db      	lsls	r3, r3, #3
    3cd8:	4a23      	ldr	r2, [pc, #140]	; (3d68 <getSelectorConfig+0x118>)
    3cda:	4413      	add	r3, r2
    3cdc:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    3cde:	4922      	ldr	r1, [pc, #136]	; (3d68 <getSelectorConfig+0x118>)
    3ce0:	9b04      	ldr	r3, [sp, #16]
    3ce2:	9a01      	ldr	r2, [sp, #4]
    3ce4:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    3ce8:	9b01      	ldr	r3, [sp, #4]
    3cea:	2b1b      	cmp	r3, #27
    3cec:	d025      	beq.n	3d3a <getSelectorConfig+0xea>
    3cee:	9b01      	ldr	r3, [sp, #4]
    3cf0:	2b1b      	cmp	r3, #27
    3cf2:	d832      	bhi.n	3d5a <getSelectorConfig+0x10a>
    3cf4:	9b01      	ldr	r3, [sp, #4]
    3cf6:	2b19      	cmp	r3, #25
    3cf8:	d003      	beq.n	3d02 <getSelectorConfig+0xb2>
    3cfa:	9b01      	ldr	r3, [sp, #4]
    3cfc:	2b1a      	cmp	r3, #26
    3cfe:	d00e      	beq.n	3d1e <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    3d00:	e02b      	b.n	3d5a <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    3d02:	4b1a      	ldr	r3, [pc, #104]	; (3d6c <getSelectorConfig+0x11c>)
    3d04:	695b      	ldr	r3, [r3, #20]
    3d06:	0e1b      	lsrs	r3, r3, #24
    3d08:	f003 030f 	and.w	r3, r3, #15
    3d0c:	4a18      	ldr	r2, [pc, #96]	; (3d70 <getSelectorConfig+0x120>)
    3d0e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3d12:	4915      	ldr	r1, [pc, #84]	; (3d68 <getSelectorConfig+0x118>)
    3d14:	9b04      	ldr	r3, [sp, #16]
    3d16:	00db      	lsls	r3, r3, #3
    3d18:	440b      	add	r3, r1
    3d1a:	605a      	str	r2, [r3, #4]
                break;
    3d1c:	e01e      	b.n	3d5c <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    3d1e:	4b13      	ldr	r3, [pc, #76]	; (3d6c <getSelectorConfig+0x11c>)
    3d20:	699b      	ldr	r3, [r3, #24]
    3d22:	0e1b      	lsrs	r3, r3, #24
    3d24:	f003 030f 	and.w	r3, r3, #15
    3d28:	4a11      	ldr	r2, [pc, #68]	; (3d70 <getSelectorConfig+0x120>)
    3d2a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3d2e:	490e      	ldr	r1, [pc, #56]	; (3d68 <getSelectorConfig+0x118>)
    3d30:	9b04      	ldr	r3, [sp, #16]
    3d32:	00db      	lsls	r3, r3, #3
    3d34:	440b      	add	r3, r1
    3d36:	605a      	str	r2, [r3, #4]
                break;
    3d38:	e010      	b.n	3d5c <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    3d3a:	4b0c      	ldr	r3, [pc, #48]	; (3d6c <getSelectorConfig+0x11c>)
    3d3c:	69db      	ldr	r3, [r3, #28]
    3d3e:	0e1b      	lsrs	r3, r3, #24
    3d40:	f003 030f 	and.w	r3, r3, #15
    3d44:	4a0a      	ldr	r2, [pc, #40]	; (3d70 <getSelectorConfig+0x120>)
    3d46:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3d4a:	4907      	ldr	r1, [pc, #28]	; (3d68 <getSelectorConfig+0x118>)
    3d4c:	9b04      	ldr	r3, [sp, #16]
    3d4e:	00db      	lsls	r3, r3, #3
    3d50:	440b      	add	r3, r1
    3d52:	605a      	str	r2, [r3, #4]
                break;
    3d54:	e002      	b.n	3d5c <getSelectorConfig+0x10c>
        }
    }
    3d56:	bf00      	nop
    3d58:	e000      	b.n	3d5c <getSelectorConfig+0x10c>
                break;
    3d5a:	bf00      	nop

    return ReturnValue;
    3d5c:	9b05      	ldr	r3, [sp, #20]
}
    3d5e:	4618      	mov	r0, r3
    3d60:	b006      	add	sp, #24
    3d62:	4770      	bx	lr
    3d64:	1fff8b98 	.word	0x1fff8b98
    3d68:	1fff8c4c 	.word	0x1fff8c4c
    3d6c:	40064000 	.word	0x40064000
    3d70:	0000739c 	.word	0x0000739c

00003d74 <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    3d74:	b086      	sub	sp, #24
    3d76:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    3d78:	2300      	movs	r3, #0
    3d7a:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    3d7c:	2300      	movs	r3, #0
    3d7e:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    3d80:	9b01      	ldr	r3, [sp, #4]
    3d82:	2b1f      	cmp	r3, #31
    3d84:	d00f      	beq.n	3da6 <getCoreDividerConfig+0x32>
    3d86:	9b01      	ldr	r3, [sp, #4]
    3d88:	2b1f      	cmp	r3, #31
    3d8a:	d80f      	bhi.n	3dac <getCoreDividerConfig+0x38>
    3d8c:	9b01      	ldr	r3, [sp, #4]
    3d8e:	2b1d      	cmp	r3, #29
    3d90:	d003      	beq.n	3d9a <getCoreDividerConfig+0x26>
    3d92:	9b01      	ldr	r3, [sp, #4]
    3d94:	2b1e      	cmp	r3, #30
    3d96:	d003      	beq.n	3da0 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    3d98:	e008      	b.n	3dac <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    3d9a:	2300      	movs	r3, #0
    3d9c:	9304      	str	r3, [sp, #16]
            break;
    3d9e:	e006      	b.n	3dae <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    3da0:	2301      	movs	r3, #1
    3da2:	9304      	str	r3, [sp, #16]
            break;
    3da4:	e003      	b.n	3dae <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    3da6:	2302      	movs	r3, #2
    3da8:	9304      	str	r3, [sp, #16]
            break;
    3daa:	e000      	b.n	3dae <getCoreDividerConfig+0x3a>
                break;
    3dac:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    3dae:	4b41      	ldr	r3, [pc, #260]	; (3eb4 <getCoreDividerConfig+0x140>)
    3db0:	681b      	ldr	r3, [r3, #0]
    3db2:	2b00      	cmp	r3, #0
    3db4:	d026      	beq.n	3e04 <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3db6:	2300      	movs	r3, #0
    3db8:	9303      	str	r3, [sp, #12]
    3dba:	e01c      	b.n	3df6 <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    3dbc:	4b3d      	ldr	r3, [pc, #244]	; (3eb4 <getCoreDividerConfig+0x140>)
    3dbe:	6819      	ldr	r1, [r3, #0]
    3dc0:	9a03      	ldr	r2, [sp, #12]
    3dc2:	4613      	mov	r3, r2
    3dc4:	005b      	lsls	r3, r3, #1
    3dc6:	4413      	add	r3, r2
    3dc8:	009b      	lsls	r3, r3, #2
    3dca:	440b      	add	r3, r1
    3dcc:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3dd0:	681b      	ldr	r3, [r3, #0]
    3dd2:	9a01      	ldr	r2, [sp, #4]
    3dd4:	429a      	cmp	r2, r3
    3dd6:	d10b      	bne.n	3df0 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    3dd8:	4b36      	ldr	r3, [pc, #216]	; (3eb4 <getCoreDividerConfig+0x140>)
    3dda:	6819      	ldr	r1, [r3, #0]
    3ddc:	9a03      	ldr	r2, [sp, #12]
    3dde:	4613      	mov	r3, r2
    3de0:	005b      	lsls	r3, r3, #1
    3de2:	4413      	add	r3, r2
    3de4:	009b      	lsls	r3, r3, #2
    3de6:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3dea:	440b      	add	r3, r1
    3dec:	9305      	str	r3, [sp, #20]
                break;
    3dee:	e009      	b.n	3e04 <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3df0:	9b03      	ldr	r3, [sp, #12]
    3df2:	3301      	adds	r3, #1
    3df4:	9303      	str	r3, [sp, #12]
    3df6:	4b2f      	ldr	r3, [pc, #188]	; (3eb4 <getCoreDividerConfig+0x140>)
    3df8:	681b      	ldr	r3, [r3, #0]
    3dfa:	7b1b      	ldrb	r3, [r3, #12]
    3dfc:	461a      	mov	r2, r3
    3dfe:	9b03      	ldr	r3, [sp, #12]
    3e00:	4293      	cmp	r3, r2
    3e02:	d3db      	bcc.n	3dbc <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3e04:	9b05      	ldr	r3, [sp, #20]
    3e06:	2b00      	cmp	r3, #0
    3e08:	d14d      	bne.n	3ea6 <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    3e0a:	9a04      	ldr	r2, [sp, #16]
    3e0c:	4613      	mov	r3, r2
    3e0e:	005b      	lsls	r3, r3, #1
    3e10:	4413      	add	r3, r2
    3e12:	009b      	lsls	r3, r3, #2
    3e14:	4a28      	ldr	r2, [pc, #160]	; (3eb8 <getCoreDividerConfig+0x144>)
    3e16:	4413      	add	r3, r2
    3e18:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    3e1a:	4927      	ldr	r1, [pc, #156]	; (3eb8 <getCoreDividerConfig+0x144>)
    3e1c:	9a04      	ldr	r2, [sp, #16]
    3e1e:	4613      	mov	r3, r2
    3e20:	005b      	lsls	r3, r3, #1
    3e22:	4413      	add	r3, r2
    3e24:	009b      	lsls	r3, r3, #2
    3e26:	440b      	add	r3, r1
    3e28:	9a01      	ldr	r2, [sp, #4]
    3e2a:	601a      	str	r2, [r3, #0]
        switch(Name)
    3e2c:	9b01      	ldr	r3, [sp, #4]
    3e2e:	2b1f      	cmp	r3, #31
    3e30:	d029      	beq.n	3e86 <getCoreDividerConfig+0x112>
    3e32:	9b01      	ldr	r3, [sp, #4]
    3e34:	2b1f      	cmp	r3, #31
    3e36:	d838      	bhi.n	3eaa <getCoreDividerConfig+0x136>
    3e38:	9b01      	ldr	r3, [sp, #4]
    3e3a:	2b1d      	cmp	r3, #29
    3e3c:	d003      	beq.n	3e46 <getCoreDividerConfig+0xd2>
    3e3e:	9b01      	ldr	r3, [sp, #4]
    3e40:	2b1e      	cmp	r3, #30
    3e42:	d010      	beq.n	3e66 <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    3e44:	e031      	b.n	3eaa <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    3e46:	4b1d      	ldr	r3, [pc, #116]	; (3ebc <getCoreDividerConfig+0x148>)
    3e48:	695b      	ldr	r3, [r3, #20]
    3e4a:	0c1b      	lsrs	r3, r3, #16
    3e4c:	f003 030f 	and.w	r3, r3, #15
    3e50:	1c59      	adds	r1, r3, #1
    3e52:	4819      	ldr	r0, [pc, #100]	; (3eb8 <getCoreDividerConfig+0x144>)
    3e54:	9a04      	ldr	r2, [sp, #16]
    3e56:	4613      	mov	r3, r2
    3e58:	005b      	lsls	r3, r3, #1
    3e5a:	4413      	add	r3, r2
    3e5c:	009b      	lsls	r3, r3, #2
    3e5e:	4403      	add	r3, r0
    3e60:	3304      	adds	r3, #4
    3e62:	6019      	str	r1, [r3, #0]
                break;
    3e64:	e022      	b.n	3eac <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    3e66:	4b15      	ldr	r3, [pc, #84]	; (3ebc <getCoreDividerConfig+0x148>)
    3e68:	699b      	ldr	r3, [r3, #24]
    3e6a:	0c1b      	lsrs	r3, r3, #16
    3e6c:	f003 030f 	and.w	r3, r3, #15
    3e70:	1c59      	adds	r1, r3, #1
    3e72:	4811      	ldr	r0, [pc, #68]	; (3eb8 <getCoreDividerConfig+0x144>)
    3e74:	9a04      	ldr	r2, [sp, #16]
    3e76:	4613      	mov	r3, r2
    3e78:	005b      	lsls	r3, r3, #1
    3e7a:	4413      	add	r3, r2
    3e7c:	009b      	lsls	r3, r3, #2
    3e7e:	4403      	add	r3, r0
    3e80:	3304      	adds	r3, #4
    3e82:	6019      	str	r1, [r3, #0]
                break;
    3e84:	e012      	b.n	3eac <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    3e86:	4b0d      	ldr	r3, [pc, #52]	; (3ebc <getCoreDividerConfig+0x148>)
    3e88:	69db      	ldr	r3, [r3, #28]
    3e8a:	0c1b      	lsrs	r3, r3, #16
    3e8c:	f003 030f 	and.w	r3, r3, #15
    3e90:	1c59      	adds	r1, r3, #1
    3e92:	4809      	ldr	r0, [pc, #36]	; (3eb8 <getCoreDividerConfig+0x144>)
    3e94:	9a04      	ldr	r2, [sp, #16]
    3e96:	4613      	mov	r3, r2
    3e98:	005b      	lsls	r3, r3, #1
    3e9a:	4413      	add	r3, r2
    3e9c:	009b      	lsls	r3, r3, #2
    3e9e:	4403      	add	r3, r0
    3ea0:	3304      	adds	r3, #4
    3ea2:	6019      	str	r1, [r3, #0]
                break;
    3ea4:	e002      	b.n	3eac <getCoreDividerConfig+0x138>
        }
    }
    3ea6:	bf00      	nop
    3ea8:	e000      	b.n	3eac <getCoreDividerConfig+0x138>
                break;
    3eaa:	bf00      	nop

    return ReturnValue;
    3eac:	9b05      	ldr	r3, [sp, #20]
}
    3eae:	4618      	mov	r0, r3
    3eb0:	b006      	add	sp, #24
    3eb2:	4770      	bx	lr
    3eb4:	1fff8b98 	.word	0x1fff8b98
    3eb8:	1fff8c64 	.word	0x1fff8c64
    3ebc:	40064000 	.word	0x40064000

00003ec0 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    3ec0:	b086      	sub	sp, #24
    3ec2:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    3ec4:	2300      	movs	r3, #0
    3ec6:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    3ec8:	2300      	movs	r3, #0
    3eca:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    3ecc:	9b01      	ldr	r3, [sp, #4]
    3ece:	2b23      	cmp	r3, #35	; 0x23
    3ed0:	d00f      	beq.n	3ef2 <getBusDividerConfig+0x32>
    3ed2:	9b01      	ldr	r3, [sp, #4]
    3ed4:	2b23      	cmp	r3, #35	; 0x23
    3ed6:	d80f      	bhi.n	3ef8 <getBusDividerConfig+0x38>
    3ed8:	9b01      	ldr	r3, [sp, #4]
    3eda:	2b21      	cmp	r3, #33	; 0x21
    3edc:	d003      	beq.n	3ee6 <getBusDividerConfig+0x26>
    3ede:	9b01      	ldr	r3, [sp, #4]
    3ee0:	2b22      	cmp	r3, #34	; 0x22
    3ee2:	d003      	beq.n	3eec <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    3ee4:	e008      	b.n	3ef8 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    3ee6:	2300      	movs	r3, #0
    3ee8:	9304      	str	r3, [sp, #16]
            break;
    3eea:	e006      	b.n	3efa <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    3eec:	2301      	movs	r3, #1
    3eee:	9304      	str	r3, [sp, #16]
            break;
    3ef0:	e003      	b.n	3efa <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    3ef2:	2302      	movs	r3, #2
    3ef4:	9304      	str	r3, [sp, #16]
            break;
    3ef6:	e000      	b.n	3efa <getBusDividerConfig+0x3a>
                break;
    3ef8:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    3efa:	4b41      	ldr	r3, [pc, #260]	; (4000 <getBusDividerConfig+0x140>)
    3efc:	681b      	ldr	r3, [r3, #0]
    3efe:	2b00      	cmp	r3, #0
    3f00:	d026      	beq.n	3f50 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3f02:	2300      	movs	r3, #0
    3f04:	9303      	str	r3, [sp, #12]
    3f06:	e01c      	b.n	3f42 <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    3f08:	4b3d      	ldr	r3, [pc, #244]	; (4000 <getBusDividerConfig+0x140>)
    3f0a:	6819      	ldr	r1, [r3, #0]
    3f0c:	9a03      	ldr	r2, [sp, #12]
    3f0e:	4613      	mov	r3, r2
    3f10:	005b      	lsls	r3, r3, #1
    3f12:	4413      	add	r3, r2
    3f14:	009b      	lsls	r3, r3, #2
    3f16:	440b      	add	r3, r1
    3f18:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3f1c:	681b      	ldr	r3, [r3, #0]
    3f1e:	9a01      	ldr	r2, [sp, #4]
    3f20:	429a      	cmp	r2, r3
    3f22:	d10b      	bne.n	3f3c <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    3f24:	4b36      	ldr	r3, [pc, #216]	; (4000 <getBusDividerConfig+0x140>)
    3f26:	6819      	ldr	r1, [r3, #0]
    3f28:	9a03      	ldr	r2, [sp, #12]
    3f2a:	4613      	mov	r3, r2
    3f2c:	005b      	lsls	r3, r3, #1
    3f2e:	4413      	add	r3, r2
    3f30:	009b      	lsls	r3, r3, #2
    3f32:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    3f36:	440b      	add	r3, r1
    3f38:	9305      	str	r3, [sp, #20]
                break;
    3f3a:	e009      	b.n	3f50 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    3f3c:	9b03      	ldr	r3, [sp, #12]
    3f3e:	3301      	adds	r3, #1
    3f40:	9303      	str	r3, [sp, #12]
    3f42:	4b2f      	ldr	r3, [pc, #188]	; (4000 <getBusDividerConfig+0x140>)
    3f44:	681b      	ldr	r3, [r3, #0]
    3f46:	7b1b      	ldrb	r3, [r3, #12]
    3f48:	461a      	mov	r2, r3
    3f4a:	9b03      	ldr	r3, [sp, #12]
    3f4c:	4293      	cmp	r3, r2
    3f4e:	d3db      	bcc.n	3f08 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    3f50:	9b05      	ldr	r3, [sp, #20]
    3f52:	2b00      	cmp	r3, #0
    3f54:	d14d      	bne.n	3ff2 <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    3f56:	9a04      	ldr	r2, [sp, #16]
    3f58:	4613      	mov	r3, r2
    3f5a:	005b      	lsls	r3, r3, #1
    3f5c:	4413      	add	r3, r2
    3f5e:	009b      	lsls	r3, r3, #2
    3f60:	4a28      	ldr	r2, [pc, #160]	; (4004 <getBusDividerConfig+0x144>)
    3f62:	4413      	add	r3, r2
    3f64:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    3f66:	4927      	ldr	r1, [pc, #156]	; (4004 <getBusDividerConfig+0x144>)
    3f68:	9a04      	ldr	r2, [sp, #16]
    3f6a:	4613      	mov	r3, r2
    3f6c:	005b      	lsls	r3, r3, #1
    3f6e:	4413      	add	r3, r2
    3f70:	009b      	lsls	r3, r3, #2
    3f72:	440b      	add	r3, r1
    3f74:	9a01      	ldr	r2, [sp, #4]
    3f76:	601a      	str	r2, [r3, #0]
        switch(Name)
    3f78:	9b01      	ldr	r3, [sp, #4]
    3f7a:	2b23      	cmp	r3, #35	; 0x23
    3f7c:	d029      	beq.n	3fd2 <getBusDividerConfig+0x112>
    3f7e:	9b01      	ldr	r3, [sp, #4]
    3f80:	2b23      	cmp	r3, #35	; 0x23
    3f82:	d838      	bhi.n	3ff6 <getBusDividerConfig+0x136>
    3f84:	9b01      	ldr	r3, [sp, #4]
    3f86:	2b21      	cmp	r3, #33	; 0x21
    3f88:	d003      	beq.n	3f92 <getBusDividerConfig+0xd2>
    3f8a:	9b01      	ldr	r3, [sp, #4]
    3f8c:	2b22      	cmp	r3, #34	; 0x22
    3f8e:	d010      	beq.n	3fb2 <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    3f90:	e031      	b.n	3ff6 <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    3f92:	4b1d      	ldr	r3, [pc, #116]	; (4008 <getBusDividerConfig+0x148>)
    3f94:	695b      	ldr	r3, [r3, #20]
    3f96:	091b      	lsrs	r3, r3, #4
    3f98:	f003 030f 	and.w	r3, r3, #15
    3f9c:	1c59      	adds	r1, r3, #1
    3f9e:	4819      	ldr	r0, [pc, #100]	; (4004 <getBusDividerConfig+0x144>)
    3fa0:	9a04      	ldr	r2, [sp, #16]
    3fa2:	4613      	mov	r3, r2
    3fa4:	005b      	lsls	r3, r3, #1
    3fa6:	4413      	add	r3, r2
    3fa8:	009b      	lsls	r3, r3, #2
    3faa:	4403      	add	r3, r0
    3fac:	3304      	adds	r3, #4
    3fae:	6019      	str	r1, [r3, #0]
                break;
    3fb0:	e022      	b.n	3ff8 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    3fb2:	4b15      	ldr	r3, [pc, #84]	; (4008 <getBusDividerConfig+0x148>)
    3fb4:	699b      	ldr	r3, [r3, #24]
    3fb6:	091b      	lsrs	r3, r3, #4
    3fb8:	f003 030f 	and.w	r3, r3, #15
    3fbc:	1c59      	adds	r1, r3, #1
    3fbe:	4811      	ldr	r0, [pc, #68]	; (4004 <getBusDividerConfig+0x144>)
    3fc0:	9a04      	ldr	r2, [sp, #16]
    3fc2:	4613      	mov	r3, r2
    3fc4:	005b      	lsls	r3, r3, #1
    3fc6:	4413      	add	r3, r2
    3fc8:	009b      	lsls	r3, r3, #2
    3fca:	4403      	add	r3, r0
    3fcc:	3304      	adds	r3, #4
    3fce:	6019      	str	r1, [r3, #0]
                break;
    3fd0:	e012      	b.n	3ff8 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    3fd2:	4b0d      	ldr	r3, [pc, #52]	; (4008 <getBusDividerConfig+0x148>)
    3fd4:	69db      	ldr	r3, [r3, #28]
    3fd6:	091b      	lsrs	r3, r3, #4
    3fd8:	f003 030f 	and.w	r3, r3, #15
    3fdc:	1c59      	adds	r1, r3, #1
    3fde:	4809      	ldr	r0, [pc, #36]	; (4004 <getBusDividerConfig+0x144>)
    3fe0:	9a04      	ldr	r2, [sp, #16]
    3fe2:	4613      	mov	r3, r2
    3fe4:	005b      	lsls	r3, r3, #1
    3fe6:	4413      	add	r3, r2
    3fe8:	009b      	lsls	r3, r3, #2
    3fea:	4403      	add	r3, r0
    3fec:	3304      	adds	r3, #4
    3fee:	6019      	str	r1, [r3, #0]
                break;
    3ff0:	e002      	b.n	3ff8 <getBusDividerConfig+0x138>
        }
    }
    3ff2:	bf00      	nop
    3ff4:	e000      	b.n	3ff8 <getBusDividerConfig+0x138>
                break;
    3ff6:	bf00      	nop

    return ReturnValue;
    3ff8:	9b05      	ldr	r3, [sp, #20]
}
    3ffa:	4618      	mov	r0, r3
    3ffc:	b006      	add	sp, #24
    3ffe:	4770      	bx	lr
    4000:	1fff8b98 	.word	0x1fff8b98
    4004:	1fff8c88 	.word	0x1fff8c88
    4008:	40064000 	.word	0x40064000

0000400c <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    400c:	b086      	sub	sp, #24
    400e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    4010:	2300      	movs	r3, #0
    4012:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    4014:	2300      	movs	r3, #0
    4016:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    4018:	9b01      	ldr	r3, [sp, #4]
    401a:	2b27      	cmp	r3, #39	; 0x27
    401c:	d00f      	beq.n	403e <getSlowDividerConfig+0x32>
    401e:	9b01      	ldr	r3, [sp, #4]
    4020:	2b27      	cmp	r3, #39	; 0x27
    4022:	d80f      	bhi.n	4044 <getSlowDividerConfig+0x38>
    4024:	9b01      	ldr	r3, [sp, #4]
    4026:	2b25      	cmp	r3, #37	; 0x25
    4028:	d003      	beq.n	4032 <getSlowDividerConfig+0x26>
    402a:	9b01      	ldr	r3, [sp, #4]
    402c:	2b26      	cmp	r3, #38	; 0x26
    402e:	d003      	beq.n	4038 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    4030:	e008      	b.n	4044 <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    4032:	2300      	movs	r3, #0
    4034:	9304      	str	r3, [sp, #16]
            break;
    4036:	e006      	b.n	4046 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    4038:	2301      	movs	r3, #1
    403a:	9304      	str	r3, [sp, #16]
            break;
    403c:	e003      	b.n	4046 <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    403e:	2302      	movs	r3, #2
    4040:	9304      	str	r3, [sp, #16]
            break;
    4042:	e000      	b.n	4046 <getSlowDividerConfig+0x3a>
                break;
    4044:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4046:	4b40      	ldr	r3, [pc, #256]	; (4148 <getSlowDividerConfig+0x13c>)
    4048:	681b      	ldr	r3, [r3, #0]
    404a:	2b00      	cmp	r3, #0
    404c:	d026      	beq.n	409c <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    404e:	2300      	movs	r3, #0
    4050:	9303      	str	r3, [sp, #12]
    4052:	e01c      	b.n	408e <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    4054:	4b3c      	ldr	r3, [pc, #240]	; (4148 <getSlowDividerConfig+0x13c>)
    4056:	6819      	ldr	r1, [r3, #0]
    4058:	9a03      	ldr	r2, [sp, #12]
    405a:	4613      	mov	r3, r2
    405c:	005b      	lsls	r3, r3, #1
    405e:	4413      	add	r3, r2
    4060:	009b      	lsls	r3, r3, #2
    4062:	440b      	add	r3, r1
    4064:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4068:	681b      	ldr	r3, [r3, #0]
    406a:	9a01      	ldr	r2, [sp, #4]
    406c:	429a      	cmp	r2, r3
    406e:	d10b      	bne.n	4088 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    4070:	4b35      	ldr	r3, [pc, #212]	; (4148 <getSlowDividerConfig+0x13c>)
    4072:	6819      	ldr	r1, [r3, #0]
    4074:	9a03      	ldr	r2, [sp, #12]
    4076:	4613      	mov	r3, r2
    4078:	005b      	lsls	r3, r3, #1
    407a:	4413      	add	r3, r2
    407c:	009b      	lsls	r3, r3, #2
    407e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    4082:	440b      	add	r3, r1
    4084:	9305      	str	r3, [sp, #20]
                break;
    4086:	e009      	b.n	409c <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    4088:	9b03      	ldr	r3, [sp, #12]
    408a:	3301      	adds	r3, #1
    408c:	9303      	str	r3, [sp, #12]
    408e:	4b2e      	ldr	r3, [pc, #184]	; (4148 <getSlowDividerConfig+0x13c>)
    4090:	681b      	ldr	r3, [r3, #0]
    4092:	7b1b      	ldrb	r3, [r3, #12]
    4094:	461a      	mov	r2, r3
    4096:	9b03      	ldr	r3, [sp, #12]
    4098:	4293      	cmp	r3, r2
    409a:	d3db      	bcc.n	4054 <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    409c:	9b05      	ldr	r3, [sp, #20]
    409e:	2b00      	cmp	r3, #0
    40a0:	d14a      	bne.n	4138 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    40a2:	9a04      	ldr	r2, [sp, #16]
    40a4:	4613      	mov	r3, r2
    40a6:	005b      	lsls	r3, r3, #1
    40a8:	4413      	add	r3, r2
    40aa:	009b      	lsls	r3, r3, #2
    40ac:	4a27      	ldr	r2, [pc, #156]	; (414c <getSlowDividerConfig+0x140>)
    40ae:	4413      	add	r3, r2
    40b0:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    40b2:	4926      	ldr	r1, [pc, #152]	; (414c <getSlowDividerConfig+0x140>)
    40b4:	9a04      	ldr	r2, [sp, #16]
    40b6:	4613      	mov	r3, r2
    40b8:	005b      	lsls	r3, r3, #1
    40ba:	4413      	add	r3, r2
    40bc:	009b      	lsls	r3, r3, #2
    40be:	440b      	add	r3, r1
    40c0:	9a01      	ldr	r2, [sp, #4]
    40c2:	601a      	str	r2, [r3, #0]
        switch(Name)
    40c4:	9b01      	ldr	r3, [sp, #4]
    40c6:	2b27      	cmp	r3, #39	; 0x27
    40c8:	d027      	beq.n	411a <getSlowDividerConfig+0x10e>
    40ca:	9b01      	ldr	r3, [sp, #4]
    40cc:	2b27      	cmp	r3, #39	; 0x27
    40ce:	d835      	bhi.n	413c <getSlowDividerConfig+0x130>
    40d0:	9b01      	ldr	r3, [sp, #4]
    40d2:	2b25      	cmp	r3, #37	; 0x25
    40d4:	d003      	beq.n	40de <getSlowDividerConfig+0xd2>
    40d6:	9b01      	ldr	r3, [sp, #4]
    40d8:	2b26      	cmp	r3, #38	; 0x26
    40da:	d00f      	beq.n	40fc <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    40dc:	e02e      	b.n	413c <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    40de:	4b1c      	ldr	r3, [pc, #112]	; (4150 <getSlowDividerConfig+0x144>)
    40e0:	695b      	ldr	r3, [r3, #20]
    40e2:	f003 030f 	and.w	r3, r3, #15
    40e6:	1c59      	adds	r1, r3, #1
    40e8:	4818      	ldr	r0, [pc, #96]	; (414c <getSlowDividerConfig+0x140>)
    40ea:	9a04      	ldr	r2, [sp, #16]
    40ec:	4613      	mov	r3, r2
    40ee:	005b      	lsls	r3, r3, #1
    40f0:	4413      	add	r3, r2
    40f2:	009b      	lsls	r3, r3, #2
    40f4:	4403      	add	r3, r0
    40f6:	3304      	adds	r3, #4
    40f8:	6019      	str	r1, [r3, #0]
                break;
    40fa:	e020      	b.n	413e <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    40fc:	4b14      	ldr	r3, [pc, #80]	; (4150 <getSlowDividerConfig+0x144>)
    40fe:	699b      	ldr	r3, [r3, #24]
    4100:	f003 030f 	and.w	r3, r3, #15
    4104:	1c59      	adds	r1, r3, #1
    4106:	4811      	ldr	r0, [pc, #68]	; (414c <getSlowDividerConfig+0x140>)
    4108:	9a04      	ldr	r2, [sp, #16]
    410a:	4613      	mov	r3, r2
    410c:	005b      	lsls	r3, r3, #1
    410e:	4413      	add	r3, r2
    4110:	009b      	lsls	r3, r3, #2
    4112:	4403      	add	r3, r0
    4114:	3304      	adds	r3, #4
    4116:	6019      	str	r1, [r3, #0]
                break;
    4118:	e011      	b.n	413e <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    411a:	4b0d      	ldr	r3, [pc, #52]	; (4150 <getSlowDividerConfig+0x144>)
    411c:	69db      	ldr	r3, [r3, #28]
    411e:	f003 030f 	and.w	r3, r3, #15
    4122:	1c59      	adds	r1, r3, #1
    4124:	4809      	ldr	r0, [pc, #36]	; (414c <getSlowDividerConfig+0x140>)
    4126:	9a04      	ldr	r2, [sp, #16]
    4128:	4613      	mov	r3, r2
    412a:	005b      	lsls	r3, r3, #1
    412c:	4413      	add	r3, r2
    412e:	009b      	lsls	r3, r3, #2
    4130:	4403      	add	r3, r0
    4132:	3304      	adds	r3, #4
    4134:	6019      	str	r1, [r3, #0]
                break;
    4136:	e002      	b.n	413e <getSlowDividerConfig+0x132>
        }
    }
    4138:	bf00      	nop
    413a:	e000      	b.n	413e <getSlowDividerConfig+0x132>
                break;
    413c:	bf00      	nop

    return ReturnValue;
    413e:	9b05      	ldr	r3, [sp, #20]
}
    4140:	4618      	mov	r0, r3
    4142:	b006      	add	sp, #24
    4144:	4770      	bx	lr
    4146:	bf00      	nop
    4148:	1fff8b98 	.word	0x1fff8b98
    414c:	1fff8cac 	.word	0x1fff8cac
    4150:	40064000 	.word	0x40064000

00004154 <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    4154:	b500      	push	{lr}
    4156:	b083      	sub	sp, #12
    4158:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    415a:	4b64      	ldr	r3, [pc, #400]	; (42ec <Clock_Ip_ClockInitializeObjects+0x198>)
    415c:	781b      	ldrb	r3, [r3, #0]
    415e:	f083 0301 	eor.w	r3, r3, #1
    4162:	b2db      	uxtb	r3, r3
    4164:	2b00      	cmp	r3, #0
    4166:	d05b      	beq.n	4220 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    4168:	4b60      	ldr	r3, [pc, #384]	; (42ec <Clock_Ip_ClockInitializeObjects+0x198>)
    416a:	2201      	movs	r2, #1
    416c:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    416e:	4b60      	ldr	r3, [pc, #384]	; (42f0 <Clock_Ip_ClockInitializeObjects+0x19c>)
    4170:	785b      	ldrb	r3, [r3, #1]
    4172:	461a      	mov	r2, r3
    4174:	4613      	mov	r3, r2
    4176:	009b      	lsls	r3, r3, #2
    4178:	4413      	add	r3, r2
    417a:	009b      	lsls	r3, r3, #2
    417c:	4a5d      	ldr	r2, [pc, #372]	; (42f4 <Clock_Ip_ClockInitializeObjects+0x1a0>)
    417e:	4413      	add	r3, r2
    4180:	4a5d      	ldr	r2, [pc, #372]	; (42f8 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    4182:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    4184:	4b5d      	ldr	r3, [pc, #372]	; (42fc <Clock_Ip_ClockInitializeObjects+0x1a8>)
    4186:	785b      	ldrb	r3, [r3, #1]
    4188:	461a      	mov	r2, r3
    418a:	4613      	mov	r3, r2
    418c:	009b      	lsls	r3, r3, #2
    418e:	4413      	add	r3, r2
    4190:	009b      	lsls	r3, r3, #2
    4192:	4a5b      	ldr	r2, [pc, #364]	; (4300 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    4194:	4413      	add	r3, r2
    4196:	4a5b      	ldr	r2, [pc, #364]	; (4304 <Clock_Ip_ClockInitializeObjects+0x1b0>)
    4198:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    419a:	4b5b      	ldr	r3, [pc, #364]	; (4308 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    419c:	791b      	ldrb	r3, [r3, #4]
    419e:	461a      	mov	r2, r3
    41a0:	4613      	mov	r3, r2
    41a2:	005b      	lsls	r3, r3, #1
    41a4:	4413      	add	r3, r2
    41a6:	009b      	lsls	r3, r3, #2
    41a8:	4a58      	ldr	r2, [pc, #352]	; (430c <Clock_Ip_ClockInitializeObjects+0x1b8>)
    41aa:	4413      	add	r3, r2
    41ac:	4a58      	ldr	r2, [pc, #352]	; (4310 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    41ae:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    41b0:	4b58      	ldr	r3, [pc, #352]	; (4314 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    41b2:	795b      	ldrb	r3, [r3, #5]
    41b4:	00db      	lsls	r3, r3, #3
    41b6:	4a58      	ldr	r2, [pc, #352]	; (4318 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    41b8:	4413      	add	r3, r2
    41ba:	4a58      	ldr	r2, [pc, #352]	; (431c <Clock_Ip_ClockInitializeObjects+0x1c8>)
    41bc:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    41be:	4b55      	ldr	r3, [pc, #340]	; (4314 <Clock_Ip_ClockInitializeObjects+0x1c0>)
    41c0:	79db      	ldrb	r3, [r3, #7]
    41c2:	00db      	lsls	r3, r3, #3
    41c4:	4a54      	ldr	r2, [pc, #336]	; (4318 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    41c6:	4413      	add	r3, r2
    41c8:	4a55      	ldr	r2, [pc, #340]	; (4320 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    41ca:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    41cc:	4b55      	ldr	r3, [pc, #340]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    41ce:	799b      	ldrb	r3, [r3, #6]
    41d0:	009b      	lsls	r3, r3, #2
    41d2:	4a55      	ldr	r2, [pc, #340]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    41d4:	4413      	add	r3, r2
    41d6:	4a55      	ldr	r2, [pc, #340]	; (432c <Clock_Ip_ClockInitializeObjects+0x1d8>)
    41d8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    41da:	4b52      	ldr	r3, [pc, #328]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    41dc:	7a1b      	ldrb	r3, [r3, #8]
    41de:	009b      	lsls	r3, r3, #2
    41e0:	4a51      	ldr	r2, [pc, #324]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    41e2:	4413      	add	r3, r2
    41e4:	4a52      	ldr	r2, [pc, #328]	; (4330 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    41e6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    41e8:	4b4e      	ldr	r3, [pc, #312]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    41ea:	7a5b      	ldrb	r3, [r3, #9]
    41ec:	009b      	lsls	r3, r3, #2
    41ee:	4a4e      	ldr	r2, [pc, #312]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    41f0:	4413      	add	r3, r2
    41f2:	4a50      	ldr	r2, [pc, #320]	; (4334 <Clock_Ip_ClockInitializeObjects+0x1e0>)
    41f4:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    41f6:	4b4b      	ldr	r3, [pc, #300]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    41f8:	7adb      	ldrb	r3, [r3, #11]
    41fa:	009b      	lsls	r3, r3, #2
    41fc:	4a4a      	ldr	r2, [pc, #296]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    41fe:	4413      	add	r3, r2
    4200:	4a4d      	ldr	r2, [pc, #308]	; (4338 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    4202:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    4204:	4b47      	ldr	r3, [pc, #284]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4206:	7b1b      	ldrb	r3, [r3, #12]
    4208:	009b      	lsls	r3, r3, #2
    420a:	4a47      	ldr	r2, [pc, #284]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    420c:	4413      	add	r3, r2
    420e:	4a4b      	ldr	r2, [pc, #300]	; (433c <Clock_Ip_ClockInitializeObjects+0x1e8>)
    4210:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    4212:	4b44      	ldr	r3, [pc, #272]	; (4324 <Clock_Ip_ClockInitializeObjects+0x1d0>)
    4214:	7b9b      	ldrb	r3, [r3, #14]
    4216:	009b      	lsls	r3, r3, #2
    4218:	4a43      	ldr	r2, [pc, #268]	; (4328 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    421a:	4413      	add	r3, r2
    421c:	4a48      	ldr	r2, [pc, #288]	; (4340 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    421e:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    4220:	4b48      	ldr	r3, [pc, #288]	; (4344 <Clock_Ip_ClockInitializeObjects+0x1f0>)
    4222:	781b      	ldrb	r3, [r3, #0]
    4224:	2b00      	cmp	r3, #0
    4226:	d002      	beq.n	422e <Clock_Ip_ClockInitializeObjects+0xda>
    4228:	9b01      	ldr	r3, [sp, #4]
    422a:	2b00      	cmp	r3, #0
    422c:	d003      	beq.n	4236 <Clock_Ip_ClockInitializeObjects+0xe2>
    422e:	4b46      	ldr	r3, [pc, #280]	; (4348 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    4230:	781b      	ldrb	r3, [r3, #0]
    4232:	2b00      	cmp	r3, #0
    4234:	d056      	beq.n	42e4 <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    4236:	f7ff fc09 	bl	3a4c <getFircConfig>
    423a:	4603      	mov	r3, r0
    423c:	4a43      	ldr	r2, [pc, #268]	; (434c <Clock_Ip_ClockInitializeObjects+0x1f8>)
    423e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    4240:	f7ff fc60 	bl	3b04 <getSoscConfig>
    4244:	4603      	mov	r3, r0
    4246:	4a42      	ldr	r2, [pc, #264]	; (4350 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    4248:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    424a:	f7ff fca7 	bl	3b9c <getSpllConfig>
    424e:	4603      	mov	r3, r0
    4250:	4a40      	ldr	r2, [pc, #256]	; (4354 <Clock_Ip_ClockInitializeObjects+0x200>)
    4252:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    4254:	2019      	movs	r0, #25
    4256:	f7ff fcfb 	bl	3c50 <getSelectorConfig>
    425a:	4603      	mov	r3, r0
    425c:	4a3e      	ldr	r2, [pc, #248]	; (4358 <Clock_Ip_ClockInitializeObjects+0x204>)
    425e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    4260:	201a      	movs	r0, #26
    4262:	f7ff fcf5 	bl	3c50 <getSelectorConfig>
    4266:	4603      	mov	r3, r0
    4268:	4a3c      	ldr	r2, [pc, #240]	; (435c <Clock_Ip_ClockInitializeObjects+0x208>)
    426a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    426c:	201b      	movs	r0, #27
    426e:	f7ff fcef 	bl	3c50 <getSelectorConfig>
    4272:	4603      	mov	r3, r0
    4274:	4a3a      	ldr	r2, [pc, #232]	; (4360 <Clock_Ip_ClockInitializeObjects+0x20c>)
    4276:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    4278:	201d      	movs	r0, #29
    427a:	f7ff fd7b 	bl	3d74 <getCoreDividerConfig>
    427e:	4603      	mov	r3, r0
    4280:	4a38      	ldr	r2, [pc, #224]	; (4364 <Clock_Ip_ClockInitializeObjects+0x210>)
    4282:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    4284:	201e      	movs	r0, #30
    4286:	f7ff fd75 	bl	3d74 <getCoreDividerConfig>
    428a:	4603      	mov	r3, r0
    428c:	4a36      	ldr	r2, [pc, #216]	; (4368 <Clock_Ip_ClockInitializeObjects+0x214>)
    428e:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    4290:	201f      	movs	r0, #31
    4292:	f7ff fd6f 	bl	3d74 <getCoreDividerConfig>
    4296:	4603      	mov	r3, r0
    4298:	4a34      	ldr	r2, [pc, #208]	; (436c <Clock_Ip_ClockInitializeObjects+0x218>)
    429a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    429c:	2021      	movs	r0, #33	; 0x21
    429e:	f7ff fe0f 	bl	3ec0 <getBusDividerConfig>
    42a2:	4603      	mov	r3, r0
    42a4:	4a32      	ldr	r2, [pc, #200]	; (4370 <Clock_Ip_ClockInitializeObjects+0x21c>)
    42a6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    42a8:	2022      	movs	r0, #34	; 0x22
    42aa:	f7ff fe09 	bl	3ec0 <getBusDividerConfig>
    42ae:	4603      	mov	r3, r0
    42b0:	4a30      	ldr	r2, [pc, #192]	; (4374 <Clock_Ip_ClockInitializeObjects+0x220>)
    42b2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    42b4:	2023      	movs	r0, #35	; 0x23
    42b6:	f7ff fe03 	bl	3ec0 <getBusDividerConfig>
    42ba:	4603      	mov	r3, r0
    42bc:	4a2e      	ldr	r2, [pc, #184]	; (4378 <Clock_Ip_ClockInitializeObjects+0x224>)
    42be:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    42c0:	2025      	movs	r0, #37	; 0x25
    42c2:	f7ff fea3 	bl	400c <getSlowDividerConfig>
    42c6:	4603      	mov	r3, r0
    42c8:	4a2c      	ldr	r2, [pc, #176]	; (437c <Clock_Ip_ClockInitializeObjects+0x228>)
    42ca:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    42cc:	2026      	movs	r0, #38	; 0x26
    42ce:	f7ff fe9d 	bl	400c <getSlowDividerConfig>
    42d2:	4603      	mov	r3, r0
    42d4:	4a2a      	ldr	r2, [pc, #168]	; (4380 <Clock_Ip_ClockInitializeObjects+0x22c>)
    42d6:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    42d8:	2027      	movs	r0, #39	; 0x27
    42da:	f7ff fe97 	bl	400c <getSlowDividerConfig>
    42de:	4603      	mov	r3, r0
    42e0:	4a28      	ldr	r2, [pc, #160]	; (4384 <Clock_Ip_ClockInitializeObjects+0x230>)
    42e2:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    42e4:	bf00      	nop
    42e6:	b003      	add	sp, #12
    42e8:	f85d fb04 	ldr.w	pc, [sp], #4
    42ec:	1fff8cd0 	.word	0x1fff8cd0
    42f0:	00006ccc 	.word	0x00006ccc
    42f4:	00007318 	.word	0x00007318
    42f8:	1fff8b9c 	.word	0x1fff8b9c
    42fc:	00006c8c 	.word	0x00006c8c
    4300:	00007260 	.word	0x00007260
    4304:	1fff8ba0 	.word	0x1fff8ba0
    4308:	00006c9c 	.word	0x00006c9c
    430c:	000072cc 	.word	0x000072cc
    4310:	1fff8ba4 	.word	0x1fff8ba4
    4314:	00006cdc 	.word	0x00006cdc
    4318:	00007344 	.word	0x00007344
    431c:	1fff8ba8 	.word	0x1fff8ba8
    4320:	1fff8be4 	.word	0x1fff8be4
    4324:	00006c6c 	.word	0x00006c6c
    4328:	0000721c 	.word	0x0000721c
    432c:	1fff8bac 	.word	0x1fff8bac
    4330:	1fff8be8 	.word	0x1fff8be8
    4334:	1fff8bb0 	.word	0x1fff8bb0
    4338:	1fff8bec 	.word	0x1fff8bec
    433c:	1fff8bb4 	.word	0x1fff8bb4
    4340:	1fff8bf0 	.word	0x1fff8bf0
    4344:	1fff8b19 	.word	0x1fff8b19
    4348:	1fff8b10 	.word	0x1fff8b10
    434c:	1fff8bb8 	.word	0x1fff8bb8
    4350:	1fff8bbc 	.word	0x1fff8bbc
    4354:	1fff8bc0 	.word	0x1fff8bc0
    4358:	1fff8bc4 	.word	0x1fff8bc4
    435c:	1fff8bc8 	.word	0x1fff8bc8
    4360:	1fff8bf4 	.word	0x1fff8bf4
    4364:	1fff8bcc 	.word	0x1fff8bcc
    4368:	1fff8bd0 	.word	0x1fff8bd0
    436c:	1fff8bf8 	.word	0x1fff8bf8
    4370:	1fff8bd4 	.word	0x1fff8bd4
    4374:	1fff8bd8 	.word	0x1fff8bd8
    4378:	1fff8bfc 	.word	0x1fff8bfc
    437c:	1fff8bdc 	.word	0x1fff8bdc
    4380:	1fff8be0 	.word	0x1fff8be0
    4384:	1fff8c00 	.word	0x1fff8c00

00004388 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    4388:	b500      	push	{lr}
    438a:	b083      	sub	sp, #12
    438c:	9001      	str	r0, [sp, #4]
    438e:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    4390:	9b01      	ldr	r3, [sp, #4]
    4392:	2b03      	cmp	r3, #3
    4394:	f000 8090 	beq.w	44b8 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    4398:	9b01      	ldr	r3, [sp, #4]
    439a:	2b03      	cmp	r3, #3
    439c:	f200 80d3 	bhi.w	4546 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    43a0:	9b01      	ldr	r3, [sp, #4]
    43a2:	2b00      	cmp	r3, #0
    43a4:	d040      	beq.n	4428 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    43a6:	9b01      	ldr	r3, [sp, #4]
    43a8:	3b01      	subs	r3, #1
    43aa:	2b01      	cmp	r3, #1
    43ac:	f200 80cb 	bhi.w	4546 <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    43b0:	9b00      	ldr	r3, [sp, #0]
    43b2:	2b00      	cmp	r3, #0
    43b4:	f040 80c9 	bne.w	454a <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    43b8:	4b68      	ldr	r3, [pc, #416]	; (455c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    43ba:	2200      	movs	r2, #0
    43bc:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    43be:	4b68      	ldr	r3, [pc, #416]	; (4560 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    43c0:	681b      	ldr	r3, [r3, #0]
    43c2:	685b      	ldr	r3, [r3, #4]
    43c4:	4a67      	ldr	r2, [pc, #412]	; (4564 <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    43c6:	6812      	ldr	r2, [r2, #0]
    43c8:	4610      	mov	r0, r2
    43ca:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    43cc:	4b66      	ldr	r3, [pc, #408]	; (4568 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    43ce:	681b      	ldr	r3, [r3, #0]
    43d0:	681b      	ldr	r3, [r3, #0]
    43d2:	4a66      	ldr	r2, [pc, #408]	; (456c <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    43d4:	6812      	ldr	r2, [r2, #0]
    43d6:	4610      	mov	r0, r2
    43d8:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    43da:	4b65      	ldr	r3, [pc, #404]	; (4570 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    43dc:	681b      	ldr	r3, [r3, #0]
    43de:	681b      	ldr	r3, [r3, #0]
    43e0:	4a64      	ldr	r2, [pc, #400]	; (4574 <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    43e2:	6812      	ldr	r2, [r2, #0]
    43e4:	4610      	mov	r0, r2
    43e6:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    43e8:	4b63      	ldr	r3, [pc, #396]	; (4578 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    43ea:	681b      	ldr	r3, [r3, #0]
    43ec:	681b      	ldr	r3, [r3, #0]
    43ee:	4a63      	ldr	r2, [pc, #396]	; (457c <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    43f0:	6812      	ldr	r2, [r2, #0]
    43f2:	4610      	mov	r0, r2
    43f4:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    43f6:	4b62      	ldr	r3, [pc, #392]	; (4580 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    43f8:	681b      	ldr	r3, [r3, #0]
    43fa:	691b      	ldr	r3, [r3, #16]
    43fc:	4a61      	ldr	r2, [pc, #388]	; (4584 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    43fe:	6812      	ldr	r2, [r2, #0]
    4400:	6812      	ldr	r2, [r2, #0]
    4402:	4610      	mov	r0, r2
    4404:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    4406:	4b60      	ldr	r3, [pc, #384]	; (4588 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4408:	681b      	ldr	r3, [r3, #0]
    440a:	68db      	ldr	r3, [r3, #12]
    440c:	4a5f      	ldr	r2, [pc, #380]	; (458c <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    440e:	6812      	ldr	r2, [r2, #0]
    4410:	6812      	ldr	r2, [r2, #0]
    4412:	4610      	mov	r0, r2
    4414:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    4416:	4b5e      	ldr	r3, [pc, #376]	; (4590 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4418:	681b      	ldr	r3, [r3, #0]
    441a:	689b      	ldr	r3, [r3, #8]
    441c:	4a5d      	ldr	r2, [pc, #372]	; (4594 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    441e:	6812      	ldr	r2, [r2, #0]
    4420:	6812      	ldr	r2, [r2, #0]
    4422:	4610      	mov	r0, r2
    4424:	4798      	blx	r3
            }
        }
        break;
    4426:	e090      	b.n	454a <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    4428:	9b00      	ldr	r3, [sp, #0]
    442a:	2b02      	cmp	r3, #2
    442c:	f040 808f 	bne.w	454e <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    4430:	4b4a      	ldr	r3, [pc, #296]	; (455c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    4432:	2201      	movs	r2, #1
    4434:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    4436:	4b56      	ldr	r3, [pc, #344]	; (4590 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    4438:	681b      	ldr	r3, [r3, #0]
    443a:	685b      	ldr	r3, [r3, #4]
    443c:	4a55      	ldr	r2, [pc, #340]	; (4594 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    443e:	6812      	ldr	r2, [r2, #0]
    4440:	4610      	mov	r0, r2
    4442:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    4444:	4b50      	ldr	r3, [pc, #320]	; (4588 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4446:	681b      	ldr	r3, [r3, #0]
    4448:	691b      	ldr	r3, [r3, #16]
    444a:	4a50      	ldr	r2, [pc, #320]	; (458c <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    444c:	6812      	ldr	r2, [r2, #0]
    444e:	4610      	mov	r0, r2
    4450:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    4452:	4b4d      	ldr	r3, [pc, #308]	; (4588 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    4454:	681b      	ldr	r3, [r3, #0]
    4456:	689b      	ldr	r3, [r3, #8]
    4458:	4a4c      	ldr	r2, [pc, #304]	; (458c <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    445a:	6812      	ldr	r2, [r2, #0]
    445c:	4610      	mov	r0, r2
    445e:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    4460:	4b47      	ldr	r3, [pc, #284]	; (4580 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4462:	681b      	ldr	r3, [r3, #0]
    4464:	68db      	ldr	r3, [r3, #12]
    4466:	4a47      	ldr	r2, [pc, #284]	; (4584 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4468:	6812      	ldr	r2, [r2, #0]
    446a:	4610      	mov	r0, r2
    446c:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    446e:	4b44      	ldr	r3, [pc, #272]	; (4580 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    4470:	681b      	ldr	r3, [r3, #0]
    4472:	689b      	ldr	r3, [r3, #8]
    4474:	4a43      	ldr	r2, [pc, #268]	; (4584 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4476:	6812      	ldr	r2, [r2, #0]
    4478:	6812      	ldr	r2, [r2, #0]
    447a:	4610      	mov	r0, r2
    447c:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    447e:	4b38      	ldr	r3, [pc, #224]	; (4560 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    4480:	681b      	ldr	r3, [r3, #0]
    4482:	685b      	ldr	r3, [r3, #4]
    4484:	4a44      	ldr	r2, [pc, #272]	; (4598 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    4486:	6812      	ldr	r2, [r2, #0]
    4488:	4610      	mov	r0, r2
    448a:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    448c:	4b36      	ldr	r3, [pc, #216]	; (4568 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    448e:	681b      	ldr	r3, [r3, #0]
    4490:	681b      	ldr	r3, [r3, #0]
    4492:	4a42      	ldr	r2, [pc, #264]	; (459c <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    4494:	6812      	ldr	r2, [r2, #0]
    4496:	4610      	mov	r0, r2
    4498:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    449a:	4b35      	ldr	r3, [pc, #212]	; (4570 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    449c:	681b      	ldr	r3, [r3, #0]
    449e:	681b      	ldr	r3, [r3, #0]
    44a0:	4a3f      	ldr	r2, [pc, #252]	; (45a0 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    44a2:	6812      	ldr	r2, [r2, #0]
    44a4:	4610      	mov	r0, r2
    44a6:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    44a8:	4b33      	ldr	r3, [pc, #204]	; (4578 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    44aa:	681b      	ldr	r3, [r3, #0]
    44ac:	681b      	ldr	r3, [r3, #0]
    44ae:	4a3d      	ldr	r2, [pc, #244]	; (45a4 <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    44b0:	6812      	ldr	r2, [r2, #0]
    44b2:	4610      	mov	r0, r2
    44b4:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    44b6:	e04a      	b.n	454e <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    44b8:	9b00      	ldr	r3, [sp, #0]
    44ba:	2b02      	cmp	r3, #2
    44bc:	d149      	bne.n	4552 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    44be:	4b27      	ldr	r3, [pc, #156]	; (455c <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    44c0:	2201      	movs	r2, #1
    44c2:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    44c4:	4b32      	ldr	r3, [pc, #200]	; (4590 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    44c6:	681b      	ldr	r3, [r3, #0]
    44c8:	685b      	ldr	r3, [r3, #4]
    44ca:	4a32      	ldr	r2, [pc, #200]	; (4594 <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    44cc:	6812      	ldr	r2, [r2, #0]
    44ce:	4610      	mov	r0, r2
    44d0:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    44d2:	4b2d      	ldr	r3, [pc, #180]	; (4588 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    44d4:	681b      	ldr	r3, [r3, #0]
    44d6:	691b      	ldr	r3, [r3, #16]
    44d8:	4a2c      	ldr	r2, [pc, #176]	; (458c <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    44da:	6812      	ldr	r2, [r2, #0]
    44dc:	4610      	mov	r0, r2
    44de:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    44e0:	4b29      	ldr	r3, [pc, #164]	; (4588 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    44e2:	681b      	ldr	r3, [r3, #0]
    44e4:	689b      	ldr	r3, [r3, #8]
    44e6:	4a29      	ldr	r2, [pc, #164]	; (458c <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    44e8:	6812      	ldr	r2, [r2, #0]
    44ea:	4610      	mov	r0, r2
    44ec:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    44ee:	4b24      	ldr	r3, [pc, #144]	; (4580 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    44f0:	681b      	ldr	r3, [r3, #0]
    44f2:	68db      	ldr	r3, [r3, #12]
    44f4:	4a23      	ldr	r2, [pc, #140]	; (4584 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    44f6:	6812      	ldr	r2, [r2, #0]
    44f8:	4610      	mov	r0, r2
    44fa:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    44fc:	4b20      	ldr	r3, [pc, #128]	; (4580 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    44fe:	681b      	ldr	r3, [r3, #0]
    4500:	689b      	ldr	r3, [r3, #8]
    4502:	4a20      	ldr	r2, [pc, #128]	; (4584 <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    4504:	6812      	ldr	r2, [r2, #0]
    4506:	6812      	ldr	r2, [r2, #0]
    4508:	4610      	mov	r0, r2
    450a:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    450c:	4b26      	ldr	r3, [pc, #152]	; (45a8 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    450e:	681b      	ldr	r3, [r3, #0]
    4510:	685b      	ldr	r3, [r3, #4]
    4512:	4a26      	ldr	r2, [pc, #152]	; (45ac <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    4514:	6812      	ldr	r2, [r2, #0]
    4516:	4610      	mov	r0, r2
    4518:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    451a:	4b25      	ldr	r3, [pc, #148]	; (45b0 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    451c:	681b      	ldr	r3, [r3, #0]
    451e:	681b      	ldr	r3, [r3, #0]
    4520:	4a24      	ldr	r2, [pc, #144]	; (45b4 <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    4522:	6812      	ldr	r2, [r2, #0]
    4524:	4610      	mov	r0, r2
    4526:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    4528:	4b23      	ldr	r3, [pc, #140]	; (45b8 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    452a:	681b      	ldr	r3, [r3, #0]
    452c:	681b      	ldr	r3, [r3, #0]
    452e:	4a23      	ldr	r2, [pc, #140]	; (45bc <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    4530:	6812      	ldr	r2, [r2, #0]
    4532:	4610      	mov	r0, r2
    4534:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    4536:	4b22      	ldr	r3, [pc, #136]	; (45c0 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    4538:	681b      	ldr	r3, [r3, #0]
    453a:	681b      	ldr	r3, [r3, #0]
    453c:	4a21      	ldr	r2, [pc, #132]	; (45c4 <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    453e:	6812      	ldr	r2, [r2, #0]
    4540:	4610      	mov	r0, r2
    4542:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    4544:	e005      	b.n	4552 <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    4546:	bf00      	nop
    4548:	e004      	b.n	4554 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    454a:	bf00      	nop
    454c:	e002      	b.n	4554 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    454e:	bf00      	nop
    4550:	e000      	b.n	4554 <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    4552:	bf00      	nop
    }

}
    4554:	bf00      	nop
    4556:	b003      	add	sp, #12
    4558:	f85d fb04 	ldr.w	pc, [sp], #4
    455c:	1fff8b19 	.word	0x1fff8b19
    4560:	1fff8ba8 	.word	0x1fff8ba8
    4564:	1fff8bc8 	.word	0x1fff8bc8
    4568:	1fff8bac 	.word	0x1fff8bac
    456c:	1fff8bd0 	.word	0x1fff8bd0
    4570:	1fff8bb0 	.word	0x1fff8bb0
    4574:	1fff8bd8 	.word	0x1fff8bd8
    4578:	1fff8bb4 	.word	0x1fff8bb4
    457c:	1fff8be0 	.word	0x1fff8be0
    4580:	1fff8b9c 	.word	0x1fff8b9c
    4584:	1fff8bc0 	.word	0x1fff8bc0
    4588:	1fff8ba0 	.word	0x1fff8ba0
    458c:	1fff8bbc 	.word	0x1fff8bbc
    4590:	1fff8ba4 	.word	0x1fff8ba4
    4594:	1fff8bb8 	.word	0x1fff8bb8
    4598:	1fff8bc4 	.word	0x1fff8bc4
    459c:	1fff8bcc 	.word	0x1fff8bcc
    45a0:	1fff8bd4 	.word	0x1fff8bd4
    45a4:	1fff8bdc 	.word	0x1fff8bdc
    45a8:	1fff8be4 	.word	0x1fff8be4
    45ac:	1fff8bf4 	.word	0x1fff8bf4
    45b0:	1fff8be8 	.word	0x1fff8be8
    45b4:	1fff8bf8 	.word	0x1fff8bf8
    45b8:	1fff8bec 	.word	0x1fff8bec
    45bc:	1fff8bfc 	.word	0x1fff8bfc
    45c0:	1fff8bf0 	.word	0x1fff8bf0
    45c4:	1fff8c00 	.word	0x1fff8c00

000045c8 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    45c8:	b500      	push	{lr}
    45ca:	b083      	sub	sp, #12
    45cc:	9001      	str	r0, [sp, #4]
    45ce:	9100      	str	r1, [sp, #0]
    switch(Command)
    45d0:	9b00      	ldr	r3, [sp, #0]
    45d2:	2b04      	cmp	r3, #4
    45d4:	d010      	beq.n	45f8 <Clock_Ip_Command+0x30>
    45d6:	9b00      	ldr	r3, [sp, #0]
    45d8:	2b04      	cmp	r3, #4
    45da:	d811      	bhi.n	4600 <Clock_Ip_Command+0x38>
    45dc:	9b00      	ldr	r3, [sp, #0]
    45de:	2b01      	cmp	r3, #1
    45e0:	d006      	beq.n	45f0 <Clock_Ip_Command+0x28>
    45e2:	9b00      	ldr	r3, [sp, #0]
    45e4:	2b02      	cmp	r3, #2
    45e6:	d10b      	bne.n	4600 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    45e8:	9801      	ldr	r0, [sp, #4]
    45ea:	f7ff fdb3 	bl	4154 <Clock_Ip_ClockInitializeObjects>
            break;
    45ee:	e008      	b.n	4602 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    45f0:	9801      	ldr	r0, [sp, #4]
    45f2:	f7ff f9db 	bl	39ac <Clock_Ip_SpecificPlatformInitClock>
            break;
    45f6:	e004      	b.n	4602 <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    45f8:	9801      	ldr	r0, [sp, #4]
    45fa:	f7ff f8ed 	bl	37d8 <DisableSafeClock>
            break;
    45fe:	e000      	b.n	4602 <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    4600:	bf00      	nop
    }
}
    4602:	bf00      	nop
    4604:	b003      	add	sp, #12
    4606:	f85d fb04 	ldr.w	pc, [sp], #4
    460a:	bf00      	nop

0000460c <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    460c:	b500      	push	{lr}
    460e:	b085      	sub	sp, #20
    4610:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    4612:	4a20      	ldr	r2, [pc, #128]	; (4694 <Mcu_Init+0x88>)
    4614:	9b01      	ldr	r3, [sp, #4]
    4616:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    4618:	2300      	movs	r3, #0
    461a:	9303      	str	r3, [sp, #12]
    461c:	e010      	b.n	4640 <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    461e:	4b1d      	ldr	r3, [pc, #116]	; (4694 <Mcu_Init+0x88>)
    4620:	681b      	ldr	r3, [r3, #0]
    4622:	6919      	ldr	r1, [r3, #16]
    4624:	9a03      	ldr	r2, [sp, #12]
    4626:	4613      	mov	r3, r2
    4628:	005b      	lsls	r3, r3, #1
    462a:	4413      	add	r3, r2
    462c:	009b      	lsls	r3, r3, #2
    462e:	440b      	add	r3, r1
    4630:	681b      	ldr	r3, [r3, #0]
    4632:	9a03      	ldr	r2, [sp, #12]
    4634:	b2d1      	uxtb	r1, r2
    4636:	4a18      	ldr	r2, [pc, #96]	; (4698 <Mcu_Init+0x8c>)
    4638:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    463a:	9b03      	ldr	r3, [sp, #12]
    463c:	3301      	adds	r3, #1
    463e:	9303      	str	r3, [sp, #12]
    4640:	4b14      	ldr	r3, [pc, #80]	; (4694 <Mcu_Init+0x88>)
    4642:	681b      	ldr	r3, [r3, #0]
    4644:	689b      	ldr	r3, [r3, #8]
    4646:	9a03      	ldr	r2, [sp, #12]
    4648:	429a      	cmp	r2, r3
    464a:	d3e8      	bcc.n	461e <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    464c:	2300      	movs	r3, #0
    464e:	9303      	str	r3, [sp, #12]
    4650:	e010      	b.n	4674 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    4652:	4b10      	ldr	r3, [pc, #64]	; (4694 <Mcu_Init+0x88>)
    4654:	681b      	ldr	r3, [r3, #0]
    4656:	6959      	ldr	r1, [r3, #20]
    4658:	9a03      	ldr	r2, [sp, #12]
    465a:	4613      	mov	r3, r2
    465c:	01db      	lsls	r3, r3, #7
    465e:	1a9b      	subs	r3, r3, r2
    4660:	00db      	lsls	r3, r3, #3
    4662:	440b      	add	r3, r1
    4664:	681b      	ldr	r3, [r3, #0]
    4666:	9a03      	ldr	r2, [sp, #12]
    4668:	b2d1      	uxtb	r1, r2
    466a:	4a0c      	ldr	r2, [pc, #48]	; (469c <Mcu_Init+0x90>)
    466c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    466e:	9b03      	ldr	r3, [sp, #12]
    4670:	3301      	adds	r3, #1
    4672:	9303      	str	r3, [sp, #12]
    4674:	4b07      	ldr	r3, [pc, #28]	; (4694 <Mcu_Init+0x88>)
    4676:	681b      	ldr	r3, [r3, #0]
    4678:	68db      	ldr	r3, [r3, #12]
    467a:	9a03      	ldr	r2, [sp, #12]
    467c:	429a      	cmp	r2, r3
    467e:	d3e8      	bcc.n	4652 <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    4680:	4b04      	ldr	r3, [pc, #16]	; (4694 <Mcu_Init+0x88>)
    4682:	681b      	ldr	r3, [r3, #0]
    4684:	699b      	ldr	r3, [r3, #24]
    4686:	4618      	mov	r0, r3
    4688:	f000 f89a 	bl	47c0 <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    468c:	bf00      	nop
    468e:	b005      	add	sp, #20
    4690:	f85d fb04 	ldr.w	pc, [sp], #4
    4694:	1fff8cdc 	.word	0x1fff8cdc
    4698:	1fff8cd8 	.word	0x1fff8cd8
    469c:	1fff8cd4 	.word	0x1fff8cd4

000046a0 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    46a0:	b084      	sub	sp, #16
    46a2:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    46a4:	2301      	movs	r3, #1
    46a6:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    46aa:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    46ae:	4618      	mov	r0, r3
    46b0:	b004      	add	sp, #16
    46b2:	4770      	bx	lr

000046b4 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    46b4:	b500      	push	{lr}
    46b6:	b085      	sub	sp, #20
    46b8:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    46ba:	4a0e      	ldr	r2, [pc, #56]	; (46f4 <Mcu_InitClock+0x40>)
    46bc:	9b01      	ldr	r3, [sp, #4]
    46be:	4413      	add	r3, r2
    46c0:	781b      	ldrb	r3, [r3, #0]
    46c2:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    46c6:	4b0c      	ldr	r3, [pc, #48]	; (46f8 <Mcu_InitClock+0x44>)
    46c8:	681b      	ldr	r3, [r3, #0]
    46ca:	6959      	ldr	r1, [r3, #20]
    46cc:	f89d 200f 	ldrb.w	r2, [sp, #15]
    46d0:	4613      	mov	r3, r2
    46d2:	01db      	lsls	r3, r3, #7
    46d4:	1a9b      	subs	r3, r3, r2
    46d6:	00db      	lsls	r3, r3, #3
    46d8:	440b      	add	r3, r1
    46da:	4618      	mov	r0, r3
    46dc:	f000 f87a 	bl	47d4 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    46e0:	2300      	movs	r3, #0
    46e2:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    46e6:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    46ea:	4618      	mov	r0, r3
    46ec:	b005      	add	sp, #20
    46ee:	f85d fb04 	ldr.w	pc, [sp], #4
    46f2:	bf00      	nop
    46f4:	1fff8cd4 	.word	0x1fff8cd4
    46f8:	1fff8cdc 	.word	0x1fff8cdc

000046fc <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    46fc:	b500      	push	{lr}
    46fe:	b085      	sub	sp, #20
    4700:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    4702:	4a0d      	ldr	r2, [pc, #52]	; (4738 <Mcu_SetMode+0x3c>)
    4704:	9b01      	ldr	r3, [sp, #4]
    4706:	4413      	add	r3, r2
    4708:	781b      	ldrb	r3, [r3, #0]
    470a:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    470e:	f001 f8bf 	bl	5890 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    4712:	4b0a      	ldr	r3, [pc, #40]	; (473c <Mcu_SetMode+0x40>)
    4714:	681b      	ldr	r3, [r3, #0]
    4716:	6919      	ldr	r1, [r3, #16]
    4718:	f89d 200f 	ldrb.w	r2, [sp, #15]
    471c:	4613      	mov	r3, r2
    471e:	005b      	lsls	r3, r3, #1
    4720:	4413      	add	r3, r2
    4722:	009b      	lsls	r3, r3, #2
    4724:	440b      	add	r3, r1
    4726:	4618      	mov	r0, r3
    4728:	f000 f87b 	bl	4822 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    472c:	f001 f8dc 	bl	58e8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    4730:	bf00      	nop
    4732:	b005      	add	sp, #20
    4734:	f85d fb04 	ldr.w	pc, [sp], #4
    4738:	1fff8cd8 	.word	0x1fff8cd8
    473c:	1fff8cdc 	.word	0x1fff8cdc

00004740 <Mcu_DistributePllClock>:
*
* @implements Mcu_DistributePllClock_Activity
*
*/
Std_ReturnType Mcu_DistributePllClock(void)
{
    4740:	b500      	push	{lr}
    4742:	b083      	sub	sp, #12
#endif /* (MCU_PARAM_CHECK == STD_ON) */

            /* Set the PLL as System Clock if it is locked and enabled by the current mode.
            If the PLL0 is already selected as system clock, then this function will return without
            doing anything. */
            Mcu_Ipw_DistributePllClock();
    4744:	f000 f850 	bl	47e8 <Mcu_Ipw_DistributePllClock>

            PllStatus = (Std_ReturnType)E_OK;
    4748:	2300      	movs	r3, #0
    474a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_DISTRIBUTEPLLCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    474e:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    4752:	4618      	mov	r0, r3
    4754:	b003      	add	sp, #12
    4756:	f85d fb04 	ldr.w	pc, [sp], #4

0000475a <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    475a:	b500      	push	{lr}
    475c:	b083      	sub	sp, #12

    /* If the PLL is not used in the configuration, return MCU_PLL_STATUS_UNDEFINED. */
#if (MCU_NO_PLL == STD_OFF)
        /* Get status of the PLL (if enabled in current mode).
           At this point, the return value can be only MCU_PLL_LOCKED or MCU_PLL_UNLOCKED. */
        PllStatus = Mcu_Ipw_GetPllStatus();
    475e:	f000 f848 	bl	47f2 <Mcu_Ipw_GetPllStatus>
    4762:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    4764:	9b01      	ldr	r3, [sp, #4]
}
    4766:	4618      	mov	r0, r3
    4768:	b003      	add	sp, #12
    476a:	f85d fb04 	ldr.w	pc, [sp], #4

0000476e <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    476e:	b500      	push	{lr}
    4770:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    4772:	f000 f860 	bl	4836 <Mcu_Ipw_GetResetReason>
    4776:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    4778:	9b01      	ldr	r3, [sp, #4]
}
    477a:	4618      	mov	r0, r3
    477c:	b003      	add	sp, #12
    477e:	f85d fb04 	ldr.w	pc, [sp], #4

00004782 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    4782:	b500      	push	{lr}
    4784:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    4786:	f000 f85c 	bl	4842 <Mcu_Ipw_GetResetRawValue>
    478a:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    478c:	9b01      	ldr	r3, [sp, #4]
}
    478e:	4618      	mov	r0, r3
    4790:	b003      	add	sp, #12
    4792:	f85d fb04 	ldr.w	pc, [sp], #4

00004796 <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4796:	b500      	push	{lr}
    4798:	b083      	sub	sp, #12
    479a:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    479c:	9801      	ldr	r0, [sp, #4]
    479e:	f000 f856 	bl	484e <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    47a2:	bf00      	nop
    47a4:	b003      	add	sp, #12
    47a6:	f85d fb04 	ldr.w	pc, [sp], #4

000047aa <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    47aa:	b082      	sub	sp, #8
    47ac:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    47ae:	4b03      	ldr	r3, [pc, #12]	; (47bc <Mcu_ClkSrcFailureNotification+0x12>)
    47b0:	681b      	ldr	r3, [r3, #0]
    47b2:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    47b4:	bf00      	nop
    47b6:	b002      	add	sp, #8
    47b8:	4770      	bx	lr
    47ba:	bf00      	nop
    47bc:	1fff8cdc 	.word	0x1fff8cdc

000047c0 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    47c0:	b500      	push	{lr}
    47c2:	b083      	sub	sp, #12
    47c4:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    47c6:	9801      	ldr	r0, [sp, #4]
    47c8:	f000 f89e 	bl	4908 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    47cc:	bf00      	nop
    47ce:	b003      	add	sp, #12
    47d0:	f85d fb04 	ldr.w	pc, [sp], #4

000047d4 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    47d4:	b500      	push	{lr}
    47d6:	b083      	sub	sp, #12
    47d8:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    47da:	9801      	ldr	r0, [sp, #4]
    47dc:	f7fc fc5a 	bl	1094 <Clock_Ip_InitClock>
}
    47e0:	bf00      	nop
    47e2:	b003      	add	sp, #12
    47e4:	f85d fb04 	ldr.w	pc, [sp], #4

000047e8 <Mcu_Ipw_DistributePllClock>:
*
* @return           void
*
*/
void Mcu_Ipw_DistributePllClock(void)
{
    47e8:	b508      	push	{r3, lr}
    Clock_Ip_DistributePll();
    47ea:	f7fd f839 	bl	1860 <Clock_Ip_DistributePll>
}
    47ee:	bf00      	nop
    47f0:	bd08      	pop	{r3, pc}

000047f2 <Mcu_Ipw_GetPllStatus>:
* @retval           MCU_PLL_LOCKED             PLL is locked.
* @retval           MCU_PLL_UNLOCKED           PLL is unlocked.
*
*/
Mcu_PllStatusType Mcu_Ipw_GetPllStatus(void)
{
    47f2:	b500      	push	{lr}
    47f4:	b083      	sub	sp, #12
    /* PLL status variable. */
    Mcu_PllStatusType PllStatus;

    switch(Clock_Ip_GetPllStatus())
    47f6:	f7fc ffaf 	bl	1758 <Clock_Ip_GetPllStatus>
    47fa:	4603      	mov	r3, r0
    47fc:	2b00      	cmp	r3, #0
    47fe:	d002      	beq.n	4806 <Mcu_Ipw_GetPllStatus+0x14>
    4800:	2b01      	cmp	r3, #1
    4802:	d003      	beq.n	480c <Mcu_Ipw_GetPllStatus+0x1a>
    4804:	e005      	b.n	4812 <Mcu_Ipw_GetPllStatus+0x20>
    {
        case CLOCK_IP_PLL_LOCKED:
        {
            PllStatus = MCU_PLL_LOCKED;
    4806:	2300      	movs	r3, #0
    4808:	9301      	str	r3, [sp, #4]
        }
        break;
    480a:	e005      	b.n	4818 <Mcu_Ipw_GetPllStatus+0x26>
        case CLOCK_IP_PLL_UNLOCKED:
        {
            PllStatus = MCU_PLL_UNLOCKED;
    480c:	2301      	movs	r3, #1
    480e:	9301      	str	r3, [sp, #4]
        }
        break;
    4810:	e002      	b.n	4818 <Mcu_Ipw_GetPllStatus+0x26>
        case CLOCK_IP_PLL_STATUS_UNDEFINED:
        default:
        {
            PllStatus = MCU_PLL_STATUS_UNDEFINED;
    4812:	2302      	movs	r3, #2
    4814:	9301      	str	r3, [sp, #4]
        }
        break;
    4816:	bf00      	nop
    }

    /* Return the PLL status. */
    return PllStatus;
    4818:	9b01      	ldr	r3, [sp, #4]
}
    481a:	4618      	mov	r0, r3
    481c:	b003      	add	sp, #12
    481e:	f85d fb04 	ldr.w	pc, [sp], #4

00004822 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    4822:	b500      	push	{lr}
    4824:	b083      	sub	sp, #12
    4826:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    4828:	9801      	ldr	r0, [sp, #4]
    482a:	f000 f81f 	bl	486c <Power_Ip_SetMode>
}
    482e:	bf00      	nop
    4830:	b003      	add	sp, #12
    4832:	f85d fb04 	ldr.w	pc, [sp], #4

00004836 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    4836:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    4838:	f000 f84e 	bl	48d8 <Power_Ip_GetResetReason>
    483c:	4603      	mov	r3, r0
}
    483e:	4618      	mov	r0, r3
    4840:	bd08      	pop	{r3, pc}

00004842 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    4842:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    4844:	f000 f856 	bl	48f4 <Power_Ip_GetResetRawValue>
    4848:	4603      	mov	r3, r0
}
    484a:	4618      	mov	r0, r3
    484c:	bd08      	pop	{r3, pc}

0000484e <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    484e:	b500      	push	{lr}
    4850:	b083      	sub	sp, #12
    4852:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    4854:	9b01      	ldr	r3, [sp, #4]
    4856:	2b00      	cmp	r3, #0
    4858:	d102      	bne.n	4860 <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    485a:	f000 f86b 	bl	4934 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    485e:	e001      	b.n	4864 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    4860:	f000 f86d 	bl	493e <Power_Ip_EnableSleepOnExit>
}
    4864:	bf00      	nop
    4866:	b003      	add	sp, #12
    4868:	f85d fb04 	ldr.w	pc, [sp], #4

0000486c <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    486c:	b500      	push	{lr}
    486e:	b085      	sub	sp, #20
    4870:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    4872:	9b01      	ldr	r3, [sp, #4]
    4874:	685b      	ldr	r3, [r3, #4]
    4876:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    4878:	9802      	ldr	r0, [sp, #8]
    487a:	f000 f9f5 	bl	4c68 <Power_Ip_SMC_ModeCheckEntry>
    487e:	4603      	mov	r3, r0
    4880:	2b00      	cmp	r3, #0
    4882:	d002      	beq.n	488a <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4884:	2301      	movs	r3, #1
    4886:	9303      	str	r3, [sp, #12]
    4888:	e003      	b.n	4892 <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    488a:	9801      	ldr	r0, [sp, #4]
    488c:	f000 fa1e 	bl	4ccc <Power_Ip_SMC_ModeConfig>
    4890:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    4892:	9b03      	ldr	r3, [sp, #12]
    4894:	2b01      	cmp	r3, #1
    4896:	d103      	bne.n	48a0 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4898:	21ff      	movs	r1, #255	; 0xff
    489a:	2003      	movs	r0, #3
    489c:	f000 f8f4 	bl	4a88 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    48a0:	bf00      	nop
    48a2:	b005      	add	sp, #20
    48a4:	f85d fb04 	ldr.w	pc, [sp], #4

000048a8 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    48a8:	b084      	sub	sp, #16
    48aa:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    48ac:	230c      	movs	r3, #12
    48ae:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    48b0:	4a08      	ldr	r2, [pc, #32]	; (48d4 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    48b2:	9b01      	ldr	r3, [sp, #4]
    48b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    48b8:	2b0e      	cmp	r3, #14
    48ba:	d805      	bhi.n	48c8 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    48bc:	4a05      	ldr	r2, [pc, #20]	; (48d4 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    48be:	9b01      	ldr	r3, [sp, #4]
    48c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    48c4:	9303      	str	r3, [sp, #12]
    48c6:	e001      	b.n	48cc <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    48c8:	230c      	movs	r3, #12
    48ca:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    48cc:	9b03      	ldr	r3, [sp, #12]
}
    48ce:	4618      	mov	r0, r3
    48d0:	b004      	add	sp, #16
    48d2:	4770      	bx	lr
    48d4:	000073b8 	.word	0x000073b8

000048d8 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    48d8:	b500      	push	{lr}
    48da:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    48dc:	f000 f940 	bl	4b60 <Power_Ip_RCM_GetResetReason>
    48e0:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    48e2:	9801      	ldr	r0, [sp, #4]
    48e4:	f7ff ffe0 	bl	48a8 <Power_Ip_ConvertIntergeToResetType>
    48e8:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    48ea:	9b00      	ldr	r3, [sp, #0]
}
    48ec:	4618      	mov	r0, r3
    48ee:	b003      	add	sp, #12
    48f0:	f85d fb04 	ldr.w	pc, [sp], #4

000048f4 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    48f4:	b500      	push	{lr}
    48f6:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    48f8:	f000 f98a 	bl	4c10 <Power_Ip_RCM_GetResetRawValue>
    48fc:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    48fe:	9b01      	ldr	r3, [sp, #4]
}
    4900:	4618      	mov	r0, r3
    4902:	b003      	add	sp, #12
    4904:	f85d fb04 	ldr.w	pc, [sp], #4

00004908 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    4908:	b500      	push	{lr}
    490a:	b083      	sub	sp, #12
    490c:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    490e:	9b01      	ldr	r3, [sp, #4]
    4910:	681b      	ldr	r3, [r3, #0]
    4912:	4618      	mov	r0, r3
    4914:	f000 f90e 	bl	4b34 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    4918:	9b01      	ldr	r3, [sp, #4]
    491a:	685b      	ldr	r3, [r3, #4]
    491c:	4618      	mov	r0, r3
    491e:	f000 f86d 	bl	49fc <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    4922:	9b01      	ldr	r3, [sp, #4]
    4924:	689b      	ldr	r3, [r3, #8]
    4926:	4618      	mov	r0, r3
    4928:	f000 f990 	bl	4c4c <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    492c:	bf00      	nop
    492e:	b003      	add	sp, #12
    4930:	f85d fb04 	ldr.w	pc, [sp], #4

00004934 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    4934:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    4936:	f000 f811 	bl	495c <Power_Ip_CM4_DisableSleepOnExit>
}
    493a:	bf00      	nop
    493c:	bd08      	pop	{r3, pc}

0000493e <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    493e:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    4940:	f000 f820 	bl	4984 <Power_Ip_CM4_EnableSleepOnExit>
}
    4944:	bf00      	nop
    4946:	bd08      	pop	{r3, pc}

00004948 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    4948:	b082      	sub	sp, #8
    494a:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    494c:	4a02      	ldr	r2, [pc, #8]	; (4958 <Power_Ip_InstallNotificationsCallback+0x10>)
    494e:	9b01      	ldr	r3, [sp, #4]
    4950:	6013      	str	r3, [r2, #0]
}
    4952:	bf00      	nop
    4954:	b002      	add	sp, #8
    4956:	4770      	bx	lr
    4958:	1fff8b1c 	.word	0x1fff8b1c

0000495c <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    495c:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    495e:	2300      	movs	r3, #0
    4960:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    4962:	4b07      	ldr	r3, [pc, #28]	; (4980 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4964:	681b      	ldr	r3, [r3, #0]
    4966:	685b      	ldr	r3, [r3, #4]
    4968:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    496a:	9b01      	ldr	r3, [sp, #4]
    496c:	f023 0302 	bic.w	r3, r3, #2
    4970:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    4972:	4b03      	ldr	r3, [pc, #12]	; (4980 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    4974:	681b      	ldr	r3, [r3, #0]
    4976:	9a01      	ldr	r2, [sp, #4]
    4978:	605a      	str	r2, [r3, #4]
}
    497a:	bf00      	nop
    497c:	b002      	add	sp, #8
    497e:	4770      	bx	lr
    4980:	1fff8b20 	.word	0x1fff8b20

00004984 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    4984:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    4986:	2300      	movs	r3, #0
    4988:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    498a:	4b07      	ldr	r3, [pc, #28]	; (49a8 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    498c:	681b      	ldr	r3, [r3, #0]
    498e:	685b      	ldr	r3, [r3, #4]
    4990:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    4992:	9b01      	ldr	r3, [sp, #4]
    4994:	f043 0302 	orr.w	r3, r3, #2
    4998:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    499a:	4b03      	ldr	r3, [pc, #12]	; (49a8 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    499c:	681b      	ldr	r3, [r3, #0]
    499e:	9a01      	ldr	r2, [sp, #4]
    49a0:	605a      	str	r2, [r3, #4]
}
    49a2:	bf00      	nop
    49a4:	b002      	add	sp, #8
    49a6:	4770      	bx	lr
    49a8:	1fff8b20 	.word	0x1fff8b20

000049ac <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    49ac:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    49ae:	2300      	movs	r3, #0
    49b0:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    49b2:	4b07      	ldr	r3, [pc, #28]	; (49d0 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    49b4:	681b      	ldr	r3, [r3, #0]
    49b6:	685b      	ldr	r3, [r3, #4]
    49b8:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    49ba:	9b01      	ldr	r3, [sp, #4]
    49bc:	f043 0304 	orr.w	r3, r3, #4
    49c0:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    49c2:	4b03      	ldr	r3, [pc, #12]	; (49d0 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    49c4:	681b      	ldr	r3, [r3, #0]
    49c6:	9a01      	ldr	r2, [sp, #4]
    49c8:	605a      	str	r2, [r3, #4]
}
    49ca:	bf00      	nop
    49cc:	b002      	add	sp, #8
    49ce:	4770      	bx	lr
    49d0:	1fff8b20 	.word	0x1fff8b20

000049d4 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    49d4:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    49d6:	2300      	movs	r3, #0
    49d8:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    49da:	4b07      	ldr	r3, [pc, #28]	; (49f8 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    49dc:	681b      	ldr	r3, [r3, #0]
    49de:	685b      	ldr	r3, [r3, #4]
    49e0:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    49e2:	9b01      	ldr	r3, [sp, #4]
    49e4:	f023 0304 	bic.w	r3, r3, #4
    49e8:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    49ea:	4b03      	ldr	r3, [pc, #12]	; (49f8 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    49ec:	681b      	ldr	r3, [r3, #0]
    49ee:	9a01      	ldr	r2, [sp, #4]
    49f0:	605a      	str	r2, [r3, #4]
}
    49f2:	bf00      	nop
    49f4:	b002      	add	sp, #8
    49f6:	4770      	bx	lr
    49f8:	1fff8b20 	.word	0x1fff8b20

000049fc <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    49fc:	b084      	sub	sp, #16
    49fe:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    4a00:	4b20      	ldr	r3, [pc, #128]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a02:	781b      	ldrb	r3, [r3, #0]
    4a04:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    4a08:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a0c:	f003 030f 	and.w	r3, r3, #15
    4a10:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    4a14:	9b01      	ldr	r3, [sp, #4]
    4a16:	781a      	ldrb	r2, [r3, #0]
    4a18:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a1c:	4313      	orrs	r3, r2
    4a1e:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    4a22:	4a18      	ldr	r2, [pc, #96]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a24:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a28:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    4a2a:	4b16      	ldr	r3, [pc, #88]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a2c:	785b      	ldrb	r3, [r3, #1]
    4a2e:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    4a32:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a36:	f003 031f 	and.w	r3, r3, #31
    4a3a:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    4a3e:	9b01      	ldr	r3, [sp, #4]
    4a40:	785a      	ldrb	r2, [r3, #1]
    4a42:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a46:	4313      	orrs	r3, r2
    4a48:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    4a4c:	4a0d      	ldr	r2, [pc, #52]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a52:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    4a54:	4b0b      	ldr	r3, [pc, #44]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a56:	789b      	ldrb	r3, [r3, #2]
    4a58:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    4a5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a60:	f003 0338 	and.w	r3, r3, #56	; 0x38
    4a64:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    4a68:	9b01      	ldr	r3, [sp, #4]
    4a6a:	789a      	ldrb	r2, [r3, #2]
    4a6c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a70:	4313      	orrs	r3, r2
    4a72:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    4a76:	4a03      	ldr	r2, [pc, #12]	; (4a84 <Power_Ip_PMC_PowerInit+0x88>)
    4a78:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4a7c:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    4a7e:	bf00      	nop
    4a80:	b004      	add	sp, #16
    4a82:	4770      	bx	lr
    4a84:	4007d000 	.word	0x4007d000

00004a88 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4a88:	b500      	push	{lr}
    4a8a:	b083      	sub	sp, #12
    4a8c:	9001      	str	r0, [sp, #4]
    4a8e:	460b      	mov	r3, r1
    4a90:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    4a94:	4b05      	ldr	r3, [pc, #20]	; (4aac <Power_Ip_ReportPowerErrors+0x24>)
    4a96:	681b      	ldr	r3, [r3, #0]
    4a98:	f89d 2003 	ldrb.w	r2, [sp, #3]
    4a9c:	4611      	mov	r1, r2
    4a9e:	9801      	ldr	r0, [sp, #4]
    4aa0:	4798      	blx	r3
}
    4aa2:	bf00      	nop
    4aa4:	b003      	add	sp, #12
    4aa6:	f85d fb04 	ldr.w	pc, [sp], #4
    4aaa:	bf00      	nop
    4aac:	1fff8b1c 	.word	0x1fff8b1c

00004ab0 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4ab0:	b082      	sub	sp, #8
    4ab2:	9001      	str	r0, [sp, #4]
    4ab4:	460b      	mov	r3, r1
    4ab6:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    4aba:	bf00      	nop
    4abc:	b002      	add	sp, #8
    4abe:	4770      	bx	lr

00004ac0 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    4ac0:	b500      	push	{lr}
    4ac2:	b085      	sub	sp, #20
    4ac4:	9003      	str	r0, [sp, #12]
    4ac6:	9102      	str	r1, [sp, #8]
    4ac8:	9201      	str	r2, [sp, #4]
    4aca:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    4acc:	2000      	movs	r0, #0
    4ace:	f7fc f810 	bl	af2 <OsIf_GetCounter>
    4ad2:	4602      	mov	r2, r0
    4ad4:	9b03      	ldr	r3, [sp, #12]
    4ad6:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    4ad8:	9b02      	ldr	r3, [sp, #8]
    4ada:	2200      	movs	r2, #0
    4adc:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    4ade:	2100      	movs	r1, #0
    4ae0:	9800      	ldr	r0, [sp, #0]
    4ae2:	f7fc f852 	bl	b8a <OsIf_MicrosToTicks>
    4ae6:	4602      	mov	r2, r0
    4ae8:	9b01      	ldr	r3, [sp, #4]
    4aea:	601a      	str	r2, [r3, #0]
}
    4aec:	bf00      	nop
    4aee:	b005      	add	sp, #20
    4af0:	f85d fb04 	ldr.w	pc, [sp], #4

00004af4 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    4af4:	b500      	push	{lr}
    4af6:	b087      	sub	sp, #28
    4af8:	9003      	str	r0, [sp, #12]
    4afa:	9102      	str	r1, [sp, #8]
    4afc:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    4afe:	2300      	movs	r3, #0
    4b00:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    4b04:	2100      	movs	r1, #0
    4b06:	9803      	ldr	r0, [sp, #12]
    4b08:	f7fc f80c 	bl	b24 <OsIf_GetElapsed>
    4b0c:	4602      	mov	r2, r0
    4b0e:	9b02      	ldr	r3, [sp, #8]
    4b10:	681b      	ldr	r3, [r3, #0]
    4b12:	441a      	add	r2, r3
    4b14:	9b02      	ldr	r3, [sp, #8]
    4b16:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    4b18:	9b02      	ldr	r3, [sp, #8]
    4b1a:	681b      	ldr	r3, [r3, #0]
    4b1c:	9a01      	ldr	r2, [sp, #4]
    4b1e:	429a      	cmp	r2, r3
    4b20:	d802      	bhi.n	4b28 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    4b22:	2301      	movs	r3, #1
    4b24:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    4b28:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    4b2c:	4618      	mov	r0, r3
    4b2e:	b007      	add	sp, #28
    4b30:	f85d fb04 	ldr.w	pc, [sp], #4

00004b34 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    4b34:	b082      	sub	sp, #8
    4b36:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    4b38:	9b01      	ldr	r3, [sp, #4]
    4b3a:	681a      	ldr	r2, [r3, #0]
    4b3c:	4907      	ldr	r1, [pc, #28]	; (4b5c <Power_Ip_RCM_ResetInit+0x28>)
    4b3e:	f641 7307 	movw	r3, #7943	; 0x1f07
    4b42:	4013      	ands	r3, r2
    4b44:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    4b46:	9b01      	ldr	r3, [sp, #4]
    4b48:	685a      	ldr	r2, [r3, #4]
    4b4a:	4904      	ldr	r1, [pc, #16]	; (4b5c <Power_Ip_RCM_ResetInit+0x28>)
    4b4c:	f642 73ff 	movw	r3, #12287	; 0x2fff
    4b50:	4013      	ands	r3, r2
    4b52:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    4b54:	bf00      	nop
    4b56:	b002      	add	sp, #8
    4b58:	4770      	bx	lr
    4b5a:	bf00      	nop
    4b5c:	4007f000 	.word	0x4007f000

00004b60 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    4b60:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    4b62:	230c      	movs	r3, #12
    4b64:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    4b66:	2300      	movs	r3, #0
    4b68:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    4b6a:	2300      	movs	r3, #0
    4b6c:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    4b6e:	2300      	movs	r3, #0
    4b70:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    4b72:	4b25      	ldr	r3, [pc, #148]	; (4c08 <Power_Ip_RCM_GetResetReason+0xa8>)
    4b74:	699a      	ldr	r2, [r3, #24]
    4b76:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4b7a:	4013      	ands	r3, r2
    4b7c:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    4b7e:	9b03      	ldr	r3, [sp, #12]
    4b80:	2b00      	cmp	r3, #0
    4b82:	d008      	beq.n	4b96 <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    4b84:	4920      	ldr	r1, [pc, #128]	; (4c08 <Power_Ip_RCM_GetResetReason+0xa8>)
    4b86:	9a03      	ldr	r2, [sp, #12]
    4b88:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4b8c:	4013      	ands	r3, r2
    4b8e:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    4b90:	4a1e      	ldr	r2, [pc, #120]	; (4c0c <Power_Ip_RCM_GetResetReason+0xac>)
    4b92:	9b03      	ldr	r3, [sp, #12]
    4b94:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    4b96:	4b1d      	ldr	r3, [pc, #116]	; (4c0c <Power_Ip_RCM_GetResetReason+0xac>)
    4b98:	681b      	ldr	r3, [r3, #0]
    4b9a:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    4b9c:	9a02      	ldr	r2, [sp, #8]
    4b9e:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4ba2:	4013      	ands	r3, r2
    4ba4:	2b82      	cmp	r3, #130	; 0x82
    4ba6:	d102      	bne.n	4bae <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    4ba8:	2305      	movs	r3, #5
    4baa:	9307      	str	r3, [sp, #28]
    4bac:	e027      	b.n	4bfe <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    4bae:	2300      	movs	r3, #0
    4bb0:	9306      	str	r3, [sp, #24]
    4bb2:	e021      	b.n	4bf8 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    4bb4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4bb8:	9b06      	ldr	r3, [sp, #24]
    4bba:	fa22 f303 	lsr.w	r3, r2, r3
    4bbe:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    4bc0:	9a01      	ldr	r2, [sp, #4]
    4bc2:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    4bc6:	4013      	ands	r3, r2
    4bc8:	2b00      	cmp	r3, #0
    4bca:	d012      	beq.n	4bf2 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    4bcc:	9a01      	ldr	r2, [sp, #4]
    4bce:	9b02      	ldr	r3, [sp, #8]
    4bd0:	4013      	ands	r3, r2
    4bd2:	2b00      	cmp	r3, #0
    4bd4:	d00a      	beq.n	4bec <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    4bd6:	9b05      	ldr	r3, [sp, #20]
    4bd8:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    4bda:	9b04      	ldr	r3, [sp, #16]
    4bdc:	3301      	adds	r3, #1
    4bde:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    4be0:	9b04      	ldr	r3, [sp, #16]
    4be2:	2b01      	cmp	r3, #1
    4be4:	d902      	bls.n	4bec <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    4be6:	230d      	movs	r3, #13
    4be8:	9307      	str	r3, [sp, #28]
                        break;
    4bea:	e008      	b.n	4bfe <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    4bec:	9b05      	ldr	r3, [sp, #20]
    4bee:	3301      	adds	r3, #1
    4bf0:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    4bf2:	9b06      	ldr	r3, [sp, #24]
    4bf4:	3301      	adds	r3, #1
    4bf6:	9306      	str	r3, [sp, #24]
    4bf8:	9b06      	ldr	r3, [sp, #24]
    4bfa:	2b1f      	cmp	r3, #31
    4bfc:	d9da      	bls.n	4bb4 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    4bfe:	9b07      	ldr	r3, [sp, #28]
}
    4c00:	4618      	mov	r0, r3
    4c02:	b008      	add	sp, #32
    4c04:	4770      	bx	lr
    4c06:	bf00      	nop
    4c08:	4007f000 	.word	0x4007f000
    4c0c:	1fff8ce0 	.word	0x1fff8ce0

00004c10 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    4c10:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    4c12:	4b0c      	ldr	r3, [pc, #48]	; (4c44 <Power_Ip_RCM_GetResetRawValue+0x34>)
    4c14:	699a      	ldr	r2, [r3, #24]
    4c16:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4c1a:	4013      	ands	r3, r2
    4c1c:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    4c1e:	9b01      	ldr	r3, [sp, #4]
    4c20:	2b00      	cmp	r3, #0
    4c22:	d008      	beq.n	4c36 <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    4c24:	4907      	ldr	r1, [pc, #28]	; (4c44 <Power_Ip_RCM_GetResetRawValue+0x34>)
    4c26:	9a01      	ldr	r2, [sp, #4]
    4c28:	f642 73ee 	movw	r3, #12270	; 0x2fee
    4c2c:	4013      	ands	r3, r2
    4c2e:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    4c30:	4a05      	ldr	r2, [pc, #20]	; (4c48 <Power_Ip_RCM_GetResetRawValue+0x38>)
    4c32:	9b01      	ldr	r3, [sp, #4]
    4c34:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    4c36:	4b04      	ldr	r3, [pc, #16]	; (4c48 <Power_Ip_RCM_GetResetRawValue+0x38>)
    4c38:	681b      	ldr	r3, [r3, #0]
    4c3a:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    4c3c:	9b00      	ldr	r3, [sp, #0]
}
    4c3e:	4618      	mov	r0, r3
    4c40:	b002      	add	sp, #8
    4c42:	4770      	bx	lr
    4c44:	4007f000 	.word	0x4007f000
    4c48:	1fff8ce0 	.word	0x1fff8ce0

00004c4c <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    4c4c:	b082      	sub	sp, #8
    4c4e:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    4c50:	9b01      	ldr	r3, [sp, #4]
    4c52:	681b      	ldr	r3, [r3, #0]
    4c54:	4a03      	ldr	r2, [pc, #12]	; (4c64 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    4c56:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    4c5a:	6093      	str	r3, [r2, #8]
}
    4c5c:	bf00      	nop
    4c5e:	b002      	add	sp, #8
    4c60:	4770      	bx	lr
    4c62:	bf00      	nop
    4c64:	4007e000 	.word	0x4007e000

00004c68 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    4c68:	b084      	sub	sp, #16
    4c6a:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    4c6c:	2301      	movs	r3, #1
    4c6e:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    4c70:	4b15      	ldr	r3, [pc, #84]	; (4cc8 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    4c72:	695b      	ldr	r3, [r3, #20]
    4c74:	b2db      	uxtb	r3, r3
    4c76:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    4c78:	9b01      	ldr	r3, [sp, #4]
    4c7a:	2b02      	cmp	r3, #2
    4c7c:	d012      	beq.n	4ca4 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    4c7e:	9b01      	ldr	r3, [sp, #4]
    4c80:	2b02      	cmp	r3, #2
    4c82:	d818      	bhi.n	4cb6 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    4c84:	9b01      	ldr	r3, [sp, #4]
    4c86:	2b00      	cmp	r3, #0
    4c88:	d003      	beq.n	4c92 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    4c8a:	9b01      	ldr	r3, [sp, #4]
    4c8c:	2b01      	cmp	r3, #1
    4c8e:	d003      	beq.n	4c98 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    4c90:	e011      	b.n	4cb6 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    4c92:	2300      	movs	r3, #0
    4c94:	9303      	str	r3, [sp, #12]
            break;
    4c96:	e013      	b.n	4cc0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    4c98:	9b02      	ldr	r3, [sp, #8]
    4c9a:	2b01      	cmp	r3, #1
    4c9c:	d10d      	bne.n	4cba <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    4c9e:	2300      	movs	r3, #0
    4ca0:	9303      	str	r3, [sp, #12]
            break;
    4ca2:	e00a      	b.n	4cba <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    4ca4:	9b02      	ldr	r3, [sp, #8]
    4ca6:	2b01      	cmp	r3, #1
    4ca8:	d002      	beq.n	4cb0 <Power_Ip_SMC_ModeCheckEntry+0x48>
    4caa:	9b02      	ldr	r3, [sp, #8]
    4cac:	2b10      	cmp	r3, #16
    4cae:	d106      	bne.n	4cbe <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    4cb0:	2300      	movs	r3, #0
    4cb2:	9303      	str	r3, [sp, #12]
            break;
    4cb4:	e003      	b.n	4cbe <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    4cb6:	bf00      	nop
    4cb8:	e002      	b.n	4cc0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4cba:	bf00      	nop
    4cbc:	e000      	b.n	4cc0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4cbe:	bf00      	nop
        }
    }

    return PowerModeCheck;
    4cc0:	9b03      	ldr	r3, [sp, #12]
}
    4cc2:	4618      	mov	r0, r3
    4cc4:	b004      	add	sp, #16
    4cc6:	4770      	bx	lr
    4cc8:	4007e000 	.word	0x4007e000

00004ccc <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4ccc:	b500      	push	{lr}
    4cce:	b08b      	sub	sp, #44	; 0x2c
    4cd0:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    4cd2:	2300      	movs	r3, #0
    4cd4:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    4cd6:	2300      	movs	r3, #0
    4cd8:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    4cda:	2300      	movs	r3, #0
    4cdc:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    4ce0:	9b01      	ldr	r3, [sp, #4]
    4ce2:	685b      	ldr	r3, [r3, #4]
    4ce4:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    4ce6:	9b08      	ldr	r3, [sp, #32]
    4ce8:	2b02      	cmp	r3, #2
    4cea:	d076      	beq.n	4dda <Power_Ip_SMC_ModeConfig+0x10e>
    4cec:	9b08      	ldr	r3, [sp, #32]
    4cee:	2b02      	cmp	r3, #2
    4cf0:	f200 80ab 	bhi.w	4e4a <Power_Ip_SMC_ModeConfig+0x17e>
    4cf4:	9b08      	ldr	r3, [sp, #32]
    4cf6:	2b00      	cmp	r3, #0
    4cf8:	d003      	beq.n	4d02 <Power_Ip_SMC_ModeConfig+0x36>
    4cfa:	9b08      	ldr	r3, [sp, #32]
    4cfc:	2b01      	cmp	r3, #1
    4cfe:	d034      	beq.n	4d6a <Power_Ip_SMC_ModeConfig+0x9e>
    4d00:	e0a3      	b.n	4e4a <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    4d02:	4b58      	ldr	r3, [pc, #352]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4d04:	68db      	ldr	r3, [r3, #12]
    4d06:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4d08:	9b06      	ldr	r3, [sp, #24]
    4d0a:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4d0e:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    4d10:	4a54      	ldr	r2, [pc, #336]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4d12:	9b06      	ldr	r3, [sp, #24]
    4d14:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4d16:	aa02      	add	r2, sp, #8
    4d18:	a903      	add	r1, sp, #12
    4d1a:	a804      	add	r0, sp, #16
    4d1c:	f24c 3350 	movw	r3, #50000	; 0xc350
    4d20:	f7ff fece 	bl	4ac0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4d24:	9a02      	ldr	r2, [sp, #8]
    4d26:	a903      	add	r1, sp, #12
    4d28:	ab04      	add	r3, sp, #16
    4d2a:	4618      	mov	r0, r3
    4d2c:	f7ff fee2 	bl	4af4 <Power_Ip_TimeoutExpired>
    4d30:	4603      	mov	r3, r0
    4d32:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    4d36:	4b4b      	ldr	r3, [pc, #300]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4d38:	695b      	ldr	r3, [r3, #20]
    4d3a:	f003 0301 	and.w	r3, r3, #1
    4d3e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4d40:	9b05      	ldr	r3, [sp, #20]
    4d42:	2b01      	cmp	r3, #1
    4d44:	d006      	beq.n	4d54 <Power_Ip_SMC_ModeConfig+0x88>
    4d46:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4d4a:	f083 0301 	eor.w	r3, r3, #1
    4d4e:	b2db      	uxtb	r3, r3
    4d50:	2b00      	cmp	r3, #0
    4d52:	d1e7      	bne.n	4d24 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    4d54:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4d58:	2b00      	cmp	r3, #0
    4d5a:	d079      	beq.n	4e50 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4d5c:	2301      	movs	r3, #1
    4d5e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4d60:	21ff      	movs	r1, #255	; 0xff
    4d62:	2000      	movs	r0, #0
    4d64:	f7ff fe90 	bl	4a88 <Power_Ip_ReportPowerErrors>
            }

            break;
    4d68:	e072      	b.n	4e50 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    4d6a:	4b3e      	ldr	r3, [pc, #248]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4d6c:	68db      	ldr	r3, [r3, #12]
    4d6e:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4d70:	9b06      	ldr	r3, [sp, #24]
    4d72:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4d76:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    4d78:	9b06      	ldr	r3, [sp, #24]
    4d7a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    4d7e:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4d80:	4a38      	ldr	r2, [pc, #224]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4d82:	9b06      	ldr	r3, [sp, #24]
    4d84:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4d86:	aa02      	add	r2, sp, #8
    4d88:	a903      	add	r1, sp, #12
    4d8a:	a804      	add	r0, sp, #16
    4d8c:	f24c 3350 	movw	r3, #50000	; 0xc350
    4d90:	f7ff fe96 	bl	4ac0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4d94:	9a02      	ldr	r2, [sp, #8]
    4d96:	a903      	add	r1, sp, #12
    4d98:	ab04      	add	r3, sp, #16
    4d9a:	4618      	mov	r0, r3
    4d9c:	f7ff feaa 	bl	4af4 <Power_Ip_TimeoutExpired>
    4da0:	4603      	mov	r3, r0
    4da2:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    4da6:	4b2f      	ldr	r3, [pc, #188]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4da8:	695b      	ldr	r3, [r3, #20]
    4daa:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4dae:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4db0:	9b05      	ldr	r3, [sp, #20]
    4db2:	2b80      	cmp	r3, #128	; 0x80
    4db4:	d006      	beq.n	4dc4 <Power_Ip_SMC_ModeConfig+0xf8>
    4db6:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4dba:	f083 0301 	eor.w	r3, r3, #1
    4dbe:	b2db      	uxtb	r3, r3
    4dc0:	2b00      	cmp	r3, #0
    4dc2:	d1e7      	bne.n	4d94 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    4dc4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4dc8:	2b00      	cmp	r3, #0
    4dca:	d043      	beq.n	4e54 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4dcc:	2301      	movs	r3, #1
    4dce:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4dd0:	21ff      	movs	r1, #255	; 0xff
    4dd2:	2000      	movs	r0, #0
    4dd4:	f7ff fe58 	bl	4a88 <Power_Ip_ReportPowerErrors>
            }

            break;
    4dd8:	e03c      	b.n	4e54 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    4dda:	4b22      	ldr	r3, [pc, #136]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4ddc:	68db      	ldr	r3, [r3, #12]
    4dde:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4de0:	9b06      	ldr	r3, [sp, #24]
    4de2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4de6:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    4de8:	9b06      	ldr	r3, [sp, #24]
    4dea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4dee:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4df0:	4a1c      	ldr	r2, [pc, #112]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4df2:	9b06      	ldr	r3, [sp, #24]
    4df4:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4df6:	aa02      	add	r2, sp, #8
    4df8:	a903      	add	r1, sp, #12
    4dfa:	a804      	add	r0, sp, #16
    4dfc:	f24c 3350 	movw	r3, #50000	; 0xc350
    4e00:	f7ff fe5e 	bl	4ac0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4e04:	9a02      	ldr	r2, [sp, #8]
    4e06:	a903      	add	r1, sp, #12
    4e08:	ab04      	add	r3, sp, #16
    4e0a:	4618      	mov	r0, r3
    4e0c:	f7ff fe72 	bl	4af4 <Power_Ip_TimeoutExpired>
    4e10:	4603      	mov	r3, r0
    4e12:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    4e16:	4b13      	ldr	r3, [pc, #76]	; (4e64 <Power_Ip_SMC_ModeConfig+0x198>)
    4e18:	695b      	ldr	r3, [r3, #20]
    4e1a:	f003 0304 	and.w	r3, r3, #4
    4e1e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4e20:	9b05      	ldr	r3, [sp, #20]
    4e22:	2b04      	cmp	r3, #4
    4e24:	d006      	beq.n	4e34 <Power_Ip_SMC_ModeConfig+0x168>
    4e26:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e2a:	f083 0301 	eor.w	r3, r3, #1
    4e2e:	b2db      	uxtb	r3, r3
    4e30:	2b00      	cmp	r3, #0
    4e32:	d1e7      	bne.n	4e04 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    4e34:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e38:	2b00      	cmp	r3, #0
    4e3a:	d00d      	beq.n	4e58 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4e3c:	2301      	movs	r3, #1
    4e3e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4e40:	21ff      	movs	r1, #255	; 0xff
    4e42:	2000      	movs	r0, #0
    4e44:	f7ff fe20 	bl	4a88 <Power_Ip_ReportPowerErrors>
            }

            break;
    4e48:	e006      	b.n	4e58 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4e4a:	2301      	movs	r3, #1
    4e4c:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    4e4e:	e004      	b.n	4e5a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4e50:	bf00      	nop
    4e52:	e002      	b.n	4e5a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4e54:	bf00      	nop
    4e56:	e000      	b.n	4e5a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4e58:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    4e5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    4e5c:	4618      	mov	r0, r3
    4e5e:	b00b      	add	sp, #44	; 0x2c
    4e60:	f85d fb04 	ldr.w	pc, [sp], #4
    4e64:	4007e000 	.word	0x4007e000

00004e68 <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    4e68:	b500      	push	{lr}
    4e6a:	b085      	sub	sp, #20
    4e6c:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    4e6e:	9b01      	ldr	r3, [sp, #4]
    4e70:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    4e72:	9803      	ldr	r0, [sp, #12]
    4e74:	f000 fbc8 	bl	5608 <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    4e78:	4a03      	ldr	r2, [pc, #12]	; (4e88 <Port_Init+0x20>)
    4e7a:	9b03      	ldr	r3, [sp, #12]
    4e7c:	6013      	str	r3, [r2, #0]
        }
    }
}
    4e7e:	bf00      	nop
    4e80:	b005      	add	sp, #20
    4e82:	f85d fb04 	ldr.w	pc, [sp], #4
    4e86:	bf00      	nop
    4e88:	1fff8ce4 	.word	0x1fff8ce4

00004e8c <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    4e8c:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    4e8e:	4b03      	ldr	r3, [pc, #12]	; (4e9c <Port_RefreshPortDirection+0x10>)
    4e90:	681b      	ldr	r3, [r3, #0]
    4e92:	4618      	mov	r0, r3
    4e94:	f000 fc10 	bl	56b8 <Port_Ipw_RefreshPortDirection>
    }
}
    4e98:	bf00      	nop
    4e9a:	bd08      	pop	{r3, pc}
    4e9c:	1fff8ce4 	.word	0x1fff8ce4

00004ea0 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    4ea0:	b086      	sub	sp, #24
    4ea2:	9003      	str	r0, [sp, #12]
    4ea4:	9102      	str	r1, [sp, #8]
    4ea6:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    4ea8:	23ff      	movs	r3, #255	; 0xff
    4eaa:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    4eac:	9b03      	ldr	r3, [sp, #12]
    4eae:	4a39      	ldr	r2, [pc, #228]	; (4f94 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    4eb0:	4293      	cmp	r3, r2
    4eb2:	d151      	bne.n	4f58 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    4eb4:	9b02      	ldr	r3, [sp, #8]
    4eb6:	2b10      	cmp	r3, #16
    4eb8:	d867      	bhi.n	4f8a <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    4eba:	a201      	add	r2, pc, #4	; (adr r2, 4ec0 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    4ebc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4ec0:	00004f05 	.word	0x00004f05
    4ec4:	00004f13 	.word	0x00004f13
    4ec8:	00004f8b 	.word	0x00004f8b
    4ecc:	00004f8b 	.word	0x00004f8b
    4ed0:	00004f8b 	.word	0x00004f8b
    4ed4:	00004f8b 	.word	0x00004f8b
    4ed8:	00004f8b 	.word	0x00004f8b
    4edc:	00004f8b 	.word	0x00004f8b
    4ee0:	00004f8b 	.word	0x00004f8b
    4ee4:	00004f8b 	.word	0x00004f8b
    4ee8:	00004f8b 	.word	0x00004f8b
    4eec:	00004f8b 	.word	0x00004f8b
    4ef0:	00004f8b 	.word	0x00004f8b
    4ef4:	00004f21 	.word	0x00004f21
    4ef8:	00004f2f 	.word	0x00004f2f
    4efc:	00004f3d 	.word	0x00004f3d
    4f00:	00004f4b 	.word	0x00004f4b
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    4f04:	2301      	movs	r3, #1
    4f06:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f08:	9a05      	ldr	r2, [sp, #20]
    4f0a:	9b01      	ldr	r3, [sp, #4]
    4f0c:	4313      	orrs	r3, r2
    4f0e:	9305      	str	r3, [sp, #20]
                break;
    4f10:	e03c      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    4f12:	2302      	movs	r3, #2
    4f14:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f16:	9a05      	ldr	r2, [sp, #20]
    4f18:	9b01      	ldr	r3, [sp, #4]
    4f1a:	4313      	orrs	r3, r2
    4f1c:	9305      	str	r3, [sp, #20]
                break;
    4f1e:	e035      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    4f20:	2304      	movs	r3, #4
    4f22:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f24:	9a05      	ldr	r2, [sp, #20]
    4f26:	9b01      	ldr	r3, [sp, #4]
    4f28:	4313      	orrs	r3, r2
    4f2a:	9305      	str	r3, [sp, #20]
                break;
    4f2c:	e02e      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    4f2e:	2308      	movs	r3, #8
    4f30:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f32:	9a05      	ldr	r2, [sp, #20]
    4f34:	9b01      	ldr	r3, [sp, #4]
    4f36:	4313      	orrs	r3, r2
    4f38:	9305      	str	r3, [sp, #20]
                break;
    4f3a:	e027      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    4f3c:	230e      	movs	r3, #14
    4f3e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4f40:	9a05      	ldr	r2, [sp, #20]
    4f42:	9b01      	ldr	r3, [sp, #4]
    4f44:	4013      	ands	r3, r2
    4f46:	9305      	str	r3, [sp, #20]
                break;
    4f48:	e020      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    4f4a:	230d      	movs	r3, #13
    4f4c:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4f4e:	9a05      	ldr	r2, [sp, #20]
    4f50:	9b01      	ldr	r3, [sp, #4]
    4f52:	4013      	ands	r3, r2
    4f54:	9305      	str	r3, [sp, #20]
                break;
    4f56:	e019      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    4f58:	9b03      	ldr	r3, [sp, #12]
    4f5a:	4a0f      	ldr	r2, [pc, #60]	; (4f98 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    4f5c:	4293      	cmp	r3, r2
    4f5e:	d115      	bne.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    4f60:	9b02      	ldr	r3, [sp, #8]
    4f62:	2b00      	cmp	r3, #0
    4f64:	d003      	beq.n	4f6e <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    4f66:	9b02      	ldr	r3, [sp, #8]
    4f68:	2b01      	cmp	r3, #1
    4f6a:	d007      	beq.n	4f7c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    4f6c:	e00e      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    4f6e:	230b      	movs	r3, #11
    4f70:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4f72:	9a05      	ldr	r2, [sp, #20]
    4f74:	9b01      	ldr	r3, [sp, #4]
    4f76:	4013      	ands	r3, r2
    4f78:	9305      	str	r3, [sp, #20]
                break;
    4f7a:	e007      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    4f7c:	2307      	movs	r3, #7
    4f7e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4f80:	9a05      	ldr	r2, [sp, #20]
    4f82:	9b01      	ldr	r3, [sp, #4]
    4f84:	4013      	ands	r3, r2
    4f86:	9305      	str	r3, [sp, #20]
                break;
    4f88:	e000      	b.n	4f8c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    4f8a:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    4f8c:	9b05      	ldr	r3, [sp, #20]
}
    4f8e:	4618      	mov	r0, r3
    4f90:	b006      	add	sp, #24
    4f92:	4770      	bx	lr
    4f94:	4004a000 	.word	0x4004a000
    4f98:	4004b000 	.word	0x4004b000

00004f9c <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    4f9c:	b500      	push	{lr}
    4f9e:	b089      	sub	sp, #36	; 0x24
    4fa0:	9003      	str	r0, [sp, #12]
    4fa2:	9102      	str	r1, [sp, #8]
    4fa4:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    4fa6:	9b01      	ldr	r3, [sp, #4]
    4fa8:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    4faa:	9b01      	ldr	r3, [sp, #4]
    4fac:	2b08      	cmp	r3, #8
    4fae:	d121      	bne.n	4ff4 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    4fb0:	4b13      	ldr	r3, [pc, #76]	; (5000 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    4fb2:	685b      	ldr	r3, [r3, #4]
    4fb4:	f003 030f 	and.w	r3, r3, #15
    4fb8:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    4fba:	9a06      	ldr	r2, [sp, #24]
    4fbc:	9902      	ldr	r1, [sp, #8]
    4fbe:	9803      	ldr	r0, [sp, #12]
    4fc0:	f7ff ff6e 	bl	4ea0 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    4fc4:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    4fc6:	9b05      	ldr	r3, [sp, #20]
    4fc8:	2bff      	cmp	r3, #255	; 0xff
    4fca:	d011      	beq.n	4ff0 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    4fcc:	f000 fef0 	bl	5db0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    4fd0:	4b0b      	ldr	r3, [pc, #44]	; (5000 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    4fd2:	685b      	ldr	r3, [r3, #4]
    4fd4:	4a0a      	ldr	r2, [pc, #40]	; (5000 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    4fd6:	f023 030f 	bic.w	r3, r3, #15
    4fda:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    4fdc:	4b08      	ldr	r3, [pc, #32]	; (5000 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    4fde:	685a      	ldr	r2, [r3, #4]
    4fe0:	9b05      	ldr	r3, [sp, #20]
    4fe2:	f003 030f 	and.w	r3, r3, #15
    4fe6:	4906      	ldr	r1, [pc, #24]	; (5000 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    4fe8:	4313      	orrs	r3, r2
    4fea:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    4fec:	f000 ff0c 	bl	5e08 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    4ff0:	2300      	movs	r3, #0
    4ff2:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    4ff4:	9b07      	ldr	r3, [sp, #28]
}
    4ff6:	4618      	mov	r0, r3
    4ff8:	b009      	add	sp, #36	; 0x24
    4ffa:	f85d fb04 	ldr.w	pc, [sp], #4
    4ffe:	bf00      	nop
    5000:	40048000 	.word	0x40048000

00005004 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    5004:	b500      	push	{lr}
    5006:	b087      	sub	sp, #28
    5008:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    500a:	2300      	movs	r3, #0
    500c:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    500e:	2300      	movs	r3, #0
    5010:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    5012:	2300      	movs	r3, #0
    5014:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    5016:	9b01      	ldr	r3, [sp, #4]
    5018:	68db      	ldr	r3, [r3, #12]
    501a:	2b02      	cmp	r3, #2
    501c:	d00a      	beq.n	5034 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    501e:	9b05      	ldr	r3, [sp, #20]
    5020:	f043 0302 	orr.w	r3, r3, #2
    5024:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    5026:	9b01      	ldr	r3, [sp, #4]
    5028:	68db      	ldr	r3, [r3, #12]
    502a:	f003 0301 	and.w	r3, r3, #1
    502e:	9a05      	ldr	r2, [sp, #20]
    5030:	4313      	orrs	r3, r2
    5032:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    5034:	9b01      	ldr	r3, [sp, #4]
    5036:	699b      	ldr	r3, [r3, #24]
    5038:	019b      	lsls	r3, r3, #6
    503a:	f003 0340 	and.w	r3, r3, #64	; 0x40
    503e:	9a05      	ldr	r2, [sp, #20]
    5040:	4313      	orrs	r3, r2
    5042:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    5044:	9b01      	ldr	r3, [sp, #4]
    5046:	6a1b      	ldr	r3, [r3, #32]
    5048:	03db      	lsls	r3, r3, #15
    504a:	b29b      	uxth	r3, r3
    504c:	9a05      	ldr	r2, [sp, #20]
    504e:	4313      	orrs	r3, r2
    5050:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    5052:	9b01      	ldr	r3, [sp, #4]
    5054:	7f1b      	ldrb	r3, [r3, #28]
    5056:	2b00      	cmp	r3, #0
    5058:	d001      	beq.n	505e <Port_Ci_Port_Ip_PinInit+0x5a>
    505a:	2310      	movs	r3, #16
    505c:	e000      	b.n	5060 <Port_Ci_Port_Ip_PinInit+0x5c>
    505e:	2300      	movs	r3, #0
    5060:	9a05      	ldr	r2, [sp, #20]
    5062:	4313      	orrs	r3, r2
    5064:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    5066:	9b01      	ldr	r3, [sp, #4]
    5068:	691b      	ldr	r3, [r3, #16]
    506a:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    506c:	9b01      	ldr	r3, [sp, #4]
    506e:	6818      	ldr	r0, [r3, #0]
    5070:	9b01      	ldr	r3, [sp, #4]
    5072:	689b      	ldr	r3, [r3, #8]
    5074:	9a04      	ldr	r2, [sp, #16]
    5076:	4619      	mov	r1, r3
    5078:	f7ff ff90 	bl	4f9c <Port_Ci_Port_Ip_ConfigureInterleave>
    507c:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    507e:	9b03      	ldr	r3, [sp, #12]
    5080:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    5082:	9b04      	ldr	r3, [sp, #16]
    5084:	021b      	lsls	r3, r3, #8
    5086:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    508a:	9a05      	ldr	r2, [sp, #20]
    508c:	4313      	orrs	r3, r2
    508e:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    5090:	f000 fcf4 	bl	5a7c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    5094:	9b01      	ldr	r3, [sp, #4]
    5096:	681b      	ldr	r3, [r3, #0]
    5098:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    509c:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    509e:	9b01      	ldr	r3, [sp, #4]
    50a0:	689b      	ldr	r3, [r3, #8]
    50a2:	2201      	movs	r2, #1
    50a4:	fa02 f303 	lsl.w	r3, r2, r3
    50a8:	43db      	mvns	r3, r3
    50aa:	9a02      	ldr	r2, [sp, #8]
    50ac:	4013      	ands	r3, r2
    50ae:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    50b0:	9b01      	ldr	r3, [sp, #4]
    50b2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    50b6:	2b00      	cmp	r3, #0
    50b8:	d001      	beq.n	50be <Port_Ci_Port_Ip_PinInit+0xba>
    50ba:	2201      	movs	r2, #1
    50bc:	e000      	b.n	50c0 <Port_Ci_Port_Ip_PinInit+0xbc>
    50be:	2200      	movs	r2, #0
    50c0:	9b01      	ldr	r3, [sp, #4]
    50c2:	689b      	ldr	r3, [r3, #8]
    50c4:	fa02 f303 	lsl.w	r3, r2, r3
    50c8:	9a02      	ldr	r2, [sp, #8]
    50ca:	4313      	orrs	r3, r2
    50cc:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    50ce:	9b01      	ldr	r3, [sp, #4]
    50d0:	681b      	ldr	r3, [r3, #0]
    50d2:	9a02      	ldr	r2, [sp, #8]
    50d4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    50d8:	f000 fcfc 	bl	5ad4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    50dc:	9b04      	ldr	r3, [sp, #16]
    50de:	2b01      	cmp	r3, #1
    50e0:	d16d      	bne.n	51be <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    50e2:	9b01      	ldr	r3, [sp, #4]
    50e4:	695b      	ldr	r3, [r3, #20]
    50e6:	2b02      	cmp	r3, #2
    50e8:	d138      	bne.n	515c <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    50ea:	9b01      	ldr	r3, [sp, #4]
    50ec:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    50f0:	2b01      	cmp	r3, #1
    50f2:	d10f      	bne.n	5114 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    50f4:	f000 fd14 	bl	5b20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    50f8:	9b01      	ldr	r3, [sp, #4]
    50fa:	685b      	ldr	r3, [r3, #4]
    50fc:	6859      	ldr	r1, [r3, #4]
    50fe:	9b01      	ldr	r3, [sp, #4]
    5100:	689b      	ldr	r3, [r3, #8]
    5102:	2201      	movs	r2, #1
    5104:	409a      	lsls	r2, r3
    5106:	9b01      	ldr	r3, [sp, #4]
    5108:	685b      	ldr	r3, [r3, #4]
    510a:	430a      	orrs	r2, r1
    510c:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    510e:	f000 fd33 	bl	5b78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    5112:	e013      	b.n	513c <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    5114:	9b01      	ldr	r3, [sp, #4]
    5116:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    511a:	2b00      	cmp	r3, #0
    511c:	d10e      	bne.n	513c <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    511e:	f000 fd51 	bl	5bc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    5122:	9b01      	ldr	r3, [sp, #4]
    5124:	685b      	ldr	r3, [r3, #4]
    5126:	6899      	ldr	r1, [r3, #8]
    5128:	9b01      	ldr	r3, [sp, #4]
    512a:	689b      	ldr	r3, [r3, #8]
    512c:	2201      	movs	r2, #1
    512e:	409a      	lsls	r2, r3
    5130:	9b01      	ldr	r3, [sp, #4]
    5132:	685b      	ldr	r3, [r3, #4]
    5134:	430a      	orrs	r2, r1
    5136:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    5138:	f000 fd70 	bl	5c1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    513c:	f000 fd94 	bl	5c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    5140:	9b01      	ldr	r3, [sp, #4]
    5142:	685b      	ldr	r3, [r3, #4]
    5144:	6959      	ldr	r1, [r3, #20]
    5146:	9b01      	ldr	r3, [sp, #4]
    5148:	689b      	ldr	r3, [r3, #8]
    514a:	2201      	movs	r2, #1
    514c:	409a      	lsls	r2, r3
    514e:	9b01      	ldr	r3, [sp, #4]
    5150:	685b      	ldr	r3, [r3, #4]
    5152:	430a      	orrs	r2, r1
    5154:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    5156:	f000 fdb3 	bl	5cc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    515a:	e030      	b.n	51be <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    515c:	f000 fd84 	bl	5c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    5160:	9b01      	ldr	r3, [sp, #4]
    5162:	685b      	ldr	r3, [r3, #4]
    5164:	6959      	ldr	r1, [r3, #20]
    5166:	9b01      	ldr	r3, [sp, #4]
    5168:	689b      	ldr	r3, [r3, #8]
    516a:	2201      	movs	r2, #1
    516c:	fa02 f303 	lsl.w	r3, r2, r3
    5170:	43da      	mvns	r2, r3
    5172:	9b01      	ldr	r3, [sp, #4]
    5174:	685b      	ldr	r3, [r3, #4]
    5176:	400a      	ands	r2, r1
    5178:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    517a:	f000 fda1 	bl	5cc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    517e:	f000 fdc5 	bl	5d0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    5182:	9b01      	ldr	r3, [sp, #4]
    5184:	685b      	ldr	r3, [r3, #4]
    5186:	6999      	ldr	r1, [r3, #24]
    5188:	9b01      	ldr	r3, [sp, #4]
    518a:	689b      	ldr	r3, [r3, #8]
    518c:	2201      	movs	r2, #1
    518e:	fa02 f303 	lsl.w	r3, r2, r3
    5192:	43da      	mvns	r2, r3
    5194:	9b01      	ldr	r3, [sp, #4]
    5196:	685b      	ldr	r3, [r3, #4]
    5198:	400a      	ands	r2, r1
    519a:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    519c:	9b01      	ldr	r3, [sp, #4]
    519e:	695b      	ldr	r3, [r3, #20]
    51a0:	2b03      	cmp	r3, #3
    51a2:	d10a      	bne.n	51ba <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    51a4:	9b01      	ldr	r3, [sp, #4]
    51a6:	685b      	ldr	r3, [r3, #4]
    51a8:	6999      	ldr	r1, [r3, #24]
    51aa:	9b01      	ldr	r3, [sp, #4]
    51ac:	689b      	ldr	r3, [r3, #8]
    51ae:	2201      	movs	r2, #1
    51b0:	409a      	lsls	r2, r3
    51b2:	9b01      	ldr	r3, [sp, #4]
    51b4:	685b      	ldr	r3, [r3, #4]
    51b6:	430a      	orrs	r2, r1
    51b8:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    51ba:	f000 fdd3 	bl	5d64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    51be:	9b01      	ldr	r3, [sp, #4]
    51c0:	681b      	ldr	r3, [r3, #0]
    51c2:	9a01      	ldr	r2, [sp, #4]
    51c4:	6892      	ldr	r2, [r2, #8]
    51c6:	9905      	ldr	r1, [sp, #20]
    51c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    51cc:	bf00      	nop
    51ce:	b007      	add	sp, #28
    51d0:	f85d fb04 	ldr.w	pc, [sp], #4

000051d4 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    51d4:	b500      	push	{lr}
    51d6:	b085      	sub	sp, #20
    51d8:	9001      	str	r0, [sp, #4]
    51da:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    51dc:	2300      	movs	r3, #0
    51de:	9303      	str	r3, [sp, #12]
    51e0:	e00d      	b.n	51fe <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    51e2:	9a03      	ldr	r2, [sp, #12]
    51e4:	4613      	mov	r3, r2
    51e6:	009b      	lsls	r3, r3, #2
    51e8:	4413      	add	r3, r2
    51ea:	00db      	lsls	r3, r3, #3
    51ec:	461a      	mov	r2, r3
    51ee:	9b00      	ldr	r3, [sp, #0]
    51f0:	4413      	add	r3, r2
    51f2:	4618      	mov	r0, r3
    51f4:	f7ff ff06 	bl	5004 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    51f8:	9b03      	ldr	r3, [sp, #12]
    51fa:	3301      	adds	r3, #1
    51fc:	9303      	str	r3, [sp, #12]
    51fe:	9a03      	ldr	r2, [sp, #12]
    5200:	9b01      	ldr	r3, [sp, #4]
    5202:	429a      	cmp	r2, r3
    5204:	d3ed      	bcc.n	51e2 <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    5206:	2300      	movs	r3, #0
}
    5208:	4618      	mov	r0, r3
    520a:	b005      	add	sp, #20
    520c:	f85d fb04 	ldr.w	pc, [sp], #4

00005210 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    5210:	b500      	push	{lr}
    5212:	b087      	sub	sp, #28
    5214:	9003      	str	r0, [sp, #12]
    5216:	9102      	str	r1, [sp, #8]
    5218:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    521a:	9a01      	ldr	r2, [sp, #4]
    521c:	9902      	ldr	r1, [sp, #8]
    521e:	9803      	ldr	r0, [sp, #12]
    5220:	f7ff febc 	bl	4f9c <Port_Ci_Port_Ip_ConfigureInterleave>
    5224:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    5226:	f000 fe15 	bl	5e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    522a:	9b03      	ldr	r3, [sp, #12]
    522c:	9a02      	ldr	r2, [sp, #8]
    522e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5232:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    5234:	9b04      	ldr	r3, [sp, #16]
    5236:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    523a:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    523c:	9b05      	ldr	r3, [sp, #20]
    523e:	021b      	lsls	r3, r3, #8
    5240:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5244:	9a04      	ldr	r2, [sp, #16]
    5246:	4313      	orrs	r3, r2
    5248:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    524a:	9b03      	ldr	r3, [sp, #12]
    524c:	9a02      	ldr	r2, [sp, #8]
    524e:	9904      	ldr	r1, [sp, #16]
    5250:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    5254:	f000 fe2a 	bl	5eac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    5258:	bf00      	nop
    525a:	b007      	add	sp, #28
    525c:	f85d fb04 	ldr.w	pc, [sp], #4

00005260 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    5260:	b500      	push	{lr}
    5262:	b083      	sub	sp, #12
    5264:	9001      	str	r0, [sp, #4]
    5266:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    5268:	f000 fe46 	bl	5ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    526c:	9b01      	ldr	r3, [sp, #4]
    526e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    5272:	2101      	movs	r1, #1
    5274:	9b00      	ldr	r3, [sp, #0]
    5276:	fa01 f303 	lsl.w	r3, r1, r3
    527a:	431a      	orrs	r2, r3
    527c:	9b01      	ldr	r3, [sp, #4]
    527e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    5282:	f000 fe65 	bl	5f50 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    5286:	bf00      	nop
    5288:	b003      	add	sp, #12
    528a:	f85d fb04 	ldr.w	pc, [sp], #4

0000528e <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    528e:	b500      	push	{lr}
    5290:	b083      	sub	sp, #12
    5292:	9001      	str	r0, [sp, #4]
    5294:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    5296:	f000 fe81 	bl	5f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    529a:	9b01      	ldr	r3, [sp, #4]
    529c:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    52a0:	2101      	movs	r1, #1
    52a2:	9b00      	ldr	r3, [sp, #0]
    52a4:	fa01 f303 	lsl.w	r3, r1, r3
    52a8:	43db      	mvns	r3, r3
    52aa:	401a      	ands	r2, r3
    52ac:	9b01      	ldr	r3, [sp, #4]
    52ae:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    52b2:	f000 fe9f 	bl	5ff4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    52b6:	bf00      	nop
    52b8:	b003      	add	sp, #12
    52ba:	f85d fb04 	ldr.w	pc, [sp], #4

000052be <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    52be:	b082      	sub	sp, #8
    52c0:	9001      	str	r0, [sp, #4]
    52c2:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    52c4:	9b00      	ldr	r3, [sp, #0]
    52c6:	785b      	ldrb	r3, [r3, #1]
    52c8:	f003 0201 	and.w	r2, r3, #1
    52cc:	9b01      	ldr	r3, [sp, #4]
    52ce:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    52d2:	9b00      	ldr	r3, [sp, #0]
    52d4:	789b      	ldrb	r3, [r3, #2]
    52d6:	f003 021f 	and.w	r2, r3, #31
    52da:	9b01      	ldr	r3, [sp, #4]
    52dc:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    52e0:	bf00      	nop
    52e2:	b002      	add	sp, #8
    52e4:	4770      	bx	lr

000052e6 <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    52e6:	b086      	sub	sp, #24
    52e8:	9003      	str	r0, [sp, #12]
    52ea:	9301      	str	r3, [sp, #4]
    52ec:	460b      	mov	r3, r1
    52ee:	f8ad 300a 	strh.w	r3, [sp, #10]
    52f2:	4613      	mov	r3, r2
    52f4:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    52f8:	2300      	movs	r3, #0
    52fa:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    52fe:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5302:	f043 0301 	orr.w	r3, r3, #1
    5306:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    530a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    530e:	f043 0302 	orr.w	r3, r3, #2
    5312:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    5316:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    531a:	f043 0310 	orr.w	r3, r3, #16
    531e:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    5322:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5326:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    532a:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    532e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5332:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    5336:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    533a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    533e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    5342:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    5346:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    534a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    534e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    5352:	4013      	ands	r3, r2
    5354:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    5358:	9b01      	ldr	r3, [sp, #4]
    535a:	2b00      	cmp	r3, #0
    535c:	d003      	beq.n	5366 <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    535e:	9b01      	ldr	r3, [sp, #4]
    5360:	2b01      	cmp	r3, #1
    5362:	d00a      	beq.n	537a <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    5364:	e013      	b.n	538e <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    5366:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    536a:	041a      	lsls	r2, r3, #16
    536c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5370:	431a      	orrs	r2, r3
    5372:	9b03      	ldr	r3, [sp, #12]
    5374:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    5378:	e009      	b.n	538e <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    537a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    537e:	041a      	lsls	r2, r3, #16
    5380:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5384:	431a      	orrs	r2, r3
    5386:	9b03      	ldr	r3, [sp, #12]
    5388:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    538c:	bf00      	nop
    }
}
    538e:	bf00      	nop
    5390:	b006      	add	sp, #24
    5392:	4770      	bx	lr

00005394 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    5394:	b500      	push	{lr}
    5396:	b087      	sub	sp, #28
    5398:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    539a:	9b01      	ldr	r3, [sp, #4]
    539c:	885b      	ldrh	r3, [r3, #2]
    539e:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    53a2:	9b01      	ldr	r3, [sp, #4]
    53a4:	689b      	ldr	r3, [r3, #8]
    53a6:	7a1b      	ldrb	r3, [r3, #8]
    53a8:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    53ac:	9b01      	ldr	r3, [sp, #4]
    53ae:	689b      	ldr	r3, [r3, #8]
    53b0:	681b      	ldr	r3, [r3, #0]
    53b2:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    53b4:	9b01      	ldr	r3, [sp, #4]
    53b6:	689b      	ldr	r3, [r3, #8]
    53b8:	685b      	ldr	r3, [r3, #4]
    53ba:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    53bc:	2300      	movs	r3, #0
    53be:	f8ad 3016 	strh.w	r3, [sp, #22]
    53c2:	e111      	b.n	55e8 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    53c4:	9b02      	ldr	r3, [sp, #8]
    53c6:	2b02      	cmp	r3, #2
    53c8:	d169      	bne.n	549e <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    53ca:	f89d 3013 	ldrb.w	r3, [sp, #19]
    53ce:	2b01      	cmp	r3, #1
    53d0:	d11a      	bne.n	5408 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    53d2:	9b01      	ldr	r3, [sp, #4]
    53d4:	685a      	ldr	r2, [r3, #4]
    53d6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53da:	005b      	lsls	r3, r3, #1
    53dc:	4413      	add	r3, r2
    53de:	881b      	ldrh	r3, [r3, #0]
    53e0:	f003 021f 	and.w	r2, r3, #31
    53e4:	9b01      	ldr	r3, [sp, #4]
    53e6:	6859      	ldr	r1, [r3, #4]
    53e8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53ec:	005b      	lsls	r3, r3, #1
    53ee:	440b      	add	r3, r1
    53f0:	881b      	ldrh	r3, [r3, #0]
    53f2:	095b      	lsrs	r3, r3, #5
    53f4:	b29b      	uxth	r3, r3
    53f6:	4619      	mov	r1, r3
    53f8:	4b81      	ldr	r3, [pc, #516]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    53fa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    53fe:	2101      	movs	r1, #1
    5400:	fa01 f202 	lsl.w	r2, r1, r2
    5404:	605a      	str	r2, [r3, #4]
    5406:	e01d      	b.n	5444 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    5408:	f89d 3013 	ldrb.w	r3, [sp, #19]
    540c:	2b00      	cmp	r3, #0
    540e:	d119      	bne.n	5444 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5410:	9b01      	ldr	r3, [sp, #4]
    5412:	685a      	ldr	r2, [r3, #4]
    5414:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5418:	005b      	lsls	r3, r3, #1
    541a:	4413      	add	r3, r2
    541c:	881b      	ldrh	r3, [r3, #0]
    541e:	f003 021f 	and.w	r2, r3, #31
    5422:	9b01      	ldr	r3, [sp, #4]
    5424:	6859      	ldr	r1, [r3, #4]
    5426:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    542a:	005b      	lsls	r3, r3, #1
    542c:	440b      	add	r3, r1
    542e:	881b      	ldrh	r3, [r3, #0]
    5430:	095b      	lsrs	r3, r3, #5
    5432:	b29b      	uxth	r3, r3
    5434:	4619      	mov	r1, r3
    5436:	4b72      	ldr	r3, [pc, #456]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    5438:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    543c:	2101      	movs	r1, #1
    543e:	fa01 f202 	lsl.w	r2, r1, r2
    5442:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    5444:	f000 fdfc 	bl	6040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5448:	9b01      	ldr	r3, [sp, #4]
    544a:	685a      	ldr	r2, [r3, #4]
    544c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5450:	005b      	lsls	r3, r3, #1
    5452:	4413      	add	r3, r2
    5454:	881b      	ldrh	r3, [r3, #0]
    5456:	095b      	lsrs	r3, r3, #5
    5458:	b29b      	uxth	r3, r3
    545a:	461a      	mov	r2, r3
    545c:	4b68      	ldr	r3, [pc, #416]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    545e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5462:	6959      	ldr	r1, [r3, #20]
    5464:	9b01      	ldr	r3, [sp, #4]
    5466:	685a      	ldr	r2, [r3, #4]
    5468:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    546c:	005b      	lsls	r3, r3, #1
    546e:	4413      	add	r3, r2
    5470:	881b      	ldrh	r3, [r3, #0]
    5472:	f003 031f 	and.w	r3, r3, #31
    5476:	2201      	movs	r2, #1
    5478:	409a      	lsls	r2, r3
    547a:	9b01      	ldr	r3, [sp, #4]
    547c:	6858      	ldr	r0, [r3, #4]
    547e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5482:	005b      	lsls	r3, r3, #1
    5484:	4403      	add	r3, r0
    5486:	881b      	ldrh	r3, [r3, #0]
    5488:	095b      	lsrs	r3, r3, #5
    548a:	b29b      	uxth	r3, r3
    548c:	4618      	mov	r0, r3
    548e:	4b5c      	ldr	r3, [pc, #368]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    5490:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5494:	430a      	orrs	r2, r1
    5496:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    5498:	f000 fdfe 	bl	6098 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    549c:	e086      	b.n	55ac <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    549e:	f000 fdcf 	bl	6040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    54a2:	9b01      	ldr	r3, [sp, #4]
    54a4:	685a      	ldr	r2, [r3, #4]
    54a6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54aa:	005b      	lsls	r3, r3, #1
    54ac:	4413      	add	r3, r2
    54ae:	881b      	ldrh	r3, [r3, #0]
    54b0:	095b      	lsrs	r3, r3, #5
    54b2:	b29b      	uxth	r3, r3
    54b4:	461a      	mov	r2, r3
    54b6:	4b52      	ldr	r3, [pc, #328]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    54b8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    54bc:	6959      	ldr	r1, [r3, #20]
    54be:	9b01      	ldr	r3, [sp, #4]
    54c0:	685a      	ldr	r2, [r3, #4]
    54c2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54c6:	005b      	lsls	r3, r3, #1
    54c8:	4413      	add	r3, r2
    54ca:	881b      	ldrh	r3, [r3, #0]
    54cc:	f003 031f 	and.w	r3, r3, #31
    54d0:	2201      	movs	r2, #1
    54d2:	fa02 f303 	lsl.w	r3, r2, r3
    54d6:	43da      	mvns	r2, r3
    54d8:	9b01      	ldr	r3, [sp, #4]
    54da:	6858      	ldr	r0, [r3, #4]
    54dc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54e0:	005b      	lsls	r3, r3, #1
    54e2:	4403      	add	r3, r0
    54e4:	881b      	ldrh	r3, [r3, #0]
    54e6:	095b      	lsrs	r3, r3, #5
    54e8:	b29b      	uxth	r3, r3
    54ea:	4618      	mov	r0, r3
    54ec:	4b44      	ldr	r3, [pc, #272]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    54ee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    54f2:	400a      	ands	r2, r1
    54f4:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    54f6:	f000 fdcf 	bl	6098 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    54fa:	f000 fdf3 	bl	60e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    54fe:	9b01      	ldr	r3, [sp, #4]
    5500:	685a      	ldr	r2, [r3, #4]
    5502:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5506:	005b      	lsls	r3, r3, #1
    5508:	4413      	add	r3, r2
    550a:	881b      	ldrh	r3, [r3, #0]
    550c:	095b      	lsrs	r3, r3, #5
    550e:	b29b      	uxth	r3, r3
    5510:	461a      	mov	r2, r3
    5512:	4b3b      	ldr	r3, [pc, #236]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    5514:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5518:	6999      	ldr	r1, [r3, #24]
    551a:	9b01      	ldr	r3, [sp, #4]
    551c:	685a      	ldr	r2, [r3, #4]
    551e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5522:	005b      	lsls	r3, r3, #1
    5524:	4413      	add	r3, r2
    5526:	881b      	ldrh	r3, [r3, #0]
    5528:	f003 031f 	and.w	r3, r3, #31
    552c:	2201      	movs	r2, #1
    552e:	fa02 f303 	lsl.w	r3, r2, r3
    5532:	43da      	mvns	r2, r3
    5534:	9b01      	ldr	r3, [sp, #4]
    5536:	6858      	ldr	r0, [r3, #4]
    5538:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    553c:	005b      	lsls	r3, r3, #1
    553e:	4403      	add	r3, r0
    5540:	881b      	ldrh	r3, [r3, #0]
    5542:	095b      	lsrs	r3, r3, #5
    5544:	b29b      	uxth	r3, r3
    5546:	4618      	mov	r0, r3
    5548:	4b2d      	ldr	r3, [pc, #180]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    554a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    554e:	400a      	ands	r2, r1
    5550:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    5552:	9b02      	ldr	r3, [sp, #8]
    5554:	2b03      	cmp	r3, #3
    5556:	d127      	bne.n	55a8 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5558:	9b01      	ldr	r3, [sp, #4]
    555a:	685a      	ldr	r2, [r3, #4]
    555c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5560:	005b      	lsls	r3, r3, #1
    5562:	4413      	add	r3, r2
    5564:	881b      	ldrh	r3, [r3, #0]
    5566:	095b      	lsrs	r3, r3, #5
    5568:	b29b      	uxth	r3, r3
    556a:	461a      	mov	r2, r3
    556c:	4b24      	ldr	r3, [pc, #144]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    556e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5572:	6999      	ldr	r1, [r3, #24]
    5574:	9b01      	ldr	r3, [sp, #4]
    5576:	685a      	ldr	r2, [r3, #4]
    5578:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    557c:	005b      	lsls	r3, r3, #1
    557e:	4413      	add	r3, r2
    5580:	881b      	ldrh	r3, [r3, #0]
    5582:	f003 031f 	and.w	r3, r3, #31
    5586:	2201      	movs	r2, #1
    5588:	409a      	lsls	r2, r3
    558a:	9b01      	ldr	r3, [sp, #4]
    558c:	6858      	ldr	r0, [r3, #4]
    558e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5592:	005b      	lsls	r3, r3, #1
    5594:	4403      	add	r3, r0
    5596:	881b      	ldrh	r3, [r3, #0]
    5598:	095b      	lsrs	r3, r3, #5
    559a:	b29b      	uxth	r3, r3
    559c:	4618      	mov	r0, r3
    559e:	4b18      	ldr	r3, [pc, #96]	; (5600 <Port_Ipw_Init_UnusedPins+0x26c>)
    55a0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    55a4:	430a      	orrs	r2, r1
    55a6:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    55a8:	f000 fdc8 	bl	613c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    55ac:	9b01      	ldr	r3, [sp, #4]
    55ae:	685a      	ldr	r2, [r3, #4]
    55b0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55b4:	005b      	lsls	r3, r3, #1
    55b6:	4413      	add	r3, r2
    55b8:	881b      	ldrh	r3, [r3, #0]
    55ba:	095b      	lsrs	r3, r3, #5
    55bc:	b29b      	uxth	r3, r3
    55be:	461a      	mov	r2, r3
    55c0:	4b10      	ldr	r3, [pc, #64]	; (5604 <Port_Ipw_Init_UnusedPins+0x270>)
    55c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    55c6:	9a01      	ldr	r2, [sp, #4]
    55c8:	6851      	ldr	r1, [r2, #4]
    55ca:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    55ce:	0052      	lsls	r2, r2, #1
    55d0:	440a      	add	r2, r1
    55d2:	8812      	ldrh	r2, [r2, #0]
    55d4:	f002 021f 	and.w	r2, r2, #31
    55d8:	9903      	ldr	r1, [sp, #12]
    55da:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    55de:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55e2:	3301      	adds	r3, #1
    55e4:	f8ad 3016 	strh.w	r3, [sp, #22]
    55e8:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    55ec:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    55f0:	429a      	cmp	r2, r3
    55f2:	f4ff aee7 	bcc.w	53c4 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    55f6:	bf00      	nop
    55f8:	bf00      	nop
    55fa:	b007      	add	sp, #28
    55fc:	f85d fb04 	ldr.w	pc, [sp], #4
    5600:	00007408 	.word	0x00007408
    5604:	000073f4 	.word	0x000073f4

00005608 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    5608:	b500      	push	{lr}
    560a:	b085      	sub	sp, #20
    560c:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    560e:	9b01      	ldr	r3, [sp, #4]
    5610:	7c1b      	ldrb	r3, [r3, #16]
    5612:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5616:	2300      	movs	r3, #0
    5618:	f8ad 300e 	strh.w	r3, [sp, #14]
    561c:	e035      	b.n	568a <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    561e:	9b01      	ldr	r3, [sp, #4]
    5620:	695a      	ldr	r2, [r3, #20]
    5622:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5626:	00db      	lsls	r3, r3, #3
    5628:	4413      	add	r3, r2
    562a:	781b      	ldrb	r3, [r3, #0]
    562c:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    5630:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5634:	4a1f      	ldr	r2, [pc, #124]	; (56b4 <Port_Ipw_Init+0xac>)
    5636:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    563a:	9b01      	ldr	r3, [sp, #4]
    563c:	695a      	ldr	r2, [r3, #20]
    563e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5642:	00db      	lsls	r3, r3, #3
    5644:	4413      	add	r3, r2
    5646:	4619      	mov	r1, r3
    5648:	f7ff fe39 	bl	52be <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    564c:	f000 fee4 	bl	6418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    5650:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5654:	4a17      	ldr	r2, [pc, #92]	; (56b4 <Port_Ipw_Init+0xac>)
    5656:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    565a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    565e:	9b01      	ldr	r3, [sp, #4]
    5660:	695a      	ldr	r2, [r3, #20]
    5662:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5666:	00db      	lsls	r3, r3, #3
    5668:	4413      	add	r3, r2
    566a:	685a      	ldr	r2, [r3, #4]
    566c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5670:	4810      	ldr	r0, [pc, #64]	; (56b4 <Port_Ipw_Init+0xac>)
    5672:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5676:	430a      	orrs	r2, r1
    5678:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    567c:	f000 fef8 	bl	6470 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5680:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5684:	3301      	adds	r3, #1
    5686:	f8ad 300e 	strh.w	r3, [sp, #14]
    568a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    568e:	b29b      	uxth	r3, r3
    5690:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5694:	429a      	cmp	r2, r3
    5696:	d3c2      	bcc.n	561e <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    5698:	9b01      	ldr	r3, [sp, #4]
    569a:	6a1b      	ldr	r3, [r3, #32]
    569c:	4619      	mov	r1, r3
    569e:	2001      	movs	r0, #1
    56a0:	f7ff fd98 	bl	51d4 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    56a4:	9801      	ldr	r0, [sp, #4]
    56a6:	f7ff fe75 	bl	5394 <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    56aa:	bf00      	nop
    56ac:	b005      	add	sp, #20
    56ae:	f85d fb04 	ldr.w	pc, [sp], #4
    56b2:	bf00      	nop
    56b4:	000073f4 	.word	0x000073f4

000056b8 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    56b8:	b500      	push	{lr}
    56ba:	b085      	sub	sp, #20
    56bc:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    56be:	9b01      	ldr	r3, [sp, #4]
    56c0:	881b      	ldrh	r3, [r3, #0]
    56c2:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    56c6:	2300      	movs	r3, #0
    56c8:	f8ad 300e 	strh.w	r3, [sp, #14]
    56cc:	e0d2      	b.n	5874 <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    56ce:	9b01      	ldr	r3, [sp, #4]
    56d0:	68d9      	ldr	r1, [r3, #12]
    56d2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    56d6:	4613      	mov	r3, r2
    56d8:	009b      	lsls	r3, r3, #2
    56da:	4413      	add	r3, r2
    56dc:	009b      	lsls	r3, r3, #2
    56de:	440b      	add	r3, r1
    56e0:	7c5b      	ldrb	r3, [r3, #17]
    56e2:	f083 0301 	eor.w	r3, r3, #1
    56e6:	b2db      	uxtb	r3, r3
    56e8:	2b00      	cmp	r3, #0
    56ea:	f000 80be 	beq.w	586a <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    56ee:	9b01      	ldr	r3, [sp, #4]
    56f0:	68d9      	ldr	r1, [r3, #12]
    56f2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    56f6:	4613      	mov	r3, r2
    56f8:	009b      	lsls	r3, r3, #2
    56fa:	4413      	add	r3, r2
    56fc:	009b      	lsls	r3, r3, #2
    56fe:	440b      	add	r3, r1
    5700:	7c1b      	ldrb	r3, [r3, #16]
    5702:	2b00      	cmp	r3, #0
    5704:	f000 80b1 	beq.w	586a <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    5708:	9b01      	ldr	r3, [sp, #4]
    570a:	68d9      	ldr	r1, [r3, #12]
    570c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5710:	4613      	mov	r3, r2
    5712:	009b      	lsls	r3, r3, #2
    5714:	4413      	add	r3, r2
    5716:	009b      	lsls	r3, r3, #2
    5718:	440b      	add	r3, r1
    571a:	881b      	ldrh	r3, [r3, #0]
    571c:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    5720:	9b01      	ldr	r3, [sp, #4]
    5722:	68d9      	ldr	r1, [r3, #12]
    5724:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5728:	4613      	mov	r3, r2
    572a:	009b      	lsls	r3, r3, #2
    572c:	4413      	add	r3, r2
    572e:	009b      	lsls	r3, r3, #2
    5730:	440b      	add	r3, r1
    5732:	68db      	ldr	r3, [r3, #12]
    5734:	2b02      	cmp	r3, #2
    5736:	d11d      	bne.n	5774 <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    5738:	f000 ffb6 	bl	66a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    573c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5740:	095b      	lsrs	r3, r3, #5
    5742:	b29b      	uxth	r3, r3
    5744:	461a      	mov	r2, r3
    5746:	4b51      	ldr	r3, [pc, #324]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5748:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    574c:	6959      	ldr	r1, [r3, #20]
    574e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5752:	f003 031f 	and.w	r3, r3, #31
    5756:	2201      	movs	r2, #1
    5758:	409a      	lsls	r2, r3
    575a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    575e:	095b      	lsrs	r3, r3, #5
    5760:	b29b      	uxth	r3, r3
    5762:	4618      	mov	r0, r3
    5764:	4b49      	ldr	r3, [pc, #292]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5766:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    576a:	430a      	orrs	r2, r1
    576c:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    576e:	f000 ffc7 	bl	6700 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    5772:	e07a      	b.n	586a <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    5774:	9b01      	ldr	r3, [sp, #4]
    5776:	68d9      	ldr	r1, [r3, #12]
    5778:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    577c:	4613      	mov	r3, r2
    577e:	009b      	lsls	r3, r3, #2
    5780:	4413      	add	r3, r2
    5782:	009b      	lsls	r3, r3, #2
    5784:	440b      	add	r3, r1
    5786:	68db      	ldr	r3, [r3, #12]
    5788:	2b01      	cmp	r3, #1
    578a:	d00b      	beq.n	57a4 <Port_Ipw_RefreshPortDirection+0xec>
    578c:	9b01      	ldr	r3, [sp, #4]
    578e:	68d9      	ldr	r1, [r3, #12]
    5790:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5794:	4613      	mov	r3, r2
    5796:	009b      	lsls	r3, r3, #2
    5798:	4413      	add	r3, r2
    579a:	009b      	lsls	r3, r3, #2
    579c:	440b      	add	r3, r1
    579e:	68db      	ldr	r3, [r3, #12]
    57a0:	2b03      	cmp	r3, #3
    57a2:	d162      	bne.n	586a <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    57a4:	f000 ff80 	bl	66a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    57a8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57ac:	095b      	lsrs	r3, r3, #5
    57ae:	b29b      	uxth	r3, r3
    57b0:	461a      	mov	r2, r3
    57b2:	4b36      	ldr	r3, [pc, #216]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    57b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    57b8:	6959      	ldr	r1, [r3, #20]
    57ba:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57be:	f003 031f 	and.w	r3, r3, #31
    57c2:	2201      	movs	r2, #1
    57c4:	fa02 f303 	lsl.w	r3, r2, r3
    57c8:	43da      	mvns	r2, r3
    57ca:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57ce:	095b      	lsrs	r3, r3, #5
    57d0:	b29b      	uxth	r3, r3
    57d2:	4618      	mov	r0, r3
    57d4:	4b2d      	ldr	r3, [pc, #180]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    57d6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    57da:	400a      	ands	r2, r1
    57dc:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    57de:	f000 ff8f 	bl	6700 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    57e2:	f000 ffb3 	bl	674c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    57e6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57ea:	095b      	lsrs	r3, r3, #5
    57ec:	b29b      	uxth	r3, r3
    57ee:	461a      	mov	r2, r3
    57f0:	4b26      	ldr	r3, [pc, #152]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    57f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    57f6:	6999      	ldr	r1, [r3, #24]
    57f8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57fc:	f003 031f 	and.w	r3, r3, #31
    5800:	2201      	movs	r2, #1
    5802:	fa02 f303 	lsl.w	r3, r2, r3
    5806:	43da      	mvns	r2, r3
    5808:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    580c:	095b      	lsrs	r3, r3, #5
    580e:	b29b      	uxth	r3, r3
    5810:	4618      	mov	r0, r3
    5812:	4b1e      	ldr	r3, [pc, #120]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5814:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5818:	400a      	ands	r2, r1
    581a:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    581c:	9b01      	ldr	r3, [sp, #4]
    581e:	68d9      	ldr	r1, [r3, #12]
    5820:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5824:	4613      	mov	r3, r2
    5826:	009b      	lsls	r3, r3, #2
    5828:	4413      	add	r3, r2
    582a:	009b      	lsls	r3, r3, #2
    582c:	440b      	add	r3, r1
    582e:	68db      	ldr	r3, [r3, #12]
    5830:	2b03      	cmp	r3, #3
    5832:	d118      	bne.n	5866 <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5834:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5838:	095b      	lsrs	r3, r3, #5
    583a:	b29b      	uxth	r3, r3
    583c:	461a      	mov	r2, r3
    583e:	4b13      	ldr	r3, [pc, #76]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5840:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5844:	6999      	ldr	r1, [r3, #24]
    5846:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    584a:	f003 031f 	and.w	r3, r3, #31
    584e:	2201      	movs	r2, #1
    5850:	409a      	lsls	r2, r3
    5852:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5856:	095b      	lsrs	r3, r3, #5
    5858:	b29b      	uxth	r3, r3
    585a:	4618      	mov	r0, r3
    585c:	4b0b      	ldr	r3, [pc, #44]	; (588c <Port_Ipw_RefreshPortDirection+0x1d4>)
    585e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5862:	430a      	orrs	r2, r1
    5864:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    5866:	f000 ff9d 	bl	67a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    586a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    586e:	3301      	adds	r3, #1
    5870:	f8ad 300e 	strh.w	r3, [sp, #14]
    5874:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5878:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    587c:	429a      	cmp	r2, r3
    587e:	f4ff af26 	bcc.w	56ce <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    5882:	bf00      	nop
    5884:	bf00      	nop
    5886:	b005      	add	sp, #20
    5888:	f85d fb04 	ldr.w	pc, [sp], #4
    588c:	00007408 	.word	0x00007408

00005890 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    5890:	b500      	push	{lr}
    5892:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5894:	f7fb f904 	bl	aa0 <Sys_GetCoreID>
    5898:	4603      	mov	r3, r0
    589a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    589c:	4a10      	ldr	r2, [pc, #64]	; (58e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    589e:	9b01      	ldr	r3, [sp, #4]
    58a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    58a4:	2b00      	cmp	r3, #0
    58a6:	d10d      	bne.n	58c4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    58a8:	f7fb f822 	bl	8f0 <Mcu_schm_read_msr>
    58ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    58ae:	9b00      	ldr	r3, [sp, #0]
    58b0:	f003 0301 	and.w	r3, r3, #1
    58b4:	2b00      	cmp	r3, #0
    58b6:	d100      	bne.n	58ba <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    58b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    58ba:	490a      	ldr	r1, [pc, #40]	; (58e4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    58bc:	9b01      	ldr	r3, [sp, #4]
    58be:	9a00      	ldr	r2, [sp, #0]
    58c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    58c4:	4a06      	ldr	r2, [pc, #24]	; (58e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    58c6:	9b01      	ldr	r3, [sp, #4]
    58c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    58cc:	1c5a      	adds	r2, r3, #1
    58ce:	4904      	ldr	r1, [pc, #16]	; (58e0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    58d0:	9b01      	ldr	r3, [sp, #4]
    58d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    58d6:	bf00      	nop
    58d8:	b003      	add	sp, #12
    58da:	f85d fb04 	ldr.w	pc, [sp], #4
    58de:	bf00      	nop
    58e0:	1fff8cec 	.word	0x1fff8cec
    58e4:	1fff8ce8 	.word	0x1fff8ce8

000058e8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    58e8:	b500      	push	{lr}
    58ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    58ec:	f7fb f8d8 	bl	aa0 <Sys_GetCoreID>
    58f0:	4603      	mov	r3, r0
    58f2:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    58f4:	4a0d      	ldr	r2, [pc, #52]	; (592c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    58f6:	9b01      	ldr	r3, [sp, #4]
    58f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    58fc:	1e5a      	subs	r2, r3, #1
    58fe:	490b      	ldr	r1, [pc, #44]	; (592c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    5900:	9b01      	ldr	r3, [sp, #4]
    5902:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    5906:	4a0a      	ldr	r2, [pc, #40]	; (5930 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    5908:	9b01      	ldr	r3, [sp, #4]
    590a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    590e:	f003 0301 	and.w	r3, r3, #1
    5912:	2b00      	cmp	r3, #0
    5914:	d106      	bne.n	5924 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    5916:	4a05      	ldr	r2, [pc, #20]	; (592c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    5918:	9b01      	ldr	r3, [sp, #4]
    591a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    591e:	2b00      	cmp	r3, #0
    5920:	d100      	bne.n	5924 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5922:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5924:	bf00      	nop
    5926:	b003      	add	sp, #12
    5928:	f85d fb04 	ldr.w	pc, [sp], #4
    592c:	1fff8cec 	.word	0x1fff8cec
    5930:	1fff8ce8 	.word	0x1fff8ce8

00005934 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    5934:	b500      	push	{lr}
    5936:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5938:	f7fb f8b2 	bl	aa0 <Sys_GetCoreID>
    593c:	4603      	mov	r3, r0
    593e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    5940:	4a10      	ldr	r2, [pc, #64]	; (5984 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    5942:	9b01      	ldr	r3, [sp, #4]
    5944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5948:	2b00      	cmp	r3, #0
    594a:	d10d      	bne.n	5968 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    594c:	f7fa ffd0 	bl	8f0 <Mcu_schm_read_msr>
    5950:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5952:	9b00      	ldr	r3, [sp, #0]
    5954:	f003 0301 	and.w	r3, r3, #1
    5958:	2b00      	cmp	r3, #0
    595a:	d100      	bne.n	595e <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    595c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    595e:	490a      	ldr	r1, [pc, #40]	; (5988 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    5960:	9b01      	ldr	r3, [sp, #4]
    5962:	9a00      	ldr	r2, [sp, #0]
    5964:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    5968:	4a06      	ldr	r2, [pc, #24]	; (5984 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    596a:	9b01      	ldr	r3, [sp, #4]
    596c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5970:	1c5a      	adds	r2, r3, #1
    5972:	4904      	ldr	r1, [pc, #16]	; (5984 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    5974:	9b01      	ldr	r3, [sp, #4]
    5976:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    597a:	bf00      	nop
    597c:	b003      	add	sp, #12
    597e:	f85d fb04 	ldr.w	pc, [sp], #4
    5982:	bf00      	nop
    5984:	1fff8cf4 	.word	0x1fff8cf4
    5988:	1fff8cf0 	.word	0x1fff8cf0

0000598c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    598c:	b500      	push	{lr}
    598e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5990:	f7fb f886 	bl	aa0 <Sys_GetCoreID>
    5994:	4603      	mov	r3, r0
    5996:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    5998:	4a0d      	ldr	r2, [pc, #52]	; (59d0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    599a:	9b01      	ldr	r3, [sp, #4]
    599c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59a0:	1e5a      	subs	r2, r3, #1
    59a2:	490b      	ldr	r1, [pc, #44]	; (59d0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    59a4:	9b01      	ldr	r3, [sp, #4]
    59a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    59aa:	4a0a      	ldr	r2, [pc, #40]	; (59d4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    59ac:	9b01      	ldr	r3, [sp, #4]
    59ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59b2:	f003 0301 	and.w	r3, r3, #1
    59b6:	2b00      	cmp	r3, #0
    59b8:	d106      	bne.n	59c8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    59ba:	4a05      	ldr	r2, [pc, #20]	; (59d0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    59bc:	9b01      	ldr	r3, [sp, #4]
    59be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59c2:	2b00      	cmp	r3, #0
    59c4:	d100      	bne.n	59c8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    59c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    59c8:	bf00      	nop
    59ca:	b003      	add	sp, #12
    59cc:	f85d fb04 	ldr.w	pc, [sp], #4
    59d0:	1fff8cf4 	.word	0x1fff8cf4
    59d4:	1fff8cf0 	.word	0x1fff8cf0

000059d8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    59d8:	b500      	push	{lr}
    59da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    59dc:	f7fb f860 	bl	aa0 <Sys_GetCoreID>
    59e0:	4603      	mov	r3, r0
    59e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    59e4:	4a10      	ldr	r2, [pc, #64]	; (5a28 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    59e6:	9b01      	ldr	r3, [sp, #4]
    59e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59ec:	2b00      	cmp	r3, #0
    59ee:	d10d      	bne.n	5a0c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    59f0:	f7fa ff7e 	bl	8f0 <Mcu_schm_read_msr>
    59f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    59f6:	9b00      	ldr	r3, [sp, #0]
    59f8:	f003 0301 	and.w	r3, r3, #1
    59fc:	2b00      	cmp	r3, #0
    59fe:	d100      	bne.n	5a02 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5a00:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    5a02:	490a      	ldr	r1, [pc, #40]	; (5a2c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    5a04:	9b01      	ldr	r3, [sp, #4]
    5a06:	9a00      	ldr	r2, [sp, #0]
    5a08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    5a0c:	4a06      	ldr	r2, [pc, #24]	; (5a28 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    5a0e:	9b01      	ldr	r3, [sp, #4]
    5a10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a14:	1c5a      	adds	r2, r3, #1
    5a16:	4904      	ldr	r1, [pc, #16]	; (5a28 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    5a18:	9b01      	ldr	r3, [sp, #4]
    5a1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5a1e:	bf00      	nop
    5a20:	b003      	add	sp, #12
    5a22:	f85d fb04 	ldr.w	pc, [sp], #4
    5a26:	bf00      	nop
    5a28:	1fff8cfc 	.word	0x1fff8cfc
    5a2c:	1fff8cf8 	.word	0x1fff8cf8

00005a30 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    5a30:	b500      	push	{lr}
    5a32:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5a34:	f7fb f834 	bl	aa0 <Sys_GetCoreID>
    5a38:	4603      	mov	r3, r0
    5a3a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    5a3c:	4a0d      	ldr	r2, [pc, #52]	; (5a74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    5a3e:	9b01      	ldr	r3, [sp, #4]
    5a40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a44:	1e5a      	subs	r2, r3, #1
    5a46:	490b      	ldr	r1, [pc, #44]	; (5a74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    5a48:	9b01      	ldr	r3, [sp, #4]
    5a4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    5a4e:	4a0a      	ldr	r2, [pc, #40]	; (5a78 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    5a50:	9b01      	ldr	r3, [sp, #4]
    5a52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a56:	f003 0301 	and.w	r3, r3, #1
    5a5a:	2b00      	cmp	r3, #0
    5a5c:	d106      	bne.n	5a6c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    5a5e:	4a05      	ldr	r2, [pc, #20]	; (5a74 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    5a60:	9b01      	ldr	r3, [sp, #4]
    5a62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a66:	2b00      	cmp	r3, #0
    5a68:	d100      	bne.n	5a6c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5a6a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5a6c:	bf00      	nop
    5a6e:	b003      	add	sp, #12
    5a70:	f85d fb04 	ldr.w	pc, [sp], #4
    5a74:	1fff8cfc 	.word	0x1fff8cfc
    5a78:	1fff8cf8 	.word	0x1fff8cf8

00005a7c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    5a7c:	b500      	push	{lr}
    5a7e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5a80:	f7fb f80e 	bl	aa0 <Sys_GetCoreID>
    5a84:	4603      	mov	r3, r0
    5a86:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    5a88:	4a10      	ldr	r2, [pc, #64]	; (5acc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    5a8a:	9b01      	ldr	r3, [sp, #4]
    5a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a90:	2b00      	cmp	r3, #0
    5a92:	d10d      	bne.n	5ab0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5a94:	f7fa ff35 	bl	902 <Port_schm_read_msr>
    5a98:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5a9a:	9b00      	ldr	r3, [sp, #0]
    5a9c:	f003 0301 	and.w	r3, r3, #1
    5aa0:	2b00      	cmp	r3, #0
    5aa2:	d100      	bne.n	5aa6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5aa4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    5aa6:	490a      	ldr	r1, [pc, #40]	; (5ad0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    5aa8:	9b01      	ldr	r3, [sp, #4]
    5aaa:	9a00      	ldr	r2, [sp, #0]
    5aac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    5ab0:	4a06      	ldr	r2, [pc, #24]	; (5acc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    5ab2:	9b01      	ldr	r3, [sp, #4]
    5ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ab8:	1c5a      	adds	r2, r3, #1
    5aba:	4904      	ldr	r1, [pc, #16]	; (5acc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    5abc:	9b01      	ldr	r3, [sp, #4]
    5abe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5ac2:	bf00      	nop
    5ac4:	b003      	add	sp, #12
    5ac6:	f85d fb04 	ldr.w	pc, [sp], #4
    5aca:	bf00      	nop
    5acc:	1fff8d04 	.word	0x1fff8d04
    5ad0:	1fff8d00 	.word	0x1fff8d00

00005ad4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    5ad4:	b500      	push	{lr}
    5ad6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5ad8:	f7fa ffe2 	bl	aa0 <Sys_GetCoreID>
    5adc:	4603      	mov	r3, r0
    5ade:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    5ae0:	4a0d      	ldr	r2, [pc, #52]	; (5b18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    5ae2:	9b01      	ldr	r3, [sp, #4]
    5ae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ae8:	1e5a      	subs	r2, r3, #1
    5aea:	490b      	ldr	r1, [pc, #44]	; (5b18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    5aec:	9b01      	ldr	r3, [sp, #4]
    5aee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    5af2:	4a0a      	ldr	r2, [pc, #40]	; (5b1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    5af4:	9b01      	ldr	r3, [sp, #4]
    5af6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5afa:	f003 0301 	and.w	r3, r3, #1
    5afe:	2b00      	cmp	r3, #0
    5b00:	d106      	bne.n	5b10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    5b02:	4a05      	ldr	r2, [pc, #20]	; (5b18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    5b04:	9b01      	ldr	r3, [sp, #4]
    5b06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b0a:	2b00      	cmp	r3, #0
    5b0c:	d100      	bne.n	5b10 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5b0e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5b10:	bf00      	nop
    5b12:	b003      	add	sp, #12
    5b14:	f85d fb04 	ldr.w	pc, [sp], #4
    5b18:	1fff8d04 	.word	0x1fff8d04
    5b1c:	1fff8d00 	.word	0x1fff8d00

00005b20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    5b20:	b500      	push	{lr}
    5b22:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5b24:	f7fa ffbc 	bl	aa0 <Sys_GetCoreID>
    5b28:	4603      	mov	r3, r0
    5b2a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    5b2c:	4a10      	ldr	r2, [pc, #64]	; (5b70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    5b2e:	9b01      	ldr	r3, [sp, #4]
    5b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b34:	2b00      	cmp	r3, #0
    5b36:	d10d      	bne.n	5b54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5b38:	f7fa fee3 	bl	902 <Port_schm_read_msr>
    5b3c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5b3e:	9b00      	ldr	r3, [sp, #0]
    5b40:	f003 0301 	and.w	r3, r3, #1
    5b44:	2b00      	cmp	r3, #0
    5b46:	d100      	bne.n	5b4a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5b48:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    5b4a:	490a      	ldr	r1, [pc, #40]	; (5b74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    5b4c:	9b01      	ldr	r3, [sp, #4]
    5b4e:	9a00      	ldr	r2, [sp, #0]
    5b50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    5b54:	4a06      	ldr	r2, [pc, #24]	; (5b70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    5b56:	9b01      	ldr	r3, [sp, #4]
    5b58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b5c:	1c5a      	adds	r2, r3, #1
    5b5e:	4904      	ldr	r1, [pc, #16]	; (5b70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    5b60:	9b01      	ldr	r3, [sp, #4]
    5b62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5b66:	bf00      	nop
    5b68:	b003      	add	sp, #12
    5b6a:	f85d fb04 	ldr.w	pc, [sp], #4
    5b6e:	bf00      	nop
    5b70:	1fff8d0c 	.word	0x1fff8d0c
    5b74:	1fff8d08 	.word	0x1fff8d08

00005b78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    5b78:	b500      	push	{lr}
    5b7a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5b7c:	f7fa ff90 	bl	aa0 <Sys_GetCoreID>
    5b80:	4603      	mov	r3, r0
    5b82:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    5b84:	4a0d      	ldr	r2, [pc, #52]	; (5bbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    5b86:	9b01      	ldr	r3, [sp, #4]
    5b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b8c:	1e5a      	subs	r2, r3, #1
    5b8e:	490b      	ldr	r1, [pc, #44]	; (5bbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    5b90:	9b01      	ldr	r3, [sp, #4]
    5b92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    5b96:	4a0a      	ldr	r2, [pc, #40]	; (5bc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    5b98:	9b01      	ldr	r3, [sp, #4]
    5b9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5b9e:	f003 0301 	and.w	r3, r3, #1
    5ba2:	2b00      	cmp	r3, #0
    5ba4:	d106      	bne.n	5bb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    5ba6:	4a05      	ldr	r2, [pc, #20]	; (5bbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    5ba8:	9b01      	ldr	r3, [sp, #4]
    5baa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5bae:	2b00      	cmp	r3, #0
    5bb0:	d100      	bne.n	5bb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5bb2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5bb4:	bf00      	nop
    5bb6:	b003      	add	sp, #12
    5bb8:	f85d fb04 	ldr.w	pc, [sp], #4
    5bbc:	1fff8d0c 	.word	0x1fff8d0c
    5bc0:	1fff8d08 	.word	0x1fff8d08

00005bc4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    5bc4:	b500      	push	{lr}
    5bc6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5bc8:	f7fa ff6a 	bl	aa0 <Sys_GetCoreID>
    5bcc:	4603      	mov	r3, r0
    5bce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    5bd0:	4a10      	ldr	r2, [pc, #64]	; (5c14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    5bd2:	9b01      	ldr	r3, [sp, #4]
    5bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5bd8:	2b00      	cmp	r3, #0
    5bda:	d10d      	bne.n	5bf8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5bdc:	f7fa fe91 	bl	902 <Port_schm_read_msr>
    5be0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5be2:	9b00      	ldr	r3, [sp, #0]
    5be4:	f003 0301 	and.w	r3, r3, #1
    5be8:	2b00      	cmp	r3, #0
    5bea:	d100      	bne.n	5bee <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5bec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    5bee:	490a      	ldr	r1, [pc, #40]	; (5c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    5bf0:	9b01      	ldr	r3, [sp, #4]
    5bf2:	9a00      	ldr	r2, [sp, #0]
    5bf4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    5bf8:	4a06      	ldr	r2, [pc, #24]	; (5c14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    5bfa:	9b01      	ldr	r3, [sp, #4]
    5bfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c00:	1c5a      	adds	r2, r3, #1
    5c02:	4904      	ldr	r1, [pc, #16]	; (5c14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    5c04:	9b01      	ldr	r3, [sp, #4]
    5c06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5c0a:	bf00      	nop
    5c0c:	b003      	add	sp, #12
    5c0e:	f85d fb04 	ldr.w	pc, [sp], #4
    5c12:	bf00      	nop
    5c14:	1fff8d14 	.word	0x1fff8d14
    5c18:	1fff8d10 	.word	0x1fff8d10

00005c1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    5c1c:	b500      	push	{lr}
    5c1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5c20:	f7fa ff3e 	bl	aa0 <Sys_GetCoreID>
    5c24:	4603      	mov	r3, r0
    5c26:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    5c28:	4a0d      	ldr	r2, [pc, #52]	; (5c60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    5c2a:	9b01      	ldr	r3, [sp, #4]
    5c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c30:	1e5a      	subs	r2, r3, #1
    5c32:	490b      	ldr	r1, [pc, #44]	; (5c60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    5c34:	9b01      	ldr	r3, [sp, #4]
    5c36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    5c3a:	4a0a      	ldr	r2, [pc, #40]	; (5c64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    5c3c:	9b01      	ldr	r3, [sp, #4]
    5c3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c42:	f003 0301 	and.w	r3, r3, #1
    5c46:	2b00      	cmp	r3, #0
    5c48:	d106      	bne.n	5c58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    5c4a:	4a05      	ldr	r2, [pc, #20]	; (5c60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    5c4c:	9b01      	ldr	r3, [sp, #4]
    5c4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c52:	2b00      	cmp	r3, #0
    5c54:	d100      	bne.n	5c58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5c56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5c58:	bf00      	nop
    5c5a:	b003      	add	sp, #12
    5c5c:	f85d fb04 	ldr.w	pc, [sp], #4
    5c60:	1fff8d14 	.word	0x1fff8d14
    5c64:	1fff8d10 	.word	0x1fff8d10

00005c68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    5c68:	b500      	push	{lr}
    5c6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5c6c:	f7fa ff18 	bl	aa0 <Sys_GetCoreID>
    5c70:	4603      	mov	r3, r0
    5c72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    5c74:	4a10      	ldr	r2, [pc, #64]	; (5cb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    5c76:	9b01      	ldr	r3, [sp, #4]
    5c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5c7c:	2b00      	cmp	r3, #0
    5c7e:	d10d      	bne.n	5c9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5c80:	f7fa fe3f 	bl	902 <Port_schm_read_msr>
    5c84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5c86:	9b00      	ldr	r3, [sp, #0]
    5c88:	f003 0301 	and.w	r3, r3, #1
    5c8c:	2b00      	cmp	r3, #0
    5c8e:	d100      	bne.n	5c92 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5c90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    5c92:	490a      	ldr	r1, [pc, #40]	; (5cbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    5c94:	9b01      	ldr	r3, [sp, #4]
    5c96:	9a00      	ldr	r2, [sp, #0]
    5c98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    5c9c:	4a06      	ldr	r2, [pc, #24]	; (5cb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    5c9e:	9b01      	ldr	r3, [sp, #4]
    5ca0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ca4:	1c5a      	adds	r2, r3, #1
    5ca6:	4904      	ldr	r1, [pc, #16]	; (5cb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    5ca8:	9b01      	ldr	r3, [sp, #4]
    5caa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5cae:	bf00      	nop
    5cb0:	b003      	add	sp, #12
    5cb2:	f85d fb04 	ldr.w	pc, [sp], #4
    5cb6:	bf00      	nop
    5cb8:	1fff8d1c 	.word	0x1fff8d1c
    5cbc:	1fff8d18 	.word	0x1fff8d18

00005cc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    5cc0:	b500      	push	{lr}
    5cc2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5cc4:	f7fa feec 	bl	aa0 <Sys_GetCoreID>
    5cc8:	4603      	mov	r3, r0
    5cca:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    5ccc:	4a0d      	ldr	r2, [pc, #52]	; (5d04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    5cce:	9b01      	ldr	r3, [sp, #4]
    5cd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5cd4:	1e5a      	subs	r2, r3, #1
    5cd6:	490b      	ldr	r1, [pc, #44]	; (5d04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    5cd8:	9b01      	ldr	r3, [sp, #4]
    5cda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    5cde:	4a0a      	ldr	r2, [pc, #40]	; (5d08 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    5ce0:	9b01      	ldr	r3, [sp, #4]
    5ce2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ce6:	f003 0301 	and.w	r3, r3, #1
    5cea:	2b00      	cmp	r3, #0
    5cec:	d106      	bne.n	5cfc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    5cee:	4a05      	ldr	r2, [pc, #20]	; (5d04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    5cf0:	9b01      	ldr	r3, [sp, #4]
    5cf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5cf6:	2b00      	cmp	r3, #0
    5cf8:	d100      	bne.n	5cfc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5cfa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5cfc:	bf00      	nop
    5cfe:	b003      	add	sp, #12
    5d00:	f85d fb04 	ldr.w	pc, [sp], #4
    5d04:	1fff8d1c 	.word	0x1fff8d1c
    5d08:	1fff8d18 	.word	0x1fff8d18

00005d0c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    5d0c:	b500      	push	{lr}
    5d0e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5d10:	f7fa fec6 	bl	aa0 <Sys_GetCoreID>
    5d14:	4603      	mov	r3, r0
    5d16:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    5d18:	4a10      	ldr	r2, [pc, #64]	; (5d5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    5d1a:	9b01      	ldr	r3, [sp, #4]
    5d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d20:	2b00      	cmp	r3, #0
    5d22:	d10d      	bne.n	5d40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5d24:	f7fa fded 	bl	902 <Port_schm_read_msr>
    5d28:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5d2a:	9b00      	ldr	r3, [sp, #0]
    5d2c:	f003 0301 	and.w	r3, r3, #1
    5d30:	2b00      	cmp	r3, #0
    5d32:	d100      	bne.n	5d36 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5d34:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    5d36:	490a      	ldr	r1, [pc, #40]	; (5d60 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    5d38:	9b01      	ldr	r3, [sp, #4]
    5d3a:	9a00      	ldr	r2, [sp, #0]
    5d3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    5d40:	4a06      	ldr	r2, [pc, #24]	; (5d5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    5d42:	9b01      	ldr	r3, [sp, #4]
    5d44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d48:	1c5a      	adds	r2, r3, #1
    5d4a:	4904      	ldr	r1, [pc, #16]	; (5d5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    5d4c:	9b01      	ldr	r3, [sp, #4]
    5d4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5d52:	bf00      	nop
    5d54:	b003      	add	sp, #12
    5d56:	f85d fb04 	ldr.w	pc, [sp], #4
    5d5a:	bf00      	nop
    5d5c:	1fff8d24 	.word	0x1fff8d24
    5d60:	1fff8d20 	.word	0x1fff8d20

00005d64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    5d64:	b500      	push	{lr}
    5d66:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5d68:	f7fa fe9a 	bl	aa0 <Sys_GetCoreID>
    5d6c:	4603      	mov	r3, r0
    5d6e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    5d70:	4a0d      	ldr	r2, [pc, #52]	; (5da8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    5d72:	9b01      	ldr	r3, [sp, #4]
    5d74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d78:	1e5a      	subs	r2, r3, #1
    5d7a:	490b      	ldr	r1, [pc, #44]	; (5da8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    5d7c:	9b01      	ldr	r3, [sp, #4]
    5d7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    5d82:	4a0a      	ldr	r2, [pc, #40]	; (5dac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    5d84:	9b01      	ldr	r3, [sp, #4]
    5d86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d8a:	f003 0301 	and.w	r3, r3, #1
    5d8e:	2b00      	cmp	r3, #0
    5d90:	d106      	bne.n	5da0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    5d92:	4a05      	ldr	r2, [pc, #20]	; (5da8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    5d94:	9b01      	ldr	r3, [sp, #4]
    5d96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d9a:	2b00      	cmp	r3, #0
    5d9c:	d100      	bne.n	5da0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5d9e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5da0:	bf00      	nop
    5da2:	b003      	add	sp, #12
    5da4:	f85d fb04 	ldr.w	pc, [sp], #4
    5da8:	1fff8d24 	.word	0x1fff8d24
    5dac:	1fff8d20 	.word	0x1fff8d20

00005db0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    5db0:	b500      	push	{lr}
    5db2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5db4:	f7fa fe74 	bl	aa0 <Sys_GetCoreID>
    5db8:	4603      	mov	r3, r0
    5dba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    5dbc:	4a10      	ldr	r2, [pc, #64]	; (5e00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    5dbe:	9b01      	ldr	r3, [sp, #4]
    5dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5dc4:	2b00      	cmp	r3, #0
    5dc6:	d10d      	bne.n	5de4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5dc8:	f7fa fd9b 	bl	902 <Port_schm_read_msr>
    5dcc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5dce:	9b00      	ldr	r3, [sp, #0]
    5dd0:	f003 0301 	and.w	r3, r3, #1
    5dd4:	2b00      	cmp	r3, #0
    5dd6:	d100      	bne.n	5dda <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5dd8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    5dda:	490a      	ldr	r1, [pc, #40]	; (5e04 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    5ddc:	9b01      	ldr	r3, [sp, #4]
    5dde:	9a00      	ldr	r2, [sp, #0]
    5de0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    5de4:	4a06      	ldr	r2, [pc, #24]	; (5e00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    5de6:	9b01      	ldr	r3, [sp, #4]
    5de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5dec:	1c5a      	adds	r2, r3, #1
    5dee:	4904      	ldr	r1, [pc, #16]	; (5e00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    5df0:	9b01      	ldr	r3, [sp, #4]
    5df2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5df6:	bf00      	nop
    5df8:	b003      	add	sp, #12
    5dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    5dfe:	bf00      	nop
    5e00:	1fff8d2c 	.word	0x1fff8d2c
    5e04:	1fff8d28 	.word	0x1fff8d28

00005e08 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    5e08:	b500      	push	{lr}
    5e0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5e0c:	f7fa fe48 	bl	aa0 <Sys_GetCoreID>
    5e10:	4603      	mov	r3, r0
    5e12:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    5e14:	4a0d      	ldr	r2, [pc, #52]	; (5e4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    5e16:	9b01      	ldr	r3, [sp, #4]
    5e18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e1c:	1e5a      	subs	r2, r3, #1
    5e1e:	490b      	ldr	r1, [pc, #44]	; (5e4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    5e20:	9b01      	ldr	r3, [sp, #4]
    5e22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    5e26:	4a0a      	ldr	r2, [pc, #40]	; (5e50 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    5e28:	9b01      	ldr	r3, [sp, #4]
    5e2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e2e:	f003 0301 	and.w	r3, r3, #1
    5e32:	2b00      	cmp	r3, #0
    5e34:	d106      	bne.n	5e44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    5e36:	4a05      	ldr	r2, [pc, #20]	; (5e4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    5e38:	9b01      	ldr	r3, [sp, #4]
    5e3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e3e:	2b00      	cmp	r3, #0
    5e40:	d100      	bne.n	5e44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5e42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5e44:	bf00      	nop
    5e46:	b003      	add	sp, #12
    5e48:	f85d fb04 	ldr.w	pc, [sp], #4
    5e4c:	1fff8d2c 	.word	0x1fff8d2c
    5e50:	1fff8d28 	.word	0x1fff8d28

00005e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    5e54:	b500      	push	{lr}
    5e56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5e58:	f7fa fe22 	bl	aa0 <Sys_GetCoreID>
    5e5c:	4603      	mov	r3, r0
    5e5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    5e60:	4a10      	ldr	r2, [pc, #64]	; (5ea4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    5e62:	9b01      	ldr	r3, [sp, #4]
    5e64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e68:	2b00      	cmp	r3, #0
    5e6a:	d10d      	bne.n	5e88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5e6c:	f7fa fd49 	bl	902 <Port_schm_read_msr>
    5e70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5e72:	9b00      	ldr	r3, [sp, #0]
    5e74:	f003 0301 	and.w	r3, r3, #1
    5e78:	2b00      	cmp	r3, #0
    5e7a:	d100      	bne.n	5e7e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5e7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    5e7e:	490a      	ldr	r1, [pc, #40]	; (5ea8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    5e80:	9b01      	ldr	r3, [sp, #4]
    5e82:	9a00      	ldr	r2, [sp, #0]
    5e84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    5e88:	4a06      	ldr	r2, [pc, #24]	; (5ea4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    5e8a:	9b01      	ldr	r3, [sp, #4]
    5e8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e90:	1c5a      	adds	r2, r3, #1
    5e92:	4904      	ldr	r1, [pc, #16]	; (5ea4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    5e94:	9b01      	ldr	r3, [sp, #4]
    5e96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5e9a:	bf00      	nop
    5e9c:	b003      	add	sp, #12
    5e9e:	f85d fb04 	ldr.w	pc, [sp], #4
    5ea2:	bf00      	nop
    5ea4:	1fff8d34 	.word	0x1fff8d34
    5ea8:	1fff8d30 	.word	0x1fff8d30

00005eac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    5eac:	b500      	push	{lr}
    5eae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5eb0:	f7fa fdf6 	bl	aa0 <Sys_GetCoreID>
    5eb4:	4603      	mov	r3, r0
    5eb6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    5eb8:	4a0d      	ldr	r2, [pc, #52]	; (5ef0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    5eba:	9b01      	ldr	r3, [sp, #4]
    5ebc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ec0:	1e5a      	subs	r2, r3, #1
    5ec2:	490b      	ldr	r1, [pc, #44]	; (5ef0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    5ec4:	9b01      	ldr	r3, [sp, #4]
    5ec6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    5eca:	4a0a      	ldr	r2, [pc, #40]	; (5ef4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    5ecc:	9b01      	ldr	r3, [sp, #4]
    5ece:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ed2:	f003 0301 	and.w	r3, r3, #1
    5ed6:	2b00      	cmp	r3, #0
    5ed8:	d106      	bne.n	5ee8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    5eda:	4a05      	ldr	r2, [pc, #20]	; (5ef0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    5edc:	9b01      	ldr	r3, [sp, #4]
    5ede:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ee2:	2b00      	cmp	r3, #0
    5ee4:	d100      	bne.n	5ee8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5ee6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5ee8:	bf00      	nop
    5eea:	b003      	add	sp, #12
    5eec:	f85d fb04 	ldr.w	pc, [sp], #4
    5ef0:	1fff8d34 	.word	0x1fff8d34
    5ef4:	1fff8d30 	.word	0x1fff8d30

00005ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    5ef8:	b500      	push	{lr}
    5efa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5efc:	f7fa fdd0 	bl	aa0 <Sys_GetCoreID>
    5f00:	4603      	mov	r3, r0
    5f02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    5f04:	4a10      	ldr	r2, [pc, #64]	; (5f48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    5f06:	9b01      	ldr	r3, [sp, #4]
    5f08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f0c:	2b00      	cmp	r3, #0
    5f0e:	d10d      	bne.n	5f2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5f10:	f7fa fcf7 	bl	902 <Port_schm_read_msr>
    5f14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5f16:	9b00      	ldr	r3, [sp, #0]
    5f18:	f003 0301 	and.w	r3, r3, #1
    5f1c:	2b00      	cmp	r3, #0
    5f1e:	d100      	bne.n	5f22 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5f20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    5f22:	490a      	ldr	r1, [pc, #40]	; (5f4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    5f24:	9b01      	ldr	r3, [sp, #4]
    5f26:	9a00      	ldr	r2, [sp, #0]
    5f28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    5f2c:	4a06      	ldr	r2, [pc, #24]	; (5f48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    5f2e:	9b01      	ldr	r3, [sp, #4]
    5f30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f34:	1c5a      	adds	r2, r3, #1
    5f36:	4904      	ldr	r1, [pc, #16]	; (5f48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    5f38:	9b01      	ldr	r3, [sp, #4]
    5f3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5f3e:	bf00      	nop
    5f40:	b003      	add	sp, #12
    5f42:	f85d fb04 	ldr.w	pc, [sp], #4
    5f46:	bf00      	nop
    5f48:	1fff8d3c 	.word	0x1fff8d3c
    5f4c:	1fff8d38 	.word	0x1fff8d38

00005f50 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    5f50:	b500      	push	{lr}
    5f52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5f54:	f7fa fda4 	bl	aa0 <Sys_GetCoreID>
    5f58:	4603      	mov	r3, r0
    5f5a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    5f5c:	4a0d      	ldr	r2, [pc, #52]	; (5f94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    5f5e:	9b01      	ldr	r3, [sp, #4]
    5f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f64:	1e5a      	subs	r2, r3, #1
    5f66:	490b      	ldr	r1, [pc, #44]	; (5f94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    5f68:	9b01      	ldr	r3, [sp, #4]
    5f6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    5f6e:	4a0a      	ldr	r2, [pc, #40]	; (5f98 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    5f70:	9b01      	ldr	r3, [sp, #4]
    5f72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f76:	f003 0301 	and.w	r3, r3, #1
    5f7a:	2b00      	cmp	r3, #0
    5f7c:	d106      	bne.n	5f8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    5f7e:	4a05      	ldr	r2, [pc, #20]	; (5f94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    5f80:	9b01      	ldr	r3, [sp, #4]
    5f82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f86:	2b00      	cmp	r3, #0
    5f88:	d100      	bne.n	5f8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    5f8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    5f8c:	bf00      	nop
    5f8e:	b003      	add	sp, #12
    5f90:	f85d fb04 	ldr.w	pc, [sp], #4
    5f94:	1fff8d3c 	.word	0x1fff8d3c
    5f98:	1fff8d38 	.word	0x1fff8d38

00005f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    5f9c:	b500      	push	{lr}
    5f9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5fa0:	f7fa fd7e 	bl	aa0 <Sys_GetCoreID>
    5fa4:	4603      	mov	r3, r0
    5fa6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    5fa8:	4a10      	ldr	r2, [pc, #64]	; (5fec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    5faa:	9b01      	ldr	r3, [sp, #4]
    5fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5fb0:	2b00      	cmp	r3, #0
    5fb2:	d10d      	bne.n	5fd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    5fb4:	f7fa fca5 	bl	902 <Port_schm_read_msr>
    5fb8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    5fba:	9b00      	ldr	r3, [sp, #0]
    5fbc:	f003 0301 	and.w	r3, r3, #1
    5fc0:	2b00      	cmp	r3, #0
    5fc2:	d100      	bne.n	5fc6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    5fc4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    5fc6:	490a      	ldr	r1, [pc, #40]	; (5ff0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    5fc8:	9b01      	ldr	r3, [sp, #4]
    5fca:	9a00      	ldr	r2, [sp, #0]
    5fcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    5fd0:	4a06      	ldr	r2, [pc, #24]	; (5fec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    5fd2:	9b01      	ldr	r3, [sp, #4]
    5fd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5fd8:	1c5a      	adds	r2, r3, #1
    5fda:	4904      	ldr	r1, [pc, #16]	; (5fec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    5fdc:	9b01      	ldr	r3, [sp, #4]
    5fde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    5fe2:	bf00      	nop
    5fe4:	b003      	add	sp, #12
    5fe6:	f85d fb04 	ldr.w	pc, [sp], #4
    5fea:	bf00      	nop
    5fec:	1fff8d44 	.word	0x1fff8d44
    5ff0:	1fff8d40 	.word	0x1fff8d40

00005ff4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    5ff4:	b500      	push	{lr}
    5ff6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    5ff8:	f7fa fd52 	bl	aa0 <Sys_GetCoreID>
    5ffc:	4603      	mov	r3, r0
    5ffe:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    6000:	4a0d      	ldr	r2, [pc, #52]	; (6038 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    6002:	9b01      	ldr	r3, [sp, #4]
    6004:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6008:	1e5a      	subs	r2, r3, #1
    600a:	490b      	ldr	r1, [pc, #44]	; (6038 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    600c:	9b01      	ldr	r3, [sp, #4]
    600e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    6012:	4a0a      	ldr	r2, [pc, #40]	; (603c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    6014:	9b01      	ldr	r3, [sp, #4]
    6016:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    601a:	f003 0301 	and.w	r3, r3, #1
    601e:	2b00      	cmp	r3, #0
    6020:	d106      	bne.n	6030 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    6022:	4a05      	ldr	r2, [pc, #20]	; (6038 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    6024:	9b01      	ldr	r3, [sp, #4]
    6026:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    602a:	2b00      	cmp	r3, #0
    602c:	d100      	bne.n	6030 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    602e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6030:	bf00      	nop
    6032:	b003      	add	sp, #12
    6034:	f85d fb04 	ldr.w	pc, [sp], #4
    6038:	1fff8d44 	.word	0x1fff8d44
    603c:	1fff8d40 	.word	0x1fff8d40

00006040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    6040:	b500      	push	{lr}
    6042:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6044:	f7fa fd2c 	bl	aa0 <Sys_GetCoreID>
    6048:	4603      	mov	r3, r0
    604a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    604c:	4a10      	ldr	r2, [pc, #64]	; (6090 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    604e:	9b01      	ldr	r3, [sp, #4]
    6050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6054:	2b00      	cmp	r3, #0
    6056:	d10d      	bne.n	6074 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6058:	f7fa fc53 	bl	902 <Port_schm_read_msr>
    605c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    605e:	9b00      	ldr	r3, [sp, #0]
    6060:	f003 0301 	and.w	r3, r3, #1
    6064:	2b00      	cmp	r3, #0
    6066:	d100      	bne.n	606a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6068:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    606a:	490a      	ldr	r1, [pc, #40]	; (6094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    606c:	9b01      	ldr	r3, [sp, #4]
    606e:	9a00      	ldr	r2, [sp, #0]
    6070:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    6074:	4a06      	ldr	r2, [pc, #24]	; (6090 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    6076:	9b01      	ldr	r3, [sp, #4]
    6078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    607c:	1c5a      	adds	r2, r3, #1
    607e:	4904      	ldr	r1, [pc, #16]	; (6090 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    6080:	9b01      	ldr	r3, [sp, #4]
    6082:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6086:	bf00      	nop
    6088:	b003      	add	sp, #12
    608a:	f85d fb04 	ldr.w	pc, [sp], #4
    608e:	bf00      	nop
    6090:	1fff8d4c 	.word	0x1fff8d4c
    6094:	1fff8d48 	.word	0x1fff8d48

00006098 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    6098:	b500      	push	{lr}
    609a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    609c:	f7fa fd00 	bl	aa0 <Sys_GetCoreID>
    60a0:	4603      	mov	r3, r0
    60a2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    60a4:	4a0d      	ldr	r2, [pc, #52]	; (60dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    60a6:	9b01      	ldr	r3, [sp, #4]
    60a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60ac:	1e5a      	subs	r2, r3, #1
    60ae:	490b      	ldr	r1, [pc, #44]	; (60dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    60b0:	9b01      	ldr	r3, [sp, #4]
    60b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    60b6:	4a0a      	ldr	r2, [pc, #40]	; (60e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    60b8:	9b01      	ldr	r3, [sp, #4]
    60ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60be:	f003 0301 	and.w	r3, r3, #1
    60c2:	2b00      	cmp	r3, #0
    60c4:	d106      	bne.n	60d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    60c6:	4a05      	ldr	r2, [pc, #20]	; (60dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    60c8:	9b01      	ldr	r3, [sp, #4]
    60ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60ce:	2b00      	cmp	r3, #0
    60d0:	d100      	bne.n	60d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    60d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    60d4:	bf00      	nop
    60d6:	b003      	add	sp, #12
    60d8:	f85d fb04 	ldr.w	pc, [sp], #4
    60dc:	1fff8d4c 	.word	0x1fff8d4c
    60e0:	1fff8d48 	.word	0x1fff8d48

000060e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    60e4:	b500      	push	{lr}
    60e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    60e8:	f7fa fcda 	bl	aa0 <Sys_GetCoreID>
    60ec:	4603      	mov	r3, r0
    60ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    60f0:	4a10      	ldr	r2, [pc, #64]	; (6134 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    60f2:	9b01      	ldr	r3, [sp, #4]
    60f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60f8:	2b00      	cmp	r3, #0
    60fa:	d10d      	bne.n	6118 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    60fc:	f7fa fc01 	bl	902 <Port_schm_read_msr>
    6100:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6102:	9b00      	ldr	r3, [sp, #0]
    6104:	f003 0301 	and.w	r3, r3, #1
    6108:	2b00      	cmp	r3, #0
    610a:	d100      	bne.n	610e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    610c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    610e:	490a      	ldr	r1, [pc, #40]	; (6138 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    6110:	9b01      	ldr	r3, [sp, #4]
    6112:	9a00      	ldr	r2, [sp, #0]
    6114:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    6118:	4a06      	ldr	r2, [pc, #24]	; (6134 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    611a:	9b01      	ldr	r3, [sp, #4]
    611c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6120:	1c5a      	adds	r2, r3, #1
    6122:	4904      	ldr	r1, [pc, #16]	; (6134 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    6124:	9b01      	ldr	r3, [sp, #4]
    6126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    612a:	bf00      	nop
    612c:	b003      	add	sp, #12
    612e:	f85d fb04 	ldr.w	pc, [sp], #4
    6132:	bf00      	nop
    6134:	1fff8d54 	.word	0x1fff8d54
    6138:	1fff8d50 	.word	0x1fff8d50

0000613c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    613c:	b500      	push	{lr}
    613e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6140:	f7fa fcae 	bl	aa0 <Sys_GetCoreID>
    6144:	4603      	mov	r3, r0
    6146:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    6148:	4a0d      	ldr	r2, [pc, #52]	; (6180 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    614a:	9b01      	ldr	r3, [sp, #4]
    614c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6150:	1e5a      	subs	r2, r3, #1
    6152:	490b      	ldr	r1, [pc, #44]	; (6180 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    6154:	9b01      	ldr	r3, [sp, #4]
    6156:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    615a:	4a0a      	ldr	r2, [pc, #40]	; (6184 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    615c:	9b01      	ldr	r3, [sp, #4]
    615e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6162:	f003 0301 	and.w	r3, r3, #1
    6166:	2b00      	cmp	r3, #0
    6168:	d106      	bne.n	6178 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    616a:	4a05      	ldr	r2, [pc, #20]	; (6180 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    616c:	9b01      	ldr	r3, [sp, #4]
    616e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6172:	2b00      	cmp	r3, #0
    6174:	d100      	bne.n	6178 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6176:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6178:	bf00      	nop
    617a:	b003      	add	sp, #12
    617c:	f85d fb04 	ldr.w	pc, [sp], #4
    6180:	1fff8d54 	.word	0x1fff8d54
    6184:	1fff8d50 	.word	0x1fff8d50

00006188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    6188:	b500      	push	{lr}
    618a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    618c:	f7fa fc88 	bl	aa0 <Sys_GetCoreID>
    6190:	4603      	mov	r3, r0
    6192:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    6194:	4a10      	ldr	r2, [pc, #64]	; (61d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    6196:	9b01      	ldr	r3, [sp, #4]
    6198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    619c:	2b00      	cmp	r3, #0
    619e:	d10d      	bne.n	61bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    61a0:	f7fa fbaf 	bl	902 <Port_schm_read_msr>
    61a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    61a6:	9b00      	ldr	r3, [sp, #0]
    61a8:	f003 0301 	and.w	r3, r3, #1
    61ac:	2b00      	cmp	r3, #0
    61ae:	d100      	bne.n	61b2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    61b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    61b2:	490a      	ldr	r1, [pc, #40]	; (61dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    61b4:	9b01      	ldr	r3, [sp, #4]
    61b6:	9a00      	ldr	r2, [sp, #0]
    61b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    61bc:	4a06      	ldr	r2, [pc, #24]	; (61d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    61be:	9b01      	ldr	r3, [sp, #4]
    61c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    61c4:	1c5a      	adds	r2, r3, #1
    61c6:	4904      	ldr	r1, [pc, #16]	; (61d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    61c8:	9b01      	ldr	r3, [sp, #4]
    61ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    61ce:	bf00      	nop
    61d0:	b003      	add	sp, #12
    61d2:	f85d fb04 	ldr.w	pc, [sp], #4
    61d6:	bf00      	nop
    61d8:	1fff8d5c 	.word	0x1fff8d5c
    61dc:	1fff8d58 	.word	0x1fff8d58

000061e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    61e0:	b500      	push	{lr}
    61e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    61e4:	f7fa fc5c 	bl	aa0 <Sys_GetCoreID>
    61e8:	4603      	mov	r3, r0
    61ea:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    61ec:	4a0d      	ldr	r2, [pc, #52]	; (6224 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    61ee:	9b01      	ldr	r3, [sp, #4]
    61f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    61f4:	1e5a      	subs	r2, r3, #1
    61f6:	490b      	ldr	r1, [pc, #44]	; (6224 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    61f8:	9b01      	ldr	r3, [sp, #4]
    61fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    61fe:	4a0a      	ldr	r2, [pc, #40]	; (6228 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    6200:	9b01      	ldr	r3, [sp, #4]
    6202:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6206:	f003 0301 	and.w	r3, r3, #1
    620a:	2b00      	cmp	r3, #0
    620c:	d106      	bne.n	621c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    620e:	4a05      	ldr	r2, [pc, #20]	; (6224 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    6210:	9b01      	ldr	r3, [sp, #4]
    6212:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6216:	2b00      	cmp	r3, #0
    6218:	d100      	bne.n	621c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    621a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    621c:	bf00      	nop
    621e:	b003      	add	sp, #12
    6220:	f85d fb04 	ldr.w	pc, [sp], #4
    6224:	1fff8d5c 	.word	0x1fff8d5c
    6228:	1fff8d58 	.word	0x1fff8d58

0000622c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    622c:	b500      	push	{lr}
    622e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6230:	f7fa fc36 	bl	aa0 <Sys_GetCoreID>
    6234:	4603      	mov	r3, r0
    6236:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    6238:	4a10      	ldr	r2, [pc, #64]	; (627c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    623a:	9b01      	ldr	r3, [sp, #4]
    623c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6240:	2b00      	cmp	r3, #0
    6242:	d10d      	bne.n	6260 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6244:	f7fa fb5d 	bl	902 <Port_schm_read_msr>
    6248:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    624a:	9b00      	ldr	r3, [sp, #0]
    624c:	f003 0301 	and.w	r3, r3, #1
    6250:	2b00      	cmp	r3, #0
    6252:	d100      	bne.n	6256 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6254:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    6256:	490a      	ldr	r1, [pc, #40]	; (6280 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    6258:	9b01      	ldr	r3, [sp, #4]
    625a:	9a00      	ldr	r2, [sp, #0]
    625c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    6260:	4a06      	ldr	r2, [pc, #24]	; (627c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    6262:	9b01      	ldr	r3, [sp, #4]
    6264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6268:	1c5a      	adds	r2, r3, #1
    626a:	4904      	ldr	r1, [pc, #16]	; (627c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    626c:	9b01      	ldr	r3, [sp, #4]
    626e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6272:	bf00      	nop
    6274:	b003      	add	sp, #12
    6276:	f85d fb04 	ldr.w	pc, [sp], #4
    627a:	bf00      	nop
    627c:	1fff8d64 	.word	0x1fff8d64
    6280:	1fff8d60 	.word	0x1fff8d60

00006284 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    6284:	b500      	push	{lr}
    6286:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6288:	f7fa fc0a 	bl	aa0 <Sys_GetCoreID>
    628c:	4603      	mov	r3, r0
    628e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    6290:	4a0d      	ldr	r2, [pc, #52]	; (62c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    6292:	9b01      	ldr	r3, [sp, #4]
    6294:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6298:	1e5a      	subs	r2, r3, #1
    629a:	490b      	ldr	r1, [pc, #44]	; (62c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    629c:	9b01      	ldr	r3, [sp, #4]
    629e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    62a2:	4a0a      	ldr	r2, [pc, #40]	; (62cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    62a4:	9b01      	ldr	r3, [sp, #4]
    62a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62aa:	f003 0301 	and.w	r3, r3, #1
    62ae:	2b00      	cmp	r3, #0
    62b0:	d106      	bne.n	62c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    62b2:	4a05      	ldr	r2, [pc, #20]	; (62c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    62b4:	9b01      	ldr	r3, [sp, #4]
    62b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62ba:	2b00      	cmp	r3, #0
    62bc:	d100      	bne.n	62c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    62be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    62c0:	bf00      	nop
    62c2:	b003      	add	sp, #12
    62c4:	f85d fb04 	ldr.w	pc, [sp], #4
    62c8:	1fff8d64 	.word	0x1fff8d64
    62cc:	1fff8d60 	.word	0x1fff8d60

000062d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    62d0:	b500      	push	{lr}
    62d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    62d4:	f7fa fbe4 	bl	aa0 <Sys_GetCoreID>
    62d8:	4603      	mov	r3, r0
    62da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    62dc:	4a10      	ldr	r2, [pc, #64]	; (6320 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    62de:	9b01      	ldr	r3, [sp, #4]
    62e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62e4:	2b00      	cmp	r3, #0
    62e6:	d10d      	bne.n	6304 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    62e8:	f7fa fb0b 	bl	902 <Port_schm_read_msr>
    62ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    62ee:	9b00      	ldr	r3, [sp, #0]
    62f0:	f003 0301 	and.w	r3, r3, #1
    62f4:	2b00      	cmp	r3, #0
    62f6:	d100      	bne.n	62fa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    62f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    62fa:	490a      	ldr	r1, [pc, #40]	; (6324 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    62fc:	9b01      	ldr	r3, [sp, #4]
    62fe:	9a00      	ldr	r2, [sp, #0]
    6300:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    6304:	4a06      	ldr	r2, [pc, #24]	; (6320 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    6306:	9b01      	ldr	r3, [sp, #4]
    6308:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    630c:	1c5a      	adds	r2, r3, #1
    630e:	4904      	ldr	r1, [pc, #16]	; (6320 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    6310:	9b01      	ldr	r3, [sp, #4]
    6312:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6316:	bf00      	nop
    6318:	b003      	add	sp, #12
    631a:	f85d fb04 	ldr.w	pc, [sp], #4
    631e:	bf00      	nop
    6320:	1fff8d6c 	.word	0x1fff8d6c
    6324:	1fff8d68 	.word	0x1fff8d68

00006328 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    6328:	b500      	push	{lr}
    632a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    632c:	f7fa fbb8 	bl	aa0 <Sys_GetCoreID>
    6330:	4603      	mov	r3, r0
    6332:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    6334:	4a0d      	ldr	r2, [pc, #52]	; (636c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    6336:	9b01      	ldr	r3, [sp, #4]
    6338:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    633c:	1e5a      	subs	r2, r3, #1
    633e:	490b      	ldr	r1, [pc, #44]	; (636c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    6340:	9b01      	ldr	r3, [sp, #4]
    6342:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    6346:	4a0a      	ldr	r2, [pc, #40]	; (6370 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    6348:	9b01      	ldr	r3, [sp, #4]
    634a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    634e:	f003 0301 	and.w	r3, r3, #1
    6352:	2b00      	cmp	r3, #0
    6354:	d106      	bne.n	6364 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    6356:	4a05      	ldr	r2, [pc, #20]	; (636c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    6358:	9b01      	ldr	r3, [sp, #4]
    635a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    635e:	2b00      	cmp	r3, #0
    6360:	d100      	bne.n	6364 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6362:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6364:	bf00      	nop
    6366:	b003      	add	sp, #12
    6368:	f85d fb04 	ldr.w	pc, [sp], #4
    636c:	1fff8d6c 	.word	0x1fff8d6c
    6370:	1fff8d68 	.word	0x1fff8d68

00006374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    6374:	b500      	push	{lr}
    6376:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6378:	f7fa fb92 	bl	aa0 <Sys_GetCoreID>
    637c:	4603      	mov	r3, r0
    637e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    6380:	4a10      	ldr	r2, [pc, #64]	; (63c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    6382:	9b01      	ldr	r3, [sp, #4]
    6384:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6388:	2b00      	cmp	r3, #0
    638a:	d10d      	bne.n	63a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    638c:	f7fa fab9 	bl	902 <Port_schm_read_msr>
    6390:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6392:	9b00      	ldr	r3, [sp, #0]
    6394:	f003 0301 	and.w	r3, r3, #1
    6398:	2b00      	cmp	r3, #0
    639a:	d100      	bne.n	639e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    639c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    639e:	490a      	ldr	r1, [pc, #40]	; (63c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    63a0:	9b01      	ldr	r3, [sp, #4]
    63a2:	9a00      	ldr	r2, [sp, #0]
    63a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    63a8:	4a06      	ldr	r2, [pc, #24]	; (63c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    63aa:	9b01      	ldr	r3, [sp, #4]
    63ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63b0:	1c5a      	adds	r2, r3, #1
    63b2:	4904      	ldr	r1, [pc, #16]	; (63c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    63b4:	9b01      	ldr	r3, [sp, #4]
    63b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    63ba:	bf00      	nop
    63bc:	b003      	add	sp, #12
    63be:	f85d fb04 	ldr.w	pc, [sp], #4
    63c2:	bf00      	nop
    63c4:	1fff8d74 	.word	0x1fff8d74
    63c8:	1fff8d70 	.word	0x1fff8d70

000063cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    63cc:	b500      	push	{lr}
    63ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    63d0:	f7fa fb66 	bl	aa0 <Sys_GetCoreID>
    63d4:	4603      	mov	r3, r0
    63d6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    63d8:	4a0d      	ldr	r2, [pc, #52]	; (6410 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    63da:	9b01      	ldr	r3, [sp, #4]
    63dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63e0:	1e5a      	subs	r2, r3, #1
    63e2:	490b      	ldr	r1, [pc, #44]	; (6410 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    63e4:	9b01      	ldr	r3, [sp, #4]
    63e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    63ea:	4a0a      	ldr	r2, [pc, #40]	; (6414 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    63ec:	9b01      	ldr	r3, [sp, #4]
    63ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63f2:	f003 0301 	and.w	r3, r3, #1
    63f6:	2b00      	cmp	r3, #0
    63f8:	d106      	bne.n	6408 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    63fa:	4a05      	ldr	r2, [pc, #20]	; (6410 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    63fc:	9b01      	ldr	r3, [sp, #4]
    63fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6402:	2b00      	cmp	r3, #0
    6404:	d100      	bne.n	6408 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6406:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6408:	bf00      	nop
    640a:	b003      	add	sp, #12
    640c:	f85d fb04 	ldr.w	pc, [sp], #4
    6410:	1fff8d74 	.word	0x1fff8d74
    6414:	1fff8d70 	.word	0x1fff8d70

00006418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    6418:	b500      	push	{lr}
    641a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    641c:	f7fa fb40 	bl	aa0 <Sys_GetCoreID>
    6420:	4603      	mov	r3, r0
    6422:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    6424:	4a10      	ldr	r2, [pc, #64]	; (6468 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    6426:	9b01      	ldr	r3, [sp, #4]
    6428:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    642c:	2b00      	cmp	r3, #0
    642e:	d10d      	bne.n	644c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6430:	f7fa fa67 	bl	902 <Port_schm_read_msr>
    6434:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6436:	9b00      	ldr	r3, [sp, #0]
    6438:	f003 0301 	and.w	r3, r3, #1
    643c:	2b00      	cmp	r3, #0
    643e:	d100      	bne.n	6442 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6440:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    6442:	490a      	ldr	r1, [pc, #40]	; (646c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    6444:	9b01      	ldr	r3, [sp, #4]
    6446:	9a00      	ldr	r2, [sp, #0]
    6448:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    644c:	4a06      	ldr	r2, [pc, #24]	; (6468 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    644e:	9b01      	ldr	r3, [sp, #4]
    6450:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6454:	1c5a      	adds	r2, r3, #1
    6456:	4904      	ldr	r1, [pc, #16]	; (6468 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    6458:	9b01      	ldr	r3, [sp, #4]
    645a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    645e:	bf00      	nop
    6460:	b003      	add	sp, #12
    6462:	f85d fb04 	ldr.w	pc, [sp], #4
    6466:	bf00      	nop
    6468:	1fff8d7c 	.word	0x1fff8d7c
    646c:	1fff8d78 	.word	0x1fff8d78

00006470 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    6470:	b500      	push	{lr}
    6472:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6474:	f7fa fb14 	bl	aa0 <Sys_GetCoreID>
    6478:	4603      	mov	r3, r0
    647a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    647c:	4a0d      	ldr	r2, [pc, #52]	; (64b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    647e:	9b01      	ldr	r3, [sp, #4]
    6480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6484:	1e5a      	subs	r2, r3, #1
    6486:	490b      	ldr	r1, [pc, #44]	; (64b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    6488:	9b01      	ldr	r3, [sp, #4]
    648a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    648e:	4a0a      	ldr	r2, [pc, #40]	; (64b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    6490:	9b01      	ldr	r3, [sp, #4]
    6492:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6496:	f003 0301 	and.w	r3, r3, #1
    649a:	2b00      	cmp	r3, #0
    649c:	d106      	bne.n	64ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    649e:	4a05      	ldr	r2, [pc, #20]	; (64b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    64a0:	9b01      	ldr	r3, [sp, #4]
    64a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64a6:	2b00      	cmp	r3, #0
    64a8:	d100      	bne.n	64ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    64aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    64ac:	bf00      	nop
    64ae:	b003      	add	sp, #12
    64b0:	f85d fb04 	ldr.w	pc, [sp], #4
    64b4:	1fff8d7c 	.word	0x1fff8d7c
    64b8:	1fff8d78 	.word	0x1fff8d78

000064bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    64bc:	b500      	push	{lr}
    64be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    64c0:	f7fa faee 	bl	aa0 <Sys_GetCoreID>
    64c4:	4603      	mov	r3, r0
    64c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    64c8:	4a10      	ldr	r2, [pc, #64]	; (650c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    64ca:	9b01      	ldr	r3, [sp, #4]
    64cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64d0:	2b00      	cmp	r3, #0
    64d2:	d10d      	bne.n	64f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    64d4:	f7fa fa15 	bl	902 <Port_schm_read_msr>
    64d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    64da:	9b00      	ldr	r3, [sp, #0]
    64dc:	f003 0301 	and.w	r3, r3, #1
    64e0:	2b00      	cmp	r3, #0
    64e2:	d100      	bne.n	64e6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    64e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    64e6:	490a      	ldr	r1, [pc, #40]	; (6510 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    64e8:	9b01      	ldr	r3, [sp, #4]
    64ea:	9a00      	ldr	r2, [sp, #0]
    64ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    64f0:	4a06      	ldr	r2, [pc, #24]	; (650c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    64f2:	9b01      	ldr	r3, [sp, #4]
    64f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64f8:	1c5a      	adds	r2, r3, #1
    64fa:	4904      	ldr	r1, [pc, #16]	; (650c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    64fc:	9b01      	ldr	r3, [sp, #4]
    64fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6502:	bf00      	nop
    6504:	b003      	add	sp, #12
    6506:	f85d fb04 	ldr.w	pc, [sp], #4
    650a:	bf00      	nop
    650c:	1fff8d84 	.word	0x1fff8d84
    6510:	1fff8d80 	.word	0x1fff8d80

00006514 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    6514:	b500      	push	{lr}
    6516:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6518:	f7fa fac2 	bl	aa0 <Sys_GetCoreID>
    651c:	4603      	mov	r3, r0
    651e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    6520:	4a0d      	ldr	r2, [pc, #52]	; (6558 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    6522:	9b01      	ldr	r3, [sp, #4]
    6524:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6528:	1e5a      	subs	r2, r3, #1
    652a:	490b      	ldr	r1, [pc, #44]	; (6558 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    652c:	9b01      	ldr	r3, [sp, #4]
    652e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    6532:	4a0a      	ldr	r2, [pc, #40]	; (655c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    6534:	9b01      	ldr	r3, [sp, #4]
    6536:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    653a:	f003 0301 	and.w	r3, r3, #1
    653e:	2b00      	cmp	r3, #0
    6540:	d106      	bne.n	6550 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    6542:	4a05      	ldr	r2, [pc, #20]	; (6558 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    6544:	9b01      	ldr	r3, [sp, #4]
    6546:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    654a:	2b00      	cmp	r3, #0
    654c:	d100      	bne.n	6550 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    654e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6550:	bf00      	nop
    6552:	b003      	add	sp, #12
    6554:	f85d fb04 	ldr.w	pc, [sp], #4
    6558:	1fff8d84 	.word	0x1fff8d84
    655c:	1fff8d80 	.word	0x1fff8d80

00006560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    6560:	b500      	push	{lr}
    6562:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6564:	f7fa fa9c 	bl	aa0 <Sys_GetCoreID>
    6568:	4603      	mov	r3, r0
    656a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    656c:	4a10      	ldr	r2, [pc, #64]	; (65b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    656e:	9b01      	ldr	r3, [sp, #4]
    6570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6574:	2b00      	cmp	r3, #0
    6576:	d10d      	bne.n	6594 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6578:	f7fa f9c3 	bl	902 <Port_schm_read_msr>
    657c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    657e:	9b00      	ldr	r3, [sp, #0]
    6580:	f003 0301 	and.w	r3, r3, #1
    6584:	2b00      	cmp	r3, #0
    6586:	d100      	bne.n	658a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6588:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    658a:	490a      	ldr	r1, [pc, #40]	; (65b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    658c:	9b01      	ldr	r3, [sp, #4]
    658e:	9a00      	ldr	r2, [sp, #0]
    6590:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    6594:	4a06      	ldr	r2, [pc, #24]	; (65b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    6596:	9b01      	ldr	r3, [sp, #4]
    6598:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    659c:	1c5a      	adds	r2, r3, #1
    659e:	4904      	ldr	r1, [pc, #16]	; (65b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    65a0:	9b01      	ldr	r3, [sp, #4]
    65a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    65a6:	bf00      	nop
    65a8:	b003      	add	sp, #12
    65aa:	f85d fb04 	ldr.w	pc, [sp], #4
    65ae:	bf00      	nop
    65b0:	1fff8d8c 	.word	0x1fff8d8c
    65b4:	1fff8d88 	.word	0x1fff8d88

000065b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    65b8:	b500      	push	{lr}
    65ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    65bc:	f7fa fa70 	bl	aa0 <Sys_GetCoreID>
    65c0:	4603      	mov	r3, r0
    65c2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    65c4:	4a0d      	ldr	r2, [pc, #52]	; (65fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    65c6:	9b01      	ldr	r3, [sp, #4]
    65c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    65cc:	1e5a      	subs	r2, r3, #1
    65ce:	490b      	ldr	r1, [pc, #44]	; (65fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    65d0:	9b01      	ldr	r3, [sp, #4]
    65d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    65d6:	4a0a      	ldr	r2, [pc, #40]	; (6600 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    65d8:	9b01      	ldr	r3, [sp, #4]
    65da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    65de:	f003 0301 	and.w	r3, r3, #1
    65e2:	2b00      	cmp	r3, #0
    65e4:	d106      	bne.n	65f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    65e6:	4a05      	ldr	r2, [pc, #20]	; (65fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    65e8:	9b01      	ldr	r3, [sp, #4]
    65ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    65ee:	2b00      	cmp	r3, #0
    65f0:	d100      	bne.n	65f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    65f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    65f4:	bf00      	nop
    65f6:	b003      	add	sp, #12
    65f8:	f85d fb04 	ldr.w	pc, [sp], #4
    65fc:	1fff8d8c 	.word	0x1fff8d8c
    6600:	1fff8d88 	.word	0x1fff8d88

00006604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    6604:	b500      	push	{lr}
    6606:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6608:	f7fa fa4a 	bl	aa0 <Sys_GetCoreID>
    660c:	4603      	mov	r3, r0
    660e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    6610:	4a10      	ldr	r2, [pc, #64]	; (6654 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    6612:	9b01      	ldr	r3, [sp, #4]
    6614:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6618:	2b00      	cmp	r3, #0
    661a:	d10d      	bne.n	6638 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    661c:	f7fa f971 	bl	902 <Port_schm_read_msr>
    6620:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6622:	9b00      	ldr	r3, [sp, #0]
    6624:	f003 0301 	and.w	r3, r3, #1
    6628:	2b00      	cmp	r3, #0
    662a:	d100      	bne.n	662e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    662c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    662e:	490a      	ldr	r1, [pc, #40]	; (6658 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    6630:	9b01      	ldr	r3, [sp, #4]
    6632:	9a00      	ldr	r2, [sp, #0]
    6634:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    6638:	4a06      	ldr	r2, [pc, #24]	; (6654 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    663a:	9b01      	ldr	r3, [sp, #4]
    663c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6640:	1c5a      	adds	r2, r3, #1
    6642:	4904      	ldr	r1, [pc, #16]	; (6654 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    6644:	9b01      	ldr	r3, [sp, #4]
    6646:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    664a:	bf00      	nop
    664c:	b003      	add	sp, #12
    664e:	f85d fb04 	ldr.w	pc, [sp], #4
    6652:	bf00      	nop
    6654:	1fff8d94 	.word	0x1fff8d94
    6658:	1fff8d90 	.word	0x1fff8d90

0000665c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    665c:	b500      	push	{lr}
    665e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6660:	f7fa fa1e 	bl	aa0 <Sys_GetCoreID>
    6664:	4603      	mov	r3, r0
    6666:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    6668:	4a0d      	ldr	r2, [pc, #52]	; (66a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    666a:	9b01      	ldr	r3, [sp, #4]
    666c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6670:	1e5a      	subs	r2, r3, #1
    6672:	490b      	ldr	r1, [pc, #44]	; (66a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    6674:	9b01      	ldr	r3, [sp, #4]
    6676:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    667a:	4a0a      	ldr	r2, [pc, #40]	; (66a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    667c:	9b01      	ldr	r3, [sp, #4]
    667e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6682:	f003 0301 	and.w	r3, r3, #1
    6686:	2b00      	cmp	r3, #0
    6688:	d106      	bne.n	6698 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    668a:	4a05      	ldr	r2, [pc, #20]	; (66a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    668c:	9b01      	ldr	r3, [sp, #4]
    668e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6692:	2b00      	cmp	r3, #0
    6694:	d100      	bne.n	6698 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6696:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6698:	bf00      	nop
    669a:	b003      	add	sp, #12
    669c:	f85d fb04 	ldr.w	pc, [sp], #4
    66a0:	1fff8d94 	.word	0x1fff8d94
    66a4:	1fff8d90 	.word	0x1fff8d90

000066a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    66a8:	b500      	push	{lr}
    66aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    66ac:	f7fa f9f8 	bl	aa0 <Sys_GetCoreID>
    66b0:	4603      	mov	r3, r0
    66b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    66b4:	4a10      	ldr	r2, [pc, #64]	; (66f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    66b6:	9b01      	ldr	r3, [sp, #4]
    66b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66bc:	2b00      	cmp	r3, #0
    66be:	d10d      	bne.n	66dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    66c0:	f7fa f91f 	bl	902 <Port_schm_read_msr>
    66c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    66c6:	9b00      	ldr	r3, [sp, #0]
    66c8:	f003 0301 	and.w	r3, r3, #1
    66cc:	2b00      	cmp	r3, #0
    66ce:	d100      	bne.n	66d2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    66d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    66d2:	490a      	ldr	r1, [pc, #40]	; (66fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    66d4:	9b01      	ldr	r3, [sp, #4]
    66d6:	9a00      	ldr	r2, [sp, #0]
    66d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    66dc:	4a06      	ldr	r2, [pc, #24]	; (66f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    66de:	9b01      	ldr	r3, [sp, #4]
    66e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66e4:	1c5a      	adds	r2, r3, #1
    66e6:	4904      	ldr	r1, [pc, #16]	; (66f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    66e8:	9b01      	ldr	r3, [sp, #4]
    66ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    66ee:	bf00      	nop
    66f0:	b003      	add	sp, #12
    66f2:	f85d fb04 	ldr.w	pc, [sp], #4
    66f6:	bf00      	nop
    66f8:	1fff8d9c 	.word	0x1fff8d9c
    66fc:	1fff8d98 	.word	0x1fff8d98

00006700 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    6700:	b500      	push	{lr}
    6702:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6704:	f7fa f9cc 	bl	aa0 <Sys_GetCoreID>
    6708:	4603      	mov	r3, r0
    670a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    670c:	4a0d      	ldr	r2, [pc, #52]	; (6744 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    670e:	9b01      	ldr	r3, [sp, #4]
    6710:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6714:	1e5a      	subs	r2, r3, #1
    6716:	490b      	ldr	r1, [pc, #44]	; (6744 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    6718:	9b01      	ldr	r3, [sp, #4]
    671a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    671e:	4a0a      	ldr	r2, [pc, #40]	; (6748 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    6720:	9b01      	ldr	r3, [sp, #4]
    6722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6726:	f003 0301 	and.w	r3, r3, #1
    672a:	2b00      	cmp	r3, #0
    672c:	d106      	bne.n	673c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    672e:	4a05      	ldr	r2, [pc, #20]	; (6744 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    6730:	9b01      	ldr	r3, [sp, #4]
    6732:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6736:	2b00      	cmp	r3, #0
    6738:	d100      	bne.n	673c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    673a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    673c:	bf00      	nop
    673e:	b003      	add	sp, #12
    6740:	f85d fb04 	ldr.w	pc, [sp], #4
    6744:	1fff8d9c 	.word	0x1fff8d9c
    6748:	1fff8d98 	.word	0x1fff8d98

0000674c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    674c:	b500      	push	{lr}
    674e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6750:	f7fa f9a6 	bl	aa0 <Sys_GetCoreID>
    6754:	4603      	mov	r3, r0
    6756:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    6758:	4a10      	ldr	r2, [pc, #64]	; (679c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    675a:	9b01      	ldr	r3, [sp, #4]
    675c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6760:	2b00      	cmp	r3, #0
    6762:	d10d      	bne.n	6780 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6764:	f7fa f8cd 	bl	902 <Port_schm_read_msr>
    6768:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    676a:	9b00      	ldr	r3, [sp, #0]
    676c:	f003 0301 	and.w	r3, r3, #1
    6770:	2b00      	cmp	r3, #0
    6772:	d100      	bne.n	6776 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6774:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    6776:	490a      	ldr	r1, [pc, #40]	; (67a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    6778:	9b01      	ldr	r3, [sp, #4]
    677a:	9a00      	ldr	r2, [sp, #0]
    677c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    6780:	4a06      	ldr	r2, [pc, #24]	; (679c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    6782:	9b01      	ldr	r3, [sp, #4]
    6784:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6788:	1c5a      	adds	r2, r3, #1
    678a:	4904      	ldr	r1, [pc, #16]	; (679c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    678c:	9b01      	ldr	r3, [sp, #4]
    678e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6792:	bf00      	nop
    6794:	b003      	add	sp, #12
    6796:	f85d fb04 	ldr.w	pc, [sp], #4
    679a:	bf00      	nop
    679c:	1fff8da4 	.word	0x1fff8da4
    67a0:	1fff8da0 	.word	0x1fff8da0

000067a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    67a4:	b500      	push	{lr}
    67a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    67a8:	f7fa f97a 	bl	aa0 <Sys_GetCoreID>
    67ac:	4603      	mov	r3, r0
    67ae:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    67b0:	4a0d      	ldr	r2, [pc, #52]	; (67e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    67b2:	9b01      	ldr	r3, [sp, #4]
    67b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67b8:	1e5a      	subs	r2, r3, #1
    67ba:	490b      	ldr	r1, [pc, #44]	; (67e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    67bc:	9b01      	ldr	r3, [sp, #4]
    67be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    67c2:	4a0a      	ldr	r2, [pc, #40]	; (67ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    67c4:	9b01      	ldr	r3, [sp, #4]
    67c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67ca:	f003 0301 	and.w	r3, r3, #1
    67ce:	2b00      	cmp	r3, #0
    67d0:	d106      	bne.n	67e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    67d2:	4a05      	ldr	r2, [pc, #20]	; (67e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    67d4:	9b01      	ldr	r3, [sp, #4]
    67d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67da:	2b00      	cmp	r3, #0
    67dc:	d100      	bne.n	67e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    67de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    67e0:	bf00      	nop
    67e2:	b003      	add	sp, #12
    67e4:	f85d fb04 	ldr.w	pc, [sp], #4
    67e8:	1fff8da4 	.word	0x1fff8da4
    67ec:	1fff8da0 	.word	0x1fff8da0

000067f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    67f0:	b500      	push	{lr}
    67f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    67f4:	f7fa f954 	bl	aa0 <Sys_GetCoreID>
    67f8:	4603      	mov	r3, r0
    67fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    67fc:	4a10      	ldr	r2, [pc, #64]	; (6840 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    67fe:	9b01      	ldr	r3, [sp, #4]
    6800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6804:	2b00      	cmp	r3, #0
    6806:	d10d      	bne.n	6824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6808:	f7fa f87b 	bl	902 <Port_schm_read_msr>
    680c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    680e:	9b00      	ldr	r3, [sp, #0]
    6810:	f003 0301 	and.w	r3, r3, #1
    6814:	2b00      	cmp	r3, #0
    6816:	d100      	bne.n	681a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6818:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    681a:	490a      	ldr	r1, [pc, #40]	; (6844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    681c:	9b01      	ldr	r3, [sp, #4]
    681e:	9a00      	ldr	r2, [sp, #0]
    6820:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    6824:	4a06      	ldr	r2, [pc, #24]	; (6840 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    6826:	9b01      	ldr	r3, [sp, #4]
    6828:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    682c:	1c5a      	adds	r2, r3, #1
    682e:	4904      	ldr	r1, [pc, #16]	; (6840 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    6830:	9b01      	ldr	r3, [sp, #4]
    6832:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6836:	bf00      	nop
    6838:	b003      	add	sp, #12
    683a:	f85d fb04 	ldr.w	pc, [sp], #4
    683e:	bf00      	nop
    6840:	1fff8dac 	.word	0x1fff8dac
    6844:	1fff8da8 	.word	0x1fff8da8

00006848 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    6848:	b500      	push	{lr}
    684a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    684c:	f7fa f928 	bl	aa0 <Sys_GetCoreID>
    6850:	4603      	mov	r3, r0
    6852:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    6854:	4a0d      	ldr	r2, [pc, #52]	; (688c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    6856:	9b01      	ldr	r3, [sp, #4]
    6858:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    685c:	1e5a      	subs	r2, r3, #1
    685e:	490b      	ldr	r1, [pc, #44]	; (688c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    6860:	9b01      	ldr	r3, [sp, #4]
    6862:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    6866:	4a0a      	ldr	r2, [pc, #40]	; (6890 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    6868:	9b01      	ldr	r3, [sp, #4]
    686a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    686e:	f003 0301 	and.w	r3, r3, #1
    6872:	2b00      	cmp	r3, #0
    6874:	d106      	bne.n	6884 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    6876:	4a05      	ldr	r2, [pc, #20]	; (688c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    6878:	9b01      	ldr	r3, [sp, #4]
    687a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    687e:	2b00      	cmp	r3, #0
    6880:	d100      	bne.n	6884 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6882:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6884:	bf00      	nop
    6886:	b003      	add	sp, #12
    6888:	f85d fb04 	ldr.w	pc, [sp], #4
    688c:	1fff8dac 	.word	0x1fff8dac
    6890:	1fff8da8 	.word	0x1fff8da8

00006894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    6894:	b500      	push	{lr}
    6896:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6898:	f7fa f902 	bl	aa0 <Sys_GetCoreID>
    689c:	4603      	mov	r3, r0
    689e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    68a0:	4a10      	ldr	r2, [pc, #64]	; (68e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    68a2:	9b01      	ldr	r3, [sp, #4]
    68a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    68a8:	2b00      	cmp	r3, #0
    68aa:	d10d      	bne.n	68c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    68ac:	f7fa f829 	bl	902 <Port_schm_read_msr>
    68b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    68b2:	9b00      	ldr	r3, [sp, #0]
    68b4:	f003 0301 	and.w	r3, r3, #1
    68b8:	2b00      	cmp	r3, #0
    68ba:	d100      	bne.n	68be <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    68bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    68be:	490a      	ldr	r1, [pc, #40]	; (68e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    68c0:	9b01      	ldr	r3, [sp, #4]
    68c2:	9a00      	ldr	r2, [sp, #0]
    68c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    68c8:	4a06      	ldr	r2, [pc, #24]	; (68e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    68ca:	9b01      	ldr	r3, [sp, #4]
    68cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    68d0:	1c5a      	adds	r2, r3, #1
    68d2:	4904      	ldr	r1, [pc, #16]	; (68e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    68d4:	9b01      	ldr	r3, [sp, #4]
    68d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    68da:	bf00      	nop
    68dc:	b003      	add	sp, #12
    68de:	f85d fb04 	ldr.w	pc, [sp], #4
    68e2:	bf00      	nop
    68e4:	1fff8db4 	.word	0x1fff8db4
    68e8:	1fff8db0 	.word	0x1fff8db0

000068ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    68ec:	b500      	push	{lr}
    68ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    68f0:	f7fa f8d6 	bl	aa0 <Sys_GetCoreID>
    68f4:	4603      	mov	r3, r0
    68f6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    68f8:	4a0d      	ldr	r2, [pc, #52]	; (6930 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    68fa:	9b01      	ldr	r3, [sp, #4]
    68fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6900:	1e5a      	subs	r2, r3, #1
    6902:	490b      	ldr	r1, [pc, #44]	; (6930 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    6904:	9b01      	ldr	r3, [sp, #4]
    6906:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    690a:	4a0a      	ldr	r2, [pc, #40]	; (6934 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    690c:	9b01      	ldr	r3, [sp, #4]
    690e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6912:	f003 0301 	and.w	r3, r3, #1
    6916:	2b00      	cmp	r3, #0
    6918:	d106      	bne.n	6928 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    691a:	4a05      	ldr	r2, [pc, #20]	; (6930 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    691c:	9b01      	ldr	r3, [sp, #4]
    691e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6922:	2b00      	cmp	r3, #0
    6924:	d100      	bne.n	6928 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6926:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6928:	bf00      	nop
    692a:	b003      	add	sp, #12
    692c:	f85d fb04 	ldr.w	pc, [sp], #4
    6930:	1fff8db4 	.word	0x1fff8db4
    6934:	1fff8db0 	.word	0x1fff8db0

00006938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    6938:	b500      	push	{lr}
    693a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    693c:	f7fa f8b0 	bl	aa0 <Sys_GetCoreID>
    6940:	4603      	mov	r3, r0
    6942:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    6944:	4a10      	ldr	r2, [pc, #64]	; (6988 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    6946:	9b01      	ldr	r3, [sp, #4]
    6948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    694c:	2b00      	cmp	r3, #0
    694e:	d10d      	bne.n	696c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6950:	f7f9 ffd7 	bl	902 <Port_schm_read_msr>
    6954:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6956:	9b00      	ldr	r3, [sp, #0]
    6958:	f003 0301 	and.w	r3, r3, #1
    695c:	2b00      	cmp	r3, #0
    695e:	d100      	bne.n	6962 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6960:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    6962:	490a      	ldr	r1, [pc, #40]	; (698c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    6964:	9b01      	ldr	r3, [sp, #4]
    6966:	9a00      	ldr	r2, [sp, #0]
    6968:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    696c:	4a06      	ldr	r2, [pc, #24]	; (6988 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    696e:	9b01      	ldr	r3, [sp, #4]
    6970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6974:	1c5a      	adds	r2, r3, #1
    6976:	4904      	ldr	r1, [pc, #16]	; (6988 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    6978:	9b01      	ldr	r3, [sp, #4]
    697a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    697e:	bf00      	nop
    6980:	b003      	add	sp, #12
    6982:	f85d fb04 	ldr.w	pc, [sp], #4
    6986:	bf00      	nop
    6988:	1fff8dbc 	.word	0x1fff8dbc
    698c:	1fff8db8 	.word	0x1fff8db8

00006990 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    6990:	b500      	push	{lr}
    6992:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6994:	f7fa f884 	bl	aa0 <Sys_GetCoreID>
    6998:	4603      	mov	r3, r0
    699a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    699c:	4a0d      	ldr	r2, [pc, #52]	; (69d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    699e:	9b01      	ldr	r3, [sp, #4]
    69a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69a4:	1e5a      	subs	r2, r3, #1
    69a6:	490b      	ldr	r1, [pc, #44]	; (69d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    69a8:	9b01      	ldr	r3, [sp, #4]
    69aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    69ae:	4a0a      	ldr	r2, [pc, #40]	; (69d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    69b0:	9b01      	ldr	r3, [sp, #4]
    69b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69b6:	f003 0301 	and.w	r3, r3, #1
    69ba:	2b00      	cmp	r3, #0
    69bc:	d106      	bne.n	69cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    69be:	4a05      	ldr	r2, [pc, #20]	; (69d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    69c0:	9b01      	ldr	r3, [sp, #4]
    69c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69c6:	2b00      	cmp	r3, #0
    69c8:	d100      	bne.n	69cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    69ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    69cc:	bf00      	nop
    69ce:	b003      	add	sp, #12
    69d0:	f85d fb04 	ldr.w	pc, [sp], #4
    69d4:	1fff8dbc 	.word	0x1fff8dbc
    69d8:	1fff8db8 	.word	0x1fff8db8

000069dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    69dc:	b500      	push	{lr}
    69de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    69e0:	f7fa f85e 	bl	aa0 <Sys_GetCoreID>
    69e4:	4603      	mov	r3, r0
    69e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    69e8:	4a10      	ldr	r2, [pc, #64]	; (6a2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    69ea:	9b01      	ldr	r3, [sp, #4]
    69ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    69f0:	2b00      	cmp	r3, #0
    69f2:	d10d      	bne.n	6a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    69f4:	f7f9 ff85 	bl	902 <Port_schm_read_msr>
    69f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    69fa:	9b00      	ldr	r3, [sp, #0]
    69fc:	f003 0301 	and.w	r3, r3, #1
    6a00:	2b00      	cmp	r3, #0
    6a02:	d100      	bne.n	6a06 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6a04:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    6a06:	490a      	ldr	r1, [pc, #40]	; (6a30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    6a08:	9b01      	ldr	r3, [sp, #4]
    6a0a:	9a00      	ldr	r2, [sp, #0]
    6a0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    6a10:	4a06      	ldr	r2, [pc, #24]	; (6a2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    6a12:	9b01      	ldr	r3, [sp, #4]
    6a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a18:	1c5a      	adds	r2, r3, #1
    6a1a:	4904      	ldr	r1, [pc, #16]	; (6a2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    6a1c:	9b01      	ldr	r3, [sp, #4]
    6a1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6a22:	bf00      	nop
    6a24:	b003      	add	sp, #12
    6a26:	f85d fb04 	ldr.w	pc, [sp], #4
    6a2a:	bf00      	nop
    6a2c:	1fff8dc4 	.word	0x1fff8dc4
    6a30:	1fff8dc0 	.word	0x1fff8dc0

00006a34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    6a34:	b500      	push	{lr}
    6a36:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6a38:	f7fa f832 	bl	aa0 <Sys_GetCoreID>
    6a3c:	4603      	mov	r3, r0
    6a3e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    6a40:	4a0d      	ldr	r2, [pc, #52]	; (6a78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    6a42:	9b01      	ldr	r3, [sp, #4]
    6a44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a48:	1e5a      	subs	r2, r3, #1
    6a4a:	490b      	ldr	r1, [pc, #44]	; (6a78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    6a4c:	9b01      	ldr	r3, [sp, #4]
    6a4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    6a52:	4a0a      	ldr	r2, [pc, #40]	; (6a7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    6a54:	9b01      	ldr	r3, [sp, #4]
    6a56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a5a:	f003 0301 	and.w	r3, r3, #1
    6a5e:	2b00      	cmp	r3, #0
    6a60:	d106      	bne.n	6a70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    6a62:	4a05      	ldr	r2, [pc, #20]	; (6a78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    6a64:	9b01      	ldr	r3, [sp, #4]
    6a66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a6a:	2b00      	cmp	r3, #0
    6a6c:	d100      	bne.n	6a70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6a6e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6a70:	bf00      	nop
    6a72:	b003      	add	sp, #12
    6a74:	f85d fb04 	ldr.w	pc, [sp], #4
    6a78:	1fff8dc4 	.word	0x1fff8dc4
    6a7c:	1fff8dc0 	.word	0x1fff8dc0

00006a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    6a80:	b500      	push	{lr}
    6a82:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6a84:	f7fa f80c 	bl	aa0 <Sys_GetCoreID>
    6a88:	4603      	mov	r3, r0
    6a8a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    6a8c:	4a10      	ldr	r2, [pc, #64]	; (6ad0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    6a8e:	9b01      	ldr	r3, [sp, #4]
    6a90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6a94:	2b00      	cmp	r3, #0
    6a96:	d10d      	bne.n	6ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6a98:	f7f9 ff33 	bl	902 <Port_schm_read_msr>
    6a9c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6a9e:	9b00      	ldr	r3, [sp, #0]
    6aa0:	f003 0301 	and.w	r3, r3, #1
    6aa4:	2b00      	cmp	r3, #0
    6aa6:	d100      	bne.n	6aaa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6aa8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    6aaa:	490a      	ldr	r1, [pc, #40]	; (6ad4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    6aac:	9b01      	ldr	r3, [sp, #4]
    6aae:	9a00      	ldr	r2, [sp, #0]
    6ab0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    6ab4:	4a06      	ldr	r2, [pc, #24]	; (6ad0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    6ab6:	9b01      	ldr	r3, [sp, #4]
    6ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6abc:	1c5a      	adds	r2, r3, #1
    6abe:	4904      	ldr	r1, [pc, #16]	; (6ad0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    6ac0:	9b01      	ldr	r3, [sp, #4]
    6ac2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6ac6:	bf00      	nop
    6ac8:	b003      	add	sp, #12
    6aca:	f85d fb04 	ldr.w	pc, [sp], #4
    6ace:	bf00      	nop
    6ad0:	1fff8dcc 	.word	0x1fff8dcc
    6ad4:	1fff8dc8 	.word	0x1fff8dc8

00006ad8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    6ad8:	b500      	push	{lr}
    6ada:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6adc:	f7f9 ffe0 	bl	aa0 <Sys_GetCoreID>
    6ae0:	4603      	mov	r3, r0
    6ae2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    6ae4:	4a0d      	ldr	r2, [pc, #52]	; (6b1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    6ae6:	9b01      	ldr	r3, [sp, #4]
    6ae8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6aec:	1e5a      	subs	r2, r3, #1
    6aee:	490b      	ldr	r1, [pc, #44]	; (6b1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    6af0:	9b01      	ldr	r3, [sp, #4]
    6af2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    6af6:	4a0a      	ldr	r2, [pc, #40]	; (6b20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    6af8:	9b01      	ldr	r3, [sp, #4]
    6afa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6afe:	f003 0301 	and.w	r3, r3, #1
    6b02:	2b00      	cmp	r3, #0
    6b04:	d106      	bne.n	6b14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    6b06:	4a05      	ldr	r2, [pc, #20]	; (6b1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    6b08:	9b01      	ldr	r3, [sp, #4]
    6b0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b0e:	2b00      	cmp	r3, #0
    6b10:	d100      	bne.n	6b14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6b12:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6b14:	bf00      	nop
    6b16:	b003      	add	sp, #12
    6b18:	f85d fb04 	ldr.w	pc, [sp], #4
    6b1c:	1fff8dcc 	.word	0x1fff8dcc
    6b20:	1fff8dc8 	.word	0x1fff8dc8

00006b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    6b24:	b500      	push	{lr}
    6b26:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6b28:	f7f9 ffba 	bl	aa0 <Sys_GetCoreID>
    6b2c:	4603      	mov	r3, r0
    6b2e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    6b30:	4a10      	ldr	r2, [pc, #64]	; (6b74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    6b32:	9b01      	ldr	r3, [sp, #4]
    6b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b38:	2b00      	cmp	r3, #0
    6b3a:	d10d      	bne.n	6b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6b3c:	f7f9 fee1 	bl	902 <Port_schm_read_msr>
    6b40:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6b42:	9b00      	ldr	r3, [sp, #0]
    6b44:	f003 0301 	and.w	r3, r3, #1
    6b48:	2b00      	cmp	r3, #0
    6b4a:	d100      	bne.n	6b4e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6b4c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    6b4e:	490a      	ldr	r1, [pc, #40]	; (6b78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    6b50:	9b01      	ldr	r3, [sp, #4]
    6b52:	9a00      	ldr	r2, [sp, #0]
    6b54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    6b58:	4a06      	ldr	r2, [pc, #24]	; (6b74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    6b5a:	9b01      	ldr	r3, [sp, #4]
    6b5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b60:	1c5a      	adds	r2, r3, #1
    6b62:	4904      	ldr	r1, [pc, #16]	; (6b74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    6b64:	9b01      	ldr	r3, [sp, #4]
    6b66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6b6a:	bf00      	nop
    6b6c:	b003      	add	sp, #12
    6b6e:	f85d fb04 	ldr.w	pc, [sp], #4
    6b72:	bf00      	nop
    6b74:	1fff8dd4 	.word	0x1fff8dd4
    6b78:	1fff8dd0 	.word	0x1fff8dd0

00006b7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    6b7c:	b500      	push	{lr}
    6b7e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6b80:	f7f9 ff8e 	bl	aa0 <Sys_GetCoreID>
    6b84:	4603      	mov	r3, r0
    6b86:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    6b88:	4a0d      	ldr	r2, [pc, #52]	; (6bc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    6b8a:	9b01      	ldr	r3, [sp, #4]
    6b8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b90:	1e5a      	subs	r2, r3, #1
    6b92:	490b      	ldr	r1, [pc, #44]	; (6bc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    6b94:	9b01      	ldr	r3, [sp, #4]
    6b96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    6b9a:	4a0a      	ldr	r2, [pc, #40]	; (6bc4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    6b9c:	9b01      	ldr	r3, [sp, #4]
    6b9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ba2:	f003 0301 	and.w	r3, r3, #1
    6ba6:	2b00      	cmp	r3, #0
    6ba8:	d106      	bne.n	6bb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    6baa:	4a05      	ldr	r2, [pc, #20]	; (6bc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    6bac:	9b01      	ldr	r3, [sp, #4]
    6bae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6bb2:	2b00      	cmp	r3, #0
    6bb4:	d100      	bne.n	6bb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6bb6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6bb8:	bf00      	nop
    6bba:	b003      	add	sp, #12
    6bbc:	f85d fb04 	ldr.w	pc, [sp], #4
    6bc0:	1fff8dd4 	.word	0x1fff8dd4
    6bc4:	1fff8dd0 	.word	0x1fff8dd0

00006bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    6bc8:	b500      	push	{lr}
    6bca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6bcc:	f7f9 ff68 	bl	aa0 <Sys_GetCoreID>
    6bd0:	4603      	mov	r3, r0
    6bd2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    6bd4:	4a10      	ldr	r2, [pc, #64]	; (6c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    6bd6:	9b01      	ldr	r3, [sp, #4]
    6bd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6bdc:	2b00      	cmp	r3, #0
    6bde:	d10d      	bne.n	6bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6be0:	f7f9 fe8f 	bl	902 <Port_schm_read_msr>
    6be4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6be6:	9b00      	ldr	r3, [sp, #0]
    6be8:	f003 0301 	and.w	r3, r3, #1
    6bec:	2b00      	cmp	r3, #0
    6bee:	d100      	bne.n	6bf2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6bf0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    6bf2:	490a      	ldr	r1, [pc, #40]	; (6c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    6bf4:	9b01      	ldr	r3, [sp, #4]
    6bf6:	9a00      	ldr	r2, [sp, #0]
    6bf8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    6bfc:	4a06      	ldr	r2, [pc, #24]	; (6c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    6bfe:	9b01      	ldr	r3, [sp, #4]
    6c00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c04:	1c5a      	adds	r2, r3, #1
    6c06:	4904      	ldr	r1, [pc, #16]	; (6c18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    6c08:	9b01      	ldr	r3, [sp, #4]
    6c0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6c0e:	bf00      	nop
    6c10:	b003      	add	sp, #12
    6c12:	f85d fb04 	ldr.w	pc, [sp], #4
    6c16:	bf00      	nop
    6c18:	1fff8ddc 	.word	0x1fff8ddc
    6c1c:	1fff8dd8 	.word	0x1fff8dd8

00006c20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    6c20:	b500      	push	{lr}
    6c22:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6c24:	f7f9 ff3c 	bl	aa0 <Sys_GetCoreID>
    6c28:	4603      	mov	r3, r0
    6c2a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    6c2c:	4a0d      	ldr	r2, [pc, #52]	; (6c64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    6c2e:	9b01      	ldr	r3, [sp, #4]
    6c30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c34:	1e5a      	subs	r2, r3, #1
    6c36:	490b      	ldr	r1, [pc, #44]	; (6c64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    6c38:	9b01      	ldr	r3, [sp, #4]
    6c3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    6c3e:	4a0a      	ldr	r2, [pc, #40]	; (6c68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    6c40:	9b01      	ldr	r3, [sp, #4]
    6c42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c46:	f003 0301 	and.w	r3, r3, #1
    6c4a:	2b00      	cmp	r3, #0
    6c4c:	d106      	bne.n	6c5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    6c4e:	4a05      	ldr	r2, [pc, #20]	; (6c64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    6c50:	9b01      	ldr	r3, [sp, #4]
    6c52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c56:	2b00      	cmp	r3, #0
    6c58:	d100      	bne.n	6c5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6c5a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6c5c:	bf00      	nop
    6c5e:	b003      	add	sp, #12
    6c60:	f85d fb04 	ldr.w	pc, [sp], #4
    6c64:	1fff8ddc 	.word	0x1fff8ddc
    6c68:	1fff8dd8 	.word	0x1fff8dd8

00006c6c <Clock_Ip_au8DividerCallbackIndex>:
    6c6c:	0e0d0c00 06030201 0a070409 000b0805     ................

00006c7c <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

00006c8c <Clock_Ip_au8XoscCallbackIndex>:
    6c8c:	00000100 00000000 00000000 00000000     ................

00006c9c <Clock_Ip_au8IrcoscCallbackIndex>:
    6c9c:	03020100 00000004 00000000 00000000     ................

00006cac <Clock_Ip_au8GateCallbackIndex>:
    6cac:	06010200 01040301 00000500 00000000     ................

00006cbc <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

00006ccc <Clock_Ip_au8PllCallbackIndex>:
    6ccc:	00000100 00000000 00000000 00000000     ................

00006cdc <Clock_Ip_au8SelectorCallbackIndex>:
    6cdc:	0a090800 03020109 07060504 00000000     ................

00006cec <Clock_Ip_au8PcfsCallbackIndex>:
	...

00006cfc <Clock_Ip_au8CmuCallbackIndex>:
	...

00006d0c <Clock_Ip_au8ClockFeatures>:
	...
    6d1c:	01000000 00000000 00000000 00000002     ................
    6d2c:	00000000 00000300 00000000 00040000     ................
    6d3c:	00000000 05000000 00000000 00000000     ................
    6d4c:	00000006 00000000 00000100 00000000     ................
    6d5c:	00010000 00000000 04000000 00000000     ................
    6d6c:	00000000 00000005 00000001 00000401     ................
    6d7c:	00000200 00050100 00030000 04020000     ................
    6d8c:	04000000 02000000 00000005 00000005     ................
    6d9c:	00000403 00000600 00050300 00070000     ................
    6dac:	05000000 00000000 00000000 00000006     ................
	...
    6dec:	00050000 00000000 06000000 00000100     ................
    6dfc:	00000000 00030007 00000000 00000000     ................
    6e0c:	00000000 00060000 00000000 07000000     ................
    6e1c:	00000100 00000000 00030008 00000000     ................
	...
    6e34:	00090000 00000000 0a000000 00000100     ................
    6e44:	00000000 0003000b 00000000 00000000     ................
    6e54:	00000000 000c0000 00000000 0d000000     ................
    6e64:	00000100 00000000 0003000e 00000000     ................
    6e74:	00000800 00000000 00090000 00000000     ................
    6e84:	0a000000 00000000 00000000 0000000b     ................
    6e94:	00000000 00000b01 00000000 000b0200     ................
    6ea4:	00000000 0b030000 00000000 00000000     ................
	...
    6ebc:	00000400 003b003b 00040000 27002700     ....;.;......'.'
    6ecc:	01000000 00000000 00000000 00000007     ................
    6edc:	00007300 00000700 00320000 00090000     .s........2.....
    6eec:	02000000 07000000 00000000 00000021     ............!...
    6efc:	00000009 00000400 00000900 00030000     ................
    6f0c:	00070000 61000000 07000000 00000000     .......a........
    6f1c:	00000024 00000007 00002500 00000700     $........%......
    6f2c:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
    6f3c:	00000000 00000020 38000004 00003800     .... ......8.8..
    6f4c:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
    6f5c:	04000000 00260000 00000026 66000004     ......&.&......f
    6f6c:	00006600 00000400 00370037 00040000     .f......7.7.....
    6f7c:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
    6f8c:	2e000004 00002e00 00000200 00404040     ............@@@.
    6f9c:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
    6fac:	0000006b 6c000004 00006c00 00000900     k......l.l......
    6fbc:	00010000 00090000 00000000 07000000     ................
    6fcc:	00000000 00000036 00000007 00003100     ....6........1..
    6fdc:	00000700 00490000 00070000 4a000000     ......I........J
    6fec:	07000000 00000000 0000004b 00000007     ........K.......
    6ffc:	00004c00 00000700 004d0000 00070000     .L........M.....
    700c:	3d000000 03000000 00000000 00000000     ...=............

0000701c <Clock_Ip_au16SelectorEntryHardwareValue>:
    701c:	01010a03 01010001 04040002 02000603     ................
    702c:	00010810 02020100 00000000 00000007     ................
    703c:	00000009 00000000 00000c0e 00000000     ................
	...

00007074 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    7074:	00020000 00000300 00000601 00000000     ................
	...

000070a4 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    70a4:	00000700 00000000 02020000 01010303     ................
    70b4:	03020606 00000000 00000000 00000000     ................
	...

000070d4 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    70d4:	00000001 00000000 02020000 01010303     ................
    70e4:	03020606 00000000 00000000 00000000     ................
	...

00007104 <Clock_Ip_au8DividerValueHardwareValue>:
    7104:	00020100 00000003 00000004 00000000     ................
    7114:	00000005 00000000 00000000 00000000     ................
    7124:	00000006 00000000 00000000 00000000     ................
	...
    7144:	00000007                                ....

00007148 <Clock_Ip_apxScgPeriphAsyncDivs>:
    7148:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

00007158 <Clock_Ip_aeSourceTypeClockName>:
    7158:	00000000 00000001 00000001 00000001     ................
    7168:	00000001 00000001 00000001 00000001     ................
    7178:	00000002 00000003 00000001 00000001     ................
    7188:	00000001 00000001 00000002 00000002     ................
    7198:	00000003 00000003 00000001 00000001     ................
    71a8:	00000004 00000004 00000004 00000004     ................
	...

00007214 <Clock_Ip_aeHwPllName>:
    7214:	00000009                                ....

00007218 <Clock_Ip_aeHwDfsName>:
    7218:	00000057                                W...

0000721c <Clock_Ip_axDividerCallbacks>:
    721c:	00001bb5 00001bbf 00001bd9 00001bf3     ................
    722c:	00001c0d 00001c27 00001c41 00001c5b     ....'...A...[...
    723c:	00001c75 00001c8f 00001ca9 00001cc3     u...............
    724c:	00001cdd 00001cf7 00001d11              ............

00007258 <Clock_Ip_axDividerTriggerCallbacks>:
    7258:	00002085 00002085                       . ... ..

00007260 <Clock_Ip_axExtOscCallbacks>:
    7260:	00002091 00002091 00002091 0000209b     . ... ... ... ..
    7270:	00002091 000020a5 000020bf 000020d9     . ... ... ... ..
    7280:	0000215d 00002171                       ]!..q!..

00007288 <Clock_Ip_axFracDivCallbacks>:
    7288:	00002331 00002331 0000233b              1#..1#..;#..

00007294 <Clock_Ip_axGateCallbacks>:
    7294:	00002355 0000235f 0000245f 00002479     U#.._#.._$..y$..
    72a4:	0000240f 00002429 000023bf 000023d9     .$..)$...#...#..
    72b4:	0000236f 00002389 000024af 000024c9     o#...#...$...$..
    72c4:	000024ff 00002519                       .$...%..

000072cc <Clock_Ip_axIntOscCallbacks>:
    72cc:	000026c5 000026c5 000026cf 000026d9     .&...&...&...&..
    72dc:	000026f3 0000270d 00002721 0000273b     .&...'..!'..;'..
    72ec:	00002755 00002769 00002783 0000279d     U'..i'...'...'..
    72fc:	00002845 0000285f 00002879              E(.._(..y(..

00007308 <Clock_Ip_axCmuCallbacks>:
    7308:	00002e15 00002e1f 00002e2b 00002e15     ........+.......

00007318 <Clock_Ip_axPllCallbacks>:
    7318:	00002e35 00002e35 00002e3f 00002e35     5...5...?...5...
    7328:	00002e4b 00002e55 00002e6f 00002e89     K...U...o.......
    7338:	00002f2d 00002f19                       -/.../..

00007340 <Clock_Ip_axPcfsCallbacks>:
    7340:	00003089                                .0..

00007344 <Clock_Ip_axSelectorCallbacks>:
    7344:	00003095 00003095 0000309f 000030b9     .0...0...0...0..
    7354:	00003095 000030d3 000030ed 00003107     .0...0...0...1..
    7364:	00003121 0000313b 00003155 0000316f     !1..;1..U1..o1..
    7374:	00003189 000031a3 000031bd 000031d7     .1...1...1...1..
    7384:	000031f1 0000320b 00003225 0000323f     .1...2..%2..?2..
    7394:	00003259 00003273                       Y2..s2..

0000739c <ClockSource>:
    739c:	00000000 00000008 00000002 00000005     ................
	...
    73b4:	00000009                                ....

000073b8 <ResetReasonArray>:
    73b8:	00000000 00000001 00000002 00000003     ................
    73c8:	00000004 00000005 00000006 00000007     ................
    73d8:	00000008 00000009 0000000a 0000000b     ................
    73e8:	0000000c 0000000d 0000000e              ............

000073f4 <Port_au32PortCiPortBaseAddr>:
    73f4:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
    7404:	4004d000                                ...@

00007408 <Port_au32PortCiGpioBaseAddr>:
    7408:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
    7418:	400ff100                                ...@

0000741c <Mcu_aClockConfigPB>:
	...
    7424:	1c010101 04000012 01000029 00000005     ........).......
    7434:	00000001 00000000 00000057 00000000     ........W.......
    7444:	00000000 00000008 007a1200 00000001     ..........z.....
    7454:	00000001 00000000 00000009 00000001     ................
    7464:	00000008 00000100 00000000 00000028     ............(...
	...
    7484:	00000019 00000009 0000001a 00000002     ................
    7494:	0000001b 00000005 0000002a 00000005     ........*.......
    74a4:	00000028 0000000e 00000029 00000001     (.......).......
    74b4:	00000056 0000001c 00000032 0000002a     V.......2...*...
    74c4:	0000002b 00000014 0000002c 00000014     +.......,.......
    74d4:	0000002d 00000014 0000002e 00000014     -...............
    74e4:	0000003f 00000000 00000040 00000000     ?.......@.......
    74f4:	00000041 00000000 00000042 00000000     A.......B.......
    7504:	00000031 00000000 00000045 00000000     1.......E.......
    7514:	00000046 00000000 00000047 00000000     F.......G.......
    7524:	00000044 00000000 00000030 00000000     D.......0.......
    7534:	0000003d 00000000 00000043 00000000     =.......C.......
    7544:	00000049 00000000 0000004a 00000000     I.......J.......
    7554:	0000004b 00000000 00000048 00000000     K.......H.......
    7564:	0000000c 00000001 00000000 0000000d     ................
    7574:	00000002 00000000 0000000e 00000001     ................
    7584:	00000000 0000000f 00000001 00000000     ................
    7594:	00000010 00000002 00000000 00000011     ................
    75a4:	00000004 00000000 0000001d 00000002     ................
    75b4:	00000000 0000001e 00000008 00000000     ................
    75c4:	0000001f 00000001 00000000 00000021     ............!...
    75d4:	00000002 00000000 00000022 00000002     ........".......
    75e4:	00000000 00000023 00000001 00000000     ....#...........
    75f4:	00000025 00000003 00000000 00000026     %...........&...
    7604:	00000004 00000000 00000027 00000002     ........'.......
    7614:	00000000 00000032 00000001 00000000     ....2...........
    7624:	00000048 00000001 00000001 00000056     H...........V...
    7634:	00000001 00000001 00000057 00000000     ........W.......
    7644:	00000000 00000057 00000000 00000000     ....W...........
    7654:	00000057 00000000 00000057 00000057     W.......W...W...
	...
    7670:	00000014 00007d00 00000015 00007d00     .....}.......}..
    7680:	00000016 00007d00 00000017 00008000     .....}..........
    7690:	00000012 00000001 00000013 00000001     ................
    76a0:	00000030 00000000 00000031 00000000     0.......1.......
    76b0:	00000032 00000000 00000033 00000000     2.......3.......
    76c0:	00000034 00000000 00000035 00000001     4.......5.......
    76d0:	00000036 00000000 00000037 00000001     6.......7.......
    76e0:	00000038 00000001 00000039 00000000     8.......9.......
    76f0:	0000003a 00000000 0000003b 00000000     :.......;.......
    7700:	0000003c 00000000 0000003d 00000000     <.......=.......
    7710:	0000003e 00000000 0000003f 00000000     >.......?.......
    7720:	00000040 00000000 00000041 00000000     @.......A.......
    7730:	00000042 00000000 00000043 00000000     B.......C.......
    7740:	00000044 00000000 00000045 00000000     D.......E.......
    7750:	00000046 00000000 00000047 00000000     F.......G.......
    7760:	00000048 00000000 00000049 00000000     H.......I.......
    7770:	0000004a 00000000 0000004b 00000000     J.......K.......
    7780:	0000004c 00000001 0000004d 00000001     L.......M.......
    7790:	0000004e 00000000 0000004f 00000000     N.......O.......
    77a0:	00000050 00000001 00000051 00000001     P.......Q.......
    77b0:	00000052 00000001 00000053 00000001     R.......S.......
    77c0:	00000054 00000001 00000055 00000000     T.......U.......
    77d0:	00000056 00000001 00000057 00000000     V.......W.......
    77e0:	00000000 00000057 00000000 00000057     ....W.......W...
	...

00007814 <Mcu_Config>:
    7814:	0000005a 00000000 00000001 00000001     Z...............
    7824:	00007968 0000741c 00007974              hy...t..ty..

00007830 <OsIf_xPredefinedConfig>:
    7830:	00000000 04c4b400                       ........

00007838 <OsIf_apxPredefinedConfig>:
    7838:	00007830                                0x..

0000783c <g_pin_mux_InitConfigArr>:
    783c:	4004c000 400ff0c0 00000000 00000002     ...@...@........
    784c:	00000001 00000002 00000000 00000000     ................
	...

00007864 <au8Port_PartitionList>:
    7864:	00000001                                ....

00007868 <au32Port_PinToPartitionMap>:
    7868:	00000001                                ....

0000786c <Port_au16NoUnUsedPadsArrayDefault>:
    786c:	00010000 00030002 00070006 00090008     ................
    787c:	000c000b 000e000d 0010000f 00200011     .............. .
    788c:	00220021 00240023 00260025 00280027     !.".#.$.%.&.'.(.
    789c:	002a0029 002c002b 002e002d 0030002f     ).*.+.,.-.../.0.
    78ac:	00400031 00420041 00460043 00480047     1.@.A.B.C.F.G.H.
    78bc:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
    78cc:	00610051 00630062 00650064 00670066     Q.a.b.c.d.e.f.g.
    78dc:	00690068 006b006a 006d006c 006f006e     h.i.j.k.l.m.n.o.
    78ec:	00710070 00810080 00830082 00850084     p.q.............
    78fc:	00870086 00890088 008b008a 008d008c     ................
    790c:	008f008e 00000090                       ........

00007914 <Port_UnUsedPin>:
    7914:	00000100 00000001 00000000              ............

00007920 <Port_aPinConfigDefault>:
    7920:	00000060 00000100 00000000 00000002     `...............
    7930:	00010001                                ....

00007934 <Port_Config>:
    7934:	00530001 0000786c 00007914 00007920     ..S.lx...y.. y..
	...
    794c:	00007868 00007864 0000783c              hx..dx..<x..

00007958 <Power_Ip_RCM_ConfigPB>:
	...

00007960 <Power_Ip_PMC_ConfigPB>:
    7960:	00000000                                ....

00007964 <Power_Ip_SMC_ConfigPB>:
    7964:	00000000                                ....

00007968 <Power_Ip_aModeConfigPB>:
	...

00007974 <Power_Ip_HwIPsConfigPB>:
    7974:	00007958 00007960 00007964              Xy..`y..dy..

00007980 <__INIT_TABLE>:
    7980:	00000002 	.word	0x00000002
    7984:	1fff8b10 	.word	0x1fff8b10
    7988:	000079a8 	.word	0x000079a8
    798c:	000079bc 	.word	0x000079bc
    7990:	1fff8800 	.word	0x1fff8800
    7994:	00000000 	.word	0x00000000
    7998:	00000310 	.word	0x00000310

0000799c <__ZERO_TABLE>:
    799c:	00000001 	.word	0x00000001
    79a0:	1fff8b30 	.word	0x1fff8b30
    79a4:	1fff8df0 	.word	0x1fff8df0
