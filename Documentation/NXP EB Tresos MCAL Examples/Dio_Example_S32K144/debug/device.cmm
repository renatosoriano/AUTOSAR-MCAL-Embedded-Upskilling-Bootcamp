;  (c) Copyright 2021 NXP
;
;  NXP Confidential. This software is owned or controlled by NXP and may only be used strictly
;  in accordance with the applicable license terms.  By expressly accepting
;  such terms or by downloading, installing, activating and/or otherwise using
;  the software, you are agreeing that you have read, and that you agree to
;  comply with and are bound by, such license terms.  If you do not agree to
;  be bound by the applicable license terms, then you may not retain,
;  install, activate or otherwise use the software.
;
;  This file contains sample code only. It is not part of the production code deliverables.
;========================================================================
LOCAL &load_to
LOCAL &elf_file
LOCAL &load_params
LOCAL &core_no
LOCAL &multicore
LOCAL &core_list
LOCAL &rchw
LOCAL &derivative_cpu
LOCAL &PFlashSize &DFlashSize

ENTRY &load_to &elf_file &load_params &core_no &multicore &core_list &custom_param

&optimizeFLSMODE=0
&optimizeSECTORS=0
&optimizeRAM=0
&optimizePLL=0

;=========================================================================
; Variables settings  
;=========================================================================

;=========================================================================
; System settings  
;=========================================================================

; Check if the chip is secured(no flash access allowed) and if so, attempt to unsecure it by triggering a mass erase.
; MDM-AP Status[2] = System security
WinCLEAR
area
SYStem.Down
ON.ERROR.continue    ;Disable error handler temporarily
Break.RESet
SYStem.JtagClock 1Mhz
SYS.CPU S32K144
;small delay need to add to wait chip stable after replay on off on station
wait 30ms
sys.up
PRINT "MDM-AP Status Register is 0x" Data.Long(EDBG:0x40000100)
IF ((Data.Long(EDBG:0x40000100)&0x00000004)==0x00000004)
(
    ;The chip is secured, attempt to unsecure it.
    PRINT "The chip is secured, attempting to unsecure it by triggering a mass erase."
    GOSUB FlashUnsecureErase

    ; Check if the operation has been successful.
    Break.RESet
    sys.up
    PRINT "MDM-AP Status Register is 0x" Data.Long(EDBG:0x40000100)
    IF ((Data.Long(EDBG:0x40000100)&0x00000004)==0x00000004)
    (
        ;Either there was an error during MDM-AP register read or the chip is still secured.
        PRINT "Either there was an error during MDM-AP register read(ex:target in reset) or the chip is still secured."
        ;Attempt to Sys.up, to check if target is still in reset.
        PRINT "Attempt to Sys.up, to check if target is still in reset."
        system.reset
        SYStem.Option TRST off
        SYStem.Option ResBreak on
        SYStem.Option WaitReset ON
        SYS.CPU S32K144
        SYStem.JtagClock 4MHz
        Break.RESet
        sys.up
        ; Check if the operation has been successful.
        PRINT "MDM-AP Status Register is 0x" Data.Long(EDBG:0x40000100)
        IF ((Data.Long(EDBG:0x40000100)&0x00000004)==0x00000004)
        (            
            ;The chip is still secured, stop execution and wait for debug.
            ;PRINT "The chip is still secured, stop execution and wait for debug"
            PRINT %ERROR "The chip is still secured/or unable to get chip status"
            ENDDO
        ) 
        ELSE
        (
            PRINT "Chip is now unsecured."
        )        
    )
    ELSE
    (
        PRINT "Chip is now unsecured."
    )
) 
on.ERROR.DEFault    ;Enable the error handler 

;cpu settings - cortexm4, S32K144
system.reset
SYStem.Option TRST off
SYStem.Option ResBreak on
SYStem.Option WaitReset ON
SYS.CPU S32K144
SYStem.JtagClock 4MHz
sys.up

; Disable Bootrom
;GOSUB DisableBootrom
;configuring ram for ensure ram do not get lock up because of ram retention
per.set ANC:0x40048004 %LONG  0x00300000
; Disable watchdog
GOSUB DisableWatchdog


    IF CPUIS("S32K142")
    (
        &derivative_cpu="S32K142"
    )
    ELSE IF CPUIS("S32K144")
    (
        &derivative_cpu="S32K144"
    )
    ELSE IF CPUIS("S32K146")
    (
        &derivative_cpu="S32K146"
    )
    ELSE IF CPUIS("S32K148")
    (
        &derivative_cpu="S32K148"
    )
     ELSE
    (
        PRINT %ERROR "FLASH size of CPU type is not supported by the script"
        ENDDO
    )


;=========================================================================
; set-up system clock initialization
;=========================================================================
if &optimizePLL==1
(
   print "Starting PLL:"

;/* FIRC Configuration */
;SCG.FIRCDIV.R=0x010101u;   /* SCG_FIRCDIV: FIRCDIV3=1, FIRCDIV2=1, FIRCDIV1=1 */
  per.set ANC:0x40064304 %LONG  0x010101
;SCG.FIRCCFG.R=0x00;        /* SCG_FIRCCFG: RANGE=0 */
  per.set ANC:0x40064308 %LONG  0x0
;while(SCG.FIRCCSR.R & 0x00800000u);
   wait (Data.Long(ANC:0x40064300)&0x000800000)==0
;SCG.FIRCCSR.R=0x00000001u;   /* SCG_FIRCCSR: FIRCEN=1 */
  per.set ANC:0x40064300 %LONG  0x1
;while(!(SCG.FIRCCSR.R & 0x01000000));
   wait (Data.Long(ANC:0x40064300)&0x01000000)==0x01000000

;  /* SIRC Configuration */
;SCG.SIRCDIV.R=0x10101u;   /* SCG_SIRCDIV: SIRCDIV3=1, SIRCDIV2=1, SIRCDIV1=1 */
   per.set ANC:0x40064204 %LONG  0x010101
;SCG.SIRCCFG.R=0x01;       /* SCG_SIRCCFG: RANGE=1 */
   per.set ANC:0x40064208 %LONG  0x1
;while(SCG.SIRCCSR.R & 0x00800000u);
   wait (Data.Long(ANC:0x40064200)&0x000800000)==0
;SCG.SIRCCSR.R=0x1u;       /* SCG_SIRCCSR: SIRCEN=1 */
   per.set ANC:0x40064200 %LONG  0x1
;while(!(SCG.SIRCCSR.R & 0x01000000u));
   wait (Data.Long(ANC:0x40064200)&0x01000000)==0x01000000

;  /* SOSC Configuration */ 
;SCG.SOSCDIV.R = 0x00010101u;  /* SCG_SOSCDIV: SOSCDIV3=1, SOSCDIV2=1, SOSCDIV1=1 */  
   per.set ANC:0x40064104 %LONG  0x010101
;SCG.SOSCCFG.R = 0x00000024u;  /* SCG_SOSCCFG: RANGE=2, EREFS=1 */
   per.set ANC:0x40064108 %LONG  0x24
;while(SCG.SOSCCSR.R & 0x00800000u);
   wait (Data.Long(ANC:0x40064100)&0x00800000)==0
;SCG.SOSCCSR.R= 0x5u;           /* SCG_SOSCCSR: SOSCLPEN=1, SOSCEN=1 */
   per.set ANC:0x40064100 %LONG  0x5
;while(!(SCG.SOSCCSR.R & 0x01000000u));
  wait (Data.Long(ANC:0x40064100)&0x01000000)==0x01000000

;  /* SPLL Configuration 80MHz */ 
;SCG.SPLLDIV.R = 0x10101u;    
   per.set ANC:0x40064604 %LONG  0x010101  
;SCG.SPLLCFG.R = 0x40000u;     /* SCG_SPLLCFG: MULT=4, PREDIV=0, SOURCE=0 */
   per.set ANC:0x40064608 %LONG  0x40000
;while(SCG.SPLLCSR.R & 0x00800000u);
   wait (Data.Long(ANC:0x40064600)&0x00800000)==0
;SCG.SPLLCSR.R=0x01;           /* SCG_SPLLCSR: SPLLEN=1 */
   per.set ANC:0x40064600 %LONG  0x1
;while(!(SCG.SPLLCSR.R & 0x01000000u));
  wait (Data.Long(ANC:0x40064600)&0x01000000)==0x01000000
  
;SCG.RCCR.R=0x06000013U;  /* RUN Mode Configuration */
    per.set ANC:0x40064014 %LONG  0x0600001
;SCG.VCCR.R=0x02000002U;  /* VLPR Mode Configuration */
    per.set ANC:0x40064018 %LONG  0x02000002
;SCG.HCCR.R=0x06000013U;  /* HSPR Mode Configuration */
    per.set ANC:0x4006401C %LONG  0x06000013

    
; set JTAG clock to 10 MHz
   SYStem.BdmClock 10MHz
)

;=========================================================================
; RAM initialization
;=========================================================================
if &optimizeRAM==1
(
    print "Starting RAM initialization:"
    ; Initialize internal SRAM (32KB)
    IF CPUIS("S32K142")
    (
        Data.Set A:0X1FFFC000--0X20002FFF  %Quad 0
    )
    ELSE IF CPUIS("S32K144")
    (
        Data.Set A:0X1FFF8000--0X20005FFF  %Quad 0
    )
    ELSE IF CPUIS("S32K146")
    (
        Data.Set A:0X1FFF0000--0X2000F7FF  %Quad 0
    )
    ELSE IF CPUIS("S32K148")
    (
        Data.Set A:0X1FFE0000--0X2001EFFF  %Quad 0
    )
     ELSE
    (
        PRINT %ERROR "FLASH size of CPU type is not supported by the script"
        ENDDO
    )
)
else
(
    IF CPUIS("S32K142")
    (
        Data.Set A:0X1FFFC000--0X20002FFF  %Quad 0
    )
    ELSE IF CPUIS("S32K144")
    (
        Data.Set A:0X1FFF8000--0X20005FFF  %Quad 0
    )
    ELSE IF CPUIS("S32K146")
    (
        Data.Set A:0X1FFF0000--0X2000F7FF  %Quad 0
    )
    ELSE IF CPUIS("S32K148")
    (
        Data.Set A:0X1FFE0000--0X2001EFFF  %Quad 0
    )
    ELSE
    (
        PRINT %ERROR "FLASH size of CPU type is not supported by the script"
        ENDDO
    )
)

IF "&load_to"=="flash"
(
;=========================================================================
; Flash declaration 
;=========================================================================
print "Starting FLASH sector creation:"
  FLASH.RESet

  PARAMETERS &DualPort
  PRIVATE &FlashDriver &PFlashSize &FlexNVMSize &FlexRAMSize &DFlashSize &EepromSize &PFlashAsDFlash &PFlashSectorSize &DFlashSectorSize

  &PFlashAsDFlash=0x00
  &DFlashSize=0x00
  &EepromSize=0x00
  IF CPUIS("S32K116")
  (
    &FlashDriver="s32k_2k2k.bin"
    &PFlashSize=0x20000
    &FlexNVMSize=0x8000
    &FlexRAMSize=0x800
    &PFlashSectorSize=0x800
    &DFlashSectorSize=0x800
  )
  ELSE IF CPUIS("S32K118")
  (
    &FlashDriver="s32k_2k2k.bin"
    &PFlashSize=0x40000
    &FlexNVMSize=0x8000
    &FlexRAMSize=0x800
    &PFlashSectorSize=0x800
    &DFlashSectorSize=0x800
  )
  ELSE IF CPUIS("S32K142")
  (
    &FlashDriver="s32k_2k2k.bin"
    &PFlashSize=0x40000
    &FlexNVMSize=0x10000
    &FlexRAMSize=0x1000
    &PFlashSectorSize=0x800
    &DFlashSectorSize=0x800
  )
  ELSE IF CPUIS("S32K144*")       ; S32K144 and S32K144W
  (
    &FlashDriver="s32k_4k2k.bin"
    &PFlashSize=0x80000
    &FlexNVMSize=0x10000
    &FlexRAMSize=0x1000
    &PFlashSectorSize=0x1000
    &DFlashSectorSize=0x800
  )
  ELSE IF CPUIS("S32K146")
  (
    &FlashDriver="s32k_4k2k.bin"
    &PFlashSize=0x100000
    &FlexNVMSize=0x10000
    &FlexRAMSize=0x1000
    &PFlashSectorSize=0x1000
    &DFlashSectorSize=0x800
  )
  ELSE IF CPUIS("S32K148")
  (
    &FlashDriver="s32k_4k4k.bin"
    &PFlashSize=0x180000
    &PFlashAsDFlash=0x70000
    &FlexNVMSize=0x10000
    &FlexRAMSize=0x1000
    &PFlashSectorSize=0x1000
    &DFlashSectorSize=0x1000
  )
  ELSE
  (
    PRINT %ERROR "FLASH size of CPU type is not supported by the script"
    ENDDO
  )

  GOSUB getDFlashEepromSize "&PFlashSize" "&PFlashAsDFlash" "&FlexNVMSize" "&FlexRAMSize"
  RETURNVALUES &DFlashSize &EepromSize

  FLASH.Create 1. 0x00000000++(&PFlashSize-0x1) &PFlashSectorSize TARGET Quad /CENSORSHIP 0x400++0xf

  IF &DFlashSize>0x0
    FLASH.Create 2. 0x10000000++(&DFlashSize-0x1) &DFlashSectorSize TARGET Quad

  IF &EepromSize>0x0
    FLASH.Create 3. 0x14000000++(&EepromSize-0x1) &EepromSize TARGET Long

  IF "&DualPort"=="0"
    FLASH.TARGET 0x20000000 0x20001000 0x1000 ~~/demo/arm/flash/quad/&FlashDriver
  ELSE
    FLASH.TARGET 0x20000000 EAHB:0x20001000 0x1000 ~~/demo/arm/flash/quad/&FlashDriver /DualPort

)

;========================================================================
; Flash programming example
;
; Flash programming speed is about three times faster when memory class E:
; is used for data buffer (DUALPORT memory access). For DUALPORT access it
; is required to setup MemAccess NEXUS for both, NEXUS and JTAG debugger. 

; put the core in RUN mode (if the core is in HSRUN flash commands do not work) 
data.set 0x4007e00c %long 0x0

; disable CACHES
data.set 0xE0082000 %Long 0x0

;sometime chip accidently go into user mode after reset (which can be source from sys.up or simple reset from SWT MCU)
;break to stop execution on flash then set CONTROL register to 0 to ensure flash algorithm can work normally
break
Register.Set CONTROL 0

IF "&load_to"=="flash"
(
   IF &optimizeFLSMODE==1
   (
      FLASH.Reprogram ALL 
      Data.Load.Elf &elf_file /GLOBTYPES
      FLASH.Reprogram OFF

   )
   ELSE
   (
      ; Read the LAST word of FLASH Config area
      &FLASH_CFG_W4=data.long(ANC:0x40C)
      &FLASH_CFG_W4_DISABLEROM=(&FLASH_CFG_W4&0x0000FFFF)
      ;Check if ROM & Secure Boot are disabled
      
      IF (&FLASH_CFG_W4_DISABLEROM==0x7FFE)
      (
        FLASH.Reprogram ALL /ERASE
        Data.Load.Elf &elf_file /GLOBTYPES
        FLASH.Reprogram OFF
      )
      ELSE
      (
        ; re-write the Flash Config area 0x400 as specified in the elf.
        FLASH.AUTO.ALL /CENSORSHIP
        Data.Load.Elf &elf_file /GLOBTYPES
        FLASH.AUTO.OFF
      )
    )  
)
ELSE IF "&load_to"=="ERASE_ONLY"
(
   flash.unlock all
   flash.auto off
   flash.ERASE ALL	
   ENDDO
)
TrOnchip.Set CORERESET OFF


system.reset
SYStem.Option TRST off
SYStem.Option ResBreak on
SYStem.Option WaitReset ON
SYStem.CPU &derivative_cpu
SYStem.JtagClock 4MHz
sys.up

; Disable watchdog
GOSUB DisableWatchdog

;load program (if FLASH selected than load only debug symbols)
IF "&load_to"=="flash"
(
   Data.Load.Elf &elf_file /GLOBTYPES /NOCODE
)
ELSE
(
   ; initialize internam SRAM
   Data.Load.Elf &elf_file /GLOBTYPES
)

; Force display mode to Thumb. On GHS compiler, because of wrong debug information, some sections are interpreted as ARM mode,
; thus displaying incorrect compiler options when using ASM mode and sometimes causing Hardfaults because of incorrect branches
; when Stepping in C mode.
SYStem.Option DisMode THUMB

WinCLEAR
WinPOS 84.125 0.0 63. 41. 0. 0. W001
Per , /SPOTLIGHT 

WinPOS 84.25 45.0 63. 12. 0. 0. W000
Register /SPOTLIGHT



ENDDO

DisableBootrom:
  Data.Set SD:0x4007F010 %LE %Long 0x6
  Data.Set SD:0x4007F014 %LE %Long 0x0
  RETURN
  
DisableWatchdog:
  LOCAL &tmp1 &tmp2

  IF CPUIS("S32K144")
    (
        D.S SD:0x20000000 %BE %Long 0x0
        D.S SD:0x20000004 %BE %Long 0x0
        D.S SD:0x20000008 %BE %Long 0x0
        D.S SD:0x2000000C %BE %Long 0x0
        D.S SD:0x20000010 %BE %Long 0x0
    )  


  &tmp1=Data.Long(ST:0x20000000)
  &tmp2=Data.Long(ST:0x20000004)
  

  ; The watchdog has a restrictive timing. It has to be configured and unlocked within a peripod
  ; of 128 cycles. Therefor the unlock sequence need to be done by a small target program.
  
  Data.Assemble ST:0x20000000  str  r1, [r0]    
  Data.Assemble ,              str  r3, [r2]    
  Data.Assemble ,              str  r5, [r4]
  Data.Assemble ,              bkpt #0
  
  Register.Set PC 0x20000000
  Register.Set SP 0x20001000
  
  Register.Set  r0 0x40052004
  Register.Set  r1 0xD928C520
  Register.Set  r2 0x40052008
  Register.Set  r3 0x0000FFFF
  Register.Set  r4 0x40052000
  Register.Set  r5 0x00002120
  
  Go.direct
  WAIT !RUN()


  RETURN

; Command roughly equivalent with "FLASH.UNSECUREErase"  
FlashUnsecureErase:    
    SYStem.Down
    Break.RESet
    SYStem.JtagClock 1Mhz
    SYStem.Mode.Prepare
    ; Set reset line low, both JTAG lines are connected to the same chip reset line, so toggle them both.
    JTAG.PIN NRESET 0
    JTAG.PIN NTRST 0
    ; Setup mass erase command bit  
    Data.Set EDBG:0x40000104 %Long 0yXXXXxxxxXXXXxxxxXXXXxxxxXXXXxxx1    
    ; wait until mass erase has completed
    WHILE ((Data.Long(EDBG:0x40000100)&0x04)==0x04)||((Data.Long(EDBG:0x40000104)&0x01)==0x01)
    ( 
    )
    WAIT 100ms    
    JTAG.PIN NRESET 1
    JTAG.PIN NTRST 1
    SYStem.Down
    WAIT 100ms

    RETURN
	
getDFlashEepromSize: ;(PFlashSize, FlexNvmSize, &FlexRAMSize)
(
  PARAMETERS &PFlashSize &PFlashAsDFlash &FlexNVMSize &FlexRAMSize
  PRIVATE &DEPART &DFlashSize &EepromSize

  &DEPART=(Data.Long(AD:0x4004804C)>>12.)&0xf
  &DFlashSize=0x0

  IF (&FlexNVMSize==(0x8000))&&(&PFlashSize==(0x20000||0x40000))
  (
    ; 128kB and 256kB configurations with 32kB FlexNVM
    IF (&DEPART==(0x0||0xb||0xf))
      &DFlashSize=0x8000
    ELSE IF (&DEPART==(0x9))
      &DFlashSize=0x2000
    ELSE IF (&DEPART==(0x3||0x8))
      &DFlashSize=0x0
    ELSE
      PRINT "Unknown DFlash Size - DEPART invalid"

    IF (&DFlashSize!=&FlexNVMSize)
      &EepromSize=&FlexRAMSize
    ELSE
      &EepromSize=0x0
  )
  ELSE IF (&FlexNVMSize==(0x10000))&&(&PFlashSize==(0x40000||0x80000||0x100000))
  (
    ; 256KB, 512kB and 1MB configurations with 64kB FlexNVM
    IF (&DEPART==(0x0||0xc||0xf))
      &DFlashSize=0x10000
    ELSE IF (&DEPART==(0x3||0xb))
      &DFlashSize=0x8000
    ELSE IF (&DEPART==(0xa))
      &DFlashSize=0x4000
    ELSE IF (&DEPART==(0x4||0x8))
      &DFlashSize=0x0
    ELSE
      PRINT "Unknown DFlash Size - DEPART invalid"

    IF (&DFlashSize!=&FlexNVMSize)
      &EepromSize=&FlexRAMSize
    ELSE
      &EepromSize=0x0
  )
  ELSE IF (&FlexNVMSize==(0x10000))&&(&PFlashSize==(0x180000))
  (
    ; 2MB configurations - 1.5MB PFlash, 448kB D(P)Flash + 64kB DFlash
    IF (&DEPART==(0x0||0xf))
    (
      &DFlashSize=&PFlashAsDFlash+&FlexNVMSize
      &EepromSize=0x0
    )
    ELSE IF (&DEPART==(0x4))
    (
      &DFlashSize=&PFlashAsDFlash
      &EepromSize=&FlexRAMSize
    )
    ELSE
      PRINT "Unknown DFlash Size - DEPART invalid"
  )
  ELSE
  (
    PRINT "Unknown DFlash Size - Flash Controller unknown"
  )
  RETURN "&DFlashSize" "&EepromSize"
)
